(function () {
  var socket = document.createElement('script')
  var script = document.createElement('script')
  socket.setAttribute('src', 'http://127.0.0.1:3001/socket.io/socket.io.js')
  script.type = 'text/javascript'

  socket.onload = function () {
    document.head.appendChild(script)
  }
  script.text = ['window.socket = io("http://127.0.0.1:3001");',
  'socket.on("bundle", function() {',
  'console.log("livereaload triggered")',
  'window.location.reload();});'].join('\n')
  document.head.appendChild(socket)
}());
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
function bjorklund(slots, pulses){
  var pattern = [],
      count = [],
      remainder = [pulses],
      divisor = slots - pulses,
      level = 0,
      build_pattern = function(lv){
        if( lv == -1 ){ pattern.push(0); }
        else if( lv == -2 ){ pattern.push(1); }
        else{
          for(var x=0; x<count[lv]; x++){
            build_pattern(lv-1);
          }

          if(remainder[lv]){
            build_pattern(lv-2);
          }
        }
      }
  ;

  while(remainder[level] > 1){
    count.push(Math.floor(divisor/remainder[level]));
    remainder.push(divisor%remainder[level]);
    divisor = remainder[level];
    level++;
  }
  count.push(divisor);

  build_pattern(level);

  return pattern.reverse();
}


module.exports = function(m, k){
  if(m > k) return bjorklund(m, k);
  else return bjorklund(k, m);
};

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":5,"get-intrinsic":90}],5:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":12,"get-intrinsic":90}],6:[function(require,module,exports){
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.chroma = factory());
})(this, (function () { 'use strict';

    var limit$2 = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var limit$1 = limit$2;

    var clip_rgb$3 = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit$1(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit$1(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type$p = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var type$o = type$p;

    var unpack$B = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type$o(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var type$n = type$p;

    var last$4 = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI$2 = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb$3,
    	limit: limit$2,
    	type: type$p,
    	unpack: unpack$B,
    	last: last$4,
    	PI: PI$2,
    	TWOPI: PI$2*2,
    	PITHIRD: PI$2/3,
    	DEG2RAD: PI$2 / 180,
    	RAD2DEG: 180 / PI$2
    };

    var input$h = {
    	format: {},
    	autodetect: []
    };

    var last$3 = utils.last;
    var clip_rgb$2 = utils.clip_rgb;
    var type$m = utils.type;
    var _input = input$h;

    var Color$D = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$m(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$3(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
                _input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (_input.format[mode]) {
            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$2(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color$D.prototype.toString = function toString () {
        if (type$m(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color$D;

    var chroma$k = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
    };

    chroma$k.Color = Color_1;
    chroma$k.version = '2.4.2';

    var chroma_1 = chroma$k;

    var unpack$A = utils.unpack;
    var max$2 = Math.max;

    var rgb2cmyk$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$A(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r,max$2(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk$1;

    var unpack$z = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$z(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils.unpack;
    var type$l = utils.type;

    var rgb2cmyk = rgb2cmyk_1;

    Color$C.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
    };

    chroma$j.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
    };

    input$g.format.cmyk = cmyk2rgb_1;

    input$g.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$y(args, 'cmyk');
            if (type$l(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$x = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$x(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css$1;

    var unpack$w = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$3 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$w(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl$3;

    var unpack$v = utils.unpack;
    var last$1 = utils.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$v(args, 'rgba');
        var mode = last$1(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css$1;

    var unpack$u = utils.unpack;
    var round$5 = Math.round;

    var hsl2rgb$1 = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$u(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb$1;

    var hsl2rgb = hsl2rgb_1;
    var input$f = input$h;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input$f.format.named) {
            try {
                return input$f.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb$1.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb$1;

    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils.type;

    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;

    Color$B.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma$i.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
    };

    input$e.format.css = css2rgb;

    input$e.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils.unpack;

    input$d.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$t(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma$h.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
    };

    Color$A.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$s = utils.unpack;

    var rgb2hcg$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$s(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg$1;

    var unpack$r = utils.unpack;
    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$r(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$q = utils.unpack;
    var type$j = utils.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;

    var rgb2hcg = rgb2hcg_1;

    Color$z.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
    };

    chroma$g.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
    };

    input$c.format.hcg = hcg2rgb_1;

    input$c.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$q(args, 'hcg');
            if (type$j(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$p = utils.unpack;
    var last = utils.last;
    var round$3 = Math.round;

    var rgb2hex$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$p(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex$2;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb$1;

    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils.type;
    var input$b = input$h;

    var rgb2hex$1 = rgb2hex_1;

    Color$y.prototype.hex = function(mode) {
        return rgb2hex$1(this._rgb, mode);
    };

    chroma$f.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
    };

    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
                return 'hex';
            }
        }
    });

    var unpack$o = utils.unpack;
    var TWOPI$2 = utils.TWOPI;
    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi$1;

    var unpack$n = utils.unpack;
    var limit = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$n(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit(i*r*3);
        g = limit(i*g*3);
        b = limit(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$m = utils.unpack;
    var type$h = utils.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;

    var rgb2hsi = rgb2hsi_1;

    Color$x.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
    };

    chroma$e.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
    };

    input$a.format.hsi = hsi2rgb_1;

    input$a.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'hsi');
            if (type$h(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$l = utils.unpack;
    var type$g = utils.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;

    var rgb2hsl$1 = rgb2hsl_1;

    Color$w.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
    };

    chroma$d.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
    };

    input$9.format.hsl = hsl2rgb_1;

    input$9.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$l(args, 'hsl');
            if (type$g(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$k = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$k(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv$1 = rgb2hsl;

    var unpack$j = utils.unpack;
    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$j(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$i = utils.unpack;
    var type$f = utils.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;

    var rgb2hsv = rgb2hsv$1;

    Color$v.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma$c.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
    };

    input$8.format.hsv = hsv2rgb_1;

    input$8.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$i(args, 'hsv');
            if (type$f(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils.unpack;
    var pow$a = Math.pow;

    var rgb2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$h(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$a((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab$2;

    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils.unpack;
    var pow$9 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$g(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
    };

    var lab2rgb_1 = lab2rgb$1;

    var unpack$f = utils.unpack;
    var type$e = utils.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;

    var rgb2lab$1 = rgb2lab_1;

    Color$u.prototype.lab = function() {
        return rgb2lab$1(this._rgb);
    };

    chroma$b.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
    };

    input$7.format.lab = lab2rgb_1;

    input$7.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'lab');
            if (type$e(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$e = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$e(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch$2;

    var unpack$d = utils.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;

    var rgb2lch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch$1;

    var unpack$c = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$c(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c]
    };

    var lch2lab_1 = lch2lab$2;

    var unpack$b = utils.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;

    var lch2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$b(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab$1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb$1;

    var unpack$a = utils.unpack;
    var lch2rgb = lch2rgb_1;

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$a(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$9 = utils.unpack;
    var type$d = utils.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;

    var rgb2lch = rgb2lch_1;

    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

    chroma$a.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
    };
    chroma$a.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
    };

    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$9(args, m);
            if (type$d(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11$1 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11$1;

    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils.type;

    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;

    Color$s.prototype.name = function() {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input$5.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: '+name);
    };

    input$5.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$8 = utils.unpack;

    var rgb2num$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$8(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num$1;

    var type$b = utils.type;

    var num2rgb = function (num) {
        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils.type;

    var rgb2num = rgb2num_1;

    Color$r.prototype.num = function() {
        return rgb2num(this._rgb);
    };

    chroma$9.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
    };

    input$4.format.num = num2rgb_1;

    input$4.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils.unpack;
    var type$9 = utils.type;
    var round$1 = Math.round;

    Color$q.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$1);
    };

    Color$q.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma$8.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
    };

    input$3.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$7(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input$3.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$7(args, 'rgba');
            if (type$9(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb$1;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils.unpack;
    var round = Math.round;

    var rgb2temperature$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$6(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    var rgb2temperature_1 = rgb2temperature$1;

    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;

    var rgb2temperature = rgb2temperature_1;

    Color$p.prototype.temp =
    Color$p.prototype.kelvin =
    Color$p.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
    };

    chroma$7.temp =
    chroma$7.kelvin =
    chroma$7.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
    };

    input$2.format.temp =
    input$2.format.kelvin =
    input$2.format.temperature = temperature2rgb_1;

    var unpack$5 = utils.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    var rgb2oklab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack$5(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    var rgb2oklab_1 = rgb2oklab$2;

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
    }

    var unpack$4 = utils.unpack;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$4(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    var oklab2rgb_1 = oklab2rgb$1;

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var unpack$3 = utils.unpack;
    var type$8 = utils.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;

    var rgb2oklab$1 = rgb2oklab_1;

    Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
    };

    chroma$6.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
    };

    input$1.format.oklab = oklab2rgb_1;

    input$1.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'oklab');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var unpack$2 = utils.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;

    var rgb2oklch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$2(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    var rgb2oklch_1 = rgb2oklch$1;

    var unpack$1 = utils.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$1(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var oklch2rgb_1 = oklch2rgb;

    var unpack = utils.unpack;
    var type$7 = utils.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;

    var rgb2oklch = rgb2oklch_1;

    Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma$5.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb_1;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    var Color$m = Color_1;
    var type$6 = utils.type;

    Color$m.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$6(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    var Color$l = Color_1;

    Color$l.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;

    Color$k.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
    };

    Color$k.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;

    var Color$j = Color_1;

    Color$j.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$i = Color_1;
    var type$5 = utils.type;
    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color$i.prototype.luminance = function(lum) {
        if (lum !== undefined && type$5(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
            return new Color$i(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
    };

    var interpolator$1 = {};

    var Color$h = Color_1;
    var type$4 = utils.type;
    var interpolator = interpolator$1;

    var mix$1 = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    var Color$g = Color_1;
    var mix = mix$1;

    Color$g.prototype.mix =
    Color$g.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    var Color$f = Color_1;

    Color$f.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;

    Color$e.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += LAB_CONSTANTS.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
    };

    Color$e.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var Color$d = Color_1;
    var type$3 = utils.type;

    Color$d.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type$3(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type$3(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color$d(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$c = Color_1;

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.rgb = rgb;

    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.lrgb = lrgb;

    var Color$a = Color_1;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator$1.lab = lab;

    var Color$9 = Color_1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
    };

    var interpolate_hsx$5 = _hsx;

    var lch = function (col1, col2, f) {
    	return interpolate_hsx$5(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;

    var Color$8 = Color_1;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color$8(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator$1.num = num;

    var interpolate_hsx$4 = _hsx;

    var hcg = function (col1, col2, f) {
    	return interpolate_hsx$4(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator$1.hcg = hcg;

    var interpolate_hsx$3 = _hsx;

    var hsi = function (col1, col2, f) {
    	return interpolate_hsx$3(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator$1.hsi = hsi;

    var interpolate_hsx$2 = _hsx;

    var hsl = function (col1, col2, f) {
    	return interpolate_hsx$2(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator$1.hsl = hsl;

    var interpolate_hsx$1 = _hsx;

    var hsv = function (col1, col2, f) {
    	return interpolate_hsx$1(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator$1.hsv = hsv;

    var Color$7 = Color_1;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    interpolator$1.oklab = oklab;

    var interpolate_hsx = _hsx;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    interpolator$1.oklch = oklch;

    var Color$6 = Color_1;
    var clip_rgb$1 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode, weights) {
        if ( mode === void 0 ) mode='lrgb';
        if ( weights === void 0 ) weights=null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k = l / weights.reduce(function(a, b) { return a + b; });
        weights.forEach(function (w,i) { weights[i] *= k; });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color$6(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c,ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci+1];
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci+1];
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A) * weights[ci+1];
                        dy += sin$2(A) * weights[ci+1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci+1];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0,0,0,0];
        for (var i=0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color$6(clip_rgb$1(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze

    var chroma$4 = chroma_1;
    var type$2 = utils.type;

    var pow$3 = Math.pow;

    var scale$2 = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma$4('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
                chroma$4.brewer[colors.toLowerCase()]) {
                colors = chroma$4.brewer[colors.toLowerCase()];
            }
            if (type$2(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma$4(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$3(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$2(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$2(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$2(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma$4.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma$4.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i+1]) { i++; }
                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
                            return out;
                        };
                    }

                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$2(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma$4[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma$4(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab
    var Color$5 = Color_1;

    var scale$1 = scale$2;

    // nth row of the pascal triangle
    var binom_row = function(n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color$5(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
                return new Color$5(lab, 'lab');
            };
        } else {
            throw new RangeError("No point in running bezier with only one color.")
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale$1(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */

    var chroma$3 = chroma_1;

    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$1 = utils.type;
    var clip_rgb = utils.clip_rgb;
    var TWOPI = utils.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;

    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$1(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI * (((start+120)/360) + (rotations * fract));
            var l = pow$2(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$1(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$1(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma$2.scale(f); };

        f.hue(hue);

        return f;
    };

    var Color$4 = Color_1;
    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, 'hex');
    };

    var type = type$p;
    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs$1(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var Color$3 = Color_1;


    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color$3(a);
        b = new Color$3(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var Color$2 = Color_1;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    var deltaE = function(a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl=1;
        if ( Kc === void 0 ) Kc=1;
        if ( Kh === void 0 ) Kh=1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color$2(a);
        b = new Color$2(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2)/2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2)/2;
        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
        var a1p = a1*(1+G);
        var a2p = a2*(1+G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p)/2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;    
        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045*avgCp;
        var sh = 1 + 0.015*avgCp*T;
        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
        return max(0, min(100, result));
    };

    var Color$1 = Color_1;

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color$1(a);
        b = new Color$1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var Color = Color_1;

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:
    var chroma$1 = chroma_1;

    var scale = scale$2;

    var scales = {
    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    var chroma = chroma_1;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors

















    // operators --> modify existing Colors










    // interpolators












    // generators -- > create new colors
    chroma.average = average;
    chroma.bezier = bezier_1;
    chroma.blend = blend_1;
    chroma.cubehelix = cubehelix;
    chroma.mix = chroma.interpolate = mix$1;
    chroma.random = random_1;
    chroma.scale = scale$2;

    // other utility methods
    chroma.analyze = analyze_1.analyze;
    chroma.contrast = contrast;
    chroma.deltaE = deltaE;
    chroma.distance = distance;
    chroma.limits = analyze_1.limits;
    chroma.valid = valid;

    // scale
    chroma.scales = scales;

    // colors
    chroma.colors = w3cx11_1;
    chroma.brewer = colorbrewer_1;

    var chroma_js = chroma;

    return chroma_js;

}));

},{}],7:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":90}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],9:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],10:[function(require,module,exports){
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = {
    "s": 1,
    "n": 0,
    "d": 1
  };

  function assign(n, s) {

    if (isNaN(n = parseInt(n, 10))) {
      throw Fraction['InvalidParameter'];
    }
    return n * s;
  }

  // Creates a new Fraction internally without the need of the bulky constructor
  function newFraction(n, d) {

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    var f = Object.create(Fraction.prototype);
    f["s"] = n < 0 ? -1 : 1;

    n = n < 0 ? -n : n;

    var a = gcd(n, d);

    f["n"] = n / a;
    f["d"] = d / a;
    return f;
  }

  function factorize(num) {

    var factors = {};

    var n = num;
    var i = 2;
    var s = 4;

    while (s <= n) {

      while (n % i === 0) {
        n/= i;
        factors[i] = (factors[i] || 0) + 1;
      }
      s+= 1 + 2 * i++;
    }

    if (n !== num) {
      if (n > 1)
        factors[n] = (factors[n] || 0) + 1;
    } else {
      factors[num] = (factors[num] || 0) + 1;
    }
    return factors;
  }

  var parse = function(p1, p2) {

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = p1;
      d = p2;
      s = n * d;

      if (n % 1 !== 0 || d % 1 !== 0) {
        throw Fraction['NonIntegerParameter'];
      }

    } else
      switch (typeof p1) {

        case "object":
          {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n*= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw Fraction['InvalidParameter'];
            }
            s = n * d;
            break;
          }
        case "number":
          {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }

            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1/= z;
              }

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) {
                M = (A + C) / (B + D);

                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;

                } else {

                  if (p1 > M) {
                    A+= C;
                    B+= D;
                  } else {
                    C+= A;
                    D+= B;
                  }

                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n*= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
        case "string":
          {
            B = p1.match(/\d+|./g);

            if (B === null)
              throw Fraction['InvalidParameter'];

            if (B[A] === '-') {// Check for minus sign at the beginning
              s = -1;
              A++;
            } else if (B[A] === '+') {// Check for plus sign at the beginning
              A++;
            }

            if (B.length === A + 1) { // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

              if (B[A] !== '.') { // Handle 0.5 and .5
                v = assign(B[A++], s);
              }
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A+= 3;
              }

            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A+= 3;
            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A+= 5;
            }

            if (B.length <= A) { // Check for more tokens on the stack
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
            }

            /* Fall through on error */
          }
        default:
          throw Fraction['InvalidParameter'];
      }

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
  };

  function modpow(b, e, m) {

    var r = 1;
    for (; e > 0; b = (b * b) % m, e >>= 1) {

      if (e & 1) {
        r = (r * b) % m;
      }
    }
    return r;
  }


  function cycleLen(n, d) {

    for (; d % 2 === 0;
      d/= 2) {
    }

    for (; d % 5 === 0;
      d/= 5) {
    }

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    var rem = 10 % d;
    var t = 1;

    for (; rem !== 1; t++) {
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
    }
    return t;
  }


  function cycleStart(n, d, len) {

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
    }
    return 0;
  }

  function gcd(a, b) {

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) {
      a%= b;
      if (!a)
        return b;
      b%= a;
      if (!b)
        return a;
    }
  };

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    parse(a, b);

    if (this instanceof Fraction) {
      a = gcd(P["d"], P["n"]); // Abuse variable a
      this["s"] = P["s"];
      this["n"] = P["n"] / a;
      this["d"] = P["d"] / a;
    } else {
      return newFraction(P['s'] * P['n'], P['d']);
    }
  }

  Fraction['DivisionByZero'] = new Error("Division by Zero");
  Fraction['InvalidParameter'] = new Error("Invalid argument");
  Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");

  Fraction.prototype = {

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() {

      return newFraction(this["n"], this["d"]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() {

      return newFraction(-this["s"] * this["n"], this["d"]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/
    "add": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["d"],
        this["d"] * P["n"]
      );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() {
      return newFraction(this['s'] * this['n'], this['d']);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return new Fraction(NaN);
      }

      if (a === undefined) {
        return newFraction(this["s"] * this["n"] % this["d"], 1);
      }

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) {
        throw Fraction['DivisionByZero'];
      }

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return newFraction(
        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
        P["d"] * this["d"]
      );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) {
        return newFraction(0, 1);
      }
      return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() {

      return newFraction(this["s"] * this["d"], this["n"]);
    },

    /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(a, b) {

      parse(a, b);

      // Trivial case when exp is an integer

      if (P['d'] === 1) {

        if (P['s'] < 0) {
          return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
        } else {
          return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
        }
      }

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
      if (this['s'] < 0) return null;

      // Now prime factor n and d
      var N = factorize(this['n']);
      var D = factorize(this['d']);

      // Exponentiate and take root for n and d individually
      var n = 1;
      var d = 1;
      for (var k in N) {
        if (k === '1') continue;
        if (k === '0') {
          n = 0;
          break;
        }
        N[k]*= P['n'];

        if (N[k] % P['d'] === 0) {
          N[k]/= P['d'];
        } else return null;
        n*= Math.pow(k, N[k]);
      }

      for (var k in D) {
        if (k === '1') continue;
        D[k]*= P['n'];

        if (D[k] % P['d'] === 0) {
          D[k]/= P['d'];
        } else return null;
        d*= Math.pow(k, D[k]);
      }

      if (P['s'] < 0) {
        return newFraction(d, n);
      }
      return newFraction(n, d);
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) {

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) {

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
    },

    "simplify": function(eps) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return this;
      }

      eps = eps || 0.001;

      var thisABS = this['abs']();
      var cont = thisABS['toContinued']();

      for (var i = 1; i < cont.length; i++) {

        var s = newFraction(cont[i - 1], 1);
        for (var k = i - 2; k >= 0; k--) {
          s = s['inverse']()['add'](cont[k]);
        }

        if (s['sub'](thisABS)['abs']().valueOf() < eps) {
          return s['mul'](this['s']);
        }
      }
      return this;
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) {

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() {

      return this["s"] * this["n"] / this["d"];
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/
    'toFraction': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          str+= " ";
          n%= d;
        }

        str+= n;
        str+= '/';
        str+= d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/
    'toLatex': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          n%= d;
        }

        str+= "\\frac{";
        str+= n;
        str+= '}{';
        str+= d;
        str+= '}';
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() {

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      if (isNaN(a) || isNaN(b)) {
        return res;
      }

      do {
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
      } while (a !== 1);

      return res;
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function(dec) {

      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) {
        return "NaN";
      }

      dec = dec || 15; // 15 = decimal places when no repetation

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var str = this['s'] < 0 ? "-" : "";

      str+= N / D | 0;

      N%= D;
      N*= 10;

      if (N)
        str+= ".";

      if (cycLen) {

        for (var i = cycOff; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= "(";
        for (var i = cycLen; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= ")";
      } else {
        for (var i = dec; N && i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
      }
      return str;
    }
  };

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Fraction;
    });
  } else if (typeof exports === "object") {
    Object.defineProperty(Fraction, "__esModule", { 'value': true });
    Fraction['default'] = Fraction;
    Fraction['Fraction'] = Fraction;
    module['exports'] = Fraction;
  } else {
    root['Fraction'] = Fraction;
  }

})(this);

},{}],11:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],12:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":11}],13:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'abs',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.abs' : Math.abs })

      out = `${ref}abs( ${inputs[0]} )`

    } else {
      out = Math.abs( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let abs = Object.create( proto )

  abs.inputs = [ x ]

  return abs
}

},{"./gen.js":44}],14:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'accum',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        genName = 'gen.' + this.name,
        functionBody

    gen.requestMemory( this.memory )

    gen.memory.heap[ this.memory.value.idx ] = this.initialValue

    functionBody = this.callback( genName, inputs[0], inputs[1], `memory[${this.memory.value.idx}]` )

    //gen.closures.add({ [ this.name ]: this }) 

    gen.memo[ this.name ] = this.name + '_value'
    
    return [ this.name + '_value', functionBody ]
  },

  callback( _name, _incr, _reset, valueRef ) {
    let diff = this.max - this.min,
        out = '',
        wrap = ''
    
    /* three different methods of wrapping, third is most expensive:
     *
     * 1: range {0,1}: y = x - (x | 0)
     * 2: log2(this.max) == integer: y = x & (this.max - 1)
     * 3: all others: if( x >= this.max ) y = this.max -x
     *
     */

    // must check for reset before storing value for output
    if( !(typeof this.inputs[1] === 'number' && this.inputs[1] < 1) ) { 
      if( this.resetValue !== this.min ) {

        out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.resetValue}\n\n`
        //out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.min}\n\n`
      }else{
        out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.min}\n\n`
        //out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.initialValue}\n\n`
      }
    }

    out += `  var ${this.name}_value = ${valueRef}\n`
    
    if( this.shouldWrap === false && this.shouldClamp === true ) {
      out += `  if( ${valueRef} < ${this.max } ) ${valueRef} += ${_incr}\n`
    }else{
      out += `  ${valueRef} += ${_incr}\n` // store output value before accumulating  
    }

    if( this.max !== Infinity  && this.shouldWrapMax ) wrap += `  if( ${valueRef} >= ${this.max} ) ${valueRef} -= ${diff}\n`
    if( this.min !== -Infinity && this.shouldWrapMin ) wrap += `  if( ${valueRef} < ${this.min} ) ${valueRef} += ${diff}\n`

    //if( this.min === 0 && this.max === 1 ) { 
    //  wrap =  `  ${valueRef} = ${valueRef} - (${valueRef} | 0)\n\n`
    //} else if( this.min === 0 && ( Math.log2( this.max ) | 0 ) === Math.log2( this.max ) ) {
    //  wrap =  `  ${valueRef} = ${valueRef} & (${this.max} - 1)\n\n`
    //} else if( this.max !== Infinity ){
    //  wrap = `  if( ${valueRef} >= ${this.max} ) ${valueRef} -= ${diff}\n\n`
    //}

    out = out + wrap + '\n'

    return out
  },

  defaults : { min:0, max:1, resetValue:0, initialValue:0, shouldWrap:true, shouldWrapMax: true, shouldWrapMin:true, shouldClamp:false }
}

module.exports = ( incr, reset=0, properties ) => {
  const ugen = Object.create( proto )
      
  Object.assign( ugen, 
    { 
      uid:    gen.getUID(),
      inputs: [ incr, reset ],
      memory: {
        value: { length:1, idx:null }
      }
    },
    proto.defaults,
    properties 
  )

  if( properties !== undefined && properties.shouldWrapMax === undefined && properties.shouldWrapMin === undefined ) {
    if( properties.shouldWrap !== undefined ) {
      ugen.shouldWrapMin = ugen.shouldWrapMax = properties.shouldWrap
    }
  }

  if( properties !== undefined && properties.resetValue === undefined ) {
    ugen.resetValue = ugen.min
  }

  if( ugen.initialValue === undefined ) ugen.initialValue = ugen.min

  Object.defineProperty( ugen, 'value', {
    get()  { 
      //console.log( 'gen:', gen, gen.memory )
      return gen.memory.heap[ this.memory.value.idx ] 
    },
    set(v) { gen.memory.heap[ this.memory.value.idx ] = v }
  })

  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],15:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'acos',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'acos': isWorklet ? 'Math.acos' :Math.acos })

      out = `${ref}acos( ${inputs[0]} )` 

    } else {
      out = Math.acos( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let acos = Object.create( proto )

  acos.inputs = [ x ]
  acos.id = gen.getUID()
  acos.name = `${acos.basename}{acos.id}`

  return acos
}

},{"./gen.js":44}],16:[function(require,module,exports){
'use strict'

let gen      = require( './gen.js' ),
    mul      = require( './mul.js' ),
    sub      = require( './sub.js' ),
    div      = require( './div.js' ),
    data     = require( './data.js' ),
    peek     = require( './peek.js' ),
    accum    = require( './accum.js' ),
    ifelse   = require( './ifelseif.js' ),
    lt       = require( './lt.js' ),
    bang     = require( './bang.js' ),
    env      = require( './env.js' ),
    add      = require( './add.js' ),
    poke     = require( './poke.js' ),
    neq      = require( './neq.js' ),
    and      = require( './and.js' ),
    gte      = require( './gte.js' ),
    memo     = require( './memo.js' ),
    utilities= require( './utilities.js' )

module.exports = ( attackTime = 44100, decayTime = 44100, _props ) => {
  const props = Object.assign({}, { shape:'exponential', alpha:5, trigger:null }, _props )
  const _bang = props.trigger !== null ? props.trigger : bang(),
        phase = accum( 1, _bang, { min:0, max: Infinity, initialValue:-Infinity, shouldWrap:false })
      
  let bufferData, bufferDataReverse, decayData, out, buffer

  //console.log( 'shape:', props.shape, 'attack time:', attackTime, 'decay time:', decayTime )
  let completeFlag = data( [0] )
  
  // slightly more efficient to use existing phase accumulator for linear envelopes
  if( props.shape === 'linear' ) {
    out = ifelse( 
      and( gte( phase, 0), lt( phase, attackTime )),
      div( phase, attackTime ),

      and( gte( phase, 0),  lt( phase, add( attackTime, decayTime ) ) ),
      sub( 1, div( sub( phase, attackTime ), decayTime ) ),
      
      neq( phase, -Infinity),
      poke( completeFlag, 1, 0, { inline:0 }),

      0 
    )
  } else {
    bufferData = env({ length:1024, type:props.shape, alpha:props.alpha })
    bufferDataReverse = env({ length:1024, type:props.shape, alpha:props.alpha, reverse:true })

    out = ifelse( 
      and( gte( phase, 0), lt( phase, attackTime ) ), 
      peek( bufferData, div( phase, attackTime ), { boundmode:'clamp' } ), 

      and( gte(phase,0), lt( phase, add( attackTime, decayTime ) ) ), 
      peek( bufferDataReverse, div( sub( phase, attackTime ), decayTime ), { boundmode:'clamp' }),

      neq( phase, -Infinity ),
      poke( completeFlag, 1, 0, { inline:0 }),

      0
    )
  }

  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    out.node = null
    utilities.register( out )
  }

  // needed for gibberish... getting this to work right with worklets
  // via promises will probably be tricky
  out.isComplete = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      const p = new Promise( resolve => {
        out.node.getMemoryValue( completeFlag.memory.values.idx, resolve )
      })

      return p
    }else{
      return gen.memory.heap[ completeFlag.memory.values.idx ]
    }
  }

  out.trigger = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      out.node.port.postMessage({ key:'set', idx:completeFlag.memory.values.idx, value:0 })
    }else{
      gen.memory.heap[ completeFlag.memory.values.idx ] = 0
    }
    _bang.trigger()
  }

  return out 
}

},{"./accum.js":14,"./add.js":17,"./and.js":19,"./bang.js":23,"./data.js":30,"./div.js":35,"./env.js":36,"./gen.js":44,"./gte.js":46,"./ifelseif.js":49,"./lt.js":52,"./memo.js":56,"./mul.js":62,"./neq.js":63,"./peek.js":68,"./poke.js":70,"./sub.js":81,"./utilities.js":87}],17:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = { 
  basename:'add',
  gen() {
    let inputs = gen.getInputs( this ),
        out='',
        sum = 0, numCount = 0, adderAtEnd = false, alreadyFullSummed = true

    if( inputs.length === 0 ) return 0

    out = `  var ${this.name} = `

    inputs.forEach( (v,i) => {
      if( isNaN( v ) ) {
        out += v
        if( i < inputs.length -1 ) {
          adderAtEnd = true
          out += ' + '
        }
        alreadyFullSummed = false
      }else{
        sum += parseFloat( v )
        numCount++
      }
    })

    if( numCount > 0 ) {
      out += adderAtEnd || alreadyFullSummed ? sum : ' + ' + sum
    }

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = ( ...args ) => {
  const add = Object.create( proto )
  add.id = gen.getUID()
  add.name = add.basename + add.id
  add.inputs = args

  return add
}

},{"./gen.js":44}],18:[function(require,module,exports){
'use strict'

let gen      = require( './gen.js' ),
    mul      = require( './mul.js' ),
    sub      = require( './sub.js' ),
    div      = require( './div.js' ),
    data     = require( './data.js' ),
    peek     = require( './peek.js' ),
    accum    = require( './accum.js' ),
    ifelse   = require( './ifelseif.js' ),
    lt       = require( './lt.js' ),
    bang     = require( './bang.js' ),
    env      = require( './env.js' ),
    param    = require( './param.js' ),
    add      = require( './add.js' ),
    gtp      = require( './gtp.js' ),
    not      = require( './not.js' ),
    and      = require( './and.js' ),
    neq      = require( './neq.js' ),
    poke     = require( './poke.js' )

module.exports = ( attackTime=44, decayTime=22050, sustainTime=44100, sustainLevel=.6, releaseTime=44100, _props ) => {
  let envTrigger = bang(),
      phase = accum( 1, envTrigger, { max: Infinity, shouldWrap:false, initialValue:Infinity }),
      shouldSustain = param( 1 ),
      defaults = {
         shape: 'exponential',
         alpha: 5,
         triggerRelease: false,
      },
      props = Object.assign({}, defaults, _props ),
      bufferData, decayData, out, buffer, sustainCondition, releaseAccum, releaseCondition


  const completeFlag = data( [0] )

  bufferData = env({ length:1024, alpha:props.alpha, shift:0, type:props.shape })

  sustainCondition = props.triggerRelease 
    ? shouldSustain
    : lt( phase, add( attackTime, decayTime, sustainTime ) )

  releaseAccum = props.triggerRelease
    ? gtp( sub( sustainLevel, accum( div( sustainLevel, releaseTime ) , 0, { shouldWrap:false }) ), 0 )
    : sub( sustainLevel, mul( div( sub( phase, add( attackTime, decayTime, sustainTime ) ), releaseTime ), sustainLevel ) ), 

  releaseCondition = props.triggerRelease
    ? not( shouldSustain )
    : lt( phase, add( attackTime, decayTime, sustainTime, releaseTime ) )

  out = ifelse(
    // attack 
    lt( phase,  attackTime ), 
    peek( bufferData, div( phase, attackTime ), { boundmode:'clamp' } ), 

    // decay
    lt( phase, add( attackTime, decayTime ) ), 
    peek( bufferData, sub( 1, mul( div( sub( phase,  attackTime ),  decayTime ), sub( 1,  sustainLevel ) ) ), { boundmode:'clamp' }),

    // sustain
    and( sustainCondition, neq( phase, Infinity ) ),
    peek( bufferData,  sustainLevel ),

    // release
    releaseCondition, //lt( phase,  attackTime +  decayTime +  sustainTime +  releaseTime ),
    peek( 
      bufferData,
      releaseAccum, 
      //sub(  sustainLevel, mul( div( sub( phase,  attackTime +  decayTime +  sustainTime),  releaseTime ),  sustainLevel ) ), 
      { boundmode:'clamp' }
    ),

    neq( phase, Infinity ),
    poke( completeFlag, 1, 0, { inline:0 }),

    0
  )
   
  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    out.node = null
    utilities.register( out )
  }

  out.trigger = ()=> {
    shouldSustain.value = 1
    envTrigger.trigger()
  }
 
  // needed for gibberish... getting this to work right with worklets
  // via promises will probably be tricky
  out.isComplete = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      const p = new Promise( resolve => {
        out.node.getMemoryValue( completeFlag.memory.values.idx, resolve )
      })

      return p
    }else{
      return gen.memory.heap[ completeFlag.memory.values.idx ]
    }
  }


  out.release = ()=> {
    shouldSustain.value = 0
    // XXX pretty nasty... grabs accum inside of gtp and resets value manually
    // unfortunately envTrigger won't work as it's back to 0 by the time the release block is triggered...
    if( usingWorklet && out.node !== null ) {
      out.node.port.postMessage({ key:'set', idx:releaseAccum.inputs[0].inputs[1].memory.value.idx, value:0 })
    }else{
      gen.memory.heap[ releaseAccum.inputs[0].inputs[1].memory.value.idx ] = 0
    }
  }

  return out 
}

},{"./accum.js":14,"./add.js":17,"./and.js":19,"./bang.js":23,"./data.js":30,"./div.js":35,"./env.js":36,"./gen.js":44,"./gtp.js":47,"./ifelseif.js":49,"./lt.js":52,"./mul.js":62,"./neq.js":63,"./not.js":65,"./param.js":67,"./peek.js":68,"./poke.js":70,"./sub.js":81}],19:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'and',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = `  var ${this.name} = (${inputs[0]} !== 0 && ${inputs[1]} !== 0) | 0\n\n`

    gen.memo[ this.name ] = `${this.name}`

    return [ `${this.name}`, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],20:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'asin',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'asin': isWorklet ? 'Math.sin' : Math.asin })

      out = `${ref}asin( ${inputs[0]} )` 

    } else {
      out = Math.asin( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let asin = Object.create( proto )

  asin.inputs = [ x ]
  asin.id = gen.getUID()
  asin.name = `${asin.basename}{asin.id}`

  return asin
}

},{"./gen.js":44}],21:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'atan',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'atan': isWorklet ? 'Math.atan' : Math.atan })

      out = `${ref}atan( ${inputs[0]} )` 

    } else {
      out = Math.atan( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let atan = Object.create( proto )

  atan.inputs = [ x ]
  atan.id = gen.getUID()
  atan.name = `${atan.basename}{atan.id}`

  return atan
}

},{"./gen.js":44}],22:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    mul     = require( './mul.js' ),
    sub     = require( './sub.js' )

module.exports = ( decayTime = 44100 ) => {
  let ssd = history ( 1 ),
      t60 = Math.exp( -6.907755278921 / decayTime )

  ssd.in( mul( ssd.out, t60 ) )

  ssd.out.trigger = ()=> {
    ssd.value = 1
  }

  return sub( 1, ssd.out )
}

},{"./gen.js":44,"./history.js":48,"./mul.js":62,"./sub.js":81}],23:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  gen() {
    gen.requestMemory( this.memory )
    
    let out = 
`  var ${this.name} = memory[${this.memory.value.idx}]
  if( ${this.name} === 1 ) memory[${this.memory.value.idx}] = 0      
      
`
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  } 
}

module.exports = ( _props ) => {
  let ugen = Object.create( proto ),
      props = Object.assign({}, { min:0, max:1 }, _props )

  ugen.name = 'bang' + gen.getUID()

  ugen.min = props.min
  ugen.max = props.max

  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    ugen.node = null
    utilities.register( ugen )
  }

  ugen.trigger = () => {
    if( usingWorklet === true && ugen.node !== null ) {
      ugen.node.port.postMessage({ key:'set', idx:ugen.memory.value.idx, value:ugen.max })
    }else{
      gen.memory.heap[ ugen.memory.value.idx ] = ugen.max 
    }
  }

  ugen.memory = {
    value: { length:1, idx:null }
  }

  return ugen
}

},{"./gen.js":44}],24:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'bool',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = `${inputs[0]} === 0 ? 0 : 1`
    
    //gen.memo[ this.name ] = `gen.data.${this.name}`

    //return [ `gen.data.${this.name}`, ' ' +out ]
    return out
  }
}

module.exports = ( in1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    uid:        gen.getUID(),
    inputs:     [ in1 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}


},{"./gen.js":44}],25:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'ceil',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.ceil' : Math.ceil })

      out = `${ref}ceil( ${inputs[0]} )`

    } else {
      out = Math.ceil( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let ceil = Object.create( proto )

  ceil.inputs = [ x ]

  return ceil
}

},{"./gen.js":44}],26:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    floor= require('./floor.js'),
    sub  = require('./sub.js'),
    memo = require('./memo.js')

let proto = {
  basename:'clip',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        out

    out =

` var ${this.name} = ${inputs[0]}
  if( ${this.name} > ${inputs[2]} ) ${this.name} = ${inputs[2]}
  else if( ${this.name} < ${inputs[1]} ) ${this.name} = ${inputs[1]}
`
    out = ' ' + out
    
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  },
}

module.exports = ( in1, min=-1, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1, min, max ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./floor.js":41,"./gen.js":44,"./memo.js":56,"./sub.js":81}],27:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'cos',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'

    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'cos': isWorklet ? 'Math.cos' : Math.cos })

      out = `${ref}cos( ${inputs[0]} )` 

    } else {
      out = Math.cos( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let cos = Object.create( proto )

  cos.inputs = [ x ]
  cos.id = gen.getUID()
  cos.name = `${cos.basename}{cos.id}`

  return cos
}

},{"./gen.js":44}],28:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'counter',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        genName = 'gen.' + this.name,
        functionBody
       
    if( this.memory.value.idx === null ) gen.requestMemory( this.memory )
    gen.memory.heap[ this.memory.value.idx ] = this.initialValue
    
    functionBody  = this.callback( genName, inputs[0], inputs[1], inputs[2], inputs[3], inputs[4],  `memory[${this.memory.value.idx}]`, `memory[${this.memory.wrap.idx}]`  )

    gen.memo[ this.name ] = this.name + '_value'
   
    if( gen.memo[ this.wrap.name ] === undefined ) this.wrap.gen()

    return [ this.name + '_value', functionBody ]
  },

  callback( _name, _incr, _min, _max, _reset, loops, valueRef, wrapRef ) {
    let diff = this.max - this.min,
        out = '',
        wrap = ''
    // must check for reset before storing value for output
    if( !(typeof this.inputs[3] === 'number' && this.inputs[3] < 1) ) { 
      out += `  if( ${_reset} >= 1 ) ${valueRef} = ${_min}\n`
    }

    out += `  var ${this.name}_value = ${valueRef};\n  ${valueRef} += ${_incr}\n` // store output value before accumulating  
    
    if( typeof this.max === 'number' && this.max !== Infinity && typeof this.min !== 'number' ) {
      wrap = 
`  if( ${valueRef} >= ${this.max} &&  ${loops} > 0) {
    ${valueRef} -= ${diff}
    ${wrapRef} = 1
  }else{
    ${wrapRef} = 0
  }\n`
    }else if( this.max !== Infinity && this.min !== Infinity ) {
      wrap = 
`  if( ${valueRef} >= ${_max} &&  ${loops} > 0) {
    ${valueRef} -= ${_max} - ${_min}
    ${wrapRef} = 1
  }else if( ${valueRef} < ${_min} &&  ${loops} > 0) {
    ${valueRef} += ${_max} - ${_min}
    ${wrapRef} = 1
  }else{
    ${wrapRef} = 0
  }\n`
    }else{
      out += '\n'
    }

    out = out + wrap

    return out
  }
}

module.exports = ( incr=1, min=0, max=Infinity, reset=0, loops=1,  properties ) => {
  let ugen = Object.create( proto ),
      defaults = Object.assign( { initialValue: 0, shouldWrap:true }, properties )

  Object.assign( ugen, { 
    min:    min, 
    max:    max,
    initialValue: defaults.initialValue,
    value:  defaults.initialValue,
    uid:    gen.getUID(),
    inputs: [ incr, min, max, reset, loops ],
    memory: {
      value: { length:1, idx: null },
      wrap:  { length:1, idx: null } 
    },
    wrap : {
      gen() { 
        if( ugen.memory.wrap.idx === null ) {
          gen.requestMemory( ugen.memory )
        }
        gen.getInputs( this )
        gen.memo[ this.name ] = `memory[ ${ugen.memory.wrap.idx} ]`
        return `memory[ ${ugen.memory.wrap.idx} ]` 
      }
    }
  },
  defaults )
 
  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        gen.memory.heap[ this.memory.value.idx ] = v 
      }
    }
  })
  
  ugen.wrap.inputs = [ ugen ]
  ugen.name = `${ugen.basename}${ugen.uid}`
  ugen.wrap.name = ugen.name + '_wrap'
  return ugen
} 

},{"./gen.js":44}],29:[function(require,module,exports){
'use strict'

let gen  = require( './gen.js' ),
    accum= require( './phasor.js' ),
    data = require( './data.js' ),
    peek = require( './peek.js' ),
    mul  = require( './mul.js' ),
    phasor=require( './phasor.js')

let proto = {
  basename:'cycle',

  initTable() {    
    let buffer = new Float32Array( 1024 )

    for( let i = 0, l = buffer.length; i < l; i++ ) {
      buffer[ i ] = Math.sin( ( i / l ) * ( Math.PI * 2 ) )
    }

    gen.globals.cycle = data( buffer, 1, { immutable:true } )
  }

}

module.exports = ( frequency=1, reset=0, _props ) => {
  if( typeof gen.globals.cycle === 'undefined' ) proto.initTable() 
  const props = Object.assign({}, { min:0 }, _props )

  const ugen = peek( gen.globals.cycle, phasor( frequency, reset, props ))
  ugen.name = 'cycle' + gen.getUID()

  return ugen
}

},{"./data.js":30,"./gen.js":44,"./mul.js":62,"./peek.js":68,"./phasor.js":69}],30:[function(require,module,exports){
'use strict'

const gen  = require('./gen.js'),
      utilities = require( './utilities.js' ),
      peek = require('./peek.js'),
      poke = require('./poke.js')

const proto = {
  basename:'data',
  globals: {},
  memo:{},

  gen() {
    let idx
    //console.log( 'data name:', this.name, proto.memo )
    //debugger
    if( gen.memo[ this.name ] === undefined ) {
      let ugen = this
      gen.requestMemory( this.memory, this.immutable ) 
      idx = this.memory.values.idx
      if( this.buffer !== undefined ) {
        try {
          gen.memory.heap.set( this.buffer, idx )
        }catch( e ) {
          console.log( e )
          throw Error( 'error with request. asking for ' + this.buffer.length +'. current index: ' + gen.memoryIndex + ' of ' + gen.memory.heap.length )
        }
      }
      //gen.data[ this.name ] = this
      //return 'gen.memory' + this.name + '.buffer'
      if( this.name.indexOf('data') === -1 ) {
        proto.memo[ this.name ] = idx
      }else{
        gen.memo[ this.name ] = idx
      }
    }else{
      //console.log( 'using gen data memo', proto.memo[ this.name ] )
      idx = gen.memo[ this.name ]
    }
    return idx
  },
}

module.exports = ( x, y=1, properties ) => {
  let ugen, buffer, shouldLoad = false
  
  if( properties !== undefined && properties.global !== undefined ) {
    if( gen.globals[ properties.global ] ) {
      return gen.globals[ properties.global ]
    }
  }

  if( typeof x === 'number' ) {
    if( y !== 1 ) {
      buffer = []
      for( let i = 0; i < y; i++ ) {
        buffer[ i ] = new Float32Array( x )
      }
    }else{
      buffer = new Float32Array( x )
    }
  }else if( Array.isArray( x ) ) { //! (x instanceof Float32Array ) ) {
    let size = x.length
    buffer = new Float32Array( size )
    for( let i = 0; i < x.length; i++ ) {
      buffer[ i ] = x[ i ]
    }
  }else if( typeof x === 'string' ) {
    //buffer = { length: y > 1 ? y : gen.samplerate * 60 } // XXX what???
    //if( proto.memo[ x ] === undefined ) {
      buffer = { length: y > 1 ? y : 1 } // XXX what???
      shouldLoad = true
    //}else{
      //buffer = proto.memo[ x ]
    //}
  }else if( x instanceof Float32Array ) {
    buffer = x
  }
  
  ugen = Object.create( proto ) 

  Object.assign( ugen, 
  { 
    buffer,
    name: proto.basename + gen.getUID(),
    dim:  buffer !== undefined ? buffer.length : 1, // XXX how do we dynamically allocate this?
    channels : 1,
    onload: null,
    //then( fnc ) {
    //  ugen.onload = fnc
    //  return ugen
    //},
    immutable: properties !== undefined && properties.immutable === true ? true : false,
    load( filename, __resolve ) {
      let promise = utilities.loadSample( filename, ugen )
      promise.then( _buffer => { 
        proto.memo[ x ] = _buffer
        ugen.name = filename
        ugen.memory.values.length = ugen.dim = _buffer.length

        gen.requestMemory( ugen.memory, ugen.immutable ) 
        gen.memory.heap.set( _buffer, ugen.memory.values.idx )
        if( typeof ugen.onload === 'function' ) ugen.onload( _buffer ) 
        __resolve( ugen )
      })
    },
    memory : {
      values: { length:buffer !== undefined ? buffer.length : 1, idx:null }
    }
  },
  properties
  )

  
  if( properties !== undefined ) {
    if( properties.global !== undefined ) {
      gen.globals[ properties.global ] = ugen
    }
    if( properties.meta === true ) {
      for( let i = 0, length = ugen.buffer.length; i < length; i++ ) {
        Object.defineProperty( ugen, i, {
          get () {
            return peek( ugen, i, { mode:'simple', interp:'none' } )
          },
          set( v ) {
            return poke( ugen, v, i )
          }
        })
      }
    }
  }

  let returnValue
  if( shouldLoad === true ) {
    returnValue = new Promise( (resolve,reject) => {
      //ugen.load( x, resolve )
      let promise = utilities.loadSample( x, ugen )
      promise.then( _buffer => { 
        proto.memo[ x ] = _buffer
        ugen.memory.values.length = ugen.dim = _buffer.length

        ugen.buffer = _buffer
        //gen.once( 'memory init', ()=> {
        //  console.log( "CALLED", ugen.memory )
        //  gen.requestMemory( ugen.memory, ugen.immutable ) 
        //  gen.memory.heap.set( _buffer, ugen.memory.values.idx )
        //  if( typeof ugen.onload === 'function' ) ugen.onload( _buffer ) 
        //})
        
        resolve( ugen )
      })     
    })
  }else if( proto.memo[ x ] !== undefined ) {

    gen.once( 'memory init', ()=> {
      gen.requestMemory( ugen.memory, ugen.immutable ) 
      gen.memory.heap.set( ugen.buffer, ugen.memory.values.idx )
      if( typeof ugen.onload === 'function' ) ugen.onload( ugen.buffer ) 
    })

    returnValue = ugen
  }else{
    returnValue = ugen
  }

  return returnValue 
}


},{"./gen.js":44,"./peek.js":68,"./poke.js":70,"./utilities.js":87}],31:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' )

module.exports = ( in1 ) => {
  let x1 = history(),
      y1 = history(),
      filter

  //History x1, y1; y = in1 - x1 + y1*0.9997; x1 = in1; y1 = y; out1 = y;
  filter = memo( add( sub( in1, x1.out ), mul( y1.out, .9997 ) ) )
  x1.in( in1 )
  y1.in( filter )

  return filter
}

},{"./add.js":17,"./gen.js":44,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81}],32:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    mul     = require( './mul.js' ),
    t60     = require( './t60.js' )

module.exports = ( decayTime = 44100, props ) => {
  let properties = Object.assign({}, { initValue:1 }, props ),
      ssd = history ( properties.initValue )

  ssd.in( mul( ssd.out, t60( decayTime ) ) )

  ssd.out.trigger = ()=> {
    ssd.value = 1
  }

  return ssd.out 
}

},{"./gen.js":44,"./history.js":48,"./mul.js":62,"./t60.js":83}],33:[function(require,module,exports){
'use strict'

const gen  = require( './gen.js'  ),
      data = require( './data.js' ),
      poke = require( './poke.js' ),
      peek = require( './peek.js' ),
      sub  = require( './sub.js'  ),
      wrap = require( './wrap.js' ),
      accum= require( './accum.js'),
      memo = require( './memo.js' )

const proto = {
  basename:'delay',

  gen() {
    let inputs = gen.getInputs( this )
    
    gen.memo[ this.name ] = inputs[0]
    
    return inputs[0]
  },
}

const defaults = { size: 512, interp:'none' }

module.exports = ( in1, taps, properties ) => {
  const ugen = Object.create( proto )
  let writeIdx, readIdx, delaydata

  if( Array.isArray( taps ) === false ) taps = [ taps ]
  
  const props = Object.assign( {}, defaults, properties )

  const maxTapSize = Math.max( ...taps )
  if( props.size < maxTapSize ) props.size = maxTapSize

  delaydata = data( props.size )
  
  ugen.inputs = []

  writeIdx = accum( 1, 0, { max:props.size, min:0 })
  
  for( let i = 0; i < taps.length; i++ ) {
    ugen.inputs[ i ] = peek( delaydata, wrap( sub( writeIdx, taps[i] ), 0, props.size ),{ mode:'samples', interp:props.interp })
  }
  
  ugen.outputs = ugen.inputs // XXX ugh, Ugh, UGH! but i guess it works.

  poke( delaydata, in1, writeIdx )

  ugen.name = `${ugen.basename}${gen.getUID()}`

  return ugen
}

},{"./accum.js":14,"./data.js":30,"./gen.js":44,"./memo.js":56,"./peek.js":68,"./poke.js":70,"./sub.js":81,"./wrap.js":89}],34:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' )

module.exports = ( in1 ) => {
  let n1 = history()
    
  n1.in( in1 )

  let ugen = sub( in1, n1.out )
  ugen.name = 'delta'+gen.getUID()

  return ugen
}

},{"./gen.js":44,"./history.js":48,"./sub.js":81}],35:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

const proto = {
  basename:'div',
  gen() {
    let inputs = gen.getInputs( this ),
        out=`  var ${this.name} = `,
        diff = 0, 
        numCount = 0,
        lastNumber = inputs[ 0 ],
        lastNumberIsUgen = isNaN( lastNumber ), 
        divAtEnd = false

    inputs.forEach( (v,i) => {
      if( i === 0 ) return

      let isNumberUgen = isNaN( v ),
        isFinalIdx   = i === inputs.length - 1

      if( !lastNumberIsUgen && !isNumberUgen ) {
        lastNumber = lastNumber / v
        out += lastNumber
      }else{
        out += `${lastNumber} / ${v}`
      }

      if( !isFinalIdx ) out += ' / ' 
    })

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = (...args) => {
  const div = Object.create( proto )
  
  Object.assign( div, {
    id:     gen.getUID(),
    inputs: args,
  })

  div.name = div.basename + div.id
  
  return div
}

},{"./gen.js":44}],36:[function(require,module,exports){
'use strict'

let gen     = require( './gen' ),
    windows = require( './windows' ),
    data    = require( './data' ),
    peek    = require( './peek' ),
    phasor  = require( './phasor' ),
    defaults = {
      type:'triangular', length:1024, alpha:.15, shift:0, reverse:false 
    }

module.exports = props => {
  
  let properties = Object.assign( {}, defaults, props )
  let buffer = new Float32Array( properties.length )

  let name = properties.type + '_' + properties.length + '_' + properties.shift + '_' + properties.reverse + '_' + properties.alpha
  if( typeof gen.globals.windows[ name ] === 'undefined' ) { 

    for( let i = 0; i < properties.length; i++ ) {
      buffer[ i ] = windows[ properties.type ]( properties.length, i, properties.alpha, properties.shift )
    }

    if( properties.reverse === true ) { 
      buffer.reverse()
    }
    gen.globals.windows[ name ] = data( buffer )
  }

  let ugen = gen.globals.windows[ name ] 
  ugen.name = 'env' + gen.getUID()

  return ugen
}

},{"./data":30,"./gen":44,"./peek":68,"./phasor":69,"./windows":88}],37:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'eq',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = this.inputs[0] === this.inputs[1] ? 1 : `  var ${this.name} = (${inputs[0]} === ${inputs[1]}) | 0\n\n`

    gen.memo[ this.name ] = `${this.name}`

    return [ `${this.name}`, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],38:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'exp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.exp' : Math.exp })

      out = `${ref}exp( ${inputs[0]} )`

    } else {
      out = Math.exp( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let exp = Object.create( proto )

  exp.inputs = [ x ]

  return exp
}

},{"./gen.js":44}],39:[function(require,module,exports){
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

// originally from:
// https://github.com/GoogleChromeLabs/audioworklet-polyfill
// I am modifying it to accept variable buffer sizes
// and to get rid of some strange global initialization that seems required to use it
// with browserify. Also, I added changes to fix a bug in Safari for the AudioWorkletProcessor
// property not having a prototype (see:https://github.com/GoogleChromeLabs/audioworklet-polyfill/pull/25)
// TODO: Why is there an iframe involved? (realm.js)

const Realm = require( './realm.js' )

const AWPF = function( self = window, bufferSize = 4096 ) {
  const PARAMS = []
  let nextPort

  if (typeof AudioWorkletNode !== 'function' || !("audioWorklet" in AudioContext.prototype)) {
    self.AudioWorkletNode = function AudioWorkletNode (context, name, options) {
      const processor = getProcessorsForContext(context)[name];
      const outputChannels = options && options.outputChannelCount ? options.outputChannelCount[0] : 2;
      const scriptProcessor = context.createScriptProcessor( bufferSize, 2, outputChannels);

      scriptProcessor.parameters = new Map();
      if (processor.properties) {
        for (let i = 0; i < processor.properties.length; i++) {
          const prop = processor.properties[i];
          const node = context.createGain().gain;
          node.value = prop.defaultValue;
          // @TODO there's no good way to construct the proxy AudioParam here
          scriptProcessor.parameters.set(prop.name, node);
        }
      }

      const mc = new MessageChannel();
      nextPort = mc.port2;
      const inst = new processor.Processor(options || {});
      nextPort = null;

      scriptProcessor.port = mc.port1;
      scriptProcessor.processor = processor;
      scriptProcessor.instance = inst;
      scriptProcessor.onaudioprocess = onAudioProcess;
      return scriptProcessor;
    };

    Object.defineProperty((self.AudioContext || self.webkitAudioContext).prototype, 'audioWorklet', {
      get () {
        return this.$$audioWorklet || (this.$$audioWorklet = new self.AudioWorklet(this));
      }
    });

    /* XXX - ADDED TO OVERCOME PROBLEM IN SAFARI WHERE AUDIOWORKLETPROCESSOR PROTOTYPE IS NOT AN OBJECT */
    const AudioWorkletProcessor = function() {
      this.port = nextPort
    }
    AudioWorkletProcessor.prototype = {}

    self.AudioWorklet = class AudioWorklet {
      constructor (audioContext) {
        this.$$context = audioContext;
      }

      addModule (url, options) {
        return fetch(url).then(r => {
          if (!r.ok) throw Error(r.status);
          return r.text();
        }).then( code => {
          const context = {
            sampleRate: this.$$context.sampleRate,
            currentTime: this.$$context.currentTime,
            AudioWorkletProcessor,
            registerProcessor: (name, Processor) => {
              const processors = getProcessorsForContext(this.$$context);
              processors[name] = {
                realm,
                context,
                Processor,
                properties: Processor.parameterDescriptors || []
              };
            }
          };

          context.self = context;
          const realm = new Realm(context, document.documentElement);
          realm.exec(((options && options.transpile) || String)(code));
          return null;
        });
      }
    };
  }

  function onAudioProcess (e) {
    const parameters = {};
    let index = -1;
    this.parameters.forEach((value, key) => {
      const arr = PARAMS[++index] || (PARAMS[index] = new Float32Array(this.bufferSize));
      // @TODO proper values here if possible
      arr.fill(value.value);
      parameters[key] = arr;
    });
    this.processor.realm.exec(
      'self.sampleRate=sampleRate=' + this.context.sampleRate + ';' +
      'self.currentTime=currentTime=' + this.context.currentTime
    );
    const inputs = channelToArray(e.inputBuffer);
    const outputs = channelToArray(e.outputBuffer);
    this.instance.process([inputs], [outputs], parameters);
  }

  function channelToArray (ch) {
    const out = [];
    for (let i = 0; i < ch.numberOfChannels; i++) {
      out[i] = ch.getChannelData(i);
    }
    return out;
  }

  function getProcessorsForContext (audioContext) {
    return audioContext.$$processors || (audioContext.$$processors = {});
  }
}

module.exports = AWPF

},{"./realm.js":40}],40:[function(require,module,exports){
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],41:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'floor',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( inputs[0] ) ) {
      //gen.closures.add({ [ this.name ]: Math.floor })

      out = `( ${inputs[0]} | 0 )`

    } else {
      out = inputs[0] | 0
    }
    
    return out
  }
}

module.exports = x => {
  let floor = Object.create( proto )

  floor.inputs = [ x ]

  return floor
}

},{"./gen.js":44}],42:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'fold',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        out

    out = this.createCallback( inputs[0], this.min, this.max ) 

    gen.memo[ this.name ] = this.name + '_value'

    return [ this.name + '_value', out ]
  },

  createCallback( v, lo, hi ) {
    let out =
` var ${this.name}_value = ${v},
      ${this.name}_range = ${hi} - ${lo},
      ${this.name}_numWraps = 0

  if(${this.name}_value >= ${hi}){
    ${this.name}_value -= ${this.name}_range
    if(${this.name}_value >= ${hi}){
      ${this.name}_numWraps = ((${this.name}_value - ${lo}) / ${this.name}_range) | 0
      ${this.name}_value -= ${this.name}_range * ${this.name}_numWraps
    }
    ${this.name}_numWraps++
  } else if(${this.name}_value < ${lo}){
    ${this.name}_value += ${this.name}_range
    if(${this.name}_value < ${lo}){
      ${this.name}_numWraps = ((${this.name}_value - ${lo}) / ${this.name}_range- 1) | 0
      ${this.name}_value -= ${this.name}_range * ${this.name}_numWraps
    }
    ${this.name}_numWraps--
  }
  if(${this.name}_numWraps & 1) ${this.name}_value = ${hi} + ${lo} - ${this.name}_value
`
    return ' ' + out
  }
}

module.exports = ( in1, min=0, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],43:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'gate',
  controlString:null, // insert into output codegen for determining indexing
  gen() {
    let inputs = gen.getInputs( this ), out
    
    gen.requestMemory( this.memory )
    
    let lastInputMemoryIdx = 'memory[ ' + this.memory.lastInput.idx + ' ]',
        outputMemoryStartIdx = this.memory.lastInput.idx + 1,
        inputSignal = inputs[0],
        controlSignal = inputs[1]
    
    /* 
     * we check to see if the current control inputs equals our last input
     * if so, we store the signal input in the memory associated with the currently
     * selected index. If not, we put 0 in the memory associated with the last selected index,
     * change the selected index, and then store the signal in put in the memery assoicated
     * with the newly selected index
     */
    
    out =

` if( ${controlSignal} !== ${lastInputMemoryIdx} ) {
    memory[ ${lastInputMemoryIdx} + ${outputMemoryStartIdx}  ] = 0 
    ${lastInputMemoryIdx} = ${controlSignal}
  }
  memory[ ${outputMemoryStartIdx} + ${controlSignal} ] = ${inputSignal}

`
    this.controlString = inputs[1]
    this.initialized = true

    gen.memo[ this.name ] = this.name

    this.outputs.forEach( v => v.gen() )

    return [ null, ' ' + out ]
  },

  childgen() {
    if( this.parent.initialized === false ) {
      gen.getInputs( this ) // parent gate is only input of a gate output, should only be gen'd once.
    }

    if( gen.memo[ this.name ] === undefined ) {
      gen.requestMemory( this.memory )

      gen.memo[ this.name ] = `memory[ ${this.memory.value.idx} ]`
    }
    
    return  `memory[ ${this.memory.value.idx} ]`
  }
}

module.exports = ( control, in1, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { count: 2 }

  if( typeof properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, {
    outputs: [],
    uid:     gen.getUID(),
    inputs:  [ in1, control ],
    memory: {
      lastInput: { length:1, idx:null }
    },
    initialized:false
  },
  defaults )
  
  ugen.name = `${ugen.basename}${gen.getUID()}`

  for( let i = 0; i < ugen.count; i++ ) {
    ugen.outputs.push({
      index:i,
      gen: proto.childgen,
      parent:ugen,
      inputs: [ ugen ],
      memory: {
        value: { length:1, idx:null }
      },
      initialized:false,
      name: `${ugen.name}_out${gen.getUID()}`
    })
  }

  return ugen
}

},{"./gen.js":44}],44:[function(require,module,exports){
'use strict'

/* gen.js
 *
 * low-level code generation for unit generators
 *
 */
const MemoryHelper = require( 'memory-helper' )
const EE = require( 'events' ).EventEmitter

const gen = {

  accum:0,
  getUID() { return this.accum++ },
  debug:false,
  samplerate: 44100, // change on audiocontext creation
  shouldLocalize: false,
  graph:null,
  globals:{
    windows: {},
  },
  mode:'worklet',
  
  /* closures
   *
   * Functions that are included as arguments to master callback. Examples: Math.abs, Math.random etc.
   * XXX Should probably be renamed callbackProperties or something similar... closures are no longer used.
   */

  closures: new Set(),
  params:   new Set(),
  inputs:   new Set(),

  parameters: new Set(),
  endBlock: new Set(),
  histories: new Map(),

  memo: {},

  //data: {},
  
  /* export
   *
   * place gen functions into another object for easier reference
   */

  export( obj ) {},

  addToEndBlock( v ) {
    this.endBlock.add( '  ' + v )
  },
  
  requestMemory( memorySpec, immutable=false ) {
    for( let key in memorySpec ) {
      let request = memorySpec[ key ]

      //console.log( 'requesting ' + key + ':' , JSON.stringify( request ) )

      if( request.length === undefined ) {
        console.log( 'undefined length for:', key )

        continue
      }

      request.idx = gen.memory.alloc( request.length, immutable )
    }
  },

  createMemory( amount=4096, type ) {
    const mem = MemoryHelper.create( amount, type )
    return mem
  },

  createCallback( ugen, mem, debug = false, shouldInlineMemory=false, memType = Float64Array ) {
    let isStereo = Array.isArray( ugen ) && ugen.length > 1,
        callback, 
        channel1, channel2

    if( typeof mem === 'number' || mem === undefined ) {
      this.memory = this.createMemory( mem, memType )
    }else{
      this.memory = mem
    }
    
    this.outputIdx = this.memory.alloc( 2, true )
    this.emit( 'memory init' )

    //console.log( 'cb memory:', mem )
    this.graph = ugen
    this.memo = {} 
    this.endBlock.clear()
    this.closures.clear()
    this.inputs.clear()
    this.params.clear()
    this.globals = { windows:{} }
    
    this.parameters.clear()
    
    this.functionBody = "  'use strict'\n"
    if( shouldInlineMemory===false ) {
      this.functionBody += this.mode === 'worklet' ? 
        "  var memory = this.memory\n\n" :
        "  var memory = gen.memory\n\n"
    }

    // call .gen() on the head of the graph we are generating the callback for
    //console.log( 'HEAD', ugen )
    for( let i = 0; i < 1 + isStereo; i++ ) {
      if( typeof ugen[i] === 'number' ) continue

      //let channel = isStereo ? ugen[i].gen() : ugen.gen(),
      let channel = isStereo ? this.getInput( ugen[i] ) : this.getInput( ugen ), 
          body = ''

      // if .gen() returns array, add ugen callback (graphOutput[1]) to our output functions body
      // and then return name of ugen. If .gen() only generates a number (for really simple graphs)
      // just return that number (graphOutput[0]).
      body += Array.isArray( channel ) ? channel[1] + '\n' + channel[0] : channel

      // split body to inject return keyword on last line
      body = body.split('\n')
     
      //if( debug ) console.log( 'functionBody length', body )
      
      // next line is to accommodate memo as graph head
      if( body[ body.length -1 ].trim().indexOf('let') > -1 ) { body.push( '\n' ) } 

      // get index of last line
      let lastidx = body.length - 1

      // insert return keyword
      body[ lastidx ] = '  memory[' + (this.outputIdx + i) + ']  = ' + body[ lastidx ] + '\n'

      this.functionBody += body.join('\n')
    }
    
    this.histories.forEach( value => {
      if( value !== null )
        value.gen()      
    })

    const returnStatement = isStereo ? `  return [ memory[${this.outputIdx}], memory[${this.outputIdx + 1}] ]` : `  return memory[${this.outputIdx}]`
    
    this.functionBody = this.functionBody.split('\n')

    if( this.endBlock.size ) { 
      this.functionBody = this.functionBody.concat( Array.from( this.endBlock ) )
      this.functionBody.push( returnStatement )
    }else{
      this.functionBody.push( returnStatement )
    }
    // reassemble function body
    this.functionBody = this.functionBody.join('\n')

    // we can only dynamically create a named function by dynamically creating another function
    // to construct the named function! sheesh...
    //
    if( shouldInlineMemory === true ) {
      this.parameters.add( 'memory' )
    }

    let paramString = ''
    if( this.mode === 'worklet' ) {
      for( let name of this.parameters.values() ) {
        paramString += name + ','
      }
      paramString = paramString.slice(0,-1)
    }

    const separator = this.parameters.size !== 0 && this.inputs.size > 0 ? ', ' : ''

    let inputString = ''
    if( this.mode === 'worklet' ) {
      for( let ugen of this.inputs.values() ) {
        inputString += ugen.name + ','
      }
      inputString = inputString.slice(0,-1)
    }

    let buildString = this.mode === 'worklet'
      ? `return function( ${inputString} ${separator} ${paramString} ){ \n${ this.functionBody }\n}`
      : `return function gen( ${ [...this.parameters].join(',') } ){ \n${ this.functionBody }\n}`
    
    if( this.debug || debug ) console.log( buildString ) 

    callback = new Function( buildString )()

    // assign properties to named function
    for( let dict of this.closures.values() ) {
      let name = Object.keys( dict )[0],
          value = dict[ name ]

      callback[ name ] = value
    }

    for( let dict of this.params.values() ) {
      let name = Object.keys( dict )[0],
          ugen = dict[ name ]
      
      Object.defineProperty( callback, name, {
        configurable: true,
        get() { return ugen.value },
        set(v){ ugen.value = v }
      })
      //callback[ name ] = value
    }

    callback.members = this.closures
    callback.data = this.data
    callback.params = this.params
    callback.inputs = this.inputs
    callback.parameters = this.parameters//.slice( 0 )
    callback.out = this.memory.heap.subarray( this.outputIdx, this.outputIdx + 2 )
    callback.isStereo = isStereo

    //if( MemoryHelper.isPrototypeOf( this.memory ) ) 
    callback.memory = this.memory.heap

    this.histories.clear()

    return callback
  },
  
  /* getInputs
   *
   * Called by each individual ugen when their .gen() method is called to resolve their various inputs.
   * If an input is a number, return the number. If
   * it is an ugen, call .gen() on the ugen, memoize the result and return the result. If the
   * ugen has previously been memoized return the memoized value.
   *
   */
  getInputs( ugen ) {
    return ugen.inputs.map( gen.getInput ) 
  },

  getInput( input ) {
    let isObject = typeof input === 'object',
        processedInput

    if( isObject ) { // if input is a ugen... 
      //console.log( input.name, gen.memo[ input.name ] )
      if( gen.memo[ input.name ] ) { // if it has been memoized...
        processedInput = gen.memo[ input.name ]
      }else if( Array.isArray( input ) ) {
        gen.getInput( input[0] )
        gen.getInput( input[1] )
      }else{ // if not memoized generate code  
        if( typeof input.gen !== 'function' ) {
          console.log( 'no gen found:', input, input.gen )
          input = input.graph
        }
        let code = input.gen()
        //if( code.indexOf( 'Object' ) > -1 ) console.log( 'bad input:', input, code )
        
        if( Array.isArray( code ) ) {
          if( !gen.shouldLocalize ) {
            gen.functionBody += code[1]
          }else{
            gen.codeName = code[0]
            gen.localizedCode.push( code[1] )
          }
          //console.log( 'after GEN' , this.functionBody )
          processedInput = code[0]
        }else{
          processedInput = code
        }
      }
    }else{ // it input is a number
      processedInput = input
    }

    return processedInput
  },

  startLocalize() {
    this.localizedCode = []
    this.shouldLocalize = true
  },
  endLocalize() {
    this.shouldLocalize = false

    return [ this.codeName, this.localizedCode.slice(0) ]
  },

  free( graph ) {
    if( Array.isArray( graph ) ) { // stereo ugen
      for( let channel of graph ) {
        this.free( channel )
      }
    } else {
      if( typeof graph === 'object' ) {
        if( graph.memory !== undefined ) {
          for( let memoryKey in graph.memory ) {
            this.memory.free( graph.memory[ memoryKey ].idx )
          }
        }
        if( Array.isArray( graph.inputs ) ) {
          for( let ugen of graph.inputs ) {
            this.free( ugen )
          }
        }
      }
    }
  }
}

gen.__proto__ = new EE()

module.exports = gen

},{"events":8,"memory-helper":221}],45:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'gt',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `(( ${inputs[0]} > ${inputs[1]}) | 0 )`
    } else {
      out += inputs[0] > inputs[1] ? 1 : 0 
    }
    out += '\n\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
  }
}

module.exports = (x,y) => {
  let gt = Object.create( proto )

  gt.inputs = [ x,y ]
  gt.name = gt.basename + gen.getUID()

  return gt
}

},{"./gen.js":44}],46:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  name:'gte',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `( ${inputs[0]} >= ${inputs[1]} | 0 )`
    } else {
      out += inputs[0] >= inputs[1] ? 1 : 0 
    }
    out += '\n\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
  }
}

module.exports = (x,y) => {
  let gt = Object.create( proto )

  gt.inputs = [ x,y ]
  gt.name = 'gte' + gen.getUID()

  return gt
}

},{"./gen.js":44}],47:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'gtp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out = `(${inputs[ 0 ]} * ( ( ${inputs[0]} > ${inputs[1]} ) | 0 ) )` 
    } else {
      out = inputs[0] * ( ( inputs[0] > inputs[1] ) | 0 )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let gtp = Object.create( proto )

  gtp.inputs = [ x,y ]

  return gtp
}

},{"./gen.js":44}],48:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

module.exports = ( in1=0 ) => {
  let ugen = {
    inputs: [ in1 ],
    memory: { value: { length:1, idx: null } },
    recorder: null,

    in( v ) {
      if( gen.histories.has( v ) ){
        let memoHistory = gen.histories.get( v )
        ugen.name = memoHistory.name
        return memoHistory
      }

      let obj = {
        gen() {
          let inputs = gen.getInputs( ugen )

          if( ugen.memory.value.idx === null ) {
            gen.requestMemory( ugen.memory )
            gen.memory.heap[ ugen.memory.value.idx ] = in1
          }

          let idx = ugen.memory.value.idx
          
          gen.addToEndBlock( 'memory[ ' + idx + ' ] = ' + inputs[ 0 ] )
          
          // return ugen that is being recorded instead of ssd.
          // this effectively makes a call to ssd.record() transparent to the graph.
          // recording is triggered by prior call to gen.addToEndBlock.
          gen.histories.set( v, obj )

          return inputs[ 0 ]
        },
        name: ugen.name + '_in'+gen.getUID(),
        memory: ugen.memory
      }

      this.inputs[ 0 ] = v
      
      ugen.recorder = obj

      return obj
    },
    
    out: {
            
      gen() {
        if( ugen.memory.value.idx === null ) {
          if( gen.histories.get( ugen.inputs[0] ) === undefined ) {
            gen.histories.set( ugen.inputs[0], ugen.recorder )
          }
          gen.requestMemory( ugen.memory )
          gen.memory.heap[ ugen.memory.value.idx ] = parseFloat( in1 )
        }
        let idx = ugen.memory.value.idx
         
        return 'memory[ ' + idx + ' ] '
      },
    },

    uid: gen.getUID(),
  }
  
  ugen.out.memory = ugen.memory 

  ugen.name = 'history' + ugen.uid
  ugen.out.name = ugen.name + '_out'
  ugen.in._name  = ugen.name = '_in'

  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        gen.memory.heap[ this.memory.value.idx ] = v 
      }
    }
  })

  return ugen
}

},{"./gen.js":44}],49:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'ifelse',

  gen() {
    let conditionals = this.inputs[0],
        defaultValue = gen.getInput( conditionals[ conditionals.length - 1] ),
        out = `  var ${this.name}_out = ${defaultValue}\n` 

    //console.log( 'conditionals:', this.name, conditionals )

    //console.log( 'defaultValue:', defaultValue )

    for( let i = 0; i < conditionals.length - 2; i+= 2 ) {
      let isEndBlock = i === conditionals.length - 3,
          cond  = gen.getInput( conditionals[ i ] ),
          preblock = conditionals[ i+1 ],
          block, blockName, output

      //console.log( 'pb', preblock )

      if( typeof preblock === 'number' ){
        block = preblock
        blockName = null
      }else{
        if( gen.memo[ preblock.name ] === undefined ) {
          // used to place all code dependencies in appropriate blocks
          gen.startLocalize()

          gen.getInput( preblock )

          block = gen.endLocalize()
          blockName = block[0]
          block = block[ 1 ].join('')
          block = '  ' + block.replace( /\n/gi, '\n  ' )
        }else{
          block = ''
          blockName = gen.memo[ preblock.name ]
        }
      }

      output = blockName === null ? 
        `  ${this.name}_out = ${block}` :
        `${block}  ${this.name}_out = ${blockName}`
      
      if( i===0 ) out += ' '
      out += 
` if( ${cond} === 1 ) {
${output}
  }`

      if( !isEndBlock ) {
        out += ` else`
      }else{
        out += `\n`
      }
    }

    gen.memo[ this.name ] = `${this.name}_out`

    return [ `${this.name}_out`, out ]
  }
}

module.exports = ( ...args  ) => {
  let ugen = Object.create( proto ),
      conditions = Array.isArray( args[0] ) ? args[0] : args

  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ conditions ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],50:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename:'in',

  gen() {
    const isWorklet = gen.mode === 'worklet'

    if( isWorklet ) {
      gen.inputs.add( this )
    }else{
      gen.parameters.add( this.name )
    }

    gen.memo[ this.name ] = isWorklet === true ? this.name + '[i]' : this.name

    return gen.memo[ this.name ]
  } 
}

module.exports = ( name, inputNumber=0, channelNumber=0, defaultValue=0, min=0, max=1 ) => {
  let input = Object.create( proto )

  input.id   = gen.getUID()
  input.name = name !== undefined ? name : `${input.basename}${input.id}`
  Object.assign( input, { defaultValue, min, max, inputNumber, channelNumber })

  input[0] = {
    gen() {
      if( ! gen.parameters.has( input.name ) ) gen.parameters.add( input.name )
      return input.name + '[0]'
    }
  }
  input[1] = {
    gen() {
      if( ! gen.parameters.has( input.name ) ) gen.parameters.add( input.name )
      return input.name + '[1]'
    }
  }


  return input
}

},{"./gen.js":44}],51:[function(require,module,exports){
'use strict'

const library = {
  export( destination ) {
    if( destination === window ) {
      destination.ssd = library.history    // history is window object property, so use ssd as alias
      destination.input = library.in       // in is a keyword in javascript
      destination.ternary = library.switch // switch is a keyword in javascript

      delete library.history
      delete library.in
      delete library.switch
    }

    Object.assign( destination, library )

    Object.defineProperty( library, 'samplerate', {
      get() { return library.gen.samplerate },
      set(v) {}
    })

    library.in = destination.input
    library.history = destination.ssd
    library.switch = destination.ternary

    destination.clip = library.clamp
  },

  gen:      require( './gen.js' ),
  
  abs:      require( './abs.js' ),
  round:    require( './round.js' ),
  param:    require( './param.js' ),
  add:      require( './add.js' ),
  sub:      require( './sub.js' ),
  mul:      require( './mul.js' ),
  div:      require( './div.js' ),
  accum:    require( './accum.js' ),
  counter:  require( './counter.js' ),
  sin:      require( './sin.js' ),
  cos:      require( './cos.js' ),
  tan:      require( './tan.js' ),
  tanh:     require( './tanh.js' ),
  asin:     require( './asin.js' ),
  acos:     require( './acos.js' ),
  atan:     require( './atan.js' ),  
  phasor:   require( './phasor.js' ),
  data:     require( './data.js' ),
  peek:     require( './peek.js' ),
  cycle:    require( './cycle.js' ),
  history:  require( './history.js' ),
  delta:    require( './delta.js' ),
  floor:    require( './floor.js' ),
  ceil:     require( './ceil.js' ),
  min:      require( './min.js' ),
  max:      require( './max.js' ),
  sign:     require( './sign.js' ),
  dcblock:  require( './dcblock.js' ),
  memo:     require( './memo.js' ),
  rate:     require( './rate.js' ),
  wrap:     require( './wrap.js' ),
  mix:      require( './mix.js' ),
  clamp:    require( './clamp.js' ),
  poke:     require( './poke.js' ),
  delay:    require( './delay.js' ),
  fold:     require( './fold.js' ),
  mod :     require( './mod.js' ),
  sah :     require( './sah.js' ),
  noise:    require( './noise.js' ),
  not:      require( './not.js' ),
  gt:       require( './gt.js' ),
  gte:      require( './gte.js' ),
  lt:       require( './lt.js' ), 
  lte:      require( './lte.js' ), 
  bool:     require( './bool.js' ),
  gate:     require( './gate.js' ),
  train:    require( './train.js' ),
  slide:    require( './slide.js' ),
  in:       require( './in.js' ),
  t60:      require( './t60.js'),
  mtof:     require( './mtof.js'),
  ltp:      require( './ltp.js'),        // TODO: test
  gtp:      require( './gtp.js'),        // TODO: test
  switch:   require( './switch.js' ),
  mstosamps:require( './mstosamps.js' ), // TODO: needs test,
  selector: require( './selector.js' ),
  utilities:require( './utilities.js' ),
  pow:      require( './pow.js' ),
  attack:   require( './attack.js' ),
  decay:    require( './decay.js' ),
  windows:  require( './windows.js' ),
  env:      require( './env.js' ),
  ad:       require( './ad.js'  ),
  adsr:     require( './adsr.js' ),
  ifelse:   require( './ifelseif.js' ),
  bang:     require( './bang.js' ),
  and:      require( './and.js' ),
  pan:      require( './pan.js' ),
  eq:       require( './eq.js' ),
  neq:      require( './neq.js' ),
  exp:      require( './exp.js' ),
  process:  require( './process.js' ),
  seq:      require( './seq.js' )
}

library.gen.lib = library

module.exports = library

},{"./abs.js":13,"./accum.js":14,"./acos.js":15,"./ad.js":16,"./add.js":17,"./adsr.js":18,"./and.js":19,"./asin.js":20,"./atan.js":21,"./attack.js":22,"./bang.js":23,"./bool.js":24,"./ceil.js":25,"./clamp.js":26,"./cos.js":27,"./counter.js":28,"./cycle.js":29,"./data.js":30,"./dcblock.js":31,"./decay.js":32,"./delay.js":33,"./delta.js":34,"./div.js":35,"./env.js":36,"./eq.js":37,"./exp.js":38,"./floor.js":41,"./fold.js":42,"./gate.js":43,"./gen.js":44,"./gt.js":45,"./gte.js":46,"./gtp.js":47,"./history.js":48,"./ifelseif.js":49,"./in.js":50,"./lt.js":52,"./lte.js":53,"./ltp.js":54,"./max.js":55,"./memo.js":56,"./min.js":57,"./mix.js":58,"./mod.js":59,"./mstosamps.js":60,"./mtof.js":61,"./mul.js":62,"./neq.js":63,"./noise.js":64,"./not.js":65,"./pan.js":66,"./param.js":67,"./peek.js":68,"./phasor.js":69,"./poke.js":70,"./pow.js":71,"./process.js":72,"./rate.js":73,"./round.js":74,"./sah.js":75,"./selector.js":76,"./seq.js":77,"./sign.js":78,"./sin.js":79,"./slide.js":80,"./sub.js":81,"./switch.js":82,"./t60.js":83,"./tan.js":84,"./tanh.js":85,"./train.js":86,"./utilities.js":87,"./windows.js":88,"./wrap.js":89}],52:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'lt',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `(( ${inputs[0]} < ${inputs[1]}) | 0  )`
    } else {
      out += inputs[0] < inputs[1] ? 1 : 0 
    }
    out += '\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (x,y) => {
  let lt = Object.create( proto )

  lt.inputs = [ x,y ]
  lt.name = lt.basename + gen.getUID()

  return lt
}

},{"./gen.js":44}],53:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'lte',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `( ${inputs[0]} <= ${inputs[1]} | 0  )`
    } else {
      out += inputs[0] <= inputs[1] ? 1 : 0 
    }
    out += '\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (x,y) => {
  let lt = Object.create( proto )

  lt.inputs = [ x,y ]
  lt.name = 'lte' + gen.getUID()

  return lt
}

},{"./gen.js":44}],54:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'ltp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out = `(${inputs[ 0 ]} * (( ${inputs[0]} < ${inputs[1]} ) | 0 ) )` 
    } else {
      out = inputs[0] * (( inputs[0] < inputs[1] ) | 0 )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let ltp = Object.create( proto )

  ltp.inputs = [ x,y ]

  return ltp
}

},{"./gen.js":44}],55:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'max',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.max' : Math.max })

      out = `${ref}max( ${inputs[0]}, ${inputs[1]} )`

    } else {
      out = Math.max( parseFloat( inputs[0] ), parseFloat( inputs[1] ) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let max = Object.create( proto )

  max.inputs = [ x,y ]

  return max
}

},{"./gen.js":44}],56:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename:'memo',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = ${inputs[0]}\n`

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  } 
}

module.exports = (in1,memoName) => {
  let memo = Object.create( proto )
  
  memo.inputs = [ in1 ]
  memo.id   = gen.getUID()
  memo.name = memoName !== undefined ? memoName + '_' + gen.getUID() : `${memo.basename}${memo.id}`

  return memo
}

},{"./gen.js":44}],57:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'min',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.min' : Math.min })

      out = `${ref}min( ${inputs[0]}, ${inputs[1]} )`

    } else {
      out = Math.min( parseFloat( inputs[0] ), parseFloat( inputs[1] ) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let min = Object.create( proto )

  min.inputs = [ x,y ]

  return min
}

},{"./gen.js":44}],58:[function(require,module,exports){
'use strict'

let gen = require('./gen.js'),
    add = require('./add.js'),
    mul = require('./mul.js'),
    sub = require('./sub.js'),
    memo= require('./memo.js')

module.exports = ( in1, in2, t=.5 ) => {
  let ugen = memo( add( mul(in1, sub(1,t ) ), mul( in2, t ) ) )
  ugen.name = 'mix' + gen.getUID()

  return ugen
}

},{"./add.js":17,"./gen.js":44,"./memo.js":56,"./mul.js":62,"./sub.js":81}],59:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

module.exports = (...args) => {
  let mod = {
    id:     gen.getUID(),
    inputs: args,

    gen() {
      let inputs = gen.getInputs( this ),
          out='(',
          diff = 0, 
          numCount = 0,
          lastNumber = inputs[ 0 ],
          lastNumberIsUgen = isNaN( lastNumber ), 
          modAtEnd = false

      inputs.forEach( (v,i) => {
        if( i === 0 ) return

        let isNumberUgen = isNaN( v ),
            isFinalIdx   = i === inputs.length - 1

        if( !lastNumberIsUgen && !isNumberUgen ) {
          lastNumber = lastNumber % v
          out += lastNumber
        }else{
          out += `${lastNumber} % ${v}`
        }

        if( !isFinalIdx ) out += ' % ' 
      })

      out += ')'

      return out
    }
  }
  
  return mod
}

},{"./gen.js":44}],60:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'mstosamps',

  gen() {
    let out,
        inputs = gen.getInputs( this ),
        returnValue

    if( isNaN( inputs[0] ) ) {
      out = `  var ${this.name } = ${gen.samplerate} / 1000 * ${inputs[0]} \n\n`
     
      gen.memo[ this.name ] = out
      
      returnValue = [ this.name, out ]
    } else {
      out = gen.samplerate / 1000 * this.inputs[0]

      returnValue = out
    }    

    return returnValue
  }
}

module.exports = x => {
  let mstosamps = Object.create( proto )

  mstosamps.inputs = [ x ]
  mstosamps.name = proto.basename + gen.getUID()

  return mstosamps
}

},{"./gen.js":44}],61:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'mtof',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: Math.exp })

      out = `( ${this.tuning} * gen.exp( .057762265 * (${inputs[0]} - 69) ) )`

    } else {
      out = this.tuning * Math.exp( .057762265 * ( inputs[0] - 69) )
    }
    
    return out
  }
}

module.exports = ( x, props ) => {
  let ugen = Object.create( proto ),
      defaults = { tuning:440 }
  
  if( props !== undefined ) Object.assign( props.defaults )

  Object.assign( ugen, defaults )
  ugen.inputs = [ x ]
  

  return ugen
}

},{"./gen.js":44}],62:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = {
  basename: 'mul',

  gen() {
    let inputs = gen.getInputs( this ),
        out = `  var ${this.name} = `,
        sum = 1, numCount = 0, mulAtEnd = false, alreadyFullSummed = true

    inputs.forEach( (v,i) => {
      if( isNaN( v ) ) {
        out += v
        if( i < inputs.length -1 ) {
          mulAtEnd = true
          out += ' * '
        }
        alreadyFullSummed = false
      }else{
        if( i === 0 ) {
          sum = v
        }else{
          sum *= parseFloat( v )
        }
        numCount++
      }
    })

    if( numCount > 0 ) {
      out += mulAtEnd || alreadyFullSummed ? sum : ' * ' + sum
    }

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = ( ...args ) => {
  const mul = Object.create( proto )
  
  Object.assign( mul, {
      id:     gen.getUID(),
      inputs: args,
  })
  
  mul.name = mul.basename + mul.id

  return mul
}

},{"./gen.js":44}],63:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'neq',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = /*this.inputs[0] !== this.inputs[1] ? 1 :*/ `  var ${this.name} = (${inputs[0]} !== ${inputs[1]}) | 0\n\n`

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],64:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'noise',

  gen() {
    let out

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    gen.closures.add({ 'noise' : isWorklet ? 'Math.random' : Math.random })

    out = `  var ${this.name} = ${ref}noise()\n`
    
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = x => {
  let noise = Object.create( proto )
  noise.name = proto.name + gen.getUID()

  return noise
}

},{"./gen.js":44}],65:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'not',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) ) {
      out = `( ${inputs[0]} === 0 ? 1 : 0 )`
    } else {
      out = !inputs[0] === 0 ? 1 : 0
    }
    
    return out
  }
}

module.exports = x => {
  let not = Object.create( proto )

  not.inputs = [ x ]

  return not
}

},{"./gen.js":44}],66:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' ),
    data = require( './data.js' ),
    peek = require( './peek.js' ),
    mul  = require( './mul.js' )

let proto = {
  basename:'pan', 
  initTable() {    
    let bufferL = new Float32Array( 1024 ),
        bufferR = new Float32Array( 1024 )

    const angToRad = Math.PI / 180
    for( let i = 0; i < 1024; i++ ) { 
      let pan = i * ( 90 / 1024 )
      bufferL[i] = Math.cos( pan * angToRad ) 
      bufferR[i] = Math.sin( pan * angToRad )
    }

    gen.globals.panL = data( bufferL, 1, { immutable:true })
    gen.globals.panR = data( bufferR, 1, { immutable:true })
  }

}

module.exports = ( leftInput, rightInput, pan =.5, properties ) => {
  if( gen.globals.panL === undefined ) proto.initTable()

  let ugen = Object.create( proto )

  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ leftInput, rightInput ],
    left:    mul( leftInput, peek( gen.globals.panL, pan, { boundmode:'clamp' }) ),
    right:   mul( rightInput, peek( gen.globals.panR, pan, { boundmode:'clamp' }) )
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./data.js":30,"./gen.js":44,"./mul.js":62,"./peek.js":68}],67:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename: 'param',

  gen() {
    gen.requestMemory( this.memory )
    
    gen.params.add( this )

    const isWorklet = gen.mode === 'worklet'

    if( isWorklet ) gen.parameters.add( this.name )

    this.value = this.initialValue

    gen.memo[ this.name ] = isWorklet ? this.name : `memory[${this.memory.value.idx}]`

    return gen.memo[ this.name ]
  } 
}

module.exports = ( propName=0, value=0, min=0, max=1 ) => {
  let ugen = Object.create( proto )
  
  if( typeof propName !== 'string' ) {
    ugen.name = ugen.basename + gen.getUID()
    ugen.initialValue = propName
  }else{
    ugen.name = propName
    ugen.initialValue = value
  }

  ugen.min = min
  ugen.max = max
  ugen.defaultValue = ugen.initialValue

  // for storing worklet nodes once they're instantiated
  ugen.waapi = null

  ugen.isWorklet = gen.mode === 'worklet'

  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }else{
        return this.initialValue
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        if( this.isWorklet && this.waapi !== null ) {
          this.waapi.value = v
        }else{
          gen.memory.heap[ this.memory.value.idx ] = v
        } 
      }
    }
  })

  ugen.memory = {
    value: { length:1, idx:null }
  }

  return ugen
}

},{"./gen.js":44}],68:[function(require,module,exports){

const gen  = require('./gen.js'),
      dataUgen = require('./data.js')

let proto = {
  basename:'peek',

  gen() {
    let genName = 'gen.' + this.name,
        inputs = gen.getInputs( this ),
        out, functionBody, next, lengthIsLog2, idx
    
    idx = inputs[1]
    lengthIsLog2 = (Math.log2( this.data.buffer.length ) | 0)  === Math.log2( this.data.buffer.length )

    if( this.mode !== 'simple' ) {

    functionBody = `  var ${this.name}_dataIdx  = ${idx}, 
      ${this.name}_phase = ${this.mode === 'samples' ? inputs[0] : inputs[0] + ' * ' + (this.data.buffer.length) }, 
      ${this.name}_index = ${this.name}_phase | 0,\n`

    if( this.boundmode === 'wrap' ) {
      next = lengthIsLog2 ?
      `( ${this.name}_index + 1 ) & (${this.data.buffer.length} - 1)` :
      `${this.name}_index + 1 >= ${this.data.buffer.length} ? ${this.name}_index + 1 - ${this.data.buffer.length} : ${this.name}_index + 1`
    }else if( this.boundmode === 'clamp' ) {
      next = 
        `${this.name}_index + 1 >= ${this.data.buffer.length - 1} ? ${this.data.buffer.length - 1} : ${this.name}_index + 1`
    } else if( this.boundmode === 'fold' || this.boundmode === 'mirror' ) {
      next = 
        `${this.name}_index + 1 >= ${this.data.buffer.length - 1} ? ${this.name}_index - ${this.data.buffer.length - 1} : ${this.name}_index + 1`
    }else{
       next = 
      `${this.name}_index + 1`     
    }

    if( this.interp === 'linear' ) {      
    functionBody += `      ${this.name}_frac  = ${this.name}_phase - ${this.name}_index,
      ${this.name}_base  = memory[ ${this.name}_dataIdx +  ${this.name}_index ],
      ${this.name}_next  = ${next},`
      
      if( this.boundmode === 'ignore' ) {
        functionBody += `
      ${this.name}_out   = ${this.name}_index >= ${this.data.buffer.length - 1} || ${this.name}_index < 0 ? 0 : ${this.name}_base + ${this.name}_frac * ( memory[ ${this.name}_dataIdx + ${this.name}_next ] - ${this.name}_base )\n\n`
      }else{
        functionBody += `
      ${this.name}_out   = ${this.name}_base + ${this.name}_frac * ( memory[ ${this.name}_dataIdx + ${this.name}_next ] - ${this.name}_base )\n\n`
      }
    }else{
      functionBody += `      ${this.name}_out = memory[ ${this.name}_dataIdx + ${this.name}_index ]\n\n`
    }

    } else { // mode is simple
      functionBody = `memory[ ${idx} + ${ inputs[0] } ]`
      
      return functionBody
    }

    gen.memo[ this.name ] = this.name + '_out'

    return [ this.name+'_out', functionBody ]
  },

  defaults : { channels:1, mode:'phase', interp:'linear', boundmode:'wrap' }
}

module.exports = ( input_data, index=0, properties ) => {
  let ugen = Object.create( proto )

  //console.log( dataUgen, gen.data )

  // XXX why is dataUgen not the actual function? some type of browserify nonsense...
  const finalData = typeof input_data.basename === 'undefined' ? gen.lib.data( input_data ) : input_data

  Object.assign( ugen, 
    { 
      'data':     finalData,
      dataName:   finalData.name,
      uid:        gen.getUID(),
      inputs:     [ index, finalData ],
    },
    proto.defaults,
    properties 
  )
  
  ugen.name = ugen.basename + ugen.uid

  return ugen
}


},{"./data.js":30,"./gen.js":44}],69:[function(require,module,exports){
'use strict'

let gen   = require( './gen.js' ),
    accum = require( './accum.js' ),
    mul   = require( './mul.js' ),
    proto = { basename:'phasor' },
    div   = require( './div.js' )

const defaults = { min: -1, max: 1 }

module.exports = ( frequency = 1, reset = 0, _props ) => {
  const props = Object.assign( {}, defaults, _props )

  const range = props.max - props.min

  const ugen = typeof frequency === 'number' 
    ? accum( (frequency * range) / gen.samplerate, reset, props ) 
    : accum( 
        div( 
          mul( frequency, range ),
          gen.samplerate
        ), 
        reset, props 
    )

  ugen.name = proto.basename + gen.getUID()

  return ugen
}

},{"./accum.js":14,"./div.js":35,"./gen.js":44,"./mul.js":62}],70:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    mul  = require('./mul.js'),
    wrap = require('./wrap.js')

let proto = {
  basename:'poke',

  gen() {
    let dataName = 'memory',
        inputs = gen.getInputs( this ),
        idx, out, wrapped
    
    idx = this.data.gen()

    //gen.requestMemory( this.memory )
    //wrapped = wrap( this.inputs[1], 0, this.dataLength ).gen()
    //idx = wrapped[0]
    //gen.functionBody += wrapped[1]
    let outputStr = this.inputs[1] === 0 ?
      `  ${dataName}[ ${idx} ] = ${inputs[0]}\n` :
      `  ${dataName}[ ${idx} + ${inputs[1]} ] = ${inputs[0]}\n`

    if( this.inline === undefined ) {
      gen.functionBody += outputStr
    }else{
      return [ this.inline, outputStr ]
    }
  }
}
module.exports = ( data, value, index, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { channels:1 } 

  if( properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, { 
    data,
    dataName:   data.name,
    dataLength: data.buffer.length,
    uid:        gen.getUID(),
    inputs:     [ value, index ],
  },
  defaults )


  ugen.name = ugen.basename + ugen.uid
  
  gen.histories.set( ugen.name, ugen )

  return ugen
}

},{"./gen.js":44,"./mul.js":62,"./wrap.js":89}],71:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'pow',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ 'pow': isWorklet ? 'Math.pow' : Math.pow })

      out = `${ref}pow( ${inputs[0]}, ${inputs[1]} )` 

    } else {
      if( typeof inputs[0] === 'string' && inputs[0][0] === '(' ) {
        inputs[0] = inputs[0].slice(1,-1)
      }
      if( typeof inputs[1] === 'string' && inputs[1][0] === '(' ) {
        inputs[1] = inputs[1].slice(1,-1)
      }

      out = Math.pow( parseFloat( inputs[0] ), parseFloat( inputs[1]) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let pow = Object.create( proto )

  pow.inputs = [ x,y ]
  pow.id = gen.getUID()
  pow.name = `${pow.basename}{pow.id}`

  return pow
}

},{"./gen.js":44}],72:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')
const proto = {
  basename:'process',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    gen.closures.add({ [''+this.funcname] : this.func })

    out = `  var ${this.name} = gen['${this.funcname}'](`

    inputs.forEach( (v,i,arr ) => {
      out += arr[ i ]
      if( i < arr.length - 1 ) out += ','
    })

    out += ')\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (...args) => {
  const process = {}// Object.create( proto )
  const id = gen.getUID()
  process.name = 'process' + id 

  process.func = new Function( ...args )

  //gen.globals[ process.name ] = process.func

  process.call = function( ...args  ) {
    const output = Object.create( proto )
    output.funcname = process.name
    output.func = process.func
    output.name = 'process_out_' + id
    output.process = process

    output.inputs = args

    return output
  }

  return process 
}

},{"./gen.js":44}],73:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' ),
    delta   = require( './delta.js' ),
    wrap    = require( './wrap.js' )

let proto = {
  basename:'rate',

  gen() {
    let inputs = gen.getInputs( this ),
        phase  = history(),
        inMinus1 = history(),
        genName = 'gen.' + this.name,
        filter, sum, out

    gen.closures.add({ [ this.name ]: this }) 

    out = 
` var ${this.name}_diff = ${inputs[0]} - ${genName}.lastSample
  if( ${this.name}_diff < -.5 ) ${this.name}_diff += 1
  ${genName}.phase += ${this.name}_diff * ${inputs[1]}
  if( ${genName}.phase > 1 ) ${genName}.phase -= 1
  ${genName}.lastSample = ${inputs[0]}
`
    out = ' ' + out

    return [ genName + '.phase', out ]
  }
}

module.exports = ( in1, rate ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    phase:      0,
    lastSample: 0,
    uid:        gen.getUID(),
    inputs:     [ in1, rate ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./add.js":17,"./delta.js":34,"./gen.js":44,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81,"./wrap.js":89}],74:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'round',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.round' : Math.round })

      out = `${ref}round( ${inputs[0]} )`

    } else {
      out = Math.round( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let round = Object.create( proto )

  round.inputs = [ x ]

  return round
}

},{"./gen.js":44}],75:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' )

let proto = {
  basename:'sah',

  gen() {
    let inputs = gen.getInputs( this ), out

    //gen.data[ this.name ] = 0
    //gen.data[ this.name + '_control' ] = 0

    gen.requestMemory( this.memory )


    out = 
` var ${this.name}_control = memory[${this.memory.control.idx}],
      ${this.name}_trigger = ${inputs[1]} > ${inputs[2]} ? 1 : 0

  if( ${this.name}_trigger !== ${this.name}_control  ) {
    if( ${this.name}_trigger === 1 ) 
      memory[${this.memory.value.idx}] = ${inputs[0]}
    
    memory[${this.memory.control.idx}] = ${this.name}_trigger
  }
`
    
    gen.memo[ this.name ] = `memory[${this.memory.value.idx}]`//`gen.data.${this.name}`

    return [ `memory[${this.memory.value.idx}]`, ' ' +out ]
  }
}

module.exports = ( in1, control, threshold=0, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { init:0 }

  if( properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, { 
    lastSample: 0,
    uid:        gen.getUID(),
    inputs:     [ in1, control,threshold ],
    memory: {
      control: { idx:null, length:1 },
      value:   { idx:null, length:1 },
    }
  },
  defaults )
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],76:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'selector',

  gen() {
    let inputs = gen.getInputs( this ), out, returnValue = 0
    
    switch( inputs.length ) {
      case 2 :
        returnValue = inputs[1]
        break;
      case 3 :
        out = `  var ${this.name}_out = ${inputs[0]} === 1 ? ${inputs[1]} : ${inputs[2]}\n\n`;
        returnValue = [ this.name + '_out', out ]
        break;  
      default:
        out = 
` var ${this.name}_out = 0
  switch( ${inputs[0]} + 1 ) {\n`

        for( let i = 1; i < inputs.length; i++ ){
          out +=`    case ${i}: ${this.name}_out = ${inputs[i]}; break;\n` 
        }

        out += '  }\n\n'
        
        returnValue = [ this.name + '_out', ' ' + out ]
    }

    gen.memo[ this.name ] = this.name + '_out'

    return returnValue
  },
}

module.exports = ( ...inputs ) => {
  let ugen = Object.create( proto )
  
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],77:[function(require,module,exports){
'use strict'

let gen   = require( './gen.js' ),
    accum = require( './accum.js' ),
    counter= require( './counter.js' ),
    peek  = require( './peek.js' ),
    ssd   = require( './history.js' ),
    data  = require( './data.js' ),
    proto = { basename:'seq' }

module.exports = ( durations = 11025, values = [0,1], phaseIncrement = 1) => {
  let clock
  
  if( Array.isArray( durations ) ) {
    // we want a counter that is using our current
    // rate value, but we want the rate value to be derived from
    // the counter. must insert a single-sample dealy to avoid
    // infinite loop.
    const clock2 = counter( 0, 0, durations.length )
    const __durations = peek( data( durations ), clock2, { mode:'simple' }) 
    clock = counter( phaseIncrement, 0, __durations )
    
    // add one sample delay to avoid codegen loop
    const s = ssd()
    s.in( clock.wrap )
    clock2.inputs[0] = s.out
  }else{
    // if the rate argument is a single value we don't need to
    // do anything tricky.
    clock = counter( phaseIncrement, 0, durations )
  }
  
  const stepper = accum( clock.wrap, 0, { min:0, max:values.length })
   
  const ugen = peek( data( values ), stepper, { mode:'simple' })

  ugen.name = proto.basename + gen.getUID()
  ugen.trigger = clock.wrap

  return ugen
}

},{"./accum.js":14,"./counter.js":28,"./data.js":30,"./gen.js":44,"./history.js":48,"./peek.js":68}],78:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'sign',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.sign' : Math.sign })

      out = `${ref}sign( ${inputs[0]} )`

    } else {
      out = Math.sign( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let sign = Object.create( proto )

  sign.inputs = [ x ]

  return sign
}

},{"./gen.js":44}],79:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'sin',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'sin': isWorklet ? 'Math.sin' : Math.sin })

      out = `${ref}sin( ${inputs[0]} )` 

    } else {
      out = Math.sin( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let sin = Object.create( proto )

  sin.inputs = [ x ]
  sin.id = gen.getUID()
  sin.name = `${sin.basename}{sin.id}`

  return sin
}

},{"./gen.js":44}],80:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' ),
    gt      = require( './gt.js' ),
    div     = require( './div.js' ),
    _switch = require( './switch.js' )

module.exports = ( in1, slideUp = 1, slideDown = 1 ) => {
  let y1 = history(0),
      filter, slideAmount

  //y (n) = y (n-1) + ((x (n) - y (n-1))/slide) 
  slideAmount = _switch( gt(in1,y1.out), slideUp, slideDown )

  filter = memo( add( y1.out, div( sub( in1, y1.out ), slideAmount ) ) )

  y1.in( filter )

  return filter
}

},{"./add.js":17,"./div.js":35,"./gen.js":44,"./gt.js":45,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81,"./switch.js":82}],81:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = {
  basename:'sub',
  gen() {
    let inputs = gen.getInputs( this ),
        out=0,
        diff = 0,
        needsParens = false, 
        numCount = 0,
        lastNumber = inputs[ 0 ],
        lastNumberIsUgen = isNaN( lastNumber ), 
        subAtEnd = false,
        hasUgens = false,
        returnValue = 0

    this.inputs.forEach( value => { if( isNaN( value ) ) hasUgens = true })

    out = '  var ' + this.name + ' = '

    inputs.forEach( (v,i) => {
      if( i === 0 ) return

      let isNumberUgen = isNaN( v ),
          isFinalIdx   = i === inputs.length - 1

      if( !lastNumberIsUgen && !isNumberUgen ) {
        lastNumber = lastNumber - v
        out += lastNumber
        return
      }else{
        needsParens = true
        out += `${lastNumber} - ${v}`
      }

      if( !isFinalIdx ) out += ' - ' 
    })

    out += '\n'

    returnValue = [ this.name, out ]

    gen.memo[ this.name ] = this.name

    return returnValue
  }

}

module.exports = ( ...args ) => {
  let sub = Object.create( proto )

  Object.assign( sub, {
    id:     gen.getUID(),
    inputs: args
  })
       
  sub.name = 'sub' + sub.id

  return sub
}

},{"./gen.js":44}],82:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'switch',

  gen() {
    let inputs = gen.getInputs( this ), out

    if( inputs[1] === inputs[2] ) return inputs[1] // if both potential outputs are the same just return one of them
    
    out = `  var ${this.name}_out = ${inputs[0]} === 1 ? ${inputs[1]} : ${inputs[2]}\n`

    gen.memo[ this.name ] = `${this.name}_out`

    return [ `${this.name}_out`, out ]
  },

}

module.exports = ( control, in1 = 1, in2 = 0 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ control, in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],83:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'t60',

  gen() {
    let out,
        inputs = gen.getInputs( this ),
        returnValue

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ 'exp' ]: isWorklet ? 'Math.exp' : Math.exp })

      out = `  var ${this.name} = ${ref}exp( -6.907755278921 / ${inputs[0]} )\n\n`
     
      gen.memo[ this.name ] = out
      
      returnValue = [ this.name, out ]
    } else {
      out = Math.exp( -6.907755278921 / inputs[0] )

      returnValue = out
    }    

    return returnValue
  }
}

module.exports = x => {
  let t60 = Object.create( proto )

  t60.inputs = [ x ]
  t60.name = proto.basename + gen.getUID()

  return t60
}

},{"./gen.js":44}],84:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'tan',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'tan': isWorklet ? 'Math.tan' : Math.tan })

      out = `${ref}tan( ${inputs[0]} )` 

    } else {
      out = Math.tan( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let tan = Object.create( proto )

  tan.inputs = [ x ]
  tan.id = gen.getUID()
  tan.name = `${tan.basename}{tan.id}`

  return tan
}

},{"./gen.js":44}],85:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'tanh',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'tanh': isWorklet ? 'Math.tan' : Math.tanh })

      out = `${ref}tanh( ${inputs[0]} )` 

    } else {
      out = Math.tanh( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let tanh = Object.create( proto )

  tanh.inputs = [ x ]
  tanh.id = gen.getUID()
  tanh.name = `${tanh.basename}{tanh.id}`

  return tanh
}

},{"./gen.js":44}],86:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    lt      = require( './lt.js' ),
    accum   = require( './accum.js' ),
    div     = require( './div.js' )

module.exports = ( frequency=440, pulsewidth=.5 ) => {
  let graph = lt( accum( div( frequency, 44100 ) ), pulsewidth )

  graph.name = `train${gen.getUID()}`

  return graph
}


},{"./accum.js":14,"./div.js":35,"./gen.js":44,"./lt.js":52}],87:[function(require,module,exports){
'use strict'

const AWPF = require( './external/audioworklet-polyfill.js' ),
      gen  = require( './gen.js' ),
      data = require( './data.js' )

let isStereo = false

const utilities = {
  ctx: null,
  buffers: {},
  isStereo:false,

  clear() {
    if( this.workletNode !== undefined ) {
      this.workletNode.disconnect()
    }else{
      this.callback = () => 0
    }
    this.clear.callbacks.forEach( v => v() )
    this.clear.callbacks.length = 0

    this.isStereo = false

    if( gen.graph !== null ) gen.free( gen.graph )
  },

  createContext( bufferSize = 2048 ) {
    const AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext
    
    // tell polyfill global object and buffersize
    AWPF( window, bufferSize )

    const start = () => {
      if( typeof AC !== 'undefined' ) {
        this.ctx = new AC({ latencyHint:.0125 })

        gen.samplerate = this.ctx.sampleRate

        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
          window.removeEventListener( 'touchstart', start )
        }else{
          window.removeEventListener( 'mousedown', start )
          window.removeEventListener( 'keydown', start )
        }

        const mySource = utilities.ctx.createBufferSource()
        mySource.connect( utilities.ctx.destination )
        mySource.start()
      }
    }

    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
      window.addEventListener( 'touchstart', start )
    }else{
      window.addEventListener( 'mousedown', start )
      window.addEventListener( 'keydown', start )
    }

    return this
  },

  createScriptProcessor() {
    this.node = this.ctx.createScriptProcessor( 1024, 0, 2 )
    this.clearFunction = function() { return 0 }
    if( typeof this.callback === 'undefined' ) this.callback = this.clearFunction

    this.node.onaudioprocess = function( audioProcessingEvent ) {
      var outputBuffer = audioProcessingEvent.outputBuffer;

      var left = outputBuffer.getChannelData( 0 ),
          right= outputBuffer.getChannelData( 1 ),
          isStereo = utilities.isStereo

     for( var sample = 0; sample < left.length; sample++ ) {
        var out = utilities.callback()

        if( isStereo === false ) {
          left[ sample ] = right[ sample ] = out 
        }else{
          left[ sample  ] = out[0]
          right[ sample ] = out[1]
        }
      }
    }

    this.node.connect( this.ctx.destination )

    return this
  },

  // remove starting stuff and add tabs
  prettyPrintCallback( cb ) {
    // get rid of "function gen" and start with parenthesis
    // const shortendCB = cb.toString().slice(9)
    const cbSplit = cb.toString().split('\n')
    const cbTrim = cbSplit.slice( 3, -2 )
    const cbTabbed = cbTrim.map( v => '      ' + v ) 
    
    return cbTabbed.join('\n')
  },

  createParameterDescriptors( cb ) {
    // [{name: 'amplitude', defaultValue: 0.25, minValue: 0, maxValue: 1}];
    let paramStr = ''

    //for( let ugen of cb.params.values() ) {
    //  paramStr += `{ name:'${ugen.name}', defaultValue:${ugen.value}, minValue:${ugen.min}, maxValue:${ugen.max} },\n      `
    //}
    for( let ugen of cb.params.values() ) {
      paramStr += `{ name:'${ugen.name}', automationRate:'k-rate', defaultValue:${ugen.defaultValue}, minValue:${ugen.min}, maxValue:${ugen.max} },\n      `
    }
    return paramStr
  },

  createParameterDereferences( cb ) {
    let str = cb.params.size > 0 ? '\n      ' : ''
    for( let ugen of cb.params.values() ) {
      str += `const ${ugen.name} = parameters.${ugen.name}[0]\n      `
    }

    return str
  },

  createParameterArguments( cb ) {
    let  paramList = ''
    for( let ugen of cb.params.values() ) {
      paramList += ugen.name + '[i],'
    }
    paramList = paramList.slice( 0, -1 )

    return paramList
  },

  createInputDereferences( cb ) {
    let str = cb.inputs.size > 0 ? '\n' : ''
    for( let input of  cb.inputs.values() ) {
      str += `const ${input.name} = inputs[ ${input.inputNumber} ][ ${input.channelNumber} ]\n      `
    }

    return str
  },


  createInputArguments( cb ) {
    let  paramList = ''
    for( let input of cb.inputs.values() ) {
      paramList += input.name + '[i],'
    }
    paramList = paramList.slice( 0, -1 )

    return paramList
  },
      
  createFunctionDereferences( cb ) {
    let memberString = cb.members.size > 0 ? '\n' : ''
    let memo = {}
    for( let dict of cb.members.values() ) {
      const name = Object.keys( dict )[0],
            value = dict[ name ]

      if( memo[ name ] !== undefined ) continue
      memo[ name ] = true

      memberString += `      const ${name} = ${value}\n`
    }

    return memberString
  },

  createWorkletProcessor( graph, name, debug, mem=44100*10 ) {
    //const mem = MemoryHelper.create( 4096, Float64Array )
    const cb = gen.createCallback( graph, mem, debug )
    const inputs = cb.inputs

    // get all inputs and create appropriate audioparam initializers
    const parameterDescriptors = this.createParameterDescriptors( cb )
    const parameterDereferences = this.createParameterDereferences( cb )
    const paramList = this.createParameterArguments( cb )
    const inputDereferences = this.createInputDereferences( cb )
    const inputList = this.createInputArguments( cb )   
    const memberString = this.createFunctionDereferences( cb )

    // change output based on number of channels.
    const genishOutputLine = cb.isStereo === false
      ? `left[ i ] = memory[0]`
      : `left[ i ] = memory[0];\n\t\tright[ i ] = memory[1]\n`

    const prettyCallback = this.prettyPrintCallback( cb )

    /***** begin callback code ****/
    // note that we have to check to see that memory has been passed
    // to the worker before running the callback function, otherwise
    // it can be passed too slowly and fail on occassion

    const workletCode = `
class ${name}Processor extends AudioWorkletProcessor {

  static get parameterDescriptors() {
    const params = [
      ${ parameterDescriptors }      
    ]
    return params
  }
 
  constructor( options ) {
    super( options )
    this.port.onmessage = this.handleMessage.bind( this )
    this.initialized = false
  }

  handleMessage( event ) {
    if( event.data.key === 'init' ) {
      this.memory = event.data.memory
      this.initialized = true
    }else if( event.data.key === 'set' ) {
      this.memory[ event.data.idx ] = event.data.value
    }else if( event.data.key === 'get' ) {
      this.port.postMessage({ key:'return', idx:event.data.idx, value:this.memory[event.data.idx] })     
    }
  }

  process( inputs, outputs, parameters ) {
    if( this.initialized === true ) {
      const output = outputs[0]
      const left   = output[ 0 ]
      const right  = output[ 1 ]
      const len    = left.length
      const memory = this.memory ${parameterDereferences}${inputDereferences}${memberString}

      for( let i = 0; i < len; ++i ) {
        ${prettyCallback}
        ${genishOutputLine}
      }
    }
    return true
  }
}
    
registerProcessor( '${name}', ${name}Processor)`

    
    /***** end callback code *****/


    if( debug === true ) console.log( workletCode )

    const url = window.URL.createObjectURL(
      new Blob(
        [ workletCode ], 
        { type: 'text/javascript' }
      )
    )

    return [ url, workletCode, inputs, cb.params, cb.isStereo ] 
  },

  registeredForNodeAssignment: [],
  register( ugen ) {
    if( this.registeredForNodeAssignment.indexOf( ugen ) === -1 ) {
      this.registeredForNodeAssignment.push( ugen )
    }
  },

  playWorklet( graph, name, debug=false, mem=44100 * 60 ) {
    utilities.clear()

    const [ url, codeString, inputs, params, isStereo ] = utilities.createWorkletProcessor( graph, name, debug, mem )

    const nodePromise = new Promise( (resolve,reject) => {
   
      utilities.ctx.audioWorklet.addModule( url ).then( ()=> {
        const workletNode = new AudioWorkletNode( utilities.ctx, name, { outputChannelCount:[ isStereo ? 2 : 1 ] })

        workletNode.callbacks = {}
        workletNode.onmessage = function( event ) {
          if( event.data.message === 'return' ) {
            workletNode.callbacks[ event.data.idx ]( event.data.value )
            delete workletNode.callbacks[ event.data.idx ]
          }
        }

        workletNode.getMemoryValue = function( idx, cb ) {
          this.workletCallbacks[ idx ] = cb
          this.workletNode.port.postMessage({ key:'get', idx: idx })
        }
        
        workletNode.port.postMessage({ key:'init', memory:gen.memory.heap })
        utilities.workletNode = workletNode

        utilities.registeredForNodeAssignment.forEach( ugen => ugen.node = workletNode )
        utilities.registeredForNodeAssignment.length = 0

        // assign all params as properties of node for easier reference 
        for( let dict of inputs.values() ) {
          const name = Object.keys( dict )[0]
          const param = workletNode.parameters.get( name )
      
          Object.defineProperty( workletNode, name, {
            set( v ) {
              param.value = v
            },
            get() {
              return param.value
            }
          })
        }

        for( let ugen of params.values() ) {
          const name = ugen.name
          const param = workletNode.parameters.get( name )
          ugen.waapi = param 
          // initialize?
          param.value = ugen.defaultValue

          Object.defineProperty( workletNode, name, {
            set( v ) {
              param.value = v
            },
            get() {
              return param.value
            }
          })
        }

        if( utilities.console ) utilities.console.setValue( codeString )

        workletNode.connect( utilities.ctx.destination )

        resolve( workletNode )
      })

    })

    return nodePromise
  },
  
  playGraph( graph, debug, mem=44100*10, memType=Float32Array ) {
    utilities.clear()
    if( debug === undefined ) debug = false
          
    this.isStereo = Array.isArray( graph )

    utilities.callback = gen.createCallback( graph, mem, debug, false, memType )
    
    if( utilities.console ) utilities.console.setValue( utilities.callback.toString() )

    return utilities.callback
  },

  loadSample( soundFilePath, data ) {
    const isLoaded = utilities.buffers[ soundFilePath ] !== undefined

    let req = new XMLHttpRequest()
    req.open( 'GET', soundFilePath, true )
    req.responseType = 'arraybuffer' 
    
    let promise = new Promise( (resolve,reject) => {
      if( !isLoaded ) {
        req.onload = function() {
          var audioData = req.response

          utilities.ctx.decodeAudioData( audioData, (buffer) => {
            data.buffer = buffer.getChannelData(0)
            utilities.buffers[ soundFilePath ] = data.buffer
            resolve( data.buffer )
          })
        }
      }else{
        setTimeout( ()=> resolve( utilities.buffers[ soundFilePath ] ), 0 )
      }
    })

    if( !isLoaded ) req.send()

    return promise
  }

}

utilities.clear.callbacks = []

module.exports = utilities

},{"./data.js":30,"./external/audioworklet-polyfill.js":39,"./gen.js":44}],88:[function(require,module,exports){
'use strict'

/*
 * many windows here adapted from https://github.com/corbanbrook/dsp.js/blob/master/dsp.js
 * starting at line 1427
 * taken 8/15/16
*/ 

const windows = module.exports = { 
  bartlett( length, index ) {
    return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2)) 
  },

  bartlettHann( length, index ) {
    return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos( 2 * Math.PI * index / (length - 1))
  },

  blackman( length, index, alpha ) {
    let a0 = (1 - alpha) / 2,
        a1 = 0.5,
        a2 = alpha / 2

    return a0 - a1 * Math.cos(2 * Math.PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1))
  },

  cosine( length, index ) {
    return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2)
  },

  gauss( length, index, alpha ) {
    return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2))
  },

  hamming( length, index ) {
    return 0.54 - 0.46 * Math.cos( Math.PI * 2 * index / (length - 1))
  },

  hann( length, index ) {
    return 0.5 * (1 - Math.cos( Math.PI * 2 * index / (length - 1)) )
  },

  lanczos( length, index ) {
    let x = 2 * index / (length - 1) - 1;
    return Math.sin(Math.PI * x) / (Math.PI * x)
  },

  rectangular( length, index ) {
    return 1
  },

  triangular( length, index ) {
    return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2))
  },

  // parabola
  welch( length, _index, ignore, shift=0 ) {
    //w[n] = 1 - Math.pow( ( n - ( (N-1) / 2 ) ) / (( N-1 ) / 2 ), 2 )
    const index = shift === 0 ? _index : (_index + Math.floor( shift * length )) % length
    const n_1_over2 = (length - 1) / 2 

    return 1 - Math.pow( ( index - n_1_over2 ) / n_1_over2, 2 )
  },
  inversewelch( length, _index, ignore, shift=0 ) {
    //w[n] = 1 - Math.pow( ( n - ( (N-1) / 2 ) ) / (( N-1 ) / 2 ), 2 )
    let index = shift === 0 ? _index : (_index + Math.floor( shift * length )) % length
    const n_1_over2 = (length - 1) / 2

    return Math.pow( ( index - n_1_over2 ) / n_1_over2, 2 )
  },

  parabola( length, index ) {
    if( index <= length / 2 ) {
      return windows.inversewelch( length / 2, index ) - 1
    }else{
      return 1 - windows.inversewelch( length / 2, index - length / 2 )
    }
  },

  exponential( length, index, alpha ) {
    return Math.pow( index / length, alpha )
  },

  linear( length, index ) {
    return index / length
  }
}

},{}],89:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    floor= require('./floor.js'),
    sub  = require('./sub.js'),
    memo = require('./memo.js')

let proto = {
  basename:'wrap',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        signal = inputs[0], min = inputs[1], max = inputs[2],
        out, diff

    //out = `(((${inputs[0]} - ${this.min}) % ${diff}  + ${diff}) % ${diff} + ${this.min})`
    //const long numWraps = long((v-lo)/range) - (v < lo);
    //return v - range * double(numWraps);   
    
    if( this.min === 0 ) {
      diff = max
    }else if ( isNaN( max ) || isNaN( min ) ) {
      diff = `${max} - ${min}`
    }else{
      diff = max - min
    }

    out =
` var ${this.name} = ${inputs[0]}
  if( ${this.name} < ${this.min} ) ${this.name} += ${diff}
  else if( ${this.name} > ${this.max} ) ${this.name} -= ${diff}

`

    return [ this.name, ' ' + out ]
  },
}

module.exports = ( in1, min=0, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1, min, max ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./floor.js":41,"./gen.js":44,"./memo.js":56,"./sub.js":81}],90:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":12,"has":216,"has-symbols":213}],91:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Analysis = {
  create( Audio ) {
    const analysis = {}

    for( let analysisName in Gibberish.analysis ) {
      const gibberishConstructor = Gibberish.analysis[ analysisName ]

      const methods = Analysis.descriptions[ analysisName ] === undefined ? null : Analysis.descriptions[ analysisName ].methods
      const description = { 
        properties: { type:'analysis' },
        name:analysisName,
        methods,
        category:'analysis'
      }

      const constructor = Ugen( gibberishConstructor, description, Audio, false, true )
      analysis[ analysisName ] = function( ...args ) {
        const ugen = constructor( ...args )
        Gibberish.worklet.ugens.set( ugen.id, ugen )
        ugen.out = ugen.__wrapped__.out
        
        if( analysisName === 'Follow' ) {
          let m = ugen.__wrapped__.multiplier || 1
          Object.defineProperty( ugen, 'multiplier', {
            configurable:true,
            get() { return m },
            set(v) { m = v; ugen.__wrapped__.multiplier = m }
          }) 
          let o = ugen.__wrapped__.offset || 0
          Object.defineProperty( ugen, 'offset', {
            configurable:true,
            get() { return o },
            set(v) { o = v; ugen.__wrapped__.offset = o }
          }) 
        }
        return ugen
      } 

    }
    return analysis
  },

  descriptions: {
    //SSD: { methods:[ 'listen' ] }
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Analysis 

},{"./ugen.js":128,"gibberish-dsp":174}],92:[function(require,module,exports){
const Gibberish   = require( 'gibberish-dsp' )
const Ugen        = require( './ugen.js' )
const Instruments = require( './instruments.js' )
const Oscillators = require( './oscillators.js' )
const Effects     = require( './effects.js' )
const Filters     = require( './filters.js' )
const Binops      = require( './binops.js' )
const Analysis    = require( './analysis.js' )
const Envelopes   = require( './envelopes.js' )
const Busses      = require( './busses.js' )
const Ensemble    = require( './ensemble.js' )
const Utility     = require( './utility.js' )
const Freesound   = require( './freesound.js' )
const Gen         = require( './gen.js' )
const WavePattern = require( './wavePattern.js' )
const WaveObjects = require( './waveObjects.js' )
//const Core        = require( 'gibber.core.lib' )
const AWPF        = require( './external/audioworklet-polyfill.js' )
//const Arp         = require( './arp.js' )

const Audio = {
  Clock: require( './clock.js' ),
  Theory: require( './theory.js' ),
  Presets: require( './presets.js' ),
  __Make: require( './make.js' ),
  initialized:false,
  autoConnect:true,
  shouldDelay:false,
  instruments:{},
  oscillators:{},
  effects:{},
  exportTarget:null,

  export( obj ) {
    if( Audio.initialized ){ 
      Object.assign( 
        obj, 
        this.instruments, 
        this.oscillators,
        this.effects,
        this.filters,
        this.busses, 
        this.envelopes, 
        this.waveObjects, 
        this.binops, 
        this.analysis 
      )
      
      Utility.export( obj )
      this.Gen.export( obj )

      obj.Gibberish = this.Gibberish

      obj.gen = this.Gen.make
      obj.lfo = this.Gen.composites.lfo
      obj.Ensemble = this.Ensemble
      obj.Drums = this.Drums
      obj.EDrums = this.EDrums
      obj.Theory = this.Theory
      obj.Freesound = this.Freesound
      obj.Clock = this.Clock
      obj.Clock.export( obj )
      obj.WavePattern = this.WavePattern
      obj.Gen = this.Gen
      obj.stop = this.stop

      obj.Out = this.Out
      obj.Make = this.Make
      obj.future = this.Gibberish.utilities.future
    }else{
      Audio.exportTarget = obj
    } 
  },

  __defaults : {
    workletPath: '../dist/gibberish_worklet.js',
    ctx:         null,
    bufferSize:  2048,
    latencyHint: .05
  },

  init( options, Gibber  ) {
    let { workletPath, ctx, bufferSize, latencyHint } = Object.assign( {}, this.__defaults, options ) 
    this.Gibber = Gibber
    this.Core = Gibber

    // XXX should probably just call Audio.Core.createProperty to avoid confusion...
    this.createProperty = Gibber.createProperty

    Gibber.Audio = this
    this.Gibberish = Gibberish

    Gibberish.workletPath = workletPath 

    this.createPubSub()

    const AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext
    window.AudioContext = AC
    AWPF( window, bufferSize ) 

    const p = new Promise( (resolve, reject) => {
      if( ctx === null ) {
        ctx = new AC({ latencyHint })
        //ctx = new AudioContext()
      }

      Gibberish.init( 44100*60*20, ctx ).then( processorNode => {
        // XXX remove once gibber.core.lib has been properly integrated 
        Audio.Core.Audio = Audio.Core.audio = Audio

        Audio.Gibberish = Gibberish

        Audio.initialized = true
        Audio.node = processorNode
        Audio.Ugen = Ugen
        Audio.Make = Audio.__Make( Audio )
        Audio.Gen = Gen( Audio )
        Audio.Gen.init()
        Audio.Gen.export( Audio.Gen.ugens )
        Audio.Theory.init( window.Gibber )
        Audio.Utilities = Utility
        Audio.WavePattern = WavePattern( Audio )
        Audio.ctx = ctx
        Audio.Out = Gibberish.output
        
        // must wait for Gen to be initialized
        Audio.Clock.init( Audio.Gen, Audio )

        Audio.createUgens()
        
        if( Audio.exportTarget !== null ) Audio.export( Audio.exportTarget )

        Gibberish.worklet.port.__postMessage = Gibberish.worklet.port.postMessage

        Gibberish.worklet.port.postMessage = function( dict ) {
          if( Audio.shouldDelay === true ) dict.delay = true

          Gibberish.worklet.port.__postMessage( dict )
        }

        Audio.export( window )

        //const drums = Audio.Drums('x*o-')
        //drums.disconnect()
        //drums.stop()

        // store last location in memory... we can clear everything else in Gibber.clear9)
        const memIdx = Object.keys( Gibberish.memory.list ).reverse()[0]
        this.__memoryEnd = parseInt( memIdx ) + Gibberish.memory.list[ memIdx ]

        // XXX this forces the gibberish scheduler to start
        // running, but it's about as hacky as it can get...
        //const __start = Audio.instruments.Synth().connect()
        //__start.disconnect()

        //Audio.Gibberish.genishi.gen.histories.clear()
        Audio.clear()

        resolve( [Audio,'Audio'] )
      })
    })
    
    return p
  },

  restart() {
    Gibber.clear()
    Gibberish.worklet.port.close()
    window.w = Gibberish.worklet
    Gibberish.worklet.disconnect()

    Gibberish.init( 44100*60*20, undefined, 'worklet', true ).then( processorNode => {
      Audio.out = Gibberish.output
      Audio.node = processorNode

      Audio.Theory.deleteProperties()
      Audio.Theory.init( window.Gibber )

      Audio.initialized = true
      Audio.node = processorNode
      Audio.Out = Gibberish.output

      Audio.Make = Audio.__Make( Audio )
      Audio.Gen = Gen( Audio )
      Audio.Gen.init()
      Audio.Gen.export( Audio.Gen.ugens )

      Audio.WavePattern = WavePattern( Audio )
      Audio.createUgens()
        
      Audio.Clock.init( Audio.Gen, Audio )

      Gibberish.worklet.port.__postMessage = Gibberish.worklet.port.postMessage
      Gibberish.worklet.port.postMessage = function( dict ) {
        if( Audio.shouldDelay === true ) dict.delay = true

        Gibberish.worklet.port.__postMessage( dict )
      }

      Audio.export( window )
      Gibber.export( window )

      const memIdx = Object.keys( Gibberish.memory.list ).reverse()[0]
      this.__memoryEnd = parseInt( memIdx ) + Gibberish.memory.list[ memIdx ]

      // XXX this forces the gibberish scheduler to start
      // running, but it's about as hacky as it can get...
      const __start = Audio.instruments.Synth().connect()
      __start.disconnect()

      //Audio.Gibberish.genishi.gen.histories.clear()

      //Audio.clear()
      console.log( 'audio engine successfully restarted.' )
      Audio.publish( 'restart' )
    })
  },

  // XXX stop clock from being cleared.
  clear() { 
    Gibberish.clear() 
    Audio.Clock.init( Audio.Gen, Audio )

    // the idea is that we only clear memory that was filled after
    // the initial Gibber initialization... this stops objects
    // like Clock and Theory from having their memory cleared and
    // from having to re-initialize them.

    // fill memory with zeros from the end initialization block onwards
    Gibberish.memory.heap.fill( 0, this.__memoryEnd )

    // get locations of all memory blocks
    const memKeys = Object.keys( Gibberish.memory.list )

    // get idx of final initialization block
    const endIdx =  memKeys.indexOf( ''+this.__memoryEnd )

    // loop through all blocks after final initialzation block
    // and delete them in the memory list... they've already
    // been zeroed out.
    for( let i = endIdx; i < memKeys.length; i++ ) {
      delete Gibberish.memory.list[ memKeys[ i ] ]
    }
    
    Audio.publish('clear')
  },

  stop() {
    Gibber.Seq.sequencers.forEach( s => s.stop() )
  },

  start() {
    Gibber.Seq.sequencers.forEach( s => s.start() )
  },
  onload() {},

  createUgens() {
    //Core.export( this, this )

    this.Freesound = Freesound( this )
    this.binops = Binops.create( this )
    this.analysis = Analysis.create( this )
    this.oscillators = Oscillators.create( this )
    this.instruments = Instruments.create( this ) 
    this.envelopes   = Envelopes.create( this )
    this.filters     = Filters.create( this )
    this.effects = Effects.create( this )
    this.busses = Busses.create( this )
    this.Ensemble = Ensemble( this )
    this.waveObjects = WaveObjects( this )

    const Pattern = this.Core.__Pattern
    Pattern.transfer( this, Pattern.toString() )

    
    const drums = require( './drums.js' )( this )
    Object.assign( this, drums )
  },

  printcb() { 
    Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'callback' }) 
  },
  printobj( obj ) {
    Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'print', object:obj.id }) 
  },
  send( msg ){
    Gibber.Audio.Gibberish.worklet.port.postMessage( msg )
  },

  createPubSub() {
    const events = this.pubevents = {}
    this.subscribe = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
    }

    this.unsubscribe = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
    }

    this.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
    }
  },

  createMapping( from, to, name, wrappedTo ) {
    if( from.__useMapping === false ) {
      to[ name ].value = from
    }else if( from.type === 'audio' ) {
      const f = to[ '__' + name ].follow = Follow({ input: from })

      let m = f.multiplier
      Object.defineProperty( to[ name ], 'multiplier', {
        get() { return m },
        set(v) { m = v; f.multiplier = m }
      })

      let o = f.offset
      Object.defineProperty( to[ name ], 'offset', {
        get() { return o },
        set(v) { o = v; f.offset = o }
      })

      wrappedTo[ name ] = f
      //to[ '__'+name].value = f

    }else if( from.type === 'gen' ) {
      // gen objects can be referred to without the graphics/audio abstraction,
      // in which case they will have no .render() function, and don't need to be rendered
      const gen = from.render !== undefined ? from.render() : from

      wrappedTo[ name ] = gen
    }
  },

  createGetter( obj, name ) { return () => obj[ '__' + name ] },

  createSetter( obj, name, post, transform=null, isPoly=false ) {
    if( typeof obj.__wrapped__ === 'object' ) {
      let desc = Object.getOwnPropertyDescriptor( obj.__wrapped__, name )

      if( desc !== undefined ) {
        Object.defineProperty( obj.__wrapped__, name,  {
          configurable:true,
          set(v) {
            obj[ '__'+name ].value = v
            if( desc.set ) {
              desc.set( v )
            }else{
              obj.__wrapped__.value = v
            }
          }
        })
      }
    }
    const setter = v => {
      let value, shouldSend = true


      if( typeof v === 'number' || typeof v === 'string' || v === null ) {
        value = transform !== null ? transform( v ) : v

        if( isPoly === true ) {
          const __wrappedObject = obj.__wrapped__
          const voice = __wrappedObject.voices[ __wrappedObject.voiceCount % __wrappedObject.voices.length ]
          voice[ name ] = value

          shouldSend = false

          Gibberish.worklet.port.postMessage({
            address:'property',
            object:voice.id,
            name,
            value
          }) 

        }else{
          obj[ '__'+name].value = v
        }
      }else if( typeof v === 'object' && v !== null && v.type === 'gen' ) {
        // gen objects can be referred to without the graphics/audio abstraction,
        // in which case they will have no .render() function, and don't need to be rendered

        v = transform !== null ? transform( v ) : v       
        const gen = v.render !== undefined ? v.render() : v 

        obj['__'+ name ].value = gen 
        value = { id: gen.id }
      }else if( typeof v === 'object' ) { //&& typeof v !== null ) {
        //if( obj.__useMapping === false || name === 'input' ) {
        //  obj[ '__'+name].value = v
        //  value = v !== null ? { id:v.id } : v
        //}else{
        //  //Audio.createMapping( v, obj, name, obj.__wrapped__ )
        //  const f = obj[ '__' + name ].follow = Follow({ input: v })

        //  let m = f.multiplier
        //  Object.defineProperty( obj[ name ], 'multiplier', {
        //    get() { return m },
        //    set(v) { m = v; f.multiplier = m }
        //  })

        //  let o = f.offset
        //  Object.defineProperty( obj[ name ], 'offset', {
        //    get() { return o },
        //    set(v) { o = v; f.offset = o }
        //  })

          //wrappedTo[ name ] = f
          //obj[ '__'+name ].value = f.__wrapped__
          //value = { id:f.id }
          obj[ '__'+name ].value = v.__wrapped__
          value = { id:v.id }
        //}
               //
        //obj[ '__'+name].value = v
        //value = v !== null ? { id:v.id } : v
      }

      if( Gibberish.mode === 'worklet' && shouldSend === true ) {
        Gibberish.worklet.port.postMessage({
          address:'property',
          object:obj.id,
          name,
          value
        }) 
      }
      if( post !== null ) {
        post.call( obj )
      }     
      if( Gibberish.mode === 'worklet' ) Audio.publish( `property.set:${obj.id}`, obj, v )
    }

    return setter
  },

  createFade( from=null, to=null, time=1, obj, name, delay=0 ) {
    if( from === null ) from = obj[ name ].value
    if( to === null ) to = obj[ name ].value

    time = Audio.Clock.time( time )

    // XXX only covers condition where ramps from fades are assigned...
    // does this need to be more generic?
    if( isNaN( from ) && from.__wrapped__.ugenName.indexOf('ramp') > -1 ) {
      from = from.to.value
    }
    if( isNaN( to ) && to.__wrapped__.ugenName.indexOf('ramp') > -1 ) {
      to = to.to.value
    }

    let ramp = Audio.envelopes.Ramp({ from, to, length:time, shouldLoop:false })
    // this is a key to not use an envelope follower for mapping
    ramp.__useMapping = false

    if( delay === 0 ) {
      obj[ name ] = ramp
    } else {
      future( (obj,name,ramp) => { 
        obj[ name ] = ramp 
      }, delay, { obj, name, ramp:ramp.__wrapped__ } )
    }

    if( ramp.__wrapped__ === undefined ) ramp.__wrapped__ = {}
    ramp.__wrapped__.values = []

    ramp.__wrapped__.output = v => {
      if( ramp.__wrapped__ !== undefined ) {
        ramp.__wrapped__.values.unshift( v )
        while( ramp.__wrapped__.values.length > 60 ) ramp.__wrapped__.values.pop()
      }
    }

    ramp.__wrapped__.finalize = () => {
      const store = ramp.__wrapped__

      // XXX I can't quite figure out why I have to wait to reset the property 
      // value here... if I don't, then the fade ugen stays assigned in the worklet processor.
      // and 0 doesn't work!
      setTimeout( ()=> obj[ name ] = store.to === 0 ? .000001 : store.to, 0 )
      store.widget.clear()
    }

    ramp.__wrapped__.from = from
    ramp.__wrapped__.to = to

    return obj
  },

  // what properties should be automatically (automagickally?)
  // filtered through Audio.Clock.time()?
  timeProps : {
    Synth:[ 'attack', 'decay', 'sustain', 'release' ],
    PolySynth:[ 'attack', 'decay', 'sustain', 'release' ],
    Complex:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyComplex:[ 'attack', 'decay', 'sustain', 'release' ],
    FM:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyFM:[ 'attack', 'decay', 'sustain', 'release' ],
    Monosynth:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyMono:[ 'attack', 'decay', 'sustain', 'release' ],
    Delay:[ 'time' ], 
  }
}

module.exports = Audio

},{"./analysis.js":91,"./binops.js":93,"./busses.js":94,"./clock.js":95,"./drums.js":96,"./effects.js":97,"./ensemble.js":98,"./envelopes.js":99,"./external/audioworklet-polyfill.js":100,"./filters.js":103,"./freesound.js":104,"./gen.js":105,"./instruments.js":106,"./make.js":107,"./oscillators.js":108,"./presets.js":109,"./theory.js":127,"./ugen.js":128,"./utility.js":129,"./waveObjects.js":130,"./wavePattern.js":131,"gibberish-dsp":174}],93:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Binops = {
  create( Audio ) {
    const binops = {}

    for( let binopName in Gibberish.binops ) {
      const gibberishConstructor = Gibberish.binops[ binopName ]

      const methods = Binops.descriptions[ binopName ] === undefined ? null : Binops.descriptions[ binopName ].methods
      const description = { 
        properties:gibberishConstructor.defaults,
        methods:methods,
        name:binopName,
        category:'binops'
      }
      description.properties.type = 'binop'

      const constructor = Ugen( gibberishConstructor, description, Audio, false, true )
      binops[ binopName ] = function( ...args ) {
        const ugen = constructor( ...args )
        ugen[0] = ugen.__wrapped__[0]
        ugen[1] = ugen.__wrapped__[1]

        return ugen
      } 
    }
    return binops
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Binops

},{"./ugen.js":128,"gibberish-dsp":174}],94:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Busses = {
  create( Audio ) {
    const busses = {}

    const busDescription = { 
      properties:Gibberish.Bus.defaults,
      methods:null,
      name:'Bus',
      category:'misc'
    }

    busses.Bus = Ugen( Gibberish.Bus, busDescription, Audio )
    busses.__Bus = function( ...args ) {
      let props
      if( args.length > 1 || args.length === 1 && typeof args[0] !== 'string' ) {
        props = { inputs:args }
      }else if( args.length === 1 ) {
        props = args[0]
      }
      
      return props !== undefined ? busses.__Bus( props ) : busses.__Bus()
    }

    const bus2Description = { 
      properties:Gibberish.Bus2.defaults,
      methods:null,
      name:'Bus2',
      category:'misc'
    }

    busses.Bus2 = Ugen( Gibberish.Bus2, bus2Description, Audio )
    busses.__Bus2 = function( ...args ) {
      let props
      if( args.length > 1 || (args.length === 1 && typeof args[0] !== 'string' && args[0].type !== 'ensemble' )) {
        props = { inputs:args }
      }else if( args.length === 1 ) {
        props = args[0]
      }
      
      return props !== undefined ? busses.__Bus2( props ) : busses.__Bus2()
    }

    return busses
  }
}

module.exports = Busses

},{"./ugen.js":128,"gibberish-dsp":174}],95:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const serialize = require( 'serialize-javascript' )

// XXX must use form key:function() {} due to serialization
const Clock = {
  __beatCount:0,
  id:null,
  nogibberish:true,
  bpm:140,
  __lastBPM:140,
  seq:null,

  export:function( obj ) {
    obj.btos = Clock.btos.bind( Clock )
    obj.btoms = Clock.btoms.bind( Clock )
    obj.stob = Clock.stob.bind( Clock )
  },

  store:function() { 
    Gibberish.Clock = this
    this.beatCount = 0
    this.queue = []
    this.init()
  },

  addToQueue:function( ...args ) {
    if( Gibberish.mode === 'processor' ) {
      args = args[0]
      args.forEach( v => Gibberish.Clock.queue.push( v ) )
    }else{
      Gibberish.worklet.port.postMessage({
        address: 'method',
        object: this.id,
        name: 'addToQueue',
        args: serialize( args ),
        functions: true
      }) 
    }
  },

  init:function( Gen, Audio ) {
    // needed so that when the clock is re-initialized (for example, after clearing)
    // gibber won't try and serialized its sequencer
    this.seq = null

    const clockFunc = ()=> {
      Gibberish.worklet.port.postMessage({
        address: 'beat',
        value: this.beatCount
      }) 

      if( this.beatCount++ % 4 === 0 ) {
        Gibberish.processor.playQueue()//.forEach( f => { f() } )
      }
    }

    if( Gibberish.mode === 'worklet' ) {
      this.id = Gibberish.utilities.getUID()
      this.audioClock = null
      this.__rate = null

      Gibberish.worklet.port.postMessage({
        address:'add',
        properties:serialize( Clock ),
        id:this.id,
        post: 'store'    
      })
      
      let bpm = this.__lastBPM
      Object.defineProperty( this, 'bpm', {
        get() { return bpm },
        set(v){ 
          bpm = v
          if( Gibberish.mode === 'worklet' ) {
            this.__lastBPM = v
            if( Audio.Gibber.Tidal !== undefined ) Audio.Gibber.Tidal.cps = bpm/120/2
            Gibberish.worklet.port.postMessage({
              address:'set',
              object:this.id,
              name:'bpm',
              value:bpm 
            }) 
          }
        }
      })

      this.audioClock = Gen.make( Gen.ugens.abs(1) )
      //this.__rate = this.audioClock.__p0 

      Object.defineProperty( this, 'rate', {
        configurable:true,
        get() { return this.audioClock },
        set(v){
          this.audioClock.p0 = v
        }
      })

      //Gibberish.worklet.port.postMessage({
      //  address:'set',
      //  value: Gen.make( Gen.ugens.abs(1) ),
      //  object:this.id,
      //  name:'audioClock'
      //})

      this.bpm = this.__lastBPM
    }

    if( Gibberish.mode === 'processor' )
      this.seq = Gibberish.Sequencer.make( [ clockFunc ], [ ()=>Gibberish.Clock.time( 1/4 ) ] ).start()

  },

  connect: function() {
    if( this.audioClock !== undefined ) {
      Gibberish.analyzers.push( this.audioClock )
      Gibberish.dirty( Gibberish.analyzers )
      console.log( 'clock connected' )
    }
  },

  // time accepts an input value and converts it into samples. the input value
  // may be measured in milliseconds, beats or samples.
  time: function( inputTime = 0 ) {
    let outputTime = inputTime

    // if input is an annotated time value such as what is returned
    // by samples() or ms()...
    // console.log( 'input time:' , inputTime )
    if( isNaN( inputTime ) ) {
      if( typeof inputTime === 'object' ) { 
        if( inputTime.type === 'samples' ) {
          outputTime = inputTime.value
        }else if( inputTime.type === 'ms' ) {
          outputTime = this.mstos( inputTime.value ) 
        }
      } 
    }else{
      // XXX 4 is a magic number, needs to account for the current time signature
      outputTime = this.btos( inputTime * 4 )
    }
    
    return outputTime
  },

  // does not work... says Gibberish can't be found? I guess Gibberish isn't in the
  // global scope of the worklet?
  Time: function( inputTime ) {
    return new Function( `return Gibberish.Clock.time( ${inputTime} )` )
  },

  mstos: function( ms ) {
    return ( ms / 1000 ) * Gibberish.ctx.sampleRate
  },

  // convert beats to samples
  btos: function( beats ) {
    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
    return samplesPerBeat * beats 
  },

  // convert samples to beats (for pattern visualizations)
  stob: function( samples ) {
    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
    return (samples / samplesPerBeat) * .25 // XXX magic number should be denominator of time signature 
  },
  // convert beats to milliseconds
  btoms: function( beats ) {
    const samplesPerMs = Gibberish.ctx.sampleRate / 1000
    return beats * samplesPerMs
  },

  ms: function( value ) {
    return { type:'ms', value }
  },

  samples: function( value ) {
    return { type:'samples', value }
  }
}

module.exports = Clock

},{"gibberish-dsp":174,"serialize-javascript":231}],96:[function(require,module,exports){
const Ugen = require( './ugen.js' )
const Presets = require( './presets.js' )

let Audio = null

const addMethod = ( obj, name, __value = 1, propOverrideName ) => {
  if( propOverrideName === undefined ) propOverrideName = name

  obj[ '__' + name ] = { 
    value: __value,
    isProperty:true,
    sequencers:[],
    mods:[],
    name,

    seq( values, timings, number = 0, delay = 0 ) {
      let prevSeq = obj['__'+name].sequencers[ number ] 
      if( prevSeq !== undefined ) { 
        prevSeq.stop(); prevSeq.clear(); 
        let idx = obj.__sequencers.indexOf( prevSeq )
        obj.__sequencers.splice( idx, 1 )
      }

      // XXX you have to add a method that does all this shit on the worklet. crap.
      obj['__'+name].sequencers[ number ] = obj['__'+name][ number ] = Audio.Core.Seq({ 
        values, 
        timings, 
        target:obj.__wrapped__, 
        key:name,
        rate:Audio.Clock.audioClock
      })
      .start( Audio.Clock.time( delay ) )

      obj.__sequencers.push( obj['__'+name][ number ] )

      // return object for method chaining
      return obj
    },
  }

  Audio.Gibberish.worklet.port.postMessage({
    address:'addMethod',
    key:name,
    function:`function( ${name} ) {
        for( let input of this.inputs ) {
          if( typeof input === 'object' ) input[ '${propOverrideName}' ] = ${name}
        }
      }`,
    id:obj.id,
    delay:Audio.shouldDelay
  })

  Object.defineProperty( obj, name, {
    configurable:true,
    get() { return this[ '__' + name ] },
    set(v){ 
      this[ '__' + name ].value = v
      for( let sampler of this.samplers ) sampler[ propOverrideName ] = this[ '__' + name ].value 
    }
  })
}

module.exports = function( __Audio ) {
  Audio = __Audio

  const Drums = function( score, time, ...args ) { 
    // XXX what url prefix should I be using?

    const temp = Audio.autoConnect
    Audio.autoConnect = false
    const k  = Audio.instruments.Sampler({ filename:'./resources/audiofiles/kick.wav' })
    const s  = Audio.instruments.Sampler({ filename:'./resources/audiofiles/snare.wav' })
    const ch = Audio.instruments.Sampler({ filename:'./resources/audiofiles/hat.wav' })
    const oh = Audio.instruments.Sampler({ filename:'./resources/audiofiles/openhat.wav' })
    Audio.autoConnect = temp

    const drums = Audio.Ensemble({
      'kd': { target:k,  method:'trigger', args:[1], name:'kick' },
      [0]: { target:k,  method:'trigger', args:[1], name:'kick' },
      'sd': { target:s,  method:'trigger', args:[1], name:'snare' },
      'sn': { target:s,  method:'trigger', args:[1], name:'snare' },
      [1]: { target:s,  method:'trigger', args:[1], name:'snare' },
      'ch': { target:ch, method:'trigger', args:[1], name:'closedHat' },
      [2]: { target:ch, method:'trigger', args:[1], name:'closedHat' },
      'oh': { target:oh, method:'trigger', args:[1], name:'openHat' },
      [3]: { target:oh, method:'trigger', args:[1], name:'openHat' },
    })

    if( Audio.autoConnect === true ) drums.connect()

    drums.__sequencers = [ ]
    //if( typeof score === 'string' ) {
    //  drums.seq = Audio.Seq({
    //    target:drums,
    //    key:'play',
    //    values:score.split(''),
    //    timings:time === undefined ? 1 / score.length : time
    //  }).start()
    

    //  drums.values = drums.seq.values
    //  drums.timings = drums.seq.timings

    //  drums.__sequencers.push( drums.seq )
    //}else{
    //  Gibber.addSequencing( drums, 'play', 0 )
    //}

    drums.samplers = [ k,s,ch,oh ]

    addMethod( drums, 'pitch', 1, 'rate' )
    addMethod( drums, 'start', 0 )
    addMethod( drums, 'end', 1 )

    props = Presets.process( { name:'Drums', category:'instruments' }, args, Audio )
    if( props !== undefined && props.__presetInit__ !== undefined ) {
      Object.assign( drums, props )
      if( props.__presetInit__ !== undefined ) props.__presetInit__.call( drums, Audio )
    }

    drums.name = 'Drums'
    return drums
  }

  const EDrums = function(  ...args ) {
    const temp = Audio.autoConnect
    Audio.autoConnect = false
    
    const kd = Audio.instruments.Kick()
    const sd = Audio.instruments.Snare()
    const ch = Audio.instruments.Hat({ decay:.1, gain:.3 })
    const oh = Audio.instruments.Hat({ decay:.5, gain:.3 })
    const cp = Audio.instruments.Clap()
    const cb = Audio.instruments.Cowbell({ gain:.65 })
    
    Audio.autoConnect = temp
    
    const drums = Audio.Ensemble({
      'kd': { target:kd, method:'trigger', args:[1], name:'kick' },
      [0]: { target:kd, method:'trigger', args:[1], name:'kick' },
      [1]: { target:sd, method:'trigger', args:[1], name:'snare' },
      'sd': { target:sd, method:'trigger', args:[1], name:'snare' },
      [2]: { target:ch, method:'trigger', args:[.2], name:'closedHat' },
      'ch': { target:ch, method:'trigger', args:[.2], name:'closedHat' },
      [3]: { target:oh, method:'trigger', args:[.2], name:'openHat' },
      'oh': { target:oh, method:'trigger', args:[.2], name:'openHat' },
      [4]: { target:cp, method:'trigger', args:[.5], name:'clap' },
      'cp': { target:cp, method:'trigger', args:[.5], name:'clap' },
      [5]: { target:cb, method:'trigger', args:[.5], name:'cowbell' },
      'cb': { target:cb, method:'trigger', args:[.5], name:'cowbell' },
    })

    //if( typeof score === 'string' ) {
    //  drums.seq = Audio.Seq({
    //    target:drums,
    //    key:'play',
    //    values:score.split(''),
    //    timings:time === undefined ? 1 / score.length : time,
    //    rate:Audio.Clock.audioClock
    //  }).start()

    //  drums.values = drums.seq.values
    //  drums.timings = drums.seq.timings
    //}

    if( Audio.autoConnect === true ) drums.connect()

    props = Presets.process( { name:'EDrums', category:'instruments' }, args, Audio )
    if( props !== undefined && props.__presetInit__ !== undefined ) {
      props.__presetInit__.call( drums, Audio )
    }

    //drums.tidal = pattern => {
    //  if( drums.__tidal !== undefined ) drums.__tidal.stop()

    //  drums.__tidal = Audio.Tidal({
    //    target:drums,
    //    key:'play',
    //    pattern
    //  }).start()

    //  return drums
    //}

    drums.name = 'EDrums'
    return drums
  }

  return { Drums, EDrums }
}

},{"./presets.js":109,"./ugen.js":128}],97:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Effects = {
  create( Audio ) {
    const effects = {}
    const poolEffects = ['Freeverb', 'Plate', 'BufferShuffler']
    Gibberish.effects = Gibberish.fx

    for( let effectName in Gibberish.effects ) {
      const gibberishConstructor = Gibberish.effects[ effectName ]

      const methods = Effects.descriptions[ effectName ] === undefined ? null : Effects.descriptions[ effectName ].methods

      // XXX how do we make this more generic for any model of reverb / any type of distortion etc.
      const replaceName = effectName === 'Freeverb' ? 'Reverb' : effectName 
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:replaceName,
        category:'effects'
      }
      description.properties.type = 'fx'

      const shouldUsePool = poolEffects.indexOf( effectName ) > -1 

      effects[ effectName ] = Ugen( gibberishConstructor, description, Audio, shouldUsePool )
      
      effects[ effectName ].presets = Audio.Presets.effects[ effectName ] 
      if( effects[ effectName ].presets !== undefined ) {
        effects[ effectName ].presets.inspect = function() {
          console.table( this )
        }
      }else{
        effects[ effectName ].presets = { inspect() { console.log( `${effectName} has no presets.` ) } }
      }
    }

    effects.Reverb = function( ...args ) {
      let argprops = null
      if( args.length === 1 ) {
        if( typeof args[0] === 'object' ) argprops = args[0]
      }else if( args.length === 2 ) {
        argprops = args[1]
      }
      const props = Object.assign( {}, { model:0 }, argprops )

      let ugen = null
      switch( props.model ) {
        case 0:
        default:
          ugen = effects.Freeverb(...args )
          break;
      }

      return ugen
    }

    return effects
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Effects

},{"./ugen.js":128,"gibberish-dsp":174}],98:[function(require,module,exports){
module.exports = function( Audio ) {
  const Gibberish = Audio.Gibberish
  const Ensemble = function( props ) {
    const cp = {
      shouldAddToUgen:true
    }

    for( let key in props ) {
      const dict = props[ key ]
      const target = dict.target
      const method = dict.method
      const args = dict.args
      cp[ key ] = {
        play: function( ...args ) { 
          Gibberish.worklet.ugens.get( this.target )[ this.method ]( ...args ) 
        },
        target:target.id,
        method,
        args,
        name:dict.name
      }

      //Object.defineProperty( cp[ key ], 'loudness', {
      //  set(v) {
      //    console.log( 'loudness:', v, Gibberish.worklet.ugens.get( this.target ))
      //    Gibberish.worklet.ugens.get( this.target ).loudness = v
      //  }
      //})
      cp[ dict.name ] = target
    }

    cp.play = function( __key ) {
      const key = isNaN(__key) ? __key : parseInt( __key ) 
      if( Gibberish.mode === 'processor' ) {
        Gibberish.worklet.ugens.get( this[ key ].target )[ this[ key ].method ]( ...this[ key ].args )
      }else{
        props[ key ].target[ this[ key ].method ]( ...this[ key ].args )
      }
    }

    const ens = Audio.busses.Bus2( cp )
    ens.__isEnsemble = true

    for( let key in props ) {
      props[ key ].target.connect( ens )
    }
    
    ens.tidals = []

    ens.stop = function() {
      ens.tidals.forEach( t => t.stop() )
      ens.__sequencers.forEach( t => t.stop() )
    }
    ens.start = function() {
      ens.tidals.forEach( t => t.start() )
      ens.__sequencers.forEach( t => t.start() )
    }

    ens.tidal = (pattern,num=0) => {
      const t =  Audio.Gibber.Tidal({
        target:ens,
        key:'play',
        pattern
      })

      if( t !== null ) {
        if( ens.tidals[ num ] !== undefined ) ens.tidals[ num ].stop()

        ens.tidals[ num ] = t
        t.start()
      }

      return ens
    }
    ens.__sequencers = []

    ens.seq = (values,timings,num=0,offset=0) => {
      if( ens.__sequencers[ num ] !== undefined ) ens.__sequencers[ num ].stop()

      ens.__sequencers[ num ] = Audio.Gibber.Seq({
        target:ens,
        key:'play',
        values,timings,offset
      }).start()

      return ens
    }

    return ens
  }

  return Ensemble
}

},{}],99:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Envelopes = {
  create( Audio ) {
    const envelopes = {}

    for( let envelopeName in Gibberish.envelopes ) {
      const gibberishConstructor = Gibberish.envelopes[ envelopeName ]

      const methods = Envelopes.descriptions[ envelopeName ] === undefined ? null : Envelopes.descriptions[ envelopeName ].methods
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:envelopeName,
        category:'envelopes'
      }
      description.properties.type = 'envelope'

      envelopes[ envelopeName ] = Ugen( gibberishConstructor, description, Audio )
    }
    return envelopes
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Envelopes

},{"./ugen.js":128,"gibberish-dsp":174}],100:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./realm.js":101,"dup":39}],101:[function(require,module,exports){


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],102:[function(require,module,exports){

// See all scales at: http://abbernie.github.io/tune/scales.html


const Tune = function(){

	// the scale as ratios
	this.scale = []

	// i/o modes
	this.mode = {
		output: "frequency",
		input: "step"
	}

	// ET major, for reference
	this.etmajor= [ 261.62558,
		293.664764,
		329.627563,
		349.228241,
		391.995422,
		440,
		493.883301,
		523.25116
	]

  
  this.TuningList = null
	// Root frequency.
	this.tonic = 440

	console.log("{{{{ Tune.js v0.1 Loaded }}}}");

}

/* Set the tonic frequency */

Tune.prototype.tonicize = function(newTonic) {
	this.tonic = newTonic
}

/* Return data in the mode you are in (freq, ratio, or midi) */

Tune.prototype.note = function(input,octave){

	var newvalue;

	if (this.mode.output == "frequency") { 
		newvalue = this.frequency(input,octave)
	} else if (this.mode.output == "ratio") { 
		newvalue = this.ratio(input,octave)
	} else if (this.mode.output == "MIDI") { 
		newvalue = this.MIDI(input,octave)
	} else {
		newvalue = this.frequency(input,octave)
	}

	
	return newvalue;

}


/* Return freq data */

Tune.prototype.frequency = function(stepIn, octaveIn) {

	if (this.mode.input == "midi" || this.mode.input == "MIDI" ) {
		this.stepIn += 60
	}
	
	// what octave is our input
	var octave = Math.floor(stepIn/this.scale.length)

	if (octaveIn) { 
		octave += octaveIn
	}
	
	// which scale degree (0 - scale length) is our input
	var scaleDegree = stepIn % this.scale.length

	while (scaleDegree < 0) {
		scaleDegree += this.scale.length
	}
	
	var freq = this.tonic*this.scale[scaleDegree]
	
	freq = freq*(Math.pow(2,octave))
	
	// truncate irrational numbers
	freq = Math.floor(freq*100000000000)/100000000000
	
	return freq

}

/* Force return ratio data */

Tune.prototype.ratio = function(stepIn, octaveIn) {

	if (this.mode.input == "midi" || this.mode.input == "MIDI" ) {
		this.stepIn += 60
	}
	
	// what octave is our input
	var octave = Math.floor(stepIn/this.scale.length)

	if (octaveIn) { 
		octave += octaveIn
	}
	
	// which scale degree (0 - scale length) is our input
	var scaleDegree = stepIn % this.scale.length

	// what ratio is our input to our key
	var ratio = Math.pow(2,octave)*this.scale[scaleDegree]

	ratio = Math.floor(ratio*100000000000)/100000000000

	return ratio

}

/* Force return adjusted MIDI data */

Tune.prototype.MIDI = function(stepIn,octaveIn) {

	var newvalue = this.frequency(stepIn,octaveIn)

	var n = 69 + 12*Math.log(newvalue/440)/Math.log(2)

	n = Math.floor(n*1000000000)/1000000000

	return n

}

/* Load a new scale */

Tune.prototype.loadScale = function(name){

	/* load the scale */
	var freqs = this.TuningList[name].frequencies
	this.scale = []
	for (var i=0;i<freqs.length-1;i++) {
		this.scale.push(freqs[i]/freqs[0])
	}

	/* visualize in console */
	//console.log(" ");
	//console.log("LOADED "+name);
	//console.log(this.TuningList[name].description);
	//console.log(this.scale);
	//var vis = [];
	//for (var i=0;i<100;i++) {
	//  vis[i] = " ";
	//}
	//for (var i=0;i<this.scale.length;i++) {
	//  var spot = Math.round(this.scale[i] * 100 - 100);
	//  if (i<10) {
	//    vis.splice(spot,1,i+1);
	//  } else {
	//    vis.splice(spot,5,i+1);
	//  }
	//}
	//var textvis = "";
	//for (var i=0;i<vis.length;i++) {
	//  textvis += vis[i];
	//}
	//console.log(name)
	//console.log(textvis)
	//// ET scale vis
	//var vis = [];
	//for (var i=0;i<100;i++) {
	//  vis[i] = " ";
	//}
	//for (var i=0;i<this.etmajor.length;i++) {
	//  var spot = Math.round(this.etmajor[i]/this.etmajor[0] * 100 - 100);
	//  if (i<10) {
	//    vis.splice(spot,1,i+1);
	//  } else {
	//    vis.splice(spot,5,i+1);
	//  }
		
	//}
	//var textvis = "";
	//for (var i=0;i<vis.length;i++) {
	//  textvis += vis[i];
	//}
	//console.log(textvis)
	//console.log("equal-tempered major (reference)")
}

/* Search the names of tunings
	 Returns an array of names of tunings */

Tune.prototype.search = function(letters) {
	var possible = []
	for (var key in this.TuningList) {
		if (key.toLowerCase().indexOf(letters.toLowerCase())!=-1) {
			possible.push(key)
		}
	}
	return possible
}

/* Return a collection of notes as an array */

Tune.prototype.chord = function(midis) {
	var output = []
	for (var i=0;i<midis.length;i++) {
		output.push(this.note(midis[i]))
	}
	return output;
}


/* Change the tonic frequency? */

Tune.prototype.root = function(newmidi, newfreq) {
	this.rootFreq = newfreq
	// not working now ... needs much work.
	// setKey is not transposing now, either.
}

module.exports = Tune

},{}],103:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const filterNames = [
  "none", "Filter24Moog", "Filter24TB303", "Filter12SVF", "Filter12Biquad", "Filter24Classic"
]

const Filters = {
  create( Audio ) {
    const filters = {}

    for( let filterName in Gibberish.filters ) {
      const gibberishConstructor = Gibberish.filters[ filterName ]

      const methods = Filters.descriptions[ filterName ] === undefined ? null : Filters.descriptions[ filterName ].methods
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:filterName,
        category:'effects'
      }
      description.__defaults__ = { isStereo : true }
      description.properties.isStereo = true
      description.properties.type = 'fx'

      filters[ filterName ] = Ugen( gibberishConstructor, description, Audio, false )
    }

    filters.LPF = filters.Filter24Moog

    filters.Filter = function( props ) {
      if( props === undefined ) props = { model: 1 }
      if( props.model === undefined ) props.model = 1

      const name = filterNames[ props.model ]

      delete props.model

      return filters[ name ]( props ) 
    }

    const description = { 
      properties: Object.assign( {}, Gibberish.filters[ 'Filter12Biquad' ].defaults, { mode:1 } ),
      methods:null,
      name:'HPF',
      category:'effects',
      __defaults__: { mode:1 }
    }
   
    filters.HPF = Ugen( Gibberish.filters[ 'Filter12Biquad' ], description, Audio, false )

    return filters
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Filters

},{"./ugen.js":128,"gibberish-dsp":174}],104:[function(require,module,exports){
module.exports = function( Audio ) {
  const token = '6a00f80ba02b2755a044cc4ef004febfc4ccd476'

  const Freesound = function( query, options ) {
    const props = Object.assign( { count:1, maxVoices:1, panVoices:true }, typeof query === 'object' ? query : options )
    const sampler = Audio.instruments.Multisampler( props )
    setTimeout( ()=>queries[ typeof query ]( query, sampler, props.count ), 0 )
 
    return sampler
  }

  Freesound.loaded = {}
  Freesound.queries = {}

  Freesound.defaults = {
    sort: 'downloads',
    single:true,
    filename:false,
    min: 0,
    max: .5,
    reverse:false,
    count:15
  }

  // add Freesound[5] notation...
  for( let i = 0; i < 20; i++ ) {
    Freesound[ i ] = function( ...args ) {
      if( args.length > 0 ) {
        if( typeof args[0] === 'string' ) {
          if( args.length > 1 ) {
            if( typeof args[1] === 'object' ) {
              args[1].maxVoices = i || 1
            } 
          }else{
            args[1] = { maxVoices:i || 1 }
          }
        }else if( typeof args[0] === 'object' ) {
          args[0].maxVoices = i || 1
        }
      }else{
        args[0] = { maxVoices:i || 1 }
      } 

      return Freesound( ...args ) 
    }
  }

  const queries = {
    number( id, sampler, num=0 ) {
      if (typeof Freesound.loaded[ id ] === 'undefined') {
        fetch( `https://freesound.org/apiv2/sounds/${id}/?&format=json&token=${token}` )
          .then( response => response.json() )
          .then( json => {
            const path = json.previews[ 'preview-hq-mp3' ]
            
            sampler.loadSample( path )
            //console.log( 'loading:', path )
          }) 
      }else{
        if( Audio.Gibberish.mode === 'worklet' ) {
          sampler.samplers[ num ].loadBuffer( Freesound.loaded[ id ] )
        }
      }
    },

    // search for text query, and then use returned id to 
    // fetch by number 
    string( query, sampler, count, originalQuery ) {
      sampler.length = count
      let queryString ='https://freesound.org/apiv2/search/text/?'

      console.group('Querying Freesound for: ' + originalQuery || query )
      if( query.indexOf( 'query' ) > -1 ) {
        queryString += query
        queryString += `&token=${token}&fields=name,id,previews,username,license&page_size=${count} `
      }else{
        queryString += `query=${query}&token=${token}&fields=name,id,previews,username,license&filter=original_filename:${query.split(' ')[0]} ac_single_event:true&sort=downloads_desc&page_size=${count}`

      }

      fetch( queryString )
        .then( data => data.json() )
        .then( sounds => {
          if( sounds.results.length > 0 ) {
            if( sounds.results.length > count ) sounds.results = sounds.results.slice(0,count)
            console.log(`%c${sounds.results.length} sounds found. Starting downloads:`, `background:black;color:white`)
          }else{
            console.log(`%cNo sounds were found for this query!`, `background:red;color:white`)
          }
          sampler.length = count < sounds.results.length ? count : sounds.results.length
          console.table( sounds.results.map( r=>({file:r.name,author:r.username,license:'CC/'+r.license.split('/').slice(4).join('/')}) ) )
          for( let i = 0; i < sampler.length; i++ ) {
            const result = sounds.results[i]
            if( result !== undefined ) {
              const filename = result.name,
                    id = result.id,
                    url = result.previews[ 'preview-hq-mp3' ] 

              if( Freesound.loaded[ url ] === undefined ) {
                //console.log( `%c${filename}`, `color:white;background:#333333;` )

                sampler.loadSample( url, (__sampler,buffer) => {
                  Freesound.loaded[ url ] = buffer.data.buffer
                })

              }else{
                // XXX memoing the files causes an error
                if( Gibberish.mode === 'worklet' ) {
                  //console.log( 'reusing freesound file:', filename )
                  sampler.loadSample( url, null, Freesound.loaded[ url ] )
                }
              }
            }
          }
          console.groupEnd()
        })
    },

    object( queryObj, sampler ) {
      const q = Object.assign( {}, Freesound.defaults, queryObj )
 
      let query = `query=${q.query}&format=json`
  
      query += `&filter=duration:[${q.min} TO ${q.max}]`
      if( q.single ) query += ` ac_single_event:true`
      if( q.filename ) query += ` original_filename:${q.query}`

      let sort = q.sort

      // user error check
      if( sort === 'ratings' ) sort = 'rating'

      sort += q.reverse ? '_asc' : '_desc'

      query += `&sort=${sort}`

      queries.string( query, sampler, q.count, q.query )
    }
  }

  return Freesound
}

},{}],105:[function(require,module,exports){
module.exports = function( Audio ) {
  
const binops = [ 
  'min','max','add','sub','mul','div','rdiv','mod',
  'and','or','gt','eq','eqp','gte','gtep','gtp','lt','lte','ltep','ltp','neq',
  'step' 
]

const monops = [
  'abs','acos','acosh','asin','asinh','atan','atan2','atanh','cos','cosh',
  'sin','sinh','tan','tanh', 'floor',
  'ceil', 'round', 'sign', 'trunc', 'fract', 'param', 'in',
]

const noops = [
  'noise'
]

const Gen  = {
  lastConnected:[],
  names:[],
  connected: [],

  isGen:true,
  debug:false,

  wavetable( frequency, props ) {
    const g = Audio.Gibberish.genish 
    let dataProps = { immutable:true }

    // use global references if applicable
    if( props.name !== undefined ) dataProps.global = props.name

    const buffer = Gen.ugens.data( props.buffer, 1, dataProps )

    return Gen.ugens.peek( buffer, Gen.ugens.phasor( frequency, 0, { min:0 } ) )
  },

  init() {
    Gen.ugens.wavetable = Gen.__wavetable
    Gen.createBinopFunctions()
    Gen.createMonopFunctions()

    Gen.names.push( ...binops )
    Gen.names.push( ...monops )
    Gen.names.push( ...Object.keys( Gen.constants ) )
    Gen.names.push( ...Object.keys( Gen.functions ) )
    //Gen.names.push( ...Object.keys( Gen.composites ) )
    Gen.names.push( 'gen' )
    Gen.names.push( 'lfo' )
    Gen.names.push( 'sine' )
    Gen.names.push( 'square' )
    Gen.names.push( 'tri' )
    Gen.names.push( 'saw' )

    //Gibber.subscribe( 'clear', ()=> Gen.lastConnected.length = 0 )
  },

  // if property is !== ugen (it's a number) a Param must be made using a default
  create( name ) {
    // rate needs custom function to skip sequencing input and only sequence rate adjustment

    const params = Array.prototype.slice.call( arguments, 1 )

    if( name === 'rate' ) return Gen.createRate( name, ...params )

    const obj = Object.create( this )
    let count = 0
    
    obj.name = name
    obj.active = false
    
    for( let key of Gen.functions[ name ].properties ) { 
      let value = params[ count++ ] || 0
      obj[ key ] = v => {
        if( v === undefined ) {
          return value
        }else{
          value = v
          if( obj.active ) {
            if( obj.__client === 'live' ) {
              Gibber.Communication.send( `genp ${obj.paramID} ${obj[ key ].uid} ${v}` ) 
            }else if( obj.__client === 'max' ) {
              Gibber.Communication.send( `sig ${obj.paramID} param ${obj[ key ].uid} ${v}`, 'max' ) 
            }
          }
        }
      }
      obj[ key ].uid = Gen.getUID()
 
      // XXX Gibber.addSequencingToMethod( obj, key )
    }

    // accomodate non-audio-rate options. during codegen the compiler
    // will check for the options property; if it exists it will write
    // the options into the generated code.
    if( params.length > Gen.functions[ name ].properties.length ) {
      obj.options = params[ Gen.functions[ name ].properties.length ]
    }

    return obj
  },

  createRate( name ) {
    let obj = Object.create( this ),
        count = 0,
        param = arguments[1] 
    
    obj.name = 'rate' 
    obj.active = false
    
    let value = param
    //console.log( 'value:', value, 'args:', arguments )
    obj[ 0 ] = v => {
      if( v === undefined ) {
        return value
      }else{
        value = v
        if( obj.active ) {
          Gibber.Communication.send( `genp ${obj.paramID} ${obj[ 0 ].uid} ${v}` ) 
        }
      }
    }

    Gen.getUID() // leave 0 behind...
    obj[ 0 ].uid = Gen.getUID()

    Gibber.addSequencingToMethod( obj, '0' )

    return obj
  },
 
  createBinopFunctions() {
    for( let key of binops ) {
      Gen.functions[ key ] = {
        properties:['0','1'], str:key
      }
    }
  },

  createMonopFunctions() {
    for( let key of monops ) {
      Gen.functions[ key ] = {
        properties:['0'], str:key
      }
    }
  },

  assignTrackAndParamID: function( track, id ) {
    this.paramID = id
    this.track = track

    let count = 0, param
    while( param = this[ count++ ] ) {
      if( typeof param() === 'object' ) {
        param().assignTrackAndParamID( track, id )
      }
    }
  },

  clear() {
    for( let ugen of Gen.connected ) {
      Gibber.Communication.send( `ungen ${ugen.paramID}` )
    }

    Gen.connected.length = 0
  },

  constants: {
    degtorad: Math.PI / 180,
    E :       Math.E,
    halfpi:   Math.PI / 2,
    invpi :   Math.PI * - 1,
    ln10  :   Math.LN10,
    ln2   :   Math.LN2,
    log10e:   Math.LOG10E,
    log2e :   Math.LOG2E,
    pi    :   Math.PI,  
    sqrt2 :   Math.SQRT2,
    sqrt1_2:  Math.SQRT1_2,
    twopi :   Math.PI * 2,
    samplerate: 'samplerate'
  },

  functions: {
    phasor: { properties:[ '0','1' ],  str:'phasor' },
    cycle:  { properties:[ '0' ],  str:'cycle' },
    phasorN:{ properties:[ '0','1' ],  str:'phasorN' },
    cycleN: { properties:[ '0' ],  str:'cycleN' },
    train:  { properties:[ '0','1' ],  str:'train' },
    rate:   { properties:[ '0' ], str:'rate' },
    noise:  { properties:[], str:'noise' },
    accum:  { properties:[ '0','1' ], str:'accum' },
    counter:{ properties:[ '0','1' ], str:'counter' },
    scale:  { properties: ['0', '1', '2', '3'], str:'scale' },
    sah:    { properties: ['0', '1', '2'], str:'sah' },
    clamp:  { properties: ['0', '1', '2'], str:'clamp' },
    ternary:{ properties: ['0', '1', '2'], str:'switch' },
    selector:{ properties: ['0', '1', '2'], str:'selector' },
    peek:   { properties:['0','1'], str:'peek' },
    data:   { properties:[], str:'data' }
  },

  _count: 0,

  getUID() {
    return 'p' + Gen._count++
  },

  time: 'time',

  out() {
    let paramArray = [],
        body, out
    
    body = this.gen( paramArray )

    out = paramArray.join( ';' )

    if( paramArray.length ) {
      out += ';'
    }
    
    out += 'out1='
    out += body + ';'
    
    if( Gen.debug ) console.log( out )

    return out
  },

  genMax( paramArray ) {
    let def = Gen.functions[ this.name ],
        str = def.str + '(',
        count = 0
    
    // tell Gibber that this gen object is part of an active gen graph
    // so that changes to it are forwarded to m4l
    this.active = true

    if( this.name === 'rate' ) {
      str += 'in1, '
      let pName = this[ 0 ].uid
      str += pName
      paramArray.push( `Param ${pName}(${this[0]()})` )
    }else{
      for( let property of def.properties ) {
        let p = this[ property ](),
            uid = this[ property ].uid
        
        //console.log( this.name, property, def.properties, uid )
        if( Gen.isPrototypeOf( p ) ) {
          str += p.gen( paramArray )
        }else if( typeof p === 'number' ) {
          let pName = uid
          str += pName
          paramArray.push( `Param ${pName}(${p})` )
        }else if( p === Gen.time ) {
          str += p
        }else if( typeof p === 'string' ) {
          str += p
        }else{
          console.log( 'CODEGEN ERROR:', p )
        }

        if( count++ < def.properties.length - 1 ) str += ','
      }
    }
    
    str += ')'

    return str
  },

  gen( paramArray ) {
    let def = Gen.functions[ this.name ],
        str = `g.${def.str}(`,
        count = 0
    
    // tell Gibber that this gen object is part of an active gen graph
    // so that changes to it are forwarded to m4l
    this.active = true

    for( let property of def.properties ) {
      let p = this[ property ](),
          uid = this[ property ].uid
      
      //console.log( this.name, property, def.properties, uid )
      if( Gen.isPrototypeOf( p ) ) {
        str += p.gen( paramArray )
      }else if( typeof p === 'number' ) {
        let pName = 'p'+paramArray.length
        //str += pName
        paramArray.push( [`${pName}`, p ] )
        str += `g.in('${pName}')`
      }else if( p === Gen.time ) {
        str += p
      }else if( typeof p === 'string' ) {
        str += p
      }else{
        console.log( 'CODEGEN ERROR:', p )
      }

      if( count++ < def.properties.length - 1 ) str += ','
    }

    if( this.options !== undefined ) {
      str += ',' + JSON.stringify( this.options )
    }
    
    str += ')'

    return str
  },

  composites: { 
    sine( frequency=2, amp=4, center=0, shouldRound=false ) {
      return Gen.composites.lfo( 'sine', frequency, amp, center, shouldRound )
    },
    siner( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'sine', frequency, amp, center, true )
    },
    square( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'square', frequency, amp, center )
    },
    saw( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'saw', frequency, amp, center )
    },
    tri( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'tri', frequency, amp, center )
    },
    lfo( type = 'sine', frequency = 2, amp = .5, center = .5, shouldRound = false ) {
      const g = Gen.ugens 
      const gibberish= Audio.Gibberish
      let osc

      switch( type ) {
        case 'saw':
          osc = g.phasor( frequency )
          break
        case 'square':
          osc = g.add( g.mul( g.gt( g.phasor( frequency ), 0 ), 2 ), -1 )
          break
        case 'noise':
          osc = g.sub( g.mul( g.noise(), 2 ), 1 )
          break
        case 'triangle':
        case 'tri':
          const p = g.phasor( frequency )
          osc = g.sub(
            1, 
            g.mul( 
              4, 
              g.abs(
                g.sub( 
                  g.round( p ),
                  p
                )
              )
            )
          )
            
          break
        case 'sine':
        default:
          osc = g.cycle( frequency )
          break
      }

      const _mul   = g.mul( osc, amp ),
            _add   = g.add( center, _mul ) 

      const lfo = shouldRound ? Gen.make( g.round( _add ) ) : Gen.make( _add )

      Object.defineProperties( lfo, {
        frequency: {
          set(v) { lfo.p1 = v },
          get()  { return lfo.p1 }
        },
        gain: {
          set(v) { lfo.p2 = v },
          get()  { return lfo.p2 }
        },
        bias: {
          set(v) { lfo.p0 = v },
          get()  { return lfo.p0 }
        }
      })

      lfo.copy = function() {
        return Gen.composites.lfo( type, this.frequency.value, this.gain.value, this.bias.value )
      }

      return lfo
    },

    fade( time = 1, from = 1, to = 0 ) {
      let g = Gen.ugens
      let fade, amt, beatsInSeconds = time * ( 60 / Gibber.Live.LOM.bpm )
     
      if( from > to ) {
        amt = from - to

        fade = g.gtp( g.sub( from, g.accum( g.div( amt, g.mul(beatsInSeconds, g.samplerate ) ), 0 ) ), to )
      }else{
        amt = to - from
        fade = g.add( from, g.ltp( g.accum( g.div( amt, g.mul( beatsInSeconds, g.samplerate ) ), 0 ), to ) )
      }
      
      // XXX should this be available in ms? msToBeats()?
      let numbeats = time / 4
      fade.shouldKill = {
        after: numbeats, 
        final: to
      }
      
      return fade
    },
    
    //beats( num ) {
    //  return Gen.ugens.rate( num )
    //  // beat( n ) => rate(in1, n)
    //  // final string should be rate( in1, num )
    //}
    beats( b ) {
      return Gen.ugens.phasor( Audio.Utilities.btof( b ), 0, { min:0 } )
    }, 
    beats2( b ) {
      return Gen.ugens.phasor( 
        Audio.Utilities.btof( b ), 
        0, 
        { min:0 } )
    }, 
  },

  ugens:{},

  export( obj ) {
    for( let key in Gen.functions ) {
      this.ugens[ key ] = Gen.create.bind( Gen, key )
    }

    Object.assign( this.ugens, Gen.constants )
    Object.assign( this.ugens, Gen.composites )

    const __in = this.ugens.in
    delete this.ugens.in
    Object.assign( obj, this.ugens )
    this.ugens.in = __in
  },


  // defer creating genish object until we know whether
  // this will be used by an audio or visual object
  make( graph, propertyNames ) {
    const defer = { 
      graph, 
      __graph:graph,
      propertyNames,
      type:'gen',
      id: Audio.Gibberish.utilities.getUID(),
      rendered:null,
      copy() {
        return Gen.make( this.__graph )
      },
      render( samplerate=44100, type='audio' ) {
        if( type === 'audio' ) {
          if( this.rendered === null ) { 
            this.rendered = Gen.__make( this.graph, this.propertyNames, defer )
            const props = this.rendered.__wrapped__.__properties__
            for( let key in props ) { 
              Object.defineProperty( this, key, {
                configurable:true,
                get() { return this.rendered[ key] },
                set(v){
                  this.rendered[ key ] = v 
                }
              })
            } 
            this.rendered.widget = this.widget
            this.rendered.__graph = graph
          }

          return this.rendered
        }

        const store = Audio.Gibberish.genish.samplerate
        const g = Audio.Gibberish.genish

        Audio.Gibberish.genish.gen.samplerate = samplerate
        const params = []
        const __graph = eval( graph.gen( params ) )
        const callback = g.gen.createCallback( __graph )
        Audio.Gibberish.genish.gen.samplerate = store      

        const out = callback.bind( null, ...params.map( v => v[1] ), g.memory )

        // annotations can be added to the original defer, so store the defer
        // to access the annotations later
        out.pre = defer 

        return out
      },

      // XXX connecting gen objects to audio properties no longer seems
      // to work... must be assigned. FIX
      connect( target ) {
        if( target.type === 'audio' ) {
          if( this.rendered === null ) { 
            this.rendered = Gen.__make( this.graph, this.propertyNames, defer )
          }
          this.rendered.connect( target )
        }
      }
    }

    return defer
  },

  __make( graph, propertyNames, target ) {
    const ugen = Audio.Gibberish.prototypes.Ugen
    const g = Audio.Gibberish.genish

    // store properties of our gen object in this array
    // they will then become properties of our Gibber object
    const paramArray = []

    // get genish.js codelet for our graph
    const genCode = graph.gen( paramArray )

    // create a properties object out of our paramArray
    const params = {}
    for( let param of paramArray ) {
      params[ param[0] ] = param[1]
    } 

    const id = Gen.getUID()

    params.id = Audio.Gibberish.utilities.getUID()

    // pass a constructor to our worklet processor
    Audio.Gibberish.worklet.port.postMessage({ 
      address:'addMethod', 
      id:-1,
      key:'Gen' + id,
      function:`function() { 
        const g = Gibberish.genish; 
        const mymod = Object.create( Gibberish.prototypes.Ugen ); 
        Gibberish.factory( mymod, ${genCode}, 'Gen${id}', ${JSON.stringify(params)}, null, true ); 
        return mymod; 
      }`
    })

    // create a worklet-side Gibberish constructor
    const make = function() {
      const mymod = Object.create( ugen )
      // the second parameter doesn't matter in the worklet, only in the processor
      // so we can just input zeroes. hmmmm... I gues it probably matters for
      // sequencing?
      
      return Audio.Gibberish.factory( mymod, g.add(0,0), 'Gen'+id, params )
    }

    // XXX do I really have to make a Gibberish constructor and a Gibber constructor to
    // turn a genish graph into a Gibber ugen? Is there a shortcut to take? Is it worth
    // writing custom code for?

    // create a Gibber constructor using our Gibberish constructor
    let temp = params.id
    //delete params.id
    const Make = Audio.Ugen( make, { name:'Gen'+id, properties:params, methods:[]}, Audio )

    // create Gibber ugen and pass in properties dictionary to initailize
    const out = Make({ params })
    out.__wrapped__.id = temp 
    out.__wrapped__.connected = []

    let count = 0
    out.__wrapped__.output = out.output = function( v ) {
      //if( Audio.Gibber.Environment !== undefined ) {
        // XXX should these be averaged instead of only taking every sixth sample (roughly
        // corresponds to 58 frames a second)
        if( count++ % 6 === 0 ) {
          // XXX this shouldn't happen here, should happen when the annotation is created.
          if( Audio.Gibber.Environment.Annotations.waveform.widgets[ temp ] === undefined ) {
            Audio.Gibber.Environment.Annotations.waveform.widgets[ temp ] = out.widget
          }
          Audio.Gibber.Environment.Annotations.waveform.updateWidget( out.widget, v, false )
        }
      //}

      out.output.value = v
    }

    // optionally map user provided names to p values for better control / sequencing
    if( Array.isArray( propertyNames )) {
      for( let i = 0; i < propertyNames.length; i++ ){
        const propertyName = propertyNames[ i ]
        if( out[ 'p'+i ] !== undefined && propertyName !== null && propertyName !== undefined ){
          out[ '__'+propertyName ] = out[ 'p'+i ]
          Object.defineProperty( out, propertyName, {
            get() { return out[ '__' + propertyName ] },
            set(v){
              if( v === undefined || v === null ) return
              out[ '__' + propertyName ].value = v
            }
          })
          Object.defineProperty( target, propertyName, {
            get() { return out[ '__' + propertyName ] },
            set(v){
              if( v === undefined || v === null ) return
              out[ '__' + propertyName ].value = v
            }
          })

        } 
      }
    }


    out.id = temp
    out.__isGen = out.__wrapped__.__isGen = true
    out.type = 'gen'

    return out
  }
}

Gen.init()

return Gen 
}

},{}],106:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Instruments = {
  create( Audio ) {
    const instruments = {}
    //const pooledInstruments = ['Synth','Monosynth','FM']
    for( let instrumentName in Gibberish.instruments ) {
      const gibberishConstructor = Gibberish.instruments[ instrumentName ]
      if( typeof gibberishConstructor.defaults === 'object' ) gibberishConstructor.defaults.octave = 0

      const methods = Instruments.descriptions[ instrumentName ] === undefined ? null : Instruments.descriptions[ instrumentName ].methods
      const description = { 
        properties:gibberishConstructor.defaults, 
        methods:methods,
        name:instrumentName,
        category:'instruments'
      }

      //const shouldPool = pooledInstruments.indexOf( instrumentName ) > -1
      instruments[ instrumentName ] = Ugen( gibberishConstructor, description, Audio, false ) 

      // for poly notation like Synth[3]()
      // create or extend dictionary with maxVoices property
      for( let i = 0; i < 20; i++ ) {
        instruments[ instrumentName ][i] = function( ...args ) {
          if( args.length > 0 ) {
            if( typeof args[0] === 'string' ) {
              if( args.length > 1 ) {
                if( typeof args[1] === 'object' ) {
                  args[1].maxVoices = i || 1
                } 
              }else{
                args[1] = { maxVoices:i || 1 }
              }
            }else if( typeof args[0] === 'object' ) {
              args[0].maxVoices = i || 1
            }
          }else{
            args[0] = { maxVoices:i || 1 }
          } 

          // use monophonic version if voice count is 1 or less
          let name
          if( i > 1 ) {
            name = instrumentName === 'Sampler' ? 'Multisampler' : 'Poly'+instrumentName
            if( name === 'PolyMonosynth' ) name = 'PolyMono' 
          }else{
            name = instrumentName
          }

          return instruments[ name ]( ...args )
        }
      }


      instruments[ instrumentName ].presets = Audio.Presets.instruments[ instrumentName ] 
      if( instruments[ instrumentName ].presets !== undefined ) {
        instruments[ instrumentName ].presets.inspect = function() {
          console.table( this )
        }
      }else{
        instruments[ instrumentName ].presets = { inspect() { console.log( `${instrumentName} has no presets.` ) } }
      }
    }
    instruments.Pluck = instruments.Karplus
    return instruments
  },

  descriptions: {
    Clap:{
      methods:[ 'trigger' ],
    },   
    Conga:{
      methods:[ 'note','trigger' ],
    },
    Clave:{
      methods:[ 'note','trigger' ],
    },
    Cowbell:{
      methods:[ 'note','trigger' ],
    },
    FM:{
      methods:[ 'note','trigger' ],
    },
    Hat:{
      methods:[ 'note','trigger' ],
    },
    Karplus:{
      methods:[ 'note','trigger' ],
    },
    Kick:{
      methods:[ 'note','trigger' ],
    },
    Monosynth:{
      methods:[ 'note','trigger' ],
    },
    Sampler:{
      methods:[ 'note', 'trigger', 'loadFile', 'loadBuffer' ],
    },
    Multisampler:{
      methods:[ 'note', 'trigger', 'pick', 'pickFile', 'pickplay', 'loadSample', 'setpan', 'setrate' ], 
    },
    Soundfont:{
      methods:[ 'note', 'trigger', 'midinote', 'midichord', 'chord', 'load', 'setpan', 'setrate' ], 
    },
    Snare:{
      methods:[ 'note','trigger' ],
    },
    Synth:{
      methods:[ 'note','trigger' ],
    },
    Complex:{
      methods:[ 'note','trigger' ],
    },
    Tom:{
      methods:[ 'note','trigger' ],
    },
    PolySynth:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyComplex:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyFM:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyKarplus:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyMono:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyConga:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyTom:{
      methods:[ 'chord','note','trigger' ],
    },
  },
  
}

module.exports = Instruments

},{"./ugen.js":128,"gibberish-dsp":174}],107:[function(require,module,exports){
module.exports = function( Audio ) {
  const Gibberish = Audio.Gibberish

  const fnc = function( props ){
    const name = props.name
    const type = props.type
    const properties = props.properties || {}
    const block = `
    const ugen = Object.create( Gibberish.prototypes[ '${type}' ] )
    const graphfnc = ${props.constructor.toString()}

    const proxy = Gibberish.factory( ugen, graphfnc(), '${name}', ${JSON.stringify(properties)} )
    return proxy`

    Gibberish[ name ] = new Function( block )

    Gibberish.worklet.port.postMessage({
      name,
      address:'addConstructor',
      constructorString:`function( Gibberish ) {
      const fnc = ${Gibberish[ name ].toString()}

      return fnc
    }`
    })

    const out = Audio.Ugen( 
      Gibberish[ name  ],
      { properties, methods:[], name, category:'instruments'},
      Audio 
    )
    return out
  }

  return fnc
}

/* example use:
def = {
  name:'Mysine',
  type:'Ugen',
  properties:{ frequency:220 },
  constructor: function() {
    const gen = Gibberish.genish
    const graph = gen.cycle( gen.in('frequency') )
    return graph
  }
}
 
Mysine = Make( def )
sine = S()
sine.frequency.seq( [110,220,330], 1/8 )
sine.connect()
*/

},{}],108:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Oscillators = {
  create( Audio ) {
    const oscillators = {}
    const defaults = {
      frequency:220, gain:.25, pulsewidth:.5
    }
    for( let oscillatorName in Gibberish.oscillators ) {
      const gibberishConstructor = Gibberish.oscillators[ oscillatorName ]

      //const methods = Oscillators.descriptions[ oscillatorName ] === undefined ? null : Oscillators.descriptions[ oscillatorName ].methods
      const description = { 
        properties:defaults, 
        methods:[],
        name:oscillatorName,
        category:'oscillators'
      }

      oscillators[ oscillatorName ] = Ugen( gibberishConstructor, description, Audio )

    }
    return oscillators
  },

  descriptions: {},
  
}

module.exports = Oscillators

},{"./ugen.js":128,"gibberish-dsp":174}],109:[function(require,module,exports){
const Presets = {
  process( description, args, Audio ) {
    let output

    // if the constructor arugment is not a string then no preset is being used
    if( typeof args[0] === 'object' ) {
      output = args[ 0 ]  
    }else if( typeof args[0] === 'string' ){
      if( args[0] === 'inspect' ) return null
      output = {}
      const preset = Presets[ description.category ][ description.name ][ args[0] ]

      if( preset !== undefined ) {
        for( let key in preset ) {
          if( key === 'presetInit' ) continue
          let value = preset[ key ]

          // if a value is a function, run the function to get the new value. these
          // preset functions are passed the main audio object, which they can typically
          // use, for example, to query the current sample rate.
          output[ key ] = typeof value === 'function' ? value( Audio ) : value
        }
        
        if( preset.presetInit !== undefined ) {
          output.__presetInit__ = preset.presetInit 
        } 
      }else{
        console.warn( `The preset ${args[0]} for the ${description.category.slice(0,-1)} ${description.name} does not exist.` )
      }
      // if there is an extra argument to modify the preset...
      if( args.length > 1 ) {
        Object.assign( output, args[1] )
      }
    }else{
      output = {}
    }
    
    if( description.__defaults__ !== undefined ) {
      console.log( 'defaults:', description.__defaults__ )
      Object.assign( output, description.__defaults__ )
    }

    return output
  },

  instruments: {
    Complex: require( './presets/complex_presets.js' ),
    Synth: require( './presets/synth_presets.js' ),
    FM:    require( './presets/fm_presets.js' ),
    Monosynth: require( './presets/monosynth_presets.js' ),
    PolyMono: require( './presets/monosynth_presets.js' ),
    Snare: require( './presets/snare_presets.js' ),
    Kick: require( './presets/kick_presets.js' ),
    Hat: require( './presets/hat_presets.js' ),

    EDrums: require( './presets/edrums_presets.js' ),
    Drums:  require( './presets/drums_presets.js' ),
    Multisampler: require( './presets/multisampler.js' ),
    Soundfont:    require( './presets/soundfont_presets.js' )
  },

  effects: {
    Chorus: require( './presets/chorus_presets.js' ),
    Distortion: require( './presets/distortion_presets.js' ),
    Flanger: require( './presets/flanger_presets.js' ),
    Reverb: require( './presets/reverb.js' ),
    Delay: require( './presets/delay_presets.js' ),
  },

  misc: {
    Bus2: require( './presets/bus2_presets.js' )
  }

}

Presets.instruments.Sampler   = Presets.instruments.Multisampler
Presets.instruments.PolySynth = Presets.instruments.Synth
Presets.instruments.PolyFM = Presets.instruments.FM
Presets.instruments.PolyMono = Presets.instruments.Monosynth

module.exports = Presets

},{"./presets/bus2_presets.js":110,"./presets/chorus_presets.js":111,"./presets/complex_presets.js":112,"./presets/delay_presets.js":113,"./presets/distortion_presets.js":114,"./presets/drums_presets.js":115,"./presets/edrums_presets.js":116,"./presets/flanger_presets.js":117,"./presets/fm_presets.js":118,"./presets/hat_presets.js":119,"./presets/kick_presets.js":120,"./presets/monosynth_presets.js":121,"./presets/multisampler.js":122,"./presets/reverb.js":123,"./presets/snare_presets.js":124,"./presets/soundfont_presets.js":125,"./presets/synth_presets.js":126}],110:[function(require,module,exports){
module.exports = {

  'spaceverb': {
    presetInit: function( audio ) {
      this.fx.verb = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.verb )
    }
  },
  'echoverb.1/3': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/3, feedback:.35, wetdry:.5 })
      this.fx.reverb  = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.delay )
      this.fx.add( this.fx.reverb )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
      this.roomSize = this.fx.reverb.roomSize
    }
  },
  'echoverb.1/6': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/6, feedback:.35, wetdry:.5 })
      this.fx.verb  = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.delay, this.fx.reverb )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
      this.roomSize = this.fx.reverb.roomSize
    }
  },
  'delay.1/6': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/6, feedback:.35, wetdry:.5 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/3': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/3, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  }, 
  'delay.1/6.fb': {
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ time:1/6, feedback:.825, wetdry:1 })
      this.fx.add( this.delay ) 
    }
  },
  'delay.1/3.fb': {
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ time:1/3, feedback:.825, wetdry:1 })
      this.fx.add( this.delay )
    }
  },
  'delay.1/5': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/5, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/8': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/8, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/9': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/9, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
    }
  },
}

},{}],111:[function(require,module,exports){
module.exports = {

  lush: {
    fastFrequency:4,
    fastGain:.425,
    slowGain:3.5,
    slowFrequency:1,
    presetInit: function( audio ) {
      const gen = audio.Gen.ugens
      this.mod1 = audio.Gen.make( audio.Gen.ugens.cycle(.1) ).connect( this.fastFrequency )
      //this.fastGain =  audio.Gen.make( gen.add( .425, gen.cycle(.1) ) )
      this.mod2 = audio.Gen.make( audio.Gen.ugens.cycle(.05) ).connect( this.slowGain )
      //this.slowGain = audio.Gen.make( gen.add( 4.5, gen.cycle(.05) ) )
    }
  },

  warbly: {
    fastFrequency:4,
    slowGain:3,
    slowFrequency:1,
    fastGain:1.5,
    presetInit: function( audio ) {
      this.mod1 = audio.Gen.make( audio.Gen.ugens.cycle(.1) ).connect( this.fastFrequency )
      this.mod2 = audio.Gen.make( audio.Gen.ugens.cycle(.05) ).connect( this.slowGain )
    }
  }

}

},{}],112:[function(require,module,exports){
module.exports = {
  'plucked': {
    bias:.35,
    gain:1,
    decay:1/5,
    pregain:4,
    description:'a short, clean sounding preset with a minimum of distortion/wavefolding.'
  },
  
  'perc': {
    bias:.35,
    gain:1,
    decay:1/5,
    pregain:5,
    description:'a short, clean sounding preset with a minimum of distortion/wavefolding.'
  },

  stab: {
    waveform:'saw', 
    decay:1/4, 
    bias:.1, 
    filterMult:0, 
    cutoff:.8, 
    Q:.15, 
    pregain:10, 
    postgain:.25, 
    filterModel:2, 
    saturation:50,
    presetInit( audio ) {
      this.fx.push( audio.effects.Distortion('earshred') )
    },
    description:'a short, heavily distorted and filtered sound. in addition to the standard Complex wavefolding, this preset also adds an additional Distortion effect (preset earsred).'
  }

}

},{}],113:[function(require,module,exports){
module.exports = {
  '1/3' : {
    time:1/3, feedback:.35, wetdry:1 
  },
  '1/6' : {
    time:1/6, feedback:.35, wetdry:1
  },
  '1/8' : {
    time:1/8, feedback:.35, wetdry:1
  },
  '1/9' : {
    time:1/9, feedback:.35, wetdry:1
  },
  '1/3.fb' : {
    time:1/3, feedback:.85, wetdry:1 
  },
  '1/6.fb' : {
    time:1/6, feedback:.85, wetdry:1
  },
  '1/8.fb' : {
    time:1/8, feedback:.85, wetdry:1
  },
  '1/9.fb' : {
    time:1/9, feedback:.85, wetdry:1
  },
  '1/3.dry' : {
    time:1/3, feedback:.35, wetdry:.5 
  },
  '1/6.dry' : {
    time:1/6, feedback:.35, wetdry:.5
  },
  '1/8.dry' : {
    time:1/8, feedback:.35, wetdry:.5
  },
  '1/9.dry' : {
    time:1/9, feedback:.35, wetdry:.5
  },
  '1/3.dry.fb' : {
    time:1/3, feedback:.85, wetdry:.5 
  },
  '1/6.dry.fb' : {
    time:1/6, feedback:.35, wetdry:.5
  },
  '1/8.dry.fb' : {
    time:1/8, feedback:.85, wetdry:.5
  },
  '1/9.dry.fb' : {
    time:1/9, feedback:.85, wetdry:.5
  }
}

},{}],114:[function(require,module,exports){
module.exports = {

  crunch: {
    pregain:10, 
    postgain:.35
  },

  earshred: {
   pregain: 500,
   postgain: .06,
   shape1: .001,
   shape2: -3
  },

  bass: {
    pregain:10,
    postgain:.35,
    shape1:3,
    shape2:10
  },

  medium: {
    pregain:40,
    postgain:.125/4
  }
}

},{}],115:[function(require,module,exports){
module.exports = {

  earshred: {
    // unfortunately you can't write normal presets for
    // Drums and EDrums, because they don't go through
    // the Ugen constructor in the typical way (they are
    // processed as busses). It would also
    // be difficult to define properties for the individual
    // drum components (snare,kick etc.) using the standard
    // preset format. For these reasons, all property assignment
    // must be performed after initialization. 
    presetInit( audio ) {
      this.fx.add( audio.effects.Distortion('earshred') )
    }
  },

  hpf: {
    presetInit( audio ) {
      // XXX have to specify input because of filter errors...
      const hpf = audio.filters.Filter12Biquad({ input:this, mode:1, cutoff:.25, Q:.5, isStereo:true })
      this.fx.add( hpf )
      this.hpf = hpf
   }
  },
  lpf: {
    presetInit( audio ) {
      // XXX have to specify input because of filter errors...
      const lpf = audio.filters.Filter24Moog({ input:this, mode:0, cutoff:.25, Q:.75, isStereo:true })
      this.fx.add( lpf )
      this.lpf = lpf
    }
  }

}

},{}],116:[function(require,module,exports){
module.exports = {

  earshred: {
    // unfortunately you can't write normal presets for
    // Drums and EDrums, because they don't go through
    // the Ugen constructor in the typical way (they are
    // processed as busses). It would also
    // be difficult to define properties for the individual
    // drum components (snare,kick etc.) using the standard
    // preset format. For these reasons, all property assignment
    // must be performed after initialization. 
    presetInit( audio ) {
      this.fx.add( audio.effects.Distortion('earshred') )

      this.kick.frequency = 55
      this.kick.decay = .975

      this.snare.tune = .25
      this.snare.snappy = 1.5
    }
  },

  warbly: {
    presetInit( audio ) {
      const bc = audio.effects.BitCrusher({ input:this, sampleRate:.35, bitDepth:.5, isStereo:true })
      this.fx.add( bc )
      this.bitcrusher = bc
      const flanger = audio.effects.Flanger({ input:this, frequency:.8, feedback:.935, isStereo:true })
      this.fx.add( flanger )
      this.flanger = flanger
      this.gain.value *= 1.35
   }
  },
  hpf: {
    presetInit( audio ) {
      const hpf = audio.filters.Filter12Biquad({ input:this, mode:1, cutoff:.35, isStereo:true })
      this.fx.add( hpf )
      this.hpf = hpf
   }
  },
  lpf: {
    presetInit( audio ) {
      const lpf = audio.filters.Filter24Moog({ input:this, mode:1, cutoff:.35, isStereo:true })
      this.fx.add( lpf )
      this.lpf = lpf
    }
  },
  short: {
    presetInit( audio ) {
      this.kick.decay = .8
      this.snare.decay = .05
      this.closedHat.decay = .05
      this.openHat.decay = .2
      this.cowbell.decay = .1
    }
  },
  long: {
    presetInit( audio ) {
      this.kick.decay = .975
      this.snare.decay = .1
      this.closedHat.decay = .1
      this.openHat.decay = .25
    }
  }

}

},{}],117:[function(require,module,exports){
module.exports = {
  moderate: {
    feedback: .25,
    frequency:.5,
    offset:.1
  },

  extreme: {
    feedback:.85,
    offset:.05,
    frequency:4
  },

}

},{}],118:[function(require,module,exports){
module.exports = {

  bass : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/16,
    octave:-2
  },
  deepbass : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/2,
    octave:-3,
    feedback:.005
  },
  kick:{
    attack : 1/4096,
    index : 5,
    cmRatio : 4/3,
    decay : 1/4,
    octave : -3,
    shape:'exponential'
  },

  perc:{
    attack : 1/4096,
    index : .5,
    cmRatio : 4/3,
    decay : 1/8,
    shape:'exponential',
    presetInit: function( audio ) {
      if( this.voices && this.voices.length > 1 ) {
        this.spread( .99 )
      }
    }
  },

  'bass.electro' : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/16,
    octave:-2,
    filterModel:2,
    saturation:200,
    Q:.25,
    cutoff:.6835
  },

  glockenspiel : {
    cmRatio	: 3.5307,
    index 	: 1,
    attack	: audio => audio.Clock.ms( 1 ),
    decay	: audio => audio.Clock.ms( 1000 ),
  },

  'glockenspiel.short' : {
    cmRatio	: 3.5307,
    index 	: 1,
    attack	: audio => audio.Clock.ms( 1 ),
    decay	  : 1/12,
    octave  : 1,
    gain    :.05 
  },

  frog : { //ljp
    cmRatio: 0.1,
    index: 2.0,
    attack: audio => audio.Clock.ms( 300 ), 
    decay: audio => audio.Clock.ms( 5 )
  },

  gong : {
    cmRatio: 1.4,
	  index: .95,
	  attack: 1/256,
	  decay: 2,
	},

  drum : {
	  cmRatio: 1.40007,
	  index: 2,
	  attack: 1/2048,
    decay: audio => audio.Clock.ms(1000) 
	},

	drum2: {
		cmRatio: 1 + Math.sqrt(2),
		index: .2,
		attack: 1/256,
		decay: audio => audio.Clock.ms(20) 
  },

	brass : {
    maxVoices:4,
	  cmRatio : 1 / 1.0007,
		index	: 5,
		attack: audio => audio.Clock.ms(100),
		decay	: 1,
    gain:.5,
  },

	clarinet : {
		cmRatio	: 3 / 2,
		index	: 1.5,
		attack: audio => audio.Clock.ms( 50 ), 
		decay:  audio => audio.Clock.ms( 200 )
  },

  fun : {
    decay:1/2,
    feedback: .0015,
    gain:.1
  },

  chirp: {
		attack: audio => audio.Clock.ms( 1 ), 
    index : 1.15,
    glide : 1,
    feedback : .5,
    cmRatio : 1.5,
    decay : 1/4,
    octave : 1,
    shape:'exponential'
  }
}

},{}],119:[function(require,module,exports){
module.exports = {
  short: {
    decay:.01
  }
}

},{}],120:[function(require,module,exports){
module.exports = {

  deep: {
    frequency:55,
    decay:.96,
  },

  tight: {
    frequency:80, 
    decay:.85,
    tone:.5
  },

  long: {
    frequency:80,
    decay:.975,
  },

  boom: {
    frequency:55,
    decay:.99,
    tone:.05
  }


}

},{}],121:[function(require,module,exports){
module.exports = {

  'short.dry' : { 
    attack: audio => audio.Clock.ms(.25), 
    decay: 1/12,
    cutoff:.3,
    filterModel:1,
    filterMult:3
  },

  arpy : {
    antialias:true,
    attack: audio => audio.Clock.ms(.5),
    decay: 1/16, 
    gain:0.2,
    cutoff:.15,
    filterMult:1,
    Q:.3,
    filterModel:1,
    filterMode:1
  },

  lead : {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.5),
    decay: 1/2, 
    octave3:0,
    cutoff:1,
    filterMult:2.5,
    Q:.975,
    filterModel:1,
    filterMode:1
  },
  // not as bright / loud
  lead2 : {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.5),
    decay: 1/2, 
    octave3:0,
    cutoff:1,
    filterMult:2.5,
    Q:.8,
    gain:.175,
    filterModel:1,
    filterMode:1
  },

  dirty: { 
    gain:.325,
    filterModel:2,
    attack:1/2048, 
    decay:1/4, 
    cutoff:1.5, 
    filterMult:4, 
    saturation:10000, 
    Q:.225, 
    detune2:-.505,
    detune3:-.5075,
    octave:-2,
    waveform:'pwm', 
    pulsewidth:.15 
  },

  winsome : {
    presetInit : function( audio ) { 
      this.lfo = audio.oscillators.Sine({ frequency:2, gain:.075 })
      this.lfo.connect( this.cutoff )
      this.lfo.connect( this.detune2 )
      this.lfo.connect( this.detune3 )
    },
    attack: audio => audio.Clock.ms(1), 
    decay:1,
    cutoff:.2,
  },

  pluckEcho: {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.1),
    decay: 1/16, 
    octave3:0,
    cutoff:.15,
    filterMult:1,
    Q:.5,
    filterModel:1,
    filterMode:1,
    panVoices:true
  },

  bassPad : { 
    attack: audio => audio.Clock.ms(.1),
    decay: 2,	
    octave:-4,
    cutoff: .225,
    filterMult:3.5,
    Q:.5,
    detune2:1.0125,
    detune3:1-.0125
  },

  warble : { 
    attack: audio => audio.Clock.ms(1),
    decay: 1/2,	
    octave: -3,
    octave2 : -1,
    cutoff: .8,
    filterMult:3,
    Q:.75,
    detune2:.0275,
    detune3:-.0275
  }, 
  dark: { 
    attack: audio => audio.Clock.ms(1),
    decay: 1,	
    octave: -3,
    octave2 : -1,
    cutoff: 1.5,
    filterMult:3,
    Q:.75,
    detune2:.0125,
    detune3:-.0125
  },
  bass: { 
    attack: audio => audio.Clock.ms(1),
    decay: 1/4,	
    octave: -3,
    cutoff: .35,
    filterMult:3,
    Q:.15,
    glide:1250,
    waveform:'pwm',
    pulsewidth:.45,
    detune2:.005,
    detune3:-.005
  },
  bass2 : {
    attack: audio => audio.Clock.ms(1), 
    decay:	1/6,
    octave: -2,
    octave2 : 0,
    octave3 : 0,      
    cutoff: .5,
    filterMult:2,
    Q:.5,
    gain:.35
  },
  
  edgy: {
    decay:1/8,
    attack:1/1024,
    octave: -2,
    octave2: -1,
    cutoff: .5,
    filterMult:3,
    Q:.75, 
    waveform:'pwm', 
    pulsewidth:.2,
    detune2:0,
    gain:.2
  },

  easy : {
    attack: audio=> audio.Clock.ms(1),
    decay:2,
    cutoff:.3,
    glide:.9995,
  },
  
  easyfx : {
    attack: audio=> audio.Clock.ms(1),
    decay:2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Delay( Clock.time(1/6), .3) )
    },
    cutoff:.125,
    glide:1000,
    detune2:.001,
    detune3:-.001,
    filterModel:1,
    filterMult:4,
    Q:.5,
  },
  chords: {
    attack: audio=> audio.Clock.ms(1),
    decay:1/2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Delay( Clock.time(1/6), .5) )
    },
    amp:.3,
    octave2:0,
    octave3:0,
    cutoff:.5,
    glide:.9995,
    filterModel:1,
    filterMult:3,
    Q:.75,
  },

  wander: {
    attack: 1/2,
    decay:  2,
    presetInit: function( audio ) {},
    amp:.2,
    detune2:.501,
    detune3:-.501,
    cutoff:.2,
    glide:5000,
    filterModel:1,
    filterMult:1.5,
    Q:.25,
  },

  'chords.short': {
    attack: audio=> audio.Clock.ms(1),
    decay:1/8,
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ delay:audio.Clock.time(1/8), feedback:.5, wetdry:.25 }) 
      this.fx.push( this.delay )
    },
    amp:.3,
    octave2:0,
    octave3:0,
    cutoff:.35,
    glide:1,
    filterModel:1,
    filterMult:3,
    Q:.5,
  },

  jump: { 
    decay:1/2048, 
    useADSR:true, 
    sustain:1/4, 
    release:1/1024,  
    maxVoices:3, 
    cutoff:35, 
    filterMult:0,
    detune2:.01,
    detune3:-.01 
  },

  shinybass2: {
    Q:.125,
    cutoff:35,
    useADSR:true,
    decay:1/10,
    sustain:1/4,
    filterMult:0,
    release:1/1024,
    octave:-3,
    panVoices:true
  },
  shinybass: {
    Q:.125,
    cutoff:5,
    useADSR:false,
    attack:1/1024,
    decay:1/10,
    filterMult:0,
    octave:-3,
    panVoices:true
  },

  'bass.muted': {
    Q:.45,
    cutoff:.5,
    useADSR:true,
    shape:'exponential',
    decay:1/8,
    sustain:1/4,
    release:1/1024,
    octave:-3,
    panVoices:true,
    filterMult:.5
  },
  'bass.stab': {
    Q:.35,
    detune2:1.5,
    detune3:.5,
    cutoff:.5,
    useADSR:true,
    shape:'exponential',
    decay:1/10,
    sustain:1/4,
    release:1/1024,
    octave:-3,
    filterMult:1.85,
    gain:.75
  },
  short: { 
    attack:1/4096,
    decay:1/16, 
    maxVoices:3, 
    cutoff:1.5, 
    filterMult:0,
    useADSR:false,
    gain:.5
  },

  noise: {
    decay:1/2,
    cutoff:.3,
    glide:10000,
    detune3:0,
    detune2:0,
    filterMult:0,
    presetInit: function( audio ) { this.fx.add( audio.effects.Gain(.1), audio.effects.Delay(1/6,.75) ) }
  },

}

},{}],122:[function(require,module,exports){
module.exports = {

  drums: { 
    files:[
      'resources/audiofiles/kick.wav',
      'resources/audiofiles/hat.wav',
      'resources/audiofiles/snare.wav',
      'resources/audiofiles/openhat.wav'
    ],
    presetInit() {
      this.length = 4
    }
  },
  test: {
    files:[
      'resources/audiofiles/kick.wav',
      'resources/audiofiles/openhat.wav'
    ],
    presetInit() {
      this.length = 2
    }
  },
  beatbox: {
    files:[
      'resources/audiofiles/beatbox/^k.wav',
      'resources/audiofiles/beatbox/^p.wav',
      'resources/audiofiles/beatbox/^tss.wav',
      'resources/audiofiles/beatbox/8.wav',
      'resources/audiofiles/beatbox/a.wav',
      'resources/audiofiles/beatbox/b.wav',
      'resources/audiofiles/beatbox/d.wav',
      'resources/audiofiles/beatbox/dot.wav',
      'resources/audiofiles/beatbox/duf.wav',
      'resources/audiofiles/beatbox/f.wav',
      'resources/audiofiles/beatbox/k.wav',
      'resources/audiofiles/beatbox/h.wav',
      'resources/audiofiles/beatbox/m.wav',
      'resources/audiofiles/beatbox/n.wav',
    ],
    presetInit() {
      this.length = 14
    }
  },
  bleeps: {
    files:[
      'resources/audiofiles/bent-bleeps/51063__stamperadam__bleep1.wav',
      'resources/audiofiles/bent-bleeps/51064__stamperadam__bleep2.wav',
      'resources/audiofiles/bent-bleeps/51065__stamperadam__clap.wav',
      'resources/audiofiles/bent-bleeps/51066__stamperadam__click.wav',
      'resources/audiofiles/bent-bleeps/51067__stamperadam__click1.wav',
      'resources/audiofiles/bent-bleeps/51068__stamperadam__g1.wav',
      'resources/audiofiles/bent-bleeps/51069__stamperadam__g2.wav',
      'resources/audiofiles/bent-bleeps/51070__stamperadam__g3.wav',
      'resources/audiofiles/bent-bleeps/51071__stamperadam__g4.wav',
      'resources/audiofiles/bent-bleeps/51072__stamperadam__g5.wav',
      'resources/audiofiles/bent-bleeps/51073__stamperadam__g6.wav',
      'resources/audiofiles/bent-bleeps/51074__stamperadam__g7.wav',
      'resources/audiofiles/bent-bleeps/51075__stamperadam__g8.wav',
      'resources/audiofiles/bent-bleeps/51076__stamperadam__g9.wav',
      'resources/audiofiles/bent-bleeps/51077__stamperadam__glitch.wav',
      'resources/audiofiles/bent-bleeps/51078__stamperadam__hatt.wav',
      'resources/audiofiles/bent-bleeps/51079__stamperadam__hit.wav',
      'resources/audiofiles/bent-bleeps/51080__stamperadam__hitt.wav',
      'resources/audiofiles/bent-bleeps/51081__stamperadam__hum.wav',
      'resources/audiofiles/bent-bleeps/51082__stamperadam__kik.wav',
      'resources/audiofiles/bent-bleeps/51083__stamperadam__snar.wav',
      'resources/audiofiles/bent-bleeps/51084__stamperadam__wa.wav',
    ],
    presetInit() {
      this.length = 22
    }
  },
  cr7030: {
    files:[
      'resources/audiofiles/cr7030/68602__birdflu__bongo7030.wav',
      'resources/audiofiles/cr7030/68603__birdflu__clave7030.wav',
      'resources/audiofiles/cr7030/68606__birdflu__hatclosed7030.wav',
      'resources/audiofiles/cr7030/68607__birdflu__hatopen7030.wav',
      'resources/audiofiles/cr7030/68608__birdflu__kick7030.wav',
      'resources/audiofiles/cr7030/68609__birdflu__snare7030.wav',
      'resources/audiofiles/cr7030/68610__birdflu__tom7030.wav',
    ],
    presetInit(){
      this.length = 7
    }
  },
  kicks: {
    files:[
      'resources/audiofiles/kicks/249200__netr-si__kick-32.wav',
      'resources/audiofiles/kicks/249201__netr-si__kick-33.wav',
      'resources/audiofiles/kicks/249202__netr-si__kick-27.wav',
      'resources/audiofiles/kicks/249203__netr-si__kick-28.wav',
      'resources/audiofiles/kicks/249204__netr-si__kick-25.wav',
      'resources/audiofiles/kicks/249205__netr-si__kick-26.wav',
      'resources/audiofiles/kicks/249206__netr-si__kick-30.wav',
      'resources/audiofiles/kicks/249207__netr-si__kick-31.wav',
      'resources/audiofiles/kicks/249208__netr-si__kick-29.wav',
      'resources/audiofiles/kicks/249209__netr-si__kick-3.wav',
      'resources/audiofiles/kicks/249211__netr-si__kick-42.wav',
      'resources/audiofiles/kicks/249212__netr-si__kick-41.wav',
      'resources/audiofiles/kicks/249213__netr-si__kick-35.wav',
      'resources/audiofiles/kicks/249214__netr-si__kick-34.wav',
      'resources/audiofiles/kicks/249215__netr-si__kick-37.wav',
      'resources/audiofiles/kicks/249216__netr-si__kick-36.wav',
      'resources/audiofiles/kicks/249217__netr-si__kick-39.wav',
      'resources/audiofiles/kicks/249218__netr-si__kick-38.wav',
      'resources/audiofiles/kicks/249219__netr-si__kick-40.wav',
      'resources/audiofiles/kicks/249220__netr-si__kick-4.wav',
      'resources/audiofiles/kicks/249222__netr-si__kick-87.wav',
      'resources/audiofiles/kicks/249223__netr-si__kick-9.wav',
      'resources/audiofiles/kicks/249224__netr-si__kick-83.wav',
      'resources/audiofiles/kicks/249225__netr-si__kick-84.wav',
      'resources/audiofiles/kicks/249226__netr-si__kick-85.wav',
      'resources/audiofiles/kicks/249227__netr-si__kick-86.wav',
      'resources/audiofiles/kicks/249228__netr-si__kick-8.wav',
      'resources/audiofiles/kicks/249229__netr-si__kick-80.wav',
      'resources/audiofiles/kicks/249230__netr-si__kick-81.wav',
      'resources/audiofiles/kicks/249231__netr-si__kick-82.wav',
      'resources/audiofiles/kicks/249232__netr-si__kick-20.wav',
      'resources/audiofiles/kicks/249233__netr-si__kick-2.wav',
      'resources/audiofiles/kicks/249234__netr-si__kick-19.wav',
      'resources/audiofiles/kicks/249235__netr-si__kick-18.wav',
      'resources/audiofiles/kicks/249236__netr-si__kick-24.wav',
      'resources/audiofiles/kicks/249237__netr-si__kick-23.wav',
      'resources/audiofiles/kicks/249238__netr-si__kick-22.wav',
      'resources/audiofiles/kicks/249239__netr-si__kick-21.wav',
      'resources/audiofiles/kicks/249240__netr-si__kick-25-2.wav',
      'resources/audiofiles/kicks/249241__netr-si__kick-25-1.wav',
      'resources/audiofiles/kicks/249242__netr-si__kick-12.wav',
      'resources/audiofiles/kicks/249243__netr-si__kick-11.wav',
      'resources/audiofiles/kicks/249244__netr-si__kick-10.wav',
      'resources/audiofiles/kicks/249245__netr-si__kick-1.wav',
      'resources/audiofiles/kicks/249246__netr-si__kick-15.wav',
      'resources/audiofiles/kicks/249247__netr-si__kick-14.wav',
      'resources/audiofiles/kicks/249248__netr-si__kick-14-1.wav',
      'resources/audiofiles/kicks/249249__netr-si__kick-13.wav',
      'resources/audiofiles/kicks/249250__netr-si__kick-17.wav',
      'resources/audiofiles/kicks/249251__netr-si__kick-16.wav',
      'resources/audiofiles/kicks/249252__netr-si__kick-67.wav',
      'resources/audiofiles/kicks/249253__netr-si__kick-68.wav',
      'resources/audiofiles/kicks/249254__netr-si__kick-65.wav',
      'resources/audiofiles/kicks/249255__netr-si__kick-66.wav',
      'resources/audiofiles/kicks/249256__netr-si__kick-63.wav',
      'resources/audiofiles/kicks/249257__netr-si__kick-64.wav',
      'resources/audiofiles/kicks/249258__netr-si__kick-61.wav',
      'resources/audiofiles/kicks/249259__netr-si__kick-62s.wav',
      'resources/audiofiles/kicks/249260__netr-si__kick-69.wav',
      'resources/audiofiles/kicks/249261__netr-si__kick-7.wav',
      'resources/audiofiles/kicks/249262__netr-si__kick-75.wav',
      'resources/audiofiles/kicks/249263__netr-si__kick-74.wav',
      'resources/audiofiles/kicks/249264__netr-si__kick-77.wav',
      'resources/audiofiles/kicks/249265__netr-si__kick-76.wav',
      'resources/audiofiles/kicks/249266__netr-si__kick-71.wav',
      'resources/audiofiles/kicks/249267__netr-si__kick-70.wav',
      'resources/audiofiles/kicks/249268__netr-si__kick-73.wav',
      'resources/audiofiles/kicks/249269__netr-si__kick-72.wav',
      'resources/audiofiles/kicks/249270__netr-si__kick-79.wav',
      'resources/audiofiles/kicks/249271__netr-si__kick-78.wav',
      'resources/audiofiles/kicks/249272__netr-si__kick-43.wav',
      'resources/audiofiles/kicks/249273__netr-si__kick-44.wav',
      'resources/audiofiles/kicks/249274__netr-si__kick-45.wav',
      'resources/audiofiles/kicks/249275__netr-si__kick-46.wav',
      'resources/audiofiles/kicks/249276__netr-si__kick-47.wav',
      'resources/audiofiles/kicks/249277__netr-si__kick-48.wav',
      'resources/audiofiles/kicks/249278__netr-si__kick-49.wav',
      'resources/audiofiles/kicks/249279__netr-si__kick-5.wav',
      'resources/audiofiles/kicks/249280__netr-si__kick-50.wav',
      'resources/audiofiles/kicks/249281__netr-si__kick-51.wav',
      'resources/audiofiles/kicks/249282__netr-si__kick-60.wav',
      'resources/audiofiles/kicks/249283__netr-si__kick-6.wav',
      'resources/audiofiles/kicks/249284__netr-si__kick-59.wav',
      'resources/audiofiles/kicks/249285__netr-si__kick-58.wav',
      'resources/audiofiles/kicks/249286__netr-si__kick-57.wav',
      'resources/audiofiles/kicks/249287__netr-si__kick-56.wav',
      'resources/audiofiles/kicks/249288__netr-si__kick-55.wav',
      'resources/audiofiles/kicks/249289__netr-si__kick-54.wav',
      'resources/audiofiles/kicks/249290__netr-si__kick-53.wav',
      'resources/audiofiles/kicks/249291__netr-si__kick-52.wav',
    ],
    presetInit() { this.length = 90 }
  }
}

},{}],123:[function(require,module,exports){
module.exports = {

  'space': {
    roomSize:.985, 
    dry:1 
  }
}

},{}],124:[function(require,module,exports){
module.exports = {

  snappy: {
    decay:.125,
    snappy:1.5,
    tune:.1
  },

  dull: {
    snappy:.15,
    decay:.15,
    tune:-.1
  }

}

},{}],125:[function(require,module,exports){
 const names = [
    "Acoustic Grand Piano",
    "Bright Acoustic Piano",
    "Electric Grand Piano",
    "Honky-tonk Piano",
    "Electric Piano 1",
    "Electric Piano 2",
    "Harpsichord",
    "Clavi",
    "Celesta",
    "Glockenspiel",
    "Music Box",
    "Vibraphone",
    "Marimba",
    "Xylophone",
    "Tubular Bells",
    "Dulcimer",
    "Drawbar Organ",
    "Percussive Organ",
    "Rock Organ",
    "Church Organ",
    "Reed Organ",
    "Accordion",
    "Harmonica",
    "Tango Accordion",
    "Acoustic Guitar (nylon)",
    "Acoustic Guitar (steel)",
    "Electric Guitar (jazz)",
    "Electric Guitar (clean)",
    "Electric Guitar (muted)",
    "Overdriven Guitar",
    "Distortion Guitar",
    "Guitar harmonics",
    "Acoustic Bass",
    "Electric Bass (finger)",
    "Electric Bass (pick)",
    "Fretless Bass",
    "Slap Bass 1",
    "Slap Bass 2",
    "Synth Bass 1",
    "Synth Bass 2",
    "Violin",
    "Viola",
    "Cello",
    "Contrabass",
    "Tremolo Strings",
    "Pizzicato Strings",
    "Orchestral Harp",
    "Timpani",
    "String Ensemble 1",
    "String Ensemble 2",
    "SynthStrings 1",
    "SynthStrings 2",
    "Choir Aahs",
    "Voice Oohs",
    "Synth Voice",
    "Orchestra Hit",
    "Trumpet",
    "Trombone",
    "Tuba",
    "Muted Trumpet",
    "French Horn",
    "Brass Section",
    "SynthBrass 1",
    "SynthBrass 2",
    "Soprano Sax",
    "Alto Sax",
    "Tenor Sax",
    "Baritone Sax",
    "Oboe",
    "English Horn",
    "Bassoon",
    "Clarinet",
    "Piccolo",
    "Flute",
    "Recorder",
    "Pan Flute",
    "Blown Bottle",
    "Shakuhachi",
    "Whistle",
    "Ocarina",
    "Lead 1 (square)",
    "Lead 2 (sawtooth)",
    "Lead 3 (calliope)",
    "Lead 4 (chiff)",
    "Lead 5 (charang)",
    "Lead 6 (voice)",
    "Lead 7 (fifths)",
    "Lead 8 (bass + lead)",
    "Pad 1 (new age)",
    "Pad 2 (warm)",
    "Pad 3 (polysynth)",
    "Pad 4 (choir)",
    "Pad 5 (bowed)",
    "Pad 6 (metallic)",
    "Pad 7 (halo)",
    "Pad 8 (sweep)",
    "FX 1 (rain)",
    "FX 2 (soundtrack)",
    "FX 3 (crystal)",
    "FX 4 (atmosphere)",
    "FX 5 (brightness)",
    "FX 6 (goblins)",
    "FX 7 (echoes)",
    "FX 8 (sci-fi)",
    "Sitar",
    "Banjo",
    "Shamisen",
    "Koto",
    "Kalimba",
    "Bag pipe",
    "Fiddle",
    "Shanai",
    "Tinkle Bell",
    "Agogo",
    "Steel Drums",
    "Woodblock",
    "Taiko Drum",
    "Melodic Tom",
    "Synth Drum",
    "Reverse Cymbal",
    "Guitar Fret Noise",
    "Breath Noise",
    "Seashore",
    "Bird Tweet",
    "Telephone Ring",
    "Helicopter",
    "Applause",
    "Gunshot"
  ]

module.exports = {}

for( let name of names ) {
  module.exports[ name ] = {
    presetInit( audio, props ) {
      this.load( names.indexOf( name ), props === undefined ? 0 : props.bank || 0 )
    }
  }
}


},{}],126:[function(require,module,exports){
module.exports = {

  acidBass: {
    Q:.9,
    filterModel:2,
    filterMult:4,
    cutoff:1.25,
    saturation:3.5,
    attack:1/8192,
    decay:1/10,
    octave:-3,
    glide:2000,
    description:`A sawtooth feeding a TB303-style lowpass filter, with high Q settings and a short envelope.`
  },

  acidBass2: {
    Q:.7,
    filterModel:2,
    filterMult:3.5,
    cutoff:.5,
    saturation:10,
    attack:1/8192,
    decay:1/10,
    octave:-2,
    glide:100
  },

  'bass.hollow': {
    Q:.2,
    filterModel:2,
    filterMult:4,
    cutoff:1.25,
    saturation:20,
    attack:1/8192,
    decay:1/4,
    octave:-3,
    glide:1000
  },

  'bleep.dry': { 
    attack:1/256, decay:1/32, 
    waveform:'sine' 
  },
  'bleep': { 
    attack:1/256, decay:1/32, 
    waveform:'sine' 
  },

  'bleep.echo': { 
    waveform:'sine', 
    attack:1/256, decay:1/32, 
    gain:.25,
    presetInit: function( audio ) {
      this.fx.push( audio.effects.Delay({ feedback:.5, time:1/12 }) )
    }
  },

  shimmer: {
    attack:1/128, decay:2,
    waveform:'pwm',
    filterModel:1,
    cutoff:1,
    filterMult:1,
    Q:.6,
    maxVoices:3,
    gain:.1,
    antialias:false,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Chorus('warbly') )
      this.pwmod = audio.Gen.make( audio.Gen.ugens.mul( audio.Gen.ugens.cycle(8), .275 ) )
      this.pwmod.connect( this.pulsewidth )
    }
  },

  stringPad: {
    attack:1/2, decay:1.5, gain:.015,
    presetInit: function( audio ) {
      this.fx.chorus = audio.effects.Chorus('lush')
      this.fx.add( this.fx.chorus  )
    }
  },

  cry: {
    attack:1/2, decay:1.5, gain:.045,
    panVoices:true,
    presetInit: function( audio ) {
      this.chorus = audio.effects.Chorus('lush', { isStereo:true })
      this.fx.add( this.chorus  )
      this.bitCrusher = audio.effects.BitCrusher({ bitDepth:.5, isStereo:true })
      this.fx.add( this.bitCrusher )
      //// gen( .5 + cycle( btof(16) ) * .35
      this.srmod = audio.Gen.make( audio.Gen.ugens.add( .5, audio.Gen.ugens.mul( audio.Gen.ugens.cycle(.125/2), .35 ) ) )
      this.bitCrusher.sampleRate = this.srmod
      this.delay = audio.effects.Delay({ time:1/6, feedback:.75 })
      this.fx.add( this.delay )
    }
  },

  brass: {
    attack:1/6, decay:1.5, gain:.05,
    filterModel:1, Q:.5575, cutoff:2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Chorus('lush') )
      this.chorus = this.fx[0]
    }
  },

  'brass.short':{
    gain:.75,
    filterModel:1,
    antialias:true,
    attack:1/32,
    decay:1/16,
    filterMult:3,
    cutoff:.175,
    Q:.6
  },

  'pwm.squeak':{
    waveform:'pwm',
    attack:1/4096,
    decay:1/16,
    Q:.8,
    cutoff:.65,
    saturation:5,
    filterModel:2,
    glide:500
  },

  'pwm.short':{
    attack:1/1024,
    decay:1/8,
    antialias:true,
    waveform:'pwm'
  },

  chirp: { filterModel:2, cutoff:.325, decay:1/16 }, 

  'square.perc': { 
    waveform:'square', 
    shape:'exponential', 
    antialias:true, 
    filterModel:2, 
    cutoff:.25, 
    decay:1/8,
    panVoices:true
  },

  'square.perc.long': { 
    waveform:'square', 
    shape:'exponential', 
    antialias:true, 
    filterModel:2, 
    cutoff:.25, 
    decay:2,
    panVoices:true
  },

  rhodes:{
    waveform:'sine',
    presetInit( audio ) {
      this.tremolo = audio.effects.Tremolo()
      this.fx.add( this.tremolo )
    },
    decay:4,
    gain:.125,
    shape:'exponential'
  },

  blank: {
    filterModel:0,
    waveform:'sine',
    antialias:false
  }
}

},{}],127:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const serialize = require( 'serialize-javascript' )
const Tune      = require( './external/tune-api-only.js' )

let Gibber = null

const Theory = {
  // needed to force library to be serialized for transport to 
  // worklet processor, must use key:function() {} format
  // for methods for serialize to work
  __Tune:Tune,

  Tune:null,
  id:null,
  type: 'Audio',
  nogibberish:true,
  quality:'minor',
  baseNumber:60,
  __tuning:'et',
  __mode: 'aeolian',
  __root:440,
  __offset:0,
  __degree:'i',
  __loadingPrefix:'js/external/tune.json/', 
  __tunings:{
    et: {
      root:'60',
      mode:'absolute',
      frequencies:[
        261.62558,
        277.182617,
        293.664764,
        311.126984,
        329.627563,
        349.228241,
        369.994415,
        391.995422,
        415.304688,
        440,
        466.163757,
        493.883301,
        523.251083727363
      ],
      description:'equal tempered (edo)'
    }
  },  

  modes: {
    ionian:     [0,2,4,5,7,9,11],
    dorian:     [0,2,3,5,7,9,10],
    phrygian:   [0,1,3,5,7,8,10],
    lydian:     [0,2,4,6,7,9,11],
    mixolydian: [0,2,4,5,7,9,10],
    aeolian:    [0,2,3,5,7,8,10],
    locrian:    [0,1,3,5,6,8,10],
    melodicminor:[0,2,3,5,7,8,11],
    wholeHalf:  [0,2,3,5,6,8,9,11],
    halfWhole:  [0,1,3,4,6,7,9,10],
    chromatic:  [0,1,2,3,4,5,6,7,8,9,10,11],
  },

  store:function() { 
    Gibberish.Theory = this

    this.Tune.TuningList = this.__tunings

    this.initProperties()
  },

  setup( tuning='et', mode='aeolian' ) {
    this.tuning = tuning
    this.mode = mode
  }, 

  // adapted from https://gist.github.com/stuartmemo/3766449
  __noteToFreq( note ) {
    note = note.toUpperCase() 

    let notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'],
        octave,
        keyNumber

    if (note.length === 3) {
      octave = note.charAt(2)
    } else {
      octave = note.charAt(1)
    }
    keyNumber = notes.indexOf(note.slice(0, -1))
    if (keyNumber < 3) {
      keyNumber = keyNumber + 12 + ((octave - 1) * 12) + 1
    } else {
      keyNumber = keyNumber + ((octave - 1) * 12) + 1
    }

    return 440 * Math.pow(2, (keyNumber- 49) / 12)
  },

  deleteProperties: function() {
    if( Gibberish.mode === 'worklet' ) {
      delete this.__root
      delete this.__tuning
      delete this.__mode
      delete this.__offset
      delete this.__degree

      Theory.markup = {
        textMarkers : {},
        cssClasses: {}
      }

      this.__root = 440
      this.__tuning = 'et'
      this.__offset = 0
      this.__degree = 'i'
      this.__mode = 'aeolian'
    }
  },

  initProperties: function() {
    if( Gibberish.mode === 'worklet' ) {
      Gibber.createProperty( 
        this, 'root', 440, function() {
          if( typeof Theory.__root.value === 'string' ) {
            Theory.root = Theory.__noteToFreq( Theory.__root.value )
          } 
        },
        
        1
      )

      Gibber.createProperty( 
        this, 'tuning', 'et', 
        function() { // XXX why doesn't this work??? duplicated below... 
          this.loadScale( this.__tuning.value ) 
        },
        1
      )

      Gibber.createProperty( this, 'mode', 'aeolian', null, 0 )
      Gibber.createProperty( this, 'offset', 0, null, 0 )
      Gibber.createProperty( this, 'degree', 'i', null, 0 )

      //setTimeout( ()=> Theory.tuning = 'et', 250 )
      this.tuning = 'et'
      //this.loadScale('et')
    }else{
      this.__initDegrees()

      Object.defineProperty( this, 'root', {
        get() { return this.__root },
        set(v) {
          if( typeof v=== 'string' ) {
            v = this.__noteToFreq( v )
          } 
          this.__root = v
          this.Tune.tonicize( this.__root )
        }
      })

      Object.defineProperty( this, 'tuning', {
        get() { return this.__tuning },
        set(v) {
          this.__tuning = v
          //this.loadScale( v )
        }
      })

      Object.defineProperty( this, 'mode', {
        get()  { return this.__mode },
        set(v) { 
          if( this.modes[ v ] !== undefined || v === null ) {
            this.__mode = v 
          }else{
            console.error( `The mode "${v}" is not valid. Valid modes include ${Object.keys(this.modes).toString()}, and null. No change to Theory.mode was applied.` )
          }
        }
      })

      Object.defineProperty( this, 'offset', {
        get()  { return this.__offset },
        set(v) { this.__offset = v }
      })

      Object.defineProperty( this, 'degree', { 
        get() { return this.__degree },
        set( __degree ) {
          if( typeof __degree  === 'string' ) {
            const degree = this.__degrees[ this.quality ][ __degree ]
        
            this.__degree = degree
            //this.rootNumber = degree.offset + this.baseNumber
            this.mode = degree.mode
          }
        }
      })

      this.degree = 'i'
    }
  },

  __degrees: { major:{}, minor:{} },

  __initDegrees:function() {
    const base = [ 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii' ]

    const scales = [ { name:'minor', values:this.modes.aeolian }, { name:'major', values:this.modes.ionian } ]

    for( let scale of scales ) {
      let name = scale.name
      let values = scale.values

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ]
        this.__degrees[ name ][ chord ] = { mode:'aeolian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'aeolian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'aeolian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'aeolian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'aeolian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ].toUpperCase()
        this.__degrees[ name ][ chord ] = { mode:'ionian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'ionian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'ionian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'ionian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'ionian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + '7'
        this.__degrees[ name ][ chord ] = { mode:'dorian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'dorian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'dorian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'dorian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'dorian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ].toUpperCase() + '7'
        this.__degrees[ name ][ chord ] = { mode:'mixolydian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'mixolydian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'mixolydian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'mixolydian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'mixolydian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + 'o'
        this.__degrees[ name ][ chord ] = { mode:'locrian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'locrian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'locrian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'locrian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'locrian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + 'M7'
        this.__degrees[ name ][ chord ] = { mode:'melodicminor', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'melodicminor', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'melodicminor', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'melodicminor', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'melodicminor', offset: values[i] + 24 }
      }
    }
  },

  init:function( __Gibber ) {
    Gibber = __Gibber

    this.Tune = new this.__Tune()
    this.Tune.TuningList = this.__tunings

    if( Gibberish.mode === 'worklet' ) {
      this.id = Gibberish.utilities.getUID()

      // can't send prototype methods of Tune over processor
      // so they need to be explicitly assigned
      this.Tune.loadScale = this.Tune.__proto__.loadScale
      this.Tune.note = this.Tune.__proto__.note
      this.Tune.frequency = this.Tune.__proto__.frequency
      this.Tune.tonicize = this.Tune.__proto__.tonicize
      this.Tune.ratio = this.Tune.__proto__.ratio
      this.Tune.MIDI = this.Tune.__proto__.MIDI
      
      Gibberish.worklet.port.postMessage({
        address:'add',
        properties:serialize( Theory ),
        id:this.id,
        post:'store'
      })

      Gibber.subscribe( 'clear', () => this.reset() )
      this.initProperties()
    }

    this.__initDegrees()
  },

  reset:function() {
    Theory.root = 440
    Theory.mode = 'aeolian'
    Theory.tuning = 'et'
    Theory.degree = 'i'
    Theory.offset = 0
  },

  freeze:function() {
    if( Gibberish.mode === 'worklet' ) {
      Gibber.Theory.degree.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.offset.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.mode.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.root.sequencers.forEach( s => s.stop() )  
    }
  },

  thaw:function() {
    if( Gibberish.mode === 'worklet' ) {
      this.degree.sequencers.forEach( s => s.start() )  
      this.offset.sequencers.forEach( s => s.start() )  
      this.mode.sequencers.forEach( s => s.start() )  
      this.root.sequencers.forEach( s => s.start() )  
    }
  },

  loadScale: function( name ) {
    if( Gibberish.mode === 'worklet' ) {
      // if the scale is already loaded...
      if( this.__tunings[ name ] !== undefined ) {
        this.__tuning.value = name
        this.Tune.loadScale( name )

        Gibberish.worklet.port.postMessage({
          address:'method',
          object:this.id,
          name:'loadScale',
          args:[name]
        })
        return
      }

      const path = this.__loadingPrefix + name + '.js' 
      fetch( path )
        .catch( console.err )
        .then( data => {
          if( data.ok ) {
            return data.json()
          }else{
            console.error( `The tuning ${name} wasn't found. Please visit http://abbernie.github.io/tune/scales.html to find the names of valid tunings.`) 
          } 
        })
        .then( json => {
          this.__tuning.value = name
          Gibberish.worklet.port.postMessage({
            address:'addToProperty',
            object:this.id,
            name:'__tunings',
            key:name,
            value:json
          })

          Gibberish.worklet.port.postMessage({
            address:'method',
            object:this.id,
            name:'loadScale',
            args:[name]
          })

          this.__tunings[ name ] = json
          this.Tune.loadScale( name )
        })
    }else{
      this.Tune.loadScale( name )
    }
  },

  // REMEMBER THAT THE .note METHOD IS ALSO MONKEY-PATCHED
  // IN ugen.js, THIS IS WHERE MOST OF THE AWPROCESSOR NOTE
  // METHOD IS IMPLEMENTED.
  note: function( __idx, octave=0, round=true ) {
    let finalIdx, mode = null, __float = __idx % 1, baseOctave, nextOctave

    let isInt = __float === 0
    if( !isInt && round===true ) {
      __idx = Math.round( __idx )
      isInt = true
    }
    
    let baseIndex = __idx < 0 ? Math.ceil( __idx ) : Math.floor( __idx ),
        nextIndex = __idx >= 0 ? baseIndex + 1 : baseIndex - 1

    baseIndex += Gibberish.Theory.__offset
    nextIndex += Gibberish.Theory.__offset

    if( Gibberish.Theory.mode !== 'chromatic' && Gibberish.Theory.mode !== null ) {
      mode = Gibberish.Theory.modes[ Gibberish.Theory.mode ]
      baseOctave = Math.floor( baseIndex / mode.length )
      nextOctave = Math.floor( nextIndex / mode.length )
      
      // XXX this looks crazy ugly but works with negative note numbers...
      baseIndex = baseIndex < 0 
        ? mode[ (mode.length - (Math.abs( baseIndex ) % mode.length)) % mode.length ] 
        : mode[ Math.abs( baseIndex ) % mode.length ]

      if( !isInt ) {
        nextIndex = nextIndex < 0 
          ? mode[ (mode.length - (Math.abs( nextIndex ) % mode.length)) % mode.length ] 
          : mode[ Math.abs( nextIndex ) % mode.length ]
      }
    }else{
      // null mode also means to use 'chromatic' mode
      mode = Gibberish.Theory.modes[ 'chromatic' ]
      const l = Gibberish.Theory.Tune.scale.length 
      baseOctave = Math.floor( baseIndex / l )
      nextOctave = Math.floor( baseIndex / l )

      baseIndex = baseIndex < 0 
        ? mode[ (l - (Math.abs( baseIndex ) % l)) % l ] 
        : mode[ Math.abs( baseIndex ) % l ]

      if( !isInt ) {
        nextIndex = nextIndex < 0 
          ? mode[ (l - (Math.abs( nextIndex ) % l)) % l ] 
          : mode[ Math.abs( nextIndex ) % l ]
      }
    }

    baseIndex += this.__degree.offset
    nextIndex += this.__degree.offset

    let outputFreq = 0
    if( !isInt ) {
      const freq0 = Gibberish.Theory.Tune.note( baseIndex, baseOctave )
      const freq1 = Gibberish.Theory.Tune.note( nextIndex, nextOctave )
      let   diff  = freq1 - freq0
      if( __idx < 0 ) diff *= -1
      outputFreq = freq0 + (diff*__float)
    }else{
      outputFreq = Gibberish.Theory.Tune.note( baseIndex, baseOctave )
    }

    return outputFreq 
  },
}

module.exports = Theory

},{"./external/tune-api-only.js":102,"gibberish-dsp":174,"serialize-javascript":231}],128:[function(require,module,exports){
const Presets = require( './presets.js' )
const Theory  = require( './theory.js' )
const Gibberish = require( 'gibberish-dsp' )

// Gibber ugens are essentially wrappers around underlying gibberish 
// ugens, providing convenience methods for rapidly sequencing
// and modulating them.

const poolSize = 12

// DRY method for removing a sequence and its associated annotations.
const removeSeq = function( obj, seq ) {
  const idx = obj.__sequencers.indexOf( seq )
  obj.__sequencers.splice( idx, 1 )
  seq.stop()
  seq.clear()
}

const createMapping = function( from, to, name, wrappedTo ) {
  if( from.__useMapping === false ) {
    wrappedTo[ name ] = from
  }else if( from.type === 'audio' ) {
    const f = to[ '__' + name ].follow = Follow({ input: from })

    let m = f.multiplier
    Object.defineProperty( to[ name ], 'multiplier', {
      get() { return m },
      set(v) { m = v; f.multiplier = m }
    })

    let o = f.offset
    Object.defineProperty( to[ name ], 'offset', {
      get() { return o },
      set(v) { o = v; f.offset = o }
    })

    wrappedTo[ name ] = f
  }else if( from.type === 'gen' ) {
    // gen objects can be referred to without the graphics/audio abstraction,
    // in which case they will have no .render() function, and don't need to be rendered
    const gen = from.render !== undefined ? from.render() : from

    wrappedTo[ name ] = gen
  }
}

const Ugen = function( gibberishConstructor, description, Audio, shouldUsePool = false, isBinop = false ) {

  let   poolCount = poolSize
  const pool = []

  const constructor = function( ...args ) {
    const properties = Presets.process( description, args, Audio ) 
    const timeProps = Audio.timeProps[ description.name ] === undefined ? [] : Audio.timeProps[ description.name ]

    if( timeProps.length > 0 ) {
      for( let key in properties ) {
        if( timeProps.indexOf( key ) > -1 ) {
          properties[ key ] = Audio.Clock.time( properties[ key ] )
        }
      }
    }

    // XXX if you want to use pooling you must also uncomment near the bottom of this file...
    // Pooling could work for reverbs IF:
    // 1. There would have to be separate mono and stereo pools.2
    // 2. Reverbs would need to run with 0 input for a while so that the functions are JIT'd

    //if( shouldUsePool && poolCount < pool.length ) {
    //  pool[ poolCount ].inUse = true
    //  const poolUgen = pool[ poolCount ].ugen
    //  poolCount++
    //  Object.assign( poolUgen, properties, args )
    //  console.log( 'pool ugen:', poolUgen )
    //  return poolUgen
    //}

    let __wrappedObject
    if( isBinop === true ) {
      __wrappedObject = gibberishConstructor( ...args ) 
    }else{
      __wrappedObject = gibberishConstructor( properties )
    }
    
    const obj = { 
      __wrapped__ :__wrappedObject,
      __sequencers : [], 
      __tidals: [],
      name:description.name,
      type:'audio',

      stop( time=null ) {
        if( time === null ) {
          for( let seq of this.__sequencers ) seq.stop()
          for( let seq of this.__tidals ) seq.stop()
        }else{
          time = Audio.Clock.time( time )
          for( let seq of this.__sequencers ) {
            future( seq => seq.stop(), time, { seq })
          }

          for( let seq of this.__tidals ) {
            future( seq => seq.stop(), time, { seq })
          }
        }
        return this
      },
      play( time=null ) {
        if( time === null ) {
          for( let seq of this.__sequencers ) seq.start()
          for( let seq of this.__tidals ) seq.start()
        }else{
          time = Audio.Clock.time( time )
          for( let seq of this.__sequencers ) {
            future( seq => seq.start(), time, { seq })
          }

          for( let seq of this.__tidals ) {
            future( seq => seq.start(), time, { seq })
          }
        }

        return this
      },
      clear() {
        for( let seq of this.__sequencers ) {
          seq.clear()
        }
        for( let seq of this.__tidals ) {
          seq.clear()
        }
        //console.log( Gibberish.mode, __wrappedObject.connected )
        if( __wrappedObject.connected !== undefined ) {
          for( let connection of __wrappedObject.connected ) {
            if( this.fx.indexOf( connection[ 0 ] ) === -1 ) {
              this.disconnect( connection[ 0 ] )
            }else{
              this.disconnect()
            }
          }
        }
        if( this.__onclear !== undefined ) {
          this.__onclear()
        }
      }
    }

    // add poly methods
    if( description.name.indexOf('Poly') > -1 || description.name.indexOf('Multi') > -1 || description.name.indexOf('Soundfont') > -1 ) {
      let useProp = description.name.indexOf('Poly') > -1
      obj.spread = function( amt=1 ) {
        if( amt === 0 ) {
          children.forEach( (c,i) => { 
            if( useProp ) 
              c.pan = .5 
            else 
              if( obj.maxVoices.value > 1 ) obj.setpan(i,.5) 
          })
          return obj
        }
        const children = this.__wrapped__.voices
        const incr = 1/(children.length-1) * amt
        children.forEach( (c,i) => {
          if( useProp ) 
            c.pan = (.5 - amt/2) + i * incr
          else
            if( obj.maxVoices.value > 1 ) obj.setpan( i, (.5-amt/2) + i * incr )
        })

        return obj
      }
      obj.voices = obj.__wrapped__.voices
      obj.inspect = function() {
        console.group( 'Inspecting ' + description.name )
        console.table( Object.assign({}, obj.voices[0].__wrapped__.__properties__, obj.__wrapped__.__properties__ ) )
        console.groupEnd()
      }
      for( let i = 0; i < 20; i++ ) {
        Object.defineProperty( obj, i, { get() { return obj.voices[i] } })
      }
    }
//btos: function( beats ) {
//    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
//    return samplesPerBeat * beats 
//  }
    // transform beat values to samples
    // in the case of a gen graph convert to a new gen object
    const timetransform = function( v ) {
      const out = typeof v === 'number' 
        ? Audio.Clock.time( v ) 
        : v.type === 'gen' 
          ? Gen.make( 
              genish.mul( 
                genish.div( 44100, genish.div( Clock.bpm, 60 ) ),
                v.graph
              ) 
            )
          : v

      return out
    }

    // wrap properties and add sequencing to them
    for( let propertyName in description.properties ) {
      if( __wrappedObject.__requiredRecompilation && __wrappedObject.__requiresRecompilation.indexOf( propertyName ) > -1 ) continue
      // XXX we have to pass id in the values dictionary under 
      // certain conditions involoving gen ugens, but we don't 
      // want .id to be sequencable!
      if( propertyName !== 'id' && propertyName !== 'type' ){
        const transform = timeProps.indexOf( propertyName ) > -1 
          ? timetransform
          : null 

        const value = __wrappedObject[ propertyName ] === undefined 
          ? __wrappedObject.__properties__[ propertyName ]
          : __wrappedObject[ propertyName ]

        Audio.createProperty( obj, propertyName, value, null, 0, transform )

        // create per-voice version of property... what properties should be excluded?
        if( description.name.indexOf('Poly') > -1 || description.name.indexOf('Multi') > -1 || description.name.indexOf('Soundfont') > -1 ) {
          Audio.createProperty( obj, propertyName+'V', value, null, 0, transform, true )//, timeProps, Audio, true )

          //createProperty( obj, propertyName, __wrappedObject, timeProps, Audio, true )
          // we don't have a way to add properties to objects in the processor thread
          // so we'll just add a method... sequencing will still work the same.
          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:propertyName+'V',
            function:`function( v ) {this.voices[ this.voiceCount % this.voices.length ][ '${propertyName}' ] = v }`
          })
        }
      }
    }

    if( description.methods !== null && description.methods.indexOf( 'note' ) > -1 ) { 
      description.methods.push( 'notef' )
      description.methods.push( 'notec' )
    }

    // wrap methods and add sequencing to them
    if( description.methods !== null ) {
      for( let methodName of description.methods ) {
        if( methodName !== 'note' || description.name.indexOf('Sampler') > -1 || description.name.indexOf('Multisampler') > -1 ) { //|| description.name.indexOf('Soundfont') > -1 ) {
          //obj[ methodName ] = __wrappedObject[ methodName ].bind( __wrappedObject )
          obj[ methodName ] = function( ...args ) {
            if( args.length === 0 ) {
              __wrappedObject[ methodName ]()
            }else{ //if( args.length === 1 ) {
              //if( Array.isArray( args[0] ) ) {
              //  obj[ methodName ].seq( args[0], 1/args[0].length )
              //}else if( typeof args[0] === 'string' ) {
              //  obj[ methodName ].tidal( args[0] )
              //}else{
                __wrappedObject[ methodName ]( ...args )
              //}
            }/*else{
              // could be a .tidal or a seq 
              if( typeof args[0] === 'string' ) { // must be tidal with tidal id #
                obj[ methodName ].tidal( ...args )
              }else{
                obj[ methodName ].seq( ...args )  // must be sequence
              }
            }*/
            return obj
          }
        }else{
          // in this block we are monkey patching the note method of Gibberish synths so that
          // they use Gibber's harmonic system inside the AudioWorkletProcessor.

          obj[ methodName ] = function( ...args ) {
            let shouldSendNoteNow = false
            if( args.length === 0 ) {
               shouldSendNoteNow = true
            }else if( args.length === 1 ) {
              if( Array.isArray( args[0] ) ) {
                obj[ methodName ].seq( args[0], 1/args[0].length )
              }else if( typeof args[0] === 'string' ) {
                obj[ methodName ].tidal( args[0] )
              }else{
                shouldSendNoteNow = true
              }
            }else{
              /*
              // could be a .tidal or a seq 
              if( typeof args[0] === 'string' ) { // must be tidal with tidal id #
                obj[ methodName ].tidal( ...args )
              }else{
                obj[ methodName ].seq( ...args )  // must be sequence
              }
              */
            }

            // this should only be for direct calls from the IDE
            if( shouldSendNoteNow && Gibberish.mode === 'worklet' ) {
              Gibberish.worklet.port.postMessage({
                address:'method',
                object:__wrappedObject.id,
                name:methodName,
                args
              })
            }

            return obj
          }

          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:'notef',
            function:`function( note, __loudness=null ){
              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.___note( note, loudness ) 
            }`
          })
          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:'notec',
            function:`function( note, __loudness=null ){
              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.note( note, loudness, false ) 
            }`
          })
          // when a message is received at the address 'monkeyPatch',
          // Gibberish will create a copy of the method identified by
          // the 'key' field, and then assign it back to the object prefaced
          // with double underscores (e.g. __note). The function that is being
          // patched in can then call the original function using the prefaced 
          // name, as is done in the last line of the argument function below.
          Gibberish.worklet.port.postMessage({
            address:'monkeyPatch',
            id:__wrappedObject.id,
            key:'note',
            function:`function( note, __loudness, round=true ){ 
              const octave = this.octave || 0
              let notesInOctave = 7
              const mode = Gibberish.Theory.mode

              if( mode !== null ) {
                notesInOctave = mode !== 'chromatic' ? Gibberish.Theory.modes[ mode ].length : Gibberish.Theory.Tune.scale.length
              }else{
                notesInOctave = Gibberish.Theory.Tune.scale.length
              }

              const offset = octave * notesInOctave
              let __note = Gibberish.Theory.note( note + offset, 0, round )

              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.___note( __note, loudness ) 
            }`
          })
          
        }

        if( methodName === 'notef' ) {
          obj.notef = function( ...args ) {
            __wrappedObject.frequency = args[0]
            __wrappedObject.trigger( __wrappedObject.__triggerLoudness )

            return obj
          }
        }

        if( methodName === 'notec' ) {
          obj.notec = function( ...args ) {
            //__wrappedObject.frequency = args[0]
            //__wrappedObject.trigger( __wrappedObject.__triggerLoudness )
            Gibberish.worklet.port.postMessage({
              address:'method',
              object:__wrappedObject.id,
              name:'notec',
              args
            })
            return obj
          }
        }
        obj[ methodName ].sequencers = []
        obj[ methodName ].tidals = []

        obj[ methodName ].seq = function( values, timings, number=0, delay=0, priority=10000 ) {
          console.log( 'method seq:', methodName, number )
          let prevSeq = obj[ methodName ].sequencers[ number ] 
          if( prevSeq !== undefined ) { 
            const idx = obj.__sequencers.indexOf( prevSeq )
            obj.__sequencers.splice( idx, 1 )
            //prevSeq.stop()
            prevSeq.clear()
            // removeSeq( obj, prevSeq )
          }

          let s = Audio.Core.Seq({ values, timings, target:obj/*__wrappedObject*/, key:methodName, priority })
          
          if( typeof delay !== 'function' ) {
            s.start( Audio.Clock.time( delay ) )
          }else{
            delay.seqs.push( s )
          }
          obj[ methodName ].sequencers[ number ] = obj[ methodName ][ number ] = s 
          obj.__sequencers.push( s )

          // return object for method chaining
          return obj
        }
        obj[ methodName ].tidal= function( pattern, number=0, delay=0 ) {
          let prevSeq = obj[ methodName ].tidals[ number ] 
          let s = Audio.Core.Tidal({ pattern, target:__wrappedObject, key:methodName })
          if( s !== null ) {
            if( prevSeq !== undefined ) { 
              const idx = obj.__tidals.indexOf( prevSeq )
              obj.__tidals.splice( idx, 1 )
              prevSeq.stop()
              prevSeq.clear()
              // removeSeq( obj, prevSeq )
            }

            s.start( Audio.Clock.time( delay ) )
            obj[ methodName ].tidals[ number ] = obj[ methodName ][ number ] = s 
            obj.__tidals.push( s )

            // XXX need to clean this up! this is solely here for annotations, and to 
            // match what I did for ensembles... 
            obj[ methodName ].__tidal = s
          }

          // return object for method chaining
          return obj
        }

        
      }
    }


    let id = __wrappedObject.id
    Object.defineProperty( __wrappedObject, 'id', {
      configurable:false,
      get() { return id },
      set(v) {
        //console.log( 'tried to change id:', obj )
        //debugger
      }
    })
    obj.id = __wrappedObject.id

    obj.__follow = null

    const followcheck = ()=> {

    }

    Object.defineProperty( obj, '__out', {
      configurable:false,
      get() {
        if( obj.__follow === null ) {
          obj.__follow = Audio.analysis.Follow({ input:obj }) 
        }

        const output = obj.__follow.output
         
        // will take a few buffers to initialize...
        if( output === undefined ) return 0

        return output[1] === undefined ? output[0] : output[0] + output[1] 
      },
      set(v) {}
    })

    obj.inspect = ()=> {
      console.group( 'Inspecting ' + description.name )
      const keys = Object.keys( obj.__wrapped__.__properties__ )
      const props = {}
      keys.forEach( key => {
        if( key[0] !== '_' ) {
          if( obj[ key ] !== null && obj[ key ] !== undefined ) {
            props[ key ] = obj[ key ].value
          }
        }
      })
      console.table( props ) 
      //console.table( obj.__wrapped__.__properties__ )
      console.groupEnd()
    }

    obj.out = function( scale=1, offset=0, bufferSize=null ) {
      // if the buffer size changes...
      if( bufferSize !== null ) {
        if( obj.__follow !== null ) {
          if( bufferSize !== obj.__follow.__wrapped__.bufferSize ) {
            //console.log( 'prev follow', bufferSize, obj.__follow.__wrapped__.bufferSize, obj.__follow )
            
            const tmp = obj.__follow
            // XXX need to remove the previous follow from the graph...
            obj.__follow = Audio.analysis.Follow({ input:Audio.Gibberish.worklet.ugens.get( obj.__follow.__wrapped__.input.id ), bufferSize })

            Audio.Gibberish.worklet.port.postMessage({
              address:'eval',
              code:`const idx = Gibberish.analyzers.findIndex( ugen => ugen.id === ${tmp.id} )
                    if( idx > -1 ) {
                      Gibberish.analyzers.splice(idx,1)
                      Gibberish.dirty( Gibberish.analyzers )
                    }`
            })
          }
        }
      }

      if( Ugen.OUTPUT === Ugen.OUTPUT_FUNCTION )
        return ()=> obj.__out * scale + offset
      else
        return Math.abs( obj.__out * scale ) + offset 
    }

    // XXX where does shouldAddToUgen come from? Not from presets.js...
    if( properties !== undefined && properties.shouldAddToUgen ) Object.assign( obj, properties )

    // create fx chaining api. e.g. synth.fx.add( Chorus(), Freeverb() )
    // we use the 'add' method to enable method chaining alongside instrument calls to
    // .connect() and .seq()

    const __fx = []
    __fx.__push = __fx.push.bind( __fx )
    __fx.add = function( ...args ) {
      args.forEach( fx => obj.__fx.push( fx ) )
      console.log( `added ${args.length} effect(s) to ${obj.name}` )
      return obj
    }
    __fx.inspect = function() {
      if( __fx.length > 0 )
        console.table( __fx.map( fx=>fx.name ) )
      else
        console.log( `there are no effects on ${obj.name} to inspect.` )
    }
    __fx.remove = function( effect=null ) {
      if( effect === null ) {
        obj.__fx.length = 0
        console.log( `all effects from ${obj.name} were removed.` )
      }else if( typeof effect === 'number' ) {
        // XXX broken for indices that !== 0
        const del = obj.__fx.splice( effect, 1 )
        console.log( `${del[0].name} at fx slot ${effect} was removed from ${obj.name}.` ) 
      }else if( typeof effect === 'string' ) {
        const indexesToErase = []
        __fx.forEach( (__effect,i) => { if( effect === __effect.name ) indexesToErase.push( i ) })
        console.log( `${indexesToErase.length} effect(s) were removed from ${obj.name}.` ) 
        for( let i = __fx.length - 1; i >= 0; i-- ) {
          if( indexesToErase.includes( i ) ) __fx.splice( i, 1 )
        }   
      } else if( typeof effect === 'object' ) {
        const idx = __fx.indexOf( effect )
        __fx.splice( idx, 1 )
        console.log( `effect ${effect.name} was removed from ${obj.name}.` ) 
      }
    }
    obj.__fx = new Proxy( __fx, {
      set( target, property, value, receiver ) {

        const lengthCheck = target.length
        const old = target.slice(0)
        target[ property ] = value
        
        if( property === 'length' ) { 
          if( target.length > 1 ) {
            // XXX need to store and reassign to end connection
            target[ target.length - 2 ].disconnect()
            target[ target.length - 2 ].connect( target[ target.length - 1 ] )
            target[ target.length - 1 ].connect()
          }else if( target.length === 1 ) {
            const connected = __wrappedObject.connected !== undefined ?__wrappedObject.connected.slice(0) : null
            __wrappedObject.disconnect()
            __wrappedObject.connect( target[ 0 ] )

            if( connected !== null ) {
              for( let connection of connected ) {
                // 0 is bus, 1 is ugen adding the fx, 2 is send amount
                target[0].connect( connection[0], connection[2] )
              }
            }else{
              target[0].connect( Audio.Master )
            }
          }else if( value === 0 && lengthCheck !== 0 ) {
            // ugh...
            if( __wrappedObject.connected !== undefined ) {
              if( __wrappedObject.connected[0] !== undefined ) {
                __wrappedObject.connect( 
                  __wrappedObject.connected[ 0 ][ 0 ].__wrapped__.connected[ 0 ][ 0 ], 
                  __wrappedObject.connected[ 0 ][ 0 ].__wrapped__.connected[ 0 ][ 2 ] 
                )

                __wrappedObject.connected[ 0 ][ 0 ].disconnect()
              }
            }
          }

        }

        return true
      }
    })

    Object.defineProperty( obj, 'fx', {
      get() { return obj.__fx },
      set(v) {
        const tmpLength = obj.__fx.length
        obj.__fx.length = 0
        if( Array.isArray( v ) ) {
          v.forEach( effect => obj.__fx.push( effect ) ) 
        }else{
          obj.__fx.push( v ) 
        }

        if( tmpLength > 0 ) {

            console.log( `${tmpLength} effect(s) were replaced with ${obj.__fx.length} effect(s) on ${obj.name}` )
        }else{

          if( Array.isArray( v ) ) {
            console.log( `${v.length} effect(s) were added to the fx chain of ${obj.name}` )
          }else{
            console.log( `a ${v.name} was added to the fx chain  of ${obj.name}` )
          }
        }
      }
    })

    obj.connect = (dest,level=1) => {
      if( typeof dest !== 'number' ) {
        if( dest !== undefined && dest.isProperty === true ) {
          // if first modulation for property, store it's initial
          // value before modulating it.
          if( dest.preModValue === undefined ) { 
            dest.preModValue = dest.value
          }

          dest.mods.push( obj )

          const sum = dest.mods.concat( dest.preModValue )
          const add = Audio.binops.Add( ...sum ) 
          // below works for oscillators, above works for instruments...
          //const add = Gibber.Gibberish.binops.Add( ...sum ) 
          add.__useMapping = false
          dest.__owner[ dest.name ] = add

          obj.__wrapped__.connected.push( [ dest.__owner[ dest.name ], obj ] )
        }else{
          // if no fx chain, connect directly to output
          if( obj.fx.length === 0 ) {
            __wrappedObject.connect( dest, level )
          }else{
            // otherwise, connect last effect in chain to output
            obj.fx[ obj.fx.length - 1 ].__wrapped__.connect( dest, level )
          }
        }
      }else{
        console.log( '%cYou cannot connect to a number; perhaps you meant this to be the level for your connection?', 'color:white;background:#900' )
      }

      return obj 
    } 

    obj.disconnect = dest => { 
      // if there's an effect chain, we disconnect that in addition
      // to disconnecting the ugen itself.
      if( dest === undefined && obj.fx.length > 0 ) {
        obj.fx[ obj.fx.length - 1 ].disconnect()
      }

      __wrappedObject.disconnect(); 
      
      return obj 
    } 

    Object.defineProperty( obj, '_', { get() { obj.disconnect(); return obj } })

    // presetInit is a function in presets that triggers actions after the ugen
    // has been instantiated... it is primarily used to add effects and modulations
    // to a preset.
    if( properties !== undefined && properties.__presetInit__ !== undefined ) {
      properties.__presetInit__.call( obj, Audio, args[1] )
    }

    // only connect if shouldNotConneect does not equal true (for LFOs and other modulation sources)
    if( obj.__wrapped__.type === 'instrument' || obj.__wrapped__.type === 'oscillator' || description.name.indexOf('Poly') > -1 ) {
      if( typeof properties !== 'object' || properties.shouldNotConnect !== true ) {
        
        if( Audio.autoConnect === true ) {
          // ensure that the ugen hasn't already been connected through the fx chain,
          // possibly through initialization of a preset
          if( obj.fx.length === 0 ) obj.connect( Audio.Master )
        }
      }

    }else if( obj.__wrapped__.type === 'effect' ) {
      obj.bus = function() {
        const b = Audio.busses.Bus2()
        b.fx.add( obj )

        const p = new Proxy( b, {
          set( target, property, value, receiver ) {
            // console.log( 'set:', target, property, value, receiver )
            if( b[ property ] === undefined && property !== 'input' ) {
              obj[ property ] = value
            }else{
              b[ property ] = value
            }
          },
          get( target, property, value, receiver ) {
            if( b[ property ] === undefined && property !== 'input' ) {
              return obj[ property ]
            }else{
              return b[ property ]
            }
          }
        })

        p.inspect = function() {
          console.group( 'Inspecting ' + description.name + ' ' + 'Bus' )

          const objKeys = Object.keys( obj.__wrapped__.__properties__ )
          const __obj = {}
          objKeys.forEach( key => {
            //console.log( 'key:', key, obj.__wrapped__ )
            if( key[0] !== '_' && key !== 'bypass' && obj[key] !== undefined ) {
              __obj[ key ] = obj[ key ].value !== undefined
                ? obj[ key ].value
                : obj.__wrapped__.__properties__[ key ].value
            }
          })
          console.group( description.name.toLowerCase() )
          console.table( __obj )
          console.groupEnd()

          console.group('bus')
          console.table( b.__wrapped__.__properties__ )
          console.groupEnd()

          console.groupEnd()
        }

        return p
      }
    }
    //console.log( `%c${description.name} created.`, 'color:white;background:#009' )
    Audio.publish( 'new ugen', description.name + ' created'  )

    return obj
  }

  //if( shouldUsePool ) {
  //  for( let i=0; i < poolSize; i++ ) {
  //    pool[ i ] = {
  //      inUse:false,
  //      ugen: constructor()
  //    }
  //  } 

  //  poolCount = 0
  //}
  
  //Ugen.createProperty = createProperty

  return constructor
}

Ugen.OUTPUT_FUNCTION = 0
Ugen.OUTPUT_SCALAR = 1
Ugen.OUTPUT = 1


module.exports = Ugen

},{"./presets.js":109,"./theory.js":127,"gibberish-dsp":174}],129:[function(require,module,exports){
const Utility = {
  rndf( min=0, max=1, number, canRepeat=true ) {
    let out = 0
  	if( number === undefined ) {
  		let diff = max - min,
  		    r = Math.random(),
  		    rr = diff * r

  		out =  min + rr;
  	}else{
      let output = [],
  		    tmp = []

  		for( let i = 0; i < number; i++ ) {
  			let num
        if( canRepeat ) {
          num = Utility.rndf(min, max)
        }else{
          num = Utility.rndf( min, max )
          while( tmp.indexOf( num ) > -1) {
            num = Utility.rndf( min, max )
          }
          tmp.push( num )
        }
  			output.push( num )
  		}

  		out = output
  	}

    return out
  },

  Rndf( _min = 0, _max = 1, quantity, canRepeat=true ) {
    // have to code gen function to hard code min / max values inside, as closures
    // or bound values won't be passed through the worklet port.XXX perhaps there should
    // be a way to transfer a function and its upvalues through the worklet? OTOH,
    // codegen works fine.

    const fncString = `const min = ${_min}
    const max = ${_max} 
    const range = max - min
    const canRepeat = ${quantity} > range ? true : ${ canRepeat }

    let out

    if( ${quantity} > 1 ) { 
      out = []
      for( let i = 0; i < ${quantity}; i++ ) {
        let num = min + Math.random() * range

        if( canRepeat === false ) {
          while( out.indexOf( num ) > -1 ) {
            num = min + Math.random() * range
          }
        }
        out[ i ] = num
      }
    }else{
      out = min + Math.random() * range 
    }

    return out;`
    
    return new Function( fncString )
  },

  rndi( min = 0, max = 1, number, canRepeat = true ) {
    let range = max - min,
        out
    
    if( range < number ) canRepeat = true

    if( typeof number === 'undefined' ) {
      range = max - min
      out = Math.round( min + Math.random() * range )
    }else{
  		let output = [],
  		    tmp = []

  		for( let i = 0; i < number; i++ ) {
  			let num
  			if( canRepeat ) {
  				num = Utility.rndi( min, max )
  			}else{
  				num = Utility.rndi( min, max )
  				while( tmp.indexOf( num ) > -1 ) {
  					num = Utility.rndi( min, max )
  				}
  				tmp.push( num )
  			}
  			output.push( num )
  		}
  		out = output
    }
    return out
  },

  Rndi( _min = 0, _max = 1, quantity=1, canRepeat = false ) {
    // have to code gen function to hard code min / max values inside, as closures
    // or bound values won't be passed through the worklet port.XXX perhaps there should
    // be a way to transfer a function and its upvalues through the worklet? OTOH,
    // codegen works fine.

    const fncString = `const min = ${_min}
    const max = ${_max} 
    const range = max - min
    const canRepeat = ${quantity} > range ? true : ${ canRepeat }

    let out

    if( ${quantity} > 1 ) { 
      out = []
      for( let i = 0; i < ${quantity}; i++ ) {
        let num = min + Math.round( Math.random() * range );

        if( canRepeat === false ) {
          while( out.indexOf( num ) > -1 ) {
            num = min + Math.round( Math.random() * range );
          }
        }
        out[ i ] = num
      }
    }else{
      out = min + Math.round( Math.random() * range ); 
    }

    return out;`
    
    return new Function( fncString )
  },

  time( v ) { return Gibber.Audio.Clock.time( v ) },
  btof( beats ) { return 1 / (beats * ( 60 / Gibber.Audio.Clock.bpm )) },

  random() {
    this.randomFlag = true
    this.randomArgs = Array.prototype.slice.call( arguments, 0 )

    return this
  },

  elementArray: function( list ) {
    let out = []

    for( var i = 0; i < list.length; i++ ) {
      out.push( list.item( i ) )
    }

    return out
  },
  
  __classListMethods: [ 'toggle', 'add', 'remove' ],

  create( query ) {
    let elementList = document.querySelectorAll( query ),
        arr = Utility.elementArray( elementList )
    
    for( let method of Utility.__classListMethods ) { 
      arr[ method ] = style => {
        for( let element of arr ) { 
          element.classList[ method ]( style )
        }
      } 
    }

    return arr
  },

  chord( ptrn, offsets ) {
    // gotta codegen function for worklet processor... similar to Rndi etc.
    let fncstr = `args.override = args[0]
    const values = []\n`

    for( let i = 0; i < offsets.length; i++ ) {
      fncstr += `values[${i}] = args[0] + ${offsets[i]}\n`
    }

    fncstr += `args[0] = values\n  return args`

    const fnc = new Function( 'args', fncstr )

    ptrn.addFilter( fnc )

    return ptrn
  },

  export( obj ) {
    obj.rndi = this.rndi
    obj.rndf = this.rndf
    obj.Rndi = this.Rndi
    obj.Rndf = this.Rndf
    obj.btof = this.btof
    obj.chord = this.chord
    obj.time = this.time

    Array.prototype.rnd = this.random
  }
}

module.exports = Utility

},{}],130:[function(require,module,exports){
module.exports = function( Gibber ) {
   const gen = Gibber.Gen.make  

   // will use this in a few places...
   const beats = b => {
     return phasor( Gibber.Utilities.btof( b ), 0, { min:0 } )
   }

   // needs to support changing values in more than one place
   // in the graph, hence the array of __params.
   const addProp = ( obj, prop, __params, __value ) => {
     let value = __value
     Object.defineProperty( obj, prop, {
       configurable:true,
       get() { return value },
       set(v) {
         value = v
         for( let __param of __params ) {
           __param.value = value
         }
       }
     })
   }

   const WavePatterns = {
     Beats( numBeats ) {
       const ugen = gen( beats( numBeats ) )
       ugen.isGen = ugen.__wrapped__.isGen = true
       
       return ugen 
     },

     SineR( period, gain, bias=0 ) {
       const ugen =  gen( floor( add( bias, mul( cycle( Gibber.Utilities.btof( period ) ), gain ) ) ), ['bias', 'period', 'gain'] )
       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     },

     LineR( period, from=0, to=1 ) {
       const b = beats( period )

       const diff = sub( to, from )
       const mult = mul( b, diff )
       const adder = add( from, mult )
       const ugen = gen( round( adder ) )
       
       addProp( ugen, 'from', [ ugen.p0, ugen.p4 ], from )
       addProp( ugen, 'to', [ ugen.p3 ], to )
       addProp( ugen, 'period', [ ugen.p1 ], period )

       const oldSetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).set
       const oldGetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).get

       Object.defineProperty( ugen, 'period', {
         get() { return oldGetter() },
         set(v) {
           oldSetter( btof(v) )
         }

       })
       
       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     },

     Line( period, from=0, to=1 ) {
       const b = beats( period )

       const diff = sub( to, from )
       const mult = mul( b, diff )
       const adder = add( from, mult )
       const ugen = gen( adder )
       
       addProp( ugen, 'from', [ ugen.p0, ugen.p4 ], from )
       addProp( ugen, 'to', [ ugen.p3 ], to )
       addProp( ugen, 'period', [ ugen.p1 ], period )

       const oldSetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).set
       const oldGetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).get

       Object.defineProperty( ugen, 'period', {
         get() { return oldGetter() },
         set(v) {
            oldSetter( btof(v) )
         }

       })

       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     }
   }

   // stores names so that annotations will correctly interpret this as a gen object
   for( let key in WavePatterns ) {
     Gibber.Gen.names.push( key )
   }

  return WavePatterns
}

},{}],131:[function(require,module,exports){
module.exports = function( Gibber ) {

  const WavePattern = function( ugen ) {
    
    const fnc = function() {
      return fnc.ugen.__wrapped__.callback.out[0] 
    }

    fnc.ugen = ugen

    return Gibber.Pattern( fnc )
  }

  return WavePattern
}

},{}],132:[function(require,module,exports){
module.exports = function( Gibber ) {

let Pattern = Gibber.Pattern

let flatten = function(){
   let flat = []
   for ( let i = 0, l = this.length; i < l; i++ ){
     let type = Object.prototype.toString.call( this[ i ]).split(' ').pop().split( ']' ).shift().toLowerCase()

     if (type) { 
       flat = flat.concat( /^(array|collection|arguments|object)$/.test( type ) ? flatten.call( this[i] ) : this[i]) 
     }
   }
   return flat
}

let createStartingArray = function( length, ones ) {
  let out = []
  for( let i = 0; i < ones; i++ ) {
    out.push( [1] )
  }
  for( let j = ones; j < length; j++ ) {
    out.push( 0 )
  }
  return out
}

let printArray = function( array ) {
  let str = ''
  for( let i = 0; i < array.length; i++ ) {
    let outerElement = array[ i ]
    if( Array.isArray( outerElement ) ) {
      str += '['
      for( let j = 0; j < outerElement.length; j++ ) {
        str += outerElement[ j ]
      }
      str += '] '
    }else{
      str += outerElement + ''
    }
  }

  return str
}

let arraysEqual = function( a, b ) {
  if ( a === b ) return true
  if ( a == null || b == null ) return false
  if ( a.length != b.length ) return false

  for ( let i = 0; i < a.length; ++i ) {
    if ( a[ i ] !== b[ i ] ) return false
  }

  return true
}

let getLargestArrayCount = function( input ) {
  let length = 0, count = 0

  for( let i = 0; i < input.length; i++ ) {
    if( Array.isArray( input[ i ] ) ) { 
      if( input[ i ].length > length ) {
        length = input[ i ].length
        count = 1
      }else if( input[ i ].length === length ) {
        count++
      }
    }
  }

  return count
}

let Euclid = function( ones, length, time, rotation ) {
  let count = 0,
      out = createStartingArray( length, ones ),
      onesAndZeros

 	function Inner( n,k ) {
    let operationCount = count++ === 0 ? k : getLargestArrayCount( out ),
        moveCandidateCount = out.length - operationCount,
        numberOfMoves = operationCount >= moveCandidateCount ? moveCandidateCount : operationCount

    if( numberOfMoves > 1 || count === 1 ) {
      for( let i = 0; i < numberOfMoves; i++ ) {
        let willBeMoved = out.pop(), isArray = Array.isArray( willBeMoved )
        out[ i ].push( willBeMoved )
        if( isArray ) { 
          flatten.call( out[ i ] )
        }
      }
    }

    if( n % k !== 0 ) {
      return Inner( k, n % k )
    }else {
      return flatten.call( out )
    }
  }
  
  onesAndZeros = Inner( length, ones )

  let pattern = Gibber.Pattern( ...onesAndZeros )

  if( isNaN( time ) || time === null ) time = 1 / onesAndZeros.length

  pattern.onrender = function( rendered ) {
    rendered.type = 'Euclid'

    rendered.time = time

    rendered.output = { time, shouldExecute: 0 }

    rendered.addFilter( ( args, ptrn ) => {
      let val = args[ 0 ]

      ptrn.output.time = Gibberish.Clock.time( ptrn.time )
      ptrn.output.shouldExecute = val 

      args[ 0 ] = ptrn.output 

      return args
    })
  }

  pattern.reseed = ( ...args )=> {
    let n, k
    
    if( Array.isArray( args[0] ) ) {
      k = args[0][0]
      n = args[0][1]
    }else{
      k = args[0]
      n = args[1]
    }

    if( n === undefined ) n = 16
    
    out = createStartingArray( n,k )
    let _onesAndZeros = Inner( n,k )
    
    pattern.set( _onesAndZeros )
    pattern.time = 1 / n

    // this.checkForUpdateFunction( 'reseed', pattern )

    return pattern
  }

  //Gibber.addSequencingToMethod( pattern, 'reseed' )

  // out = calculateRhythms( onesAndZeros, dur )
  // out.initial = onesAndZeros
  if( typeof rotation === 'number' ) pattern.rotate( rotation )
  return pattern //out
}
// E(5,8) = [ .25, .125, .25, .125, .25 ]
let calculateRhythms = function( values, dur ) {
  let out = []
  
  if( typeof dur === 'undefined' ) dur = 1 / values.length

  let idx = 0,
      currentDur = 0
  
  while( idx < values.length ) {
    idx++
    currentDur += dur
    
    if( values[ idx ] == 1 || idx === values.length ) {
      out.push( currentDur )
      currentDur = 0
    } 
  }
  
  return out
}

let answers = {
  '1,4' : '1000',
  '2,3' : '101',
  '2,5' : '10100',
  '3,4' : '1011',
  '3,5' : '10101',
  '3,7' : '1010100',
  '3,8' : '10010010',
  '4,7' : '1010101',
  '4,9' : '101010100',
  '4,11': '10010010010',
  '5,6' : '101111',
  '5,7' : '1011011',
  '5,8' : '10110110',
  '5,9' : '101010101',
  '5,11': '10101010100',
  '5,12': '100101001010',
  '5,16': '1001001001001000',
  '7,8' : '10111111',
  '11,24': '100101010101001010101010'
}

Euclid.test = function( testKey ) {
  let failed = 0, passed = 0

  if( typeof testKey !== 'string' ) {
    for( let key in answers ) {
      let expectedResult = answers[ key ],
          result = flatten.call( Euclid.apply( null, key.split(',') ) ).join('')

      console.log( result, expectedResult )

      if( result === expectedResult ) {
        console.log("TEST PASSED", key )
        passed++
      }else{
        console.log("TEST FAILED", key )
        failed++
      }
    }
    console.log("*****************************TEST RESULTS - Passed: " + passed + ", Failed: " + failed )
  }else{
    let expectedResult = answers[testKey],
				result = flatten.call( Euclid.apply( null, testKey.split(',') ) ).join('')

    console.log( result, expectedResult )

    if( result == expectedResult ) {
      console.log("TEST PASSED FOR", testKey)
    }else{
      console.log("TEST FAILED FOR", testKey)
    }
  }
}

return Euclid
}

},{}],133:[function(require,module,exports){
module.exports = function( Gibber ) {

const Pattern = Gibber.Pattern

const Hex = function( hexString, time = 1/16, rotation ) {
  let count = 0,
      onesAndZeros = ''

  if( typeof hexString === 'string' ) {
    for( let chr of hexString ) {
      let num = Number( '0x'+chr )

      onesAndZeros += (num & 8) > 0 ? 1 : 0
      onesAndZeros += (num & 4) > 0 ? 1 : 0
      onesAndZeros += (num & 2) > 0 ? 1 : 0
      onesAndZeros += (num & 1) > 0 ? 1 : 0
    }
  }else{
    onesAndZeros = hexString.toString(2)
    while( onesAndZeros.length < 16 ) {
      onesAndZeros = '0'+onesAndZeros
    }
  }

  let __onesAndZeros = onesAndZeros.split('') 

  const pattern = Gibber.Pattern( ...__onesAndZeros ) 
  
  pattern.onrender = function( rendered ) {
    rendered.type = 'Hex'

    rendered.time = time

    rendered.output = { time, shouldExecute: 0 }

    rendered.addFilter( ( args, ptrn ) => {
      let val = args[ 0 ]

      ptrn.output.time = Gibberish.Clock.time( ptrn.time )
      ptrn.output.shouldExecute = parseInt(val) 

      args[ 0 ] = ptrn.output 

      return args
    })
  }

  pattern.reseed = ( ...args )=> {
    let n, k
    
    if( Array.isArray( args[0] ) ) {
      k = args[0][0]
      n = args[0][1]
    }else{
      k = args[0]
      n = args[1]
    }

    if( n === undefined ) n = 16
    
    out = createStartingArray( n,k )
    let _onesAndZeros = Inner( n,k )
    
    pattern.set( _onesAndZeros )
    pattern.time = 1 / n

    // this.checkForUpdateFunction( 'reseed', pattern )

    return pattern
  }

  //Gibber.addSequencingToMethod( pattern, 'reseed' )

  if( typeof rotation === 'number' ) pattern.rotate( rotation )

  return pattern
}

return Hex

}

},{}],134:[function(require,module,exports){
const Gibber = {
  initialized: false,
  exportTarget: null,
  plugins: [],
  // needed so audio plugin can transfer pattern function string to worklet
  __Pattern: require( './pattern.js' ),

  /* 
   * const promises = Gibber.init([
   *   {
   *     plugin:Audio, // Audio is required, imported, or grabbed via <script>
   *     options: { workletPath:'../dist/gibberish_worklet.js' }
   *   },
   *   {
   *     plugin:Graphics,
   *     options:{ canvas:document.querySelector('canvas' ) }
   *   }
   * ])
  */

  init( plugins ) { 
    this.createPubSub( this )
    this.plugins = plugins

    const promises = []

    // init each plugin and collect promises
    for( let plugin of plugins ) {
      promises.push( 
        plugin.plugin.init( plugin.options, this ) 
      )
    }

    const p = new Promise( (resolve,reject) => {
      const finishedInitPromise = Promise.all( promises ).then( values => {
        
        this.Pattern = this.__Pattern( this )
        this.Seq      = require( './seq.js'      )( this )
        this.Tidal    = require( './tidal.js'    )( this )
        this.Euclid   = require( './euclid.js'   )( this )
        this.Hex      = require( './hex.js'      )( this ) 
        this.Triggers = require( './triggers.js' )( this )
        this.Steps    = require( './steps.js'    )( this )

        values.forEach( v => {
          if( Array.isArray( v ) ) 
            this[ v[1] ] = v[0]
        })

        Gibber.publish( 'init' )
        
        resolve()
      })
    })
  
    return p
  },

  log( ...args ) {
    if( Gibber.Environment ) {
      Gibber.Environment.log( ...args )
    }else{
      console.log( ...args )
    }
  },

  error( ...args ) {
    if( Gibber.Environment ) {
      Gibber.Environment.error( ...args )
    }else{
      console.error( ...args )
    }
  },

  export( obj ) {
    // XXX must keep reference to main pattern function
    // so it can be serialized and transferred to audioworklet  
    obj.Pattern  = this.Pattern
    obj.Seq = this.Seq
    obj.Tidal = this.Tidal
    obj.Euclid = this.Euclid
    obj.Hex = this.Hex
    obj.Triggers = this.Triggers
    obj.Steps = this.Steps

    this.plugins.forEach( p => {
      p.plugin.export( obj, Gibber ) 
    })

    //obj.Clock = this.Clock
    //obj.WavePattern = this.WavePattern
  },

  // XXX stop clock from being cleared.
  clear() { 
    for( let plugin of Gibber.plugins ) {
      plugin.plugin.clear()
    }

    this.Seq.clear()
    this.Tidal.clear()

    this.publish( 'clear' )
  },

  onload() {},

  createPubSub( obj ) {
    const events = {}
    obj.subscribe = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
    }

    obj.unsubscribe = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
    }

    obj.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
    }
  },

  // When a property is created, a proxy-ish object is made that is
  // prefaced by a double underscore. This object holds the value of the 
  // property, sequencers for the property, and modulations for the property.
  // Alternative getter/setter methods can be passed as arguments.
  createProperty( obj, name, value, post=null, priority=0, transform=null, isPoly=false ) {
    obj[ '__' + name ] = { 
      value,
      isProperty:true,
      sequencers:[],
      tidals:[],
      mods:[],
      name,
      type:obj.type,
      __owner:obj,

      fade( from=0, to=1, time=4, delay=0 ) {
        Gibber[ obj.type ].createFade( from, to, time, obj, name, delay )
        return obj
      }
    }

    Gibber.addSequencing( obj, name, priority, value, '__' )

    Object.defineProperty( obj, name, {
      configurable:true,
      get: Gibber[ obj.type ].createGetter( obj, name ),
      set: Gibber[ obj.type ].createSetter( obj, name, post, transform, isPoly )
    })
  },

  getType( obj ) {
    let type
    switch( from.type ) {
      case 'audio':
      case 'Audio':
        type = Gibber.Audio
        break
      case 'graphics':
      case 'Graphics':
        type = Gibber.Graphics
        break
      case 'gen':
        type = 'gen'
        break
    }

    return type
  },

  mappings: {},
  
  createMapping( from, to, name, wrappedTo ) {
    const fromlib = this.getType( from ),
          tolib   = this.getType( to )


    if( mappings[ tolib ] !== undefined &&
      mappings[ tolib ][ fromlib ] !== undefined ) {
      
      const mapper = mappings[ tolib ][ fromlib ]

      mapper( name, to, from )
    }

  
    //if( from.type === 'audio' ) {
    //  const f = to[ '__' + name ].follow = Follow({ input: from, bufferSize:4096 })

    //  Marching.callbacks.push( time => {
    //    if( f.output !== undefined ) {
    //      to[ name ] = f.output
    //    }
    //  })

    //  let m = f.multiplier
    //  Object.defineProperty( to[ name ], 'multiplier', {
    //    configurable:true,
    //    get() { return m },
    //    set(v) { m = v; f.multiplier = m }
    //  })

    //  let o = f.offset
    //  Object.defineProperty( to[ name ], 'offset', {
    //    configurable:true,
    //    get() { return o },
    //    set(v) { o = v; f.offset = o }
    //  })
    //}else if( from.type === 'gen' ) {
    //  const gen = from.render( 60, 'graphics' )

    //  // needed for annotations
    //  to[ name ].value.id = to[ name ].value.varName

    //  // XXX fix the two possible locations for the callback
    //  if( to[ name ].value.callback !== undefined ) {
    //    const idx = Marching.callbacks.indexOf( to[ name ].value.callback )
    //    Marching.callbacks.splice( idx, 1 )
    //  }else if( to[ '__'+name ].callback !== undefined ) {
    //    const idx = Marching.callbacks.indexOf( to[ '__'+name ].callback )
    //    Marching.callbacks.splice( idx, 1 )
    //  }

    //  // XXX fix the two possible locations for the callback
    //  if( typeof to[ name ].value === 'object' ) {
    //    to[ name ].value.callback = t => {
    //      const val = gen()
    //      to[ name ] = val
    //      //console.log( 'val:', val, to[ name ].value.widget !== undefined )
    //      let target = to[ name ].value.widget !== undefined ? to[ name ].value.widget : from.widget

    //      if( target === undefined && to[ name ].value.mark !== undefined ) 
    //        target = to[ name ].value.mark.replacedWith

    //      Gibber.Environment.codeMarkup.waveform.updateWidget( target, val, false )
    //    }
    //  }else{
    //    // assignment hack while DOM creation is taking place,
    //    // only needed for mappings to individual vector elements.
    //    if( to[ '__'+name ].widget === undefined ) {
    //      setTimeout( ()=> to[ '__'+name ].widget = gen.pre.widget, 150 )
    //    }

    //    to[ '__'+name ].callback = t => {
    //      const val = gen()
    //      to[ name ] = val
    //      Gibber.Environment.codeMarkup.waveform.updateWidget( to[ '__'+name ].widget, val, false )
    //    }
    //  }

    //  if( typeof to[ name ].value !== 'object' ) {
    //    Marching.callbacks.push( to[ '__'+name ].callback )
    //  }else{
    //    Marching.callbacks.push( to[ name ].value.callback )
    //  }
    //}
  },

  addSequencing( obj, name, priority, value, prefix='' ) {
    if( obj[ prefix+name ] === undefined ) obj[ prefix+name ] = {}

    obj[ prefix+name ].sequencers = []
    obj[ prefix+name ].seq = function ( values, timings, number = 0, delay = 0 ) {
      if( value !== undefined && typeof value === 'object' ) value.name = obj.name
      const type = obj.type === 'gen' ? 'audio' : obj.type
      Gibber.Seq({ 
        values, 
        timings, 
        target:obj,
        key:name,
        priority,
        delay,
        number,
        standalone:false,
        name:obj.name
      })

      return obj
    }

    obj[ prefix+name ].tidal = function( pattern,  number = 0, delay = 0 ) {
      if( value !== undefined ) value.name = obj.name
      const type = obj.type === 'gen' ? 'audio' : obj.type
      const s = Gibber.Tidal({ 
        pattern, 
        target:obj, 
        key:name,
        number,
        delay,
        standalone:false
      })

      // return object for method chaining
      return obj
    }
  }
  
}

module.exports = Gibber 

},{"./euclid.js":132,"./hex.js":133,"./pattern.js":135,"./seq.js":136,"./steps.js":137,"./tidal.js":138,"./triggers.js":139}],135:[function(require,module,exports){
const patternWrapper = function( Gibber ) {
  "use strict"

  // hack to pass Gibberish to pattern generator from within worklet processor
  let Gibberish
  if( Gibber.Gibberish === undefined ) {
    Gibberish = Gibber.Audio !== undefined ? Gibber.Audio.Gibberish : Gibber 
  }else{
    Gibberish = Gibber.Gibberish
  }

  let PatternProto = Object.create( function(){} )

  // this prototype is somewhat limited, as we want to be able to add
  // .seq() methods to everything. This means that every pattern needs its own
  // copy of each method. One alternative would be to use a more comprehensive
  // prototype and then place proxies on each method of each pattern that access
  // object-specific sequencers... but just making copies of all functions is certainly
  // simpler.
  Object.assign( PatternProto, {
    type:'pattern',
    DNR: -987654321,
    concat( _pattern ) { this.values = this.values.concat( _pattern.values ) },  
    //toString() { return this.values.toString() },
    //valueOf() { return this.values },

    __message(  key, args ) {
      if( this.category === 'audio' ) {
        if( Gibberish.mode === 'processor' )
          Gibberish.processor.messages.push( this.id, key, args )
      } 
    },

    getLength() {
      let l
      if( this.start <= this.end ) {
        l = this.end - this.start + 1
      }else{
        l = this.values.length + this.end - this.start + 1
      }
      return l
    },

    runFilters( val, idx ) {
      let args = [ val, 1, idx ] // 1 is phaseModifier

      for( let filter of this.filters ) {
        const __args = args
        try {
          args = filter( args, this ) 
        } catch( e ) {
          console.error( e )
          console.log( 'filter problem?' )
          console.log( `removing bad filter from pattern: ${filter.toString()}` ) 
          const idx = this.filters.indexOf( filter )
          this.filters.splice( idx, 1 )
          args = __args
        }
      }

      // XXX why is this one off from the worklet-side pattern id?
      this.__message( 'update.value', args.override === undefined ? args[0] : args.override ) 
      this.__message( 'update.currentIndex', args[2] ) 
      if( this.isGen === true ) {
        this.__message( 'waveformPoint', args.override === undefined ? args[0] : args.override ) 
      }

      return args
    },

    checkForUpdateFunction( name, ...args ) {
      if( this.__delayAnnotations === true ) {
        setTimeout( ()=> {
          if( this.listeners[ name ] ) {
            this.listeners[ name ].apply( this, args )
          }else if( Pattern.listeners[ name ] ) {
            Pattern.listeners[ name ].apply( this, args )
          }
        }, 5 )
      }else{
        if( this.listeners[ name ] ) {
          this.listeners[ name ].apply( this, args )
        }else if( Pattern.listeners[ name ] ) {
          Pattern.listeners[ name ].apply( this, args )
        }
      }
    },

    // used when _onchange has not been assigned to individual patterns
    _onchange() {},

    // XXX it would be nice if filters used a similar style to fx chains...
    // pattern.filters.add( ) etc.
    addFilter( filter, name=null ) {
      if( name !== null ) {
        filter.__name = name
        const idx = this.filters.findIndex( f => f.__name === name )
        this.filters.splice( idx, 1 )  
      }
      this.filters.push( filter )
      return this
    },

    removeFilter( idx=null ) {
      if( idx !== null ) {
        this.filters.splice( idx, 1 )  
      }else{
        this.filters.length = 0
      }

      return this
    },

    inspect() {
      if( Gibberish.mode === 'processor' ) 
        console.table({ values:this.values.toString(), 'number of filters':this.filters.length, phase:this.phase })
    },

    render( cat='Audio' ) {
      this.category = cat
      if( typeof Gibber[ cat ] === 'object' && typeof Gibber[ cat ].patternRender === 'function' ) {
        Gibber[ cat ].patternRender( this )
      }
      if( typeof this.onrender === 'function' ) {
        this.onrender()
      }
    },

    copy() {
      const p = Pattern( ...this.values )
      //this.filters.forEach( f => p.addFilter( f ) )
      p.start = this.start
      p.end   = this.end
      p.phase = this.phase

      return p
    },

    __methodNames:  [
      'rotate','switch','invert','flip',
      'transpose','reverse','shuffle','scale',
      'store', 'range', 'set', 'freeze', 'thaw', 'double'
    ]

  })

  const Pattern = function( ...args ) {
    //console.log( 'args[0]:', args[0].isPattern, args[0] )
    //if( typeof args[0] === 'function' && args[0] !== null && args[0].isPattern === true ) {
    //  console.log( 'got pattern' )
    //  return args[0]
    //}

    const isFunction = args.length === 1 && typeof args[0] === 'function',
          isGen = typeof args[0] === 'object' && args[0].__isGen

    //if( isGen === true ) { 
    //  // must have a priority or it screws us codegen for analysis
    //  args[0].priority = 0
    //  Gibberish.analyzers.push( args[0] )
    //  Gibberish.dirty( Gibberish.analyzers )
    //}


    const fnc = function() {
      let len = fnc.getLength(),
          idx, val, args

      if( len === 1 ) { 
        idx = 0 
      }else{
        idx = fnc.phase > -1 ? Math.floor( fnc.start + (fnc.phase % len ) ) : Math.floor( fnc.end + (fnc.phase % len ) )
      }

      if( isFunction ) {
        val = fnc.values[ 0 ]()
        args = fnc.runFilters( val, idx )
        val = args[0]
      } else if( isGen === true ) {
        val = fnc.values[ 0 ].callback.out[0]

        args = fnc.runFilters( val, idx )
        val = args[0]
      }else{
        val = fnc.values[ Math.floor( idx % fnc.values.length ) ]
        args = fnc.runFilters( val, idx )
      
        fnc.phase += fnc.stepSize * args[ 1 ]


        val = args[ 0 ]
      }
      // check to see if value is a function, and if so evaluate it
      //if( typeof val === 'function' ) {
        //val = val()
      //}
      /*else if ( Array.isArray( val ) ) {
        // if val is an Array, loop through array and evaluate any functions found there. TODO: IS THIS SMART?

        for( let i = 0; i < val.length; i++ ){
          if( typeof val[ i ] === 'function' ) {
            val[ i ] = val[ i ]()
          }
        }
      }
      */

      //XXX is this needed? Adding it interferes with Steps
      //if( val === fnc.DNR ) val = null

      return val
    }



    let out 
    Object.assign( fnc, {
      category:'audio',
      start : 0,
      end   : 0,
      phase : 0,
      values : args, 
      isPattern: true,
      __frozen:false,
      // wrap annotation update in setTimeout( func, 0 )
      __delayAnnotations:false,
      //values : typeof arguments[0] !== 'string' || arguments.length > 1 ? Array.prototype.slice.call( arguments, 0 ) : arguments[0].split(''),    
      original : null,
      storage : [],
      stepSize : 1,
      integersOnly : false,
      filters : [],
      __listeners: [],
      onchange : null,
      isop:true,
      isGen,

      freeze( shouldFreezeTheory = true ) {
        fnc.__frozen = true
      },
      thaw() {
        fnc.__frozen = false
        Gibber.Theory.thaw()
      },

      setSeq( seq ) {
        this.seq = seq
      },

      range(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.range( ...args )
          return this
        }

        if( !fnc.__frozen ) {
          let start, end
          
          if( Array.isArray( arguments[0] ) ) {
            start = arguments[0][0]
            end   = arguments[0][1]
          }else{
            start = arguments[0]
            end   = arguments[1]
          }
          
          if( start < end ) {
            fnc.start = start
            fnc.end = end
          }else{
            fnc.start = end
            fnc.end = start
          }

          this.checkForUpdateFunction( 'range', fnc )
        }

        return fnc
      },
      double(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.double(...args)
          return this
        }
        if( !fnc.__frozen ) {

          fnc.values.push( ...fnc.values ) 
          
          fnc.end = fnc.values.length - 1
          
          // if( fnc.end > fnc.values.length - 1 ) {
          //   fnc.end = fnc.values.length - 1
          // }else if( fnc.end < )
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange()
        }
        
        return fnc
      },   

      set(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.set(...args)
          return this
        }
        if( !fnc.__frozen ) {
          let args = Array.isArray( arguments[ 0 ] ) ? arguments[ 0 ] : arguments
          
          fnc.values.length = 0

          const tmp = [] 
          
          for( let i = 0; i < args.length; i++ ) {
            const val = args[i].isPattern === true ? args[ i ].original.slice(0) : args[ i ] 
            tmp.push( val )
          }
          fnc.values = tmp
          
          fnc.end = fnc.values.length - 1
          
          // if( fnc.end > fnc.values.length - 1 ) {
          //   fnc.end = fnc.values.length - 1
          // }else if( fnc.end < )
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange( 'set', fnc.values ) //args )
        }
        
        return fnc
      },
       
      reverse() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.reverse()
          return this
        }
        if( !fnc.__frozen ) {
          let array = fnc.values,
              left = null,
              right = null,
              length = array.length,
              temporary;
              
          for ( left = 0, right = length - 1; left < right; left += 1, right -= 1 ) {
            temporary = array[ left ]
            array[ left ] = array[ right ]
            array[ right ] = temporary;
          }
          
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', array ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'reverse', null )
        }
        
        return fnc
      },
      // humanize: function( randomMin, randomMax ) {
   //      let lastAmt = 0
   //
   //      for( let i = 0; i < this.filters.length; i++ ) {
   //        if( this.filters[ i ].humanize ) {
   //          lastAmt = this.filters[ i ].lastAmt
   //          this.filters.splice( i, 1 )
   //          break;
   //        }
   //      }
   //
   //      let filter = function( args ) {
   //        console.log( filter.lastAmt, args[0])
   //        args[ 0 ] -= filter.lastAmt
   //        filter.lastAmt = Gibber.Clock.time( Gibber.Utilities.rndi( randomMin, randomMax ) )
   //
   //        console.log( "LA", filter.lastAmt )
   //        args[0] += filter.lastAmt
   //
   //        return args
   //      }
   //      filter.lastAmt = lastAmt
   //      filter.humanize = true
   //
   //      this.filters.push( filter )
   //
   //      return this
   //    },
      repeat() {
        let counts = {}
      
        for( let i = 0; i < arguments.length; i +=2 ) {
          counts[ arguments[ i ] ] = {
            phase: 0,
            target: arguments[ i + 1 ]
          }
        }
        
        let repeating = false, repeatValue = null, repeatIndex = null
        let filter = function( args ) {
          let value = args[ 0 ], phaseModifier = args[ 1 ], output = args
          
          //console.log( args, counts )
          if( repeating === false && counts[ value ] ) {
            repeating = true
            repeatValue = value
            repeatIndex = args[2]
          }
          
          if( repeating === true ) {
            if( counts[ repeatValue ].phase !== counts[ repeatValue ].target ) {
              output[ 0 ] = repeatValue            
              output[ 1 ] = 0
              output[ 2 ] = repeatIndex
              //[ val, 1, idx ]
              counts[ repeatValue ].phase++
            }else{
              counts[ repeatValue ].phase = 0
              output[ 1 ] = 1
              if( value !== repeatValue ) { 
                repeating = false
              }else{
                counts[ repeatValue ].phase++
              }
            }
          }
        
          return output
        }
      
        fnc.filters.push( filter )
      
        return fnc
      },
    
      reset() { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.reset()
          return this
        }
        if( !fnc.__frozen ) {
          // XXX replace with some type of standard deep copy
          if( Array.isArray( fnc.original[0] ) ) {
            const arr = []
            for( let i = 0; i < fnc.original.length; i++ ) {
              const chord = fnc.original[ i ]
              arr[ i ] = []
              for( let j = 0; j < chord.length; j++ ) {
                arr[ i ][ j ] = chord[ j ] 
              }
            }
            fnc.values = arr
          }else{
            fnc.values = fnc.original.slice(0)
          }
          //fnc.set( fnc.original.slice( 0 ) );
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }  
          fnc._onchange( 'reset', null )
        }

        return fnc 
      },

      store( pos ) { fnc.storage[ pos || fnc.storage.length ] = fnc.values.slice( 0 ); return fnc; },

      transpose( amt ) { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.transpose( amt )
          return this
        }
        if( !fnc.__frozen ) {
          for( let i = 0; i < fnc.values.length; i++ ) { 
            let val = fnc.values[ i ]
            
            if( Array.isArray( val ) ) {
              for( let j = 0; j < val.length; j++ ) {
                if( typeof val[ j ] === 'number' ) {
                  val[ j ] = fnc.integersOnly ? Math.round( val[ j ] + amt ) : val[ j ] + amt
                }
              }
            }else{
              if( typeof val === 'number' ) {
                fnc.values[ i ] = fnc.integersOnly ? Math.round( fnc.values[ i ] + amt ) : fnc.values[ i ] + amt
              }
            }
          }
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', ['transpose', amt] ) 
          }      
          //fnc._onchange( 'transpose', amt )
        }
        
        return fnc
      },

      shuffle() { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.shuffle( )
          return this
        }
        if( !fnc.__frozen ) {
          Gibber.Utility.shuffle( fnc.values )
          fnc._onchange( 'shuffule', null )
        }
        
        return fnc
      },

      scale( amt ) { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.scale( amt )
          return this
        }
        if( !fnc.__frozen ) {
          fnc.values.map( (val, idx, array) => {
            if( Array.isArray( val ) ) {
              array[ idx ] = val.map( inside  => {
                if( typeof inside === 'number' ) {
                  return fnc.integersOnly ? Math.round( inside * amt ) : inside * amt
                } else {
                  return inside
                }
              })
            }else{
              if( typeof val === 'number' ) {
                array[ idx ] = fnc.integersOnly ? Math.round( val * amt ) : val * amt
              }
            }
          })
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange( 'scale', amt )
        }
        
        return fnc
      },

      flip() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.flip( )
          return this
        }
        if( !fnc.__frozen ) {
          let start = [],
              ordered = null
        
          ordered = fnc.values.filter( function(elem) {
            let shouldPush = start.indexOf( elem ) === -1
            if( shouldPush ) start.push( elem )
            return shouldPush
          })
        
          ordered = ordered.sort( function( a,b ){ return a - b } )
        
          for( let i = 0; i < fnc.values.length; i++ ) {
            let pos = ordered.indexOf( fnc.values[ i ] )
            fnc.values[ i ] = ordered[ ordered.length - pos - 1 ]
          }
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }       
          fnc._onchange( 'flip', null )
        }
      
        return fnc
      },
      
      invert() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.invert( )
          return this
        }
        if( !fnc.__frozen ) {
          let prime0 = fnc.values[ 0 ]
          
          for( let i = 1; i < fnc.values.length; i++ ) {
            if( typeof fnc.values[ i ] === 'number' ) {
              let inverse = prime0 + (prime0 - fnc.values[ i ])
              fnc.values[ i ] = inverse
            }
          }
          
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'invert', null )
        }
        
        return fnc
      },
    
      switch( to ) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.switch( to )
          return this
        }
        if( !fnc.__frozen ) {
          if( fnc.storage[ to ] ) {
            fnc.values = fnc.storage[ to ].slice( 0 )
          }
          
          fnc._onchange( 'switch', to )
        }
        
        return fnc
      },
    
      rotate( amt ) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.rotate( amt )
          return this
        }
        if( !fnc.__frozen ) {
          if( amt > 0 ) {
            while( amt > 0 ) {
              let end = fnc.values.pop()
              fnc.values.unshift( end )
              amt--
            }
          }else if( amt < 0 ) {
            while( amt < 0 ) {
              let begin = fnc.values.shift()
              fnc.values.push( begin )
              amt++
            }
          }

          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'rotate', amt )
        }
        
        return fnc
      },

      clear() {
        if( Gibberish.mode === 'worklet' ) {
          for( let key of PatternProto.__methodNames ) {
            for( let i = 0; i < out[ key ].sequencers.length; i++ ) {
              // this can most certainly be optimized, but I had real problems
              // getting this clearing to work, perhaps related to proxy behaviors?
              const __seq = Gibber.Seq.sequencers.find( s => s.id === out[ key ][ i ].id )
              if( __seq !== undefined ) {
                Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'method', object:__seq.id, name:'stop', args:[] })
              
                __seq.stop()
                __seq.clear()

                const idx = Gibber.Seq.sequencers.indexOf( __seq )
                Gibber.Seq.sequencers.splice( idx, 1 )
                __seq.target[ __seq.key ][0].stop()
              }
            }
          } 
        }else{
          // genish-based patterns are connected as analyzers so that they
          // don't have to feed into a bus to get rendered. we must remove them
          // from the analysis array to finalize clearing.
          if( out.isGen === true ) {
            const idx = Gibberish.analyzers.indexOf( args[0] )
            if( idx !== -1 ) {
              Gibberish.analyzers.splice( idx, 1 )
              Gibberish.analyzers.dirty = true
            }
          }
        }
      }
    })
    
    if( Gibberish.mode === 'worklet' ) {
      fnc.id = Gibberish.utilities.getUID()

      if( isGen === true ) {
        fnc.waveformPoint = val => {
          // accounts for annoying edge case where wave pattern is
          // inlined to a call to .seq
          // XXX fix in parsing or somehow figure out how to only do this once
          if( fnc.widget !== undefined ) fnc.values[0].widget = fnc.widget
          if( fnc.values[0].widget !== undefined ) {

            // convert samples to beats
            if( fnc.__patternType === 'timings' ) {
              val = Gibber.Clock.stob( val )
            }
            fnc.values[0].widget.values[ fnc.values[0].widget.values.length - 1 ] = { value:val } 
          }
        }
      }
    }
    //fnc.filters.pattern = fnc
    // can I resotre this without making the object non-serializable?
    //fnc.retrograde = fnc.reverse.bind( fnc )
    
    fnc.end = fnc.values.length - 1
    
    /*
    fnc.filters.test = function() { console.log( 'test' ) }
    
    fnc.filters.add = function( f ) {
      this.filters.push( f )
    }.bind(fnc)
    fnc.filters.remove = function( idx ) {
      console.log( 'filter:', this )
      this.filters.splice( idx, 1 )
    }.bind( fnc )
    fnc.filters.inspect = function() {
      console.log( `there are currenly ${this.length} filters on this pattern` )
    }.bind(fnc)
    */

    if( Array.isArray( fnc.values[0] ) ) {
      const arr = []
      for( let i = 0; i < fnc.values.length; i++ ) {
        const chord = fnc.values[ i ]
        arr[ i ] = []
        for( let j = 0; j < chord.length; j++ ) {
          arr[ i ][ j ] = chord[ j ] 
        }
      }
      fnc.original = arr
    }else{
      fnc.original = fnc.values.slice(0)
    }

    fnc.storage[ 0 ] = fnc.original.slice( 0 )
    fnc.integersOnly = fnc.values.every( function( n ) { return n === +n && n === (n|0); })
    
    fnc.listeners = {}
    fnc.sequences = {}

    if( Gibberish.mode === 'worklet' ) {

      for( let key of PatternProto.__methodNames ) { 
        Gibber.addSequencing( fnc,key,2,undefined )
      }
      //for( let key of PatternProto.__methodNames ) { 
      //  fnc.sequencers[ key ] = Gibber.Core !== undefined 
      //    ? Gibber.Core.addSequencing( fnc, key, 2 ) 
      //    : Gibber.addSequencing( fnc,key,2 )
      //}
      fnc.sequences.reset = Gibber.addSequencing( fnc, 'reset', 1 )
    }
    
    // TODO: Gibber.createProxyProperties( fnc, { 'stepSize':0, 'start':0, 'end':0 })
    
    fnc.__proto__ = PatternProto 

    let pn = ''
    Object.defineProperty( fnc, 'patternName', {
      get() { return pn },
      set(__pn) {
        pn = __pn
      }
    })

    fnc.render = function( mode='audio' ) {
      if( mode === 'audio' ) {
        // 'isPattern' is a hack to force pattern initialization arguments to be submitted as
        // a list, instead of in a property dictionary. When 'isPattern' is true, gibberish
        // looks for an 'inputs' property and then passes its value (assumed to be an array)
        // using the spread operator to the constructor. 
        out = Gibberish.Proxy( 'pattern', { inputs:fnc.values, isPattern:true, filters:fnc.filters, id:fnc.id }, fnc ) 

        if( isGen === true ) { 
          // must have a priority or it screws up codegen for analysis
          args[0].priority = 0
          Gibberish.analyzers.push( args[0] )
          Gibberish.dirty( Gibberish.analyzers )
        }
      }

      if( args.filters ) {
        args.filters.forEach( f => out.addFilter( f ) )
      }else if( typeof args[0] === 'object' && args[0].filters ) {
        args[0].filters.forEach( f => out.addFilter( f ) )
      }

      Pattern.children.push( out )

      if( fnc.onrender ) fnc.onrender( out )

      fnc.__rendered = out

      return out
    }
    if( Gibberish.mode === 'processor' ) return fnc.render()

    return fnc 
  }

  Pattern.listeners = {}
  Pattern.children = []
  Pattern.__isFrozen = false
  Pattern.freeze = function( shouldFreezeTheory = true ) {
    Pattern.children.forEach( p => p.freeze() ) 
    if( shouldFreezeTheory === true ) {
      Gibber.Theory.freeze()
      Pattern.__isFrozen = true
    }
  }
  Pattern.thaw = ()=> {
    Pattern.children.forEach( p => p.thaw() )
    if( Pattern.__isFrozen === true ) {
      Gibber.Theory.thaw()
      Pattern.__isFrozen = false
    }
  }

  Pattern.export = function( obj ) {
    obj.freeze = Pattern.freeze
    obj.thaw   = Pattern.thaw
  }

  Pattern.listeners.range = function( fnc ) {
    //if( !Notation.isRunning ) return
    
    if( Gibberish.mode === 'processor' ) return

    // TODO: don't use Gibber.currentTrack, store the object in the pattern
    let rangeStart = fnc.markers[ fnc.start ].find(),
        rangeEnd   = fnc.markers[ fnc.end ].find()

    if( !fnc.range.init ) {
      fnc.range.init = true
      var ptrnStart = fnc.markers[ 0 ].find(),
          ptrnEnd = fnc.markers[ fnc.markers.length - 1 ].find()

      //fnc.column.editor.markText( ptrnStart.from, ptrnEnd.to, { className:'rangeOutside' })
      Gibber.Environment.editor.markText( ptrnStart.from, ptrnEnd.to, { className:'rangeOutside' })//className:'pattern-update-range-outside' })
      if( !Pattern.listeners.range.initialzied ) Pattern.listeners.range.init()
    }

    if( fnc.range.mark ) fnc.range.mark.clear()
    //fnc.range.mark = fnc.column.editor.markText( rangeStart.from, rangeEnd.to, { className:'rangeInside' })
    // TODO: Dont use GE.codemirror... how else do I get this? stored in pattern is created?
    fnc.range.mark = Gibber.Environment.editor.markText( rangeStart.from, rangeEnd.to, { className:'rangeInside' })
  }

  Pattern.listeners.range.init = function() {
    //$.injectCSS({ 
    //  '.rangeOutside': {
    //    'color':'#666 !important'
    //  },
    //  '.rangeInside': {
    //    'color':'rgba(102, 153, 221, 1) !important'
    //  }
    //})
    Pattern.listeners.range.initialized = true
  }

  //Pattern.prototype = PatternProto*/

  return Pattern

}

// helper function to pass the pattern constructor to the gibberish worklet processor.
patternWrapper.transfer = function( Audio, constructorString ) {
  if( Audio.Gibberish !== undefined && Audio.Gibberish.mode === 'worklet' ) {
    Audio.Gibberish.worklet.port.postMessage({
      address:'addConstructor',
      name:'Pattern',
      constructorString
    })
  }
}


module.exports = patternWrapper

},{}],136:[function(require,module,exports){
module.exports = function( Gibber ) {
  const addValuesFilters = (seq,key,target) => {
    const values = seq.values
    const __values = seq.values

    if( __values.randomFlag ) {
      values.addFilter( ( args,ptrn ) => {
        const range = ptrn.values.length - 1
        const idx = Math.round( Math.random() * range )
        return [ ptrn.values[ idx ], 1, idx ] 
      })
      //for( let i = 0; i < this.values.randomArgs.length; i+=2 ) {
      //  valuesPattern.repeat( this.values.randomArgs[ i ], this.values.randomArgs[ i + 1 ] )
      //}
    }

    // trigger autotrig patterns
    if( key === 'note' || key === 'chord' || key === 'trigger' || key === 'notef' || key === 'pickplay' ) {
      values.addFilter( ( args,ptrn ) => {
        if( ptrn.seq.target.autotrig !== undefined ) {
          for( let s of ptrn.seq.target.autotrig ) {
            s.fire()
          }
        }
        return args
      })
    } 
  }

  const addTimingFilters = function( seq,key,renderMode ) {
    const __timings = seq.timings
    if( __timings.randomFlag ) {
      __timings.addFilter( ( args,ptrn ) => {
        const range = ptrn.values.length - 1
        const idx = Math.round( Math.random() * range )
        return [ ptrn.values[ idx ], 1, idx ] 
      })
      //for( let i = 0; i < this.values.randomArgs.length; i+=2 ) {
      //  valuesPattern.repeat( this.values.randomArgs[ i ], this.values.randomArgs[ i + 1 ] )
      //}
    }

    const filter = renderMode === 'Audio' 
      ? (args,ptrn) => {
        if( typeof args[0] === 'number' ) {
          args[0] = Gibberish.Clock.time( args[0] )
        }
        return args
      }
      : (args,ptrn) => {
        if( typeof args[0] === 'number' ) {
          args[0] = Gibber.Clock.time( args[0] )
        }
        return args
      }  

    seq.timings.addFilter( (args,ptrn)=>{
      if( args[0] === 0 ) {
        ptrn.seq.stop()
        console.warn( 'sequencer attempting to fire with a time of zero; this will result in an infinite loop, so the sequencer has been stopped.' )
      }
      return args
    })
    seq.timings.addFilter( filter ) 
  }

  const Seq = function( props ) { 
    let   __values  = props.values
    const __timings = props.timings
    const delay     = props.delay
    const target    = props.target
    const key       = props.key
    const priority  = props.priority
    let   rate      = props.rate || 1
    let   density   = props.density || 1
    let   autotrig  = false
    const render    = props.render || 'Audio'

    const Gibberish = Gibber.Audio.Gibberish !== undefined ? Gibber.Audio.Gibberish : null

    if( __values.type === 'gen' ) {
      __values = __values.render()
    }

    if( Array.isArray( __values ) && __values.length <= 0 ) throw Error('arrays passed to sequences must have at least one value inside of them')
    // convert to pattern if needed and render
    const values = Array.isArray( __values ) 
      ? Gibber.Pattern( ...__values ).render()
      : typeof __values === 'function' && __values.isPattern 
        ? __values.render()
        : __values.requiresRender 
          ? __values
          : Gibber.Pattern( __values ).render()

    // if an array of values is passed, let users call pattern method on that array, for example:
    // a.note.seq( b=[0,1,2,3], 1/4 )
    // b.transpose.seq( 1,1 )
    if( Array.isArray( __values ) ) {
      Object.assign( __values, values )
      __values.addFilter = values.addFilter.bind( values )
      __values.removeFilter = values.removeFilter.bind( values )
      __values.inspect = values.inspect.bind( values )
    } else if( typeof __values === 'object' && __values.type==='gen' ) {
      props.values.addFilter = values.addFilter.bind( values )
      props.values.removeFilter = values.removeFilter.bind( values )
      props.values.inspect = values.inspect.bind( values )
    }

    // process time values
    if( target !== undefined ) {
      if( Gibber[ render ].timeProps[ target.name ] !== undefined 
        && Gibber[ render ].timeProps[ target.name ].indexOf( key ) !== -1  ) {

        const filter = render === 'Audio' 
          ? (args,ptrn) => {
              args[0] = Gibberish.Clock.time( args[0] )
              return args
            }
          : (args,ptrn) => {
              args[0] = Gibber.Audio.Clock.time( args[0] )
              return args
            }

        values.addFilter( filter )
      }
    }
 
    const timings = Array.isArray( __timings ) 
      ? Gibber.Pattern( ...__timings ).render()
      : typeof __timings === 'function' && __timings.isPattern 
        ? __timings.render()
        : __timings === undefined || __timings === null 
          ? null
          : __timings.requiresRender
            ? __timings
            : Gibber.Pattern( __timings ).render()


    if( timings === null ) autotrig = true

    if( Array.isArray( __timings ) ) {
      Object.assign( __timings, timings )
      __timings.addFilter = timings.addFilter.bind( timings )
    }
    if( autotrig === false ) {
      timings.output = { time:'time', shouldExecute:0 }
      timings.density = 1

      // XXX delay annotations so that they occur after values annotations have occurred. There might
      // need to be more checks for this flag in the various annotation update files... right now
      // the check is only in createBorderCycle.js.
      timings.__delayAnnotations = true
    }

    // if an array is passed to the seq, enable users to call pattern methods on array
    //if( Array.isArray( __timings ) ) Object.assign( __timings, timings )

    const clear = render === 'Audio'
      ? function() {
          this.stop()
          
          if( this.values !== undefined && this.values.clear !== undefined  ) {
            this.values.clear()
          }
          if( this.timings !== undefined && this.timings !== null && this.timings.clear !== undefined ) this.timings.clear()

          
          if( Gibberish.mode === 'worklet' ) {
            const idx = Seq.sequencers.indexOf( seq )
            seq.stop()
            const __seq = Seq.sequencers.splice( idx, 1 )[0]
            if( __seq !== undefined ) {
              __seq.stop()
            }
          }
        }
      : function() {
          this.stop()
          
          if( this.values !== undefined && this.values.clear !== undefined  ) this.values.clear()
          if( this.timings !== undefined && this.timings !== null && this.timings.clear !== undefined ) this.timings.clear()

          const idx = Seq.sequencers.indexOf( seq )
          const __seq = Seq.sequencers.splice( idx, 1 )[0]
          if( __seq !== undefined ) {
            __seq.stop()
          }
        }

    values.__patternType = 'values'
    if( timings !== null ) timings.__patternType = 'timings'

    //const offsetRate = Gibberish.binops.Mul(rate, Gibber.Clock.AudioClock )

    // XXX need to fix so that we can use the clock rate as the base
    // XXX need to abstract this so that a graphics sequencer could also be called...
    const seq = Gibber.Audio.Gibberish.Sequencer({ values, timings, density, target, key, priority, rate:1/*Gibber.Clock.AudioClock*/, clear, autotrig, mainthreadonly:props.mainthreadonly })

    if( values.setSeq ) values.setSeq( seq )

    addValuesFilters( seq,key )

    if( autotrig === false ) {
      addTimingFilters( seq,key,render )
      if( timings.setSeq ) timings.setSeq( seq )
    }else{
      if( target !== undefined ) {
        if( target.autotrig === undefined ) {
          target.autotrig = []
          Gibber.Audio.Gibberish.worklet.port.postMessage({
            address:'property',
            name:'autotrig',
            value:[],
            object:target.id
          })

        }
        // object name key value
        if( Gibber.Audio.Gibberish.mode === 'worklet' ) {
          Gibber.Audio.Gibberish.worklet.port.postMessage({
            address:'addObjectToProperty',
            name:'autotrig',
            object:target.id,
            key:target.autotrig.length,
            value:seq.id
          })
          target.autotrig.push( seq )
        }
      }else{
        throw Error('you must define timings for any sequence without a target')
      }
    } 

    //Gibberish.proxyEnabled = false
    //Gibber.Ugen.createProperty( seq, 'density', timings, [], Gibber )
    //Gibberish.proxyEnabled = true

    Seq.sequencers.push( seq )

    // if x.y.seq() etc. 
    // standalone === false is most common use case
    if( props.standalone === false ) { 
      // required ternary because pattern methods don't have __ prefix 
      const targetProp = target[ '__' + key ] === undefined 
        ? target[ key ] 
        : target[ '__' + key ]
      
      const prevSeq = targetProp.sequencers[ props.number ] 
      if( prevSeq !== undefined ) { 
        prevSeq.clear();
      }


      // XXX you have to add a method that does all this shit on the worklet. crap.
      targetProp.sequencers[ props.number ] = seq
      targetProp[ props.number ] = seq 
      //target.__sequencers.push( seq )
      if( typeof delay !== 'function' ) { 
        seq.start( Gibber.Audio.Clock.time( delay ) )
      } else {
        delay.seqs.push( seq )
      }
    }

    Gibber.publish( 'new sequence', seq )

    return seq
  }

  Seq.sequencers = []
  Seq.clear = function() {
    Seq.sequencers.forEach( seq => seq.clear() )
    //for( let i = Seq.sequencers.length - 1; i >= 0; i-- ) {
    //  Seq.sequencers[ i ].clear()
    //}
    Seq.sequencers = []
  }
  Seq.DNR = -987654321

  return Seq

}

},{}],137:[function(require,module,exports){
module.exports = function( Gibber ) {
 
const Steps = {
  type:'Steps',
  create( _steps, target ) {
    const stepseq = Object.create( Steps )
    
    stepseq.seqs = {}

    for( let _key in _steps ) {
      let values = _steps[ _key ]
      const parsedKey = parseInt( _key )
      const key = isNaN( parsedKey ) ? _key : parsedKey

      let usesStringValues = false
      if( values.isPattern !== true ) {
        if( Array.isArray( values ) ) {
          values = Gibber.Pattern( ...values )
        }else if( typeof values === 'string' ) {
          values = values.split('')
          usesStringValues = true
        }else{
          values = Gibber.Pattern( values )
        }
      }

      const seq = Gibber.Seq({
        values: usesStringValues ? values : key,
        timings: usesStringValues ?  [ 1  / values.length ] : values,
        'key': target.__isEnsemble !== true ? 'note' : 'trigger', 
        target: target.__isEnsemble ? target[ target[ key ].name ] : target, 
        priority:0
      })

      const onlyUsesVelocity = typeof key === 'string'


      if( usesStringValues ) {
        seq.values.addFilter( new Function( 'args', 'ptrn', 
         `let sym = args[ 0 ],
              velocity = parseInt( sym, 16 ) / 15

          if( isNaN( velocity ) ) {
            velocity = sym === 'x' 
              ? 1
              : sym === 'X'
                ? 1.5
                : 0
          }

          // TODO: is there a better way to get access to beat, beatOffset and scheduler?
          if( velocity !== 0 ) {
            ${ onlyUsesVelocity ? '' :'ptrn.seq.target.__triggerLoudness = velocity' }
          }

          args[ 0 ] = sym === '.' ? -987654321 : ${typeof key === 'string' ? 'velocity' : key }

          return args
        `) )
      }

      stepseq.seqs[ _key ] = seq
      stepseq[ _key ] = usesStringValues ? seq.values : seq.timings
    }

    stepseq.start()
    stepseq.addPatternMethods()

    return stepseq
  },
  
  /* two parts:
   * 1. The easy part, make methods that can be called from the main thread
   *    and run over every seq instance in the step sequencer
   * 2. The hard part, make an object that lives in the audio thread
   *    and can be sequenced. It needs references to all sequencers in the 
   *    step sequencer.
   */
  addPatternMethods() {
    // XXX shouldn't use audio id by default... sigh
    const id = Gibber.Audio.Gibberish.utilities.getUID()

    // store ids of all controlled sequencers
    const seqIds = []
    for( let key in this.seqs ) {
      seqIds.push( this.seqs[ key ].id )
    }

    // this object will be transferred to audio thread
    const obj = { id, seqIds }

    groupMethodNames.forEach( name => {
      // EASY PART 
      this[ name ] = function( ...args ) { 
        for( let key in this.seqs ) { 
          this.seqs[ key ].values[ name ].apply( this, args ) 
        } 
      }

      this[ name ].sequencers = []
      this[ name ].seq = ( values, timings, number = 0, delay = 0 ) => {
        const s = Gibber.Seq({ 
          values, 
          timings, 
          target:this.__wrapped,
          key:name,
          priority:1,
        }).start()
        
        this[ name ].sequencers.push( s )

        // needed for annotations
        this[ name ][ number ] = s

        return this 
      } 

      // store function body to create function in audio thread representation of steps
      // needs to be one line for stringify / parsing
      // XXX ugh arguments? is there ever more than one argument?
      obj[ name ] = `for( let seq of this.seqs ) { seq.values.${name}.apply( this, arguments ); seq.timings.${name}.apply( this, arguments )}`
    })

    // HARD PART
    // code to be evaluated in audio thread
    // 1. create a new object, steps, bassed on stringifying obj
    // 2. add all of the transform methods
    // 3. store all controlled sequencers in steps.seqs after getting references
    //    from Gibberish.ugens 
    const code = `const steps = JSON.parse( \`${JSON.stringify(obj)}\` )
      const methods = ${JSON.stringify( groupMethodNames ) }
      steps.seqs = steps.seqIds.map( id => Gibberish.ugens.get( id ) )
      for( let method of methods ) {
        steps[ method ] = new Function( steps[ method ] ) 
      }
      Gibberish.ugens.set( steps.id, steps )`
 
    Gibber.Audio.Gibberish.worklet.port.postMessage({
      address:'eval',
      code
    }) 

    this.__wrapped = obj
  },

  start() {
    for( let key in this.seqs ) { 
      this.seqs[ key ].start()
    }
  },

  stop() {
    for( let key in this.seqs ) { 
      this.seqs[ key ].stop()
    }
  },

  clear() { 
    this.stop() 

    for( let key in this.seqs ) {
      this.seqs[ key ].timings.clear()
    }
  }

}

const groupMethodNames = [ 
  'rotate', 'reverse', 'transpose', 'range',
  'shuffle', 'scale', 'repeat', 'store', 
  'reset','flip', 'invert', 'set', 'double'
]

return Steps.create

}

},{}],138:[function(require,module,exports){
module.exports = function( Gibber ) {

  const Seq = function( props ) { 
    const pattern   = props.pattern
    const target    = props.target
    const key       = props.key
    const number    = props.number
    const delay     = props.delay
    const priority  = props.priority || 0
    let   rate      = props.rate || 1
    let   density   = props.density || 1
    let   autotrig  = false


    const render    = target.type !== undefined ? target.type.toLowerCase() : 'audio'
    //const Gibber.Audio.Gibberish = Gibber.Gibber.Audio.Gibberish !== undefined ? Gibber.Gibber.Audio.Gibberish : null

    const clear = render === 'audio'
      ? function() {
          this.stop()
          
          if( Gibber.Audio.Gibberish.mode === 'worklet' ) {
            const idx = Seq.sequencers.indexOf( seq )
            seq.stop()
            const __seq = Seq.sequencers.splice( idx, 1 )[0]
            if( __seq !== undefined ) {
              __seq.stop()
            }
          }
        }
      : function() {
          this.stop()
          
          const idx = Seq.sequencers.indexOf( seq )
          const __seq = Seq.sequencers.splice( idx, 1 )[0]
          if( __seq !== undefined ) {
            __seq.stop()
          }
      }

    const filters = [
      // report back triggered tokens for annotations
      function( val, tidal, uid ) {
        if( Gibberish.mode === 'processor' ) {
          Gibberish.processor.messages.push( tidal.id, 'update.uid', uid )   
          Gibberish.processor.messages.push( tidal.id, 'update.value', val )   
        }
        return val
      } 
    ]

    if( key === 'note' || key === 'chord' || key === 'trigger' ) {
      filters.push( ( args,tidal ) => {
        if( tidal.target.autotrig !== undefined ) {
          for( let s of tidal.target.autotrig ) {
            s.fire()
          }
        }
        return args
      })
    }

    let p
    try {
      p = Gibber.Audio.Gibberish.Tidal.Pattern( pattern ) 
    } catch(e) {
      Gibber.publish( 'error', `\nYour Tidal pattern ${pattern} used invalid syntax.\n` )
      //console.log(`%c\nYour Tidal pattern ${pattern} used invalid syntax.\n`, `color:white;background:#900` )
      return null
    }

    if( key !== 'degree' ) {
      const tokens = [...pattern.matchAll(/[a-zA-Z]+/g)].map( v=>v[0] )
      let tokenNotFound = false
      tokens.forEach( t => {
        if( target[ t ] === undefined ) {
          //console.error(
          //  `%c\nYour Tidal pattern is using a token (${t}) that can't be found on the targeted instrument.`, 
          //  `color:white;background:#900` 
          //  ) 
          
          Gibber.publish( 'error', `\nYour Tidal pattern is using a token (${t}) that can't be found on the targeted instrument.\n` )
          tokenNotFound = true
        }
      })

      if( tokenNotFound === true ) return null
    }

    const seq = Gibber.Audio.Gibberish.Tidal({ pattern, target, key, priority, filters, mainthreadonly:props.mainthreadonly })
    seq.clear = clear
    seq.uid = Gibber.Audio.Gibberish.Tidal.getUID()
    
    //Gibber.Audio.Gibberish.proxyEnabled = false
    //Audio.Ugen.createProperty( seq, 'density', timings, [], Audio )
    //Gibber.Audio.Gibberish.proxyEnabled = true

    Gibber.addSequencing( seq, 'rotate', 1 )

    Seq.sequencers.push( seq )

    Gibber.subscribe( 'clear', ()=> seq.clear() )

    // if x.y.tidal() etc. 
    // standalone === false is most common use case
    if( props.standalone === false ) {
      let prevSeq = target[ '__' + key ].tidals[ number ] 
      if( prevSeq !== undefined ) {
        if( target.__sequencers !== undefined ) {
          const idx = target.__sequencers.indexOf( prevSeq )
          target.__sequencers.splice( idx, 1 )
        }
        // XXX stop() destroys an extra sequencer for some reason????
        prevSeq.stop()
        prevSeq.clear()
        //removeSeq( obj, prevSeq )
      }

      seq.start( Gibber.Audio.Clock.time( delay ) )

      target[ '__' + key ].tidals[ number ] = target[ '__' + key ][ number ] = seq
    }

    Gibber.publish( 'new tidal', seq )
    return seq
  }

  Seq.sequencers = []
  Seq.clear = function() {
    Seq.sequencers.forEach( seq => seq.clear() )
    //for( let i = Seq.sequencers.length - 1; i >= 0; i-- ) {
    //  Seq.sequencers[ i ].clear()
    //}
    Seq.sequencers = []
  }
  Seq.DNR = -987654321

  let val = 1 
  Object.defineProperty( Seq, 'cps', {
    get() { return val },
    set(v) {
      val = v
      Gibber.Audio.Gibberish.Tidal.cps = v
    }
  })

  return Seq

}

},{}],139:[function(require,module,exports){
module.exports = function( Gibber ) {

const Pattern = Gibber.Pattern

const Triggers = function( __values ) {
  const values = __values.split('')
  const pattern = Pattern( ...values ) 
  pattern.isPattern = true
  pattern.type = 'Triggers'
  // need to define custom function to use key as value
  pattern.onrender = function( rendered ) {
    rendered.addFilter( new Function( 'args', 'ptrn', 
     `let sym = args[ 0 ],
          velocity = parseInt( sym, 16 ) / 15

      if( isNaN( velocity ) ) {
        velocity = 0
      }

      if( velocity !== 0 ) {
        ptrn.seq.target.__triggerLoudness = velocity
      }

      ptrn.output = {
        time : Gibberish.Clock.time( ${1/values.length} ),
        shouldExecute: sym !== '.' ? 1 : 0
      }

      args[0] = ptrn.output

      return args`
    ))
  }

  return pattern
}

return Triggers

}

},{}],140:[function(require,module,exports){
let ugen = require( '../ugen.js' )

let analyzer = Object.create( ugen )

Object.assign( analyzer, {
  __type__: 'analyzer',
  priority:0
})

module.exports = analyzer

},{"../ugen.js":210}],141:[function(require,module,exports){
module.exports = function( Gibberish ) {
  const { In, Out, SSD } = require( './singlesampledelay.js'  )( Gibberish )

  const analyzers = {
    SSD,
    SSD_In: In,
    SSD_Out: Out, 
    Follow: require( './follow.dsp.js'  )( Gibberish )
  }
  analyzers.Follow_out = analyzers.Follow.out
  analyzers.Follow_in  = analyzers.Follow.in
  
  analyzers.export = target => {
    for( let key in analyzers ) {
      if( key !== 'export' ) {
        target[ key ] = analyzers[ key ]
      }
    }
  }

  return analyzers

}

},{"./follow.dsp.js":142,"./singlesampledelay.js":143}],142:[function(require,module,exports){
const g = require( 'genish.js' ),
      analyzer = require( './analyzer.js' ),
      ugen = require( '../ugen.js' )

const genish = g

module.exports = function( Gibberish ) {

  const Follow = function( __props ){
    const props = Object.assign( {}, Follow.defaults, __props )

    let isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false

    let out = props 

    /* if we are in the main thread,
     * only send a command to make a Follow instance
     * to the processor thread and include the id #
     * of the input ugen.
     */

    //console.log( 'isStereo:', Gibberish.mode, isStereo, props.input )
    if( Gibberish.mode === 'worklet' ) {
      // send obj to be made in processor thread
      props.input = { id: props.input.id }
      props.isStereo = isStereo

      // creates clashes in processor thread unless
      // we skip a number here... nice
      Gibberish.utilities.getUID()

      props.overrideid = Gibberish.utilities.getUID()

      // XXX seems like this id gets overridden somewhere
      // hence .overrideid
      props.id = props.overrideid

      Gibberish.worklet.port.postMessage({
        address:'add',

        properties:JSON.stringify( props ),

        name:['analysis','Follow']
      })

      Gibberish.worklet.ugens.set( props.overrideid, out )

      let mult = props.multiplier

      Object.defineProperty( out, 'multiplier', {
        get() { return mult },
        set(v){
          mult = v
          Gibberish.worklet.port.postMessage({ 
            address:'set', 
            object:props.overrideid,
            name:'multiplier',
            value:mult
          })
        }
      })

      let offset = props.offset
      Object.defineProperty( out, 'offset', {
        get() { return offset },
        set(v){
          offset = v
          Gibberish.worklet.port.postMessage({ 
            address:'set', 
            object:props.overrideid,
            name:'offset',
            value:offset
          })
        }
      })
    }else{
      //isStereo = props.isStereo

      const buffer = g.data( props.bufferSize, 1 )
      const input  = g.in( 'input' )
      const multiplier = g.in( 'multiplier' )
      const offset     = g.in( 'offset' )
      
      const follow_out = Object.create( analyzer )
      follow_out.id = props.id = __props.overrideid

      let avg = g.data( 1,1, { meta:true } ) // output; make available outside jsdsp block
      const idx = avg.memory.values.idx
  
      const callback = function( memory ) {
        return avg[0]
      }

      const out = {
        callback,
        input:props.input,
        isStereo,
        dirty:true,
        inputNames:[ 'input', 'memory' ],
        inputs:[ props.input ],
        id: Gibberish.utilities.getUID(),

        __properties__: { input:props.input },
      }

      // nonsense to make our custom function work
      out.callback.ugenName = out.ugenName = `follow_out_${follow_out.id}`
      out.id = __props.overrideid

      // begin input tracker
      const follow_in = Object.create( ugen )

      if( isStereo === true ) {
        if( props.outputStereo === false ) {
          { 
            "use jsdsp"
            // phase to write to follow buffer
            const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

            // hold running sum
            const sum = g.data( 1, 1, { meta:true })

            const mono = props.abs === true ? g.abs( input[0] + input[1] ) : input[0] + input[1]

            sum[0] = sum[0] + mono - g.peek( buffer, bufferPhaseOut, { mode:'simple' })

            g.poke( buffer, g.abs( mono ), bufferPhaseOut )

            avg = (sum[0] / props.bufferSize) * multiplier + offset
          }
        }else{
          const bufferL = buffer
          const bufferR = g.data( props.bufferSize, 1 )

          { 
            "use jsdsp"
            // phase to write to follow buffer
            const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

            // hold running sum
            const sumL = g.data( 1, 1, { meta:true })
            const sumR = g.data( 1, 1, { meta:true })

            const left = props.abs === true  ? g.abs( input[0] ) : input[0]
            const right = props.abs === true ? g.abs( input[1] ) : input[1]

            sumL[0] = sumL[0] + left - g.peek( bufferL, bufferPhaseOut, { mode:'simple' })
            sumR[0] = sumR[0] + right- g.peek( bufferR, bufferPhaseOut, { mode:'simple' })

            g.poke( bufferL, g.abs( left  ), bufferPhaseOut )
            g.poke( bufferR, g.abs( right ), bufferPhaseOut )

            avg = [
              (sumL[0] / props.bufferSize) * multiplier + offset,
              (sumR[0] / props.bufferSize) * multiplier + offset,
            ]
          }
        }
      }else{
        {
          "use jsdsp"
          // phase to write to follow buffer
          const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

          // hold running sum
          const sum = g.data( 1, 1, { meta:true })

          const __input = props.abs === true ? g.abs( input ) : input

          sum[0] = sum[0] + __input - g.peek( buffer, bufferPhaseOut, { mode:'simple' })
          
          g.poke( buffer, g.abs( input ), bufferPhaseOut )

          avg = (sum[0] / props.bufferSize) * multiplier + offset
        }
      }
      Gibberish.utilities.getUID()

      props.isStereo = false
      const record = Gibberish.factory( 
        follow_in,
        avg, 
        ['analysis', 'follow_in'], 
        props
      )

      // nonsense to make our custom function work
      record.callback.ugenName = record.ugenName = `follow_in_${follow_out.id}`

      if( Gibberish.analyzers.indexOf( record ) === -1 ) Gibberish.analyzers.push( record )

      Gibberish.dirty( Gibberish.analyzers )

      Gibberish.ugens.set( __props.overrideid, record )

      out.record = record
    }

    return out

  }
 
  Follow.defaults = {
    input:0,
    bufferSize:1024,
    multiplier:1,
    abs: true,
    outputStereo:false,
    offset:0
  }

  return Follow

}

},{"../ugen.js":210,"./analyzer.js":140,"genish.js":51}],143:[function(require,module,exports){
const g = require( 'genish.js' ),
      analyzer = require( './analyzer.js' ),
      proxy    = require( '../workletProxy.js' ),
      ugen     = require( '../ugen.js' )

module.exports = function( Gibberish ) {
 
// an SSD ugen is in effect two-in-one,
// one for input and one for output.  
  
const SSD = inputProps => {
  const ssd = Object.create( analyzer )

  const props = Object.assign({}, SSD.defaults, inputProps )
  const isStereo = props.isStereo 
  const input    = g.in( 'input' )
  const historyL = g.history(0)
  const historyR = g.history(0)

  ssd.out = Out( [historyL,historyR], props )
  ssd.in  =  In( [historyL,historyR], props )

  ssd.listen = ssd.in.listen

  return ssd 
}

const Out = ( histories,props ) => {
  let history
  // if we don't find our history ugen in the processor thread,
  // just go ahead and make a new one, they're cheap...
  if( Gibberish.mode === 'processor' ) {
    const id = Array.isArray( histories ) ? histories[0].id : histories.id
    history = Gibberish.ugens.get( id )
    if( history === undefined ) {
      history = g.history( 0 )
      Gibberish.ugens.set( id, history )
    }
    if( props === undefined ) props = { id }
  }else{
    history = histories[0]
  }

  return Gibberish.factory( Object.create( ugen ), history.out, ['analysis','SSD_Out'], props, null )
}

const In = histories => {
  const input = g.in( 'input' )
  let historyL, historyR
  
  if( Gibberish.mode === 'processor' ) {
    // for some reason the proessor id is always one off from the main thread id
    historyL = Gibberish.ugens.get( histories.id - 1 )
    historyR = Gibberish.ugens.get( histories.id )
  }else{
    historyL = histories[0]
    historyR = histories[1]
  }

  // deliberate let
  let ssdin = Object.create( ugen )
  
  ssdin.listen = function( input ) {
    ssdin.input = input
    // changing the input must trigger codegen
    Gibberish.dirty( Gibberish.analyzers ) 

    let isStereo = input.isStereo
    if( input.isStereo === undefined && input.isop === true ) {
      isStereo = input.inputs[0].isStereo === true || input.inputs[1].isStereo === true 
    }
    if( isStereo === true && Gibberish.mode === 'processor' ) {
      const idx = historyL.graph.memory.value.idx     
      ssdin.callback = function( input, memory ) {
        memory[ idx ] = input[ 0 ]
        memory[ idx + 1 ] = input[ 1 ]
        return 0     
      }

      // when each ugen callback is passed to the master callback function
      // it needs to have a ugenName property; we'll just copy this over
      ssdin.callback.ugenName = ssdin.ugenName
    }
  }

  ssdin = Gibberish.factory( ssdin, input, ['analysis','SSD_In'], { 'input':0 } )

  // overwrite the callback function in the processor thread...
  if( Gibberish.mode === 'processor' ) {
    const idx = historyL.graph.memory.value.idx
    
    ssdin.callback = function( input, memory ) {
      memory[ idx ] = input
      return 0     
    }

    // when each ugen callback is passed to the master callback function
    // it needs to have a ugenName property; we'll just copy this over
    ssdin.callback.ugenName = ssdin.ugenName
  }

  ssdin.type = 'analysis'
  Gibberish.analyzers.push( ssdin )

  return ssdin
}

SSD.defaults = {
  input:0,
  isStereo:false
}

return { In, Out, SSD }

}

},{"../ugen.js":210,"../workletProxy.js":212,"./analyzer.js":140,"genish.js":51}],144:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const AD = function( argumentProps ) {
    const ad = Object.create( ugen ),
          attack  = g.in( 'attack' ),
          decay   = g.in( 'decay' )

    const props = Object.assign( {}, AD.defaults, argumentProps )

    const graph = g.ad( attack, decay, { shape:props.shape, alpha:props.alpha })

    ad.trigger = graph.trigger
    
    const __out = Gibberish.factory( ad, graph, ['envelopes','AD'], props )

    return __out
  }

  AD.defaults = { attack:44100, decay:44100, shape:'exponential', alpha:5 } 

  return AD

}

},{"../ugen.js":210,"genish.js":51}],145:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const ADSR = function( argumentProps ) {
    const adsr  = Object.create( ugen ),
          attack  = g.in( 'attack' ),
          decay   = g.in( 'decay' ),
          sustain = g.in( 'sustain' ),
          release = g.in( 'release' ),
          sustainLevel = g.in( 'sustainLevel' )

    const props = Object.assign( {}, ADSR.defaults, argumentProps )

    Object.assign( adsr, props )

    const graph = g.adsr( 
      attack, decay, sustain, sustainLevel, release, 
      { triggerRelease: props.triggerRelease, shape:props.shape, alpha:props.alpha } 
    )

    adsr.trigger = graph.trigger
    adsr.advance = graph.release

    const __out = Gibberish.factory( adsr, graph, ['envelopes','ADSR'], props )

    return __out 
  }

  ADSR.defaults = { 
    attack:22050, 
    decay:22050, 
    sustain:44100, 
    sustainLevel:.6, 
    release: 44100, 
    triggerRelease:false,
    shape:'exponential',
    alpha:5 
  } 

  return ADSR
}

},{"../ugen.js":210,"genish.js":51}],146:[function(require,module,exports){
const g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const Envelopes = {
    AD     : require( './ad.js' )( Gibberish ),
    ADSR   : require( './adsr.js' )( Gibberish ),
    Ramp   : require( './ramp.js' )( Gibberish ),

    export : target => {
      for( let key in Envelopes ) {
        if( key !== 'export' && key !== 'factory' ) {
          target[ key ] = Envelopes[ key ]
        }
      }
    },

    factory( useADSR, shape, attack, decay, sustain, sustainLevel, release, triggerRelease=false ) {
      let env

      // deliberate use of single = to accomodate both 1 and true
      if( useADSR != true ) {
        env = g.ad( attack, decay, { shape }) 
      }else {
        env = g.adsr( attack, decay, sustain, sustainLevel, release, { shape, triggerRelease })
        env.advance = env.release
      }

      return env
    }
  } 

  return Envelopes
}

},{"./ad.js":144,"./adsr.js":145,"./ramp.js":147,"genish.js":51}],147:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const Ramp = function( argumentProps ) {
    const ramp   = Object.create( ugen ),
          length = g.in( 'length' ),
          from   = g.in( 'from' ),
          to     = g.in( 'to' )

    const props = Object.assign({}, Ramp.defaults, argumentProps )

    const reset = g.bang()

    const phase = g.accum( g.div( 1, length ), reset, { shouldWrap:props.shouldLoop, shouldClamp:true }),
          diff = g.sub( to, from ),
          graph = g.add( from, g.mul( phase, diff ) )
        
    ramp.trigger = reset.trigger

    const out = Gibberish.factory( ramp, graph, ['envelopes','ramp'], props )


    return out
  }

  Ramp.defaults = { from:0, to:1, length:g.gen.samplerate, shouldLoop:false }

  return Ramp

}

},{"../ugen.js":210,"genish.js":51}],148:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./realm.js":150,"dup":39}],149:[function(require,module,exports){
/*
 * https://github.com/antimatter15/heapqueue.js/blob/master/heapqueue.js
 *
 * This implementation is very loosely based off js-priority-queue
 * by Adam Hooper from https://github.com/adamhooper/js-priority-queue
 *
 * The js-priority-queue implementation seemed a teensy bit bloated
 * with its require.js dependency and multiple storage strategies
 * when all but one were strongly discouraged. So here is a kind of
 * condensed version of the functionality with only the features that
 * I particularly needed.
 *
 * Using it is pretty simple, you just create an instance of HeapQueue
 * while optionally specifying a comparator as the argument:
 *
 * var heapq = new HeapQueue();
 *
 * //IF NEGATIVE, RETURN A
 *
 * var customq = new HeapQueue(function(a, b){
 *   // if b > a, return negative
 *   // means that it spits out the smallest item first
 *   return a - b;
 * });
 *
 * Note that in this case, the default comparator is identical to
 * the comparator which is used explicitly in the second queue.
 *
 * Once you've initialized the heapqueue, you can plop some new
 * elements into the queue with the push method (vaguely reminiscent
 * of typical javascript arays)
 *
 * heapq.push(42);
 * heapq.push("kitten");
 *
 * The push method returns the new number of elements of the queue.
 *
 * You can push anything you'd like onto the queue, so long as your
 * comparator function is capable of handling it. The default
 * comparator is really stupid so it won't be able to handle anything
 * other than an number by default.
 *
 * You can preview the smallest item by using peek.
 *
 * heapq.push(-9999);
 * heapq.peek(); // ==> -9999
 *
 * The useful complement to to the push method is the pop method,
 * which returns the smallest item and then removes it from the
 * queue.
 *
 * heapq.push(1);
 * heapq.push(2);
 * heapq.push(3);
 * heapq.pop(); // ==> 1
 * heapq.pop(); // ==> 2
 * heapq.pop(); // ==> 3
 */
const HeapQueue = function(cmp){
  this.cmp = (cmp || function(a, b){ return a - b; });
  this.length = 0;
  this.data = [];
}
HeapQueue.prototype.peek = function(){
  return this.data[0];
};
HeapQueue.prototype.push = function(value){
  this.data.push(value);

  var pos = this.data.length - 1,
  parent, x;

  while(pos > 0){
    parent = (pos - 1) >>> 1;
    if(this.cmp(this.data[pos], this.data[parent]) < 0){
      x = this.data[parent];
      this.data[parent] = this.data[pos];
      this.data[pos] = x;
      pos = parent;
    }else break;
  }
  return this.length++;
};
HeapQueue.prototype.pop = function(){
  var last_val = this.data.pop(),
  ret = this.data[0];
  if(this.data.length > 0){
    this.data[0] = last_val;
    var pos = 0,
    last = this.data.length - 1,
    left, right, minIndex, x;
    while(1){
      left = (pos << 1) + 1;
      right = left + 1;
      minIndex = pos;
      if(left <= last && this.cmp(this.data[left], this.data[minIndex]) < 0) minIndex = left;
      if(right <= last && this.cmp(this.data[right], this.data[minIndex]) < 0) minIndex = right;
      if(minIndex !== pos){
        x = this.data[minIndex];
        this.data[minIndex] = this.data[pos];
        this.data[pos] = x;
        pos = minIndex;
      }else break;
    }
  } else {
    ret = last_val;
  }
  this.length--;
  return ret;
};

module.exports = HeapQueue

},{}],150:[function(require,module,exports){

/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],151:[function(require,module,exports){
const __proxy = require( './workletProxy.js' )
const effectProto = require( './fx/effect.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )
  
  const factory = function( ugen, graph, __name, values, cb=null, shouldProxy = true ) {
    if( Gibberish.mode === 'processor' )
      ugen.callback = cb === null ? Gibberish.genish.gen.createCallback( graph, Gibberish.memory, false, true ) : cb
    else
      ugen.callback = { out:[] }

    let name = Array.isArray( __name ) ? __name[ __name.length - 1 ] : __name

    Object.assign( ugen, {
      //type: 'ugen',
      id: values.id || Gibberish.utilities.getUID(), 
      ugenName: name + '_',
      graph: graph,
      inputNames: ugen.inputNames || new Set( Gibberish.genish.gen.parameters ),
      isStereo: Array.isArray( graph ),
      dirty: true,
      __properties__:values,
      __addresses__:{}
    })

    ugen.ugenName += ugen.id
    if( Gibberish.mode === 'processor' ) {
      ugen.callback.ugenName = ugen.ugenName // XXX hacky
      ugen.callback.id = ugen.id
    }

    //console.log( 'ugen name/id:', ugen.ugenName, ugen.id )
    //console.log( 'callback name/id:', ugen.callback.ugenName, ugen.callback.id )

    for( let param of ugen.inputNames ) {
      if( param === 'memory' ) continue

      let value = values[ param ],
          isNumber = typeof value === 'object' || isNaN( value ) ? false : true,
          idx

      if( isNumber ) { 
        idx = Gibberish.memory.alloc( 1 )
        Gibberish.memory.heap[ idx ] = value
        ugen.__addresses__[ param ] = idx
      }

      // TODO: do we need to check for a setter?
      let desc = Object.getOwnPropertyDescriptor( ugen, param ),
          setter

      if( desc !== undefined ) {
        setter = desc.set
      }

      Object.defineProperty( ugen, param, {
        configurable:true,
        get() { 
          if( isNumber ) {
            return Gibberish.memory.heap[ idx ]
          }else{
            return value 
          }
        },
        set( v ) {
          //if( param === 'input' ) console.log( 'INPUT:', v, isNumber )
          if( value !== v ) {
            if( setter !== undefined ) setter( v )
            if( typeof v === 'number' ) {
              Gibberish.memory.heap[ idx ] = value = v
              if( isNumber === false ) Gibberish.dirty( ugen )
              isNumber = true
            }else{
              value = v
              /*if( isNumber === true )*/ Gibberish.dirty( ugen )
              //console.log( 'switching from number:', param, value )
              isNumber = false
            }
          }
        }
      })
    }

    // add bypass 
    if( effectProto.isPrototypeOf( ugen ) ) {
      let value = ugen.bypass
      Object.defineProperty( ugen, 'bypass', {
        configurable:true,
        get() { return value },
        set( v ) {
          if( value !== v ) {
            Gibberish.dirty( ugen )
            value = v
          }
        }
      })

    }

    if( ugen.__requiresRecompilation !== undefined ) {
      ugen.__requiresRecompilation.forEach( prop => {
        let value = values[ prop ]
        let isNumber = !isNaN( value )

        Object.defineProperty( ugen, prop, {
          configurable:true,
          get() { 
            if( isNumber ) {
              let idx = ugen.__addresses__[ prop ]
              return Gibberish.memory.heap[ idx ]
            }else{
              //console.log( 'returning:', prop, value, Gibberish.mode )
              return value 
            }
          },
          set( v ) {
            if( value !== v ) {
              if( typeof v === 'number' ) {
                let idx = ugen.__addresses__[ prop ]
                if( idx === undefined ){
                  idx = Gibberish.memory.alloc( 1 )
                  ugen.__addresses__[ prop ] = idx
                }
                value = values[ prop ] = Gibberish.memory.heap[ idx ] = v
                isNumber = true
              }else{
                value = values[ prop ] = v
                isNumber = false
                //console.log( 'setting ugen', value, Gibberish.mode )
                Gibberish.dirty( ugen )
              }

              //console.log( 'SETTING REDO GRAPH', prop, Gibberish.mode )
              
              // needed for filterType at the very least, becauae the props
              // are reused when re-creating the graph. This seems like a cheaper
              // way to solve this problem.
              //values[ prop ] = v

              this.__redoGraph()
            }
          }
        })
      })
    }

    // will only create proxy if worklets are being used
    // otherwise will return unaltered ugen

    if( values.shouldAddToUgen === true ) Object.assign( ugen, values )

    return shouldProxy ? proxy( __name, values, ugen ) : ugen
  }

  factory.getUID = () => { return Gibberish.utilities.getUID() }

  return factory
}

},{"./fx/effect.js":166,"./workletProxy.js":212}],152:[function(require,module,exports){
let g = require( 'genish.js' )
 
// constructor for schroeder allpass filters
let allPass = function( _input, length=500, feedback=.5 ) {
  let index  = g.counter( 1,0,length ),
      buffer = g.data( length ),
      bufferSample = g.peek( buffer, index, { interp:'none', mode:'samples' }),
      out = g.memo( g.add( g.mul( -1, _input), bufferSample ) )
                
  g.poke( buffer, g.add( _input, g.mul( bufferSample, feedback ) ), index )
 
  return out
}

module.exports = allPass

},{"genish.js":51}],153:[function(require,module,exports){
let g = require( 'genish.js' ),
    filter = require( './filter.js' )

module.exports = function( Gibberish ) {

  const genish = g
  Gibberish.genish.biquad = ( input, __cutoff, __Q, mode, isStereo ) => {
    'use jsdsp'
    let in1a0,x0a1,x1a2,y0b0,y1b1,
        in1a0_r,x0a1_r,x1a2_r,y0b0_r,y1b1_r,
        c

    let returnValue
    
    const x = genish.data([ 0,0 ], 1, { meta:true })
    const y = genish.data([ 0,0 ], 1, { meta:true })
    const a = genish.data([ 0,0,0 ], 1, { meta:true })
    const b = genish.data([ 0,0 ], 1, { meta:true })
    
    const Q = g.min( .5 + __Q * 22, 22.5 ) 
    const cutoff = g.max( .005, g.min( __cutoff,.995 ) ) * g.gen.samplerate / 4 
    //let w0 = g.memo( g.mul( 2 * Math.PI, g.div( g.max(.005, g.min(cutoff,.995)),  g.gen.samplerate ) ) ),
    let w0 =  (2 * Math.PI) * (cutoff / g.gen.samplerate),
        sinw0 = g.sin( w0 ),
        cosw0 = g.cos( w0 ),
        alpha = sinw0 / ( 2 * Q )

    //let w0 = g.memo( g.mul( 2 * Math.PI, g.div( cutoff,  g.gen.samplerate ) ) ),
      
    let oneMinusCosW = 1 - cosw0

    /******** process coefficients ********/
    switch( mode ) {
      case 1:
        a[0] = (1 + cosw0) / 2
        a[1] = (1 + cosw0) * -1
        a[2] = a[0]
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
        break;
      case 2:
        a[0] = Q * alpha
        a[1] = 0
        a[2] = a[0] * -1
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
        break;
      default: // LP
        a[0] = oneMinusCosW / 2
        a[1] = oneMinusCosW
        a[2] = a[0]
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
    }

    a[0] = a[0] / c; a[1] = a[1] / c; a[2] = a[2] / c
    b[0] = b[0] / c; b[1] = b[1] / c

    /******** end coefficients ********/

    /****** left / mono output ********/

    let l = isStereo === true ? input[0] : input
    in1a0 = l * a[0]
    x0a1  = x[0] * a[1]
    x1a2  = x[1] * a[2]

    x[1] = x[0] 
    x[0] = l

    let sumLeft = in1a0 + x0a1 + x1a2

    y0b0 = y[0] * b[0]
    y1b1 = y[1] * b[1]
    y[1] = y[0] 

    let sumRight = y0b0 + y1b1

    let diff = sumLeft - sumRight

    y[0] = diff
    
    /******** end left/mono **********/

    if( isStereo ) {
      const xr = genish.data([ 0,0 ], 1, { meta:true })
      const yr = genish.data([ 0,0 ], 1, { meta:true })
      //let x1_1 = g.history(), x2_1 = g.history(), y1_1 = g.history(), y2_1 = g.history()

      const r = input[1] 
      in1a0_r = r * a[0] //g.mul( x1_1.in( input[1] ), a0 )
      x0a1_r  = xr[0] * a[1]//g.mul( x2_1.in( x1_1.out ), a1 )
      x1a2_r  = xr[1] * a[2]//g.mul( x2_1.out,            a2 )

      xr[1]   = xr[0]
      xr[0] = r

      const sumLeft_r = in1a0_r + x0a1_r + x1a2_r

      y0b0_r = yr[0] * b[0]//g.mul( y2_1.in( y1_1.out ), b1 )
      y1b1_r = yr[1] * b[1]//g.mul( y2_1.out, b2 )
      yr[1] = yr[0]

      const sumRight_r = y0b0_r + y1b1_r

      const diff_r = sumLeft_r - sumRight_r

      yr[0] = diff_r
      
      returnValue = [ diff, diff_r ]
    }else{
      returnValue = diff
    }

    return returnValue
  }

  let Biquad = inputProps => {
    const biquad = Object.create( filter )
    const props = Object.assign( {}, Biquad.defaults, inputProps ) 
    let __out

    Object.assign( biquad, props )

    biquad.__createGraph = function() {
      let isStereo = false
      if( __out === undefined ) {
        isStereo = props.input !== undefined && props.input.isStereo !== undefined ? props.input.isStereo : false 
      }else{
        isStereo = __out.input.isStereo
        __out.isStereo = isStereo
      }
      biquad.graph = Gibberish.genish.biquad( g.in('input'), g.in('cutoff'),  g.in('Q'), biquad.mode, isStereo )
    }

    biquad.__createGraph()
    biquad.__requiresRecompilation = [ 'mode', 'input' ]

    __out = Gibberish.factory(
      biquad,
      biquad.graph,
      ['filters','Filter12Biquad'], 
      props
    )

    return __out
  }

  Biquad.defaults = {
    input:0,
    Q: .15,
    cutoff:.05,
    mode:0
  }

  return Biquad

}


},{"./filter.js":156,"genish.js":51}],154:[function(require,module,exports){
let g = require( 'genish.js' )

let combFilter = function( _input, combLength, damping=.5*.4, feedbackCoeff=.84 ) {
  let lastSample   = g.history(),
  	  readWriteIdx = g.counter( 1,0,combLength ),
      combBuffer   = g.data( combLength ),
	    out          = g.peek( combBuffer, readWriteIdx, { interp:'none', mode:'samples' }),
      storeInput   = g.memo( g.add( g.mul( out, g.sub( 1, damping)), g.mul( lastSample.out, damping ) ) )
      
  lastSample.in( storeInput )
 
  g.poke( combBuffer, g.add( _input, g.mul( storeInput, feedbackCoeff ) ), readWriteIdx )
 
  return out
}

module.exports = combFilter

},{"genish.js":51}],155:[function(require,module,exports){
const g = require( 'genish.js' ),
      filter = require( './filter.js' )

const genish = g
module.exports = function( Gibberish ) {
  Gibberish.genish.diodeZDF = ( input, __Q, __freq, saturation, isStereo=false ) => {
    const iT = 1 / g.gen.samplerate,
          kz1 = g.history(0),
          kz2 = g.history(0),
          kz3 = g.history(0),
          kz4 = g.history(0)

    let   ka1 = 1.0,
          ka2 = 0.5,
          ka3 = 0.5,
          ka4 = 0.5,
          kindx = 0   

    const freq = g.mul( g.max(.005, g.min( __freq, .995)),  genish.gen.samplerate / 2 )
    //const freq = g.max(.005, g.min( __freq, .995))

    // XXX this is where the magic number hapens for Q...
    const Q = g.memo( g.add( .5, g.mul( __Q, g.add( 5, g.sub( 5, g.mul( g.div( freq, 20000  ), 5 ) ) ) ) ) )
    // kwd = 2 * $M_PI * acf[kindx]
    const kwd = g.memo( g.mul( Math.PI * 2, freq ) )

    // kwa = (2/iT) * tan(kwd * iT/2) 
    const kwa =g.memo( g.mul( 2/iT, g.tan( g.mul( kwd, iT/2 ) ) ) )

    // kG  = kwa * iT/2 
    const kg = g.memo( g.mul( kwa, iT/2 ) )
    
    const kG4 = g.memo( g.mul( .5, g.div( kg, g.add( 1, kg ) ) ) )
    const kG3 = g.memo( g.mul( .5, g.div( kg, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG4 ) ) ) ) )
    const kG2 = g.memo( g.mul( .5, g.div( kg, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG3 ) ) ) ) )
    const kG1 = g.memo( g.div( kg, g.sub( g.add( 1, kg ), g.mul( kg, kG2 ) ) ) )

    const kGAMMA = g.memo( g.mul( g.mul( kG4, kG3 ) , g.mul( kG2, kG1 ) ) )

    const kSG1 = g.memo( g.mul( g.mul( kG4, kG3 ), kG2 ) ) 

    const kSG2 = g.memo( g.mul( kG4, kG3) )  
    const kSG3 = kG4 
    let kSG4 = 1.0 
    // kk = 4.0*(kQ - 0.5)/(25.0 - 0.5)
    const kalpha = g.memo( g.div( kg, g.add(1.0, kg) ) )

    const kbeta1 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( kg, kG2 ) ) ) )
    const kbeta2 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG3 ) ) ) )
    const kbeta3 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG4 ) ) ) )
    const kbeta4 = g.memo( g.div( 1.0, g.add( 1, kg ) ) ) 

    const kgamma1 = g.memo( g.add( 1, g.mul( kG1, kG2 ) ) )
    const kgamma2 = g.memo( g.add( 1, g.mul( kG2, kG3 ) ) )
    const kgamma3 = g.memo( g.add( 1, g.mul( kG3, kG4 ) ) )

    const kdelta1 = kg
    const kdelta2 = g.memo( g.mul( 0.5, kg ) )
    const kdelta3 = g.memo( g.mul( 0.5, kg ) )

    const kepsilon1 = kG2
    const kepsilon2 = kG3
    const kepsilon3 = kG4

    const klastcut = freq

    //;; feedback inputs 
    const kfb4 = g.memo( g.mul( kbeta4 , kz4.out ) ) 
    const kfb3 = g.memo( g.mul( kbeta3, g.add( kz3.out, g.mul( kfb4, kdelta3 ) ) ) )
    const kfb2 = g.memo( g.mul( kbeta2, g.add( kz2.out, g.mul( kfb3, kdelta2 ) ) ) )

    //;; feedback process

    const kfbo1 = g.memo( g.mul( kbeta1, g.add( kz1.out, g.mul( kfb2, kdelta1 ) ) ) ) 
    const kfbo2 = g.memo( g.mul( kbeta2, g.add( kz2.out, g.mul( kfb3, kdelta2 ) ) ) ) 
    const kfbo3 = g.memo( g.mul( kbeta3, g.add( kz3.out, g.mul( kfb4, kdelta3 ) ) ) ) 
    const kfbo4 = kfb4

    const kSIGMA = g.memo( 
      g.add( 
        g.add( 
          g.mul( kSG1, kfbo1 ), 
          g.mul( kSG2, kfbo2 )
        ), 
        g.add(
          g.mul( kSG3, kfbo3 ), 
          g.mul( kSG4, kfbo4 )
        ) 
      ) 
    )

    //const kSIGMA = 1
    //;; non-linear processing
    //if (knlp == 1) then
    //  kin = (1.0 / tanh(ksaturation)) * tanh(ksaturation * kin)
    //elseif (knlp == 2) then
    //  kin = tanh(ksaturation * kin) 
    //endif
    //
    //const kin = input 
    let kin = isStereo === true ? g.add( input[0], input[1] ) : input//g.memo( g.mul( g.div( 1, g.tanh( saturation ) ), g.tanh( g.mul( saturation, input ) ) ) )
    kin = g.tanh( g.mul( saturation, kin ) )

    const kun = g.div( g.sub( kin, g.mul( Q, kSIGMA ) ), g.add( 1, g.mul( Q, kGAMMA ) ) )
    //const kun = g.div( 1, g.add( 1, g.mul( Q, kGAMMA ) ) )
        //(kin - kk * kSIGMA) / (1.0 + kk * kGAMMA)

    //;; 1st stage
    let kxin = g.memo( g.add( g.add( g.mul( kun, kgamma1 ), kfb2), g.mul( kepsilon1, kfbo1 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    let kv = g.memo( g.mul( g.sub( g.mul( ka1, kxin ), kz1.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    let klp = g.add( kv, kz1.out )
    //klp = kv + kz1
    kz1.in( g.add( klp, kv ) ) 
    //kz1 = klp + kv

        //;; 2nd stage
    //kxin = (klp * kgamma2 + kfb3 + kepsilon2 * kfbo2)
    //kv = (ka2 * kxin - kz2) * kalpha 
    //klp = kv + kz2
    //kz2 = klp + kv

    kxin = g.memo( g.add( g.add( g.mul( klp, kgamma2 ), kfb3), g.mul( kepsilon2, kfbo2 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka2, kxin ), kz2.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz2.out ) 
    //klp = kv + kz1
    kz2.in( g.add( klp, kv ) ) 
    //kz1 = klp + kv

    //;; 3rd stage
    //kxin = (klp * kgamma3 + kfb4 + kepsilon3 * kfbo3)
    //kv = (ka3 * kxin - kz3) * kalpha 
    //klp = kv + kz3
    //kz3 = klp + kv

    kxin = g.memo( g.add( g.add( g.mul( klp, kgamma3 ), kfb4), g.mul( kepsilon3, kfbo3 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka3, kxin ), kz3.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz3.out )
    //klp = kv + kz1
    kz3.in( g.add( klp, kv ) )
    //kz1 = klp + kv

    //;; 4th stage
    //kv = (ka4 * klp - kz4) * kalpha 
    //klp = kv + kz4
    //kz4 = klp + kv

    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka4, kxin ), kz4.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz4.out )
    //klp = kv + kz1
    kz4.in( g.add( klp, kv ) )

    //kz1 = klp + kv
    if( isStereo ) {
      //let polesR = g.data([ 0,0,0,0 ], 1, { meta:true }),
      //    rezzR = g.clamp( g.mul( polesR[3], rez ) ),
      //    outputR = g.sub( input[1], rezzR )         

      //polesR[0] = g.add( polesR[0], g.mul( g.add( g.mul(-1, polesR[0] ), outputR   ), cutoff ))
      //polesR[1] = g.add( polesR[1], g.mul( g.add( g.mul(-1, polesR[1] ), polesR[0] ), cutoff ))
      //polesR[2] = g.add( polesR[2], g.mul( g.add( g.mul(-1, polesR[2] ), polesR[1] ), cutoff ))
      //polesR[3] = g.add( polesR[3], g.mul( g.add( g.mul(-1, polesR[3] ), polesR[2] ), cutoff ))

      //let right = g.switch( isLowPass, polesR[3], g.sub( outputR, polesR[3] ) )

      //returnValue = [left, right]
    }else{
     // returnValue = klp
    }
    //returnValue = klp
    
    return klp
 }

  const DiodeZDF = inputProps => {
    const zdf      = Object.create( filter )
    const props    = Object.assign( {}, DiodeZDF.defaults, filter.defaults, inputProps )
    const isStereo = props.input.isStereo 

    Object.assign( zdf, props )

    const __out = Gibberish.factory(
      zdf, 
      Gibberish.genish.diodeZDF( g.in('input'), g.in('Q'), g.in('cutoff'), g.in('saturation'), isStereo ), 
      ['filters','Filter24TB303'],
      props
    )

    return __out 
  }

  DiodeZDF.defaults = {
    input:0,
    Q: .65,
    saturation: 1,
    cutoff:.5 
  }

  return DiodeZDF

}

},{"./filter.js":156,"genish.js":51}],156:[function(require,module,exports){
let ugen = require( '../ugen.js' )()

let filter = Object.create( ugen )

Object.assign( filter, {
  defaults: { bypass:false } 
})

module.exports = filter

},{"../ugen.js":210}],157:[function(require,module,exports){
let g = require( 'genish.js' ),
    filter = require( './filter.js' )

module.exports = function( Gibberish ) {

  Gibberish.genish.filter24 = ( input, _rez, _cutoff, isLowPass, isStereo=false ) => {
    let returnValue,
        polesL = g.data([ 0,0,0,0 ], 1, { meta:true }),
        peekProps = { interp:'none', mode:'simple' },
        rez = g.memo( g.mul( _rez, 5 ) ),
        cutoff = g.memo( g.div( _cutoff, 11025 ) ),
        rezzL = g.clamp( g.mul( polesL[3], rez ) ),
        outputL = g.sub( isStereo ? input[0] : input, rezzL ) 

    polesL[0] = g.add( polesL[0], g.mul( g.add( g.mul(-1, polesL[0] ), outputL   ), cutoff ))
    polesL[1] = g.add( polesL[1], g.mul( g.add( g.mul(-1, polesL[1] ), polesL[0] ), cutoff ))
    polesL[2] = g.add( polesL[2], g.mul( g.add( g.mul(-1, polesL[2] ), polesL[1] ), cutoff ))
    polesL[3] = g.add( polesL[3], g.mul( g.add( g.mul(-1, polesL[3] ), polesL[2] ), cutoff ))
    
    let left = g.switch( isLowPass, polesL[3], g.sub( outputL, polesL[3] ) )

    if( isStereo ) {
      let polesR = g.data([ 0,0,0,0 ], 1, { meta:true }),
          rezzR = g.clamp( g.mul( polesR[3], rez ) ),
          outputR = g.sub( input[1], rezzR )         

      polesR[0] = g.add( polesR[0], g.mul( g.add( g.mul(-1, polesR[0] ), outputR   ), cutoff ))
      polesR[1] = g.add( polesR[1], g.mul( g.add( g.mul(-1, polesR[1] ), polesR[0] ), cutoff ))
      polesR[2] = g.add( polesR[2], g.mul( g.add( g.mul(-1, polesR[2] ), polesR[1] ), cutoff ))
      polesR[3] = g.add( polesR[3], g.mul( g.add( g.mul(-1, polesR[3] ), polesR[2] ), cutoff ))

      let right = g.switch( isLowPass, polesR[3], g.sub( outputR, polesR[3] ) )

      returnValue = [left, right]
    }else{
      returnValue = left
    }

    return returnValue
  }

  let Filter24 = inputProps => {
    let filter24   = Object.create( filter )
    let props    = Object.assign( {}, Filter24.defaults, filter.defaults, inputProps )
    let isStereo = props.input.isStereo 

    const __out = Gibberish.factory(
      filter24, 
      Gibberish.genish.filter24( g.in('input'), g.in('Q'), g.in('cutoff'), g.in('isLowPass'), isStereo ), 
      ['filters','Filter24Classic'],
      props
    )

    return __out
  }


  Filter24.defaults = {
    input:0,
    Q: .25,
    cutoff: 880,
    isLowPass:1
  }

  return Filter24

}


},{"./filter.js":156,"genish.js":51}],158:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const g = Gibberish.genish

  const filters = {
    Filter24Classic : require( './filter24.js'  )( Gibberish ),
    Filter24Moog    : require( './ladder.dsp.js' )( Gibberish ),
    Filter24TB303   : require( './diodeFilterZDF.js' )( Gibberish ),
    Filter12Biquad  : require( './biquad.dsp.js'    )( Gibberish ),
    Filter12SVF     : require( './svf.js'       )( Gibberish ),
    
    // not for use by end-users
    genish: {
      Comb        : require( './combfilter.js' ),
      AllPass     : require( './allpass.js' )
    },

    factory( input, cutoff, saturation, _props, isStereo = false ) {
      let filteredOsc 

      let props = Object.assign({}, filters.defaults, _props )

      switch( props.filterModel ) {
        case 1:
          filteredOsc = g.zd24( input, g.min( g.in('Q'), .9999 ), cutoff, 0 ) // g.max(.005, g.min( cutoff, 1 ) ) )
          break;
        case 2:
          filteredOsc = g.diodeZDF( input, g.min( g.in('Q'), .9999 ), cutoff, saturation, isStereo ) 
          break;
        case 3:
          filteredOsc = g.svf( input, cutoff, g.sub( 1, g.in('Q')), props.filterMode, isStereo, true ) 
          break; 
        case 4:
          filteredOsc = g.biquad( input, cutoff,  g.in('Q'), props.filterMode, isStereo ) 
          break; 
        case 5:
          //isLowPass = g.param( 'lowPass', 1 ),
          filteredOsc = g.filter24( input, g.in('Q'), cutoff, props.filterMode, isStereo )
          break;
        default:
          // return unfiltered signal
          filteredOsc = input //g.filter24( oscWithGain, g.in('resonance'), cutoff, isLowPass )
          break;
      }

      return filteredOsc
    },

    defaults: { filterMode: 0, filterModel:0 }
  }

  filters.export = target => {
    for( let key in filters ) {
      if( key !== 'export' && key !== 'genish' ) {
        target[ key ] = filters[ key ]
      }
    }
  }

return filters

}

},{"./allpass.js":152,"./biquad.dsp.js":153,"./combfilter.js":154,"./diodeFilterZDF.js":155,"./filter24.js":157,"./ladder.dsp.js":159,"./svf.js":160}],159:[function(require,module,exports){
const genish = require( 'genish.js' ),
      filterProto = require( './filter.js' )

module.exports = function( Gibberish ) {

  const makeChannel = function( input, _Q, _freq ) {
    'use jsdsp'
    const iT = 1 / genish.gen.samplerate,
          z  = genish.data([ 0,0,0,0 ], 1, { meta:true })

    const freq = genish.max(.005, genish.min( _freq, 1 ) ) 
    const Q = .5 + _Q * 23
    // kwd = 2 * $M_PI * acf[kindx]
    const kwd = ( Math.PI * 2 ) * freq * genish.gen.samplerate / 2

    // kwa = (2/iT) * tan(kwd * iT/2) 
    const kwa = 2/iT * genish.tan( kwd * iT/2 )

    // kG  = kwa * iT/2 
    const kg = kwa * iT/2

    // kk = 4.0*(kQ - 0.5)/(25.0 - 0.5)
    const kk = 4 * (Q - .5) / 24.5

    // kg_plus_1 = (1.0 + kg)
    const kg_plus_1 = 1 + kg

    // kG = kg / kg_plus_1 
    const kG     = kg / kg_plus_1,
          kG_2   = kG * kG,
          kG_3   = kG_2 * kG,
          kGAMMA = kG_2 * kG_2

    const kS1 = z[0] / kg_plus_1,
          kS2 = z[1] / kg_plus_1,
          kS3 = z[2] / kg_plus_1,
          kS4 = z[3] / kg_plus_1

    //kS = kG_3 * kS1  + kG_2 * kS2 + kG * kS3 + kS4 
    const kS = kG_3 * kS1 + kG_2 * kS2 + kG * kS3 + kS4

    //ku = (kin - kk *  kS) / (1 + kk * kGAMMA)
    const ku  = (input - kk * kS) / (1 + kk * kGAMMA)

    let kv =  ( ku - z[0] ) * kG
    let klp = kv + z[0]
    z[0] = klp + kv

    kv  = ( klp - z[1] ) * kG
    klp = kv + z[1]
    z[1] = klp + kv

    kv  = (klp - z[2] ) * kG
    klp = kv + z[2]
    z[2] = klp + kv

    kv  = (klp - z[3] ) * kG
    klp = kv + z[3]
    z[3] = klp + kv

    return klp
  }

  Gibberish.genish.zd24 = ( input, _Q, freq, isStereo=false ) => {
    const leftInput = isStereo === true ? input[0] : input
    const left = makeChannel( leftInput, _Q, freq )

    let out
    if( isStereo === true ) {
      const right = makeChannel( input[1], _Q, freq )
      out = [ left, right ]
    }else{
      out = left
    }

    return out
  }

  const Zd24 = inputProps => {
    const filter   = Object.create( filterProto )
    const props    = Object.assign( {}, Zd24.defaults, filter.defaults, inputProps )
    let out

    filter.__requiresRecompilation = [ 'input' ]
    filter.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = props.input !== undefined && props.input.isStereo !== undefined ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      filter.graph = Gibberish.genish.zd24( genish.in('input'), genish.in('Q'), genish.in('cutoff'), isStereo ) 
    } 

    filter.__createGraph()

    out = Gibberish.factory(
      filter, 
      filter.graph, 
      ['filters','Filter24Moog'],
      props
    )

    return out
  }

  Zd24.defaults = {
    input:0,
    Q: .75,
    cutoff: .25,
  }

  return Zd24

}


},{"./filter.js":156,"genish.js":51}],160:[function(require,module,exports){
const g = require( 'genish.js' ),
      filter = require( './filter.js' )

module.exports = function( Gibberish ) {
  Gibberish.genish.svf = ( input, cutoff, Q, mode, isStereo=false, shouldConvertFreqQ=false ) => {
    let d1 = g.data([0,0], 1, { meta:true }), d2 = g.data([0,0], 1, { meta:true }),
        peekProps = { mode:'simple', interp:'none' }

    if( shouldConvertFreqQ === true ) {
      //Q = g.min( g.add(.01 , __Q), 1 ) 
      cutoff = g.mul( g.max( .005, g.min( cutoff,.995 ) ), g.div( g.gen.samplerate, 4 ) )
    }

    let f1 = g.memo( g.mul( 2 * Math.PI, g.div( cutoff, g.gen.samplerate ) ) )
    let oneOverQ = g.memo( g.div( 1, Q ) )
    let l = g.memo( g.add( d2[0], g.mul( f1, d1[0] ) ) ),
        h = g.memo( g.sub( g.sub( isStereo ? input[0] : input, l ), g.mul( Q, d1[0] ) ) ),
        b = g.memo( g.add( g.mul( f1, h ), d1[0] ) ),
        n = g.memo( g.add( h, l ) )

    d1[0] = b
    d2[0] = l

    let out = g.selector( mode, l, h, b, n )

    let returnValue
    if( isStereo ) {
      let d12 = g.data([0,0], 1, { meta:true }), d22 = g.data([0,0], 1, { meta:true })
      let l2 = g.memo( g.add( d22[0], g.mul( f1, d12[0] ) ) ),
          h2 = g.memo( g.sub( g.sub( input[1], l2 ), g.mul( Q, d12[0] ) ) ),
          b2 = g.memo( g.add( g.mul( f1, h2 ), d12[0] ) ),
          n2 = g.memo( g.add( h2, l2 ) )

      d12[0] = b2
      d22[0] = l2

      let out2 = g.selector( mode, l2, h2, b2, n2 )

      returnValue = [ out, out2 ]
    }else{
      returnValue = out
    }

    return returnValue
  }

  let SVF = inputProps => {
    const svf = Object.create( filter )
    const props = Object.assign( {}, SVF.defaults, filter.defaults, inputProps ) 

    const isStereo = props.input.isStereo
    
    // XXX NEEDS REFACTORING
    const __out = Gibberish.factory( 
      svf,
      //Gibberish.genish.svf( g.in('input'), g.mul( g.in('cutoff'), g.gen.samplerate / 5 ), g.sub( 1, g.in('Q') ), g.in('mode'), isStereo ), 
      Gibberish.genish.svf( g.in('input'), g.mul( g.in('cutoff'), g.gen.samplerate / 5 ), g.sub( 1, g.in('Q') ), g.in('mode'), isStereo, true ), 
      ['filters','Filter12SVF'], 
      props
    )

    return __out
  }


  SVF.defaults = {
    input:0,
    Q: .65,
    cutoff:.25,
    mode:0
  }

  return SVF

}


},{"./filter.js":156,"genish.js":51}],161:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let BitCrusher = inputProps => {
  const  props = Object.assign( { bitCrusherLength: 44100 }, BitCrusher.defaults, effect.defaults, inputProps ),
         bitCrusher = Object.create( effect )

  let out

  bitCrusher.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    let input = g.in( 'input' ),
        inputGain = g.in( 'inputGain' ),
        bitDepth = g.in( 'bitDepth' ),
        sampleRate = g.in( 'sampleRate' ),
        leftInput = isStereo ? input[ 0 ] : input,
        rightInput = isStereo ? input[ 1 ] : null
    
    let storeL = g.history(0)
    let sampleReduxCounter = g.counter( sampleRate, 0, 1 )

    let bitMult = g.pow( g.mul( bitDepth, 16 ), 2 )
    let crushedL = g.div( g.floor( g.mul( g.mul( leftInput, inputGain ), bitMult ) ), bitMult )

    let outL = g.switch(
      sampleReduxCounter.wrap,
      crushedL,
      storeL.out
    )

    if( isStereo ) {
      let storeR = g.history(0)
      let crushedR = g.div( g.floor( g.mul( g.mul( rightInput, inputGain ), bitMult ) ), bitMult )

      let outR = g.switch( 
        sampleReduxCounter.wrap,
        crushedR,
        storeL.out
      )

      bitCrusher.graph = [ outL, outR ]
    }else{
      bitCrusher.graph = outL
    }
  }

  bitCrusher.__createGraph()
  bitCrusher.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    bitCrusher,
    bitCrusher.graph,
    ['fx','bitCrusher'], 
    props 
  )
  return out 
}

BitCrusher.defaults = {
  input:0,
  bitDepth:.5,
  sampleRate: .5
}

return BitCrusher

}

},{"./effect.js":166,"genish.js":51}],162:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
  let proto = Object.create( effect )

  let Shuffler = inputProps => {
    let bufferShuffler = Object.create( proto ),
        bufferSize = 88200

    const props = Object.assign( {}, Shuffler.defaults, effect.defaults, inputProps )
    
    let out
    bufferShuffler.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : true 
      }else{
        isStereo = out.input.isStereo
        //out.isStereo = isStereo
      }      
      
      const phase = g.accum( 1,0,{ shouldWrap: false })

      const input = g.in( 'input' ),
            inputGain = g.in( 'inputGain' ),
            __leftInput = isStereo ? input[ 0 ] : input,
            __rightInput = isStereo ? input[ 1 ] : null,
            leftInput = g.mul( __leftInput, inputGain ),
            rightInput = g.mul( __rightInput, inputGain ),
            rateOfShuffling = g.in( 'rate' ),
            chanceOfShuffling = g.in( 'chance' ),
            reverseChance = g.in( 'reverseChance' ),
            repitchChance = g.in( 'repitchChance' ),
            repitchMin = g.in( 'repitchMin' ),
            repitchMax = g.in( 'repitchMax' )

      let pitchMemory = g.history(1)

      let shouldShuffleCheck = g.eq( g.mod( phase, rateOfShuffling ), 0 )
      let isShuffling = g.memo( g.sah( g.lt( g.noise(), chanceOfShuffling ), shouldShuffleCheck, 0 ) ) 

      // if we are shuffling and on a repeat boundary...
      let shuffleChanged = g.memo( g.and( shouldShuffleCheck, isShuffling ) )
      let shouldReverse = g.lt( g.noise(), reverseChance ),
          reverseMod = g.switch( shouldReverse, -1, 1 )

      let pitch = g.ifelse( 
        g.and( shuffleChanged, g.lt( g.noise(), repitchChance ) ),
        g.memo( g.mul( g.add( repitchMin, g.mul( g.sub( repitchMax, repitchMin ), g.noise() ) ), reverseMod ) ),
        reverseMod
      )
      
      // only switch pitches on repeat boundaries
      pitchMemory.in( g.switch( shuffleChanged, pitch, pitchMemory.out ) )

      let fadeLength = g.memo( g.div( rateOfShuffling, 100 ) ),
          fadeIncr = g.memo( g.div( 1, fadeLength ) )

      const bufferL = g.data( bufferSize )
      const bufferR = isStereo ? g.data( bufferSize ) : null
      let readPhase = g.accum( pitchMemory.out, 0, { shouldWrap:false }) 
      let stutter = g.wrap( g.sub( g.mod( readPhase, bufferSize ), 22050 ), 0, bufferSize )

      let normalSample = g.peek( bufferL, g.accum( 1, 0, { max:88200 }), { mode:'simple' })

      let stutterSamplePhase = g.switch( isShuffling, stutter, g.mod( readPhase, bufferSize ) )
      let stutterSample = g.memo( g.peek( 
        bufferL, 
        stutterSamplePhase,
        { mode:'samples' }
      ) )
      
      let stutterShouldFadeIn = g.and( shuffleChanged, isShuffling )
      let stutterPhase = g.accum( 1, shuffleChanged, { shouldWrap: false })

      let fadeInAmount = g.memo( g.div( stutterPhase, fadeLength ) )
      let fadeOutAmount = g.div( g.sub( rateOfShuffling, stutterPhase ), g.sub( rateOfShuffling, fadeLength ) )
      
      let fadedStutter = g.ifelse(
        g.lt( stutterPhase, fadeLength ),
        g.memo( g.mul( g.switch( g.lt( fadeInAmount, 1 ), fadeInAmount, 1 ), stutterSample ) ),
        g.gt( stutterPhase, g.sub( rateOfShuffling, fadeLength ) ),
        g.memo( g.mul( g.gtp( fadeOutAmount, 0 ), stutterSample ) ),
        stutterSample
      )
      
      let outputL = g.mix( normalSample, fadedStutter, isShuffling ) 

      let pokeL = g.poke( bufferL, leftInput, g.mod( g.add( phase, 44100 ), 88200 ) )

      let panner = g.pan( outputL, outputL, g.in( 'pan' ) )
      
      bufferShuffler.graph = [ panner.left, panner.right ]
    }

    bufferShuffler.__createGraph()
    bufferShuffler.__requiresRecompilation = [ 'input' ]
    
    out = Gibberish.factory( 
      bufferShuffler,
      bufferShuffler.graph,
      ['fx','shuffler'], 
      props 
    )

    return out 
  }
  
  Shuffler.defaults = {
    input:0,
    rate:22050,
    chance:.25,
    reverseChance:.5,
    repitchChance:.5,
    repitchMin:.5,
    repitchMax:2,
    pan:.5,
    mix:.5
  }

  return Shuffler 
}

},{"./effect.js":166,"genish.js":51}],163:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )
  
module.exports = function( Gibberish ) {
 
let __Chorus = inputProps => {
  const props = Object.assign({}, __Chorus.defaults, effect.defaults, inputProps )
  let out
  
  const chorus = Object.create( effect )

  chorus.__createGraph = function() {
    const input = g.in('input'),
          inputGain = g.in( 'inputGain' ),
          freq1 = g.in('slowFrequency'),
          freq2 = g.in('fastFrequency'),
          amp1  = g.in('slowGain'),
          amp2  = g.in('fastGain')

    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    const win0   = g.env( 'inversewelch', 1024 ),
          win120 = g.env( 'inversewelch', 1024, 0, .333 ),
          win240 = g.env( 'inversewelch', 1024, 0, .666 )
    
    const slowPhasor = g.phasor( freq1, 0, { min:0 }),
          slowPeek1  = g.mul( g.peek( win0,   slowPhasor ), amp1 ),
          slowPeek2  = g.mul( g.peek( win120, slowPhasor ), amp1 ),
          slowPeek3  = g.mul( g.peek( win240, slowPhasor ), amp1 )
    
    const fastPhasor = g.phasor( freq2, 0, { min:0 }),
          fastPeek1  = g.mul( g.peek( win0,   fastPhasor ), amp2 ),
          fastPeek2  = g.mul( g.peek( win120, fastPhasor ), amp2 ),
          fastPeek3  = g.mul( g.peek( win240, fastPhasor ), amp2 )


    let sampleRate = Gibberish.ctx.sampleRate
     
    const ms = sampleRate / 1000 
    const maxDelayTime = 1000 * ms

    //console.log( 'sr:', sampleRate, 'ms:', ms, 'maxDelayTime:', maxDelayTime )

    const time1 =  g.mul( g.add( slowPeek1, fastPeek1, 5 ), ms ),
          time2 =  g.mul( g.add( slowPeek2, fastPeek2, 5 ), ms ),
          time3 =  g.mul( g.add( slowPeek3, fastPeek3, 5 ), ms )

    const delay1L = g.delay( leftInput, time1, { size:maxDelayTime }),
          delay2L = g.delay( leftInput, time2, { size:maxDelayTime }),
          delay3L = g.delay( leftInput, time3, { size:maxDelayTime })

    
    const leftOutput = g.add( delay1L, delay2L, delay3L )
    if( isStereo ) {
      const rightInput = g.mul( input[1], inputGain )
      const delay1R = g.delay(rightInput, time1, { size:maxDelayTime }),
            delay2R = g.delay(rightInput, time2, { size:maxDelayTime }),
            delay3R = g.delay(rightInput, time3, { size:maxDelayTime })

      // flip a couple delay lines for stereo effect?
      const rightOutput = g.add( delay1R, delay2L, delay3R )
      chorus.graph = [ g.add( delay1L, delay2R, delay3L), rightOutput ]
    }else{
      chorus.graph = leftOutput
    }
  }

  chorus.__createGraph()
  chorus.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( chorus, chorus.graph, ['fx','chorus'], props )

  return out 
}

__Chorus.defaults = {
  input:0,
  slowFrequency: .18,
  slowGain:3,
  fastFrequency:6,
  fastGain:1,
  inputGain:1
}

return __Chorus

}

},{"./effect.js":166,"genish.js":51}],164:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let Delay = inputProps => {
  let props = Object.assign( { delayLength: 88200 }, effect.defaults, Delay.defaults, inputProps ),
      delay = Object.create( effect )

  let out
  delay.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input      = g.in( 'input' ),
          inputGain  = g.in( 'inputGain' ),
          delayTime  = g.in( 'time' ),
          wetdry     = g.in( 'wetdry' ),
          leftInput  = isStereo ? g.mul( input[ 0 ], inputGain ) : g.mul( input, inputGain ),
          rightInput = isStereo ? g.mul( input[ 1 ], inputGain ) : null
      
    const feedback = g.in( 'feedback' )

    // left channel
    const feedbackHistoryL = g.history()
    const echoL = g.delay( g.add( leftInput, g.mul( feedbackHistoryL.out, feedback ) ), delayTime, { size:props.delayLength })
    feedbackHistoryL.in( echoL )
    const left = g.mix( leftInput, echoL, wetdry )

    if( isStereo ) {
      // right channel
      const feedbackHistoryR = g.history()
      const echoR = g.delay( g.add( rightInput, g.mul( feedbackHistoryR.out, feedback ) ), delayTime, { size:props.delayLength })
      feedbackHistoryR.in( echoR )
      const right = g.mix( rightInput, echoR, wetdry )

      delay.graph = [ left, right ]
    }else{
      delay.graph = left 
    }
  }

  delay.__createGraph()
  delay.__requiresRecompilation = [ 'input' ]
  
  out = Gibberish.factory( 
    delay,
    delay.graph, 
    ['fx','delay'], 
    props 
  )

  return out
}

Delay.defaults = {
  input:0,
  feedback:.5,
  time: 11025,
  wetdry: .5
}

return Delay

}

},{"./effect.js":166,"genish.js":51}],165:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

const genish = g

// taken from csound: http://manual.freeshell.org/csound5/distort1.html
/*

         exp(asig * (shape1 + pregain)) - exp(asig * (shape2 - pregain))
  aout = ---------------------------------------------------------------
         exp(asig * pregain)            + exp(-asig * pregain)

*/

module.exports = function( Gibberish ) {

  let Distortion = inputProps => {
    let props = Object.assign( {}, effect.defaults, Distortion.defaults, inputProps ),
        distortion= Object.create( effect ),
        out

    distortion.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      const input = g.in( 'input' ),
            inputGain = g.in( 'inputGain' ),
            shape1 = g.in( 'shape1' ),
            shape2 = g.in( 'shape2' ),
            pregain = g.in( 'pregain' ),
            postgain = g.in( 'postgain' )

      let lout
      {
        'use jsdsp'
        const linput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )
        const ltop = g.exp( linput * (shape1 + pregain) ) - g.exp( linput * (shape2 - pregain) )
        const lbottom = g.exp( linput * pregain ) + g.exp( -1 * linput * pregain )
        lout = ( ltop / lbottom ) * postgain
      }

      if( isStereo ) {
        let rout
        {
          'use jsdsp'
          const rinput = isStereo ? g.mul( input[1], inputGain ) : g.mul( input, inputGain )
          const rtop = g.exp( rinput * (shape1 + pregain) ) - g.exp( rinput * (shape2 - pregain) )
          const rbottom = g.exp( rinput * pregain ) + g.exp( -1 * rinput * pregain )
          rout = ( rtop / rbottom ) * postgain
        }

        distortion.graph = [ lout, rout ]
      }else{
        distortion.graph = lout 
      }
    }

    distortion.__createGraph()
    distortion.__requiresRecompilation = [ 'input' ]

    out = Gibberish.factory( 
      distortion,
      distortion.graph, 
      [ 'fx','distortion' ], 
      props 
    )
    return out 
  }

  Distortion.defaults = {
    input:0,
    shape1:.1,
    shape2:.1,
    pregain:5,
    postgain:.5,
  }

  return Distortion

}

},{"./effect.js":166,"genish.js":51}],166:[function(require,module,exports){
let ugen = require( '../ugen.js' )()

let effect = Object.create( ugen )

Object.assign( effect, {
  defaults: { bypass:false, inputGain:1 },
  type:'effect'
})

module.exports = effect

},{"../ugen.js":210}],167:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const effects = {
    Freeverb    : require( './freeverb.js'  )( Gibberish ),
    //Plate       : require( './dattorro.dsp.js' )( Gibberish ),
    Flanger     : require( './flanger.js'   )( Gibberish ),
    Vibrato     : require( './vibrato.js'   )( Gibberish ),
    Delay       : require( './delay.js'     )( Gibberish ),
    BitCrusher  : require( './bitCrusher.js')( Gibberish ),
    Distortion  : require( './distortion.dsp.js')( Gibberish ),
    RingMod     : require( './ringMod.js'   )( Gibberish ),
    Tremolo     : require( './tremolo.js'   )( Gibberish ),
    Chorus      : require( './chorus.js'    )( Gibberish ),
    Wavefolder  : require( './wavefolder.dsp.js')( Gibberish )[0],
    Shuffler    : require( './bufferShuffler.js'  )( Gibberish ),
    //Gate        : require( './gate.js'      )( Gibberish ),
  }

  effects.export = target => {
    for( let key in effects ) {
      if( key !== 'export' ) {
        target[ key ] = effects[ key ]
      }
    }
  }

return effects

}

},{"./bitCrusher.js":161,"./bufferShuffler.js":162,"./chorus.js":163,"./delay.js":164,"./distortion.dsp.js":165,"./flanger.js":168,"./freeverb.js":169,"./ringMod.js":170,"./tremolo.js":171,"./vibrato.js":172,"./wavefolder.dsp.js":173}],168:[function(require,module,exports){
let g = require( 'genish.js' ),
    proto = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let Flanger = inputProps => {
  let props   = Object.assign( { delayLength:44100 }, Flanger.defaults, proto.defaults, inputProps ),
      flanger = Object.create( proto ),
      out

  flanger.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          delayLength = props.delayLength,
          feedbackCoeff = g.in( 'feedback' ),
          modAmount = g.in( 'offset' ),
          frequency = g.in( 'frequency' ),
          delayBufferL = g.data( delayLength )

    const writeIdx = g.accum( 1,0, { min:0, max:delayLength, interp:'none', mode:'samples' })
    
    const offset = g.mul( modAmount, 500 )

    const mod = props.mod === undefined ? g.cycle( frequency ) : props.mod
    
    const readIdx = g.wrap( 
      g.add( 
        g.sub( writeIdx, offset ), 
        mod//g.mul( mod, g.sub( offset, 1 ) ) 
      ), 
      0, 
      delayLength
    )

    const leftInput = isStereo ? input[0] : input

    const delayedOutL = g.peek( delayBufferL, readIdx, { interp:'linear', mode:'samples' })
    
    g.poke( delayBufferL, g.add( leftInput, g.mul( delayedOutL, feedbackCoeff ) ), writeIdx )

    const left = g.add( leftInput, delayedOutL )

    if( isStereo === true ) {
      const rightInput = input[1]
      const delayBufferR = g.data( delayLength )
      
      let delayedOutR = g.peek( delayBufferR, readIdx, { interp:'linear', mode:'samples' })

      g.poke( delayBufferR, g.add( rightInput, g.mul( delayedOutR, feedbackCoeff ) ), writeIdx )
      const right = g.add( rightInput, delayedOutR )

      flanger.graph = [ left, right ]

    }else{
      flanger.graph = left
    }
  }

  flanger.__createGraph()
  flanger.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    flanger,
    flanger.graph, 
    ['fx','flanger'], 
    props 
  ) 

  return out 
}

Flanger.defaults = {
  input:0,
  feedback:.81,
  offset:.125,
  frequency:1
}

return Flanger

}

},{"./effect.js":166,"genish.js":51}],169:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
  
const allPass = Gibberish.filters.genish.AllPass
const combFilter = Gibberish.filters.genish.Comb

const tuning = {
  combCount:	  	8,
  combTuning: 		[ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],                    
  allPassCount: 	4,
  allPassTuning:	[ 225, 556, 441, 341 ],
  allPassFeedback:0.5,
  fixedGain: 		  0.015,
  scaleDamping: 	0.4,
  scaleRoom: 		  0.28,
  offsetRoom: 	  0.7,
  stereoSpread:   23
}

const Freeverb = inputProps => {
  const props = Object.assign( {}, effect.defaults, Freeverb.defaults, inputProps ),
        reverb = Object.create( effect ) 

  let out 
  reverb.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
    }    

    const combsL = [], combsR = []

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          wet1 = g.in( 'wet1'),
          wet2 = g.in( 'wet2' ),  
          dry = g.in( 'dry' ), 
          roomSize = g.in( 'roomSize' ), 
          damping = g.in( 'damping' )
    
    const __summedInput = isStereo === true ? g.add( input[0], input[1] ) : input,
          summedInput = g.mul( __summedInput, inputGain ),
          attenuatedInput = g.memo( g.mul( summedInput, tuning.fixedGain ) )
    
    // create comb filters in parallel...
    for( let i = 0; i < 8; i++ ) { 
      combsL.push( 
        combFilter( 
          attenuatedInput, 
          tuning.combTuning[i], 
          g.mul(damping,.4),
          g.mul( tuning.scaleRoom + tuning.offsetRoom, roomSize ) 
        ) 
      )
      combsR.push( 
        combFilter( 
          attenuatedInput, 
          tuning.combTuning[i] + tuning.stereoSpread, 
          g.mul(damping,.4), 
          g.mul( tuning.scaleRoom + tuning.offsetRoom, roomSize ) 
        ) 
      )
    }
    
    // ... and sum them with attenuated input, use of let is deliberate here
    let outL = g.add( attenuatedInput, ...combsL )
    let outR = g.add( attenuatedInput, ...combsR )
    
    // run through allpass filters in series
    for( let i = 0; i < 4; i++ ) { 
      outL = allPass( outL, tuning.allPassTuning[ i ] + tuning.stereoSpread )
      outR = allPass( outR, tuning.allPassTuning[ i ] + tuning.stereoSpread )
    }
    
    const outputL = g.add( g.mul( outL, wet1 ), g.mul( outR, wet2 ), g.mul( isStereo === true ? input[0] : input, dry ) ),
          outputR = g.add( g.mul( outR, wet1 ), g.mul( outL, wet2 ), g.mul( isStereo === true ? input[1] : input, dry ) )

    reverb.graph = [ outputL, outputR ]
  }

  reverb.__createGraph()
  reverb.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( reverb, reverb.graph, ['fx','freeverb'], props )

  return out
}


Freeverb.defaults = {
  input: 0,
  wet1: 1,
  wet2: 0,
  dry: .5,
  roomSize: .925,
  damping:  .5,
}

return Freeverb 

}


},{"./effect.js":166,"genish.js":51}],170:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let RingMod = inputProps => {
  let props   = Object.assign( {}, RingMod.defaults, effect.defaults, inputProps ),
      ringMod = Object.create( effect ),
      out

  ringMod.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          frequency = g.in( 'frequency' ),
          gain = g.in( 'gain' ),
          mix = g.in( 'mix' )
    
    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain ),
          sine = g.mul( g.cycle( frequency ), gain )
   
    const left = g.add( g.mul( leftInput, g.sub( 1, mix )), g.mul( g.mul( leftInput, sine ), mix ) ) 
        
    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain ),
            right = g.add( g.mul( rightInput, g.sub( 1, mix )), g.mul( g.mul( rightInput, sine ), mix ) ) 
      
      ringMod.graph = [ left, right ]
    }else{
      ringMod.graph = left
    }
  }

  ringMod.__createGraph() 
  ringMod.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    ringMod,
    ringMod.graph, 
    [ 'fx','ringMod'], 
    props 
  )
  
  return out 
}

RingMod.defaults = {
  input:0,
  frequency:220,
  gain: 1, 
  mix:1
}

return RingMod

}

},{"./effect.js":166,"genish.js":51}],171:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
const Tremolo = inputProps => {
  const props   = Object.assign( {}, Tremolo.defaults, effect.defaults, inputProps ),
        tremolo = Object.create( effect )
  
  let out
  tremolo.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          frequency = g.in( 'frequency' ),
          amount = g.in( 'amount' )
    
    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    let osc
    if( props.shape === 'square' ) {
      osc = g.gt( g.phasor( frequency ), 0 )
    }else if( props.shape === 'saw' ) {
      osc = g.gtp( g.phasor( frequency ), 0 )
    }else{
      osc = g.cycle( frequency )
    }

    const mod = g.mul( osc, amount )
   
    const left = g.sub( leftInput, g.mul( leftInput, mod ) )

    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain ),
            right = g.mul( rightInput, mod )

      tremolo.graph = [ left, right ]
    }else{
      tremolo.graph = left
    }
  }
  
  tremolo.__createGraph()
  tremolo.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    tremolo,
    tremolo.graph,
    ['fx','tremolo'], 
    props 
  ) 
  return out 
}

Tremolo.defaults = {
  input:0,
  frequency:2,
  amount: 1, 
  shape:'sine'
}

return Tremolo

}

},{"./effect.js":166,"genish.js":51}],172:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
const Vibrato = inputProps => {
  const props   = Object.assign( {}, Vibrato.defaults, effect.defaults, inputProps ),
        vibrato = Object.create( effect )

  let out
  vibrato.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          delayLength = 44100,
          feedbackCoeff = g.in( 'feedback' ),
          modAmount = g.in( 'amount' ),
          frequency = g.in( 'frequency' ),
          delayBufferL = g.data( delayLength )

    const writeIdx = g.accum( 1,0, { min:0, max:delayLength, interp:'none', mode:'samples' })
    
    const offset = g.mul( modAmount, 500 )
    
    const readIdx = g.wrap( 
      g.add( 
        g.sub( writeIdx, offset ), 
        g.mul( g.cycle( frequency ), g.sub( offset, 1 ) ) 
      ), 
      0, 
      delayLength
    )

    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    const delayedOutL = g.peek( delayBufferL, readIdx, { interp:'linear', mode:'samples' })
    
    g.poke( delayBufferL, g.add( leftInput, g.mul( delayedOutL, feedbackCoeff ) ), writeIdx )

    const left = delayedOutL

    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain )
      const delayBufferR = g.data( delayLength )
      
      const delayedOutR = g.peek( delayBufferR, readIdx, { interp:'linear', mode:'samples' })

      g.poke( delayBufferR, g.add( rightInput, mul( delayedOutR, feedbackCoeff ) ), writeIdx )
      const right = delayedOutR

      vibrato.graph = [ left, right ]
    }else{
      vibrato.graph = left 
    }
  }

  vibrato.__createGraph()
  vibrato.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    vibrato,
    vibrato.graph,    
    [ 'fx', 'vibrato' ], 
    props 
  ) 
  return out 
}

Vibrato.defaults = {
  input:0,
  feedback:.01,
  amount:.5,
  frequency:4
}

return Vibrato

}

},{"./effect.js":166,"genish.js":51}],173:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

const genish = g

const RL = 7.5e3,
       R = 15e3, 
      VT = 26e-3,
      Is = 10e-16,
       a = 2*RL/R,
       b = (R+2*RL)/(VT*R),
       d = (RL*Is)/VT

// Antialiasing error threshold
const thresh = 10e-10;

const wavestage = in1 => {
  const body = `  const thresh = 10e-10;

  let w = Ln1;
  let expw, p, r, s;

  const e = Math.E
  const pow = Math.pow
  const abs = Math.abs
  for(let i=0; i<1000; i++) {
    expw = pow(e,w);

    p = w*expw - x;
    r = (w+1)*expw;
    s = (w+2)/(2*(w+1));        
    err = (p/(r-(p*s)));

    if (abs(err)<thresh) {
      break;
    }

    w = w - err;
  }

  return w;`

  const Lambert_W = g.process( 'x','Ln1', body )

  const Ln1 = g.history(0),
        Fn1 = g.history(0),
        xn1 = g.history(0)

  {
    'use jsdsp'
    // Compute Antiderivative
    const l = g.sign(in1); 
    let u = d * g.pow( Math.E, l * b * in1 )
    let Ln = Lambert_W.call(u,Ln1.out)
    const Fn = (0.5 * VT/b ) * (Ln * (Ln + 2)) - 0.5*a*in1*in1

    let xn = 0.5 * ( in1 + xn1.out )
    u = d * g.pow( Math.E, l * b * xn )
    Ln = Lambert_W.call( u, Ln1.out )

    //out1 = ;
    // Check for ill-conditioning
    const out1 = g.ifelse(
      g.lt( g.abs( in1 - xn1.out ), thresh), 
      (l * VT * Ln) - ( a * xn ),
      (Fn - Fn1.out) / (in1 - xn1.out)
    )

    // Update States
    Ln1.in( Ln )
    Fn1.in( Fn )
    xn1.in( in1 )

    return out1
  }
}

module.exports = function( Gibberish ) {

  const Wavefolder = inputProps => {

    let props = Object.assign( {}, effect.defaults, Wavefolder.defaults, inputProps ),
        wavefolder = Object.create( effect ),
        out

    wavefolder.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      const input = g.in( 'input' ),
            gain  = g.in( 'gain' ),
            postgain = g.in( 'postgain' )

      let lout
      {
        'use jsdsp'

        const linput = isStereo ? input[0] * gain : input * gain
        lout = linput * .333
        lout = wavestage( wavestage( wavestage( wavestage( lout ) ) ) )
        lout = lout * .6
        lout = g.tanh( lout ) * postgain
      }

      wavefolder.graph = lout

      if( isStereo ) {
        let rout
        {
          'use jsdsp'
          const rinput = isStereo ? input[1] * gain : input * gain
          rout = rinput * .333
          rout = wavestage( wavestage( wavestage( wavestage( rout ) ) ) )
          rout = rout * .6
          rout = g.tanh( rout ) * postgain
        }

        wavefolder.graph = [ lout, rout ]
      }
    }

    wavefolder.__createGraph()
    wavefolder.__requiresRecompilation = [ 'input' ]

    out = Gibberish.factory( 
      wavefolder,
      wavefolder.graph, 
      [ 'fx','wavefolder' ], 
      props 
    )

    return out 
  }

  Wavefolder.defaults = {
    input:0,
    gain:2,
    postgain:1
  }

  return [ Wavefolder, wavestage ]

}

},{"./effect.js":166,"genish.js":51}],174:[function(require,module,exports){
let MemoryHelper = require( 'memory-helper' ),
    genish       = require( 'genish.js' )
    
let Gibberish = {
  blockCallbacks: [], // called every block
  dirtyUgens: [],
  callbackUgens: [],
  callbackNames: [],
  analyzers: [],
  graphIsDirty: false,
  ugens: {},
  debug: false,
  id: -1,
  preventProxy:false,
  proxyEnabled: true,

  output: null,

  memory : null, // 20 minutes by default?
  factory: null, 
  genish,
  scheduler: require( './scheduling/scheduler.js' ),
  //workletProcessorLoader: require( './workletProcessor.js' ),
  workletProcessor: null,

  memoed: {},
  mode:'scriptProcessor',

  prototypes: {
    ugen: null,//require('./ugen.js'),
    instrument: require( './instruments/instrument.js' ),
    effect: require( './fx/effect.js' ),
    analyzer: require( './analysis/analyzer.js' )
  },

  mixins: {
    polyinstrument: require( './instruments/polyMixin.js' )
  },

  workletPath: './gibberish_worklet.js',

  init( memAmount, ctx, mode='worklet' ) {
    let numBytes = isNaN( memAmount ) ? 20 * 60 * 44100 : memAmount

    // regardless of whether or not gibberish is using worklets,
    // we still want genish to output vanilla js functions instead
    // of audio worklet classes; these functions will be called
    // from within the gibberish audioworklet processor node.
    this.genish.gen.mode = 'scriptProcessor'

    this.memory = MemoryHelper.create( numBytes, Float64Array )

    this.mode = mode

    const startup = this.utilities.createWorklet

    this.scheduler.init( this )
    
    this.analyzers.dirty = false

    if( this.mode === 'worklet' ) {

      const p = new Promise( (resolve, reject ) => {

        const pp = new Promise( (__resolve, __reject ) => {
          this.utilities.createContext( ctx, startup.bind( this.utilities ), __resolve )
        }).then( ()=> {
          Gibberish.preventProxy = true
          Gibberish.load()
          Gibberish.preventProxy = false
          Gibberish.output = this.Bus2()

          // Gibberish.output needs to be assign so that ugens can
          // connect to it by default. There's no other way to assign it
          // outside of evaling code at this point.
          Gibberish.worklet.port.postMessage({ 
            address:'eval', 
            code:`Gibberish.output = this.ugens.get(${Gibberish.output.id});` 
          })

          resolve()
        })

      })
      
      return p

    }else if( this.mode === 'processor' ) {
      Gibberish.load()
    }
  },

  load() {
    this.factory      = require( './factory.js' )( this )
    
    this.Panner       = require( './misc/panner.js' )( this )
    this.PolyTemplate = require( './instruments/polytemplate.js' )( this )
    this.oscillators  = require( './oscillators/oscillators.js' )( this )
    this.filters      = require( './filters/filters.js' )( this )
    this.binops       = require( './misc/binops.js' )( this )
    this.monops       = require( './misc/monops.js' )( this )
    this.Bus          = require( './misc/bus.js' )( this )
    this.Bus2         = require( './misc/bus2.js' )( this )
    this.instruments  = require( './instruments/instruments.js' )( this )
    this.fx           = require( './fx/effects.js' )( this )
    this.Sequencer    = require( './scheduling/sequencer.js' )( this )
    this.Sequencer2   = require( './scheduling/seq2.js' )( this )
    this.Tidal        = require( './scheduling/tidal.js' )( this )
    this.envelopes    = require( './envelopes/envelopes.js' )( this )
    this.analysis     = require( './analysis/analyzers.js' )( this )
    this.time         = require( './misc/time.js' )( this )
    this.Proxy        = require( './workletProxy.js' )( this )
  },

  export( target, shouldExportGenish=false ) {
    if( target === undefined ) throw Error('You must define a target object for Gibberish to export variables to.')

    if( shouldExportGenish ) this.genish.export( target )

    this.instruments.export( target )
    this.fx.export( target )
    this.filters.export( target )
    this.oscillators.export( target )
    this.binops.export( target )
    this.monops.export( target )
    this.envelopes.export( target )
    this.analysis.export( target )
    target.Sequencer = this.Sequencer
    target.Sequencer2 = this.Sequencer2
    target.Bus = this.Bus
    target.Bus2 = this.Bus2
    target.Scheduler = this.scheduler
    target.Tidal = this.Tidal
    this.time.export( target )
    this.utilities.export( target )
  },

  printcb() { 
    Gibberish.worklet.port.postMessage({ address:'callback' }) 
  },
  printobj( obj ) {
    Gibberish.worklet.port.postMessage({ address:'print', object:obj.id }) 
  },
  send( msg ){
    Gibberish.worklet.port.postMessage( msg )
  },

  dirty( ugen ) {
    if( ugen === this.analyzers ) {
      this.graphIsDirty = true
      this.analyzers.dirty = true
    } else {
      this.dirtyUgens.push( ugen )
      this.graphIsDirty = true
      if( this.memoed[ ugen.ugenName ] ) {
        delete this.memoed[ ugen.ugenName ]
      }
    } 
  },

  clear() {
    // do not delete the gain and the pan of the master bus 
    this.output.inputs.splice( 0, this.output.inputs.length - 2 )
    //this.output.inputNames.length = 0
    this.analyzers.length = 0
    this.scheduler.clear()
    this.dirty( this.output )
    if( this.mode === 'worklet' ) {
      this.worklet.port.postMessage({ 
        address:'method', 
        object:this.id,
        name:'clear',
        args:[]
      })
    }
    // clear memory... XXX should this be a MemoryHelper function?
    //this.memory.heap.fill(0)
    //this.memory.list = {}

    Gibberish.genish.gen.removeAllListeners('memory init')
    Gibberish.genish.gen.histories.clear()

    //Gibberish.output = this.Bus2()
    
  },

  // used to sort analysis ugens by priority.
  // higher priorities mean lower ordering in the array,
  // which means they will run first in the callback function.
  // by defult, analysis ugens are assigned a priority of 0 in the
  // analysis prototype.
  analysisCompare( a,b ) {
    return (isNaN(b.priority) ? 0 : b.priority) - (isNaN(a.priority) ? 0: a.priority )
  },

  generateCallback() {
    if( this.mode === 'worklet' ) {
      Gibberish.callback = function() { return 0 }
      Gibberish.callback.out = []
      return Gibberish.callback
    }
    let uid = 0,
        callbackBody, lastLine, analysis=''

    this.memoed = {}

    callbackBody = this.processGraph( this.output )
    lastLine = callbackBody[ callbackBody.length - 1]
    callbackBody.unshift( "\t'use strict'" )

    this.analyzers
      .sort( this.analysisCompare )
      .forEach( v=> {
        const analysisBlock = Gibberish.processUgen( v )
        //if( Gibberish.mode === 'processor' ) {
        //  console.log( 'analysis:', analysisBlock, v  )
        //}
        let analysisLine

        if( typeof analysisBlock === 'object' ) {
          analysisLine = analysisBlock.pop()

          analysisBlock.forEach( v => {
            callbackBody.splice( callbackBody.length - 1, 0, v )
          })
        }else{
          analysisLine = analysisBlock
        }

        callbackBody.push( analysisLine )
      })

    this.analyzers.forEach( v => {
      if( this.callbackUgens.indexOf( v.callback ) === -1 )
        this.callbackUgens.push( v.callback )
    })

    this.callbackNames = this.callbackUgens.map( v => v.ugenName )

    callbackBody.push( '\n\treturn ' + lastLine.split( '=' )[0].split( ' ' )[1] )

    if( this.debug === true ) console.log( 'callback:\n', callbackBody.join('\n') )
    
    this.callbackNames.push( 'mem' )
    this.callbackUgens.push( this.memory.heap )
    this.callback = Function( ...this.callbackNames, callbackBody.join( '\n' ) )//.bind( null, ...this.callbackUgens )
    this.callback.out = []

    if( this.oncallback ) this.oncallback( this.callback )

    return this.callback 
  },

  processGraph( output ) {
    this.callbackUgens.length = 0
    this.callbackNames.length = 0

    this.callbackUgens.push( output.callback )

    let body = this.processUgen( output )
    

    this.dirtyUgens.length = 0
    this.graphIsDirty = false

    return body
  },
  proxyReplace( obj ) {
    if( typeof obj === 'object' && obj !== null ) {
      if( obj.id !== undefined ) {
        const __obj = Gibberish.processor.ugens.get( obj.id )
        //console.log( 'retrieved:', __obj.name )

        //if( obj.prop !== undefined ) console.log( 'got a ssd.out', obj )
        return obj.prop !== undefined ? __obj[ obj.prop ] : __obj
      }else if( obj.isFunc === true ) {
        let func =  eval( '(' + obj.value + ')' )

        //console.log( 'replacing function:', func )

        return func
      }
    }

    return obj
  },

  processUgen( ugen, block ) {
    if( block === undefined ) block = []
    if( ugen === undefined ) return block


    let dirtyIdx = Gibberish.dirtyUgens.indexOf( ugen )

    let memo = Gibberish.memoed[ ugen.ugenName ]

    if( memo !== undefined ) {
      return memo
    } else if( ugen === true || ugen === false ) {
      throw "Why is ugen a boolean? [true] or [false]";
    } else if( ugen.block === undefined || dirtyIndex !== -1 ) {
      // weird edge case with analysis (follow) ugen
      if( ugen.id === undefined ) {
        ugen.id = ugen.__properties__.overrideid
      }

      let line = `\tconst v_${ugen.id} = ` 
      if( !ugen.isop ) line += `${ugen.ugenName}( `

      // must get array so we can keep track of length for comma insertion
      const keys = ugen.isop === true || ugen.type === 'bus'  
        ? Object.keys( ugen.inputs ) 
        : [...ugen.inputNames ] 

      line = ugen.isop === true 
        ? Gibberish.__processBinop( ugen, line, block, keys ) 
        : Gibberish.__processNonBinop( ugen, line, block, keys )

      line = Gibberish.__addLineEnding( line, ugen, keys )

      block.push( line )
      
      Gibberish.memoed[ ugen.ugenName ] = `v_${ugen.id}`

      if( dirtyIdx !== -1 ) {
        Gibberish.dirtyUgens.splice( dirtyIdx, 1 )
      }

    }else if( ugen.block ) {
      return ugen.block
    }

    return block
  }, 

  __processBinop( ugen, line, block, keys ) {
    //__getInputString( line, input, block, key, ugen ) {
    const isLeftStereo = Gibberish.__isStereo( ugen.inputs[0] ), 
          isRightStereo = Gibberish.__isStereo( ugen.inputs[1] ),
          left = Gibberish.__getInputString( line, ugen.inputs[0], block, '0', keys ),
          right= Gibberish.__getInputString( line, ugen.inputs[1], block, '1', keys ),
          op = ugen.op
        
    let graph, out

    if( isLeftStereo === true && isRightStereo === false ) {
      line += `[ ${left}[0] ${op} ${right}, ${left}[1] ${op} ${right} ]`
      //graph = [ g.add( args[0].graph[0], args[1] ), g.add( args[0].graph[1], args[1] )]
    }else if( isLeftStereo === false && isRightStereo === true ) {
      //graph = [ g.add( args[0], args[1].graph[0] ), g.add( args[0], args[1].graph[1] )]
      line += `[ ${left} ${op} ${right}[0], ${left} ${op} ${right}[1] ]`
    }else if( isLeftStereo === true && isRightStereo === true ) {
      //graph = [ g.add( args[0].graph[0], args[1].graph[0] ), g.add( args[0].graph[1], args[1].graph[1] )]
      line += `[ ${left}[0] ${op} ${right}[0], ${left}[1] ${op} ${right}[1] ]`
    }else{
      // XXX important, must re-assign when calling processNonBinop
      line = Gibberish.__processNonBinop( ugen, line, block, keys )
    }
    
    return line
  },

  __processNonBinop( ugen, line, block, keys ) {
    for( let i = 0; i < keys.length; i++ ) {
      let key = keys[ i ]
      // binop.inputs is actual values, not just property names
      let input 
      if( ugen.isop || ugen.type ==='bus' ) {
        input = ugen.inputs[ key ]
      }else{
        input = ugen[ key ] 
      }

      if( input !== undefined ) { 
        input = Gibberish.__getBypassedInput( input )
        line += Gibberish.__getInputString( line, input, block, key, ugen )
        line  = Gibberish.__addSeparator( line, input, ugen, i < keys.length - 1 )
      }
    }

    return line
  },

  // determine if a ugen is stereo
  __isStereo( ugen ) {
    let isStereo = false

    if( ugen === undefined || ugen === null ) return false

    if( ugen.isStereo === true ) return true

    if( ugen.isop === true ) {
      return Gibberish.__isStereo( ugen.inputs[0] ) || Gibberish.__isStereo( ugen.inputs[1] )
    }
    
    return isStereo
  },

  // if an effect is bypassed, get next one in chain (or output destination)
  __getBypassedInput( input ) {
    if( input.bypass === true ) {
      // loop through inputs of chain until one is found
      // that is not being bypassed

      let found = false

      while( input.input !== 'undefined' && found === false ) {
        if( typeof input.input.bypass !== 'undefined' ) {
          input = input.input
          if( input.bypass === false ) found = true
        }else{
          input = input.input
          found = true
        }
      }
    }

    return input
  },

  // get a string representing a ugen for insertion into callback.
  // if a ugen contains other ugens, trigger codegen for those ugens as well.
  __getInputString( line, input, block, key, ugen ) {
    let value = ''
    if( typeof input === 'number' ) {
      if( isNaN(key) ) {
        value += `mem[${ugen.__addresses__[ key ]}]`//input
      }else{
        value += input
      }
    } else if( typeof input === 'boolean' ) {
      value += '' + input
    }else{
      //console.log( 'key:', key, 'input:', ugen.inputs, ugen.inputs[ key ] ) 
      // XXX not sure why this has to be here, but somehow non-processed objects
      // that only contain id numbers are being passed here...

      if( input !== undefined ) {
        if( Gibberish.mode === 'processor' ) {
          if( input.ugenName === undefined && input.id !== undefined  ) {
            if( ugen === undefined  ) {
              input = Gibberish.processor.ugens.get( input.id )
            }else{
              if( ugen.type !== 'seq' ) {
                input = Gibberish.processor.ugens.get( input.id )
              }
            }
          }
        }

        Gibberish.processUgen( input, block )

        if( !input.isop ) {
          // check is needed so that graphs with ssds that refer to themselves
          // don't add the ssd in more than once
          if( Gibberish.callbackUgens.indexOf( input.callback ) === -1 ) {
            Gibberish.callbackUgens.push( input.callback )
          }
        }

        value += `v_${input.id}`
        input.__varname = value
      }
    }

    return value
  },

  // add separators for function calls and handle binops (mono only)
  __addSeparator( line, input, ugen, isNotEndOfLine ) {
    if( isNotEndOfLine === true ) {
      if( ugen.isop === true ) {
        if( ugen.op === '*' || ugen.op === '/' ) {
          if( input !== 1 ) {
            line += ' ' + ugen.op + ' '
          }else{
            line = line.slice( 0, -1 * (''+input).length )
          }
        }else{
          line += ' ' + ugen.op + ' '
        }
      }else{
        line += ', '
      }
    }

    return line
  },

  // add memory to end of function calls and close parenthesis 
  __addLineEnding( line, ugen, keys ) {
    if( (ugen.type === 'bus' && keys.length > 0) ) line += ', '
    if( !ugen.isop && ugen.type !== 'seq' ) line += 'mem'
    line += ugen.isop ? '' : ' )'

    return line
  },

}

Gibberish.prototypes.Ugen = Gibberish.prototypes.ugen = require( './ugen.js' )( Gibberish )
Gibberish.utilities = require( './utilities.js' )( Gibberish )

module.exports = Gibberish

},{"./analysis/analyzer.js":140,"./analysis/analyzers.js":141,"./envelopes/envelopes.js":146,"./factory.js":151,"./filters/filters.js":158,"./fx/effect.js":166,"./fx/effects.js":167,"./instruments/instrument.js":181,"./instruments/instruments.js":182,"./instruments/polyMixin.js":187,"./instruments/polytemplate.js":188,"./misc/binops.js":194,"./misc/bus.js":195,"./misc/bus2.js":196,"./misc/monops.js":197,"./misc/panner.js":198,"./misc/time.js":199,"./oscillators/oscillators.js":202,"./scheduling/scheduler.js":206,"./scheduling/seq2.js":207,"./scheduling/sequencer.js":208,"./scheduling/tidal.js":209,"./ugen.js":210,"./utilities.js":211,"./workletProxy.js":212,"genish.js":51,"memory-helper":221}],175:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g
  
module.exports = function( Gibberish ) {

  const Clap = argumentProps => {
    'use jsdsp' 

    const clap = Object.create( instrument ),
          decay = g.in( 'decay' ), // 0-1 input value
          scaledDecay = decay * (g.gen.samplerate * 2 ),
          gain  = g.in( 'gain' ),
          spacing = g.in( 'spacing' ), // spacing between clap, in Hzs
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          cutoff = g.in('cutoff'),
          Q      = g.in('Q')

    const props = Object.assign( {}, Clap.defaults, argumentProps )

    const eg = g.decay( scaledDecay, { initValue:0 } ), 
          check = g.gt( eg, .0005 ),
          noise = -1 + g.noise() * 2,
          rnd = noise,//g.gtp( noise, 0 ),// * eg,
          b   = g.bang(),
          saw = g.phasor( spacing, b, { min:0 }),
          rsaw = 1 - saw,
          saw_env = g.ad( 0, .035 * g.gen.samplerate, { shape:'linear' }), 
          b2 = g.bang(),
          count = g.accum( 1,b2,{ max:Infinity, min:0, initialValue:0 }),
          delayedNoise = g.switch( g.gte( count, g.gen.samplerate * .035 ), rnd, 0 ),
          bpf1 = g.svf( delayedNoise, 1000, .5, 2, false ),

          scaledOut = ( bpf1 * eg + ( rnd * rsaw * saw_env ) ) * gain * loudness * triggerLoudness,
          out = g.svf( scaledOut, cutoff, Q, 1, false )
    
    // XXX TODO : make this work with ifelse. the problem is that poke ugens put their
    // code at the bottom of the callback function, instead of at the end of the
    // associated if/else block.
    const ife = g.switch( check, out, 0 )
    
    clap.env = {
      trigger( vol ) {
        b.trigger()
        eg.trigger( vol )
        b2.trigger()
        saw_env.trigger()
      }
    } 
    
    return Gibberish.factory( clap, ife, ['instruments','clap'], props  )
  }
  
  Clap.defaults = {
    gain: 1,
    spacing:100,
    decay:.2,
    loudness:1,
    __triggerLoudness:1,
    cutoff:900,
    Q:.85
  }

  return Clap

}

},{"./instrument.js":181,"genish.js":51}],176:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' ),
      __wavefold   = require( '../fx/wavefolder.dsp.js' )

const genish = g

module.exports = function( Gibberish ) {
  const wavefold = __wavefold( Gibberish )[1]

  const Complex = inputProps => {
    const syn = Object.create( instrument )

    const frequency = g.in( 'frequency' ),
          loudness  = g.in( 'loudness' ), 
          triggerLoudness = g.in( '__triggerLoudness' ),
          glide   = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.slide( frequency, glide, glide ),
          attack  = g.in( 'attack' ), 
          decay   = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), 
          sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' ),
          pregain = g.in( 'pregain' ),
          postgain= g.in( 'postgain' ),
          bias    = g.in( 'bias' )

    const props = Object.assign( {}, Complex.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const osc = Gibberish.oscillators.factory( syn.waveform, slidingFreq, syn.antialias )

      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      const saturation = g.in('saturation')

      // below doesn't work as it attempts to assign to release property triggering codegen...
      // syn.release = ()=> { syn.env.release() }

      {
        'use jsdsp'
        let oscWithEnv = osc * env * loudness * triggerLoudness,
            panner

        let foldedOsc = wavefold( wavefold( wavefold( wavefold( bias + oscWithEnv * (pregain * env) * .333 ) ) ) )
        foldedOsc = g.tanh( foldedOsc * .6 ) * postgain
 
        // 16 is an unfortunate empirically derived magic number...
        const baseCutoffFreq = g.in('cutoff') * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness * triggerLoudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( foldedOsc, cutoff, saturation, props )

        let complexWithGain = filteredOsc * g.in( 'gain' )
        // XXX ugly, ugly hack
        if(  props.filterModel !== 2 ) complexWithGain = complexWithGain * saturation
    
        if( syn.panVoices === true ) { 
          panner = g.pan( complexWithGain, complexWithGain, g.in( 'pan' ) ) 
          syn.graph = [ panner.left, panner.right ]
        }else{
          syn.graph = complexWithGain
        }

        syn.env = env
        syn.osc = osc
        syn.filter = filteredOsc
      }

    }
    
    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel','filterMode', 'useADSR', 'shape' ]
    syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments', 'complex'], props  )

    return out
  }
  
  Complex.defaults = {
    waveform:'triangle',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'exponential',
    triggerRelease:false,
    gain: .5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:true,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    glide:1,
    saturation:1,
    filterMult:2,
    Q:.25,
    cutoff:.5,
    //filterType:1,
    filterModel:1,
    filterMode:0,
    isStereo:false,
    pregain:4,
    postgain:1,
    bias:0
  }

  // do not include velocity, which shoudl always be per voice
  let PolyComplex = Gibberish.PolyTemplate( Complex, ['frequency','attack','decay','pulsewidth','pan','gain','glide', 'saturation', 'filterMult', 'Q', 'cutoff', 'resonance', 'antialias', 'filterModel', 'waveform', 'filterMode', '__triggerLoudness', 'loudness', 'pregain', 'postgain', 'bias'] ) 
  PolyComplex.defaults = Complex.defaults

  return [ Complex, PolyComplex ]

}

},{"../fx/wavefolder.dsp.js":173,"./instrument.js":181,"genish.js":51}],177:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Conga = argumentProps => {
    const conga = Object.create( instrument ),
          frequency = g.in( 'frequency' ),
          decay = g.in( 'decay' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Conga.defaults, argumentProps )

    const trigger = g.bang(),
          impulse = g.mul( trigger, 60 ),
          _decay =  g.sub( .101, g.div( decay, 10 ) ), // create range of .001 - .099
          bpf = g.svf( impulse, frequency, _decay, 2, false ),
          out = g.mul( bpf, g.mul( g.mul( triggerLoudness,loudness ), gain ) )
    
    conga.isStereo = false
    conga.env = trigger
    return Gibberish.factory( conga, out, ['instruments','conga'], props  )
  }
  
  Conga.defaults = {
    gain: .125,
    frequency:190,
    decay: .85,
    loudness: 1,
    __triggerLoudness:1
  }

  const PolyConga = Gibberish.PolyTemplate( Conga, ['gain','frequency','decay','loudness','__triggerLoudness' ] ) 
  PolyConga.defaults = Conga.defaults

  return [ Conga, PolyConga ]
}

},{"./instrument.js":181,"genish.js":51}],178:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Cowbell = argumentProps => {
    let cowbell = Object.create( instrument )
    
    const decay   = g.in( 'decay' ),
          gain    = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Cowbell.defaults, argumentProps )

    const bpfCutoff = g.param( 'bpfc', 1000 ),
          s1 = Gibberish.oscillators.factory( 'square', 560 ),
          s2 = Gibberish.oscillators.factory( 'square', 845 ),
          eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 }), 
          bpf = g.svf( g.add( s1,s2 ), bpfCutoff, 3, 2, false ),
          envBpf = g.mul( bpf, eg ),
          out = g.mul( envBpf, g.mul( gain, loudness, triggerLoudness ) )

    cowbell.env = eg 

    cowbell.isStereo = false

    cowbell = Gibberish.factory( cowbell, out, ['instruments', 'cowbell'], props  )
    
    return cowbell
  }
  
  Cowbell.defaults = {
    gain: 1,
    decay:.5,
    loudness:1,
    __triggerLoudness:1
  }

  return Cowbell

}

},{"./instrument.js":181,"genish.js":51}],179:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {

  const FM = inputProps => {
    let syn = Object.create( instrument )

    let frequency = g.in( 'frequency' ),
        glide = g.max( 1, g.in( 'glide' ) ),
        slidingFreq = g.slide( frequency, glide, glide ),
        cmRatio = g.in( 'cmRatio' ),
        index = g.in( 'index' ),
        feedback = g.in( 'feedback' ),
        attack = g.in( 'attack' ), decay = g.in( 'decay' ),
        sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
        release = g.in( 'release' ),
        loudness = g.in( 'loudness' ),
        triggerLoudness = g.in( '__triggerLoudness' ),
        saturation = g.in( 'saturation' )

    const props = Object.assign( {}, FM.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      syn.advance = ()=> { env.release() }

      const feedbackssd = g.history( 0 )

      const modOsc = Gibberish.oscillators.factory( 
        syn.modulatorWaveform, 
        g.add( g.mul( slidingFreq, cmRatio ), g.mul( feedbackssd.out, feedback, index ) ), 
        syn.antialias 
      )

      {
        'use jsdsp'
        const Loudness = loudness * triggerLoudness
        const modOscWithIndex = modOsc * slidingFreq * index * Loudness
        const modOscWithEnv   = modOscWithIndex * env
        
        const modOscWithEnvAvg =  .5 * ( modOscWithEnv + feedbackssd.out )

        feedbackssd.in( modOscWithEnvAvg )

        const carrierOsc = Gibberish.oscillators.factory( syn.carrierWaveform, g.add( slidingFreq, modOscWithEnvAvg ), syn.antialias )

        // XXX horrible hack below to "use" saturation even when not using a diode filter 
        const carrierOscWithEnv = props.filterModel === 2 ? carrierOsc * env : g.mul(carrierOsc, g.mul(env,saturation) )

        const baseCutoffFreq = g.in( 'cutoff' ) * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * Loudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( carrierOscWithEnv, cutoff, saturation, syn )
        const synthWithGain = filteredOsc * g.in( 'gain' ) * Loudness
        
        let panner
        if( props.panVoices === true ) { 
          panner = g.pan( synthWithGain, synthWithGain, g.in( 'pan' ) ) 
          syn.graph = [panner.left, panner.right ]
          syn.isStereo = true
        }else{
          syn.graph = synthWithGain
          syn.isStereo = false
        }
      }

      syn.env = env

      return env
    }
    
    syn.__requiresRecompilation = [ 'carrierWaveform', 'modulatorWaveform', 'antialias', 'filterModel', 'filterMode' ]
    const env = syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph , ['instruments','FM'], props )

    out.env.advance = out.advance 
    return out
  }

  FM.defaults = {
    carrierWaveform:'sine',
    modulatorWaveform:'sine',
    attack: 44,
    feedback: 0,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .25,
    cmRatio:2,
    index:5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:false,
    panVoices:false,
    glide:1,
    saturation:1,
    filterMult:1.5,
    Q:.25,
    cutoff:.35,
    filterModel:0,
    filterMode:0,
    loudness: 1,
    __triggerLoudness:1

  }

  const PolyFM = Gibberish.PolyTemplate( FM, ['glide','frequency','attack','decay','pulsewidth','pan','gain','cmRatio','index', 'saturation', 'filterMult', 'Q', 'cutoff', 'antialias', 'filterModel', 'carrierWaveform', 'modulatorWaveform','filterMode', 'feedback', 'useADSR', 'sustain', 'release', 'sustainLevel', '__triggerLoudness','loudness' ] ) 
  PolyFM.defaults = FM.defaults

  return [ FM, PolyFM ]

}

},{"./instrument.js":181,"genish.js":51}],180:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  let Hat = argumentProps => {
    let hat = Object.create( instrument ),
        tune  = g.in( 'tune' ),
        scaledTune = g.memo( g.add( .4, tune ) ),
        decay  = g.in( 'decay' ),
        gain  = g.in( 'gain' ),
        loudness = g.in( 'loudness' ),
        triggerLoudness = g.in( '__triggerLoudness' )

    let props = Object.assign( {}, Hat.defaults, argumentProps )

    let baseFreq = g.mul( 325, scaledTune ), // range of 162.5 - 487.5
        bpfCutoff = g.mul( g.param( 'bpfc', 7000 ), scaledTune ),
        hpfCutoff = g.mul( g.param( 'hpfc', 11000 ), scaledTune ),  
        s1 = Gibberish.oscillators.factory( 'square', baseFreq, false ),
        s2 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.4471 ) ),
        s3 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.6170 ) ),
        s4 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.9265 ) ),
        s5 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,2.5028 ) ),
        s6 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,2.6637 ) ),
        sum = g.add( s1,s2,s3,s4,s5,s6 ),
        eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 }), 
        bpf = g.svf( sum, bpfCutoff, .5, 2, false ),
        envBpf = g.mul( bpf, eg ),
        hpf = g.filter24( envBpf, 0, hpfCutoff, 0 ),
        out = g.mul( hpf, g.mul( gain, g.mul( loudness, triggerLoudness ) ) )

    hat.env = eg 
    hat.isStereo = false

    const __hat = Gibberish.factory( hat, out, ['instruments','hat'], props  )
    

    return __hat
  }
  
  Hat.defaults = {
    gain:  .5,
    tune: .6,
    decay:.1,
    loudness:1,
    __triggerLoudness:1
  }

  return Hat

}

},{"./instrument.js":181,"genish.js":51}],181:[function(require,module,exports){
const ugen = require('../ugen.js')();

const instrument = Object.create(ugen);

Object.assign(instrument, {
  type: 'instrument',

  note(freq, loudness = null) {
    // if binop is should be used...
    if (isNaN(this.frequency)) {
      // and if we are assigning binop for the first time...
      let obj = Gibberish.processor.ugens.get(this.frequency.id);
      if (obj === undefined) {
        throw Error(`Incorrect note ${this.frequency} assigned to ${this.ugenName}; this value will be ignored.`);
        return;
      }
      if (obj.isop !== true) {
        obj.inputs[0] = freq;
      } else {
        obj.inputs[1] = freq;
        Gibberish.dirty(this);
      }
      this.frequency = obj;
    } else {
      this.frequency = freq;
    }

    if (loudness !== null) {
      this.__triggerLoudness = loudness;
    }

    this.env.trigger();
  },

  trigger(loudness = 1) {
    if (isNaN(loudness)) {
      throw Error(`A non-number was passed to trigger() on ${this.ugenName}; this value will be ignored and the envelope will not be triggered.`);
    } else {
      this.__triggerLoudness = loudness;
      this.env.trigger();
    }
  }

});

module.exports = instrument

},{"../ugen.js":210}],182:[function(require,module,exports){
module.exports = function( Gibberish ) {

const instruments = {
  Kick        : require( './kick.js' )( Gibberish ),
  Clave       : require( './conga.js' )( Gibberish )[0], // clave is same as conga with different defaults, see below
  Hat         : require( './hat.js' )( Gibberish ),
  Snare       : require( './snare.js' )( Gibberish ),
  Cowbell     : require( './cowbell.js' )( Gibberish ),
  Tom         : require( './tom.js' )( Gibberish ),
  Clap        : require( './clap.dsp.js' )( Gibberish ),
  Multisampler: require( './multisampler.dsp.js' )( Gibberish ),
  Soundfont   : require( './soundfont.js' )( Gibberish )
}

instruments.Clave.defaults.frequency = 2500
instruments.Clave.defaults.decay = .5;

[ instruments.Synth, instruments.PolySynth ]     = require( './synth.dsp.js' )( Gibberish );
[ instruments.Complex, instruments.PolyComplex]  = require( './complex.dsp.js' )( Gibberish );
[ instruments.Monosynth, instruments.PolyMono ]  = require( './monosynth.dsp.js' )( Gibberish );
[ instruments.FM, instruments.PolyFM ]           = require( './fm.dsp.js' )( Gibberish );
[ instruments.Sampler, instruments.PolySampler ] = require( './sampler.js' )( Gibberish );
[ instruments.Karplus, instruments.PolyKarplus ] = require( './karplusstrong.js' )( Gibberish );
[ instruments.Conga, instruments.PolyConga ]     = require( './conga.js' )( Gibberish )

instruments.export = target => {
  for( let key in instruments ) {
    if( key !== 'export' ) {
      target[ key ] = instruments[ key ]
    }
  }
}

return instruments

}

},{"./clap.dsp.js":175,"./complex.dsp.js":176,"./conga.js":177,"./cowbell.js":178,"./fm.dsp.js":179,"./hat.js":180,"./karplusstrong.js":183,"./kick.js":184,"./monosynth.dsp.js":185,"./multisampler.dsp.js":186,"./sampler.js":189,"./snare.js":190,"./soundfont.js":191,"./synth.dsp.js":192,"./tom.js":193}],183:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Karplus = inputProps => {

    const props = Object.assign( {}, Karplus.defaults, inputProps )
    let syn = Object.create( instrument )
    
    let sampleRate = Gibberish.ctx.sampleRate 

    const trigger = g.bang(),
          // high initialValue stops triggering on initialization
          phase = g.accum( 1, trigger, { shouldWrapMax:false, initialValue:1000000 } ),
          env = g.gtp( g.sub( 1, g.div( phase, 200 ) ), 0 ),
          impulse = g.mul( g.noise(), env ),
          feedback = g.history(),
          frequency = g.in('frequency'),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFrequency = g.slide( frequency, glide, glide ),
          delay = g.delay( g.add( impulse, feedback.out ), g.div( sampleRate, slidingFrequency )),
          decayed = g.mul( delay, g.t60( g.mul( g.in('decay'), slidingFrequency ) ) ),
          damped =  g.mix( decayed, feedback.out, g.in('damping') ),
          n = g.noise(),
          blendValue = g.switch( g.gt( n, g.in('blend') ), -1, 1 ), 
          withGain = g.mul( g.mul( blendValue, damped ), g.mul( g.mul( g.in('loudness'), g.in('__triggerLoudness') ), g .in('gain') ) )

    feedback.in( damped )

    const properties = Object.assign( {}, Karplus.defaults, props )

    Object.assign( syn, {
      properties : props,

      env : trigger,
      phase,

      getPhase() {
        return Gibberish.memory.heap[ phase.memory.value.idx ]
      },
    })

    if( properties.panVoices ) {  
      const panner = g.pan( withGain, withGain, g.in( 'pan' ) )
      syn = Gibberish.factory( syn, [panner.left, panner.right], ['instruments','karplus'], props  )
      syn.isStereo = true
    }else{
      syn = Gibberish.factory( syn, withGain, ['instruments','karplus'], props )
      syn.isStereo = false 
    }

    return syn
  }
  
  Karplus.defaults = {
    decay: .97,
    damping:.2,
    gain: .15,
    frequency:220,
    pan: .5,
    glide:1,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    blend:1
  }

  let envCheckFactory = ( syn,synth ) => {
    let envCheck = ()=> {
      let phase = syn.getPhase(),
          endTime = synth.decay * sampleRate

      if( phase > endTime ) {
        synth.disconnectUgen( syn )
        syn.isConnected = false
        Gibberish.memory.heap[ syn.phase.memory.value.idx ] = 0 // trigger doesn't seem to reset for some reason
      }else{
        Gibberish.blockCallbacks.push( envCheck )
      }
    }
    return envCheck
  }

  const PolyKarplus = Gibberish.PolyTemplate( Karplus, ['frequency','decay','damping','pan','gain', 'glide','loudness', '__triggerLoudness'], envCheckFactory ) 
  PolyKarplus.defaults = Karplus.defaults

  return [ Karplus, PolyKarplus ]

}

},{"./instrument.js":181,"genish.js":51}],184:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Kick = inputProps => {
    // establish prototype chain
    const kick = Object.create( instrument )

    // define inputs
    const frequency = g.in( 'frequency' ),
          decay = g.in( 'decay' ),
          tone  = g.in( 'tone' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          Loudness = g.mul( loudness, triggerLoudness )
    
    // create initial property set
    const props = Object.assign( {}, Kick.defaults, inputProps )
    Object.assign( kick, props )

    // create DSP graph
    const trigger = g.bang(),
          impulse = g.mul( trigger, 60 ),
          scaledDecay = g.sub( 1.005, decay ), // -> range { .005, 1.005 }
          scaledTone = g.add( 50, g.mul( tone, g.mul(4000, Loudness ) ) ), // -> range { 50, 4050 }
          bpf = g.svf( impulse, frequency, scaledDecay, 2, false ),
          lpf = g.svf( bpf, scaledTone, .5, 0, false ),
          graph = g.mul( lpf, g.mul( gain, Loudness ) )
    
    kick.env = trigger
    const out = Gibberish.factory( kick, graph, ['instruments','kick'], props  )

    return out
  }
  
  Kick.defaults = {
    gain: 1,
    frequency:85,
    tone: .25,
    decay:.9,
    loudness:1,
    __triggerLoudness:1
  }

  return Kick

}

},{"./instrument.js":181,"genish.js":51}],185:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' ),
      feedbackOsc = require( '../oscillators/fmfeedbackosc.js' )

module.exports = function( Gibberish ) {

  const Mono = argumentProps => {
    const syn = Object.create( instrument ),
          oscs = [], 
          frequency = g.in( 'frequency' ),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.memo( g.slide( frequency, glide, glide ) ),
          attack = g.in( 'attack' ), decay = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          Loudness = g.mul( loudness, triggerLoudness ),
          saturation = g.in( 'saturation' )

    const props = Object.assign( {}, Mono.defaults, argumentProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      for( let i = 0; i < 3; i++ ) {
        let osc, freq

        switch( i ) {
          case 1:
            freq = g.add( slidingFreq, g.mul( slidingFreq, g.in('detune2') ) )
            break;
          case 2:
            freq = g.add( slidingFreq, g.mul( slidingFreq, g.in('detune3') ) )
            break;
          default:
            freq = slidingFreq
        }

        osc = Gibberish.oscillators.factory( syn.waveform, freq, syn.antialias )
        
        oscs[ i ] = osc
      }


      //const baseCutoffFreq = g.in('cutoff') * (frequency /  (g.gen.samplerate / 16 ))
      //const cutoff = baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness ) * env 
      const oscSum = g.add( ...oscs ),
            // XXX horrible hack below to "use" saturation even when not using a diode filter 
            oscWithEnv = props.filterModel=== 2 ? g.mul( oscSum, env ) : g.sub( g.add( g.mul( oscSum, env), saturation ), saturation ),
            baseCutoffFreq = g.mul( g.in('cutoff'), g.div( frequency, g.gen.samplerate / 16 ) ),
            cutoff = g.mul( g.mul( baseCutoffFreq, g.pow( 2, g.mul( g.in('filterMult'), Loudness ) )), env ),
            filteredOsc = Gibberish.filters.factory( oscWithEnv, cutoff, g.in('saturation'), syn )
        
      if( props.panVoices ) {  
        const panner = g.pan( filteredOsc,filteredOsc, g.in( 'pan' ) )
        syn.graph = [ g.mul( panner.left, g.in('gain'), Loudness ), g.mul( panner.right, g.in('gain'), Loudness ) ]
        syn.isStereo = true
      }else{
        syn.graph = g.mul( filteredOsc, g.in('gain'), Loudness )
        syn.isStereo = false
      }

      syn.env = env
    }

    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel', 'filterMode' ]
    syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments','Monosynth'], props )

    return out
  } 
  
  Mono.defaults = {
    waveform: 'saw',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .25,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    detune2:.005,
    detune3:-.005,
    cutoff: .5,
    Q: .25,
    panVoices:false,
    glide: 1,
    antialias:false,
    //filterType: 1,
    filterModel: 1,
    filterMode: 0, // 0 = LP, 1 = HP, 2 = BP, 3 = Notch
    saturation:.5,
    filterMult: 2,
    loudness:1,
    __triggerLoudness:1
  }

  let PolyMono = Gibberish.PolyTemplate( Mono, 
    [ 'frequency','attack','decay','cutoff','Q',
      'detune2','detune3','pulsewidth','pan','gain', 
      'glide', 'saturation', 'filterMult',  'antialias', 
      'filterModel', 'waveform', 'filterMode', 'loudness', '__triggerLoudness' ]
  ) 
  PolyMono.defaults = Mono.defaults

  return [ Mono, PolyMono ]
}

},{"../oscillators/fmfeedbackosc.js":201,"./instrument.js":181,"genish.js":51}],186:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}
  
  Object.assign( proto, {
    pickFile( sample ) {
      this.currentSample = sample
    },
    pick( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
    },
    pickplay( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
      return this.trigger()
    },
    note( rate ) {
      //this.rate = rate
      return this.trigger( null, rate )
    },
    setpan( num=0, value=.5 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.pan.memory.values.idx )
        voice.pan = value
      }
    },
    setrate( num=0, value=1 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.rate.memory.values.idx )
        voice.rate = value
      }
    },
    trigger( volume=null, rate=null ) {
      'no jsdsp'
      if( volume !== null ) this.__triggerLoudness = volume

      let voice = null
      if( Gibberish.mode === 'processor' ) {
        const sampler = this.samplers[ this.currentSample ]

        // if sample isn't loaded...
        if( sampler === undefined ) return

        voice = this.__getVoice__()

        // set voice buffer length
        g.gen.memory.heap[ voice.bufferLength.memory.values.idx ] = sampler.dataLength

        // set voice data index
        g.gen.memory.heap[ voice.bufferLoc.memory.values.idx ] = sampler.dataIdx

        //if( rate !== null ) g.gen.memory.heap[ voice.rate.memory.values.idx ] = rate
        if( rate !== null ) voice.rate = rate
        if( rate > 0 ) {
          voice.trigger()
        }else{
          //console.log( 'reverse?', rate )
          voice.bang.trigger()
          //voice.phase.value = 0
          voice.phase.value = sampler.dataLength - 1
          //console.log( 'phase', voice.phase.value )
        }
        //if( rate < 0 ) {
        //  const phase = sampler.dataIdx + Math.round((sampler.dataLength/2)) - 1
        //  console.log( 'phase:', phase, 'length:', sampler.dataLength, 'start:', sampler.dataIdx )
        //  //voice.phase.value = phase
        //  //g.gen.memory.heap[ voice.phase.memory.value.idx ] = phase
        //}else{
        //  // will reset phase to 0
        //  voice.trigger()
        //}
        
        //voice.trigger()
        //g.gen.memory.heap[ voice.rate.memory.values.idx ] = rate
      }

      return voice
    },
    __getVoice__() {
      return this.voices[ this.voiceCount++ % this.voices.length ]
    },
  })

  const Sampler = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null, voiceCount:0, files:[] }, Sampler.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Multisampler'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    const voices = []
    for( let i = 0; i < syn.maxVoices; i++ ) {
      'use jsdsp'

      const voice = {
        bufferLength: g.data( [1], 1, { meta:true }),
        bufferLoc:    g.data( [1], 1, { meta:true }),
        bang: g.bang(),
        // XXX how do I change this from main thread?
        __pan: g.data( [.5], 1, { meta:true }),
        __rate: g.data( [1], 1, { meta:true }),
        __shouldLoop: g.data( [1], 1, { meta:true }),
        __loudness:  g.data( [1], 1, { meta:true }),
        get loudness() { 
          return g.gen.memory.heap[ this.__loudness.memory.values.idx   ]
        },
        set loudness( v ) {
          g.gen.memory.heap[ this.__loudness.memory.values.idx ] = v
        },
        set pan(v) {
          g.gen.memory.heap[ this.__pan.memory.values.idx ] = v
        },
        set rate(v) {
          g.gen.memory.heap[ this.__rate.memory.values.idx ] = v
        },
      }

      voice.phase = g.counter( 
        rate * voice.__rate[0], 
        start * voice.bufferLength[0],
        end * voice.bufferLength[0], 
        voice.bang,
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )

      voice.trigger = voice.bang.trigger

      voice.graph = g.ifelse(
        // if phase is greater than start and less than end... 
        g.and( 
          g.gte( voice.phase, start * voice.bufferLength[0] ), 
          g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
        ),
        // ...read data
        voice.peek = g.peekDyn( 
          voice.bufferLoc[0], 
          voice.bufferLength[0],
          voice.phase,
          { mode:'samples' }
        ),
        // ...else return 0
        0
      ) 
      * loudness 
      * voice.__loudness[0] 

      const pan = g.pan( voice.graph, voice.graph, voice.__pan[0] )
      voice.graph = [ pan.left, pan.right ]

      voices.push( voice )
    }

    // load in sample data
    const samplers = {}

    // bound to individual sampler objects in loadSample function
    syn.loadBuffer = function( buffer, onload ) {
      // main thread: when sample is loaded, copy it over message port
      // processor thread: onload is called via messageport handler, and
      // passed in the new buffer to be copied.
      if( Gibberish.mode === 'worklet' ) {
        const memIdx = Gibberish.memory.alloc( this.data.buffer.length, true )

        Gibberish.worklet.port.postMessage({
          address:'copy_multi',
          id:     syn.id,
          buffer: this.data.buffer,
          filename: this.filename
        })

        if( typeof onload === 'function' ) onload( this, buffer )

      }else if( Gibberish.mode === 'processor' ) {
        this.data.buffer = buffer 

        // set data memory spec before issuing memory request
        this.dataLength = this.data.memory.values.length = this.data.dim = this.data.buffer.length

        // request memory to copy the bufer over
        g.gen.requestMemory( this.data.memory, false )
        g.gen.memory.heap.set( this.data.buffer, this.data.memory.values.idx )

        // set location of buffer (does not work)
        this.dataIdx = this.data.memory.values.idx

        syn.currentSample = this.filename
      }
    }

    syn.loadSample = function( filename, __onload, buffer=null ) {
      'use jsdsp'

      const sampler = samplers[ filename ] = {
        dataLength: null,
        dataIdx: null,
        buffer: null,
        filename
      }

      const onload = syn.loadBuffer.bind( sampler ) 
      // passing a filename to data will cause it to be loaded in the main thread
      // onload will then be called to pass the buffer over the messageport. In the
      // processor thread, make a placeholder until data is available.
      if( Gibberish.mode === 'worklet' ) {
        sampler.data = g.data( buffer !== null ? buffer : filename, 1, { onload })

        // check to see if a promise is returned; a valid
        // data object is only return if the file has been
        // previously loaded and the corresponding buffer has
        // been cached.
        if( sampler.data instanceof Promise ) {
          sampler.data.then( d => {
            sampler.data = d
            memo[ filename ] = sampler.data 
            onload( sampler, __onload )
          })
        }else{
          // using a cached data buffer, no need
          // for asynchronous loading.
          memo[ filename ] = sampler
          onload( sampler, __onload )
        }     
      }else{
        sampler.data = g.data( new Float32Array(), 1, { onload, filename })
        sampler.data.onload = onload
      } 
    }

    props.files.forEach( filename => syn.loadSample( filename ) )

    syn.__createGraph = function() {
      'use jsdsp'
      
      const graphs = voices.map( voice => voice.graph )
      const left = g.add( ...voices.map( voice => voice.graph[0] ) )
      const right = g.add( ...voices.map( voice => voice.graph[1] ) )
      const gain = g.in( 'gain' )
      syn.graph = [ left * gain, right * gain ]

      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph[0], syn.graph[1], g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    syn.__createGraph()

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','multisampler'], 
      props 
    ) 

    Gibberish.preventProxy = true
    Gibberish.proxyEnabled = false

    out.voices = voices
    out.samplers = samplers

    Gibberish.proxyEnabled = true
    Gibberish.preventProxy = false

    return out
  }

  Sampler.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    shouldLoop:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    maxVoices:5, 
    __triggerLoudness:1
  }

  return Sampler
}

},{"./instrument.js":181,"genish.js":51}],187:[function(require,module,exports){
// XXX TOO MANY GLOBAL GIBBERISH VALUES

const Gibberish = require( '../index.js' )

module.exports = {
  note( freq ) {
    // will be sent to processor node via proxy method...
    if( Gibberish.mode !== 'worklet' ) {
      let voice = this.__getVoice__()
      //Object.assign( voice, this.properties )
      //if( gain === undefined ) gain = this.gain
      //voice.gain = gain
      voice.__triggerLoudness = this.__triggerLoudness
      voice.note( freq, this.__triggerLoudness )
      this.__runVoice__( voice, this )
      this.triggerNote = freq
    }
  },

  // XXX this is not particularly satisfying...
  // must check for both notes and chords
  trigger( loudness ) {
    if( this.triggerChord !== null ) {
      this.triggerChord.forEach( v => {
        let voice = this.__getVoice__()
        Object.assign( voice, this.properties )
        voice.note( v, loudness )
        this.__runVoice__( voice, this )
      })
    }else if( this.triggerNote !== null ) {
      let voice = this.__getVoice__()
      Object.assign( voice, this.properties )
      voice.note( this.triggerNote, loudness )
      this.__runVoice__( voice, this )
    }else{
      let voice = this.__getVoice__()
      Object.assign( voice, this.properties )
      voice.trigger( loudness )
      this.__runVoice__( voice, this )
    }
  },

  __runVoice__( voice, _poly ) {
    if( !voice.isConnected ) {
      voice.connect( _poly )
      voice.isConnected = true
    }

    //let envCheck
    //if( _poly.envCheck === undefined ) {
    //  envCheck = function() {
    //    if( voice.env.isComplete() ) {
    //      _poly.disconnectUgen( voice )
    //      voice.isConnected = false
    //    }else{
    //      Gibberish.blockCallbacks.push( envCheck )
    //    }
    //  }
    //}else{
    //  envCheck = _poly.envCheck( voice, _poly )
    //}

    // XXX uncomment this line to turn on dynamically connecting
    // disconnecting individual voices from graph
    //Gibberish.blockCallbacks.push( envCheck )
  },

  __getVoice__() {
    return this.voices[ this.voiceCount++ % this.voices.length ]
  },

  chord( frequencies ) {
    // will be sent to processor node via proxy method...
    if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
      frequencies.forEach( v => this.note( v ) )
      this.triggerChord = frequencies
    }
  },

  free() {
    for( let child of this.voices ) child.free()
  },

  triggerChord:null,
  triggerNote:null
}

},{"../index.js":174}],188:[function(require,module,exports){
/*
 * This files creates a factory generating polysynth constructors.
 */

const g = require( 'genish.js' )
const __proxy = require( '../workletProxy.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )

  const TemplateFactory = ( ugen, propertyList, _envCheck ) => {

    const Template = props => {
      const properties = Object.assign( {}, { isStereo:true, maxVoices:4 }, props )

      //const synth = properties.isStereo === true ? Object.create( stereoProto ) : Object.create( monoProto )
      const synth = properties.isStereo === true ? Gibberish.Bus2({ __useProxy__:false }) : Gibberish.Bus({ __useProxy__:false }) 

      Object.assign( 
        synth, 

        {
          maxVoices: properties.maxVoices, 
          voiceCount: 0,
          envCheck: _envCheck,
          dirty: true,
          ugenName: 'poly' + ugen.name + '_' + synth.id + '_' + ( properties.isStereo ? 2 : 1 ),
          properties
        },

        Gibberish.mixins.polyinstrument
      )

      properties.panVoices = true//false//properties.isStereo
      synth.callback.ugenName = synth.ugenName

      const storedId = properties.id
      if( properties.id !== undefined ) delete properties.id 

      const voices = []
      for( let i = 0; i < synth.maxVoices; i++ ) {
        properties.id = synth.id +'_'+i
        voices[i] = ugen( properties )
        if( Gibberish.mode === 'processor' )
          voices[i].callback.ugenName = voices[i].ugenName

        voices[i].isConnected = false
        //synth.__voices[i] = proxy( ['instruments', ugen.name], properties, synth.voices[i] )
      }

      let _propertyList 
      if( properties.isStereo === false ) {
        _propertyList = propertyList.slice( 0 )
        const idx =  _propertyList.indexOf( 'pan' )
        if( idx  > -1 ) _propertyList.splice( idx, 1 )
      }

      properties.id = storedId

      TemplateFactory.setupProperties( synth, ugen, properties.isStereo ? propertyList : _propertyList )
      
      const p = proxy( ['instruments', 'Poly'+ugen.name], properties, synth ) 

      // proxy workaround nightmare... if we include the voices when we create
      // the proxy, they wind up being strangely unaddressable. perhaps they
      // are being overwritting in the Processor.ugens map object?
      // manually adding each one seems to work around the problem
      if( Gibberish.mode === 'worklet' ) {
        p.voices = []
        let count = 0
        for( let v of voices ) {
          Gibberish.worklet.port.postMessage({
            address: 'addObjectToProperty',
            object: synth.id,
            name:'voices',
            key:count,
            value:v.id
          })

          p.voices[ count ] = v
          count++
        }
      }

      return p 
    }

    return Template
  }

  TemplateFactory.setupProperties = function( synth, ugen, props ) {
    for( let property of props ) {
      if( property === 'pan' || property === 'id' ) continue
      Object.defineProperty( synth, property, {
        configurable:true,
        get() {
          return synth.properties[ property ] || ugen.defaults[ property ]
        },
        set( v ) {
          synth.properties[ property ] = v
          for( let child of synth.voices ) {
            child[ property ] = v
          }
        }
      })
    }
  }

  return TemplateFactory

}

},{"../workletProxy.js":212,"genish.js":51}],189:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}

  Object.assign( proto, {
    note( rate ) {
      this.rate = rate
      if( rate > 0 ) {
        this.__trigger()
      }else{
        this.__phase__.value = this.end * (this.data.buffer.length - 1)
      }
    },
    trigger( volume ) {
      if( volume !== undefined ) this.gain = volume

      if( Gibberish.mode === 'processor' ) {
        // if we're playing the sample forwards...
        if( Gibberish.memory.heap[ this.__rateStorage__.memory.values.idx ] > 0 ) {
          this.__trigger()
        }else{
          this.__phase__.value = this.end * (this.data.buffer.length - 1)
        }
      }
    },
  })

  const Sampler = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null }, Sampler.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          bufferLength = g.in( 'bufferLength' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Sampler'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    syn.__createGraph = function() {
      syn.__bang__ = g.bang()
      syn.__trigger = syn.__bang__.trigger

      syn.__phase__ = g.counter( 
        rate, 
        g.mul(start,bufferLength), 
        g.mul( end, bufferLength ), 
        syn.__bang__, 
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )
      
      syn.__rateStorage__ = rateStorage
      rateStorage[0] = rate

      // XXX we added our recorded 'rate' param and then effectively subtract it,
      // so that its presence in the graph will force genish to actually record the 
      // rate as the input. this is extremely hacky... there should be a way to record
      // value without having to include it in the graph!
      syn.graph = g.add( g.mul( 
        g.ifelse( 
          g.and( g.gte( syn.__phase__, g.mul(start,bufferLength) ), g.lt( syn.__phase__, g.mul(end,bufferLength) ) ),
          g.peek( 
            syn.data, 
            syn.__phase__,
            { mode:'samples' }
          ),
          0
        ), 
        g.mul( g.mul( loudness, triggerLoudness ), g.in('gain') )
      ), rateStorage[0], g.mul( rateStorage[0], -1 ) )
      
      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph, syn.graph, g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    const onload = (buffer,filename) => {
      if( buffer === undefined ) return
      if( Gibberish.mode === 'worklet' ) {
        //const memIdx = memo[ filename ].idx !== undefined ? memo[ filename ].idx : Gibberish.memory.alloc( syn.data.memory.values.length, true )

        const memIdx = Gibberish.memory.alloc( buffer.length, true )
        //memo[ filename ].idx = memIdx

        Gibberish.worklet.port.postMessage({
          address:'copy',
          id:     syn.id,
          idx:    memIdx,
          buffer
        })

      }else if ( Gibberish.mode === 'processor' ) {
        syn.data.buffer = buffer
        syn.data.memory.values.length = syn.data.dim = buffer.length
        syn.__redoGraph() 
      }

      if( typeof syn.onload === 'function' ){  
        syn.onload( buffer || syn.data.buffer )
      }
      if( syn.bufferLength === -999999999 && syn.data.buffer !== undefined ) syn.bufferLength = syn.data.buffer.length - 1
    }

    //if( props.filename ) {
    syn.loadFile = function( filename ) {
      //if( memo[ filename ] === undefined ) {
        if( Gibberish.mode !== 'processor' ) {
          syn.data = g.data( filename, 1, { onload })


          // check to see if a promise is returned; a valid
          // data object is only return if the file has been
          // previously loaded and the corresponding buffer has
          // been cached.
          if( syn.data instanceof Promise ) {
            syn.data.then( d => {
              syn.data = d
              memo[ filename ] = syn.data
              onload( d.buffer, filename )
            })
          }else{
            // using a cached data buffer, no need
            // for asynchronous loading.
            memo[ filename ] = syn.data
            onload( syn.data.buffer, filename )
          }     
        }else{
          syn.data = g.data( new Float32Array(), 1, { onload, filename })
          //memo[ filename ] = syn.data
        }
      //}else{
      //  syn.data = memo[ filename ]
      //  console.log( 'memo data:', syn.data )
      //  onload( syn.data.buffer, filename )
      //}
    }

    syn.loadBuffer = function( buffer ) {
      if( Gibberish.mode === 'processor' ) {
        syn.data.buffer = buffer
        syn.data.memory.values.length = syn.data.dim = buffer.length
        syn.__redoGraph() 
      }
    }

    if( props.filename !== undefined ) {
      syn.loadFile( props.filename )
    }else{
      syn.data = g.data( new Float32Array() )
    }

    if( syn.data !== undefined ) {
      syn.data.onload = onload

      syn.__createGraph()
    }

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','sampler'], 
      props 
    ) 

    return out
  }

  Sampler.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    __triggerLoudness:1
  }

  const envCheckFactory = function( voice, _poly ) {
    const envCheck = () => {
      const phase = Gibberish.memory.heap[ voice.__phase__.memory.value.idx ]
      if( ( voice.rate > 0 && phase > voice.end ) || ( voice.rate < 0 && phase < 0 ) ) {
        _poly.disconnectUgen.call( _poly, voice )
        voice.isConnected = false
      }else{
        Gibberish.blockCallbacks.push( envCheck )
      }
    }

    return envCheck
  }

  const PolySampler = Gibberish.PolyTemplate( Sampler, ['rate','pan','gain','start','end','loops','bufferLength','__triggerLoudness','loudness'], envCheckFactory ) 

  return [ Sampler, PolySampler ]
}


},{"./instrument.js":181,"genish.js":51}],190:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )
  
module.exports = function( Gibberish ) {

  const Snare = argumentProps => {
    const snare = Object.create( instrument ),
          decay = g.in( 'decay' ),
          scaledDecay = g.mul( decay, g.gen.samplerate * 2 ),
          snappy= g.in( 'snappy' ),
          tune  = g.in( 'tune' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in('__triggerLoudness'),
          Loudness = g.mul( loudness, triggerLoudness ),
          eg = g.decay( scaledDecay, { initValue:0 } ), 
          check = g.memo( g.gt( eg, .0005 ) ),
          rnd = g.mul( g.noise(), eg ),
          hpf = g.svf( rnd, g.add( 1000, g.mul( g.add( 1, tune), 1000 ) ), .5, 1, false ),
          snap = g.mul( g.gtp( g.mul( hpf, snappy ), 0 ), Loudness ), // rectify
          bpf1 = g.svf( eg, g.mul( 180, g.add( tune, 1 ) ), .05, 2, false ),
          bpf2 = g.svf( eg, g.mul( 330, g.add( tune, 1 ) ), .05, 2, false ),
          out  = g.memo( g.add( snap, bpf1, g.mul( bpf2, .8 ) ) ), //XXX why is memo needed?
          scaledOut = g.mul( out, g.mul( gain, Loudness ) ),
          ife = g.switch( check, scaledOut, 0 ),
          props = Object.assign( {}, Snare.defaults, argumentProps )

    // XXX TODO : make above switch work with ifelse. the problem is that poke ugens put their
    // code at the bottom of the callback function, instead of at the end of the
    // associated if/else block.
    
    snare.env = eg 
    const __snare = Gibberish.factory( snare, ife, ['instruments','snare'], props  )
    
    return __snare
  }
  
  Snare.defaults = {
    gain: .5,
    tune:0,
    snappy: 1,
    decay:.1,
    loudness:1,
    __triggerLoudness:1
  }

  return Snare

}

},{"./instrument.js":181,"genish.js":51}],191:[function(require,module,exports){
/*fetch( '0000_Aspirin_sf2_file.json' )
.then( res => res.json() )
.then( json => {
  window.zones = json.zones
  console.log( window.zones )
})

ab = Gibberish.utilities..decodeArrayBuffer( zones[0].file )
genish.utilities.ctx.decodeAudioData( ab, buffer => {
  __ab = buffer
  console.log( 'buffer made' )
})


_d = data( __ab )
play( peek( _d, phasor(1,0,{min:0}) ) )
*/

const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

const soundfonts = {}

const banks = [
  'Aspirin',
  'Chaos',
  'FluidR3',
  'GeneralUserGS',
  'JCLive'
]

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}
  
  Object.assign( proto, {
    pickFile( sample ) {
      this.currentSample = sample
    },
    pick( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
    },
    pickplay( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
      return this.trigger()
    },
    __note( rate, loudness=null ) {
      // soundfont measures pitch in cents
      // originalPitch = findMidiForHz( hz ) * 100 // (100 cents per midi index)
      // rate = Math.pow(2, (100.0 * pitch - originalPitch) / 1200.0) // 1200 cents per octave
      return this.trigger( loudness, rate )
    },
    note( freq, loudness=null ) {
      'no jsdsp'
      const midinote = 69 + 12 * Math.log2( freq/440 )
      this.midinote( midinote, loudness )
    },
    midipick( midinote, loudness ) {
      // loop through zones to find correct sample #
      let idx = 0, pitch = 0
      for( let zone of this.zones ) {
        if( midinote >= zone.keyRangeLow && midinote <= zone.keyRangeHigh ) {
          pitch = zone.originalPitch
          break;
        }
        idx++
      }
      this.pick( idx )
      return pitch
    },
    midinote( midinote, loudness=null ) {
      'no jsdsp'
      const samplePitch = this.midipick( midinote )
      const pitch = Math.pow( 2, (100 * midinote - samplePitch ) / 1200 ) 
      //const pitch = 1//Math.pow( 2, (samplePitch ) ) 
      this.__note( pitch, loudness )
    }, 
    midichord( frequencies ) {
      if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
        frequencies.forEach( v => this.midinote( v ) )
        this.triggerChord = frequencies
      }
    },
    chord( frequencies ) {
      if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
        frequencies.forEach( v => this.note( v ) )
        this.triggerChord = frequencies
      }
    },

    setpan( num=0, value=.5 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.pan.memory.values.idx )
        voice.pan = value
      }
    },
    setrate( num=0, value=1 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.rate.memory.values.idx )
        voice.rate = value
      }
    },
    trigger( volume=null, rate=null ) {
      'no jsdsp'
      //if( volume !== null ) this.__triggerLoudness = volume

      let voice = null
      if( Gibberish.mode === 'processor' ) {
        const sampler = this.samplers[ this.currentSample ]

        // if sample isn't loaded...
        if( sampler === undefined ) return

        voice = this.__getVoice__()

        // set voice buffer length
        g.gen.memory.heap[ voice.bufferLength.memory.values.idx ] = sampler.dataLength

        // set voice data index
        g.gen.memory.heap[ voice.bufferLoc.memory.values.idx ] = sampler.dataIdx

        g.gen.memory.heap[ voice.__loopStart.memory.values.idx ] = sampler.zone.loopStart
        g.gen.memory.heap[ voice.__loopEnd.memory.values.idx   ] = sampler.zone.loopEnd

        if( volume !== null )
          g.gen.memory.heap[ voice.loudness.memory.values.idx   ] = volume

        if( rate !== null ) voice.rate = rate 
        
        voice.trigger()
      }

      return voice
    },
    __getVoice__() {
      return this.voices[ this.voiceCount++ % this.voices.length ]
    },
  })

  const Soundfont = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null, voiceCount:0, files:[] }, Soundfont.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Soundfont'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    // create all our vocecs
    const voices = []
    for( let i = 0; i < syn.maxVoices; i++ ) {
      'use jsdsp'

      const voice = {
        bufferLength: g.data( [1], 1, { meta:true }),
        bufferLoc:    g.data( [1], 1, { meta:true }),
        bang: g.bang(),
        // XXX how do I change this from main thread?
        __pan: g.data( [.5], 1, { meta:true }),
        __rate: g.data( [1], 1, { meta:true }),
        __shouldLoop: g.data( [1], 1, { meta:true }),
        __loopStart: g.data( [1], 1, { meta:true }),
        __loopEnd:   g.data( [1], 1, { meta:true }),
        __loudness:  g.data( [1], 1, { meta:true }),
        get loudness() { 
          return g.gen.memory.heap[ this.__loudness.memory.values.idx   ]
        },
        set loudness( v ) {
          g.gen.memory.heap[ this.__loudness.memory.values.idx ] = v
        },
        set pan(v) {
          g.gen.memory.heap[ this.__pan.memory.values.idx ] = v
        },
        set rate(v) {
          g.gen.memory.heap[ this.__rate.memory.values.idx ] = v
        },
      }

      voice.phase = g.counter( 
        rate * voice.__rate[0], 
        start * voice.bufferLength[0],
        end * voice.bufferLength[0], 
        voice.bang,
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )

      voice.trigger = voice.bang.trigger

      voice.graph = g.ifelse(
        // if phase is greater than start and less than end... 
        g.and( 
          g.gte( voice.phase, start * voice.bufferLength[0] ), 
          g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
        ),
        // ...read data
        voice.peek = g.peekDyn( 
          voice.bufferLoc[0], 
          voice.bufferLength[0],
          voice.phase,
          { mode:'samples' }
        ),
        // ...else return 0
        0
      ) 
      * loudness 
      * voice.__loudness[0] 

      // start of attempt to loop sustain...
      //voice.graph = g.ifelse(
      //  // if phase is greater than start and less than end... 
      //  g.and( 
      //    g.gte( voice.phase, start * voice.bufferLength[0] ), 
      //    g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
      //  ),
      //  // ...read data
      //  voice.peek = g.peekDyn( 
      //    voice.bufferLoc[0], 
      //    voice.bufferLength[0],
      //    voice.phase,
      //    { mode:'samples' }
      //  ),
      //  // ...else return 0
      //  g.ifelse(
      //    g.and(
      //      voice.__shouldLoop[0],
      //      g.gt( voice.phase, voice.__loopEnd[0] )
      //    ),
      //    g.peekDyn( 
      //      voice.bufferLoc[0], 
      //      voice.bufferLength[0],
      //      g.add( 
      //        voice.__loopStart[0],
      //        g.mod(
      //          voice.phase,
      //          //g.sub( voice.phase, voice.__loopStart[0] ),
      //          g.sub( voice.__loopEnd[0], voice.__loopStart[0] )
      //        )
      //      ),
      //      { mode:'samples' }
      //    ),
      //    0
      //  )
      //) 
      //* loudness 
      //* triggerLoudness 
      
      const pan = g.pan( voice.graph, voice.graph, voice.__pan[0] )
      voice.graph = [ pan.left, pan.right ]

      voices.push( voice )
    }

    // load in sample data
    const samplers = {}

    // bound to individual sampler objects in loadSample function
    syn.loadBuffer = function( buffer, onload ) {
      // main thread: when sample is loaded, copy it over message port
      // processor thread: onload is called via messageport handler, and
      // passed in the new buffer to be copied.
      if( Gibberish.mode === 'worklet' ) {
        const memIdx = Gibberish.memory.alloc( this.data.buffer.length, true )

        Gibberish.worklet.port.postMessage({
          address:'copy_multi',
          id:     syn.id,
          buffer: this.data.buffer,
          filename: this.filename
        })

        if( typeof onload === 'function' ) onload( this, buffer )

      }else if( Gibberish.mode === 'processor' ) {
        this.data.buffer = buffer 

        // set data memory spec before issuing memory request
        this.dataLength = this.data.memory.values.length = this.data.dim = this.data.buffer.length
        this.zone = syn.zones[ this.filename ]

        // request memory to copy the bufer over
        g.gen.requestMemory( this.data.memory, false )
        g.gen.memory.heap.set( this.data.buffer, this.data.memory.values.idx )

        // set location of buffer (does not work)
        this.dataIdx = this.data.memory.values.idx

        syn.currentSample = this.filename
      }
    }

    syn.loadSample = function( filename, __onload, buffer=null ) {
      'use jsdsp'

      const sampler = samplers[ filename ] = {
        dataLength: null,
        dataIdx: null,
        buffer: null,
        filename
      }

      const onload = syn.loadBuffer.bind( sampler ) 
      // passing a filename to data will cause it to be loaded in the main thread
      // onload will then be called to pass the buffer over the messageport. In the
      // processor thread, make a placeholder until data is available.
      if( Gibberish.mode === 'worklet' ) {
        sampler.data = g.data( buffer !== null ? buffer : filename, 1, { onload })

        // check to see if a promise is returned; a valid
        // data object is only return if the file has been
        // previously loaded and the corresponding buffer has
        // been cached.
        if( sampler.data instanceof Promise ) {
          sampler.data.then( d => {
            sampler.data = d
            memo[ filename ] = sampler.data 
            onload( sampler, __onload )
          })
        }else{
          // using a cached data buffer, no need
          // for asynchronous loading.
          memo[ filename ] = sampler
          sampler.dataLength = buffer.length
          onload( sampler, __onload )
        }     
      }else{
        // not sure if first case will happen with soundfonts (it does with regular multisampler)
        if( buffer === null ) {
          sampler.data = g.data( new Float32Array(), 1, { onload, filename })
          sampler.data.onload = onload
        }else{
          sampler.data = g.data( buffer, 1, { onload, filename })
          //sampler.data.onload = onload
          onload( buffer, __onload )
        }
      }

      return sampler
    }

    syn.load = function( soundNumber=0, bankIndex=0 ) {
      'no jsdsp'

      // need to memoize... already storing in soundfonts
      if( Gibberish.mode === 'processor' ) return

      // in case users pass name of soundfont instead of number
      if( typeof soundNumber === 'string' ) {
        let __soundNumber = Soundfont.names.indexOf( soundNumber )
        if( __soundNumber === -1 ) {
          __soundNumber = 0
          console.warn( `The ${soundNumber} Soundfont can't be found. Using Piano instead.` )
        }
        soundNumber = __soundNumber
      }

      let num = (soundNumber) + '0'
      if( soundNumber < 100 ) num = '0'+num
      if( soundNumber < 10 )  num = '0'+num

      fetch( `${Soundfont.resourcePath}${num}_${banks[bankIndex]}.sf2.json` )
        .then( res => res.json() )
        .then( json => {
          const zones = soundfonts[ soundNumber ] = json.zones
          this.zones = zones
          for( let i = 0; i < zones.length; i++) {
            const zone = zones[i]
            const ab = Gibberish.utilities.base64.decodeArrayBuffer( zone.file )
            g.utilities.ctx.decodeAudioData( ab, buffer => {
              zone.sampler = syn.loadSample( i, null, buffer )
            })
          }
        })
    }

    //props.files.forEach( filename => syn.loadSample( filename ) )

    syn.__createGraph = function() {
      'use jsdsp'
      
      const graphs = voices.map( voice => voice.graph )
      const left = g.add( ...voices.map( voice => voice.graph[0] ) )
      const right = g.add( ...voices.map( voice => voice.graph[1] ) )
      const gain = g.in( 'gain' )
      syn.graph = [ left * gain, right * gain ]

      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph[0], syn.graph[1], g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    syn.__createGraph()

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','soundfont'], 
      props 
    ) 

    Gibberish.preventProxy = true
    Gibberish.proxyEnabled = false

    out.voices = voices
    out.samplers = samplers

    Gibberish.proxyEnabled = true
    Gibberish.preventProxy = false

    return out
  }

  Soundfont.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    shouldLoop:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    maxVoices:5, 
    __triggerLoudness:1
  }

  Soundfont.resourcePath = 'resources/soundfonts/'
  Soundfont.names = [
    "Acoustic Grand Piano",
    "Bright Acoustic Piano",
    "Electric Grand Piano",
    "Honky-tonk Piano",
    "Electric Piano 1",
    "Electric Piano 2",
    "Harpsichord",
    "Clavi",
    "Celesta",
    "Glockenspiel",
    "Music Box",
    "Vibraphone",
    "Marimba",
    "Xylophone",
    "Tubular Bells",
    "Dulcimer",
    "Drawbar Organ",
    "Percussive Organ",
    "Rock Organ",
    "Church Organ",
    "Reed Organ",
    "Accordion",
    "Harmonica",
    "Tango Accordion",
    "Acoustic Guitar (nylon)",
    "Acoustic Guitar (steel)",
    "Electric Guitar (jazz)",
    "Electric Guitar (clean)",
    "Electric Guitar (muted)",
    "Overdriven Guitar",
    "Distortion Guitar",
    "Guitar harmonics",
    "Acoustic Bass",
    "Electric Bass (finger)",
    "Electric Bass (pick)",
    "Fretless Bass",
    "Slap Bass 1",
    "Slap Bass 2",
    "Synth Bass 1",
    "Synth Bass 2",
    "Violin",
    "Viola",
    "Cello",
    "Contrabass",
    "Tremolo Strings",
    "Pizzicato Strings",
    "Orchestral Harp",
    "Timpani",
    "String Ensemble 1",
    "String Ensemble 2",
    "SynthStrings 1",
    "SynthStrings 2",
    "Choir Aahs",
    "Voice Oohs",
    "Synth Voice",
    "Orchestra Hit",
    "Trumpet",
    "Trombone",
    "Tuba",
    "Muted Trumpet",
    "French Horn",
    "Brass Section",
    "SynthBrass 1",
    "SynthBrass 2",
    "Soprano Sax",
    "Alto Sax",
    "Tenor Sax",
    "Baritone Sax",
    "Oboe",
    "English Horn",
    "Bassoon",
    "Clarinet",
    "Piccolo",
    "Flute",
    "Recorder",
    "Pan Flute",
    "Blown Bottle",
    "Shakuhachi",
    "Whistle",
    "Ocarina",
    "Lead 1 (square)",
    "Lead 2 (sawtooth)",
    "Lead 3 (calliope)",
    "Lead 4 (chiff)",
    "Lead 5 (charang)",
    "Lead 6 (voice)",
    "Lead 7 (fifths)",
    "Lead 8 (bass + lead)",
    "Pad 1 (new age)",
    "Pad 2 (warm)",
    "Pad 3 (polysynth)",
    "Pad 4 (choir)",
    "Pad 5 (bowed)",
    "Pad 6 (metallic)",
    "Pad 7 (halo)",
    "Pad 8 (sweep)",
    "FX 1 (rain)",
    "FX 2 (soundtrack)",
    "FX 3 (crystal)",
    "FX 4 (atmosphere)",
    "FX 5 (brightness)",
    "FX 6 (goblins)",
    "FX 7 (echoes)",
    "FX 8 (sci-fi)",
    "Sitar",
    "Banjo",
    "Shamisen",
    "Koto",
    "Kalimba",
    "Bag pipe",
    "Fiddle",
    "Shanai",
    "Tinkle Bell",
    "Agogo",
    "Steel Drums",
    "Woodblock",
    "Taiko Drum",
    "Melodic Tom",
    "Synth Drum",
    "Reverse Cymbal",
    "Guitar Fret Noise",
    "Breath Noise",
    "Seashore",
    "Bird Tweet",
    "Telephone Ring",
    "Helicopter",
    "Applause",
    "Gunshot"
  ]

  Soundfont.inspect = function() {
    console.table( Soundfont.names )
  }

  return Soundfont
}

},{"./instrument.js":181,"genish.js":51}],192:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {

  const Synth = inputProps => {
    const syn = Object.create( instrument )

    const frequency = g.in( 'frequency' ),
          loudness  = g.in( 'loudness' ), 
          triggerLoudness = g.in( '__triggerLoudness' ),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.slide( frequency, glide, glide ),
          attack = g.in( 'attack' ), decay = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' )

    const props = Object.assign( {}, Synth.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const osc = Gibberish.oscillators.factory( syn.waveform, slidingFreq, syn.antialias )

      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )


      // syn.env = env
      // below doesn't work as it attempts to assign to release property triggering codegen...
      syn.advance = ()=> { env.release() }

      {
        'use jsdsp'
        let oscWithEnv = osc * env * loudness * triggerLoudness,
            saturation = g.in('saturation'),
            panner

        // 16 is an unfortunate empirically derived magic number...
        const baseCutoffFreq = g.in('cutoff') * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness * triggerLoudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( oscWithEnv, cutoff, saturation, props )

        let synthWithGain = filteredOsc * g.in( 'gain' )
        
        // XXX This line has to be here for correct code generation to work when
        // saturation is not being used... obviously this should cancel out. 
        if( syn.filterModel !== 2 ) synthWithGain = synthWithGain + saturation - saturation
    
        if( syn.panVoices === true ) { 
          panner = g.pan( synthWithGain, synthWithGain, g.in( 'pan' ) ) 
          syn.graph = [ panner.left, panner.right ]
          syn.isStereo = true
        }else{
          syn.graph = synthWithGain
          syn.isStereo = false
        }

        syn.env = env
        syn.osc = osc
        syn.filter = filteredOsc
      }

      return env

    }
    
    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel','filterMode', 'useADSR', 'shape' ]
    const env = syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments', 'synth'], props, null, true, ['saturation']  )

    out.env.advance = out.advance 

    return out
  }
  
  Synth.defaults = {
    waveform:'saw',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:false,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    glide:1,
    saturation:1,
    filterMult:2,
    Q:.25,
    cutoff:.5,
    filterModel:1,
    filterMode:0
  }

  // do not include velocity, which shoudl always be per voice
  let PolySynth = Gibberish.PolyTemplate( Synth, ['frequency','attack','decay','pulsewidth','pan','gain','glide', 'saturation', 'filterMult', 'Q', 'cutoff', 'resonance', 'antialias', 'filterModel', 'waveform', 'filterMode', '__triggerLoudness', 'loudness'] ) 
  PolySynth.defaults = Synth.defaults

  return [ Synth, PolySynth ]

}

},{"./instrument.js":181,"genish.js":51}],193:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Tom = argumentProps => {
    let tom = Object.create( instrument )
    
    const decay   = g.in( 'decay' ),
          pitch   = g.in( 'frequency' ),
          gain    = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Tom.defaults, argumentProps )

    const trigger = g.bang(),
          impulse = g.mul( trigger, 1 ),
          eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 } ), 
          bpf = g.mul( g.svf( impulse, pitch, .0175, 2, false ), 10 ),
          noise = g.gtp( g.noise(), 0 ), // rectify noise
          envelopedNoise = g.mul( noise, eg ),
          lpf = g.mul( g.svf( envelopedNoise, 120, .5, 0, false ), 2.5 ),
          out = g.mul( g.add( bpf, lpf ), g.mul( gain, g.mul( loudness, triggerLoudness ) ) )

    tom.env = {
      trigger: function() {
        eg.trigger()
        trigger.trigger()
      }
    }

    tom.isStereo = false

    tom = Gibberish.factory( tom, out, ['instruments', 'tom'], props  )
    
    return tom
  }
  
  Tom.defaults = {
    gain: 1,
    decay:.7,
    frequency:120,
    loudness:1,
    __triggerLoudness:1
  }

  return Tom
}

},{"./instrument.js":181,"genish.js":51}],194:[function(require,module,exports){
const ugenproto = require( '../ugen.js' )(),
     __proxy     = require( '../workletProxy.js' ),
     g = require( 'genish.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )

  const createProperties = function( p, id ) {
    for( let i = 0; i < 2; i++ ) {
      Object.defineProperty( p, i, {
        configurable:true,
        get() { return p.inputs[ i ] },
        set(v) {
          p.inputs[ i ] = v
          if( Gibberish.mode === 'worklet' ) {
            if( typeof v === 'number' ) {
              Gibberish.worklet.port.postMessage({ 
                address:'addToProperty', 
                object:id,
                name:'inputs',
                key:i,
                value:v
              })
            }else{
              Gibberish.worklet.port.postMessage({ 
                address:'addObjectToProperty', 
                object:id,
                name:'inputs',
                key:i,
                value:v.id
              })
            }
            Gibberish.worklet.port.postMessage({
              address:'dirty',
              id
            })
          }
        }
      })
    }
  }

  const Binops = {
    export( obj ) {
      for( let key in Binops ) {
        if( key !== 'export' ) {
          obj[ key ] = Binops[ key ]
        }
      }
    },
    
    Add( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'+', inputs:args, ugenName:'add' + id, id, isStereo } )
      
      const p = proxy( ['binops','Add'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },

    Sub( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'-', inputs:args, ugenName:'sub' + id, id, isStereo } )

      return proxy( ['binops','Sub'], { isop:true, inputs:args }, ugen )
    },

    Mul( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'*', inputs:args, ugenName:'mul' + id, id, isStereo } )

      const p = proxy( ['binops','Mul'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )
      return p
    },

    Div( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'/', inputs:args, ugenName:'div' + id, id, isStereo} )
    
      const p = proxy( ['binops','Div'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },

    Mod( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'%', inputs:args, ugenName:'mod' + id, id, isStereo} )

      const p = proxy( ['binops','Mod'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },   
  }

  for( let key in Binops ) {
    Binops[ key ].defaults = { 0:0, 1:0 }
  }

  return Binops
}

},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],195:[function(require,module,exports){
let g = require( 'genish.js' ),
    ugen = require( '../ugen.js' )(),
    __proxy= require( '../workletProxy.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )
  const Bus = Object.create( ugen )

  Object.assign( Bus, {
    gain: {
      set( v ) {
        this.mul.inputs[ 1 ] = v
        Gibberish.dirty( this )
      },
      get() {
        return this.mul[ 1 ]
      }
    },

    __addInput( input ) {
      this.sum.inputs.push( input )
      Gibberish.dirty( this )
    },

    create( _props ) {
      const props = Object.assign({}, Bus.defaults, { inputs:[0] }, _props )

      // MUST PREVENT PROXY
      // Othherwise these binops are created in the worklet and sent
      // across the thread to be instantiated, and then instantiated again
      // when the bus is created in the processor thread, messing up the various
      // uids involved. By preventing proxying the binops are only created
      // a single time when the bus is sent across the thread.
      Gibberish.preventProxy = true
      const sum = Gibberish.binops.Add( ...props.inputs )
      const mul = Gibberish.binops.Mul( sum, props.gain )
      Gibberish.preventProxy = false

      const graph = Gibberish.Panner({ input:mul, pan: props.pan })

      graph.sum = sum
      graph.mul = mul
      graph.disconnectUgen = Bus.disconnectUgen

      graph.__properties__ = props

      const out = props.__useProxy__ === true ? proxy( ['Bus'], props, graph ) : graph

      Object.defineProperty( out, 'gain', Bus.gain )

      if( false && Gibberish.preventProxy === false && Gibberish.mode === 'worklet' ) {
        const meta = {
          address:'add',
          name:['Bus'],
          props, 
          id:graph.id
        }
        Gibberish.worklet.port.postMessage( meta )
        Gibberish.worklet.port.postMessage({ 
          address:'method', 
          object:graph.id,
          name:'connect',
          args:[]
        })
      }

      return out 
    },

    disconnectUgen( ugen ) {
      let removeIdx = this.sum.inputs.indexOf( ugen )

      if( removeIdx !== -1 ) {
        this.sum.inputs.splice( removeIdx, 1 )
        Gibberish.dirty( this )
      }
    },

    // can't include inputs here as it will be sucked up by Gibber,
    // instead pass during Object.assign() after defaults.
    defaults: { gain:1, pan:.5, __useProxy__:true }
  })

  const constructor = Bus.create.bind( Bus )
  constructor.defaults = Bus.defaults

  return constructor
}


},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],196:[function(require,module,exports){
const g = require( 'genish.js' ),
      ugen = require( '../ugen.js' )(),
      __proxy = require( '../workletProxy.js' )


module.exports = function( Gibberish ) {
  const Bus2 = Object.create( ugen )
  const proxy = __proxy( Gibberish )

  let bufferL, bufferR
  
  Object.assign( Bus2, { 
    create( __props ) {

      if( bufferL === undefined ) {
        const p = g.pan()
        
        // copy memory... otherwise the wavetables don't have memory indices.
        bufferL = Gibberish.memory.alloc(1024)
        Gibberish.memory.heap.set( Gibberish.genish.gen.globals.panL.buffer, bufferL )

        bufferR = Gibberish.memory.alloc(1024)
        Gibberish.memory.heap.set( Gibberish.genish.gen.globals.panR.buffer, bufferR )
      }

      // XXX must be same type as what is returned by genish for type checks to work correctly
      const output = new Float64Array( 2 ) 

      const bus = Object.create( Bus2 )

      let init = false

      const props = Object.assign({}, Bus2.defaults, __props )

      Object.assign( 
        bus,

        {
          callback() {
            output[ 0 ] = output[ 1 ] = 0
            const lastIdx = arguments.length - 1
            const memory  = arguments[ lastIdx ]
            let pan  = arguments[ lastIdx - 1 ]
            const gain = arguments[ lastIdx - 2 ]

            for( let i = 0; i < lastIdx - 2; i+= 3 ) {
              const input = arguments[ i ],
                    level = arguments[ i + 1 ],
                    isStereo = arguments[ i + 2 ]

              output[ 0 ] += isStereo === true ? input[ 0 ] * level : input * level

              output[ 1 ] += isStereo === true ? input[ 1 ] * level : input * level
            }

            if( pan < 0 ) {
              pan = 0
            }else if( pan > 1 ){
              pan = 1
            }

            const panRawIndex  = pan * 1023,
                  panBaseIndex = panRawIndex | 0,
                  panNextIndex = (panBaseIndex + 1) & 1023,
                  interpAmount = panRawIndex - panBaseIndex,
                  panL = memory[ bufferL + panBaseIndex ] 
                    + ( interpAmount * ( memory[ bufferL + panNextIndex ] - memory[ bufferL + panBaseIndex ] ) ),
                  panR = memory[ bufferR + panBaseIndex ] 
                    + ( interpAmount * ( memory[ bufferR + panNextIndex ] - memory[ bufferR + panBaseIndex ] ) )
            
            output[0] *= gain * panL
            output[1] *= gain * panR

            return output
          },
          id : Gibberish.factory.getUID(),
          dirty : false,
          type : 'bus',
          inputs:[ 1, .5 ],
          isStereo: true,
          __properties__:props
        },

        Bus2.defaults,

        props
      )

      bus.ugenName = bus.callback.ugenName = 'bus2_' + bus.id

      const out = bus.__useProxy__ === true ? proxy( ['Bus2'], props, bus ) : bus


      // we have to include custom properties for these as the argument list for
      // the compiled output function is variable
      // so codegen can't know the correct argument order for the function
      let pan = .5
      Object.defineProperty( out, 'pan', {
        get() { return pan },
        set(v){ 
          pan = v
          out.inputs[ out.inputs.length - 1 ] = pan
          Gibberish.dirty( out )
        }
      })

      let gain = 1
      Object.defineProperty( out, 'gain', {
        get() { return gain },
        set(v){ 
          gain = v
          out.inputs[ out.inputs.length - 2 ] = gain
          Gibberish.dirty( out )
        }
      })

      return out
    },
    
    disconnectUgen( ugen ) {
      let removeIdx = this.inputs.indexOf( ugen )

      if( removeIdx !== -1 ) {
        this.inputs.splice( removeIdx, 3 )
        Gibberish.dirty( this )
      }
    },

    defaults: { gain:1, pan:.5, __useProxy__:true }
  })

  const constructor = Bus2.create.bind( Bus2 )
  constructor.defaults = Bus2.defaults

  return constructor

}

},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],197:[function(require,module,exports){
const  g    = require( 'genish.js'  ),
       ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {

  const Monops = {
    export( obj ) {
      for( let key in Monops ) {
        if( key !== 'export' ) {
          obj[ key ] = Monops[ key ]
        }
      }
    },
    
    Abs( input ) {
      const abs = Object.create( ugen )
      const graph = g.abs( g.in('input') )
      
      const __out = Gibberish.factory( abs, graph, ['monops','abs'], Object.assign({}, Monops.defaults, { inputs:[input], isop:true }) )

      return __out
    },

    Pow( input, exponent ) {
      const pow = Object.create( ugen )
      const graph = g.pow( g.in('input'), g.in('exponent') )
      
      Gibberish.factory( pow, graph, ['monops','pow'], Object.assign({}, Monops.defaults, { inputs:[input], exponent, isop:true }) )

      return pow
    },
    Clamp( input, min, max ) {
      const clamp = Object.create( ugen )
      const graph = g.clamp( g.in('input'), g.in('min'), g.in('max') )
      
      const __out = Gibberish.factory( clamp, graph, ['monops','clamp'], Object.assign({}, Monops.defaults, { inputs:[input], isop:true, min, max }) )

      return __out
    },

    Merge( input ) {
      const merger = Object.create( ugen )
      const cb = function( _input ) {
        return _input[0] + _input[1]
      }

      Gibberish.factory( merger, g.in( 'input' ), ['monops','merge'], { inputs:[input], isop:true }, cb )
      merger.type = 'analysis'
      merger.inputNames = [ 'input' ]
      merger.inputs = [ input ]
      merger.input = input
      
      return merger
    },
  }

  Monops.defaults = { input:0 }

  return Monops
}

},{"../ugen.js":210,"genish.js":51}],198:[function(require,module,exports){
const g = require( 'genish.js' )

const ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {
 
let Panner = inputProps => {
  const props  = Object.assign( {}, Panner.defaults, inputProps ),
        panner = Object.create( ugen )

  const isStereo = props.input.isStereo !== undefined ? props.input.isStereo : Array.isArray( props.input ) 
  
  const input = g.in( 'input' ),
        pan   = g.in( 'pan' )

  let graph 
  if( isStereo ) {
    graph = g.pan( input[0], input[1], pan )  
  }else{
    graph = g.pan( input, input, pan )
  }

  Gibberish.factory( panner, [ graph.left, graph.right], ['panner'], props )
  
  return panner
}

Panner.defaults = {
  input:0,
  pan:.5
}

return Panner 

}

},{"../ugen.js":210,"genish.js":51}],199:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const Time = {
    bpm: 120,

    export: function(target) {
      Object.assign( target, Time )
    },

    ms : function(val) {
      return val * Gibberish.ctx.sampleRate / 1000;
    },

    seconds : function(val) {
      return val * Gibberish.ctx.sampleRate;
    },

    beats : function(val) {
      return function() { 
        var samplesPerBeat = Gibberish.ctx.sampleRate / ( Gibberish.Time.bpm / 60 ) ;
        return samplesPerBeat * val ;
      }
    }
  }

  return Time
}

},{}],200:[function(require,module,exports){
const genish = require( 'genish.js' ),
      ssd = genish.history,
      noise = genish.noise

module.exports = function() {
  "use jsdsp"

  const last = ssd( 0 )

  const white = ( noise() * 2 ) - 1

  let out = (last.out + (.02 * white)) / 1.02

  last.in( out )

  out *= 3.5
   
  return out
}

},{"genish.js":51}],201:[function(require,module,exports){
let g = require( 'genish.js' )

let feedbackOsc = function( frequency, filter, pulsewidth=.5, argumentProps ) {
  if( argumentProps === undefined ) argumentProps = { type: 0 }

  let lastSample = g.history(),
      // determine phase increment and memoize result
      w = g.memo( g.div( frequency, g.gen.samplerate ) ),
      // create scaling factor
      n = g.sub( -.5, w ),
      scaling = g.mul( g.mul( 13, filter ), g.pow( n, 5 ) ),
      // calculate dc offset and normalization factors
      DC = g.sub( .376, g.mul( w, .752 ) ),
      norm = g.sub( 1, g.mul( 2, w ) ),
      // determine phase
      osc1Phase = g.accum( w, 0, { min:-1 }),
      osc1, out

  // create current sample... from the paper:
  // osc = (osc + sin(2*pi*(phase + osc*scaling)))*0.5f;
  osc1 = g.memo( 
    g.mul(
      g.add(
        lastSample.out,
        g.sin(
          g.mul(
            Math.PI * 2,
            g.memo( g.add( osc1Phase, g.mul( lastSample.out, scaling ) ) )
          )
        )
      ),
      .5
    )
  )

  // store sample to use as modulation
  lastSample.in( osc1 )

  // if pwm / square waveform instead of sawtooth...
  if( argumentProps.type === 1 ) { 
    const lastSample2 = g.history() // for osc 2
    const lastSampleMaster = g.history() // for sum of osc1,osc2

    const osc2 = g.mul(
      g.add(
        lastSample2.out,
        g.sin(
          g.mul(
            Math.PI * 2,
            g.memo( g.add( osc1Phase, g.mul( lastSample2.out, scaling ), pulsewidth ) )
          )
        )
      ),
      .5
    )

    lastSample2.in( osc2 )
    out = g.memo( g.sub( lastSample.out, lastSample2.out ) )
    out = g.memo( g.add( g.mul( 2.5, out ), g.mul( -1.5, lastSampleMaster.out ) ) )
    
    lastSampleMaster.in( g.sub( osc1, osc2 ) )

  }else{
     // offset and normalize
    osc1 = g.add( g.mul( 2.5, osc1 ), g.mul( -1.5, lastSample.out ) )
    osc1 = g.add( osc1, DC )
 
    out = osc1
  }

  return g.mul( out, norm )
}

module.exports = feedbackOsc

},{"genish.js":51}],202:[function(require,module,exports){
const g = require( 'genish.js' ),
      ugen = require( '../ugen.js' )(),
      feedbackOsc = require( './fmfeedbackosc.js' ),
      polyBlep = require( './polyblep.dsp.js' )

//  __makeOscillator__( type, frequency, antialias ) {
    
module.exports = function( Gibberish ) {
  let Oscillators = {
    export( obj ) {
      for( let key in Oscillators ) {
        if( key !== 'export' ) {
          obj[ key ] = Oscillators[ key ]
        }
      }
    },

    genish: {
      Brown: require( './brownnoise.dsp.js' ),
      Pink:  require( './pinknoise.dsp.js'  )
    },

    Wavetable: require( './wavetable.js' )( Gibberish ),
    
    Square( inputProps ) {
      const sqr   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'square', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( sqr, graph, ['oscillators','square'], props )

      return out
    },

    Triangle( inputProps ) {
      const tri= Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'triangle', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( tri, graph, ['oscillators','triangle'], props )

      return out
    },

    PWM( inputProps ) {
      const pwm   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false, pulsewidth:.25 }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'pwm', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( pwm, graph, ['oscillators','PWM'], props )

      return out
    },

    Sine( inputProps ) {
      const sine  = Object.create( ugen )
      const props = Object.assign({}, Oscillators.defaults, inputProps )
      const graph = g.mul( g.cycle( g.in('frequency') ), g.in('gain') )

      const out = Gibberish.factory( sine, graph, ['oscillators','sine'], props )
      
      return out
    },

    Noise( inputProps ) {
      const noise = Object.create( ugen )
      const props = Object.assign( {}, { gain: 1, color:'white' }, inputProps )
      let graph 

      switch( props.color ) {
        case 'brown':
          graph = g.mul( Oscillators.genish.Brown(), g.in('gain') )
          break;
        case 'pink':
          graph = g.mul( Oscillators.genish.Pink(), g.in('gain') )
          break;
        default:
          graph = g.mul( g.noise(), g.in('gain') )
          break;
      }

      const out = Gibberish.factory( noise, graph, ['oscillators','noise'], props )

      return out
    },

    Saw( inputProps ) {
      const saw   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'saw', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( saw, graph, ['oscillators','saw'], props )

      return out
    },

    ReverseSaw( inputProps ) {
      const saw   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = g.sub( 1, Oscillators.factory( 'saw', g.in( 'frequency' ), props.antialias ) )
      const graph = g.mul( osc, g.in( 'gain' ) )

      const out = Gibberish.factory( saw, graph, ['oscillators','ReverseSaw'], props )
      
      return out
    },

    factory( type, frequency, antialias=false ) {
      let osc

      switch( type ) {
        case 'pwm':
          let pulsewidth = g.in('pulsewidth')
          if( antialias == true ) {
            osc = feedbackOsc( frequency, 1, pulsewidth, { type:1 })
          }else{
            let phase = g.phasor( frequency, 0, { min:0 } )
            osc = g.lt( phase, pulsewidth )
          }
          break;
        case 'saw':
          if( antialias == false ) {
            osc = g.phasor( frequency )
          }else{
            osc = polyBlep( frequency, { type })
          }
          break;
        case 'sine':
          osc = g.cycle( frequency )
          break;
        case 'square':
          if( antialias == true ) {
            //osc = feedbackOsc( frequency, 1, .5, { type:1 })
            osc = polyBlep( frequency, { type })
          }else{
            osc = g.wavetable( frequency, { buffer:Oscillators.Square.buffer, name:'square' } )
          }
          break;
        case 'triangle':
          if( antialias == true ) {
            osc = polyBlep( frequency, { type })
          }else{
            osc = g.wavetable( frequency, { buffer:Oscillators.Triangle.buffer, name:'triangle' } )
          }
          break;
        case 'noise':
          osc = g.noise()
          break;
      }

      return osc
    }
  }

  Oscillators.Square.buffer = new Float32Array( 1024 )

  for( let i = 1023; i >= 0; i-- ) { 
    Oscillators.Square.buffer [ i ] = i / 1024 > .5 ? 1 : -1
  }

  Oscillators.Triangle.buffer = new Float32Array( 1024 )

  
  for( let i = 1024; i--; i = i ) { Oscillators.Triangle.buffer[i] = 1 - 4 * Math.abs(( (i / 1024) + 0.25) % 1 - 0.5); }

  Oscillators.defaults = {
    frequency: 440,
    gain: 1
  }

  return Oscillators

}

},{"../ugen.js":210,"./brownnoise.dsp.js":200,"./fmfeedbackosc.js":201,"./pinknoise.dsp.js":203,"./polyblep.dsp.js":204,"./wavetable.js":205,"genish.js":51}],203:[function(require,module,exports){
const genish = require( 'genish.js' ),
      ssd = genish.history,
      data = genish.data,
      noise = genish.noise

module.exports = function() {
  "use jsdsp"

  const b = data( 8, 1, { meta: true })
  const white = noise() * 2 - 1

  b[0] = ( .99886 * b[0] ) + ( white * .0555179 )
  b[1] = ( .99332 * b[1] ) + ( white * .0750579 )
  b[2] = ( .96900 * b[2] ) + ( white * .1538520 )
  b[3] = ( .88650 * b[3] ) + ( white * .3104856 )
  b[4] = ( .55000 * b[4] ) + ( white * .5329522 )
  b[5] = ( -.7616 * b[5] ) - ( white * .0168980 )
 
  const out = ( b[0] + b[1] + b[2] + b[3] + b[4] + b[5] + b[6] + white * .5362 ) * .11

  b[6] = white * .115926

  return out

}

},{"genish.js":51}],204:[function(require,module,exports){
const genish = require( 'genish.js' )
const g = genish

// based on http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/
const polyBlep = function( __frequency, argumentProps ) {
  'use jsdsp'
  if( argumentProps === undefined ) argumentProps = { type: 'saw' }
  
  const mem = g.history(0)
  const type = argumentProps.type
  const frequency = __frequency === undefined ? 220 : __frequency
  const dt = frequency / g.gen.samplerate
  
  const t = g.accum( dt, 0, { min:0 })
  let osc

  // triangle waves are integrated square waves, so the below case accomodates both types
  if( type === 'triangle' || type === 'square' ) {
    // lt NOT gt to get correct phase
    osc = (2 * g.lt(t,.5) ) - 1
  }else{
    osc = 2 * t - 1
  }
  const case1 = g.lt(t,dt)
  const case2 = g.gt(t,1-dt)
  const adjustedT = g.switch( case1, t/dt, g.switch( case2, (t-1)/dt, t ) )
  
  // if/elseif/else with nested ternary operators
  const blep = g.switch(
    case1,
    adjustedT + adjustedT - adjustedT * adjustedT - 1,
    g.switch(
      case2,
      adjustedT * adjustedT + adjustedT + adjustedT + 1,
      // final else case is 0
      0
    )
  )
  
  // triangle waves are integrated square waves, so the below case accomodates both types
  if( type !== 'saw' ) {
    osc = osc + blep
    const t_2 = g.memo( g.mod( t + .5, 1 ) )
    const case1_2 = g.lt(t_2,dt)
    const case2_2 = g.gt(t_2,1-dt)
    const adjustedT_2 = g.switch( case1_2, t_2/dt, g.switch( case2_2, (t_2-1)/dt, t_2 ) )
 
    const blep2 = g.switch(
      case1_2,
      adjustedT_2 + adjustedT_2 - adjustedT_2 * adjustedT_2 - 1,
      g.switch(
        case2_2,
        adjustedT_2 * adjustedT_2 + adjustedT_2 + adjustedT_2 + 1,
        0
      )
    )
    osc = osc - blep2
    
    // leaky integrator to create triangle from square wave
    if( type === 'triangle' ) {
      osc = dt * osc + (1 - dt ) * mem.out
      mem.in( osc )
    }
  }else{
    osc = osc - blep
  }
  
  return osc
}

module.exports = polyBlep 

},{"genish.js":51}],205:[function(require,module,exports){
let g = require( 'genish.js' ),
    ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {

  const Wavetable = function( inputProps ) {
    const wavetable = Object.create( ugen )
    const props  = Object.assign({}, Gibberish.oscillators.defaults, inputProps )
    const osc = g.wavetable( g.in('frequency'), props )
    const graph = g.mul( 
      osc, 
      g.in( 'gain' )
    )

    Gibberish.factory( wavetable, graph, 'wavetable', props )

    return wavetable
  }

  g.wavetable = function( frequency, props ) {
    let dataProps = { immutable:true }

    // use global references if applicable
    if( props.name !== undefined ) dataProps.global = props.name

    const buffer = g.data( props.buffer, 1, dataProps )

    return g.peek( buffer, g.phasor( frequency, 0, { min:0 } ) )
  }

  return Wavetable
}

},{"../ugen.js":210,"genish.js":51}],206:[function(require,module,exports){
const Queue = require( '../external/priorityqueue.js' )

let Gibberish = null

const Scheduler = {
  phase: 0,

  queue: new Queue( ( a, b ) => {
    if( a.time === b.time ) { 
      return a.priority < b.priority ? -1 : a.priority > b.priority ? 1 : 0;
    }else{
      return a.time - b.time //a.time.minus( b.time )
    }
  }),

  init( __Gibberish ) {
    Gibberish = __Gibberish
  },

  clear() {
    this.queue.data.length = 0
    this.queue.length = 0
    this.phase = 0
  },

  add( time, func, priority = 0 ) {
    time += this.phase

    this.queue.push({ time, func, priority })

    return this.phase
  },

  tick( usingSync = false ) {
    if( this.shouldSync === usingSync ) {
      if( this.queue.length ) {
        let next = this.queue.peek()

        if( isNaN( next.time ) ) {
          this.queue.pop()
        }
        
        while( this.phase >= next.time ) {
          next.func( next.priority )
          this.queue.pop()
          next = this.queue.peek()

          // XXX this happens when calling sequencer.stop()... why?
          if( next === undefined ) break
        }
      }

      this.phase++
    }

    return this.phase
  },

  advance( amt ) {
    this.phase += amt
    this.tick( true )
  }
}

let shouldSync = false
Object.defineProperty( Scheduler, 'shouldSync', {
  get() { return shouldSync },
  set(v){ 
    shouldSync = v
    if( Gibberish.mode === 'worklet' ) {
      Gibberish.worklet.port.postMessage({
        address:'eval',
        code:'Gibberish.scheduler.shouldSync = ' + v
      })
    }
  }
})

module.exports = Scheduler

},{"../external/priorityqueue.js":149}],207:[function(require,module,exports){
const g = require( 'genish.js' ),
      __proxy = require( '../workletProxy.js' ),
      ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {
  const __proto__ = Object.create( ugen )

  const proxy = __proxy( Gibberish )

  Object.assign( __proto__, {
    start( delay=0 ) {
      if( delay !== 0 ) {
        Gibberish.scheduler.add( delay, ()=> {
          Gibberish.analyzers.push( this )
          Gibberish.dirty( Gibberish.analyzers )
        })
      }else{
        Gibberish.analyzers.push( this )
        Gibberish.dirty( Gibberish.analyzers )
      }
      return this
    },
    stop( delay=0 ) {
      const idx = Gibberish.analyzers.indexOf( this )
      if( delay === 0 ) {
        if( idx > -1 ) {
          Gibberish.analyzers.splice( idx, 1 )
          Gibberish.dirty( Gibberish.analyzers )
        }
        this.phase = 0
        this.nextTime = 0
      }else{
        Gibberish.scheduler.add( delay, ()=> {
          if( idx > -1 ) {
            Gibberish.analyzers.splice( idx, 1 )
            Gibberish.dirty( Gibberish.analyzers )
          }
          this.phase = 0
          this.nextTime = 0
        })
      }

      return this
    },
    fire(){
      let value  = typeof this.values  === 'function' ? this.values  : this.values[ this.__valuesPhase++  % this.values.length  ]
      if( typeof value === 'function' && this.target === undefined ) {
        value()
      }else if( typeof this.target[ this.key ] === 'function' ) {
        if( typeof value === 'function' ) {
          value = value()
        }
        if( value !== this.DNR ) {
          this.target[ this.key ]( value )
        }
      }else{
        if( typeof value === 'function' ) value = value()
        if( value !== this.DNR )
          this.target[ this.key ] = value
      }
    }
  })

  // XXX we need to implement priority, which will in turn determine the order
  // that the sequencers are added to the callback function.
  const Seq2 = { 
    create( inputProps ) {
      const seq = Object.create( __proto__ ),
            properties = Object.assign({}, Seq2.defaults, inputProps )

      seq.phase = 0
      seq.inputNames = [ 'rate', 'density' ]
      seq.inputs = [ 1, 1 ]
      seq.nextTime = 0
      seq.__valuesPhase = 0
      seq.__timingsPhase = 0
      seq.id = Gibberish.factory.getUID()
      seq.dirty = true
      seq.type = 'seq'
      seq.__addresses__ = {}
      seq.DNR = -987654321

      properties.id = Gibberish.factory.getUID()

      Object.assign( seq, properties ) 
      seq.__properties__ = properties

      // support for sequences that are triggered via other means,
      // in Gibber this is when you provide timing to one sequence
      // on an object and want to use that one pattern to trigger
      // multiple sequences.
      if( seq.timings === null ) { seq.nextTime = Infinity } 

      // XXX this needs to be optimized as much as humanly possible, since it's running at audio rate...
      seq.callback = function( rate, density ) {
        while( seq.phase >= seq.nextTime ) {
          let value  = typeof seq.values  === 'function' ? seq.values  : seq.values[ seq.__valuesPhase++  % seq.values.length  ],
              shouldRun = true
          
          let timing = null
          if( seq.timings !== null && seq.timings !== undefined ) { 
            timing = typeof seq.timings === 'function' ? seq.timings : seq.timings[ seq.__timingsPhase++ % seq.timings.length ]
            if( typeof timing === 'function' ) timing = timing()
          }
          
          let shouldIncreaseSpeed = density <= 1 ? false : true

          // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
          // objects indicating both whether or not they should should trigger values as well
          // as the next time they should run. perhaps this could be made more generalizable?
          if( timing !== null && typeof timing === 'object' ) {
            if( timing.shouldExecute === 1 ) {
              shouldRun = true
            }else{
              shouldRun = false
            }
            timing = timing.time 
          }else if( timing !== null ) {
            if( Math.random() >= density ) shouldRun = false
          }

          if( shouldRun ) {
            if( seq.mainthreadonly !== undefined ) {
              if( typeof value === 'function' ) {
                value = value()
              }
              Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
            }else if( typeof value === 'function' && seq.target === undefined ) {
              value()
            }else if( typeof seq.target[ seq.key ] === 'function' ) {
              if( typeof value === 'function' ) {
                value = value()
              }
              if( value !== seq.DNR ) {
                seq.target[ seq.key ]( value )
              }
            }else{
              if( typeof value === 'function' ) value = value()
              if( value !== seq.DNR )
                seq.target[ seq.key ] = value
            }
          }

          if( timing === null ) return

          seq.phase -= seq.nextTime

          if( shouldIncreaseSpeed ) {
            timing = Math.random() > (2 - density) ? timing / 2 : timing
          }
          seq.nextTime = timing
        }

        seq.phase += rate

        return 0
      }

      seq.ugenName = seq.callback.ugenName = 'seq_' + seq.id

      // since we're not passing our sequencer through the ugen template, we need
      // to grab a memory address for its rate so it can be sequenced and define
      // a property that manipulates that memory address.
      const idx = Gibberish.memory.alloc( 1 )
      Gibberish.memory.heap[ idx ] = seq.rate
      seq.__addresses__.rate = idx

      let value = seq.rate
      Object.defineProperty( seq, 'rate', {
        get() { return value },
        set( v ) {
          if( value !== v ) {
            if( typeof v === 'number' ) Gibberish.memory.heap[ idx ] = v

            Gibberish.dirty( Gibberish.analyzers )
            value = v
          }
        }
      })

      const didx = Gibberish.memory.alloc( 1 )
      Gibberish.memory.heap[ didx ] = seq.density
      seq.__addresses__.density = didx

      let dvalue = seq.density
      Object.defineProperty( seq, 'density', {
        get() { return dvalue },
        set( v ) {
          if( dvalue !== v ) {
            if( typeof v === 'number' ) Gibberish.memory.heap[ didx ] = v

            Gibberish.dirty( Gibberish.analyzers )
            dvalue = v
          }
        }
      })

      if( Gibberish.mode === 'worklet' ) {
        Gibberish.utilities.createPubSub( seq )
      }

      return proxy( ['Sequencer2'], properties, seq ) 
    }
  }

  Seq2.defaults = { rate: 1, density:1, priority:0, phase:0 }
  Seq2.create.DO_NOT_OUTPUT = -987654321

  return Seq2.create

}


},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],208:[function(require,module,exports){
(function (global){(function (){
const __proxy = require( '../workletProxy.js' )

module.exports = function( Gibberish ) {

const renderFnc = function( pattern ) {
  const keys = Object.keys( pattern.dict )
  const objs = Object.values( pattern.dict )
    .map( v => typeof v === 'object' && !Array.isArray( v )
    ? Gibberish.processor.ugens.get(v.id) 
    : v 
    )

  // we create a new inner function using the function constructor,
  // where every argument is codegen'd as an upvalue to the
  // returned function. after codegen we call the functon
  // to get the inner function with the upvalues andd
  // return that. Store references to globals as upvalues as well.
  let code = 'let Gibberish = __Gibberish, global = __global;\n'
  keys.forEach( k => {
    let line = `let ${k} = `
    const value = pattern.dict[ k ]
    const getter = typeof value === 'object' 
      ? Array.isArray( value )
      ? `[${value.toString()}]`
      : `Gibberish.processor.ugens.get(${ value.id })`
      : value
    line += getter 
    code += line + '\n'

  })  
  code +=`return function() { ${ pattern.fncstr } }` 

  // pass in globals to be used as upvalues in final function
  const fnc = new Function( '__Gibberish', '__global', code )( Gibberish, global )

  return fnc 
}

const proxy = __proxy( Gibberish )

const Sequencer = props => {
  let __seq
  let floatError = 0

  const seq = {
    type:'seq',
    __isRunning:false,
    __valuesPhase:  0,
    __timingsPhase: 0,
    __onlyRunsOnce: false,
    __repeatCount: null,
    DNR : -987654321,

    tick( priority ) {
      let value  = typeof seq.values  === 'function' 
          ? seq.values  
          : seq.values[  seq.__valuesPhase++  % seq.values.length  ],

        timing = typeof seq.timings === 'function' 
          ? seq.timings 
          : seq.timings !== null
            ? seq.timings[ seq.__timingsPhase++ % seq.timings.length ]
            : null,

        shouldRun = true
      
      if( seq.__onlyRunsOnce === true ) {
        if( seq.__valuesPhase === seq.values.length ) {
          seq.stop()
        }
      }else if( seq.__repeatCount !== null ) {
        if( seq.__valuesPhase % seq.values.length === 0 ) {
          seq.__repeatCount--
          if( seq.__repeatCount === 0 ) {
            seq.stop()
            seq.__repeatCount = null
          }
        }
      }

      if( typeof timing === 'function' ) timing = timing()

      // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
      // objects indicating both whether or not they should should trigger values as well
      // as the next time they should run. perhaps this could be made more generalizable?
      if( timing !== null ) {
        if( typeof timing === 'object' ) {
          if( timing.shouldExecute === 1 ) {
            shouldRun = true
          }else{
            shouldRun = false
          }
          timing = timing.time 
        }

        timing *= seq.rate
      }else{
        shouldRun = false 
      }

      if( value === Sequencer.DO_NOT_OUTPUT ) shouldRun = false

      if( shouldRun ) {
        try{
          if( seq.mainthreadonly !== undefined ) {
            if( typeof value === 'function' ) {
              value = value()
            }
            //console.log( 'main thread only' )
            Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
          }else if( typeof value === 'function' && seq.target === undefined ) {
            value()
          }else if( typeof seq.target[ seq.key ] === 'function' ) {
            //console.log( seq.key, seq.target )
            if( typeof value === 'function' ) value = value()
            if( value !== seq.DNR )
              seq.target[ seq.key ]( value )
          }else{
            if( typeof value === 'function' ) value = value()
            if( value !== seq.DNR )
              seq.target[ seq.key ] = value
          }

          if( seq.reportOutput === true ) {
            Gibberish.processor.port.postMessage({
              address:'__sequencer',
              id: seq.id,
              name:'output',
              value,
              phase: seq.__valuesPhase,
              length: seq.values.length
            })
          }
        } catch(e) {
          console.error( `A sequence targeting ${seq.target.ugenName}.${seq.key} contains an improper value and will be stopped.` )
          return
        }
      }
      
      if( Gibberish.mode === 'processor' ) {
        if( seq.__isRunning === true && !isNaN( timing ) && seq.autotrig === false ) {
          timing += floatError
          Gibberish.scheduler.add( timing, seq.tick, seq.priority )
          floatError = timing - Math.floor( timing )
        }
      }
    },
    fire(){
      let value  = typeof this.values  === 'function' ? this.values  : this.values[ this.__valuesPhase++  % this.values.length  ]
      if( typeof value === 'function' && this.target === undefined ) {
        value()
      }else if( typeof this.target[ this.key ] === 'function' ) {
        if( typeof value === 'function' ) {
          value = value()
        }
        if( value !== this.DNR ) {
          this.target[ this.key ]( value )
        }
      }else{
        if( typeof value === 'function' ) value = value()
        if( value !== this.DNR )
          this.target[ this.key ] = value
      }
    },

    start( delay = 0 ) {
      if( Gibberish.mode === 'processor' && seq.__isRunning === false ) {
        Gibberish.scheduler.add( 
          delay, 
          priority => {
            seq.tick( priority )
            Gibberish.processor.port.postMessage({
              address:'__sequencer',
              id: seq.id,
              name:'start'
            })
          }, 
          seq.priority 
        )
      }
      seq.__isRunning = true
      seq.__delay = delay
      return __seq
    },

    stop( delay = null ) {
      if( delay === null ) {
        seq.__isRunning = false

        if( Gibberish.mode === 'processor' ) {
          Gibberish.processor.port.postMessage({
            address:'__sequencer',
            id: seq.id,
            name:'stop'
          })
        }
      
      }else{
        Gibberish.scheduler.add( delay, seq.stop )
      }
      return __seq
    },

    once() {
      seq.__onlyRunsOnce = true
      return __seq
    },

    repeat( repeatCount = 2 ) {
      seq.__repeatCount = repeatCount
      return __seq
    }
  }

  props.id = Gibberish.factory.getUID()

  if( Gibberish.mode === 'worklet' ) {
    Gibberish.utilities.createPubSub( seq )
  }else{
    // need a separate reference to the properties for worklet meta-programming
    if( typeof props.values === 'object' && props.values.requiresRender === true ) {
      props.values = renderFnc( props.values )
    }
    if( props.timings !== null && typeof props.timings === 'object' && props.timings.requiresRender === true ) {
      props.timings = renderFnc( props.timings )
    }
  }

  const properties = Object.assign( {}, Sequencer.defaults, props )
  Object.assign( seq, properties ) 
  seq.__properties__ = properties

  __seq =  proxy( ['Sequencer'], properties, seq )

  return __seq
}

Sequencer.defaults = { priority:100, rate:1, reportOutput:false, autotrig:false }

Sequencer.make = function( values, timings, target, key, priority, reportOutput ) {
  return Sequencer({ values, timings, target, key, priority, reportOutput })
}

Sequencer.DO_NOT_OUTPUT = -987654321

return Sequencer

}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../workletProxy.js":212}],209:[function(require,module,exports){
const __proxy = require( '../workletProxy.js' )
const Pattern = require( 'tidal.pegjs' )

module.exports = function( Gibberish ) {

const proxy = __proxy( Gibberish )

const Sequencer = props => {
  let __seq
  const seq = {
    __isRunning:false,

    __phase:  0,
    __type:'seq',
    __pattern: Pattern( props.pattern, { addLocations:true, addUID:true, enclose:true }),
    __events: null,

    tick( priority ) {
      // running for first time, perform a query
      if( seq.__events === null || seq.__events.length === 0 ) {
        seq.__events = seq.__pattern.query( seq.__phase++, 1 )
      }

      // used when scheduling events that are very far apart
      if( seq.__events.length <= 0 ) {
        if( Gibberish.mode === 'processor' ) {
          if( seq.__isRunning === true  ) {
            Gibberish.scheduler.add( Gibberish.ctx.sampleRate / Sequencer.clock.cps, seq.tick, seq.priority )
          }

        }

        return
      }

      const startTime = seq.__events[ 0 ].arc.start

      if( seq.key !== 'chord' ) {
        while( seq.__events.length > 0 && startTime.valueOf() === seq.__events[0].arc.start.valueOf() ) {
          let event  = seq.__events.shift(),
              value  = event.value,
              uid    = event.uid

          // for bjorklund etc.
          if( typeof value === 'object' ) value = value.value

          if( seq.filters !== null ) value = seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, uid ), value )  
          if( seq.mainthreadonly !== undefined ) {
            if( typeof value === 'function' ) {
              value = value()
            }
            Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
          }else if( typeof seq.target[ seq.key ] === 'function' ) {
            seq.target[ seq.key ]( value )
          }else{
            seq.target[ seq.key ] = value
          }
        }
      }else{
        let value = seq.__events.filter( evt => startTime.valueOf() === evt.arc.start.valueOf() ).map( evt => evt.value )
        let uid = seq.__events[0].uid

        const events = seq.__events.splice( 0, value.length )

        if( seq.filters !== null ) {
          if( value.length === 1 ) {
            value = seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, uid ), value )  
          }else{
            value.forEach( (v,i) => seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, events[ i ].uid ), v ) )
          }
        }

        if( typeof seq.target[ seq.key ] === 'function' ) {
          seq.target[ seq.key ]( value )
        }else{
          seq.target[ seq.key ] = value
        }
      }

      if( Gibberish.mode === 'processor' ) {
        let timing
        if( seq.__events.length <= 0 ) {
          let time = 0
          while( seq.__events.length <= 0 ) {
            seq.__events = seq.__pattern.query( seq.__phase++, 1 )
            time++
          }
          //seq.__events.forEach( evt => {
          //  evt.arc.start = evt.arc.start.add( 1 ).sub( startTime ) 
          //  evt.arc.end   = evt.arc.end.add( 1 ).sub( startTime )
          //})

          timing = time - startTime.valueOf() 
        }else{
          timing = seq.__events[0].arc.start.sub( startTime ).valueOf() 
        }
        
        timing *= Math.ceil( Gibberish.ctx.sampleRate / Sequencer.clock.cps ) + 1 

        if( seq.__isRunning === true && !isNaN( timing ) && timing > 0 ) {
          // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
          // objects indicating both whether or not they should should trigger values as well
          // as the next time they should run. perhaps this could be made more generalizable?
          
          //if( typeof timing === 'object' ) {
          //  if( timing.shouldExecute === 1 ) {
          //    shouldRun = true
          //  }else{
          //    shouldRun = false
          //  }
          //  timing = timing.time 
          //}

          //timing *= seq.rate

          Gibberish.scheduler.add( timing, seq.tick, seq.priority )
        }
      }


    },

    rotate( amt ) {
      seq.__phase += amt
      return __seq 
    },

    start( delay = 0 ) {
      seq.__isRunning = true
      Gibberish.scheduler.add( delay, seq.tick, seq.priority )
      return __seq
    },

    stop() {
      seq.__isRunning = false
      return __seq
    },

    set( patternString ) {
      seq.__pattern = Pattern( patternString, { addLocations:true, addUID:true, enclose:true })

    }
  }

  props.id = Gibberish.factory.getUID()

  // need a separate reference to the properties for worklet meta-programming
  const properties = Object.assign( {}, Sequencer.defaults, props )
  Object.assign( seq, properties ) 
  seq.__properties__ = properties

  __seq =  proxy( ['Tidal'], properties, seq )

  return __seq
}

Sequencer.defaults = { priority:100000, pattern:'', rate:1, filters:null }

Sequencer.make = function( values, timings, target, key, priority ) {
  return Sequencer({ values, timings, target, key, priority })
}

let __uid = 0
Sequencer.getUID = ()=> {
  return __uid++
}

Sequencer.Pattern = Pattern

Sequencer.clock = { cps: 1 }

Sequencer.id = Gibberish.utilities.getUID()

if( Gibberish.mode === 'worklet' ) {
  Gibberish.worklet.port.postMessage({
    address:'eval',
    code:`Gibberish.Tidal.clock.id = ${Sequencer.id}; Gibberish.ugens.set( ${Sequencer.id}, Gibberish.Tidal.clock )`
  })
  
  let cps = 1
  Object.defineProperty( Sequencer, 'cps', {
    get() { return cps },
    set(v){ 
      cps = v
      if( Gibberish.mode === 'worklet' ) {
        Gibberish.worklet.port.postMessage({
          address:'set',
          object:Sequencer.id,
          name:'cps',
          value:cps 
        }) 
      }
    }
  })
}

return Sequencer

}

},{"../workletProxy.js":212,"tidal.pegjs":233}],210:[function(require,module,exports){
let Gibberish = null

const __ugen = function( __Gibberish ) {
  if( __Gibberish !== undefined && Gibberish == null ) Gibberish = __Gibberish
 
  const replace = obj => {
    if( typeof obj === 'object' ) {
      if( obj.id !== undefined ) {
        return processor.ugens.get( obj.id )
      } 
    }

    return obj
  }

  const ugen = {
    __Gibberish:Gibberish,

    free:function() {
      Gibberish.genish.gen.free( this.graph )
    },

    print:function() {
      console.log( this.callback.toString() )
    },

    connect:function( target, level=1 ) {
      if( this.connected === undefined ) this.connected = []

      //let input = level === 1 ? this : Gibberish.binops.Mul( this, level )
      let input = this

      if( target === undefined || target === null ) target = Gibberish.output 


      // XXX I forgot, where is __addInput found? Can we control the
      // level of the input?
      if( typeof target.__addInput == 'function' ) {
        target.__addInput( input )
      } else if( target.sum && target.sum.inputs ) {
        target.sum.inputs.push( input )
      } else if( target.inputs ) {
        const idx = target.inputs.indexOf( input )

        // if no connection exists...
        if( idx === -1 ) {
          target.inputs.unshift( input, level, input.isStereo )
        }else{
          // ... otherwise update the connection's level, which is stored
          // one index higher in the input list.
          target.inputs[ idx + 1 ] = level
        }
      } else {
        target.input = input
        target.inputGain = level
      }

      Gibberish.dirty( target )

      this.connected.push([ target, input, level ])
      
      return this
    },

    disconnect:function( target ) {
      if( target === undefined ){
        if( Array.isArray( this.connected ) ) {
          for( let connection of this.connected ) {
            if( connection[0].disconnectUgen !== undefined ) {
              connection[0].disconnectUgen( connection[1] )
            }else if( connection[0].input === this ) {
              connection[0].input = 0
            }
          }
          this.connected.length = 0
        }
      }else{
        const connection = this.connected.find( v => v[0] === target )
        // if target is a bus...
        if( target.disconnectUgen !== undefined ) {
          if( connection !== undefined ) {
            target.disconnectUgen( connection[1] )
          }
        }else{
          // must be an effect, set input to 0
          target.input = 0
        }

        const targetIdx = this.connected.indexOf( connection )

        if( targetIdx !== -1 ) {
          this.connected.splice( targetIdx, 1 )
        }
      }
    },

    chain:function( target, level=1 ) {
      this.connect( target,level )

      return target
    },

    __redoGraph:function() {
      let isStereo = this.isStereo
      this.__createGraph()
      this.callback = Gibberish.genish.gen.createCallback( this.graph, Gibberish.memory, false, true )
      this.inputNames = new Set( Gibberish.genish.gen.parameters ) 
      this.callback.ugenName = this.ugenName
      Gibberish.dirty( this )

      // if channel count has changed after recompiling graph...
      if( isStereo !== this.isStereo ) {

        // check for any connections before iterating...
        if( this.connected === undefined ) return
        // loop through all busses the ugen is connected to
        for( let connection of this.connected ) {
          // set the dirty flag of the bus
          Gibberish.dirty( connection[ 0 ] )

          // check for inputs array, which indicates connection is to a bus
          if( connection[0].inputs !== undefined ) {
            // find the input in the busses 'inputs' array
            const inputIdx = connection[ 0 ].inputs.indexOf( connection[ 1 ] )

            // assumiing it is found...
            if( inputIdx !== -1 ) {
              // change stereo field
              connection[ 0 ].inputs[ inputIdx + 2 ] = this.isStereo
            }
          }else if( connection[0].input !== undefined ) {
            if( connection[0].__redoGraph !== undefined ) {
              connection[0].__redoGraph()
            }
          }
        }
      }
    },
  }

  return ugen

}

module.exports = __ugen

},{}],211:[function(require,module,exports){
const genish = require( 'genish.js' ),
      AWPF = require( './external/audioworklet-polyfill.js' )

module.exports = function( Gibberish ) {

let uid = 0
const utilities = {
  Make: function( props ){
    const name = props.name || 'Ugen' + (Math.floor( Math.random()*10000 ) )
    const type = props.type || 'Ugen'
    const properties = props.properties || {}
    const block = `
    const ugen = Object.create( Gibberish.prototypes[ '${type}' ] )
    const graphfnc = ${props.constructor.toString()}

    const proxy = Gibberish.factory( ugen, graphfnc(), '${name}', ${JSON.stringify(properties)} )
    if( typeof props === 'object' ) Object.assign( proxy, props )

    return proxy`

    Gibberish[ name ] = new Function( 'props', block )

    Gibberish.worklet.port.postMessage({
      name,
      address:'addConstructor',
      constructorString:`function( Gibberish ) {
      const fnc = ${Gibberish[ name ].toString()}

      return fnc
    }`
    })

    return Gibberish[ name ]
  },

  createContext( ctx, cb, resolve, bufferSize=2048 ) {
    let AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext

    AWPF( window, bufferSize )

    const start = () => {
      if( typeof AC !== 'undefined' ) {
        this.ctx = Gibberish.ctx = ctx === undefined ? new AC({ latencyHint:.025 }) : ctx

        genish.gen.samplerate = this.ctx.sampleRate
        genish.utilities.ctx = this.ctx

        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
          window.removeEventListener( 'touchstart', start )
        }else{
          window.removeEventListener( 'mousedown', start )
          window.removeEventListener( 'keydown', start )
        }

        const mySource = utilities.ctx.createBufferSource()
        mySource.connect( utilities.ctx.destination )
        mySource.start()
      }

      if( typeof cb === 'function' ) cb( resolve )
    }

    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
      window.addEventListener( 'touchstart', start )
    }else{
      window.addEventListener( 'mousedown', start )
      window.addEventListener( 'keydown', start )
    }

    return Gibberish.ctx
  },
  
  createWorklet( resolve ) {
    Gibberish.ctx.audioWorklet.addModule( Gibberish.workletPath ).then( () => {
      Gibberish.worklet = new AudioWorkletNode( Gibberish.ctx, 'gibberish', { outputChannelCount:[2] } )

      Gibberish.worklet.connect( Gibberish.ctx.destination )
      Gibberish.worklet.port.onmessage = event => {
        const callback = Gibberish.utilities.workletHandlers[ event.data.address ]
        if( typeof callback === 'function' ) callback( event )     
      }
      Gibberish.worklet.ugens = new Map()

      resolve()
    })
  },

  future( fnc, time, dict ) {
    const keys = Object.keys( dict )
    const code = `
      const fnc = ${fnc.toString()}
      const args = [${keys.map( key => typeof dict[key] === 'object' ? dict[ key ].id : `'${dict[ key]}'` ).join(',')}]
      const objs = args.map( v => typeof v === 'number' ? Gibberish.processor.ugens.get(v) : v )
      Gibberish.scheduler.add( ${time}, ()=> fnc( ...objs ), 1 )
    ` 
    Gibberish.worklet.port.postMessage({ 
      address:'eval', 
      code
    })
  },

  workletHandlers: {
    phase( event ) {
      Gibberish.phase = event.data.value
      if( typeof Gibberish.onphaseupdate === 'function' ) {
        Gibberish.onphaseupdate( Gibberish.phase )
      }
    },
    __sequencer( event ) {
      const message = event.data
      const id = message.id
      const eventName = message.name
      const obj = Gibberish.worklet.ugens.get( id )
      if( obj !== undefined && obj.publish !== undefined )
        obj.publish( eventName, message )
    },
    callback( event ) {
      if( typeof Gibberish.oncallback === 'function' ) {
        Gibberish.oncallback( event.data.code )
      }
    },
    get( event ) {
      let name = event.data.name
      let value
      if( name[0] === 'Gibberish' ) {
        value = Gibberish
        name.shift()
      }
      for( let segment of name ) {
        value = value[ segment ]
      }

      Gibberish.worklet.port.postMessage({
        address:'set',
        name:'Gibberish.' + name.join('.'),
        value
      })
    },
    state( event ){
      const messages = event.data.messages
      if( messages.length === 0 ) return

      // XXX is preventProxy actually used?
      Gibberish.preventProxy = true
      Gibberish.proxyEnabled = false

      let i = 0
      while( i < messages.length ) {
        const id = messages[ i ] 
        const propName = messages[ i + 1 ]
        const valueL = messages[ i + 2 ]
        const valueR = messages[ i + 3 ]
        const value = valueL
        const obj = Gibberish.worklet.ugens.get( id )

        if( Gibberish.worklet.debug === true ) {
          if( propName !== 'output' ) console.log( propName, value, id )
        }

        if( typeof propName !== 'string' ) continue
        
        if( obj !== undefined && propName.indexOf('.') === -1 && propName !== 'id' ) { 
          if( obj[ propName ] !== undefined ) {
            if( typeof obj[ propName ] !== 'function' ) {
              if( propName === 'output' ) {
                obj[ propName ] = [ valueL, valueR ]
              }else{
                obj[ propName ] = value
              }
            }else{
              obj[ propName ]( value )
            }
          }else{
            obj[ propName ] = value
          }
        }else if( obj !== undefined ) {
          const propSplit = propName.split('.')
          if( obj[ propSplit[ 0 ] ] !== undefined ) {
            if( propSplit[1] !== undefined ) {
              if( typeof obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ] !== 'function' ) {
                obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ] = value
              }else{
                obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ]( value )
              }
            }
          }else{
            //console.log( 'undefined split property!', id, propSplit[0], propSplit[1], value, obj )
          }
        }
        // XXX double check and make sure this isn't getting sent back to processornode...
        // console.log( propName, value, obj )
        i += propName === 'output' ? 4 : 3
      }
      Gibberish.preventProxy = false
      Gibberish.proxyEnabled = true
    }
  },

  createPubSub( obj ) {
    const events = {}
    obj.on = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
      return obj
    }

    obj.off = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
      return obj
    }

    obj.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
      return obj
    }
  },

  wrap( func, ...args ) {
    const out = {
      action:'wrap',
      value:func,
      // must return objects containing only the id number to avoid
      // creating circular JSON references that would result from passing actual ugens
      args: args.map( v => { return { id:v.id } })
    }
    return out
  },

  // for wrapping upvalues in a dictionary and passing function across thread
  // to be reconstructed.
  // ex; wrapped = fn( ()=> { return Math.random() * test }, { test:20 })
  // syn.note.seq( wrapped, 1/4 )
  fn( fnc, dict={}) {
    const fncstr = fnc.toString()
    const firstBracketIdx = fncstr.indexOf('{')
    const code = fncstr.slice(firstBracketIdx+1, -1 )
    const s = { requiresRender:true, filters:[], fncstr:code, args:[], dict, addFilter( f ) { this.filters.push(f) } }  
    return s
  },

  run( fnc ) { 
    const str = fnc.tostring()
    const idx = str.indexof('=>') + 2
    const code = str.slice( idx ).trim()
    Gibberish.worklet.port.postMessage({ 
      address:'eval',
      code
    })
  },

  export( obj ) {
    obj.wrap = this.wrap
    obj.future = this.future
    obj.Make = this.Make
  },

  getUID() { return uid++ },

  base64 : {
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    // will return a  Uint8Array type
    decodeArrayBuffer: function(input) {
        var bytes = (input.length/4) * 3;
        var ab = new ArrayBuffer(bytes);
        this.decode(input, ab);

        return ab;
    },
    decode: function(input, arrayBuffer) {
      //get last chars to see if are valid
      var lkey1 = this._keyStr.indexOf(input.charAt(input.length-1));		 
      var lkey2 = this._keyStr.indexOf(input.charAt(input.length-2));		 
      var bytes = (input.length/4) * 3;
      if (lkey1 == 64) bytes--; //padding chars, so skip
      if (lkey2 == 64) bytes--; //padding chars, so skip
      var uarray;
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      var j = 0;
      if (arrayBuffer)
          uarray = new Uint8Array(arrayBuffer);
      else
          uarray = new Uint8Array(bytes);
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      for (i=0; i<bytes; i+=3) {	
          //get the 3 octects in 4 ascii chars
          enc1 = this._keyStr.indexOf(input.charAt(j++));
          enc2 = this._keyStr.indexOf(input.charAt(j++));
          enc3 = this._keyStr.indexOf(input.charAt(j++));
          enc4 = this._keyStr.indexOf(input.charAt(j++));

          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;

          uarray[i] = chr1;			
          if (enc3 != 64) uarray[i+1] = chr2;
          if (enc4 != 64) uarray[i+2] = chr3;
      }
      return uarray;	
    }
  }
}

return utilities

}

},{"./external/audioworklet-polyfill.js":148,"genish.js":51}],212:[function(require,module,exports){
const serialize = require('serialize-javascript')

module.exports = function( Gibberish ) {

const replaceObj = function( obj, shouldSerializeFunctions = true ) {
  if( typeof obj === 'object' && obj !== null && obj.id !== undefined ) {
    if( obj.__type !== 'seq' ) { // XXX why?
      return { id:obj.id, prop:obj.prop }
    }else{
      // shouldn't I be serializing most objects, not just seqs?
      return serialize( obj )
    }
  }else if( typeof obj === 'function' && shouldSerializeFunctions === true ) {
    return { isFunc:true, value:serialize( obj ) }
  }
  return obj
}

const makeAndSendObject = function( __name, values, obj ) {
  const properties = {}

  // object has already been sent through messageport...

  for( let key in values ) {
    const alreadyProcessed = (typeof values[ key ] === 'object' && values[ key ] !== null && values[ key ].__meta__ !== undefined) ||
      (typeof values[key] === 'function' && values[ key ].__meta__ !== undefined )

    if( alreadyProcessed ) { 
      properties[ key ] = { id:values[ key ].__meta__.id }
    }else if( Array.isArray( values[ key ] ) ) {
      const arr = []
      for( let i = 0; i < values[ key ].length; i++ ) {
        arr[ i ] = replaceObj( values[ key ][i], false  )
      }
      properties[ key ] = arr
    }else if( typeof values[key] === 'object' && values[key] !== null ){
      properties[ key ] = replaceObj( values[ key ], false )
    }else{
      properties[ key ] = values[ key ]
    }
  }

  let serializedProperties = serialize( properties )

  if( Array.isArray( __name ) ) {
    const oldName = __name[ __name.length - 1 ]
    __name[ __name.length - 1 ] = oldName[0].toUpperCase() + oldName.substring(1)
  }else{
    __name = [ __name[0].toUpperCase() + __name.substring(1) ]
  }

  obj.__meta__ = {
    address:'add',
    name:__name,
    properties:serializedProperties, 
    id:obj.id
  }

  Gibberish.worklet.ugens.set( obj.id, obj )

  Gibberish.worklet.port.postMessage( obj.__meta__ )
}

const doNotProxy = [ 'connected', 'input', 'wrap', 'callback', 'inputNames', 'on', 'off','publish' ]
   
const __proxy = function( __name, values, obj ) {

  if( Gibberish.mode === 'worklet' && Gibberish.preventProxy === false ) {
    makeAndSendObject( __name, values, obj )

    // proxy for all method calls to send to worklet
    const proxy = new Proxy( obj, {
      get( target, prop, receiver ) {
        if( typeof target[ prop ] === 'function' && prop.indexOf('__') === -1 && doNotProxy.indexOf( prop ) === -1 ) {
          const proxy = new Proxy( target[ prop ], {
            apply( __target, thisArg, args ) {

              if( Gibberish.proxyEnabled === true ) {
                const __args = args.map( __value => replaceObj( __value, true ) )

                Gibberish.worklet.port.postMessage({ 
                  address:'method', 
                  object:obj.id,
                  name:prop,
                  args:__args
                })
              }

              const temp = Gibberish.proxyEnabled
              Gibberish.proxyEnabled = false
              const out =  __target.apply( thisArg, args )
              Gibberish.proxyEnabled = temp
              return out
            }
          })
          
          return proxy
        }

        return target[ prop ]
      },
      set( target, prop, value, receiver ) {
        if( doNotProxy.indexOf( prop ) === -1 ) { 
          if( Gibberish.proxyEnabled === true ) {
            const __value = replaceObj( value )

            if( __value !== undefined ) {
              Gibberish.worklet.port.postMessage({ 
                address:'set', 
                object:obj.id,
                name:prop,
                value:__value
              })
            }
          }
        }

        target[ prop ] = value

        // must return true for any ES6 proxy setter
        return true
      }
    })

    // XXX XXX XXX XXX XXX XXX
    // REMEMBER THAT YOU MUST ASSIGN THE RETURNED VALUE TO YOUR UGEN,
    // YOU CANNOT USE THIS FUNCTION TO MODIFY A UGEN IN PLACE.
    // XXX XXX XXX XXX XXX XXX

    return proxy
  }else if( Gibberish.mode === 'processor' && Gibberish.preventProxy === false ) {

    const proxy = new Proxy( obj, {
      //get( target, prop, receiver ) { return target[ prop ] },
      set( target, prop, value, receiver ) {
        let valueType = typeof value
        if( prop.indexOf('__') === -1 && valueType !== 'function' && valueType !== 'object' ) {
          if( Gibberish.processor !== undefined ) { 
            Gibberish.processor.messages.push( obj.id, prop, value )
          }
        }
        target[ prop ] = value

        // must return true for any ES6 proxy setter
        return true
      }
    })

    return proxy
  }

  return obj
}

return __proxy

}

},{"serialize-javascript":231}],213:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":214}],214:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],215:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":214}],216:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":12}],217:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],218:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":4,"has-tostringtag/shams":215}],219:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":215}],220:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":1,"call-bind/callBound":4,"es-abstract/helpers/getOwnPropertyDescriptor":7,"foreach":9,"has-tostringtag/shams":215}],221:[function(require,module,exports){
'use strict'

let MemoryHelper = {
  create( sizeOrBuffer=4096, memtype=Float32Array ) {
    let helper = Object.create( this )

    // conveniently, buffer constructors accept either a size or an array buffer to use...
    // so, no matter which is passed to sizeOrBuffer it should work.
    Object.assign( helper, {
      heap: new memtype( sizeOrBuffer ),
      list: {},
      freeList: {}
    })

    return helper
  },

  alloc( size, immutable ) {
    let idx = -1

    if( size > this.heap.length ) {
      throw Error( 'Allocation request is larger than heap size of ' + this.heap.length )
    }

    for( let key in this.freeList ) {
      let candidate = this.freeList[ key ]

      if( candidate.size >= size ) {
        idx = key

        this.list[ idx ] = { size, immutable, references:1 }

        if( candidate.size !== size ) {
          let newIndex = idx + size,
              newFreeSize

          for( let key in this.list ) {
            if( key > newIndex ) {
              newFreeSize = key - newIndex
              this.freeList[ newIndex ] = newFreeSize
            }
          }
        }

        break
      }
    }

    if( idx !== -1 ) delete this.freeList[ idx ]

    if( idx === -1 ) {
      let keys = Object.keys( this.list ),
          lastIndex

      if( keys.length ) { // if not first allocation...
        lastIndex = parseInt( keys[ keys.length - 1 ] )

        idx = lastIndex + this.list[ lastIndex ].size
      }else{
        idx = 0
      }

      this.list[ idx ] = { size, immutable, references:1 }
    }

    if( idx + size >= this.heap.length ) {
      throw Error( 'No available blocks remain sufficient for allocation request.' )
    }
    return idx
  },

  addReference( index ) {
    if( this.list[ index ] !== undefined ) { 
      this.list[ index ].references++
    }
  },

  free( index ) {
    if( this.list[ index ] === undefined ) {
      throw Error( 'Calling free() on non-existing block.' )
    }

    let slot = this.list[ index ]
    if( slot === 0 ) return
    slot.references--

    if( slot.references === 0 && slot.immutable !== true ) {    
      this.list[ index ] = 0

      let freeBlockSize = 0
      for( let key in this.list ) {
        if( key > index ) {
          freeBlockSize = key - index
          break
        }
      }

      this.freeList[ index ] = freeBlockSize
    }
  },
}

module.exports = MemoryHelper

},{}],222:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],223:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":224,"./lib/tychei":225,"./lib/xor128":226,"./lib/xor4096":227,"./lib/xorshift7":228,"./lib/xorwow":229,"./seedrandom":230}],224:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],225:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],226:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],227:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],228:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],229:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],230:[function(require,module,exports){
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":3}],231:[function(require,module,exports){
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/

'use strict';

// Generate an internal UID to make the regexp pattern harder to guess.
var UID                 = Math.floor(Math.random() * 0x10000000000).toString(16);
var PLACE_HOLDER_REGEXP = new RegExp('"@__(F|R|D|M|S)-' + UID + '-(\\d+)__@"', 'g');

var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
var IS_PURE_FUNCTION = /function.*?\(/;
var IS_ARROW_FUNCTION = /.*?=>.*?/;
var UNSAFE_CHARS_REGEXP   = /[<>\/\u2028\u2029]/g;

var RESERVED_SYMBOLS = ['*', 'async'];

// Mapping of unsafe HTML and invalid JavaScript line terminator chars to their
// Unicode char counterparts which are safe to use in JavaScript strings.
var ESCAPED_CHARS = {
    '<'     : '\\u003C',
    '>'     : '\\u003E',
    '/'     : '\\u002F',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
};

function escapeUnsafeChars(unsafeChar) {
    return ESCAPED_CHARS[unsafeChar];
}

module.exports = function serialize(obj, options) {
    options || (options = {});

    // Backwards-compatibility for `space` as the second argument.
    if (typeof options === 'number' || typeof options === 'string') {
        options = {space: options};
    }

    var functions = [];
    var regexps   = [];
    var dates     = [];
    var maps      = [];
    var sets      = [];

    // Returns placeholders for functions and regexps (identified by index)
    // which are later replaced by their string representation.
    function replacer(key, value) {
        if (!value) {
            return value;
        }

        // If the value is an object w/ a toJSON method, toJSON is called before
        // the replacer runs, so we use this[key] to get the non-toJSONed value.
        var origValue = this[key];
        var type = typeof origValue;

        if (type === 'object') {
            if(origValue instanceof RegExp) {
                return '@__R-' + UID + '-' + (regexps.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Date) {
                return '@__D-' + UID + '-' + (dates.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Map) {
                return '@__M-' + UID + '-' + (maps.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Set) {
                return '@__S-' + UID + '-' + (sets.push(origValue) - 1) + '__@';
            }
        }

        if (type === 'function') {
            return '@__F-' + UID + '-' + (functions.push(origValue) - 1) + '__@';
        }

        return value;
    }

    function serializeFunc(fn) {
      var serializedFn = fn.toString();
      if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
          throw new TypeError('Serializing native function: ' + fn.name);
      }

      // pure functions, example: {key: function() {}}
      if(IS_PURE_FUNCTION.test(serializedFn)) {
          return serializedFn;
      }

      // arrow functions, example: arg1 => arg1+5
      if(IS_ARROW_FUNCTION.test(serializedFn)) {
          return serializedFn;
      }

      var argsStartsAt = serializedFn.indexOf('(');
      var def = serializedFn.substr(0, argsStartsAt)
        .trim()
        .split(' ')
        .filter(function(val) { return val.length > 0 });

      var nonReservedSymbols = def.filter(function(val) {
        return RESERVED_SYMBOLS.indexOf(val) === -1
      });

      // enhanced literal objects, example: {key() {}}
      if(nonReservedSymbols.length > 0) {
          return (def.indexOf('async') > -1 ? 'async ' : '') + 'function'
            + (def.join('').indexOf('*') > -1 ? '*' : '')
            + serializedFn.substr(argsStartsAt);
      }

      // arrow functions
      return serializedFn;
    }

    var str;

    // Creates a JSON string representation of the value.
    // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.
    if (options.isJSON && !options.space) {
        str = JSON.stringify(obj);
    } else {
        str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);
    }

    // Protects against `JSON.stringify()` returning `undefined`, by serializing
    // to the literal string: "undefined".
    if (typeof str !== 'string') {
        return String(str);
    }

    // Replace unsafe HTML and invalid JavaScript line terminator chars with
    // their safe Unicode char counterpart. This _must_ happen before the
    // regexps and functions are serialized and added back to the string.
    if (options.unsafe !== true) {
        str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
    }

    if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0) {
        return str;
    }

    // Replaces all occurrences of function, regexp, date, map and set placeholders in the
    // JSON string with their string representations. If the original value can
    // not be found, then `undefined` is used.
    return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {
        if (type === 'D') {
            return "new Date(\"" + dates[valueIndex].toISOString() + "\")";
        }

        if (type === 'R') {
            return regexps[valueIndex].toString();
        }

        if (type === 'M') {
            return "new Map(" + serialize(Array.from(maps[valueIndex].entries()), options) + ")";
        }

        if (type === 'S') {
            return "new Set(" + serialize(Array.from(sets[valueIndex].values()), options) + ")";
        }

        var fn = functions[valueIndex];

        return serializeFunc(fn);
    });
}

},{}],232:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { pattern: peg$parsepattern },
      peg$startRuleFunction  = peg$parsepattern,

      peg$c0 = function(value) {
        let out = value
        if( options.enclose === true && value.type !== 'group' ) {
          out = { type:'group', values:[ value ] }
        }
        
        return out
      },
      peg$c1 = function(_valuesstart, _valuesend) {
        _valuesend.unshift( _valuesstart )
        const values = _valuesend

        let out
        
        if( values.type === undefined ) {
          // getting nested arrays with feet...
          out = {
            values:Array.isArray( values[0] ) ? values[0] : values,
            type:'group' 
          }
        }else{
          out = values
          out.type = 'group'
        }
       
        addLoc( out, location() )

        return out
      },
      peg$c2 = peg$otherExpectation("group"),
      peg$c3 = "[",
      peg$c4 = peg$literalExpectation("[", false),
      peg$c5 = "]",
      peg$c6 = peg$literalExpectation("]", false),
      peg$c7 = function(values) {
        const out = {
          values,
          type:'group' 
        }
        
        return addLoc( out, location() ) 
      },
      peg$c8 = peg$otherExpectation("term"),
      peg$c9 = function(body) {return body},
      peg$c10 = "(",
      peg$c11 = peg$literalExpectation("(", false),
      peg$c12 = ",",
      peg$c13 = peg$literalExpectation(",", false),
      peg$c14 = ")",
      peg$c15 = peg$literalExpectation(")", false),
      peg$c16 = function(value, pulses, slots, rotation) {
        const result = {
          type:'bjorklund',
          pulses, 
          slots, 
          value,
          'rotation': rotation.length > 0 ? rotation[ 0 ] : null
        }
       
        const withLoc = addLoc( result, location() ) 
        //withLoc.value.uid = withLoc.uid
        return withLoc
      },
      peg$c17 = function(body) { return body },
      peg$c18 = "?",
      peg$c19 = peg$literalExpectation("?", false),
      peg$c20 = function(value) {
        const out = { type:'degrade', value }
        return out
        //return addLoc( out, location() )
      },
      peg$c21 = "*",
      peg$c22 = peg$literalExpectation("*", false),
      peg$c23 = function(value, rate) {
        const r =  { type:'speed', rate, value }

        if( options.addLocations === true ) {
          r.location = {
            start:value.location.start,
            end: rate.location.end
          }
        }
        
        return r 
      },
      peg$c24 = "/",
      peg$c25 = peg$literalExpectation("/", false),
      peg$c26 = function(value, rate) {
        /*const r =  { type:'slow', rate, value }*/

        //if( options.addLocations === true ) {
        //  r.location = {
        //    start:value.location.start,
        //    end: rate.location.end
        //  }
        //}
        //const group = value.type === 'group'
        //  ? value
        const group = { type:'group', values:[ value ] }

        const onestep = {
          type:'onestep',
          values:[ group ]
        }

        for( let i = 0; i < rate.value - 1; i++ ) {
          group.values.push({ type:'rest' })
        }

        addLoc( onestep, location() )
        return onestep
        /*return r */
      },
      peg$c27 = "{",
      peg$c28 = peg$literalExpectation("{", false),
      peg$c29 = "}",
      peg$c30 = peg$literalExpectation("}", false),
      peg$c31 = function(left, right) {
        const result = { 
          'left':{
            type:'group',
            values:left
          }, 
          'right':{
            type:'group',
            values:right,
          },
          type: 'polymeter' 
        }

        addLoc( result.left, location() )
        addLoc( result.right, location() )
        addLoc( result, location() )

        return result
      },
      peg$c32 = "~",
      peg$c33 = peg$literalExpectation("~", false),
      peg$c34 = function() {
       return { type:'rest' }
      },
      peg$c35 = function(start, end) {
        const out = {
          type:'group',
          values: start.map( grp => grp[0] )
        }
        out.values.push( end )

        return addLoc( out, location() )
      },
      peg$c36 = function(value) {
        return value
      },
      peg$c37 = function(body, end) {
        const values = body.map( val => val[0] )

        values.push( end )

        const result = {
          type: 'layers',
          values
        }

        return addLoc( result, location() )
      },
      peg$c38 = "<",
      peg$c39 = peg$literalExpectation("<", false),
      peg$c40 = ">",
      peg$c41 = peg$literalExpectation(">", false),
      peg$c42 = function(body, end) {
        const onestep = {
          type:'onestep',
          values:[body]
        }

        if( end !== null ) {
          onestep.values.push( end )
        }

        return addLoc( onestep, location() )
      },
      peg$c43 = peg$otherExpectation("word"),
      peg$c44 = /^[letter number]/,
      peg$c45 = peg$classExpectation(["l", "e", "t", "t", "e", "r", " ", "n", "u", "m", "b", "e", "r"], false, false),
      peg$c46 = function(value) { 
        return addLoc( { type:typeof value, value, }, location() )
      },
      peg$c47 = function(l) {
        return addLoc( { type:'string', value:text().trim() }, location() )
      },
      peg$c48 = /^[^ [\] {} () \t\n\r '*' '\/' '.' '~' '?' ',' '>' '<' ]/,
      peg$c49 = peg$classExpectation([" ", "[", "]", " ", "{", "}", " ", "(", ")", " ", "\t", "\n", "\r", " ", "'", "*", "'", " ", "'", "/", "'", " ", "'", ".", "'", " ", "'", "~", "'", " ", "'", "?", "'", " ", "'", ",", "'", " ", "'", ">", "'", " ", "'", "<", "'", " "], true, false),
      peg$c50 = function(value) {
        return addLoc( {type:'string', value }, location() )
      },
      peg$c51 = ".",
      peg$c52 = peg$literalExpectation(".", false),
      peg$c53 = "-",
      peg$c54 = peg$literalExpectation("-", false),
      peg$c55 = /^[0-9]/,
      peg$c56 = peg$classExpectation([["0", "9"]], false, false),
      peg$c57 = function() {
        return addLoc( { type:'number', value:+text().trim() }, location() )
      },
      peg$c58 = peg$otherExpectation("whitespace"),
      peg$c59 = /^[ \t\n\r ]/,
      peg$c60 = peg$classExpectation([" ", "\t", "\n", "\r", " "], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$resultsCache = {},

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsepattern() {
    var s0, s1;

    var key    = peg$currPos * 28 + 0,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsefeet();
    if (s1 === peg$FAILED) {
      s1 = peg$parselist();
      if (s1 === peg$FAILED) {
        s1 = peg$parseterm();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselist() {
    var s0, s1, s2, s3, s4, s5;

    var key    = peg$currPos * 28 + 1,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseterm();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsegroup() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key    = peg$currPos * 28 + 2,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c3;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c5;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c2); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseterm() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 3,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsespeed();
      if (s1 === peg$FAILED) {
        s1 = peg$parseslow();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedegrade();
          if (s1 === peg$FAILED) {
            s1 = peg$parselayer();
            if (s1 === peg$FAILED) {
              s1 = peg$parsenumber();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletters();
                if (s1 === peg$FAILED) {
                  s1 = peg$parsepolymeter();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parsegroup();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseletter();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parserest();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseonestep();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseeuclid() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

    var key    = peg$currPos * 28 + 4,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenoteuclid();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseterm();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c12;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c13); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseterm();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s10 = peg$c14;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c15); }
                      }
                      if (s10 === peg$FAILED) {
                        s10 = null;
                      }
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s11 = peg$c12;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c13); }
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s13 = [];
                            s14 = peg$parseterm();
                            while (s14 !== peg$FAILED) {
                              s13.push(s14);
                              s14 = peg$parseterm();
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse_();
                              if (s14 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s15 = peg$c14;
                                  peg$currPos++;
                                } else {
                                  s15 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c15); }
                                }
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c16(s2, s5, s8, s13);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenoteuclid() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 5,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsegroup();
    if (s1 === peg$FAILED) {
      s1 = peg$parsenumber();
      if (s1 === peg$FAILED) {
        s1 = peg$parseword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseletters();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletter();
            if (s1 === peg$FAILED) {
              s1 = peg$parserest();
              if (s1 === peg$FAILED) {
                s1 = peg$parseonestep();
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedegrade() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 6,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotdegrade();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 63) {
        s2 = peg$c18;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c20(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotdegrade() {
    var s0;

    var key    = peg$currPos * 28 + 7,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsenumber();
    if (s0 === peg$FAILED) {
      s0 = peg$parsespeed();
      if (s0 === peg$FAILED) {
        s0 = peg$parseslow();
        if (s0 === peg$FAILED) {
          s0 = peg$parseeuclid();
          if (s0 === peg$FAILED) {
            s0 = peg$parsegroup();
            if (s0 === peg$FAILED) {
              s0 = peg$parseletter();
              if (s0 === peg$FAILED) {
                s0 = peg$parseonestep();
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsespeed() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 8,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotspeed();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c21;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotspeed();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c23(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotspeed() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 9,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsepolymeter();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenumber();
        if (s1 === peg$FAILED) {
          s1 = peg$parselayer();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parsegroup();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseonestep();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseslow() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 10,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotslow();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c24;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotslow();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotslow() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 11,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsepolymeter();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenumber();
        if (s1 === peg$FAILED) {
          s1 = peg$parselayer();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parsegroup();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseonestep();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepolymeter() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    var key    = peg$currPos * 28 + 12,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c27;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c12;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseterm();
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseterm();
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s9 = peg$c29;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c30); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s4, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parserest() {
    var s0, s1;

    var key    = peg$currPos * 28 + 13,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 126) {
      s1 = peg$c32;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c33); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c34();
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefeet() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 14,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsefoot();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsefoot();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenotfoot();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefoot() {
    var s0, s1, s2, s3;

    var key    = peg$currPos * 28 + 15,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsenotfoot();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsenotfoot();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsedot();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotfoot() {
    var s0;

    var key    = peg$currPos * 28 + 16,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parselist();
    if (s0 === peg$FAILED) {
      s0 = peg$parsedegrade();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepolymeter();
        if (s0 === peg$FAILED) {
          s0 = peg$parserest();
          if (s0 === peg$FAILED) {
            s0 = peg$parsespeed();
            if (s0 === peg$FAILED) {
              s0 = peg$parseslow();
              if (s0 === peg$FAILED) {
                s0 = peg$parseeuclid();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsenumber();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseletter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseletters();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseword();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseonestep();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselayer() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var key    = peg$currPos * 28 + 17,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c3;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parsenotlayer();
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c12;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c13); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parsenotlayer();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s8 = peg$c12;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c13); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotlayer();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s7 = peg$c5;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c6); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c37(s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotlayer() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 18,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsespeed();
    if (s1 === peg$FAILED) {
      s1 = peg$parseslow();
      if (s1 === peg$FAILED) {
        s1 = peg$parselist();
        if (s1 === peg$FAILED) {
          s1 = peg$parsenumber();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parseeuclid();
              if (s1 === peg$FAILED) {
                s1 = peg$parsepolymeter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parsegroup();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseletter();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parserest();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseonestep();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseonestep() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key    = peg$currPos * 28 + 19,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      s1 = peg$c38;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenotonestep();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotonestep();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s7 = peg$c40;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c41); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c42(s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotonestep() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 20,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parselist();
    if (s1 === peg$FAILED) {
      s1 = peg$parseeuclid();
      if (s1 === peg$FAILED) {
        s1 = peg$parsepolymeter();
        if (s1 === peg$FAILED) {
          s1 = peg$parseword();
          if (s1 === peg$FAILED) {
            s1 = peg$parsegroup();
            if (s1 === peg$FAILED) {
              s1 = peg$parsenumber();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parselayer();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseword() {
    var s0, s1, s2, s3, s4;

    var key    = peg$currPos * 28 + 21,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c44.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c45); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c43); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseletters() {
    var s0, s1, s2, s3;

    var key    = peg$currPos * 28 + 22,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseletter();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseletter();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseletter() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 23,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (peg$c48.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c50(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedot() {
    var s0;

    var key    = peg$currPos * 28 + 24,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.charCodeAt(peg$currPos) === 46) {
      s0 = peg$c51;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c52); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsequestion() {
    var s0;

    var key    = peg$currPos * 28 + 25,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.charCodeAt(peg$currPos) === 63) {
      s0 = peg$c18;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c19); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenumber() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 26,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c53;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c55.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c51;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c55.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c51;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c55.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c56); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    var key    = peg$currPos * 28 + 27,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = [];
    if (peg$c59.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c59.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }


    const addLocations = options.addLocations
   
    let uid = 0
    const addLoc = function( value, location ) {
      if( addLocations === true ) {
        value.location = location
      }
      
      if( options.addUID === true ) {
        value.uid = uid++
      }

      return value
    }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],233:[function(require,module,exports){
const parse = require('../dist/tidal.js').parse
const query = require('./queryArc.js' ).queryArc
const Fraction = require( 'fraction.js' )

/* The Pattern object is used to parse a pattern
 * a single time and then query it repeatedly, assuming
 * different start and end times for each query. A priority
 * queue is used to sort the events... 
*/
const Pattern = ( patternString, opts ) => {
  if( typeof patternString !== 'string' )
    throw 'You must provide a string to generate the pattern from'

  let __data
  try{
    __data = parse( patternString, opts )
  }catch( e ) {
    throw `We were unable to parse the pattern ${patternString}. ${e.toString()}`
  }

  const ptrn = {
    __rawString: patternString,
    __data,

    events: null,

    __sort( a,b ) { return a.arc.start.compare( b.arc.start ) },
    query( start, duration ) {
      if( typeof start !== 'object' ) start = Fraction( start )
      if( typeof duration !== 'object' ) duration = Fraction( duration )

      ptrn.events = query( 
        ptrn.__data, 
        start,
        duration 
      )
      .sort( ptrn.__sort )

      return ptrn.events
    },

    print() {
      if( ptrn.events !== null ) {
        ptrn.events.forEach( v => 
          console.log( 
            `${v.arc.start.toFraction()} - ${v.arc.end.toFraction()}: [ ${v.value.toString()} ]` 
          ) 
        )
      }else{
        console.log( 'No events have been generated from the pattern; have you queried it yet?' )
      }
    }
  }

  return ptrn
}

module.exports = Pattern

},{"../dist/tidal.js":232,"./queryArc.js":234,"fraction.js":10}],234:[function(require,module,exports){
const Fraction = require( 'fraction.js' )
const util     = require( 'util' )
const bjork    = require( 'bjork' ) 
const log      = util.inspect
const srand    = require( 'seedrandom' )

const rnd = function( phase ) {
  //console.log( 'phase', phase.toFraction() )
  return new srand( phase.toFraction() )()
}

/* queryArc
 *
 * Generates events for provided pattern, starting at
 * an initial phase, subdivides queries in individual 
 * cycles if duration of query is greater than 1 cycle.
 * Filters events outside of the the intended range. 
 * Remaps events to be relative to the initial phase.
 */
const queryArc = function( pattern, phase, duration ) {
  const start         = phase.clone(),
        end           = start.add( duration ),
        // get phase offset if scheduling begins in middle of event arc
        adjustedPhase = adjustPhase( phase, getPhaseIncr( pattern ), end )

  let eventList

  // if we're querying an arc that is less than or equal to one cycle in length..
  if( duration.valueOf() <= 1 ) {
    eventList = processPattern( 
      pattern, 
      duration, 
      adjustedPhase, 
      null, 
      null, 
      false//shouldRemap( pattern ) 
    )
  }else{
    // for longer arcs we need to query one cycle at a time
    eventList = []
    let count = 0
    for( let i = adjustedPhase.valueOf(); i < adjustedPhase.add( duration ).valueOf(); i++ ) {
      eventList = eventList.concat( 
        processPattern( 
          pattern, 
          Fraction(1),
          adjustedPhase.add( count++ ), 
          null, 
          null, 
          false
        )
      )
    }
  }

  // prune any events that fall before our start phase or after our end phase
  eventList = eventList.filter( evt => {
    return (evt.arc.start.valueOf() >= start.valueOf() 
        && evt.arc.start.valueOf()  <  end.valueOf() ) 
  })
  // remap events to make their arcs relative to initial phase argument
  .map( evt => {
    evt.arc.start = evt.arc.start.sub( start )
    evt.arc.end   = evt.arc.end.sub( start )
    return evt
  })
 
  //console.log( 'eventList:', log(eventList,{depth:4}) )
  return eventList
}

// if an event is found that represents a pattern (as opposed to a constant) this function
// is called to query the pattern and map any generated events to the appropriate timespan
const processPattern = ( pattern, duration, phase, phaseIncr=null, override = null, shouldRemapArcs=false ) => {
  //if( phaseIncr !== null ) debugger
  const state = []
  state.phase = phase
  let events = handlers[ pattern.type ]( 
    state, 
    pattern, 
    /*shouldReset( pattern ) === true ? Fraction(0) :*/ phase.clone(), 
    // XXX this is confusing. we are getting around a problem
    // with polymeters where duplicate events are generated by
    // not passing a phaseIncr... it's not needed since there's an
    // override. But this doesn't seem like correct way to solve
    // this problem and will probably cause future problems...
    phaseIncr !== null ? duration.div( phaseIncr ) : duration, 
    override 
  )

  // if needed, remap arcs for events
  if( shouldRemapArcs === true ) {
    if( phaseIncr === null ) phaseIncr = getPhaseIncr( pattern )
    events = events.map( v => ({
      value: v.value,
      arc: getMappedArc( v.arc, phase.clone(), phaseIncr )
    }) )
  }
 
  return events 
}
// placeholder for potentially adding more goodies (parent arc etc.) later
const Arc = ( start, end ) => ({ start, end })

const shouldNotRemap = ['polymeter', 'onestep']
const shouldRemap = pattern => shouldNotRemap.indexOf( pattern.type ) === -1

// XXX seems like getMappedArc should be changed to what onestep and group are now using?
// would that change work with how getMappedArc is used in processPattern?

// map arc time values to appropriate durations
const getMappedArc = ( arc, phase, phaseIncr ) => {
  let mappedArc
  
  if( phase.mod( phaseIncr ).valueOf() !== 0 ) {
    mappedArc = Arc( 
      arc.start.mul( phaseIncr ).add( phase ), 
      arc.end.mul( phaseIncr ).add( phaseIncr.mod( phase ) ) 
    )
  }else{
    mappedArc = Arc( 
      arc.start.mul( phaseIncr ).add( phase ), 
      arc.end.mul( phaseIncr ).add( phase ) 
    )
  }
  
  return mappedArc
}

// if initial phase is in the middle of an arc, advance to the end by calculating the difference
// between the current phase and the start of the next arc, and increasing phase accordingly.
const adjustPhase = ( phase, phaseIncr, end ) => phase.valueOf() === 0 
  ? Fraction(0) 
  : phase.sub( phase.mod( phaseIncr ) )

// check to see if phase should advance to next event, or, if next event is too far in the future, to the
// end of the current duration being requested.
const advancePhase = ( phase, phaseIncr, end ) => phase + phaseIncr <= end ? phase.add( phaseIncr ) : end 

// calculate the duration of the current event being processed.
const calculateDuration = ( phase, phaseIncr, end ) => phase + phaseIncr <= end ? phaseIncr : end.sub( phase )

// get an index number for a pattern for a particular phase
const getIndex = ( pattern, phase ) => {
  let idx = 0
  if( pattern.options !== undefined ) {
    if( pattern.options.overrideIncr === true ) {
      idx = phase.div( pattern.options.incr ).mod( pattern.values.length ).floor()
    }
  }else{
    // default list behavior
    idx = phase.mul( Fraction( pattern.values.length ) ).mod( pattern.values.length ).floor()
  }

  return idx.valueOf()
}

// in addition to 'fast', phase resets are also necessary when indexing subpatterns,
// which are currently arrays with no defined .type property, hence the inclusion of
// undefined in the array below
const shouldResetPhase = [ 'repeat', undefined, 'group', 'layers' ] 

// XXX does these need to look at all parents recursively? Right now we're only using one generation...
const shouldReset = pattern => {
  const reset = shouldResetPhase.indexOf( pattern.type ) > -1 
  const parent = pattern.parent !== undefined && shouldResetPhase.indexOf( pattern.parent.type ) > -1

  return reset && parent
}

// I assume this will need to be a switch on pattern.type in the future...
const getPhaseIncr = pattern => {
  let incr

  switch( pattern.type ) {
    case 'polymeter': incr = Fraction( 1, pattern.left.values.length ); break;
    case 'number': case 'string': incr = Fraction( 1 ); break;
    case 'onestep': incr = null; break;
    default:
      if( pattern.values === undefined ){
        incr = Fraction(1)
      } else {
        incr = Fraction( 1, pattern.values.length )
        //let len = 0
        //pattern.values.forEach( v => len += v.type === 'slow' ? v.rate.value : 1 )
        //incr = Fraction( 1, len ) 
      }
      break;

  }

  return incr
}

const handlers = {
  rest( state ) { return state },

  // standard lists e.g. '0 1 2 3' or '[0 1 2]'
  group( state, pattern, phase, duration, overrideIncr=null ) {
    const start     = phase.clone(),
          end       = start.add( duration ),
          phaseIncr = overrideIncr === null 
            ? getPhaseIncr( pattern ) 
            : overrideIncr
          
    let eventList = []

    //console.log( 
    //  'type:',  pattern.type, 
    //  'phase:', phase.toFraction(),
    //  'incr:',  phaseIncr.toFraction(),
    //  'dur:',   duration.toFraction()
    //)
    
    while( phase.compare( end ) < 0 ) {
      // if pattern is a list, read using current phase, else read directly
      const member = Array.isArray( pattern.values ) === true 
        ? pattern.values[ getIndex( pattern, phase ) ] 
        : pattern.value

      // get duration of current event being processed
      const dur = calculateDuration( phase, phaseIncr, end )

      // if value is not a numeric or string constant (if it's a pattern)...
      if( member === undefined || (isNaN( member.value ) && typeof member.value !== 'string') ) {
        // query the pattern and remap time values appropriately 
        if( member !== undefined ) member.parent = pattern
        //console.log( 'processing ', pattern.type, member.type, dur.toFraction(),  phaseIncr.toFraction() )
        const events = processPattern( 
          member, 
          Fraction(1), 
          //member.type !== 'slow' ? Fraction(0) : phase.clone(), 
          Fraction(0),
          null, //getPhaseIncr(member),
          null, 
          false//shouldRemap( member )
        )
        .map( evt => {
          evt.arc.start = evt.arc.start.mul( dur ).add( phase )
          evt.arc.end   = evt.arc.end.mul( dur ).add( phase )
          return evt
        })

        eventList = eventList.concat( events )
      }else{
        // XXX shouldn't we just process all patterns???
        // member does not need further processing, so add to event list
        const evt = { 
          value:member.value, 
          arc:Arc( phase, phase.add( dur ) ),
        }
        if( member.uid !== undefined ) evt.uid = member.uid 

        eventList.push( evt )
      }

      // assuming we are starting / ending at a regular phase increment value...
      
      if( phase.mod( phaseIncr ).valueOf() === 0 ) {
        phase = advancePhase( phase, phaseIncr, end )
      }else{
        // advance phase to next phase increment
        phase = phase.add( phaseIncr.sub( phase.mod( phaseIncr ) ) ) 
      }
    }

    // prune any events that fall before our start phase or after our end phase
    eventList = eventList.filter( evt => {
      return evt.arc.start.valueOf() >= start.valueOf() && evt.arc.start.valueOf() < end.valueOf()
    })
   
    return state.concat( eventList )
  },

  bjorklund( state, pattern, phase, duration ) {
    const onesAndZeros = bjork( pattern.pulses.value, pattern.slots.value )
    let rotation = pattern.rotation !== null ? pattern.rotation.value : 0
    
    // rotate right
    if( rotation > 0 ) {
      while( rotation > 0 ) {
        const right = onesAndZeros.pop()
        onesAndZeros.unshift( right )
        rotation--
      }
    } else if( rotation < 0 ) {
      // rotate left
      while( rotation < 0 ) {
        const left = onesAndZeros.shift()
        onesAndZeros.push( left )
        rotation++
      }
    }
    
    const slotDuration = duration.div( pattern.slots.value )
    const valueIsValue = pattern.value.type === 'number' || pattern.value.type === 'string'

    const events = onesAndZeros.map( ( shouldInclude, i, arr ) => {
      let evt
      // don't process unless an actual event will be included...
      if( shouldInclude === 1 ) {
        const startPhase = phase.add( slotDuration.mul( i ) )
        evt = {
          shouldInclude,
          // XXX is there a case where we should use more than 
          // the first value by querying the value pattern?
          value:valueIsValue ? pattern.value : processPattern( pattern.value, slotDuration, startPhase )[0].value,
          arc:Arc( startPhase, startPhase.add( slotDuration ) ) 
        }
      }else{
        evt = { shouldInclude }
      }

      return evt
    })
    .filter( evt => {
      let shouldInclude = evt.shouldInclude

      // needed to pass tests and is also cleaner...
      delete evt.shouldInclude
      return shouldInclude === 1
    })

    events.forEach( evt => {
      evt.uid = pattern.value.uid
      state.push( evt ) 
    })
    
    return state
  },

  onestep( state, pattern, phase, duration ) {
    pattern.values.forEach( group => {
      // initialize, then increment. this assumes that the pattern will be parsed once,
      // and then the resulting data structure will be queried repeatedly, enabling the use
      // of state.
      group.count = group.count === undefined ? 0 : group.count + 1

      const subpattern = group.values[ group.count % group.values.length ]
      const dur = duration.valueOf() <= 1 ? Fraction(1) : duration 
      const durDiff = duration.mul( dur ) 

      const events = processPattern( 
        subpattern, 
        dur,
        Fraction(0), 
        null,
        null,null,true
      ).map( evt => {
        evt.arc.start = evt.arc.start.mul( duration ).add( phase )
        evt.arc.end = evt.arc.end.mul( duration ).add( phase )

        return evt
      })  

      state.push( ...events )
    })

    return state
  },

  number( state, pattern, phase, duration ) {
    //if( phase.valueOf() === 0 ) {
      const evt = { arc:Arc( phase, phase.add( duration ) ), value:pattern.value }
      if( pattern.uid !== undefined ) evt.uid = pattern.uid
      state.push(evt)
    //}
    return state 
  },

  string( state, pattern, phase, duration ) {
    const evt = { arc:Arc( phase, phase.add( duration ) ), value:pattern.value }
    if( pattern.uid !== undefined ) evt.uid = pattern.uid
    state.push(evt)
    return state 
  },

  degrade( state, pattern, phase, duration ) {
    // attempt to seed random... rnd( state.phase )
    const rnum = Math.random()
    //console.log( 'rnd:', rnum, state.phase.toFraction() )
    if( rnum > .5 ) {
      const evt = { 
        arc:Arc( phase, phase.add( duration ) ), 
        value:pattern.value.value
      }

      //console.log( 'adding', evt )

      if( pattern.uid !== undefined ) evt.uid = pattern.uid

      state.push( evt )
    }

    return state 
  },

  polymeter( state, pattern, phase, duration ) {
    pattern.left.parent = pattern.right.parent = pattern

    const incr  = Fraction( 1, pattern.left.values.length )
    const left  = processPattern( pattern.left, duration, phase.clone(), duration, incr, false )

    pattern.right.options = { overrideIncr: true, incr }
    const right = processPattern( pattern.right, duration, phase.clone(), duration, incr, false ) 

    return state.concat( left ).concat( right )
  },

  layers( state, pattern, phase, duration ) {
    //pattern.left.parent = pattern.right.parent = pattern
    for( const group of pattern.values ) {
      const incr = getPhaseIncr( group )
      const events = processPattern( group, duration.clone(), phase.clone(), duration, null, false)
      // not sure why excess events are generated, but they need to be filtered...
      .filter( evt => 
        evt.arc.start.valueOf() >= phase.valueOf() 
        && evt.arc.start.valueOf() < phase.add( duration ).valueOf()
      )
      
      //console.log( 'group:', util.inspect( group, { depth:3 }) )
      //console.log( 'state:', util.inspect( events, { depth:3 }))
      state = state.concat( events )
    }

    return state
  },

  slow( state, pattern, phase, duration ) {
    const speed = pattern.rate.value

    let events
    //if( phase.valueOf() % speed === 0 ) {
      // XXX why do we need this edge case?
      const phaseDiff = phase.sub( phase.div( speed ) )

      if( pattern.value.type !== 'layers' ) {
        //events = queryArc(
        //  pattern.value,
        //  phase.div( speed ),
        //  duration.div( speed )
        //)
        //console.log( duration, phase, speed )
        //events = processPattern(
        //  pattern.value,
        //  duration.mul( speed ),
        //  phase.div( speed )
        //)       
        events = queryArc(
          pattern.value,
          Fraction(0),
          duration.div( speed ) 
        ).map( evt => {
          const diff = evt.arc.end.sub( evt.arc.start )
          evt.arc.start = evt.arc.start.add( phase )
          evt.arc.end   = evt.arc.start.add( duration.mul( speed ) ).add( phase )
          //console.log( diff, duration.mul( speed ), evt.arc.start, evt.arc.end )
          return evt
        })
      }else{
        events = handlers.layers( state, pattern.value, phase.div( speed ), duration.div( speed ) )
      }

      //console.log( log( events, { depth:3 }), phase.add( duration ).toFraction() )
      //if( pattern.value.type === 'group' ) {
      //  events = events.map( evt => {
      //    evt.arc.start = evt.arc.start.mul( speed )
      //    evt.arc.end   = evt.arc.end.mul( speed )
      //    return evt
      //  })
      //}
      //events = events.map( evt => {
      //  evt.arc.start = evt.arc.start.add( phaseDiff )
      //  evt.arc.end   = evt.arc.end.add( phaseDiff )
      //  //evt.arc.start = evt.arc.start.add( phase )
      //  //evt.arc.end   = evt.arc.end.add( phase )
      //  return evt
      //})
      //.filter( evt => evt.arc.start.valueOf() < phase.add( duration ).valueOf() )
    //}
    //console.log( 'slow:', log( events, { depth:3 }), phase.add( duration ).toFraction() )

    if( events !== undefined ) state = state.concat( events )

    return state
  },

//const processPattern = ( pattern, duration, phase, phaseIncr=null, override = null, shouldRemapArcs=true ) => {
  speed( state, pattern, phase, duration ) {
    // the general process of increasing the speed of a pattern is to query
    // for a longer duration according to the speed, and the scale the resulting
    // events.
    
    // following explanation from yaxu for how subpatterns work with rates...
    // https://talk.lurk.org/channel/tidal?msg=z5ck73H9EvxQwMqq6 
    // re: pattern a*[2 4 8]
    // "Anyway what happens in this kind of situation is that it splits the cycle in three, 
    // each a window on what would have happened if you'd have sped things up by the given number
    // so for the first third you'd get a third of two a's
    // for the second third you'd get the second third of four a's..."
    
    const speed = pattern.rate.value
    const events = queryArc(
      pattern.value,
      Fraction(0),
      duration.mul( speed ) 
    ).map( evt => {
      evt.arc.start = evt.arc.start.div( speed ).add( phase )
      evt.arc.end   = evt.arc.end.div( speed ).add( phase )
      return evt
    })

    // XXX account for having a speeds pattern!!!!
    /*
    
    const incr = Fraction(1, speeds.length)
    const speeds = queryArc( pattern.rate, Fraction(0), Fraction(1) )

    for( let i = 0; i < speeds.length; i++ ) {
      let speed = speeds[ i ].value

      if( pattern.operator === '*' ) {
        //events = queryArc( 
        //  pattern.value,
        //  phase.clone(), //Fraction( 0 ), 
        //  Fraction( speed ).mul( duration )
        //)
        events = processPattern(
          pattern.value,
          duration.mul( speed ),
          phase.clone()//Fraction( speed ).mul( duration )
          //phase.clone() 
        )
          
        // remap events to correct time spans
        .map( evt => {
          evt.arc.start = evt.arc.start.div( speed )//.add( phase )
          evt.arc.end   = evt.arc.end.div( speed )//.add( phase )
          return evt
        })
        //.filter( evt => 
        //  evt.arc.start.compare( incr.mul( i ) ) >= 0 
        //    && evt.arc.start.compare( incr.mul( i+1 ) ) < 0 
        //))
        // add to previous events
        .concat( events )
      }else{
        speed = 1/speed
        //console.log( 'phase:', phase.mul( speed ) )
        events = processPattern( 
          pattern.value, 
          duration.mul( Fraction( speed ) ), 
          phase.mul( speed ),
          getPhaseIncr( pattern ).mul( speed ), null, false
        )
        //console.log( 'events:', log( events, { depth:4 } ) )
        // remap events to correct time spans
        events.map( evt => {
          if( evt.arc.start.valueOf() !== 0 ) {
            // XXX I don't know why this is necessary but it gets rid of a off-by-one error
            evt.arc.start = evt.arc.start.sub( phase.div( 1/speed ) )
          }

          // also, does the event length need to be adjusted? might as well...
          //console.log( 'end:', evt.arc.end.toFraction(), phase.toFraction(), speed )
          evt.arc.end = evt.arc.end.mul( 1/speed )//.mul( 1/speed )
          //evt.arc.end.sub( phase.div( 1/speed ) ).add( 1/speed - 1)

          return evt
        })
        // remove events don't fall in the current window
        .filter( evt => 
          evt.arc.start.compare( incr.mul(i) ) >= 0 && 
          evt.arc.start.compare( incr.mul(i+1) ) <= 0 
        )
        // add to previous events
        .concat( events )
      }
    }*/

    //console.log( 'events:', log( events, { depth:4 }) )
    return state.concat( events )
  },
}

module.exports.queryArc = queryArc

},{"bjork":2,"fraction.js":10,"seedrandom":223,"util":237}],235:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],236:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":218,"is-generator-function":219,"is-typed-array":220,"which-typed-array":238}],237:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":235,"./support/types":236,"_process":222,"inherits":217}],238:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":1,"call-bind/callBound":4,"es-abstract/helpers/getOwnPropertyDescriptor":7,"foreach":9,"has-tostringtag/shams":215,"is-typed-array":220}],239:[function(require,module,exports){
const Audio = require("gibber.audio.lib"),
  Gibber = require("gibber.core.lib");
chroma = require("chroma-js");
const pallette = chroma.brewer.Set1;
const set1Scale = chroma.scale(pallette);
console.log("pallette: ", pallette);

// console.log('Chroma: ', Chroma);
for (const key in Audio) {
  if (Object.hasOwnProperty.call(Audio, key)) {
    const element = Audio[key];
    // console.log('key: ', key, (typeof element));
  }
}
const contents = document.createElement("div");
document.body.appendChild(contents);
contents.classList.add("contents");

const leftSide = document.createElement("div");
contents.appendChild(leftSide);
leftSide.classList.add("left-side");
const rightSide = document.createElement("div");
contents.appendChild(rightSide);
rightSide.classList.add("right-side");
const rightSide2 = document.createElement("div");
document.body.appendChild(rightSide2);
rightSide2.classList.add("right-side2");

console.log("Audio: ", Audio);
const instrumentsCategories = Audio.Presets.instruments;
console.log("instrumentsCategories: ", instrumentsCategories);
var categoriesSize = Object.keys(instrumentsCategories).length;
let counter = -1;
let counter2 = -1;
const descriptionsDisplays = [];
const instrumentParameters = {};
const allInstrumentParameters = new Set();
const allInstrumentParameters2 = {};
const allInstruments = {};
const allInstruments2 = {};
const colorsPerCategory = {};

const allPosibleInstrumentsDisplay = document.createElement("div");
allPosibleInstrumentsDisplay.style.position = "absolute";
allPosibleInstrumentsDisplay.style.top = "0";
allPosibleInstrumentsDisplay.style.left = "0";

let allPosibleInstruments = [];
document.body.appendChild(allPosibleInstrumentsDisplay);

for (const category in instrumentsCategories) {
  if (Object.hasOwnProperty.call(instrumentsCategories, category)) {
    counter++;
    const instrumentsInCategory = instrumentsCategories[category];
    const instrumentInCategoryKeys = Object.keys(instrumentsInCategory);

    const iLength = instrumentInCategoryKeys.length;
    // console.log('key: ', key);
    // console.log('element: ', Object.keys(element));
    const categoryDiv = document.createElement("div");
    categoryDiv.className = "instrument-category";
    const categoryTitle = document.createElement("h3");
    categoryTitle.className = "category-name";
    categoryTitle.onclick = () => {
      rightSide.innerHTML = "";
      claerAllDescriptions();
    };
    categoryTitle.innerHTML = `${counter}-${category}---${iLength}`;
    categoryDiv.appendChild(categoryTitle);
    const instrumentDescription = document.createElement("div");
    const bgColor = set1Scale(counter / categoriesSize)
      .darken(2)
      .hex();
    colorsPerCategory[category] = bgColor;
    categoryDiv.style.backgroundColor = bgColor;
    const paramsSet = new Set();
    instrumentParameters[category] = paramsSet;
    for (let i = 0; i < iLength; i++) {
      counter2++;
      const instrument = instrumentInCategoryKeys[i];
      const instrumentObject = instrumentsInCategory[instrument];
      const paramDiv = document.createElement("span");
      paramDiv.classList.add("param");
      const uniqueID = category + instrument;
      allPosibleInstruments.push(`s = ${category}('${instrument}')`);
      allInstruments[uniqueID] = {
        category,
        instrument,
        bgColor,
        paramDiv,
      };
      // paramDiv.classList.add(category);
      // paramDiv.classList.add(key);
      const paramName = document.createElement("span");
      paramName.innerHTML = instrument;
      allInstruments2[instrument] = paramDiv;
      paramDiv.appendChild(paramName);
      paramDiv.onclick = () => {
        onParamaClick(category, instrument);
      };
      const paramValue = document.createElement("span");
      for (const property in instrumentObject) {
        if (Object.hasOwnProperty.call(instrumentObject, property)) {
          const value = instrumentObject[property];
          paramsSet.add(property);
          allInstrumentParameters.add(property);
          if (allInstrumentParameters2[property]) {
            allInstrumentParameters2[property].typeof.add(typeof value);
            allInstrumentParameters2[property].categories.add(category);
            allInstrumentParameters2[property].keys.add(instrument);
          } else {
            allInstrumentParameters2[property] = {
              property,
              typeof: new Set([typeof value]),
              categories: new Set([category]),
              keys: new Set([instrument]),
            };
          }

          const propertyDiv = document.createElement("div");
          propertyDiv.className = "property";
          const propertyName = document.createElement("span");
          propertyName.innerHTML = property + ".";
          propertyDiv.appendChild(propertyName);
          const propertyValue = document.createElement("span");
          propertyValue.innerHTML = value;
          propertyDiv.appendChild(propertyValue);
          paramDiv.appendChild(propertyDiv);
        }
      }
      paramDiv.appendChild(paramValue);
      categoryDiv.appendChild(paramDiv);
    }
    categoryDiv.appendChild(instrumentDescription);
    descriptionsDisplays.push(instrumentDescription);
    leftSide.appendChild(categoryDiv);
    // console.log('instrumentDiv: ', instrumentDiv);
  }
}
// console.log("allInstruments: ", allInstruments);
allPosibleInstruments = allPosibleInstruments.join("<br>");
console.log("allPosibleInstruments: ", allPosibleInstruments);
// allPosibleInstrumentsDisplay.innerHTML = allPosibleInstruments;
const claerAllDescriptions = () => {
  descriptionsDisplays.forEach((display) => {
    display.innerHTML = "";
  });
};
const onParamaClick = (category, instrument) => {
  document.querySelectorAll(".property").forEach((element) => {
    element.onclick = null;
  });
  claerAllDescriptions();
  const bgColor = allInstruments[category + instrument].bgColor;
  const properties = instrumentsCategories[category][instrument];
  let indesOfAAAA = Object.keys(instrumentsCategories[category]).indexOf(
    instrument
  );
  let indesOfBBB = Object.keys(instrumentsCategories).indexOf(category);
  let string = `<div style="background-color:${bgColor};"><span>${indesOfBBB}/${
    Object.keys(instrumentsCategories).length
  }-${category}</span>----<span>${indesOfAAAA}/${
    Object.keys(instrumentsCategories[category]).length
  }-${instrument}</span></div>`;
  allInstrumentParameters.forEach((property) => {
    const value = properties[property];
    const element2 = allInstrumentParameters2[property];
    let categoriesColumn = "";
    Object.keys(instrumentsCategories).forEach((category4Property) => {
      const hasCategory4Property = element2.categories.has(category4Property);
      categoriesColumn += `<div style="border:1px solid ${
        category === category4Property && hasCategory4Property && value
          ? "#aaa"
          : "#555"
      };display:inline-block;width:10px;height:10px;color:#555;background-color:${
        hasCategory4Property
          ? colorsPerCategory[category4Property]
          : "transparent"
      };">&nbsp;</div>`;
    });
    const columnProperty2 = `<span class="column tiny">${element2.categories.size}</span>`;
    const columnProperty3 = `<span class="column tiny">${element2.keys.size}</span>`;
    const columnProperty = `<span class="column small property" onclick="onInstrumentParamClick(this)">${property}</span>`;
    const columnTypeOf = `<span class="column small">${
      element2.typeof ? Array.from(element2.typeof).toString() : "-"
    }</span>`;
    const columnElementValue = `<span class="column element">${
      value ? value : ""
    }</span> `;
    string += `<div>${columnProperty} ${columnTypeOf} ${columnElementValue}${categoriesColumn}${columnProperty2}${columnProperty3}</div>`;
  });
  rightSide.innerHTML = string;
};
onParamaClick("Drums", "earshred");

onInstrumentParamClick = function (e) {
  const parameter = e.textContent;
  console.log("parameter: ", parameter);
  const asdasd = allInstrumentParameters2[parameter];

  console.log("asdasd: ", asdasd);
  rightSide2.innerHTML = Array.from(asdasd.categories)
    .map(
      (category) =>
        `<span style="border:1px solid white;background-color:${colorsPerCategory[category]}">${category}</span>`
    )
    .join("");
  for (const key in allInstruments2) {
    if (Object.hasOwnProperty.call(allInstruments2, key)) {
      const element = allInstruments2[key];
      element.classList.remove("highlight");
    }
  }
  Array.from(asdasd.keys).forEach((key) => {
    console.log("key: ", key);
    const asdasdascxxxx = allInstruments2[key];
    console.log("asdasdascxxxx: ", asdasdascxxxx);
    asdasdascxxxx.classList.add("highlight");
  });
};
function one() {
  let aaaaa = Object.keys(allInstruments);

  setInterval(() => {
    const randomIndex = (aaaaa.length * Math.random()) | 0;
    const randomKey = aaaaa.splice(randomIndex, 1);
    if (aaaaa.length === 0) {
      aaaaa = Object.keys(allInstruments);
    }
    const randomElement = allInstruments[randomKey];
    onParamaClick(randomElement.category, randomElement.instrument);
  }, 100);
}

function two() {
  let index = -1;
  const keys = Object.keys(allInstruments);
  const length = keys.length;
  setInterval(() => {
    index++;
    const nextKey = keys[index % length];
    const nextElement = allInstruments[nextKey];
    onParamaClick(nextElement.category, nextElement.instrument);
  }, 100);
}
// two();
// one();
console.log("counter2: ", counter2);
console.log(Object.keys(allInstruments).length);

},{"chroma-js":6,"gibber.audio.lib":92,"gibber.core.lib":134}]},{},[239])


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iam9yay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hyb21hLWpzL2Nocm9tYS5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZnJhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hYnMuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2FjY3VtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hY29zLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hZC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hZHNyLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hbmQuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2FzaW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2F0YW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2F0dGFjay5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYmFuZy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYm9vbC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY2VpbC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY2xhbXAuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2Nvcy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY291bnRlci5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY3ljbGUuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RhdGEuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RjYmxvY2suanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RlY2F5LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9kZWxheS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZGVsdGEuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2Rpdi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZW52LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9lcS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZXhwLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9leHRlcm5hbC9hdWRpb3dvcmtsZXQtcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2V4dGVybmFsL3JlYWxtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZm9sZC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ2VuLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ndC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ3RlLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ndHAuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2hpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2lmZWxzZWlmLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9pbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2x0LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9sdGUuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2x0cC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbWF4LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9tZW1vLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9taW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL21peC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbW9kLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9tc3Rvc2FtcHMuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL210b2YuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL211bC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbmVxLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ub2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbm90LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9wYW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3BhcmFtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9wZWVrLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9waGFzb3IuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Bva2UuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Bvdy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcm91bmQuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3NhaC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3NlcS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2luLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9zbGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc3ViLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9zd2l0Y2guanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Q2MC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvdGFuLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy90YW5oLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy90cmFpbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvdXRpbGl0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy93aW5kb3dzLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy93cmFwLmpzIiwibm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9hbmFseXNpcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2F1ZGlvLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvYmlub3BzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvYnVzc2VzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvY2xvY2suanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9kcnVtcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2VmZmVjdHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9lbnNlbWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2VudmVsb3Blcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2V4dGVybmFsL3JlYWxtLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvZXh0ZXJuYWwvdHVuZS1hcGktb25seS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2ZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9mcmVlc291bmQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9nZW4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9pbnN0cnVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL21ha2UuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9vc2NpbGxhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL2J1czJfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvY2hvcnVzX3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL2NvbXBsZXhfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZGVsYXlfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZGlzdG9ydGlvbl9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9kcnVtc19wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9lZHJ1bXNfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZmxhbmdlcl9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9mbV9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9oYXRfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMva2lja19wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9tb25vc3ludGhfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvbXVsdGlzYW1wbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9yZXZlcmIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL3NuYXJlX3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL3NvdW5kZm9udF9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9zeW50aF9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvdGhlb3J5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvdWdlbi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3V0aWxpdHkuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy93YXZlT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3dhdmVQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5jb3JlLmxpYi9qcy9ldWNsaWQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL2hleC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuY29yZS5saWIvanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3NlcS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuY29yZS5saWIvanMvc3RlcHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5jb3JlLmxpYi9qcy90cmlnZ2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2FuYWx5c2lzL2FuYWx5emVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvYW5hbHlzaXMvYW5hbHl6ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvYW5hbHlzaXMvZm9sbG93LmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2FuYWx5c2lzL3NpbmdsZXNhbXBsZWRlbGF5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL2FkLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL2Fkc3IuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9lbnZlbG9wZXMvZW52ZWxvcGVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL3JhbXAuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9leHRlcm5hbC9wcmlvcml0eXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZXh0ZXJuYWwvcmVhbG0uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9hbGxwYXNzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9iaXF1YWQuZHNwLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9jb21iZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9kaW9kZUZpbHRlclpERi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9maWx0ZXIyNC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvZmlsdGVycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvbGFkZGVyLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvc3ZmLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvYml0Q3J1c2hlci5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2J1ZmZlclNodWZmbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvY2hvcnVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvZGVsYXkuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9kaXN0b3J0aW9uLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2VmZmVjdC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2VmZmVjdHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9mbGFuZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvZnJlZXZlcmIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9yaW5nTW9kLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvdHJlbW9sby5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L3ZpYnJhdG8uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC93YXZlZm9sZGVyLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvY2xhcC5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9jb21wbGV4LmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2NvbmdhLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvY293YmVsbC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2ZtLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2hhdC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2luc3RydW1lbnQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9pbnN0cnVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2thcnBsdXNzdHJvbmcuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9raWNrLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvbW9ub3N5bnRoLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL211bHRpc2FtcGxlci5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9wb2x5TWl4aW4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9wb2x5dGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zYW1wbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvc25hcmUuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zb3VuZGZvbnQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zeW50aC5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy90b20uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9taXNjL2Jpbm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL21pc2MvYnVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvbWlzYy9idXMyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvbWlzYy9tb25vcHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9taXNjL3Bhbm5lci5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL21pc2MvdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL2Jyb3dubm9pc2UuZHNwLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvb3NjaWxsYXRvcnMvZm1mZWVkYmFja29zYy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL29zY2lsbGF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvb3NjaWxsYXRvcnMvcGlua25vaXNlLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL3BvbHlibGVwLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL3dhdmV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3NjaGVkdWxpbmcvc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvc2NoZWR1bGluZy9zZXEyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvc2NoZWR1bGluZy9zZXF1ZW5jZXIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9zY2hlZHVsaW5nL3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvdWdlbi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3dvcmtsZXRQcm94eS5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LWhlbHBlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9zZXJpYWxpemUtamF2YXNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aWRhbC5wZWdqcy9kaXN0L3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL3RpZGFsLnBlZ2pzL3NyYy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3RpZGFsLnBlZ2pzL3NyYy9xdWVyeUFyYy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJzcmMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8vR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbndCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3IzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiZnVuY3Rpb24gYmpvcmtsdW5kKHNsb3RzLCBwdWxzZXMpe1xuICB2YXIgcGF0dGVybiA9IFtdLFxuICAgICAgY291bnQgPSBbXSxcbiAgICAgIHJlbWFpbmRlciA9IFtwdWxzZXNdLFxuICAgICAgZGl2aXNvciA9IHNsb3RzIC0gcHVsc2VzLFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgYnVpbGRfcGF0dGVybiA9IGZ1bmN0aW9uKGx2KXtcbiAgICAgICAgaWYoIGx2ID09IC0xICl7IHBhdHRlcm4ucHVzaCgwKTsgfVxuICAgICAgICBlbHNlIGlmKCBsdiA9PSAtMiApeyBwYXR0ZXJuLnB1c2goMSk7IH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBmb3IodmFyIHg9MDsgeDxjb3VudFtsdl07IHgrKyl7XG4gICAgICAgICAgICBidWlsZF9wYXR0ZXJuKGx2LTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKHJlbWFpbmRlcltsdl0pe1xuICAgICAgICAgICAgYnVpbGRfcGF0dGVybihsdi0yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgO1xuXG4gIHdoaWxlKHJlbWFpbmRlcltsZXZlbF0gPiAxKXtcbiAgICBjb3VudC5wdXNoKE1hdGguZmxvb3IoZGl2aXNvci9yZW1haW5kZXJbbGV2ZWxdKSk7XG4gICAgcmVtYWluZGVyLnB1c2goZGl2aXNvciVyZW1haW5kZXJbbGV2ZWxdKTtcbiAgICBkaXZpc29yID0gcmVtYWluZGVyW2xldmVsXTtcbiAgICBsZXZlbCsrO1xuICB9XG4gIGNvdW50LnB1c2goZGl2aXNvcik7XG5cbiAgYnVpbGRfcGF0dGVybihsZXZlbCk7XG5cbiAgcmV0dXJuIHBhdHRlcm4ucmV2ZXJzZSgpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obSwgayl7XG4gIGlmKG0gPiBrKSByZXR1cm4gYmpvcmtsdW5kKG0sIGspO1xuICBlbHNlIHJldHVybiBiam9ya2x1bmQoaywgbSk7XG59O1xuIiwiIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLyoqXG4gKiBjaHJvbWEuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNvbG9yIGNvbnZlcnNpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTksIEdyZWdvciBBaXNjaFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gVGhlIG5hbWUgR3JlZ29yIEFpc2NoIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAqIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdSRUdPUiBBSVNDSCBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsXG4gKiBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiAqIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIGNocm9tYS5qcyBpbmNsdWRlcyBjb2xvcnMgZnJvbSBjb2xvcmJyZXdlcjIub3JnLCB3aGljaCBhcmUgcmVsZWFzZWQgdW5kZXJcbiAqIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDIgQ3ludGhpYSBCcmV3ZXIsIE1hcmsgSGFycm93ZXIsXG4gKiBhbmQgVGhlIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELFxuICogZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWNcbiAqIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogTmFtZWQgY29sb3JzIGFyZSB0YWtlbiBmcm9tIFgxMSBDb2xvciBOYW1lcy5cbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICpcbiAqIEBwcmVzZXJ2ZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmNocm9tYSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbGltaXQkMiA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAoIG1pbiA9PT0gdm9pZCAwICkgbWluPTA7XG4gICAgICAgIGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXg9MTtcblxuICAgICAgICByZXR1cm4geCA8IG1pbiA/IG1pbiA6IHggPiBtYXggPyBtYXggOiB4O1xuICAgIH07XG5cbiAgICB2YXIgbGltaXQkMSA9IGxpbWl0JDI7XG5cbiAgICB2YXIgY2xpcF9yZ2IkMyA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgICAgIHJnYi5fdW5jbGlwcGVkID0gcmdiLnNsaWNlKDApO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8PTM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJnYltpXSA8IDAgfHwgcmdiW2ldID4gMjU1KSB7IHJnYi5fY2xpcHBlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICByZ2JbaV0gPSBsaW1pdCQxKHJnYltpXSwgMCwgMjU1KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0JDEocmdiW2ldLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH07XG5cbiAgICAvLyBwb3J0ZWQgZnJvbSBqUXVlcnkncyAkLnR5cGVcbiAgICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBbJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsICdGdW5jdGlvbicsICdBcnJheScsICdEYXRlJywgJ1JlZ0V4cCcsICdVbmRlZmluZWQnLCAnTnVsbCddOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgIGNsYXNzVG9UeXBlWyhcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIpXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgdmFyIHR5cGUkcCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gY2xhc3NUb1R5cGVbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCI7XG4gICAgfTtcblxuICAgIHZhciB0eXBlJG8gPSB0eXBlJHA7XG5cbiAgICB2YXIgdW5wYWNrJEIgPSBmdW5jdGlvbiAoYXJncywga2V5T3JkZXIpIHtcbiAgICAgICAgaWYgKCBrZXlPcmRlciA9PT0gdm9pZCAwICkga2V5T3JkZXI9bnVsbDtcblxuICAgIFx0Ly8gaWYgY2FsbGVkIHdpdGggbW9yZSB0aGFuIDMgYXJndW1lbnRzLCB3ZSByZXR1cm4gdGhlIGFyZ3VtZW50c1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMykgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7IH1cbiAgICAgICAgLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAgICAgLy8gYW5kIHVzZSB0aGUga2V5T3JkZXIgc3RyaW5nIHRvIGV4dHJhY3QgYW5kIHNvcnQgcHJvcGVydGllc1xuICAgIFx0aWYgKHR5cGUkbyhhcmdzWzBdKSA9PSAnb2JqZWN0JyAmJiBrZXlPcmRlcikge1xuICAgIFx0XHRyZXR1cm4ga2V5T3JkZXIuc3BsaXQoJycpXG4gICAgXHRcdFx0LmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkOyB9KVxuICAgIFx0XHRcdC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGFyZ3NbMF1ba107IH0pO1xuICAgIFx0fVxuICAgIFx0Ly8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgIFx0Ly8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcblxuICAgIHZhciB0eXBlJG4gPSB0eXBlJHA7XG5cbiAgICB2YXIgbGFzdCQ0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoLTE7XG4gICAgICAgIGlmICh0eXBlJG4oYXJnc1tsXSkgPT0gJ3N0cmluZycpIHsgcmV0dXJuIGFyZ3NbbF0udG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHV0aWxzID0ge1xuICAgIFx0Y2xpcF9yZ2I6IGNsaXBfcmdiJDMsXG4gICAgXHRsaW1pdDogbGltaXQkMixcbiAgICBcdHR5cGU6IHR5cGUkcCxcbiAgICBcdHVucGFjazogdW5wYWNrJEIsXG4gICAgXHRsYXN0OiBsYXN0JDQsXG4gICAgXHRQSTogUEkkMixcbiAgICBcdFRXT1BJOiBQSSQyKjIsXG4gICAgXHRQSVRISVJEOiBQSSQyLzMsXG4gICAgXHRERUcyUkFEOiBQSSQyIC8gMTgwLFxuICAgIFx0UkFEMkRFRzogMTgwIC8gUEkkMlxuICAgIH07XG5cbiAgICB2YXIgaW5wdXQkaCA9IHtcbiAgICBcdGZvcm1hdDoge30sXG4gICAgXHRhdXRvZGV0ZWN0OiBbXVxuICAgIH07XG5cbiAgICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcbiAgICB2YXIgY2xpcF9yZ2IkMiA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciB0eXBlJG0gPSB1dGlscy50eXBlO1xuICAgIHZhciBfaW5wdXQgPSBpbnB1dCRoO1xuXG4gICAgdmFyIENvbG9yJEQgPSBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZSRtKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGlzIGFscmVhZHkgYSBDb2xvciBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsYXN0IGFyZ3VtZW50IGNvdWxkIGJlIHRoZSBtb2RlXG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQzKGFyZ3MpO1xuICAgICAgICB2YXIgYXV0b2RldGVjdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgYXV0b2RldGVjdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pbnB1dC5zb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBfaW5wdXQuYXV0b2RldGVjdCA9IF9pbnB1dC5hdXRvZGV0ZWN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYi5wIC0gYS5wOyB9KTtcbiAgICAgICAgICAgICAgICBfaW5wdXQuc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG8tZGV0ZWN0IGZvcm1hdFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBfaW5wdXQuYXV0b2RldGVjdDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIG1vZGUgPSBjaGsudGVzdC5hcHBseShjaGssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgICAgICAgdmFyIHJnYiA9IF9pbnB1dC5mb3JtYXRbbW9kZV0uYXBwbHkobnVsbCwgYXV0b2RldGVjdCA/IGFyZ3MgOiBhcmdzLnNsaWNlKDAsLTEpKTtcbiAgICAgICAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYiQyKHJnYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZm9ybWF0OiAnK2FyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFscGhhIGNoYW5uZWxcbiAgICAgICAgaWYgKG1lLl9yZ2IubGVuZ3RoID09PSAzKSB7IG1lLl9yZ2IucHVzaCgxKTsgfVxuICAgIH07XG5cbiAgICBDb2xvciRELnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgaWYgKHR5cGUkbSh0aGlzLmhleCkgPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gdGhpcy5oZXgoKTsgfVxuICAgICAgICByZXR1cm4gKFwiW1wiICsgKHRoaXMuX3JnYi5qb2luKCcsJykpICsgXCJdXCIpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3JfMSA9IENvbG9yJEQ7XG5cbiAgICB2YXIgY2hyb21hJGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIFx0d2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIFx0cmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIGNocm9tYSRrLkNvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MpICkpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkay5Db2xvciA9IENvbG9yXzE7XG4gICAgY2hyb21hJGsudmVyc2lvbiA9ICcyLjQuMic7XG5cbiAgICB2YXIgY2hyb21hXzEgPSBjaHJvbWEkaztcblxuICAgIHZhciB1bnBhY2skQSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbWF4JDIgPSBNYXRoLm1heDtcblxuICAgIHZhciByZ2IyY215ayQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skQShhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHIgPSByIC8gMjU1O1xuICAgICAgICBnID0gZyAvIDI1NTtcbiAgICAgICAgYiA9IGIgLyAyNTU7XG4gICAgICAgIHZhciBrID0gMSAtIG1heCQyKHIsbWF4JDIoZyxiKSk7XG4gICAgICAgIHZhciBmID0gayA8IDEgPyAxIC8gKDEtaykgOiAwO1xuICAgICAgICB2YXIgYyA9ICgxLXItaykgKiBmO1xuICAgICAgICB2YXIgbSA9ICgxLWctaykgKiBmO1xuICAgICAgICB2YXIgeSA9ICgxLWItaykgKiBmO1xuICAgICAgICByZXR1cm4gW2MsbSx5LGtdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmNteWtfMSA9IHJnYjJjbXlrJDE7XG5cbiAgICB2YXIgdW5wYWNrJHogPSB1dGlscy51bnBhY2s7XG5cbiAgICB2YXIgY215azJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayR6KGFyZ3MsICdjbXlrJyk7XG4gICAgICAgIHZhciBjID0gYXJnc1swXTtcbiAgICAgICAgdmFyIG0gPSBhcmdzWzFdO1xuICAgICAgICB2YXIgeSA9IGFyZ3NbMl07XG4gICAgICAgIHZhciBrID0gYXJnc1szXTtcbiAgICAgICAgdmFyIGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG4gICAgICAgIGlmIChrID09PSAxKSB7IHJldHVybiBbMCwwLDAsYWxwaGFdOyB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjID49IDEgPyAwIDogMjU1ICogKDEtYykgKiAoMS1rKSwgLy8gclxuICAgICAgICAgICAgbSA+PSAxID8gMCA6IDI1NSAqICgxLW0pICogKDEtayksIC8vIGdcbiAgICAgICAgICAgIHkgPj0gMSA/IDAgOiAyNTUgKiAoMS15KSAqICgxLWspLCAvLyBiXG4gICAgICAgICAgICBhbHBoYVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgY215azJyZ2JfMSA9IGNteWsycmdiO1xuXG4gICAgdmFyIGNocm9tYSRqID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJEMgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCRnID0gaW5wdXQkaDtcbiAgICB2YXIgdW5wYWNrJHkgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkbCA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcmdiMmNteWsgPSByZ2IyY215a18xO1xuXG4gICAgQ29sb3IkQy5wcm90b3R5cGUuY215ayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmNteWsodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGouY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkQywgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2NteWsnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGcuZm9ybWF0LmNteWsgPSBjbXlrMnJnYl8xO1xuXG4gICAgaW5wdXQkZy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayR5KGFyZ3MsICdjbXlrJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRsKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbXlrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayR4ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDIgPSB1dGlscy5sYXN0O1xuICAgIHZhciBybmQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gTWF0aC5yb3VuZChhKjEwMCkvMTAwOyB9O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICAgKiAtIGhzbDJjc3MoaCxzLGwsYSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsXSwgbW9kZSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgICAqIC0gaHNsMmNzcyh7aCxzLGwsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIGhzbDJjc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgaHNsYSA9IHVucGFjayR4KGFyZ3MsICdoc2xhJyk7XG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQyKGFyZ3MpIHx8ICdsc2EnO1xuICAgICAgICBoc2xhWzBdID0gcm5kKGhzbGFbMF0gfHwgMCk7XG4gICAgICAgIGhzbGFbMV0gPSBybmQoaHNsYVsxXSoxMDApICsgJyUnO1xuICAgICAgICBoc2xhWzJdID0gcm5kKGhzbGFbMl0qMTAwKSArICclJztcbiAgICAgICAgaWYgKG1vZGUgPT09ICdoc2xhJyB8fCAoaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM108MSkpIHtcbiAgICAgICAgICAgIGhzbGFbM10gPSBoc2xhLmxlbmd0aCA+IDMgPyBoc2xhWzNdIDogMTtcbiAgICAgICAgICAgIG1vZGUgPSAnaHNsYSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtb2RlICsgXCIoXCIgKyAoaHNsYS5qb2luKCcsJykpICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgaHNsMmNzc18xID0gaHNsMmNzcyQxO1xuXG4gICAgdmFyIHVucGFjayR3ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmhzbChyLGcsYilcbiAgICAgKiAtIHJnYjJoc2wocixnLGIsYSlcbiAgICAgKiAtIHJnYjJoc2woW3IsZyxiXSlcbiAgICAgKiAtIHJnYjJoc2woW3IsZyxiLGFdKVxuICAgICAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gICAgICovXG4gICAgdmFyIHJnYjJoc2wkMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJHcoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcblxuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXG4gICAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICB2YXIgcywgaDtcblxuICAgICAgICBpZiAobWF4ID09PSBtaW4pe1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBsIDwgMC41ID8gKG1heCAtIG1pbikgLyAobWF4ICsgbWluKSA6IChtYXggLSBtaW4pIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPT0gbWF4KSB7IGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoZyA9PSBtYXgpIHsgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSBtYXgpIHsgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7IH1cblxuICAgICAgICBoICo9IDYwO1xuICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoPjMgJiYgYXJnc1szXSE9PXVuZGVmaW5lZCkgeyByZXR1cm4gW2gscyxsLGFyZ3NbM11dOyB9XG4gICAgICAgIHJldHVybiBbaCxzLGxdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbCQzO1xuXG4gICAgdmFyIHVucGFjayR2ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDEgPSB1dGlscy5sYXN0O1xuICAgIHZhciBoc2wyY3NzID0gaHNsMmNzc18xO1xuICAgIHZhciByZ2IyaHNsJDIgPSByZ2IyaHNsXzE7XG4gICAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmNzcyhyLGcsYilcbiAgICAgKiAtIHJnYjJjc3MocixnLGIsYSlcbiAgICAgKiAtIHJnYjJjc3MoW3IsZyxiXSwgbW9kZSlcbiAgICAgKiAtIHJnYjJjc3MoW3IsZyxiLGFdLCBtb2RlKVxuICAgICAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIHJnYjJjc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiYSA9IHVucGFjayR2KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciBtb2RlID0gbGFzdCQxKGFyZ3MpIHx8ICdyZ2InO1xuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwzKSA9PSAnaHNsJykge1xuICAgICAgICAgICAgcmV0dXJuIGhzbDJjc3MocmdiMmhzbCQyKHJnYmEpLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZ2JhWzBdID0gcm91bmQkNihyZ2JhWzBdKTtcbiAgICAgICAgcmdiYVsxXSA9IHJvdW5kJDYocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSByb3VuZCQ2KHJnYmFbMl0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3JnYmEnIHx8IChyZ2JhLmxlbmd0aCA+IDMgJiYgcmdiYVszXTwxKSkge1xuICAgICAgICAgICAgcmdiYVszXSA9IHJnYmEubGVuZ3RoID4gMyA/IHJnYmFbM10gOiAxO1xuICAgICAgICAgICAgbW9kZSA9ICdyZ2JhJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG1vZGUgKyBcIihcIiArIChyZ2JhLnNsaWNlKDAsbW9kZT09PSdyZ2InPzM6NCkuam9pbignLCcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJjc3NfMSA9IHJnYjJjc3MkMTtcblxuICAgIHZhciB1bnBhY2skdSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcm91bmQkNSA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgaHNsMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduO1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skdShhcmdzLCAnaHNsJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IGwqMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHQzID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciBjID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciB0MiA9IGwgPCAwLjUgPyBsICogKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgdmFyIHQxID0gMiAqIGwgLSB0MjtcbiAgICAgICAgICAgIHZhciBoXyA9IGggLyAzNjA7XG4gICAgICAgICAgICB0M1swXSA9IGhfICsgMS8zO1xuICAgICAgICAgICAgdDNbMV0gPSBoXztcbiAgICAgICAgICAgIHQzWzJdID0gaF8gLSAxLzM7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldIDwgMCkgeyB0M1tpXSArPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldID4gMSkgeyB0M1tpXSAtPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKDYgKiB0M1tpXSA8IDEpXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoMiAqIHQzW2ldIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDI7IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgzICogdDNbaV0gPCAyKVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDNbaV0pICogNjsgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChhc3NpZ24gPSBbcm91bmQkNShjWzBdKjI1NSkscm91bmQkNShjWzFdKjI1NSkscm91bmQkNShjWzJdKjI1NSldLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsYXJnc1szXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbDJyZ2JfMSA9IGhzbDJyZ2IkMTtcblxuICAgIHZhciBoc2wycmdiID0gaHNsMnJnYl8xO1xuICAgIHZhciBpbnB1dCRmID0gaW5wdXQkaDtcblxuICAgIHZhciBSRV9SR0IgPSAvXnJnYlxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccypcXCkkLztcbiAgICB2YXIgUkVfUkdCQSA9IC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgICB2YXIgUkVfUkdCX1BDVCA9IC9ecmdiXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICAgIHZhciBSRV9SR0JBX1BDVCA9IC9ecmdiYVxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbiAgICB2YXIgUkVfSFNMID0gL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgICB2YXIgUkVfSFNMQSA9IC9eaHNsYVxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuXG4gICAgdmFyIHJvdW5kJDQgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIGNzczJyZ2IkMSA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgY3NzID0gY3NzLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICB2YXIgbTtcblxuICAgICAgICBpZiAoaW5wdXQkZi5mb3JtYXQubmFtZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0JGYuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2IoMjUwLDIwLDApXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0IpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiA9IG0uc2xpY2UoMSw0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTwzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiWzNdID0gMTsgIC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiByZ2I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2JhKDI1MCwyMCwwLDAuNClcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQkEpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiQxID0gbS5zbGljZSgxLDUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxPTA7IGkkMTw0OyBpJDErKykge1xuICAgICAgICAgICAgICAgIHJnYiQxW2kkMV0gPSArcmdiJDFbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZ2IkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYigxMDAlLDAlLDAlKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCX1BDVCkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDIgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDI9MDsgaSQyPDM7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgcmdiJDJbaSQyXSA9IHJvdW5kJDQocmdiJDJbaSQyXSAqIDIuNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiJDJbM10gPSAxOyAgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHJnYiQyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiYSgxMDAlLDAlLDAlLDAuNClcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQkFfUENUKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IkMyA9IG0uc2xpY2UoMSw1KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMz0wOyBpJDM8MzsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkM1tpJDNdID0gcm91bmQkNChyZ2IkM1tpJDNdICogMi41NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZ2IkM1szXSA9ICtyZ2IkM1szXTtcbiAgICAgICAgICAgIHJldHVybiByZ2IkMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhzbCgwLDEwMCUsNTAlKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkpIHtcbiAgICAgICAgICAgIHZhciBoc2wgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgICAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgICAgICAgdmFyIHJnYiQ0ID0gaHNsMnJnYihoc2wpO1xuICAgICAgICAgICAgcmdiJDRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHNsYSgwLDEwMCUsNTAlLDAuNSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTEEpKSkge1xuICAgICAgICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgaHNsJDFbMV0gKj0gMC4wMTtcbiAgICAgICAgICAgIGhzbCQxWzJdICo9IDAuMDE7XG4gICAgICAgICAgICB2YXIgcmdiJDUgPSBoc2wycmdiKGhzbCQxKTtcbiAgICAgICAgICAgIHJnYiQ1WzNdID0gK21bNF07ICAvLyBkZWZhdWx0IGFscGhhID0gMVxuICAgICAgICAgICAgcmV0dXJuIHJnYiQ1O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNzczJyZ2IkMS50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIFJFX1JHQi50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9SR0JBLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX1JHQl9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCQV9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfSFNMLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX0hTTEEudGVzdChzKTtcbiAgICB9O1xuXG4gICAgdmFyIGNzczJyZ2JfMSA9IGNzczJyZ2IkMTtcblxuICAgIHZhciBjaHJvbWEkaSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRCID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkZSA9IGlucHV0JGg7XG4gICAgdmFyIHR5cGUkayA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcmdiMmNzcyA9IHJnYjJjc3NfMTtcbiAgICB2YXIgY3NzMnJnYiA9IGNzczJyZ2JfMTtcblxuICAgIENvbG9yJEIucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJjc3ModGhpcy5fcmdiLCBtb2RlKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGkuY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRCLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnY3NzJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRlLmZvcm1hdC5jc3MgPSBjc3MycmdiO1xuXG4gICAgaW5wdXQkZS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRrKGgpID09PSAnc3RyaW5nJyAmJiBjc3MycmdiLnRlc3QoaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Nzcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBDb2xvciRBID0gQ29sb3JfMTtcbiAgICB2YXIgY2hyb21hJGggPSBjaHJvbWFfMTtcbiAgICB2YXIgaW5wdXQkZCA9IGlucHV0JGg7XG4gICAgdmFyIHVucGFjayR0ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgaW5wdXQkZC5mb3JtYXQuZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJnYiA9IHVucGFjayR0KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHJnYlswXSAqPSAyNTU7XG4gICAgICAgIHJnYlsxXSAqPSAyNTU7XG4gICAgICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIGNocm9tYSRoLmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRBLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnZ2wnXSkgKSk7XG4gICAgfTtcblxuICAgIENvbG9yJEEucHJvdG90eXBlLmdsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgICAgIHJldHVybiBbcmdiWzBdLzI1NSwgcmdiWzFdLzI1NSwgcmdiWzJdLzI1NSwgcmdiWzNdXTtcbiAgICB9O1xuXG4gICAgdmFyIHVucGFjayRzID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIHJnYjJoY2ckMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJHMoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgICB2YXIgYyA9IGRlbHRhICogMTAwIC8gMjU1O1xuICAgICAgICB2YXIgX2cgPSBtaW4gLyAoMjU1IC0gZGVsdGEpICogMTAwO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyID09PSBtYXgpIHsgaCA9IChnIC0gYikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGcgPT09IG1heCkgeyBoID0gMisoYiAtIHIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChiID09PSBtYXgpIHsgaCA9IDQrKHIgLSBnKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBoICo9IDYwO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoLCBjLCBfZ107XG4gICAgfTtcblxuICAgIHZhciByZ2IyaGNnXzEgPSByZ2IyaGNnJDE7XG5cbiAgICB2YXIgdW5wYWNrJHIgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGZsb29yJDMgPSBNYXRoLmZsb29yO1xuXG4gICAgLypcbiAgICAgKiB0aGlzIGlzIGJhc2ljYWxseSBqdXN0IEhTViB3aXRoIHNvbWUgbWlub3IgdHdlYWtzXG4gICAgICpcbiAgICAgKiBodWUuLiBbMC4uMzYwXVxuICAgICAqIGNocm9tYSAuLiBbMC4uMV1cbiAgICAgKiBncmF5bmVzcyAuLiBbMC4uMV1cbiAgICAgKi9cblxuICAgIHZhciBoY2cycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDIsIGFzc2lnbiQzLCBhc3NpZ24kNCwgYXNzaWduJDU7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayRyKGFyZ3MsICdoY2cnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBfZyA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgX2cgPSBfZyAqIDI1NTtcbiAgICAgICAgdmFyIF9jID0gYyAqIDI1NTtcbiAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGggPT09IDM2MCkgeyBoID0gMDsgfVxuICAgICAgICAgICAgaWYgKGggPiAzNjApIHsgaCAtPSAzNjA7IH1cbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICAgICAgaCAvPSA2MDtcbiAgICAgICAgICAgIHZhciBpID0gZmxvb3IkMyhoKTtcbiAgICAgICAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICAgICAgICB2YXIgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgICAgICAgIHZhciBxID0gcCArIF9jICogKDEgLSBmKTtcbiAgICAgICAgICAgIHZhciB0ID0gcCArIF9jICogZjtcbiAgICAgICAgICAgIHZhciB2ID0gcCArIF9jO1xuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiAoYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IChhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMzogKGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IChhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pOyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgaGNnMnJnYl8xID0gaGNnMnJnYjtcblxuICAgIHZhciB1bnBhY2skcSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRqID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGcgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkeiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGMgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoY2cgPSByZ2IyaGNnXzE7XG5cbiAgICBDb2xvciR6LnByb3RvdHlwZS5oY2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoY2codGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGcuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR6LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGNnJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRjLmZvcm1hdC5oY2cgPSBoY2cycmdiXzE7XG5cbiAgICBpbnB1dCRjLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDEsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJHEoYXJncywgJ2hjZycpO1xuICAgICAgICAgICAgaWYgKHR5cGUkaihhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGNnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRwID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdDtcbiAgICB2YXIgcm91bmQkMyA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgcmdiMmhleCQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skcChhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgYSA9IHJlZlszXTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdhdXRvJztcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gMTsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBtb2RlID0gYSA8IDEgPyAncmdiYScgOiAncmdiJztcbiAgICAgICAgfVxuICAgICAgICByID0gcm91bmQkMyhyKTtcbiAgICAgICAgZyA9IHJvdW5kJDMoZyk7XG4gICAgICAgIGIgPSByb3VuZCQzKGIpO1xuICAgICAgICB2YXIgdSA9IHIgPDwgMTYgfCBnIDw8IDggfCBiO1xuICAgICAgICB2YXIgc3RyID0gXCIwMDAwMDBcIiArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gNik7XG4gICAgICAgIHZhciBoeGEgPSAnMCcgKyByb3VuZCQzKGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaHhhID0gaHhhLnN1YnN0cihoeGEubGVuZ3RoIC0gMik7XG4gICAgICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdyZ2JhJzogcmV0dXJuIChcIiNcIiArIHN0ciArIGh4YSk7XG4gICAgICAgICAgICBjYXNlICdhcmdiJzogcmV0dXJuIChcIiNcIiArIGh4YSArIHN0cik7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gKFwiI1wiICsgc3RyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmdiMmhleF8xID0gcmdiMmhleCQyO1xuXG4gICAgdmFyIFJFX0hFWCA9IC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC87XG4gICAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gICAgdmFyIGhleDJyZ2IkMSA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgaWYgKGhleC5tYXRjaChSRV9IRVgpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIHNpeC1kaWdpdFxuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGhleCA9IGhleFswXStoZXhbMF0raGV4WzFdK2hleFsxXStoZXhbMl0raGV4WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHZhciByID0gdSA+PiAxNjtcbiAgICAgICAgICAgIHZhciBnID0gdSA+PiA4ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiID0gdSAmIDB4RkY7XG4gICAgICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2ggcmdiYSBoZXggZm9ybWF0LCBlZyAjRkYwMDAwNzdcbiAgICAgICAgaWYgKGhleC5tYXRjaChSRV9IRVhBKSkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDUgfHwgaGV4Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXhbMF0raGV4WzBdK2hleFsxXStoZXhbMV0raGV4WzJdK2hleFsyXStoZXhbM10raGV4WzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUkMSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgdmFyIHIkMSA9IHUkMSA+PiAyNCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgZyQxID0gdSQxID4+IDE2ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiJDEgPSB1JDEgPj4gOCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGgucm91bmQoKHUkMSAmIDB4RkYpIC8gMHhGRiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gW3IkMSxnJDEsYiQxLGFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgdXNlZCB0byBjaGVjayBmb3IgY3NzIGNvbG9ycyBoZXJlXG4gICAgICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgICAgICAvLyAgICAgcmV0dXJuIHJnYlxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGhleCBjb2xvcjogXCIgKyBoZXgpKTtcbiAgICB9O1xuXG4gICAgdmFyIGhleDJyZ2JfMSA9IGhleDJyZ2IkMTtcblxuICAgIHZhciBjaHJvbWEkZiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR5ID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSRpID0gdXRpbHMudHlwZTtcbiAgICB2YXIgaW5wdXQkYiA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhleCQxID0gcmdiMmhleF8xO1xuXG4gICAgQ29sb3IkeS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgICByZXR1cm4gcmdiMmhleCQxKHRoaXMuX3JnYiwgbW9kZSk7XG4gICAgfTtcblxuICAgIGNocm9tYSRmLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkeSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hleCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkYi5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICAgIGlucHV0JGIuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNCxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUkaShoKSA9PT0gJ3N0cmluZycgJiYgWzMsNCw1LDYsNyw4LDldLmluZGV4T2YoaC5sZW5ndGgpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hleCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skbyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICAgIHZhciBtaW4kMiA9IE1hdGgubWluO1xuICAgIHZhciBzcXJ0JDQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGFjb3MgPSBNYXRoLmFjb3M7XG5cbiAgICB2YXIgcmdiMmhzaSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICAgICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL3JnYjJoc2kuY3BwXG4gICAgICAgICovXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skbyhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgICAgIHZhciBoO1xuICAgICAgICB2YXIgbWluXyA9IG1pbiQyKHIsZyxiKTtcbiAgICAgICAgdmFyIGkgPSAocitnK2IpIC8gMztcbiAgICAgICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fL2kgOiAwO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSAoKHItZykrKHItYikpIC8gMjtcbiAgICAgICAgICAgIGggLz0gc3FydCQ0KChyLWcpKihyLWcpICsgKHItYikqKGctYikpO1xuICAgICAgICAgICAgaCA9IGFjb3MoaCk7XG4gICAgICAgICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgICAgICAgICBoID0gVFdPUEkkMiAtIGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoIC89IFRXT1BJJDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoKjM2MCxzLGldO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzaV8xID0gcmdiMmhzaSQxO1xuXG4gICAgdmFyIHVucGFjayRuID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsaW1pdCA9IHV0aWxzLmxpbWl0O1xuICAgIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIFBJVEhJUkQgPSB1dGlscy5QSVRISVJEO1xuICAgIHZhciBjb3MkNCA9IE1hdGguY29zO1xuXG4gICAgLypcbiAgICAgKiBodWUgWzAuLjM2MF1cbiAgICAgKiBzYXR1cmF0aW9uIFswLi4xXVxuICAgICAqIGludGVuc2l0eSBbMC4uMV1cbiAgICAgKi9cbiAgICB2YXIgaHNpMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAvKlxuICAgICAgICBib3Jyb3dlZCBmcm9tIGhlcmU6XG4gICAgICAgIGh0dHA6Ly9odW1tZXIuc3RhbmZvcmQuZWR1L211c2VpbmZvL2RvYy9leGFtcGxlcy9odW1kcnVtL2tleXNjYXBlMi9oc2kycmdiLmNwcFxuICAgICAgICAqL1xuICAgICAgICBhcmdzID0gdW5wYWNrJG4oYXJncywgJ2hzaScpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGkgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG5cbiAgICAgICAgaWYgKGlzTmFOKGgpKSB7IGggPSAwOyB9XG4gICAgICAgIGlmIChpc05hTihzKSkgeyBzID0gMDsgfVxuICAgICAgICAvLyBub3JtYWxpemUgaHVlXG4gICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICBoIC89IDM2MDtcbiAgICAgICAgaWYgKGggPCAxLzMpIHtcbiAgICAgICAgICAgIGIgPSAoMS1zKS8zO1xuICAgICAgICAgICAgciA9ICgxK3MqY29zJDQoVFdPUEkkMSpoKS9jb3MkNChQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICBnID0gMSAtIChiK3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGggPCAyLzMpIHtcbiAgICAgICAgICAgIGggLT0gMS8zO1xuICAgICAgICAgICAgciA9ICgxLXMpLzM7XG4gICAgICAgICAgICBnID0gKDErcypjb3MkNChUV09QSSQxKmgpL2NvcyQ0KFBJVEhJUkQtVFdPUEkkMSpoKSkvMztcbiAgICAgICAgICAgIGIgPSAxIC0gKHIrZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoIC09IDIvMztcbiAgICAgICAgICAgIGcgPSAoMS1zKS8zO1xuICAgICAgICAgICAgYiA9ICgxK3MqY29zJDQoVFdPUEkkMSpoKS9jb3MkNChQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICByID0gMSAtIChnK2IpO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBsaW1pdChpKnIqMyk7XG4gICAgICAgIGcgPSBsaW1pdChpKmcqMyk7XG4gICAgICAgIGIgPSBsaW1pdChpKmIqMyk7XG4gICAgICAgIHJldHVybiBbcioyNTUsIGcqMjU1LCBiKjI1NSwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgaHNpMnJnYl8xID0gaHNpMnJnYjtcblxuICAgIHZhciB1bnBhY2skbSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRoID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGUgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkeCA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGEgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJoc2kgPSByZ2IyaHNpXzE7XG5cbiAgICBDb2xvciR4LnByb3RvdHlwZS5oc2kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc2kodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGUuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR4LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNpJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRhLmZvcm1hdC5oc2kgPSBoc2kycmdiXzE7XG5cbiAgICBpbnB1dCRhLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJG0oYXJncywgJ2hzaScpO1xuICAgICAgICAgICAgaWYgKHR5cGUkaChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHNpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRsID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGcgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkZCA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR3ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkOSA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhzbCQxID0gcmdiMmhzbF8xO1xuXG4gICAgQ29sb3Ikdy5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNsJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGQuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR3LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNsJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ5LmZvcm1hdC5oc2wgPSBoc2wycmdiXzE7XG5cbiAgICBpbnB1dCQ5LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJGwoYXJncywgJ2hzbCcpO1xuICAgICAgICAgICAgaWYgKHR5cGUkZyhhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHNsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRrID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBtaW4kMSA9IE1hdGgubWluO1xuICAgIHZhciBtYXgkMSA9IE1hdGgubWF4O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gcmdiMmhzdihyLGcsYilcbiAgICAgKiAtIHJnYjJoc3YoW3IsZyxiXSlcbiAgICAgKiAtIHJnYjJoc3Yoe3IsZyxifSlcbiAgICAgKi9cbiAgICB2YXIgcmdiMmhzbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJGsoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgbWluXyA9IG1pbiQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXhfIC0gbWluXztcbiAgICAgICAgdmFyIGgscyx2O1xuICAgICAgICB2ID0gbWF4XyAvIDI1NS4wO1xuICAgICAgICBpZiAobWF4XyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBkZWx0YSAvIG1heF87XG4gICAgICAgICAgICBpZiAociA9PT0gbWF4XykgeyBoID0gKGcgLSBiKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoZyA9PT0gbWF4XykgeyBoID0gMisoYiAtIHIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChiID09PSBtYXhfKSB7IGggPSA0KyhyIC0gZykgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCwgcywgdl1cbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoc3YkMSA9IHJnYjJoc2w7XG5cbiAgICB2YXIgdW5wYWNrJGogPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xuXG4gICAgdmFyIGhzdjJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICAgICAgICBhcmdzID0gdW5wYWNrJGooYXJncywgJ2hzdicpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHYgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIHYgKj0gMjU1O1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgciA9IGcgPSBiID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoID09PSAzNjApIHsgaCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgICAgIGggLz0gNjA7XG5cbiAgICAgICAgICAgIHZhciBpID0gZmxvb3IkMihoKTtcbiAgICAgICAgICAgIHZhciBmID0gaCAtIGk7XG4gICAgICAgICAgICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICAgICAgICAgICAgdmFyIHEgPSB2ICogKDEgLSBzICogZik7XG4gICAgICAgICAgICB2YXIgdCA9IHYgKiAoMSAtIHMgKiAoMSAtIGYpKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiAoYXNzaWduID0gW3YsIHQsIHBdLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IChhc3NpZ24kMSA9IFtxLCB2LCBwXSwgciA9IGFzc2lnbiQxWzBdLCBnID0gYXNzaWduJDFbMV0sIGIgPSBhc3NpZ24kMVsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMzogKGFzc2lnbiQzID0gW3AsIHEsIHZdLCByID0gYXNzaWduJDNbMF0sIGcgPSBhc3NpZ24kM1sxXSwgYiA9IGFzc2lnbiQzWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IChhc3NpZ24kNCA9IFt0LCBwLCB2XSwgciA9IGFzc2lnbiQ0WzBdLCBnID0gYXNzaWduJDRbMV0sIGIgPSBhc3NpZ24kNFsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA1OiAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pOyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcixnLGIsYXJncy5sZW5ndGggPiAzP2FyZ3NbM106MV07XG4gICAgfTtcblxuICAgIHZhciBoc3YycmdiXzEgPSBoc3YycmdiO1xuXG4gICAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGYgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkYyA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR2ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkOCA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhzdiA9IHJnYjJoc3YkMTtcblxuICAgIENvbG9yJHYucHJvdG90eXBlLmhzdiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhzdih0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkYy5oc3YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHYsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoc3YnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDguZm9ybWF0LmhzdiA9IGhzdjJyZ2JfMTtcblxuICAgIGlucHV0JDguYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skaShhcmdzLCAnaHN2Jyk7XG4gICAgICAgICAgICBpZiAodHlwZSRmKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGFiQ29uc3RhbnRzID0ge1xuICAgICAgICAvLyBDb3JyZXNwb25kcyByb3VnaGx5IHRvIFJHQiBicmlnaHRlci9kYXJrZXJcbiAgICAgICAgS246IDE4LFxuXG4gICAgICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgICAgICBYbjogMC45NTA0NzAsXG4gICAgICAgIFluOiAxLFxuICAgICAgICBabjogMS4wODg4MzAsXG5cbiAgICAgICAgdDA6IDAuMTM3OTMxMDM0LCAgLy8gNCAvIDI5XG4gICAgICAgIHQxOiAwLjIwNjg5NjU1MiwgIC8vIDYgLyAyOVxuICAgICAgICB0MjogMC4xMjg0MTg1NSwgICAvLyAzICogdDEgKiB0MVxuICAgICAgICB0MzogMC4wMDg4NTY0NTIsICAvLyB0MSAqIHQxICogdDFcbiAgICB9O1xuXG4gICAgdmFyIExBQl9DT05TVEFOVFMkMyA9IGxhYkNvbnN0YW50cztcbiAgICB2YXIgdW5wYWNrJGggPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHBvdyRhID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgcmdiMmxhYiQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skaChhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJ4eXoocixnLGIpO1xuICAgICAgICB2YXIgeCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgeSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgICAgcmV0dXJuIFtsIDwgMCA/IDAgOiBsLCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7IHJldHVybiByIC8gMTIuOTI7IH1cbiAgICAgICAgcmV0dXJuIHBvdyRhKChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfTtcblxuICAgIHZhciB4eXpfbGFiID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHQgPiBMQUJfQ09OU1RBTlRTJDMudDMpIHsgcmV0dXJuIHBvdyRhKHQsIDEgLyAzKTsgfVxuICAgICAgICByZXR1cm4gdCAvIExBQl9DT05TVEFOVFMkMy50MiArIExBQl9DT05TVEFOVFMkMy50MDtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJ4eXogPSBmdW5jdGlvbiAocixnLGIpIHtcbiAgICAgICAgciA9IHJnYl94eXoocik7XG4gICAgICAgIGcgPSByZ2JfeHl6KGcpO1xuICAgICAgICBiID0gcmdiX3h5eihiKTtcbiAgICAgICAgdmFyIHggPSB4eXpfbGFiKCgwLjQxMjQ1NjQgKiByICsgMC4zNTc1NzYxICogZyArIDAuMTgwNDM3NSAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlhuKTtcbiAgICAgICAgdmFyIHkgPSB4eXpfbGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlluKTtcbiAgICAgICAgdmFyIHogPSB4eXpfbGFiKCgwLjAxOTMzMzkgKiByICsgMC4xMTkxOTIwICogZyArIDAuOTUwMzA0MSAqIGIpIC8gTEFCX0NPTlNUQU5UUyQzLlpuKTtcbiAgICAgICAgcmV0dXJuIFt4LHksel07XG4gICAgfTtcblxuICAgIHZhciByZ2IybGFiXzEgPSByZ2IybGFiJDI7XG5cbiAgICB2YXIgTEFCX0NPTlNUQU5UUyQyID0gbGFiQ29uc3RhbnRzO1xuICAgIHZhciB1bnBhY2skZyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcG93JDkgPSBNYXRoLnBvdztcblxuICAgIC8qXG4gICAgICogTCogWzAuLjEwMF1cbiAgICAgKiBhIFstMTAwLi4xMDBdXG4gICAgICogYiBbLTEwMC4uMTAwXVxuICAgICAqL1xuICAgIHZhciBsYWIycmdiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRnKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHgseSx6LCByLGcsYl87XG5cbiAgICAgICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgICAgICB4ID0gaXNOYU4oYSkgPyB5IDogeSArIGEgLyA1MDA7XG4gICAgICAgIHogPSBpc05hTihiKSA/IHkgOiB5IC0gYiAvIDIwMDtcblxuICAgICAgICB5ID0gTEFCX0NPTlNUQU5UUyQyLlluICogbGFiX3h5eih5KTtcbiAgICAgICAgeCA9IExBQl9DT05TVEFOVFMkMi5YbiAqIGxhYl94eXooeCk7XG4gICAgICAgIHogPSBMQUJfQ09OU1RBTlRTJDIuWm4gKiBsYWJfeHl6KHopO1xuXG4gICAgICAgIHIgPSB4eXpfcmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeik7ICAvLyBENjUgLT4gc1JHQlxuICAgICAgICBnID0geHl6X3JnYigtMC45NjkyNjYwICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NjAgKiB6KTtcbiAgICAgICAgYl8gPSB4eXpfcmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeik7XG5cbiAgICAgICAgcmV0dXJuIFtyLGcsYl8sYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgeHl6X3JnYiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiAyNTUgKiAociA8PSAwLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBwb3ckOShyLCAxIC8gMi40KSAtIDAuMDU1KVxuICAgIH07XG5cbiAgICB2YXIgbGFiX3h5eiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID4gTEFCX0NPTlNUQU5UUyQyLnQxID8gdCAqIHQgKiB0IDogTEFCX0NPTlNUQU5UUyQyLnQyICogKHQgLSBMQUJfQ09OU1RBTlRTJDIudDApXG4gICAgfTtcblxuICAgIHZhciBsYWIycmdiXzEgPSBsYWIycmdiJDE7XG5cbiAgICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRiID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHUgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ3ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IybGFiJDEgPSByZ2IybGFiXzE7XG5cbiAgICBDb2xvciR1LnByb3RvdHlwZS5sYWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJsYWIkMSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkYi5sYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHUsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydsYWInXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDcuZm9ybWF0LmxhYiA9IGxhYjJyZ2JfMTtcblxuICAgIGlucHV0JDcuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnbGFiJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGUgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICAgIHZhciBzcXJ0JDMgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGF0YW4yJDIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciByb3VuZCQyID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBsYWIybGNoJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRlKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIGwgPSByZWZbMF07XG4gICAgICAgIHZhciBhID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIGMgPSBzcXJ0JDMoYSAqIGEgKyBiICogYik7XG4gICAgICAgIHZhciBoID0gKGF0YW4yJDIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcbiAgICAgICAgaWYgKHJvdW5kJDIoYyoxMDAwMCkgPT09IDApIHsgaCA9IE51bWJlci5OYU47IH1cbiAgICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuXG4gICAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2gkMjtcblxuICAgIHZhciB1bnBhY2skZCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcmdiMmxhYiA9IHJnYjJsYWJfMTtcbiAgICB2YXIgbGFiMmxjaCQxID0gbGFiMmxjaF8xO1xuXG4gICAgdmFyIHJnYjJsY2gkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGQoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2IybGFiKHIsZyxiKTtcbiAgICAgICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBsYWIybGNoJDEobCxhLGJfKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsY2hfMSA9IHJnYjJsY2gkMTtcblxuICAgIHZhciB1bnBhY2skYyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgREVHMlJBRCA9IHV0aWxzLkRFRzJSQUQ7XG4gICAgdmFyIHNpbiQzID0gTWF0aC5zaW47XG4gICAgdmFyIGNvcyQzID0gTWF0aC5jb3M7XG5cbiAgICB2YXIgbGNoMmxhYiQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIENvbnZlcnQgZnJvbSBhIHF1YWxpdGF0aXZlIHBhcmFtZXRlciBoIGFuZCBhIHF1YW50aXRhdGl2ZSBwYXJhbWV0ZXIgbCB0byBhIDI0LWJpdCBwaXhlbC5cbiAgICAgICAgVGhlc2UgZm9ybXVsYXMgd2VyZSBpbnZlbnRlZCBieSBEYXZpZCBEYWxyeW1wbGUgdG8gb2J0YWluIG1heGltdW0gY29udHJhc3Qgd2l0aG91dCBnb2luZ1xuICAgICAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG5cbiAgICAgICAgQSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgd2FzIGFkZGVkIGJ5IEdyZWdvciBBaXNjaFxuICAgICAgICAqL1xuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGMoYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGMgPSByZWZbMV07XG4gICAgICAgIHZhciBoID0gcmVmWzJdO1xuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaCA9IGggKiBERUcyUkFEO1xuICAgICAgICByZXR1cm4gW2wsIGNvcyQzKGgpICogYywgc2luJDMoaCkgKiBjXVxuICAgIH07XG5cbiAgICB2YXIgbGNoMmxhYl8xID0gbGNoMmxhYiQyO1xuXG4gICAgdmFyIHVucGFjayRiID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gybGFiJDEgPSBsY2gybGFiXzE7XG4gICAgdmFyIGxhYjJyZ2IgPSBsYWIycmdiXzE7XG5cbiAgICB2YXIgbGNoMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skYihhcmdzLCAnbGNoJyk7XG4gICAgICAgIHZhciBsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByZWYgPSBsY2gybGFiJDEgKGwsYyxoKTtcbiAgICAgICAgdmFyIEwgPSByZWZbMF07XG4gICAgICAgIHZhciBhID0gcmVmWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGxhYjJyZ2IgKEwsYSxiXyk7XG4gICAgICAgIHZhciByID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgbGNoMnJnYl8xID0gbGNoMnJnYiQxO1xuXG4gICAgdmFyIHVucGFjayRhID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gycmdiID0gbGNoMnJnYl8xO1xuXG4gICAgdmFyIGhjbDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGhjbCA9IHVucGFjayRhKGFyZ3MsICdoY2wnKS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBsY2gycmdiLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgICB9O1xuXG4gICAgdmFyIGhjbDJyZ2JfMSA9IGhjbDJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJDkgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZCA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRhID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHQgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ2ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IybGNoID0gcmdiMmxjaF8xO1xuXG4gICAgQ29sb3IkdC5wcm90b3R5cGUubGNoID0gZnVuY3Rpb24oKSB7IHJldHVybiByZ2IybGNoKHRoaXMuX3JnYik7IH07XG4gICAgQ29sb3IkdC5wcm90b3R5cGUuaGNsID0gZnVuY3Rpb24oKSB7IHJldHVybiByZ2IybGNoKHRoaXMuX3JnYikucmV2ZXJzZSgpOyB9O1xuXG4gICAgY2hyb21hJGEubGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR0LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbGNoJ10pICkpO1xuICAgIH07XG4gICAgY2hyb21hJGEuaGNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR0LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGNsJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ2LmZvcm1hdC5sY2ggPSBsY2gycmdiXzE7XG4gICAgaW5wdXQkNi5mb3JtYXQuaGNsID0gaGNsMnJnYl8xO1xuXG4gICAgWydsY2gnLCdoY2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBpbnB1dCQ2LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJDkoYXJncywgbSk7XG4gICAgICAgICAgICBpZiAodHlwZSRkKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTsgfSk7XG5cbiAgICAvKipcbiAgICBcdFgxMSBjb2xvciBuYW1lc1xuXG4gICAgXHRodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICAqL1xuXG4gICAgdmFyIHczY3gxMSQxID0ge1xuICAgICAgICBhbGljZWJsdWU6ICcjZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgICAgIGFxdWE6ICcjMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgICAgICBiZWlnZTogJyNmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICcjZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJyMwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgICAgIGJyb3duOiAnI2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICAgICAgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICAgICAgY29ybmZsb3dlcjogJyM2NDk1ZWQnLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLFxuICAgICAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxuICAgICAgICBjcmltc29uOiAnI2RjMTQzYycsXG4gICAgICAgIGN5YW46ICcjMDBmZmZmJyxcbiAgICAgICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcbiAgICAgICAgZGFya2N5YW46ICcjMDA4YjhiJyxcbiAgICAgICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLFxuICAgICAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxuICAgICAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcbiAgICAgICAgZGFya2dyZXk6ICcjYTlhOWE5JyxcbiAgICAgICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsXG4gICAgICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICAgICAgZGFya29yY2hpZDogJyM5OTMyY2MnLFxuICAgICAgICBkYXJrcmVkOiAnIzhiMDAwMCcsXG4gICAgICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICAgICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgICAgICBkYXJrc2xhdGVncmV5OiAnIzJmNGY0ZicsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJyxcbiAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxuICAgICAgICBkZWVwcGluazogJyNmZjE0OTMnLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLFxuICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsXG4gICAgICAgIGRpbWdyZXk6ICcjNjk2OTY5JyxcbiAgICAgICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLFxuICAgICAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcbiAgICAgICAgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJyxcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJyxcbiAgICAgICAgZnVjaHNpYTogJyNmZjAwZmYnLFxuICAgICAgICBnYWluc2Jvcm86ICcjZGNkY2RjJyxcbiAgICAgICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLFxuICAgICAgICBnb2xkOiAnI2ZmZDcwMCcsXG4gICAgICAgIGdvbGRlbnJvZDogJyNkYWE1MjAnLFxuICAgICAgICBncmF5OiAnIzgwODA4MCcsXG4gICAgICAgIGdyZWVuOiAnIzAwODAwMCcsXG4gICAgICAgIGdyZWVueWVsbG93OiAnI2FkZmYyZicsXG4gICAgICAgIGdyZXk6ICcjODA4MDgwJyxcbiAgICAgICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICAgICAgaG90cGluazogJyNmZjY5YjQnLFxuICAgICAgICBpbmRpYW5yZWQ6ICcjY2Q1YzVjJyxcbiAgICAgICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgICAgIGl2b3J5OiAnI2ZmZmZmMCcsXG4gICAgICAgIGtoYWtpOiAnI2YwZTY4YycsXG4gICAgICAgIGxhc2VybGVtb246ICcjZmZmZjU0JyxcbiAgICAgICAgbGF2ZW5kZXI6ICcjZTZlNmZhJyxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLFxuICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcbiAgICAgICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLFxuICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXG4gICAgICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLFxuICAgICAgICBsaWdodGdvbGRlbnJvZDogJyNmYWZhZDInLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgICAgICBsaWdodGdyYXk6ICcjZDNkM2QzJyxcbiAgICAgICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLFxuICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcbiAgICAgICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsXG4gICAgICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICAgICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c2xhdGVncmV5OiAnIzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnI2IwYzRkZScsXG4gICAgICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsXG4gICAgICAgIGxpbWU6ICcjMDBmZjAwJyxcbiAgICAgICAgbGltZWdyZWVuOiAnIzMyY2QzMicsXG4gICAgICAgIGxpbmVuOiAnI2ZhZjBlNicsXG4gICAgICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcbiAgICAgICAgbWFyb29uOiAnIzgwMDAwMCcsXG4gICAgICAgIG1hcm9vbjI6ICcjN2YwMDAwJyxcbiAgICAgICAgbWFyb29uMzogJyNiMDMwNjAnLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsXG4gICAgICAgIG1lZGl1bWJsdWU6ICcjMDAwMGNkJyxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJyM5MzcwZGInLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLFxuICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJyxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsXG4gICAgICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxuICAgICAgICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcbiAgICAgICAgbWludGNyZWFtOiAnI2Y1ZmZmYScsXG4gICAgICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxuICAgICAgICBtb2NjYXNpbjogJyNmZmU0YjUnLFxuICAgICAgICBuYXZham93aGl0ZTogJyNmZmRlYWQnLFxuICAgICAgICBuYXZ5OiAnIzAwMDA4MCcsXG4gICAgICAgIG9sZGxhY2U6ICcjZmRmNWU2JyxcbiAgICAgICAgb2xpdmU6ICcjODA4MDAwJyxcbiAgICAgICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXG4gICAgICAgIG9yYW5nZTogJyNmZmE1MDAnLFxuICAgICAgICBvcmFuZ2VyZWQ6ICcjZmY0NTAwJyxcbiAgICAgICAgb3JjaGlkOiAnI2RhNzBkNicsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJyxcbiAgICAgICAgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJyNkYjcwOTMnLFxuICAgICAgICBwYXBheWF3aGlwOiAnI2ZmZWZkNScsXG4gICAgICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxuICAgICAgICBwZXJ1OiAnI2NkODUzZicsXG4gICAgICAgIHBpbms6ICcjZmZjMGNiJyxcbiAgICAgICAgcGx1bTogJyNkZGEwZGQnLFxuICAgICAgICBwb3dkZXJibHVlOiAnI2IwZTBlNicsXG4gICAgICAgIHB1cnBsZTogJyM4MDAwODAnLFxuICAgICAgICBwdXJwbGUyOiAnIzdmMDA3ZicsXG4gICAgICAgIHB1cnBsZTM6ICcjYTAyMGYwJyxcbiAgICAgICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLFxuICAgICAgICByZWQ6ICcjZmYwMDAwJyxcbiAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLFxuICAgICAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLFxuICAgICAgICBzYWxtb246ICcjZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxuICAgICAgICBzZWFncmVlbjogJyMyZThiNTcnLFxuICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICcjYTA1MjJkJyxcbiAgICAgICAgc2lsdmVyOiAnI2MwYzBjMCcsXG4gICAgICAgIHNreWJsdWU6ICcjODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXG4gICAgICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLFxuICAgICAgICBzbGF0ZWdyZXk6ICcjNzA4MDkwJyxcbiAgICAgICAgc25vdzogJyNmZmZhZmEnLFxuICAgICAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLFxuICAgICAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnI2QyYjQ4YycsXG4gICAgICAgIHRlYWw6ICcjMDA4MDgwJyxcbiAgICAgICAgdGhpc3RsZTogJyNkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICcjZmY2MzQ3JyxcbiAgICAgICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsXG4gICAgICAgIHZpb2xldDogJyNlZTgyZWUnLFxuICAgICAgICB3aGVhdDogJyNmNWRlYjMnLFxuICAgICAgICB3aGl0ZTogJyNmZmZmZmYnLFxuICAgICAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJyNmZmZmMDAnLFxuICAgICAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInXG4gICAgfTtcblxuICAgIHZhciB3M2N4MTFfMSA9IHczY3gxMSQxO1xuXG4gICAgdmFyIENvbG9yJHMgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ1ID0gaW5wdXQkaDtcbiAgICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICAgIHZhciB3M2N4MTEgPSB3M2N4MTFfMTtcbiAgICB2YXIgaGV4MnJnYiA9IGhleDJyZ2JfMTtcbiAgICB2YXIgcmdiMmhleCA9IHJnYjJoZXhfMTtcblxuICAgIENvbG9yJHMucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhleCA9IHJnYjJoZXgodGhpcy5fcmdiLCAncmdiJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModzNjeDExKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKHczY3gxMVtuXSA9PT0gaGV4KSB7IHJldHVybiBuLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH07XG5cbiAgICBpbnB1dCQ1LmZvcm1hdC5uYW1lZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh3M2N4MTFbbmFtZV0pIHsgcmV0dXJuIGhleDJyZ2IodzNjeDExW25hbWVdKTsgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29sb3IgbmFtZTogJytuYW1lKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRjKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFbaC50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmFtZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJDggPSB1dGlscy51bnBhY2s7XG5cbiAgICB2YXIgcmdiMm51bSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skOChhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gICAgfTtcblxuICAgIHZhciByZ2IybnVtXzEgPSByZ2IybnVtJDE7XG5cbiAgICB2YXIgdHlwZSRiID0gdXRpbHMudHlwZTtcblxuICAgIHZhciBudW0ycmdiID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICBpZiAodHlwZSRiKG51bSkgPT0gXCJudW1iZXJcIiAmJiBudW0gPj0gMCAmJiBudW0gPD0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgIHZhciByID0gbnVtID4+IDE2O1xuICAgICAgICAgICAgdmFyIGcgPSAobnVtID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiID0gbnVtICYgMHhGRjtcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBudW0gY29sb3I6IFwiK251bSk7XG4gICAgfTtcblxuICAgIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuXG4gICAgdmFyIGNocm9tYSQ5ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHIgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ0ID0gaW5wdXQkaDtcbiAgICB2YXIgdHlwZSRhID0gdXRpbHMudHlwZTtcblxuICAgIHZhciByZ2IybnVtID0gcmdiMm51bV8xO1xuXG4gICAgQ29sb3Ikci5wcm90b3R5cGUubnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IybnVtKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ5Lm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ251bSddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuXG4gICAgaW5wdXQkNC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGUkYShhcmdzWzBdKSA9PT0gJ251bWJlcicgJiYgYXJnc1swXSA+PSAwICYmIGFyZ3NbMF0gPD0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjaHJvbWEkOCA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRxID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkMyA9IGlucHV0JGg7XG4gICAgdmFyIHVucGFjayQ3ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDkgPSB1dGlscy50eXBlO1xuICAgIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICAgIENvbG9yJHEucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKHJuZCkge1xuICAgICAgICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kPXRydWU7XG5cbiAgICAgICAgaWYgKHJuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDMpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCwzKS5tYXAocm91bmQkMSk7XG4gICAgfTtcblxuICAgIENvbG9yJHEucHJvdG90eXBlLnJnYmEgPSBmdW5jdGlvbihybmQpIHtcbiAgICAgICAgaWYgKCBybmQgPT09IHZvaWQgMCApIHJuZD10cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCw0KS5tYXAoZnVuY3Rpb24gKHYsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGk8MyA/IChybmQgPT09IGZhbHNlID8gdiA6IHJvdW5kJDEodikpIDogdjtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNocm9tYSQ4LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkcSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ3JnYiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMy5mb3JtYXQucmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrJDcoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgaWYgKHJnYmFbM10gPT09IHVuZGVmaW5lZCkgeyByZ2JhWzNdID0gMTsgfVxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAzLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayQ3KGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ5KGFyZ3MpID09PSAnYXJyYXknICYmIChhcmdzLmxlbmd0aCA9PT0gMyB8fFxuICAgICAgICAgICAgICAgIGFyZ3MubGVuZ3RoID09PSA0ICYmIHR5cGUkOShhcmdzWzNdKSA9PSAnbnVtYmVyJyAmJiBhcmdzWzNdID49IDAgJiYgYXJnc1szXSA8PSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmdiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICAgICAqL1xuXG4gICAgdmFyIGxvZyQxID0gTWF0aC5sb2c7XG5cbiAgICB2YXIgdGVtcGVyYXR1cmUycmdiJDEgPSBmdW5jdGlvbiAoa2VsdmluKSB7XG4gICAgICAgIHZhciB0ZW1wID0ga2VsdmluIC8gMTAwO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIGlmICh0ZW1wIDwgNjYpIHtcbiAgICAgICAgICAgIHIgPSAyNTU7XG4gICAgICAgICAgICBnID0gdGVtcCA8IDYgPyAwIDogLTE1NS4yNTQ4NTU2MjcwOTE3OSAtIDAuNDQ1OTY5NTA0Njk1NzkxMzMgKiAoZyA9IHRlbXAtMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2ckMShnKTtcbiAgICAgICAgICAgIGIgPSB0ZW1wIDwgMjAgPyAwIDogLTI1NC43NjkzNTE4NDEyMDkwMiArIDAuODI3NDA5NjA2NDAwNzM5NSAqIChiID0gdGVtcC0xMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2ckMShiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcC01NSkgLSA0MC4yNTM2NjMwOTMzMjEyNyAqIGxvZyQxKHIpO1xuICAgICAgICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcC01MCkgLSAyOC4wODUyOTYzNTA3OTU3ICogbG9nJDEoZyk7XG4gICAgICAgICAgICBiID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgfTtcblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2JfMSA9IHRlbXBlcmF0dXJlMnJnYiQxO1xuXG4gICAgLypcbiAgICAgKiBCYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBOZWlsIEJhcnRsZXR0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICAgICAqKi9cblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSB0ZW1wZXJhdHVyZTJyZ2JfMTtcbiAgICB2YXIgdW5wYWNrJDYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrJDYoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJnYlswXSwgYiA9IHJnYlsyXTtcbiAgICAgICAgdmFyIG1pblRlbXAgPSAxMDAwO1xuICAgICAgICB2YXIgbWF4VGVtcCA9IDQwMDAwO1xuICAgICAgICB2YXIgZXBzID0gMC40O1xuICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICAgICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYih0ZW1wKTtcbiAgICAgICAgICAgIGlmICgocmdiJDFbMl0gLyByZ2IkMVswXSkgPj0gKGIgLyByKSkge1xuICAgICAgICAgICAgICAgIG1heFRlbXAgPSB0ZW1wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5UZW1wID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91bmQodGVtcCk7XG4gICAgfTtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmVfMSA9IHJnYjJ0ZW1wZXJhdHVyZSQxO1xuXG4gICAgdmFyIGNocm9tYSQ3ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHAgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQyID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IydGVtcGVyYXR1cmUgPSByZ2IydGVtcGVyYXR1cmVfMTtcblxuICAgIENvbG9yJHAucHJvdG90eXBlLnRlbXAgPVxuICAgIENvbG9yJHAucHJvdG90eXBlLmtlbHZpbiA9XG4gICAgQ29sb3IkcC5wcm90b3R5cGUudGVtcGVyYXR1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJ0ZW1wZXJhdHVyZSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkNy50ZW1wID1cbiAgICBjaHJvbWEkNy5rZWx2aW4gPVxuICAgIGNocm9tYSQ3LnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRwLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsndGVtcCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMi5mb3JtYXQudGVtcCA9XG4gICAgaW5wdXQkMi5mb3JtYXQua2VsdmluID1cbiAgICBpbnB1dCQyLmZvcm1hdC50ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlMnJnYl8xO1xuXG4gICAgdmFyIHVucGFjayQ1ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBjYnJ0ID0gTWF0aC5jYnJ0O1xuICAgIHZhciBwb3ckOCA9IE1hdGgucG93O1xuICAgIHZhciBzaWduJDEgPSBNYXRoLnNpZ247XG5cbiAgICB2YXIgcmdiMm9rbGFiJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLy8gT0tMYWIgY29sb3Igc3BhY2UgaW1wbGVtZW50YXRpb24gdGFrZW4gZnJvbVxuICAgICAgICAvLyBodHRwczovL2JvdHRvc3Nvbi5naXRodWIuaW8vcG9zdHMvb2tsYWIvXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skNShhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IFtyZ2IybHJnYihyIC8gMjU1KSwgcmdiMmxyZ2IoZyAvIDI1NSksIHJnYjJscmdiKGIgLyAyNTUpXTtcbiAgICAgICAgdmFyIGxyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBsZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgbGIgPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIGwgPSBjYnJ0KDAuNDEyMjIxNDcwOCAqIGxyICsgMC41MzYzMzI1MzYzICogbGcgKyAwLjA1MTQ0NTk5MjkgKiBsYik7XG4gICAgICAgIHZhciBtID0gY2JydCgwLjIxMTkwMzQ5ODIgKiBsciArIDAuNjgwNjk5NTQ1MSAqIGxnICsgMC4xMDczOTY5NTY2ICogbGIpO1xuICAgICAgICB2YXIgcyA9IGNicnQoMC4wODgzMDI0NjE5ICogbHIgKyAwLjI4MTcxODgzNzYgKiBsZyArIDAuNjI5OTc4NzAwNSAqIGxiKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMC4yMTA0NTQyNTUzICogbCArIDAuNzkzNjE3Nzg1ICogbSAtIDAuMDA0MDcyMDQ2OCAqIHMsXG4gICAgICAgICAgICAxLjk3Nzk5ODQ5NTEgKiBsIC0gMi40Mjg1OTIyMDUgKiBtICsgMC40NTA1OTM3MDk5ICogcyxcbiAgICAgICAgICAgIDAuMDI1OTA0MDM3MSAqIGwgKyAwLjc4Mjc3MTc2NjIgKiBtIC0gMC44MDg2NzU3NjYgKiBzXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciByZ2Iyb2tsYWJfMSA9IHJnYjJva2xhYiQyO1xuXG4gICAgZnVuY3Rpb24gcmdiMmxyZ2IoYykge1xuICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMoYyk7XG4gICAgICAgIGlmIChhYnMgPCAwLjA0MDQ1KSB7XG4gICAgICAgICAgICByZXR1cm4gYyAvIDEyLjkyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2lnbiQxKGMpIHx8IDEpICogcG93JDgoKGFicyArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH1cblxuICAgIHZhciB1bnBhY2skNCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcG93JDcgPSBNYXRoLnBvdztcbiAgICB2YXIgc2lnbiA9IE1hdGguc2lnbjtcblxuICAgIC8qXG4gICAgICogTCogWzAuLjEwMF1cbiAgICAgKiBhIFstMTAwLi4xMDBdXG4gICAgICogYiBbLTEwMC4uMTAwXVxuICAgICAqL1xuICAgIHZhciBva2xhYjJyZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJDQoYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgTCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuXG4gICAgICAgIHZhciBsID0gcG93JDcoTCArIDAuMzk2MzM3Nzc3NCAqIGEgKyAwLjIxNTgwMzc1NzMgKiBiLCAzKTtcbiAgICAgICAgdmFyIG0gPSBwb3ckNyhMIC0gMC4xMDU1NjEzNDU4ICogYSAtIDAuMDYzODU0MTcyOCAqIGIsIDMpO1xuICAgICAgICB2YXIgcyA9IHBvdyQ3KEwgLSAwLjA4OTQ4NDE3NzUgKiBhIC0gMS4yOTE0ODU1NDggKiBiLCAzKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMjU1ICogbHJnYjJyZ2IoKzQuMDc2NzQxNjYyMSAqIGwgLSAzLjMwNzcxMTU5MTMgKiBtICsgMC4yMzA5Njk5MjkyICogcyksXG4gICAgICAgICAgICAyNTUgKiBscmdiMnJnYigtMS4yNjg0MzgwMDQ2ICogbCArIDIuNjA5NzU3NDAxMSAqIG0gLSAwLjM0MTMxOTM5NjUgKiBzKSxcbiAgICAgICAgICAgIDI1NSAqIGxyZ2IycmdiKC0wLjAwNDE5NjA4NjMgKiBsIC0gMC43MDM0MTg2MTQ3ICogbSArIDEuNzA3NjE0NzAxICogcyksXG4gICAgICAgICAgICBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICB2YXIgb2tsYWIycmdiXzEgPSBva2xhYjJyZ2IkMTtcblxuICAgIGZ1bmN0aW9uIGxyZ2IycmdiKGMpIHtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGMpO1xuICAgICAgICBpZiAoYWJzID4gMC4wMDMxMzA4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHNpZ24oYykgfHwgMSkgKiAoMS4wNTUgKiBwb3ckNyhhYnMsIDEgLyAyLjQpIC0gMC4wNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjICogMTIuOTI7XG4gICAgfVxuXG4gICAgdmFyIHVucGFjayQzID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDggPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkNiA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRvID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkMSA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMm9rbGFiJDEgPSByZ2Iyb2tsYWJfMTtcblxuICAgIENvbG9yJG8ucHJvdG90eXBlLm9rbGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMm9rbGFiJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDYub2tsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJG8sIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydva2xhYiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkMS5mb3JtYXQub2tsYWIgPSBva2xhYjJyZ2JfMTtcblxuICAgIGlucHV0JDEuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skMyhhcmdzLCAnb2tsYWInKTtcbiAgICAgICAgICAgIGlmICh0eXBlJDgoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29rbGFiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayQyID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByZ2Iyb2tsYWIgPSByZ2Iyb2tsYWJfMTtcbiAgICB2YXIgbGFiMmxjaCA9IGxhYjJsY2hfMTtcblxuICAgIHZhciByZ2Iyb2tsY2gkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJDIoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2Iyb2tsYWIociwgZywgYik7XG4gICAgICAgIHZhciBsID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBhID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gbGFiMmxjaChsLCBhLCBiXyk7XG4gICAgfTtcblxuICAgIHZhciByZ2Iyb2tsY2hfMSA9IHJnYjJva2xjaCQxO1xuXG4gICAgdmFyIHVucGFjayQxID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsY2gybGFiID0gbGNoMmxhYl8xO1xuICAgIHZhciBva2xhYjJyZ2IgPSBva2xhYjJyZ2JfMTtcblxuICAgIHZhciBva2xjaDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayQxKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBoID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHJlZiA9IGxjaDJsYWIobCwgYywgaCk7XG4gICAgICAgIHZhciBMID0gcmVmWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBva2xhYjJyZ2IoTCwgYSwgYl8pO1xuICAgICAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIG9rbGNoMnJnYl8xID0gb2tsY2gycmdiO1xuXG4gICAgdmFyIHVucGFjayA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQ3ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJDUgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkbiA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2Iyb2tsY2ggPSByZ2Iyb2tsY2hfMTtcblxuICAgIENvbG9yJG4ucHJvdG90eXBlLm9rbGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMm9rbGNoKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ1Lm9rbGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRuLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnb2tsY2gnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0LmZvcm1hdC5va2xjaCA9IG9rbGNoMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ29rbGNoJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ3KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdva2xjaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBDb2xvciRtID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQ2ID0gdXRpbHMudHlwZTtcblxuICAgIENvbG9yJG0ucHJvdG90eXBlLmFscGhhID0gZnVuY3Rpb24oYSwgbXV0YXRlKSB7XG4gICAgICAgIGlmICggbXV0YXRlID09PSB2b2lkIDAgKSBtdXRhdGU9ZmFsc2U7XG5cbiAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCAmJiB0eXBlJDYoYSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmdiWzNdID0gYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkbShbdGhpcy5fcmdiWzBdLCB0aGlzLl9yZ2JbMV0sIHRoaXMuX3JnYlsyXSwgYV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmdiWzNdO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkbCA9IENvbG9yXzE7XG5cbiAgICBDb2xvciRsLnByb3RvdHlwZS5jbGlwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2IuX2NsaXBwZWQgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRrID0gQ29sb3JfMTtcbiAgICB2YXIgTEFCX0NPTlNUQU5UUyQxID0gbGFiQ29uc3RhbnRzO1xuXG4gICAgQ29sb3Ikay5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHZhciBtZSA9IHRoaXM7XG4gICAgXHR2YXIgbGFiID0gbWUubGFiKCk7XG4gICAgXHRsYWJbMF0gLT0gTEFCX0NPTlNUQU5UUyQxLktuICogYW1vdW50O1xuICAgIFx0cmV0dXJuIG5ldyBDb2xvciRrKGxhYiwgJ2xhYicpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xuICAgIH07XG5cbiAgICBDb2xvciRrLnByb3RvdHlwZS5icmlnaHRlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHRyZXR1cm4gdGhpcy5kYXJrZW4oLWFtb3VudCk7XG4gICAgfTtcblxuICAgIENvbG9yJGsucHJvdG90eXBlLmRhcmtlciA9IENvbG9yJGsucHJvdG90eXBlLmRhcmtlbjtcbiAgICBDb2xvciRrLnByb3RvdHlwZS5icmlnaHRlciA9IENvbG9yJGsucHJvdG90eXBlLmJyaWdodGVuO1xuXG4gICAgdmFyIENvbG9yJGogPSBDb2xvcl8xO1xuXG4gICAgQ29sb3Ikai5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG1jKSB7XG4gICAgICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbW9kZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKSAtIChtb2RlLnN1YnN0cigwLCAyKSA9PT0gJ29rJyA/IDIgOiAwKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHsgcmV0dXJuIHNyY1tpXTsgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBpbiBtb2RlIFwiICsgbW9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkaSA9IENvbG9yXzE7XG4gICAgdmFyIHR5cGUkNSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIHBvdyQ2ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgRVBTID0gMWUtNztcbiAgICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICAgIENvbG9yJGkucHJvdG90eXBlLmx1bWluYW5jZSA9IGZ1bmN0aW9uKGx1bSkge1xuICAgICAgICBpZiAobHVtICE9PSB1bmRlZmluZWQgJiYgdHlwZSQ1KGx1bSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobHVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgYmxhY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJGkoWzAsMCwwLHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsdW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkaShbMjU1LDI1NSwyNTUsdGhpcy5fcmdiWzNdXSwgJ3JnYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cbiAgICAgICAgICAgIHZhciBjdXJfbHVtID0gdGhpcy5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgIHZhciBtb2RlID0gJ3JnYic7XG4gICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSBNQVhfSVRFUjtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBsbSA9IG1pZC5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobHVtIC0gbG0pIDwgRVBTIHx8ICFtYXhfaXRlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yJGkoWzAsMCwwXSksIHRoaXMpIDogdGVzdCh0aGlzLCBuZXcgQ29sb3IkaShbMjU1LDI1NSwyNTVdKSkpLnJnYigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRpKHJnYi5jb25jYXQoIFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCAodGhpcy5fcmdiKS5zbGljZSgwLDMpKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmdiMmx1bWluYW5jZSA9IGZ1bmN0aW9uIChyLGcsYikge1xuICAgICAgICAvLyByZWxhdGl2ZSBsdW1pbmFuY2VcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgciA9IGx1bWluYW5jZV94KHIpO1xuICAgICAgICBnID0gbHVtaW5hbmNlX3goZyk7XG4gICAgICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbiAgICB9O1xuXG4gICAgdmFyIGx1bWluYW5jZV94ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCAvPSAyNTU7XG4gICAgICAgIHJldHVybiB4IDw9IDAuMDM5MjggPyB4LzEyLjkyIDogcG93JDYoKHgrMC4wNTUpLzEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJwb2xhdG9yJDEgPSB7fTtcblxuICAgIHZhciBDb2xvciRoID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQ0ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdG9yJDE7XG5cbiAgICB2YXIgbWl4JDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICBpZiAoIGYgPT09IHZvaWQgMCApIGY9MC41O1xuICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMztcbiAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMyBdO1xuXG4gICAgICAgIHZhciBtb2RlID0gcmVzdFswXSB8fCAnbHJnYic7XG4gICAgICAgIGlmICghaW50ZXJwb2xhdG9yW21vZGVdICYmICFyZXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGludGVycG9sYXRvcilbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJpbnRlcnBvbGF0aW9uIG1vZGUgXCIgKyBtb2RlICsgXCIgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlJDQoY29sMSkgIT09ICdvYmplY3QnKSB7IGNvbDEgPSBuZXcgQ29sb3IkaChjb2wxKTsgfVxuICAgICAgICBpZiAodHlwZSQ0KGNvbDIpICE9PSAnb2JqZWN0JykgeyBjb2wyID0gbmV3IENvbG9yJGgoY29sMik7IH1cbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvclttb2RlXShjb2wxLCBjb2wyLCBmKVxuICAgICAgICAgICAgLmFscGhhKGNvbDEuYWxwaGEoKSArIGYgKiAoY29sMi5hbHBoYSgpIC0gY29sMS5hbHBoYSgpKSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRnID0gQ29sb3JfMTtcbiAgICB2YXIgbWl4ID0gbWl4JDE7XG5cbiAgICBDb2xvciRnLnByb3RvdHlwZS5taXggPVxuICAgIENvbG9yJGcucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oY29sMiwgZikge1xuICAgIFx0aWYgKCBmID09PSB2b2lkIDAgKSBmPTAuNTtcbiAgICBcdHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIFx0d2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgXHRyZXR1cm4gbWl4LmFwcGx5KHZvaWQgMCwgWyB0aGlzLCBjb2wyLCBmIF0uY29uY2F0KCByZXN0ICkpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZiA9IENvbG9yXzE7XG5cbiAgICBDb2xvciRmLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uKG11dGF0ZSkge1xuICAgIFx0aWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZT1mYWxzZTtcblxuICAgIFx0dmFyIHJnYiA9IHRoaXMuX3JnYjtcbiAgICBcdHZhciBhID0gcmdiWzNdO1xuICAgIFx0aWYgKG11dGF0ZSkge1xuICAgIFx0XHR0aGlzLl9yZ2IgPSBbcmdiWzBdKmEsIHJnYlsxXSphLCByZ2JbMl0qYSwgYV07XG4gICAgXHRcdHJldHVybiB0aGlzO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0cmV0dXJuIG5ldyBDb2xvciRmKFtyZ2JbMF0qYSwgcmdiWzFdKmEsIHJnYlsyXSphLCBhXSwgJ3JnYicpO1xuICAgIFx0fVxuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkZSA9IENvbG9yXzE7XG4gICAgdmFyIExBQl9DT05TVEFOVFMgPSBsYWJDb25zdGFudHM7XG5cbiAgICBDb2xvciRlLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHR2YXIgbWUgPSB0aGlzO1xuICAgIFx0dmFyIGxjaCA9IG1lLmxjaCgpO1xuICAgIFx0bGNoWzFdICs9IExBQl9DT05TVEFOVFMuS24gKiBhbW91bnQ7XG4gICAgXHRpZiAobGNoWzFdIDwgMCkgeyBsY2hbMV0gPSAwOyB9XG4gICAgXHRyZXR1cm4gbmV3IENvbG9yJGUobGNoLCAnbGNoJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIENvbG9yJGUucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0cmV0dXJuIHRoaXMuc2F0dXJhdGUoLWFtb3VudCk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRkID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQzID0gdXRpbHMudHlwZTtcblxuICAgIENvbG9yJGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtYywgdmFsdWUsIG11dGF0ZSkge1xuICAgICAgICBpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBpID0gbW9kZS5pbmRleE9mKGNoYW5uZWwpIC0gKG1vZGUuc3Vic3RyKDAsIDIpID09PSAnb2snID8gMiA6IDApO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlJDModmFsdWUpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSAqPSArdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldIC89ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQzKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdmFsdWUgZm9yIENvbG9yLnNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvciRkKHNyYywgbW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZ2IgPSBvdXQuX3JnYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRjID0gQ29sb3JfMTtcblxuICAgIHZhciByZ2IgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEuX3JnYjtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLl9yZ2I7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkYyhcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0teHl6MFswXSksXG4gICAgICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdLXh5ejBbMV0pLFxuICAgICAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXS14eXowWzJdKSxcbiAgICAgICAgICAgICdyZ2InXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEucmdiID0gcmdiO1xuXG4gICAgdmFyIENvbG9yJGIgPSBDb2xvcl8xO1xuICAgIHZhciBzcXJ0JDIgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHBvdyQ1ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgbHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4MSA9IHJlZlswXTtcbiAgICAgICAgdmFyIHkxID0gcmVmWzFdO1xuICAgICAgICB2YXIgejEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGNvbDIuX3JnYjtcbiAgICAgICAgdmFyIHgyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgejIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRiKFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHgxLDIpICogKDEtZikgKyBwb3ckNSh4MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHkxLDIpICogKDEtZikgKyBwb3ckNSh5MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHoxLDIpICogKDEtZikgKyBwb3ckNSh6MiwyKSAqIGYpLFxuICAgICAgICAgICAgJ3JnYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5scmdiID0gbHJnYjtcblxuICAgIHZhciBDb2xvciRhID0gQ29sb3JfMTtcblxuICAgIHZhciBsYWIgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5sYWIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRhKFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXS14eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0teHl6MFsxXSksXG4gICAgICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdLXh5ejBbMl0pLFxuICAgICAgICAgICAgJ2xhYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5sYWIgPSBsYWI7XG5cbiAgICB2YXIgQ29sb3IkOSA9IENvbG9yXzE7XG5cbiAgICB2YXIgX2hzeCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxO1xuXG4gICAgICAgIHZhciB4eXowLCB4eXoxO1xuICAgICAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzdicpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzdigpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHN2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hjZycpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjZygpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNnKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2xjaCcgfHwgbSA9PT0gJ2hjbCcpIHtcbiAgICAgICAgICAgIG0gPSAnaGNsJztcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ29rbGNoJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5va2xjaCgpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBodWUwLCBodWUxLCBzYXQwLCBzYXQxLCBsYnYwLCBsYnYxO1xuICAgICAgICBpZiAobS5zdWJzdHIoMCwgMSkgPT09ICdoJyB8fCBtID09PSAnb2tsY2gnKSB7XG4gICAgICAgICAgICAoYXNzaWduID0geHl6MCwgaHVlMCA9IGFzc2lnblswXSwgc2F0MCA9IGFzc2lnblsxXSwgbGJ2MCA9IGFzc2lnblsyXSk7XG4gICAgICAgICAgICAoYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgICAgICBpZiAoIWlzTmFOKGh1ZTApICYmICFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgLy8gYm90aCBjb2xvcnMgaGF2ZSBodWVcbiAgICAgICAgICAgIGlmIChodWUxID4gaHVlMCAmJiBodWUxIC0gaHVlMCA+IDE4MCkge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgKyAzNjAgLSBodWUwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgLSBodWUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHVlID0gaHVlMCArIGYgKiBkaDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgICAgICAgIGh1ZSA9IGh1ZTA7XG4gICAgICAgICAgICBpZiAoKGxidjEgPT0gMSB8fCBsYnYxID09IDApICYmIG0gIT0gJ2hzdicpIHsgc2F0ID0gc2F0MDsgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgaHVlID0gaHVlMTtcbiAgICAgICAgICAgIGlmICgobGJ2MCA9PSAxIHx8IGxidjAgPT0gMCkgJiYgbSAhPSAnaHN2JykgeyBzYXQgPSBzYXQxOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodWUgPSBOdW1iZXIuTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhdCA9PT0gdW5kZWZpbmVkKSB7IHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTsgfVxuICAgICAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgICAgIHJldHVybiBtID09PSAnb2tsY2gnID8gbmV3IENvbG9yJDkoW2xidiwgc2F0LCBodWVdLCBtKSA6IG5ldyBDb2xvciQ5KFtodWUsIHNhdCwgbGJ2XSwgbSk7XG4gICAgfTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkNSA9IF9oc3g7XG5cbiAgICB2YXIgbGNoID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkNShjb2wxLCBjb2wyLCBmLCAnbGNoJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmxjaCA9IGxjaDtcbiAgICBpbnRlcnBvbGF0b3IkMS5oY2wgPSBsY2g7XG5cbiAgICB2YXIgQ29sb3IkOCA9IENvbG9yXzE7XG5cbiAgICB2YXIgbnVtID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICAgICAgdmFyIGMyID0gY29sMi5udW0oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ4KGMxICsgZiAqIChjMi1jMSksICdudW0nKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5udW0gPSBudW07XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDQgPSBfaHN4O1xuXG4gICAgdmFyIGhjZyA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDQoY29sMSwgY29sMiwgZiwgJ2hjZycpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oY2cgPSBoY2c7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDMgPSBfaHN4O1xuXG4gICAgdmFyIGhzaSA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDMoY29sMSwgY29sMiwgZiwgJ2hzaScpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc2kgPSBoc2k7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDIgPSBfaHN4O1xuXG4gICAgdmFyIGhzbCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDIoY29sMSwgY29sMiwgZiwgJ2hzbCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc2wgPSBoc2w7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGVfaHN4JDEgPSBfaHN4O1xuXG4gICAgdmFyIGhzdiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgXHRyZXR1cm4gaW50ZXJwb2xhdGVfaHN4JDEoY29sMSwgY29sMiwgZiwgJ2hzdicpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5oc3YgPSBoc3Y7XG5cbiAgICB2YXIgQ29sb3IkNyA9IENvbG9yXzE7XG5cbiAgICB2YXIgb2tsYWIgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEub2tsYWIoKTtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLm9rbGFiKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNyhcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgICAgICdva2xhYidcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEub2tsYWIgPSBva2xhYjtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3ggPSBfaHN4O1xuXG4gICAgdmFyIG9rbGNoID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnb2tsY2gnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEub2tsY2ggPSBva2xjaDtcblxuICAgIHZhciBDb2xvciQ2ID0gQ29sb3JfMTtcbiAgICB2YXIgY2xpcF9yZ2IkMSA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICAgIHZhciBzcXJ0JDEgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIFBJJDEgPSBNYXRoLlBJO1xuICAgIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICAgIHZhciBzaW4kMiA9IE1hdGguc2luO1xuICAgIHZhciBhdGFuMiQxID0gTWF0aC5hdGFuMjtcblxuICAgIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgd2VpZ2h0cykge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGU9J2xyZ2InO1xuICAgICAgICBpZiAoIHdlaWdodHMgPT09IHZvaWQgMCApIHdlaWdodHM9bnVsbDtcblxuICAgICAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgIGlmICghd2VpZ2h0cykgeyB3ZWlnaHRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkobCkpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9KTsgfVxuICAgICAgICAvLyBub3JtYWxpemUgd2VpZ2h0c1xuICAgICAgICB2YXIgayA9IGwgLyB3ZWlnaHRzLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG4gICAgICAgIHdlaWdodHMuZm9yRWFjaChmdW5jdGlvbiAodyxpKSB7IHdlaWdodHNbaV0gKj0gazsgfSk7XG4gICAgICAgIC8vIGNvbnZlcnQgY29sb3JzIHRvIENvbG9yIG9iamVjdHNcbiAgICAgICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IENvbG9yJDYoYyk7IH0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2xyZ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gY29sb3JzLnNoaWZ0KCk7XG4gICAgICAgIHZhciB4eXogPSBmaXJzdC5nZXQobW9kZSk7XG4gICAgICAgIHZhciBjbnQgPSBbXTtcbiAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbCBjb2xvclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8eHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgICAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG4gICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJyAmJiAhaXNOYU4oeHl6W2ldKSkge1xuICAgICAgICAgICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICAgICAgZHkgKz0gc2luJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjLGNpKSB7XG4gICAgICAgICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNudFtpXSArPSB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSB4eXoyW2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ICs9IGNvcyQyKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHNpbiQyKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5eltpXSArPSB4eXoyW2ldICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSQxPTA7IGkkMTx4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgIHZhciBBJDEgPSBhdGFuMiQxKGR5IC8gY250W2kkMV0sIGR4IC8gY250W2kkMV0pIC8gUEkkMSAqIDE4MDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoQSQxIDwgMCkgeyBBJDEgKz0gMzYwOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHsgQSQxIC09IDM2MDsgfVxuICAgICAgICAgICAgICAgIHh5eltpJDFdID0gQSQxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdL2NudFtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFscGhhIC89IGw7XG4gICAgICAgIHJldHVybiAobmV3IENvbG9yJDYoeHl6LCBtb2RlKSkuYWxwaGEoYWxwaGEgPiAwLjk5OTk5ID8gMSA6IGFscGhhLCB0cnVlKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2F2ZXJhZ2VfbHJnYiA9IGZ1bmN0aW9uIChjb2xvcnMsIHdlaWdodHMpIHtcbiAgICAgICAgdmFyIGwgPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgeHl6ID0gWzAsMCwwLDBdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICB2YXIgZiA9IHdlaWdodHNbaV0gLyBsO1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbC5fcmdiO1xuICAgICAgICAgICAgeHl6WzBdICs9IHBvdyQ0KHJnYlswXSwyKSAqIGY7XG4gICAgICAgICAgICB4eXpbMV0gKz0gcG93JDQocmdiWzFdLDIpICogZjtcbiAgICAgICAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sMikgKiBmO1xuICAgICAgICAgICAgeHl6WzNdICs9IHJnYlszXSAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgeHl6WzBdID0gc3FydCQxKHh5elswXSk7XG4gICAgICAgIHh5elsxXSA9IHNxcnQkMSh4eXpbMV0pO1xuICAgICAgICB4eXpbMl0gPSBzcXJ0JDEoeHl6WzJdKTtcbiAgICAgICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkgeyB4eXpbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNihjbGlwX3JnYiQxKHh5eikpO1xuICAgIH07XG5cbiAgICAvLyBtaW5pbWFsIG11bHRpLXB1cnBvc2UgaW50ZXJmYWNlXG5cbiAgICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG4gICAgdmFyIGNocm9tYSQ0ID0gY2hyb21hXzE7XG4gICAgdmFyIHR5cGUkMiA9IHV0aWxzLnR5cGU7XG5cbiAgICB2YXIgcG93JDMgPSBNYXRoLnBvdztcblxuICAgIHZhciBzY2FsZSQyID0gZnVuY3Rpb24oY29sb3JzKSB7XG5cbiAgICAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgdmFyIF9tb2RlID0gJ3JnYic7XG4gICAgICAgIHZhciBfbmFjb2wgPSBjaHJvbWEkNCgnI2NjYycpO1xuICAgICAgICB2YXIgX3NwcmVhZCA9IDA7XG4gICAgICAgIC8vIGNvbnN0IF9maXhlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICAgICAgdmFyIF9wb3MgPSBbXTtcbiAgICAgICAgdmFyIF9wYWRkaW5nID0gWzAsMF07XG4gICAgICAgIHZhciBfY2xhc3NlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgX291dCA9IGZhbHNlO1xuICAgICAgICB2YXIgX21pbiA9IDA7XG4gICAgICAgIHZhciBfbWF4ID0gMTtcbiAgICAgICAgdmFyIF9jb3JyZWN0TGlnaHRuZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBfY29sb3JDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9nYW1tYSA9IDE7XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgdmFyIHNldENvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG4gICAgICAgICAgICBpZiAoY29sb3JzICYmIHR5cGUkMihjb2xvcnMpID09PSAnc3RyaW5nJyAmJiBjaHJvbWEkNC5icmV3ZXIgJiZcbiAgICAgICAgICAgICAgICBjaHJvbWEkNC5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzID0gY2hyb21hJDQuYnJld2VyW2NvbG9ycy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlJDIoY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29sb3JzWzBdLCBjb2xvcnNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG4gICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGM8Y29sb3JzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYSQ0KGNvbG9yc1tjXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF1dG8tZmlsbCBjb2xvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgIF9wb3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjJDE9MDsgYyQxPGNvbG9ycy5sZW5ndGg7IGMkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjJDEvKGNvbG9ycy5sZW5ndGgtMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29sb3JzID0gY29sb3JzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiB2YWx1ZSA+PSBfY2xhc3Nlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuICAgICAgICB2YXIgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuXG4gICAgICAgIC8vIGNvbnN0IGNsYXNzaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgICAgICAvLyAgICAgaWYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtaW5jID0gX2NsYXNzZXNbMF0gKyAoKF9jbGFzc2VzWzFdLV9jbGFzc2VzWzBdKSAqICgwICsgKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgMXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgY29uc3QgbWF4YyA9IF9jbGFzc2VzW24tMV0gKyAoKF9jbGFzc2VzW25dLV9jbGFzc2VzW24tMV0pICogKDEgLSAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiBsYXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiB2YWw7XG4gICAgICAgIC8vIH07XG5cbiAgICAgICAgdmFyIGdldENvbG9yID0gZnVuY3Rpb24odmFsLCBieXBhc3NNYXApIHtcbiAgICAgICAgICAgIHZhciBjb2wsIHQ7XG4gICAgICAgICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHsgYnlwYXNzTWFwID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChpc05hTih2YWwpIHx8ICh2YWwgPT09IG51bGwpKSB7IHJldHVybiBfbmFjb2w7IH1cbiAgICAgICAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGdldENsYXNzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aC0yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBpbnRlcnBvbGF0ZSBiZXR3ZWVuIG1pbi9tYXhcbiAgICAgICAgICAgICAgICAgICAgdCA9ICh2YWwgLSBfbWluKSAvIChfbWF4IC0gX21pbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb21haW4gbWFwXG4gICAgICAgICAgICB0ID0gdE1hcERvbWFpbih0KTtcblxuICAgICAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgICAgICB0ID0gdE1hcExpZ2h0bmVzcyh0KTsgIC8vIGxpZ2h0bmVzcyBjb3JyZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfZ2FtbWEgIT09IDEpIHsgdCA9IHBvdyQzKHQsIF9nYW1tYSk7IH1cblxuICAgICAgICAgICAgdCA9IF9wYWRkaW5nWzBdICsgKHQgKiAoMSAtIF9wYWRkaW5nWzBdIC0gX3BhZGRpbmdbMV0pKTtcblxuICAgICAgICAgICAgdCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHQpKTtcblxuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHQgKiAxMDAwMCk7XG5cbiAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUgJiYgX2NvbG9yQ2FjaGVba10pIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMihfY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8X3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgPj0gcCkgJiYgKGkgPT09IChfcG9zLmxlbmd0aC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2krMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQtcCkvKF9wb3NbaSsxXS1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjaHJvbWEkNC5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2krMV0sIHQsIF9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQyKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnModCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUpIHsgX2NvbG9yQ2FjaGVba10gPSBjb2w7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29sb3JDYWNoZSA9IHt9OyB9O1xuXG4gICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hyb21hJDQoZ2V0Q29sb3IodikpO1xuICAgICAgICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkgeyByZXR1cm4gY1tfb3V0XSgpOyB9IGVsc2UgeyByZXR1cm4gYzsgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSQyKGNsYXNzZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGNocm9tYSQ0LmFuYWx5emUoX2RvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjaHJvbWEkNC5saW1pdHMoZCwgJ2UnLCBjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY2xhc3NlcztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGYuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9taW4gPSBkb21haW5bMF07XG4gICAgICAgICAgICBfbWF4ID0gZG9tYWluW2RvbWFpbi5sZW5ndGgtMV07XG4gICAgICAgICAgICBfcG9zID0gW107XG4gICAgICAgICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChkb21haW4ubGVuZ3RoID09PSBrKSAmJiAoX21pbiAhPT0gX21heCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKChkLV9taW4pIC8gKF9tYXgtX21pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjPGs7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBfcG9zLnB1c2goYy8oay0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZG9tYWluIG1hcFxuICAgICAgICAgICAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsaSkgeyByZXR1cm4gaS8oZG9tYWluLmxlbmd0aC0xKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0QnJlYWtzID0gZG9tYWluLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQgLSBfbWluKSAvIChfbWF4IC0gX21pbik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRCcmVha3MuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdE91dFtpXSA9PT0gdmFsOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHsgcmV0dXJuIHQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpKzFdKSB7IGkrKzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gKHQgLSB0QnJlYWtzW2ldKSAvICh0QnJlYWtzW2krMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gdE91dFtpXSArIGYgKiAodE91dFtpKzFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9kb21haW4gPSBbX21pbiwgX21heF07XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm1vZGUgPSBmdW5jdGlvbihfbSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZGUgPSBfbTtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucmFuZ2UgPSBmdW5jdGlvbihjb2xvcnMsIF9wb3MpIHtcbiAgICAgICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5vdXQgPSBmdW5jdGlvbihfbykge1xuICAgICAgICAgICAgX291dCA9IF9vO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zcHJlYWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3ByZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY29ycmVjdExpZ2h0bmVzcyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHsgdiA9IHRydWU7IH1cbiAgICAgICAgICAgIF9jb3JyZWN0TGlnaHRuZXNzID0gdjtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIGlmIChfY29ycmVjdExpZ2h0bmVzcykge1xuICAgICAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTDEgPSBnZXRDb2xvcigxLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbCA9IEwwID4gTDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9pZGVhbCA9IEwwICsgKChMMSAtIEwwKSAqIHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDAgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChNYXRoLmFicyhMX2RpZmYpID4gMWUtMikgJiYgKG1heF9pdGVyLS0gPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2wpIHsgTF9kaWZmICo9IC0xOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MSAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnBhZGRpbmcgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IFtwLHBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcGFkZGluZyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmNvbG9ycyA9IGZ1bmN0aW9uKG51bUNvbG9ycywgb3V0KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCByZXR1cm4gdGhlIG9yaWdpbmFsIGNvbG9ycyB0aGF0IHdlcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyBvdXQgPSAnaGV4JzsgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2YoMC41KV07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkbSA9IF9kb21haW5bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRkID0gX2RvbWFpblsxXSAtIGRtO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGYoIGRtICsgKChpLyhudW1Db2xvcnMtMSkpICogZGQpICk7IH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZXR1cm5zIGFsbCBjb2xvcnMgYmFzZWQgb24gdGhlIGRlZmluZWQgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpLTFdK19jbGFzc2VzW2ldKSowLjUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyA9IF9kb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmKHYpOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNocm9tYSQ0W291dF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjW291dF0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2FjaGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3VzZUNhY2hlID0gYztcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmdhbW1hID0gZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgaWYgKGcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5ub2RhdGEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX25hY29sID0gY2hyb21hJDQoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9fcmFuZ2VfXyhsZWZ0LCByaWdodCwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgICB2YXIgZW5kID0gIWluY2x1c2l2ZSA/IHJpZ2h0IDogYXNjZW5kaW5nID8gcmlnaHQgKyAxIDogcmlnaHQgLSAxO1xuICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGFzY2VuZGluZyA/IGkgPCBlbmQgOiBpID4gZW5kOyBhc2NlbmRpbmcgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgcmFuZ2UucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAvL1xuXG4gICAgLy8gQHJlcXVpcmVzIHV0aWxzIGxhYlxuICAgIHZhciBDb2xvciQ1ID0gQ29sb3JfMTtcblxuICAgIHZhciBzY2FsZSQxID0gc2NhbGUkMjtcblxuICAgIC8vIG50aCByb3cgb2YgdGhlIHBhc2NhbCB0cmlhbmdsZVxuICAgIHZhciBiaW5vbV9yb3cgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciByb3cgPSBbMSwgMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3cm93ID0gWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3cm93W2pdID0gKHJvd1tqXSB8fCAwKSArIHJvd1tqIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3cgPSBuZXdyb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9O1xuXG4gICAgdmFyIGJlemllciA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDI7XG5cbiAgICAgICAgdmFyIEksIGxhYjAsIGxhYjEsIGxhYjI7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvciQ1KGMpOyB9KTtcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAoYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ25bMF0sIGxhYjEgPSBhc3NpZ25bMV0pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGxhYjBbaV0gKyAodCAqIChsYWIxW2ldIC0gbGFiMFtpXSkpOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIChhc3NpZ24kMSA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKDEtdCkqKDEtdCkgKiBsYWIwW2ldKSArICgyICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAodCAqIHQgKiBsYWIyW2ldKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBsYWIzO1xuICAgICAgICAgICAgKGFzc2lnbiQyID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXSk7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gKCgxLXQpKigxLXQpKigxLXQpICogbGFiMFtpXSkgKyAoMyAqICgxLXQpICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAoMyAqICgxLXQpICogdCAqIHQgKiBsYWIyW2ldKSArICh0KnQqdCAqIGxhYjNbaV0pOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgY2FzZSAoZGVncmVlIG4gYmV6aWVyKVxuICAgICAgICAgICAgdmFyIGxhYnMsIHJvdywgbjtcbiAgICAgICAgICAgIGxhYnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmxhYigpOyB9KTtcbiAgICAgICAgICAgIG4gPSBjb2xvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJvdyA9IGJpbm9tX3JvdyhuKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gMSAtIHQ7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBsYWJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBlbCwgaikgeyByZXR1cm4gKHN1bSArIHJvd1tqXSAqIE1hdGgucG93KCB1LCAobiAtIGopICkgKiBNYXRoLnBvdyggdCwgaiApICogZWxbaV0pOyB9LCAwKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkNShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHBvaW50IGluIHJ1bm5pbmcgYmV6aWVyIHdpdGggb25seSBvbmUgY29sb3IuXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEk7XG4gICAgfTtcblxuICAgIHZhciBiZXppZXJfMSA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgICAgICAgdmFyIGYgPSBiZXppZXIoY29sb3JzKTtcbiAgICAgICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjYWxlJDEoZik7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAgKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgICAqL1xuXG4gICAgdmFyIGNocm9tYSQzID0gY2hyb21hXzE7XG5cbiAgICB2YXIgYmxlbmQgPSBmdW5jdGlvbiAoYm90dG9tLCB0b3AsIG1vZGUpIHtcbiAgICAgICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gICAgfTtcblxuICAgIHZhciBibGVuZF9mID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChib3R0b20sdG9wKSB7XG4gICAgICAgICAgICB2YXIgYzAgPSBjaHJvbWEkMyh0b3ApLnJnYigpO1xuICAgICAgICAgICAgdmFyIGMxID0gY2hyb21hJDMoYm90dG9tKS5yZ2IoKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWEkMy5yZ2IoZihjMCwgYzEpKTtcbiAgICAgICAgfTsgfTtcblxuICAgIHZhciBlYWNoID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07IH07XG5cbiAgICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4gICAgdmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSAqIGIgLyAyNTU7IH07XG4gICAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgPiBiID8gYiA6IGE7IH07XG4gICAgdmFyIGxpZ2h0ZW4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhID4gYiA/IGEgOiBiOyB9O1xuICAgIHZhciBzY3JlZW4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiAyNTUgKiAoMSAtICgxLWEvMjU1KSAqICgxLWIvMjU1KSk7IH07XG4gICAgdmFyIG92ZXJsYXkgPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBiIDwgMTI4ID8gMiAqIGEgKiBiIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1ICkgKiAoIDEgLSBiIC8gMjU1ICkpOyB9O1xuICAgIHZhciBidXJuID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gMjU1ICogKDEgLSAoMSAtIGIgLyAyNTUpIC8gKGEvMjU1KSk7IH07XG4gICAgdmFyIGRvZGdlID0gZnVuY3Rpb24gKGEsYikge1xuICAgICAgICBpZiAoYSA9PT0gMjU1KSB7IHJldHVybiAyNTU7IH1cbiAgICAgICAgYSA9IDI1NSAqIChiIC8gMjU1KSAvICgxIC0gYSAvIDI1NSk7XG4gICAgICAgIHJldHVybiBhID4gMjU1ID8gMjU1IDogYVxuICAgIH07XG5cbiAgICAvLyAjIGFkZCA9IChhLGIpIC0+XG4gICAgLy8gIyAgICAgaWYgKGEgKyBiID4gMjU1KSB0aGVuIDI1NSBlbHNlIGEgKyBiXG5cbiAgICBibGVuZC5ub3JtYWwgPSBibGVuZF9mKGVhY2gobm9ybWFsKSk7XG4gICAgYmxlbmQubXVsdGlwbHkgPSBibGVuZF9mKGVhY2gobXVsdGlwbHkpKTtcbiAgICBibGVuZC5zY3JlZW4gPSBibGVuZF9mKGVhY2goc2NyZWVuKSk7XG4gICAgYmxlbmQub3ZlcmxheSA9IGJsZW5kX2YoZWFjaChvdmVybGF5KSk7XG4gICAgYmxlbmQuZGFya2VuID0gYmxlbmRfZihlYWNoKGRhcmtlbikpO1xuICAgIGJsZW5kLmxpZ2h0ZW4gPSBibGVuZF9mKGVhY2gobGlnaHRlbikpO1xuICAgIGJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG4gICAgYmxlbmQuYnVybiA9IGJsZW5kX2YoZWFjaChidXJuKSk7XG4gICAgLy8gYmxlbmQuYWRkID0gYmxlbmRfZihlYWNoKGFkZCkpO1xuXG4gICAgdmFyIGJsZW5kXzEgPSBibGVuZDtcblxuICAgIC8vIGN1YmVoZWxpeCBpbnRlcnBvbGF0aW9uXG4gICAgLy8gYmFzZWQgb24gRC5BLiBHcmVlbiBcIkEgY29sb3VyIHNjaGVtZSBmb3IgdGhlIGRpc3BsYXkgb2YgYXN0cm9ub21pY2FsIGludGVuc2l0eSBpbWFnZXNcIlxuICAgIC8vIGh0dHA6Ly9hc3Ryb24tc29jLmluL2J1bGxldGluLzExSnVuZS8yODkzOTIwMTEucGRmXG5cbiAgICB2YXIgdHlwZSQxID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2xpcF9yZ2IgPSB1dGlscy5jbGlwX3JnYjtcbiAgICB2YXIgVFdPUEkgPSB1dGlscy5UV09QSTtcbiAgICB2YXIgcG93JDIgPSBNYXRoLnBvdztcbiAgICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgICB2YXIgY29zJDEgPSBNYXRoLmNvcztcbiAgICB2YXIgY2hyb21hJDIgPSBjaHJvbWFfMTtcblxuICAgIHZhciBjdWJlaGVsaXggPSBmdW5jdGlvbihzdGFydCwgcm90YXRpb25zLCBodWUsIGdhbW1hLCBsaWdodG5lc3MpIHtcbiAgICAgICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQ9MzAwO1xuICAgICAgICBpZiAoIHJvdGF0aW9ucyA9PT0gdm9pZCAwICkgcm90YXRpb25zPS0xLjU7XG4gICAgICAgIGlmICggaHVlID09PSB2b2lkIDAgKSBodWU9MTtcbiAgICAgICAgaWYgKCBnYW1tYSA9PT0gdm9pZCAwICkgZ2FtbWE9MTtcbiAgICAgICAgaWYgKCBsaWdodG5lc3MgPT09IHZvaWQgMCApIGxpZ2h0bmVzcz1bMCwxXTtcblxuICAgICAgICB2YXIgZGggPSAwLCBkbDtcbiAgICAgICAgaWYgKHR5cGUkMShsaWdodG5lc3MpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkbCA9IGxpZ2h0bmVzc1sxXSAtIGxpZ2h0bmVzc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKGZyYWN0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IFRXT1BJICogKCgoc3RhcnQrMTIwKS8zNjApICsgKHJvdGF0aW9ucyAqIGZyYWN0KSk7XG4gICAgICAgICAgICB2YXIgbCA9IHBvdyQyKGxpZ2h0bmVzc1swXSArIChkbCAqIGZyYWN0KSwgZ2FtbWEpO1xuICAgICAgICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIChmcmFjdCAqIGRoKSA6IGh1ZTtcbiAgICAgICAgICAgIHZhciBhbXAgPSAoaCAqIGwgKiAoMS1sKSkgLyAyO1xuICAgICAgICAgICAgdmFyIGNvc19hID0gY29zJDEoYSk7XG4gICAgICAgICAgICB2YXIgc2luX2EgPSBzaW4kMShhKTtcbiAgICAgICAgICAgIHZhciByID0gbCArIChhbXAgKiAoKC0wLjE0ODYxICogY29zX2EpICsgKDEuNzgyNzcqIHNpbl9hKSkpO1xuICAgICAgICAgICAgdmFyIGcgPSBsICsgKGFtcCAqICgoLTAuMjkyMjcgKiBjb3NfYSkgLSAoMC45MDY0OSogc2luX2EpKSk7XG4gICAgICAgICAgICB2YXIgYiA9IGwgKyAoYW1wICogKCsxLjk3Mjk0ICogY29zX2EpKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWEkMihjbGlwX3JnYihbcioyNTUsZyoyNTUsYioyNTUsMV0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnN0YXJ0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgaWYgKChzID09IG51bGwpKSB7IHJldHVybiBzdGFydDsgfVxuICAgICAgICAgICAgc3RhcnQgPSBzO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5yb3RhdGlvbnMgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoKHIgPT0gbnVsbCkpIHsgcmV0dXJuIHJvdGF0aW9uczsgfVxuICAgICAgICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuZ2FtbWEgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICBpZiAoKGcgPT0gbnVsbCkpIHsgcmV0dXJuIGdhbW1hOyB9XG4gICAgICAgICAgICBnYW1tYSA9IGc7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmh1ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIGlmICgoaCA9PSBudWxsKSkgeyByZXR1cm4gaHVlOyB9XG4gICAgICAgICAgICBodWUgPSBoO1xuICAgICAgICAgICAgaWYgKHR5cGUkMShodWUpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG4gICAgICAgICAgICAgICAgaWYgKGRoID09PSAwKSB7IGh1ZSA9IGh1ZVsxXTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIGlmICgoaCA9PSBudWxsKSkgeyByZXR1cm4gbGlnaHRuZXNzOyB9XG4gICAgICAgICAgICBpZiAodHlwZSQxKGgpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgbGlnaHRuZXNzID0gaDtcbiAgICAgICAgICAgICAgICBkbCA9IGhbMV0gLSBoWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaWdodG5lc3MgPSBbaCxoXTtcbiAgICAgICAgICAgICAgICBkbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hyb21hJDIuc2NhbGUoZik7IH07XG5cbiAgICAgICAgZi5odWUoaHVlKTtcblxuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJDQgPSBDb2xvcl8xO1xuICAgIHZhciBkaWdpdHMgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgICB2YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgdmFyIHJhbmRvbV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZSA9ICcjJztcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPDY7IGkrKykge1xuICAgICAgICAgICAgY29kZSArPSBkaWdpdHMuY2hhckF0KGZsb29yJDEocmFuZG9tKCkgKiAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IkNChjb2RlLCAnaGV4Jyk7XG4gICAgfTtcblxuICAgIHZhciB0eXBlID0gdHlwZSRwO1xuICAgIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgICB2YXIgcG93JDEgPSBNYXRoLnBvdztcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5cbiAgICB2YXIgYW5hbHl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICAgICAgaWYgKCBrZXkgPT09IHZvaWQgMCApIGtleT1udWxsO1xuXG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFKi0xLFxuICAgICAgICAgICAgc3VtOiAwLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YSA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgdHlwZSh2YWwpID09PSAnb2JqZWN0JykgeyB2YWwgPSB2YWxba2V5XTsgfVxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCAmJiAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHIudmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICByLnN1bSArPSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7IHIubWluID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IHIubWF4KSB7IHIubWF4ID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgci5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgICAgIHIubGltaXRzID0gZnVuY3Rpb24gKG1vZGUsIG51bSkgeyByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7IH07XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuXG4gICAgdmFyIGxpbWl0cyA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlLCBudW0pIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdlcXVhbCc7XG4gICAgICAgIGlmICggbnVtID09PSB2b2lkIDAgKSBudW09NztcblxuICAgICAgICBpZiAodHlwZShkYXRhKSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkYXRhID0gYW5hbHl6ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gZGF0YS5taW47XG4gICAgICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGRhdGEudmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS1iOyB9KTtcblxuICAgICAgICBpZiAobnVtID09PSAxKSB7IHJldHVybiBbbWluLG1heF07IH1cblxuICAgICAgICB2YXIgbGltaXRzID0gW107XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdjJykgeyAvLyBjb250aW51b3VzXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnZScpIHsgLy8gZXF1YWwgaW50ZXJ2YWxcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8bnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaChtaW4rKChpL251bSkqKG1heC1taW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2wnKSB7IC8vIGxvZyBzY2FsZVxuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5fbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWluKTtcbiAgICAgICAgICAgIHZhciBtYXhfbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWF4KTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDE9MTsgaSQxPG51bTsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaChwb3ckMSgxMCwgbWluX2xvZyArICgoaSQxL251bSkgKiAobWF4X2xvZyAtIG1pbl9sb2cpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdxJykgeyAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMj0xOyBpJDI8bnVtOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gKCh2YWx1ZXMubGVuZ3RoLTEpICogaSQyKS9udW07XG4gICAgICAgICAgICAgICAgdmFyIHBiID0gZmxvb3IocCk7XG4gICAgICAgICAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHAgPiBwYlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHIgPSBwIC0gcGI7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKCh2YWx1ZXNbcGJdKigxLXByKSkgKyAodmFsdWVzW3BiKzFdKnByKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2snKSB7IC8vIGstbWVhbnMgY2x1c3RlcmluZ1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICAgICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgICAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgY2x1c3RlcjtcbiAgICAgICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBnZXQgc2VlZCB2YWx1ZXNcbiAgICAgICAgICAgIGNlbnRyb2lkcyA9IFtdO1xuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMz0xOyBpJDM8bnVtOyBpJDMrKykge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArICgoaSQzL251bSkgKiAobWF4LW1pbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1heCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8bnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0PTA7IGkkNDxuOyBpJDQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDE9MDsgaiQxPG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzJDEoY2VudHJvaWRzW2okMV0tdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGokMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHNbaSQ0XSA9IGJlc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2VudHJvaWRzIHN0ZXBcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2VudHJvaWRzID0gbmV3IEFycmF5KG51bSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQyPTA7IGokMjxudW07IGokMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqJDJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ1PTA7IGkkNTxuOyBpJDUrKykge1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbY2x1c3Rlcl0gKz0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQzPTA7IGokMzxudW07IGokMysrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqJDNdICo9IDEvY2x1c3RlclNpemVzW2okM107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29udmVyZ2VuY2VcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDQ9MDsgaiQ0PG51bTsgaiQ0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqJDRdICE9PSBjZW50cm9pZHNbaiQ0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VudHJvaWRzID0gbmV3Q2VudHJvaWRzO1xuICAgICAgICAgICAgICAgIG5iX2l0ZXJzKys7XG5cbiAgICAgICAgICAgICAgICBpZiAobmJfaXRlcnMgPiAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuICAgICAgICAgICAgdmFyIGtDbHVzdGVycyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaiQ1PTA7IGokNTxudW07IGokNSsrKSB7XG4gICAgICAgICAgICAgICAga0NsdXN0ZXJzW2okNV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkkNj0wOyBpJDY8bjsgaSQ2KyspIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAgICAgICAgICBrQ2x1c3RlcnNbY2x1c3Rlcl0ucHVzaCh2YWx1ZXNbaSQ2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqJDY9MDsgaiQ2PG51bTsgaiQ2KyspIHtcbiAgICAgICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVswXSk7XG4gICAgICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1ba0NsdXN0ZXJzW2okNl0ubGVuZ3RoLTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLGIpeyByZXR1cm4gYS1iOyB9KTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKHRtcEtNZWFuc0JyZWFrc1swXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDc9MTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3Kz0gMikge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdG1wS01lYW5zQnJlYWtzW2kkN107XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2KSAmJiAobGltaXRzLmluZGV4T2YodikgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdHMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbWl0cztcbiAgICB9O1xuXG4gICAgdmFyIGFuYWx5emVfMSA9IHthbmFseXplOiBhbmFseXplLCBsaW1pdHM6IGxpbWl0c307XG5cbiAgICB2YXIgQ29sb3IkMyA9IENvbG9yXzE7XG5cblxuICAgIHZhciBjb250cmFzdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8vIFdDQUcgY29udHJhc3QgcmF0aW9cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWZcbiAgICAgICAgYSA9IG5ldyBDb2xvciQzKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yJDMoYik7XG4gICAgICAgIHZhciBsMSA9IGEubHVtaW5hbmNlKCk7XG4gICAgICAgIHZhciBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgICAgIHJldHVybiBsMSA+IGwyID8gKGwxICsgMC4wNSkgLyAobDIgKyAwLjA1KSA6IChsMiArIDAuMDUpIC8gKGwxICsgMC4wNSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciQyID0gQ29sb3JfMTtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgcG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBleHAgPSBNYXRoLmV4cDtcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIGRlbHRhRSA9IGZ1bmN0aW9uKGEsIGIsIEtsLCBLYywgS2gpIHtcbiAgICAgICAgaWYgKCBLbCA9PT0gdm9pZCAwICkgS2w9MTtcbiAgICAgICAgaWYgKCBLYyA9PT0gdm9pZCAwICkgS2M9MTtcbiAgICAgICAgaWYgKCBLaCA9PT0gdm9pZCAwICkgS2g9MTtcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMjAwMClcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DSUUyMDAwLmh0bWxcbiAgICAgICAgdmFyIHJhZDJkZWcgPSBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHJldHVybiAzNjAgKiByYWQgLyAoMiAqIFBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZzJyYWQgPSBmdW5jdGlvbihkZWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoMiAqIFBJICogZGVnKSAvIDM2MDtcbiAgICAgICAgfTtcbiAgICAgICAgYSA9IG5ldyBDb2xvciQyKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yJDIoYik7XG4gICAgICAgIHZhciByZWYgPSBBcnJheS5mcm9tKGEubGFiKCkpO1xuICAgICAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgICAgIHZhciBhMSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIxID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgICAgICB2YXIgTDIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEyID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgYXZnTCA9IChMMSArIEwyKS8yO1xuICAgICAgICB2YXIgQzEgPSBzcXJ0KHBvdyhhMSwgMikgKyBwb3coYjEsIDIpKTtcbiAgICAgICAgdmFyIEMyID0gc3FydChwb3coYTIsIDIpICsgcG93KGIyLCAyKSk7XG4gICAgICAgIHZhciBhdmdDID0gKEMxICsgQzIpLzI7XG4gICAgICAgIHZhciBHID0gMC41KigxLXNxcnQocG93KGF2Z0MsIDcpLyhwb3coYXZnQywgNykgKyBwb3coMjUsIDcpKSkpO1xuICAgICAgICB2YXIgYTFwID0gYTEqKDErRyk7XG4gICAgICAgIHZhciBhMnAgPSBhMiooMStHKTtcbiAgICAgICAgdmFyIEMxcCA9IHNxcnQocG93KGExcCwgMikgKyBwb3coYjEsIDIpKTtcbiAgICAgICAgdmFyIEMycCA9IHNxcnQocG93KGEycCwgMikgKyBwb3coYjIsIDIpKTtcbiAgICAgICAgdmFyIGF2Z0NwID0gKEMxcCArIEMycCkvMjtcbiAgICAgICAgdmFyIGFyY3RhbjEgPSByYWQyZGVnKGF0YW4yKGIxLCBhMXApKTtcbiAgICAgICAgdmFyIGFyY3RhbjIgPSByYWQyZGVnKGF0YW4yKGIyLCBhMnApKTtcbiAgICAgICAgdmFyIGgxcCA9IGFyY3RhbjEgPj0gMCA/IGFyY3RhbjEgOiBhcmN0YW4xICsgMzYwO1xuICAgICAgICB2YXIgaDJwID0gYXJjdGFuMiA+PSAwID8gYXJjdGFuMiA6IGFyY3RhbjIgKyAzNjA7XG4gICAgICAgIHZhciBhdmdIcCA9IGFicyhoMXAgLSBoMnApID4gMTgwID8gKGgxcCArIGgycCArIDM2MCkvMiA6IChoMXAgKyBoMnApLzI7XG4gICAgICAgIHZhciBUID0gMSAtIDAuMTcqY29zKGRlZzJyYWQoYXZnSHAgLSAzMCkpICsgMC4yNCpjb3MoZGVnMnJhZCgyKmF2Z0hwKSkgKyAwLjMyKmNvcyhkZWcycmFkKDMqYXZnSHAgKyA2KSkgLSAwLjIqY29zKGRlZzJyYWQoNCphdmdIcCAtIDYzKSk7XG4gICAgICAgIHZhciBkZWx0YUhwID0gaDJwIC0gaDFwO1xuICAgICAgICBkZWx0YUhwID0gYWJzKGRlbHRhSHApIDw9IDE4MCA/IGRlbHRhSHAgOiBoMnAgPD0gaDFwID8gZGVsdGFIcCArIDM2MCA6IGRlbHRhSHAgLSAzNjA7XG4gICAgICAgIGRlbHRhSHAgPSAyKnNxcnQoQzFwKkMycCkqc2luKGRlZzJyYWQoZGVsdGFIcCkvMik7XG4gICAgICAgIHZhciBkZWx0YUwgPSBMMiAtIEwxO1xuICAgICAgICB2YXIgZGVsdGFDcCA9IEMycCAtIEMxcDsgICAgXG4gICAgICAgIHZhciBzbCA9IDEgKyAoMC4wMTUqcG93KGF2Z0wgLSA1MCwgMikpL3NxcnQoMjAgKyBwb3coYXZnTCAtIDUwLCAyKSk7XG4gICAgICAgIHZhciBzYyA9IDEgKyAwLjA0NSphdmdDcDtcbiAgICAgICAgdmFyIHNoID0gMSArIDAuMDE1KmF2Z0NwKlQ7XG4gICAgICAgIHZhciBkZWx0YVRoZXRhID0gMzAqZXhwKC1wb3coKGF2Z0hwIC0gMjc1KS8yNSwgMikpO1xuICAgICAgICB2YXIgUmMgPSAyKnNxcnQocG93KGF2Z0NwLCA3KS8ocG93KGF2Z0NwLCA3KSArIHBvdygyNSwgNykpKTtcbiAgICAgICAgdmFyIFJ0ID0gLVJjKnNpbigyKmRlZzJyYWQoZGVsdGFUaGV0YSkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc3FydChwb3coZGVsdGFMLyhLbCpzbCksIDIpICsgcG93KGRlbHRhQ3AvKEtjKnNjKSwgMikgKyBwb3coZGVsdGFIcC8oS2gqc2gpLCAyKSArIFJ0KihkZWx0YUNwLyhLYypzYykpKihkZWx0YUhwLyhLaCpzaCkpKTtcbiAgICAgICAgcmV0dXJuIG1heCgwLCBtaW4oMTAwLCByZXN1bHQpKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJDEgPSBDb2xvcl8xO1xuXG4gICAgLy8gc2ltcGxlIEV1Y2xpZGVhbiBkaXN0YW5jZVxuICAgIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIsIG1vZGUpIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdsYWInO1xuXG4gICAgICAgIC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcXVhdGlvbnMuaHRtbFxuICAgICAgICBhID0gbmV3IENvbG9yJDEoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3IkMShiKTtcbiAgICAgICAgdmFyIGwxID0gYS5nZXQobW9kZSk7XG4gICAgICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgc3VtX3NxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICAgICAgICBzdW1fc3EgKz0gZCpkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoc3VtX3NxKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yID0gQ29sb3JfMTtcblxuICAgIHZhciB2YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncykgKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNvbWUgcHJlLWRlZmluZWQgY29sb3Igc2NhbGVzOlxuICAgIHZhciBjaHJvbWEkMSA9IGNocm9tYV8xO1xuXG4gICAgdmFyIHNjYWxlID0gc2NhbGUkMjtcblxuICAgIHZhciBzY2FsZXMgPSB7XG4gICAgXHRjb29sOiBmdW5jdGlvbiBjb29sKCkgeyByZXR1cm4gc2NhbGUoW2Nocm9tYSQxLmhzbCgxODAsMSwuOSksIGNocm9tYSQxLmhzbCgyNTAsLjcsLjQpXSkgfSxcbiAgICBcdGhvdDogZnVuY3Rpb24gaG90KCkgeyByZXR1cm4gc2NhbGUoWycjMDAwJywnI2YwMCcsJyNmZjAnLCcjZmZmJ10pLm1vZGUoJ3JnYicpIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIENvbG9yQnJld2VyIGNvbG9ycyBmb3IgY2hyb21hLmpzXG5cbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLCBhbmQgVGhlXG4gICAgICAgIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LlxuXG4gICAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICAgICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWRcbiAgICAgICAgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1JcbiAgICAgICAgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAgICAgICAgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuXG4gICAgdmFyIGNvbG9yYnJld2VyID0ge1xuICAgICAgICAvLyBzZXF1ZW50aWFsXG4gICAgICAgIE9yUmQ6IFsnI2ZmZjdlYycsICcjZmVlOGM4JywgJyNmZGQ0OWUnLCAnI2ZkYmI4NCcsICcjZmM4ZDU5JywgJyNlZjY1NDgnLCAnI2Q3MzAxZicsICcjYjMwMDAwJywgJyM3ZjAwMDAnXSxcbiAgICAgICAgUHVCdTogWycjZmZmN2ZiJywgJyNlY2U3ZjInLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM3NGE5Y2YnLCAnIzM2OTBjMCcsICcjMDU3MGIwJywgJyMwNDVhOGQnLCAnIzAyMzg1OCddLFxuICAgICAgICBCdVB1OiBbJyNmN2ZjZmQnLCAnI2UwZWNmNCcsICcjYmZkM2U2JywgJyM5ZWJjZGEnLCAnIzhjOTZjNicsICcjOGM2YmIxJywgJyM4ODQxOWQnLCAnIzgxMGY3YycsICcjNGQwMDRiJ10sXG4gICAgICAgIE9yYW5nZXM6IFsnI2ZmZjVlYicsICcjZmVlNmNlJywgJyNmZGQwYTInLCAnI2ZkYWU2YicsICcjZmQ4ZDNjJywgJyNmMTY5MTMnLCAnI2Q5NDgwMScsICcjYTYzNjAzJywgJyM3ZjI3MDQnXSxcbiAgICAgICAgQnVHbjogWycjZjdmY2ZkJywgJyNlNWY1ZjknLCAnI2NjZWNlNicsICcjOTlkOGM5JywgJyM2NmMyYTQnLCAnIzQxYWU3NicsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgICAgICBZbE9yQnI6IFsnI2ZmZmZlNScsICcjZmZmN2JjJywgJyNmZWUzOTEnLCAnI2ZlYzQ0ZicsICcjZmU5OTI5JywgJyNlYzcwMTQnLCAnI2NjNGMwMicsICcjOTkzNDA0JywgJyM2NjI1MDYnXSxcbiAgICAgICAgWWxHbjogWycjZmZmZmU1JywgJyNmN2ZjYjknLCAnI2Q5ZjBhMycsICcjYWRkZDhlJywgJyM3OGM2NzknLCAnIzQxYWI1ZCcsICcjMjM4NDQzJywgJyMwMDY4MzcnLCAnIzAwNDUyOSddLFxuICAgICAgICBSZWRzOiBbJyNmZmY1ZjAnLCAnI2ZlZTBkMicsICcjZmNiYmExJywgJyNmYzkyNzInLCAnI2ZiNmE0YScsICcjZWYzYjJjJywgJyNjYjE4MWQnLCAnI2E1MGYxNScsICcjNjcwMDBkJ10sXG4gICAgICAgIFJkUHU6IFsnI2ZmZjdmMycsICcjZmRlMGRkJywgJyNmY2M1YzAnLCAnI2ZhOWZiNScsICcjZjc2OGExJywgJyNkZDM0OTcnLCAnI2FlMDE3ZScsICcjN2EwMTc3JywgJyM0OTAwNmEnXSxcbiAgICAgICAgR3JlZW5zOiBbJyNmN2ZjZjUnLCAnI2U1ZjVlMCcsICcjYzdlOWMwJywgJyNhMWQ5OWInLCAnIzc0YzQ3NicsICcjNDFhYjVkJywgJyMyMzhiNDUnLCAnIzAwNmQyYycsICcjMDA0NDFiJ10sXG4gICAgICAgIFlsR25CdTogWycjZmZmZmQ5JywgJyNlZGY4YjEnLCAnI2M3ZTliNCcsICcjN2ZjZGJiJywgJyM0MWI2YzQnLCAnIzFkOTFjMCcsICcjMjI1ZWE4JywgJyMyNTM0OTQnLCAnIzA4MWQ1OCddLFxuICAgICAgICBQdXJwbGVzOiBbJyNmY2ZiZmQnLCAnI2VmZWRmNScsICcjZGFkYWViJywgJyNiY2JkZGMnLCAnIzllOWFjOCcsICcjODA3ZGJhJywgJyM2YTUxYTMnLCAnIzU0Mjc4ZicsICcjM2YwMDdkJ10sXG4gICAgICAgIEduQnU6IFsnI2Y3ZmNmMCcsICcjZTBmM2RiJywgJyNjY2ViYzUnLCAnI2E4ZGRiNScsICcjN2JjY2M0JywgJyM0ZWIzZDMnLCAnIzJiOGNiZScsICcjMDg2OGFjJywgJyMwODQwODEnXSxcbiAgICAgICAgR3JleXM6IFsnI2ZmZmZmZicsICcjZjBmMGYwJywgJyNkOWQ5ZDknLCAnI2JkYmRiZCcsICcjOTY5Njk2JywgJyM3MzczNzMnLCAnIzUyNTI1MicsICcjMjUyNTI1JywgJyMwMDAwMDAnXSxcbiAgICAgICAgWWxPclJkOiBbJyNmZmZmY2MnLCAnI2ZmZWRhMCcsICcjZmVkOTc2JywgJyNmZWIyNGMnLCAnI2ZkOGQzYycsICcjZmM0ZTJhJywgJyNlMzFhMWMnLCAnI2JkMDAyNicsICcjODAwMDI2J10sXG4gICAgICAgIFB1UmQ6IFsnI2Y3ZjRmOScsICcjZTdlMWVmJywgJyNkNGI5ZGEnLCAnI2M5OTRjNycsICcjZGY2NWIwJywgJyNlNzI5OGEnLCAnI2NlMTI1NicsICcjOTgwMDQzJywgJyM2NzAwMWYnXSxcbiAgICAgICAgQmx1ZXM6IFsnI2Y3ZmJmZicsICcjZGVlYmY3JywgJyNjNmRiZWYnLCAnIzllY2FlMScsICcjNmJhZWQ2JywgJyM0MjkyYzYnLCAnIzIxNzFiNScsICcjMDg1MTljJywgJyMwODMwNmInXSxcbiAgICAgICAgUHVCdUduOiBbJyNmZmY3ZmInLCAnI2VjZTJmMCcsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzY3YTljZicsICcjMzY5MGMwJywgJyMwMjgxOGEnLCAnIzAxNmM1OScsICcjMDE0NjM2J10sXG4gICAgICAgIFZpcmlkaXM6IFsnIzQ0MDE1NCcsICcjNDgyNzc3JywgJyMzZjRhOGEnLCAnIzMxNjc4ZScsICcjMjY4MzhmJywgJyMxZjlkOGEnLCAnIzZjY2U1YScsICcjYjZkZTJiJywgJyNmZWU4MjUnXSxcblxuICAgICAgICAvLyBkaXZlcmdpbmdcblxuICAgICAgICBTcGVjdHJhbDogWycjOWUwMTQyJywgJyNkNTNlNGYnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZTZmNTk4JywgJyNhYmRkYTQnLCAnIzY2YzJhNScsICcjMzI4OGJkJywgJyM1ZTRmYTInXSxcbiAgICAgICAgUmRZbEduOiBbJyNhNTAwMjYnLCAnI2Q3MzAyNycsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNkOWVmOGInLCAnI2E2ZDk2YScsICcjNjZiZDYzJywgJyMxYTk4NTAnLCAnIzAwNjgzNyddLFxuICAgICAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgICAgICBQaVlHOiBbJyM4ZTAxNTInLCAnI2M1MWI3ZCcsICcjZGU3N2FlJywgJyNmMWI2ZGEnLCAnI2ZkZTBlZicsICcjZjdmN2Y3JywgJyNlNmY1ZDAnLCAnI2I4ZTE4NicsICcjN2ZiYzQxJywgJyM0ZDkyMjEnLCAnIzI3NjQxOSddLFxuICAgICAgICBQUkduOiBbJyM0MDAwNGInLCAnIzc2MmE4MycsICcjOTk3MGFiJywgJyNjMmE1Y2YnLCAnI2U3ZDRlOCcsICcjZjdmN2Y3JywgJyNkOWYwZDMnLCAnI2E2ZGJhMCcsICcjNWFhZTYxJywgJyMxYjc4MzcnLCAnIzAwNDQxYiddLFxuICAgICAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgICAgIEJyQkc6IFsnIzU0MzAwNScsICcjOGM1MTBhJywgJyNiZjgxMmQnLCAnI2RmYzI3ZCcsICcjZjZlOGMzJywgJyNmNWY1ZjUnLCAnI2M3ZWFlNScsICcjODBjZGMxJywgJyMzNTk3OGYnLCAnIzAxNjY1ZScsICcjMDAzYzMwJ10sXG4gICAgICAgIFJkR3k6IFsnIzY3MDAxZicsICcjYjIxODJiJywgJyNkNjYwNGQnLCAnI2Y0YTU4MicsICcjZmRkYmM3JywgJyNmZmZmZmYnLCAnI2UwZTBlMCcsICcjYmFiYWJhJywgJyM4Nzg3ODcnLCAnIzRkNGQ0ZCcsICcjMWExYTFhJ10sXG4gICAgICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG5cbiAgICAgICAgLy8gcXVhbGl0YXRpdmVcblxuICAgICAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgICAgICBBY2NlbnQ6IFsnIzdmYzk3ZicsICcjYmVhZWQ0JywgJyNmZGMwODYnLCAnI2ZmZmY5OScsICcjMzg2Y2IwJywgJyNmMDAyN2YnLCAnI2JmNWIxNycsICcjNjY2NjY2J10sXG4gICAgICAgIFNldDE6IFsnI2U0MWExYycsICcjMzc3ZWI4JywgJyM0ZGFmNGEnLCAnIzk4NGVhMycsICcjZmY3ZjAwJywgJyNmZmZmMzMnLCAnI2E2NTYyOCcsICcjZjc4MWJmJywgJyM5OTk5OTknXSxcbiAgICAgICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgICAgICBEYXJrMjogWycjMWI5ZTc3JywgJyNkOTVmMDInLCAnIzc1NzBiMycsICcjZTcyOThhJywgJyM2NmE2MWUnLCAnI2U2YWIwMicsICcjYTY3NjFkJywgJyM2NjY2NjYnXSxcbiAgICAgICAgUGFpcmVkOiBbJyNhNmNlZTMnLCAnIzFmNzhiNCcsICcjYjJkZjhhJywgJyMzM2EwMmMnLCAnI2ZiOWE5OScsICcjZTMxYTFjJywgJyNmZGJmNmYnLCAnI2ZmN2YwMCcsICcjY2FiMmQ2JywgJyM2YTNkOWEnLCAnI2ZmZmY5OScsICcjYjE1OTI4J10sXG4gICAgICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgICAgIFBhc3RlbDE6IFsnI2ZiYjRhZScsICcjYjNjZGUzJywgJyNjY2ViYzUnLCAnI2RlY2JlNCcsICcjZmVkOWE2JywgJyNmZmZmY2MnLCAnI2U1ZDhiZCcsICcjZmRkYWVjJywgJyNmMmYyZjInXSxcbiAgICB9O1xuXG4gICAgLy8gYWRkIGxvd2VyY2FzZSBhbGlhc2VzIGZvciBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKGNvbG9yYnJld2VyKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGxpc3RbaV07XG5cbiAgICAgICAgY29sb3JicmV3ZXJba2V5LnRvTG93ZXJDYXNlKCldID0gY29sb3JicmV3ZXJba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3JicmV3ZXJfMSA9IGNvbG9yYnJld2VyO1xuXG4gICAgdmFyIGNocm9tYSA9IGNocm9tYV8xO1xuXG4gICAgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAgIC8vIGEgc21hbGxlciBjaHJvbWEuanMgYnVpbHRcblxuICAgIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBvcGVyYXRvcnMgLS0+IG1vZGlmeSBleGlzdGluZyBDb2xvcnNcblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIGludGVycG9sYXRvcnNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBnZW5lcmF0b3JzIC0tID4gY3JlYXRlIG5ldyBjb2xvcnNcbiAgICBjaHJvbWEuYXZlcmFnZSA9IGF2ZXJhZ2U7XG4gICAgY2hyb21hLmJlemllciA9IGJlemllcl8xO1xuICAgIGNocm9tYS5ibGVuZCA9IGJsZW5kXzE7XG4gICAgY2hyb21hLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgICBjaHJvbWEubWl4ID0gY2hyb21hLmludGVycG9sYXRlID0gbWl4JDE7XG4gICAgY2hyb21hLnJhbmRvbSA9IHJhbmRvbV8xO1xuICAgIGNocm9tYS5zY2FsZSA9IHNjYWxlJDI7XG5cbiAgICAvLyBvdGhlciB1dGlsaXR5IG1ldGhvZHNcbiAgICBjaHJvbWEuYW5hbHl6ZSA9IGFuYWx5emVfMS5hbmFseXplO1xuICAgIGNocm9tYS5jb250cmFzdCA9IGNvbnRyYXN0O1xuICAgIGNocm9tYS5kZWx0YUUgPSBkZWx0YUU7XG4gICAgY2hyb21hLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY2hyb21hLmxpbWl0cyA9IGFuYWx5emVfMS5saW1pdHM7XG4gICAgY2hyb21hLnZhbGlkID0gdmFsaWQ7XG5cbiAgICAvLyBzY2FsZVxuICAgIGNocm9tYS5zY2FsZXMgPSBzY2FsZXM7XG5cbiAgICAvLyBjb2xvcnNcbiAgICBjaHJvbWEuY29sb3JzID0gdzNjeDExXzE7XG4gICAgY2hyb21hLmJyZXdlciA9IGNvbG9yYnJld2VyXzE7XG5cbiAgICB2YXIgY2hyb21hX2pzID0gY2hyb21hO1xuXG4gICAgcmV0dXJuIGNocm9tYV9qcztcblxufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBAbGljZW5zZSBGcmFjdGlvbi5qcyB2NC4yLjAgMDUvMDMvMjAyMlxuICogaHR0cHM6Ly93d3cueGFyZy5vcmcvMjAxNC8wMy9yYXRpb25hbC1udW1iZXJzLWluLWphdmFzY3JpcHQvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxLCBSb2JlcnQgRWlzZWxlIChyb2JlcnRAeGFyZy5vcmcpXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqKi9cblxuXG4vKipcbiAqXG4gKiBUaGlzIGNsYXNzIG9mZmVycyB0aGUgcG9zc2liaWxpdHkgdG8gY2FsY3VsYXRlIGZyYWN0aW9ucy5cbiAqIFlvdSBjYW4gcGFzcyBhIGZyYWN0aW9uIGluIGRpZmZlcmVudCBmb3JtYXRzLiBFaXRoZXIgYXMgYXJyYXksIGFzIGRvdWJsZSwgYXMgc3RyaW5nIG9yIGFzIGFuIGludGVnZXIuXG4gKlxuICogQXJyYXkvT2JqZWN0IGZvcm1cbiAqIFsgMCA9PiA8bm9taW5hdG9yPiwgMSA9PiA8ZGVub21pbmF0b3I+IF1cbiAqIFsgbiA9PiA8bm9taW5hdG9yPiwgZCA9PiA8ZGVub21pbmF0b3I+IF1cbiAqXG4gKiBJbnRlZ2VyIGZvcm1cbiAqIC0gU2luZ2xlIGludGVnZXIgdmFsdWVcbiAqXG4gKiBEb3VibGUgZm9ybVxuICogLSBTaW5nbGUgZG91YmxlIHZhbHVlXG4gKlxuICogU3RyaW5nIGZvcm1cbiAqIDEyMy40NTYgLSBhIHNpbXBsZSBkb3VibGVcbiAqIDEyMy80NTYgLSBhIHN0cmluZyBmcmFjdGlvblxuICogMTIzLic0NTYnIC0gYSBkb3VibGUgd2l0aCByZXBlYXRpbmcgZGVjaW1hbCBwbGFjZXNcbiAqIDEyMy4oNDU2KSAtIHN5bm9ueW1cbiAqIDEyMy40NSc2JyAtIGEgZG91YmxlIHdpdGggcmVwZWF0aW5nIGxhc3QgcGxhY2VcbiAqIDEyMy40NSg2KSAtIHN5bm9ueW1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIHZhciBmID0gbmV3IEZyYWN0aW9uKFwiOS40JzMxJ1wiKTtcbiAqIGYubXVsKFstNCwgM10pLmRpdig0LjkpO1xuICpcbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCkge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIE1heGltdW0gc2VhcmNoIGRlcHRoIGZvciBjeWNsaWMgcmF0aW9uYWwgbnVtYmVycy4gMjAwMCBzaG91bGQgYmUgbW9yZSB0aGFuIGVub3VnaC5cbiAgLy8gRXhhbXBsZTogMS83ID0gMC4oMTQyODU3KSBoYXMgNiByZXBlYXRpbmcgZGVjaW1hbCBwbGFjZXMuXG4gIC8vIElmIE1BWF9DWUNMRV9MRU4gZ2V0cyByZWR1Y2VkLCBsb25nIGN5Y2xlcyB3aWxsIG5vdCBiZSBkZXRlY3RlZCBhbmQgdG9TdHJpbmcoKSBvbmx5IGdldHMgdGhlIGZpcnN0IDEwIGRpZ2l0c1xuICB2YXIgTUFYX0NZQ0xFX0xFTiA9IDIwMDA7XG5cbiAgLy8gUGFyc2VkIGRhdGEgdG8gYXZvaWQgY2FsbGluZyBcIm5ld1wiIGFsbCB0aGUgdGltZVxuICB2YXIgUCA9IHtcbiAgICBcInNcIjogMSxcbiAgICBcIm5cIjogMCxcbiAgICBcImRcIjogMVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFzc2lnbihuLCBzKSB7XG5cbiAgICBpZiAoaXNOYU4obiA9IHBhcnNlSW50KG4sIDEwKSkpIHtcbiAgICAgIHRocm93IEZyYWN0aW9uWydJbnZhbGlkUGFyYW1ldGVyJ107XG4gICAgfVxuICAgIHJldHVybiBuICogcztcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBuZXcgRnJhY3Rpb24gaW50ZXJuYWxseSB3aXRob3V0IHRoZSBuZWVkIG9mIHRoZSBidWxreSBjb25zdHJ1Y3RvclxuICBmdW5jdGlvbiBuZXdGcmFjdGlvbihuLCBkKSB7XG5cbiAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgdGhyb3cgRnJhY3Rpb25bJ0RpdmlzaW9uQnlaZXJvJ107XG4gICAgfVxuXG4gICAgdmFyIGYgPSBPYmplY3QuY3JlYXRlKEZyYWN0aW9uLnByb3RvdHlwZSk7XG4gICAgZltcInNcIl0gPSBuIDwgMCA/IC0xIDogMTtcblxuICAgIG4gPSBuIDwgMCA/IC1uIDogbjtcblxuICAgIHZhciBhID0gZ2NkKG4sIGQpO1xuXG4gICAgZltcIm5cIl0gPSBuIC8gYTtcbiAgICBmW1wiZFwiXSA9IGQgLyBhO1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgZnVuY3Rpb24gZmFjdG9yaXplKG51bSkge1xuXG4gICAgdmFyIGZhY3RvcnMgPSB7fTtcblxuICAgIHZhciBuID0gbnVtO1xuICAgIHZhciBpID0gMjtcbiAgICB2YXIgcyA9IDQ7XG5cbiAgICB3aGlsZSAocyA8PSBuKSB7XG5cbiAgICAgIHdoaWxlIChuICUgaSA9PT0gMCkge1xuICAgICAgICBuLz0gaTtcbiAgICAgICAgZmFjdG9yc1tpXSA9IChmYWN0b3JzW2ldIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIHMrPSAxICsgMiAqIGkrKztcbiAgICB9XG5cbiAgICBpZiAobiAhPT0gbnVtKSB7XG4gICAgICBpZiAobiA+IDEpXG4gICAgICAgIGZhY3RvcnNbbl0gPSAoZmFjdG9yc1tuXSB8fCAwKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvcnNbbnVtXSA9IChmYWN0b3JzW251bV0gfHwgMCkgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFjdG9ycztcbiAgfVxuXG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuXG4gICAgdmFyIG4gPSAwLCBkID0gMSwgcyA9IDE7XG4gICAgdmFyIHYgPSAwLCB3ID0gMCwgeCA9IDAsIHkgPSAxLCB6ID0gMTtcblxuICAgIHZhciBBID0gMCwgQiA9IDE7XG4gICAgdmFyIEMgPSAxLCBEID0gMTtcblxuICAgIHZhciBOID0gMTAwMDAwMDA7XG4gICAgdmFyIE07XG5cbiAgICBpZiAocDEgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gbnVsbCkge1xuICAgICAgLyogdm9pZCAqL1xuICAgIH0gZWxzZSBpZiAocDIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbiA9IHAxO1xuICAgICAgZCA9IHAyO1xuICAgICAgcyA9IG4gKiBkO1xuXG4gICAgICBpZiAobiAlIDEgIT09IDAgfHwgZCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgRnJhY3Rpb25bJ05vbkludGVnZXJQYXJhbWV0ZXInXTtcbiAgICAgIH1cblxuICAgIH0gZWxzZVxuICAgICAgc3dpdGNoICh0eXBlb2YgcDEpIHtcblxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFwiZFwiIGluIHAxICYmIFwiblwiIGluIHAxKSB7XG4gICAgICAgICAgICAgIG4gPSBwMVtcIm5cIl07XG4gICAgICAgICAgICAgIGQgPSBwMVtcImRcIl07XG4gICAgICAgICAgICAgIGlmIChcInNcIiBpbiBwMSlcbiAgICAgICAgICAgICAgICBuKj0gcDFbXCJzXCJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgwIGluIHAxKSB7XG4gICAgICAgICAgICAgIG4gPSBwMVswXTtcbiAgICAgICAgICAgICAgaWYgKDEgaW4gcDEpXG4gICAgICAgICAgICAgICAgZCA9IHAxWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRnJhY3Rpb25bJ0ludmFsaWRQYXJhbWV0ZXInXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBuICogZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwMSA8IDApIHtcbiAgICAgICAgICAgICAgcyA9IHAxO1xuICAgICAgICAgICAgICBwMSA9IC1wMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAxICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgICBuID0gcDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxID4gMCkgeyAvLyBjaGVjayBmb3IgIT0gMCwgc2NhbGUgd291bGQgYmVjb21lIE5hTiAobG9nKDApKSwgd2hpY2ggY29udmVyZ2VzIHJlYWxseSBzbG93XG5cbiAgICAgICAgICAgICAgaWYgKHAxID49IDEpIHtcbiAgICAgICAgICAgICAgICB6ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoMSArIE1hdGgubG9nKHAxKSAvIE1hdGguTE4xMCkpO1xuICAgICAgICAgICAgICAgIHAxLz0gejtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFVzaW5nIEZhcmV5IFNlcXVlbmNlc1xuICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LmpvaG5kY29vay5jb20vYmxvZy8yMDEwLzEwLzIwL2Jlc3QtcmF0aW9uYWwtYXBwcm94aW1hdGlvbi9cblxuICAgICAgICAgICAgICB3aGlsZSAoQiA8PSBOICYmIEQgPD0gTikge1xuICAgICAgICAgICAgICAgIE0gPSAoQSArIEMpIC8gKEIgKyBEKTtcblxuICAgICAgICAgICAgICAgIGlmIChwMSA9PT0gTSkge1xuICAgICAgICAgICAgICAgICAgaWYgKEIgKyBEIDw9IE4pIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IEEgKyBDO1xuICAgICAgICAgICAgICAgICAgICBkID0gQiArIEQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEQgPiBCKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBDO1xuICAgICAgICAgICAgICAgICAgICBkID0gRDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBBO1xuICAgICAgICAgICAgICAgICAgICBkID0gQjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgaWYgKHAxID4gTSkge1xuICAgICAgICAgICAgICAgICAgICBBKz0gQztcbiAgICAgICAgICAgICAgICAgICAgQis9IEQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBDKz0gQTtcbiAgICAgICAgICAgICAgICAgICAgRCs9IEI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChCID4gTikge1xuICAgICAgICAgICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgICAgICAgICAgZCA9IEQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgICAgICAgICAgZCA9IEI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG4qPSB6O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTihwMSkgfHwgaXNOYU4ocDIpKSB7XG4gICAgICAgICAgICAgIGQgPSBuID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgQiA9IHAxLm1hdGNoKC9cXGQrfC4vZyk7XG5cbiAgICAgICAgICAgIGlmIChCID09PSBudWxsKVxuICAgICAgICAgICAgICB0aHJvdyBGcmFjdGlvblsnSW52YWxpZFBhcmFtZXRlciddO1xuXG4gICAgICAgICAgICBpZiAoQltBXSA9PT0gJy0nKSB7Ly8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgICBzID0gLTE7XG4gICAgICAgICAgICAgIEErKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQltBXSA9PT0gJysnKSB7Ly8gQ2hlY2sgZm9yIHBsdXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgIEErKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEIubGVuZ3RoID09PSBBICsgMSkgeyAvLyBDaGVjayBpZiBpdCdzIGp1c3QgYSBzaW1wbGUgbnVtYmVyIFwiMTIzNFwiXG4gICAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBKytdLCBzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQltBICsgMV0gPT09ICcuJyB8fCBCW0FdID09PSAnLicpIHsgLy8gQ2hlY2sgaWYgaXQncyBhIGRlY2ltYWwgbnVtYmVyXG5cbiAgICAgICAgICAgICAgaWYgKEJbQV0gIT09ICcuJykgeyAvLyBIYW5kbGUgMC41IGFuZCAuNVxuICAgICAgICAgICAgICAgIHYgPSBhc3NpZ24oQltBKytdLCBzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBBKys7XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAgICAgIGlmIChBICsgMSA9PT0gQi5sZW5ndGggfHwgQltBICsgMV0gPT09ICcoJyAmJiBCW0EgKyAzXSA9PT0gJyknIHx8IEJbQSArIDFdID09PSBcIidcIiAmJiBCW0EgKyAzXSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICB3ID0gYXNzaWduKEJbQV0sIHMpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnBvdygxMCwgQltBXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIEErKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciByZXBlYXRpbmcgcGxhY2VzXG4gICAgICAgICAgICAgIGlmIChCW0FdID09PSAnKCcgJiYgQltBICsgMl0gPT09ICcpJyB8fCBCW0FdID09PSBcIidcIiAmJiBCW0EgKyAyXSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gYXNzaWduKEJbQSArIDFdLCBzKTtcbiAgICAgICAgICAgICAgICB6ID0gTWF0aC5wb3coMTAsIEJbQSArIDFdLmxlbmd0aCkgLSAxO1xuICAgICAgICAgICAgICAgIEErPSAzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQltBICsgMV0gPT09ICcvJyB8fCBCW0EgKyAxXSA9PT0gJzonKSB7IC8vIENoZWNrIGZvciBhIHNpbXBsZSBmcmFjdGlvbiBcIjEyMy80NTZcIiBvciBcIjEyMzo0NTZcIlxuICAgICAgICAgICAgICB3ID0gYXNzaWduKEJbQV0sIHMpO1xuICAgICAgICAgICAgICB5ID0gYXNzaWduKEJbQSArIDJdLCAxKTtcbiAgICAgICAgICAgICAgQSs9IDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEJbQSArIDNdID09PSAnLycgJiYgQltBICsgMV0gPT09ICcgJykgeyAvLyBDaGVjayBmb3IgYSBjb21wbGV4IGZyYWN0aW9uIFwiMTIzIDEvMlwiXG4gICAgICAgICAgICAgIHYgPSBhc3NpZ24oQltBXSwgcyk7XG4gICAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBICsgMl0sIHMpO1xuICAgICAgICAgICAgICB5ID0gYXNzaWduKEJbQSArIDRdLCAxKTtcbiAgICAgICAgICAgICAgQSs9IDU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCA8PSBBKSB7IC8vIENoZWNrIGZvciBtb3JlIHRva2VucyBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgZCA9IHkgKiB6O1xuICAgICAgICAgICAgICBzID0gLyogdm9pZCAqL1xuICAgICAgICAgICAgICBuID0geCArIGQgKiB2ICsgeiAqIHc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBGYWxsIHRocm91Z2ggb24gZXJyb3IgKi9cbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRnJhY3Rpb25bJ0ludmFsaWRQYXJhbWV0ZXInXTtcbiAgICAgIH1cblxuICAgIGlmIChkID09PSAwKSB7XG4gICAgICB0aHJvdyBGcmFjdGlvblsnRGl2aXNpb25CeVplcm8nXTtcbiAgICB9XG5cbiAgICBQW1wic1wiXSA9IHMgPCAwID8gLTEgOiAxO1xuICAgIFBbXCJuXCJdID0gTWF0aC5hYnMobik7XG4gICAgUFtcImRcIl0gPSBNYXRoLmFicyhkKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtb2Rwb3coYiwgZSwgbSkge1xuXG4gICAgdmFyIHIgPSAxO1xuICAgIGZvciAoOyBlID4gMDsgYiA9IChiICogYikgJSBtLCBlID4+PSAxKSB7XG5cbiAgICAgIGlmIChlICYgMSkge1xuICAgICAgICByID0gKHIgKiBiKSAlIG07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cblxuICBmdW5jdGlvbiBjeWNsZUxlbihuLCBkKSB7XG5cbiAgICBmb3IgKDsgZCAlIDIgPT09IDA7XG4gICAgICBkLz0gMikge1xuICAgIH1cblxuICAgIGZvciAoOyBkICUgNSA9PT0gMDtcbiAgICAgIGQvPSA1KSB7XG4gICAgfVxuXG4gICAgaWYgKGQgPT09IDEpIC8vIENhdGNoIG5vbi1jeWNsaWMgbnVtYmVyc1xuICAgICAgcmV0dXJuIDA7XG5cbiAgICAvLyBJZiB3ZSB3b3VsZCBsaWtlIHRvIGNvbXB1dGUgcmVhbGx5IGxhcmdlIG51bWJlcnMgcXVpY2tlciwgd2UgY291bGQgbWFrZSB1c2Ugb2YgRmVybWF0J3MgbGl0dGxlIHRoZW9yZW06XG4gICAgLy8gMTBeKGQtMSkgJSBkID09IDFcbiAgICAvLyBIb3dldmVyLCB3ZSBkb24ndCBuZWVkIHN1Y2ggbGFyZ2UgbnVtYmVycyBhbmQgTUFYX0NZQ0xFX0xFTiBzaG91bGQgYmUgdGhlIGNhcHN0b25lLFxuICAgIC8vIGFzIHdlIHdhbnQgdG8gdHJhbnNsYXRlIHRoZSBudW1iZXJzIHRvIHN0cmluZ3MuXG5cbiAgICB2YXIgcmVtID0gMTAgJSBkO1xuICAgIHZhciB0ID0gMTtcblxuICAgIGZvciAoOyByZW0gIT09IDE7IHQrKykge1xuICAgICAgcmVtID0gcmVtICogMTAgJSBkO1xuXG4gICAgICBpZiAodCA+IE1BWF9DWUNMRV9MRU4pXG4gICAgICAgIHJldHVybiAwOyAvLyBSZXR1cm5pbmcgMCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3QgcHJpbnQgaXQgYXMgYSBjeWNsaWMgbnVtYmVyLiBJdCdzIGxpa2VseSB0aGF0IHRoZSBhbnN3ZXIgaXMgYGQtMWBcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGN5Y2xlU3RhcnQobiwgZCwgbGVuKSB7XG5cbiAgICB2YXIgcmVtMSA9IDE7XG4gICAgdmFyIHJlbTIgPSBtb2Rwb3coMTAsIGxlbiwgZCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDMwMDsgdCsrKSB7IC8vIHMgPCB+bG9nMTAoTnVtYmVyLk1BWF9WQUxVRSlcbiAgICAgIC8vIFNvbHZlIDEwXnMgPT0gMTBeKHMrdCkgKG1vZCBkKVxuXG4gICAgICBpZiAocmVtMSA9PT0gcmVtMilcbiAgICAgICAgcmV0dXJuIHQ7XG5cbiAgICAgIHJlbTEgPSByZW0xICogMTAgJSBkO1xuICAgICAgcmVtMiA9IHJlbTIgKiAxMCAlIGQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcblxuICAgIGlmICghYSlcbiAgICAgIHJldHVybiBiO1xuICAgIGlmICghYilcbiAgICAgIHJldHVybiBhO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGElPSBiO1xuICAgICAgaWYgKCFhKVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIGIlPSBhO1xuICAgICAgaWYgKCFiKVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtudW1iZXJ8RnJhY3Rpb249fSBhXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gYlxuICAgKi9cbiAgZnVuY3Rpb24gRnJhY3Rpb24oYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEZyYWN0aW9uKSB7XG4gICAgICBhID0gZ2NkKFBbXCJkXCJdLCBQW1wiblwiXSk7IC8vIEFidXNlIHZhcmlhYmxlIGFcbiAgICAgIHRoaXNbXCJzXCJdID0gUFtcInNcIl07XG4gICAgICB0aGlzW1wiblwiXSA9IFBbXCJuXCJdIC8gYTtcbiAgICAgIHRoaXNbXCJkXCJdID0gUFtcImRcIl0gLyBhO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oUFsncyddICogUFsnbiddLCBQWydkJ10pO1xuICAgIH1cbiAgfVxuXG4gIEZyYWN0aW9uWydEaXZpc2lvbkJ5WmVybyddID0gbmV3IEVycm9yKFwiRGl2aXNpb24gYnkgWmVyb1wiKTtcbiAgRnJhY3Rpb25bJ0ludmFsaWRQYXJhbWV0ZXInXSA9IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIEZyYWN0aW9uWydOb25JbnRlZ2VyUGFyYW1ldGVyJ10gPSBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIG11c3QgYmUgaW50ZWdlclwiKTtcblxuICBGcmFjdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBcInNcIjogMSxcbiAgICBcIm5cIjogMCxcbiAgICBcImRcIjogMSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKC00KS5hYnMoKSA9PiA0XG4gICAgICoqL1xuICAgIFwiYWJzXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcIm5cIl0sIHRoaXNbXCJkXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0cyB0aGUgc2lnbiBvZiB0aGUgY3VycmVudCBmcmFjdGlvblxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbigtNCkubmVnKCkgPT4gNFxuICAgICAqKi9cbiAgICBcIm5lZ1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKC10aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdLCB0aGlzW1wiZFwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IDQ2NyAvIDMwXG4gICAgICoqL1xuICAgIFwiYWRkXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSArIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgICAgdGhpc1tcImRcIl0gKiBQW1wiZFwiXVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKHtuOiAyLCBkOiAzfSkuYWRkKFwiMTQuOVwiKSA9PiAtNDI3IC8gMzBcbiAgICAgKiovXG4gICAgXCJzdWJcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgICAgdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIC0gUFtcInNcIl0gKiB0aGlzW1wiZFwiXSAqIFBbXCJuXCJdLFxuICAgICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLm11bCgzKSA9PiA1Nzc2IC8gMTExXG4gICAgICoqL1xuICAgIFwibXVsXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICAgIHRoaXNbXCJzXCJdICogUFtcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJuXCJdLFxuICAgICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmludmVyc2UoKS5kaXYoMylcbiAgICAgKiovXG4gICAgXCJkaXZcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0sXG4gICAgICAgIHRoaXNbXCJkXCJdICogUFtcIm5cIl1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgYWN0dWFsIG9iamVjdFxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbihcIi0xNy4oMzQ1KVwiKS5jbG9uZSgpXG4gICAgICoqL1xuICAgIFwiY2xvbmVcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1sncyddICogdGhpc1snbiddLCB0aGlzWydkJ10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtb2R1bG8gb2YgdHdvIHJhdGlvbmFsIG51bWJlcnMgLSBhIG1vcmUgcHJlY2lzZSBmbW9kXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKCc0LigzKScpLm1vZChbNywgOF0pID0+ICgxMy8zKSAlICg3LzgpID0gKDUvNilcbiAgICAgKiovXG4gICAgXCJtb2RcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBpZiAoaXNOYU4odGhpc1snbiddKSB8fCBpc05hTih0aGlzWydkJ10pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdLCAxKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2UoYSwgYik7XG4gICAgICBpZiAoMCA9PT0gUFtcIm5cIl0gJiYgMCA9PT0gdGhpc1tcImRcIl0pIHtcbiAgICAgICAgdGhyb3cgRnJhY3Rpb25bJ0RpdmlzaW9uQnlaZXJvJ107XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKiBGaXJzdCBzaWxseSBhdHRlbXB0LCBraW5kYSBzbG93XG4gICAgICAgKlxuICAgICAgIHJldHVybiB0aGF0W1wic3ViXCJdKHtcbiAgICAgICBcIm5cIjogbnVtW1wiblwiXSAqIE1hdGguZmxvb3IoKHRoaXMubiAvIHRoaXMuZCkgLyAobnVtLm4gLyBudW0uZCkpLFxuICAgICAgIFwiZFwiOiBudW1bXCJkXCJdLFxuICAgICAgIFwic1wiOiB0aGlzW1wic1wiXVxuICAgICAgIH0pOyovXG5cbiAgICAgIC8qXG4gICAgICAgKiBOZXcgYXR0ZW1wdDogYTEgLyBiMSA9IGEyIC8gYjIgKiBxICsgclxuICAgICAgICogPT4gYjIgKiBhMSA9IGEyICogYjEgKiBxICsgYjEgKiBiMiAqIHJcbiAgICAgICAqID0+IChiMiAqIGExICUgYTIgKiBiMSkgLyAoYjEgKiBiMilcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgICB0aGlzW1wic1wiXSAqIChQW1wiZFwiXSAqIHRoaXNbXCJuXCJdKSAlIChQW1wiblwiXSAqIHRoaXNbXCJkXCJdKSxcbiAgICAgICAgUFtcImRcIl0gKiB0aGlzW1wiZFwiXVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb25hbCBnY2Qgb2YgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oNSw4KS5nY2QoMyw3KSA9PiAxLzU2XG4gICAgICovXG4gICAgXCJnY2RcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcblxuICAgICAgLy8gZ2NkKGEgLyBiLCBjIC8gZCkgPSBnY2QoYSwgYykgLyBsY20oYiwgZClcblxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGdjZChQW1wiblwiXSwgdGhpc1tcIm5cIl0pICogZ2NkKFBbXCJkXCJdLCB0aGlzW1wiZFwiXSksIFBbXCJkXCJdICogdGhpc1tcImRcIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmcmFjdGlvbmFsIGxjbSBvZiB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbig1LDgpLmxjbSgzLDcpID0+IDE1XG4gICAgICovXG4gICAgXCJsY21cIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcblxuICAgICAgLy8gbGNtKGEgLyBiLCBjIC8gZCkgPSBsY20oYSwgYykgLyBnY2QoYiwgZClcblxuICAgICAgaWYgKFBbXCJuXCJdID09PSAwICYmIHRoaXNbXCJuXCJdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXdGcmFjdGlvbigwLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihQW1wiblwiXSAqIHRoaXNbXCJuXCJdLCBnY2QoUFtcIm5cIl0sIHRoaXNbXCJuXCJdKSAqIGdjZChQW1wiZFwiXSwgdGhpc1tcImRcIl0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY2VpbCBvZiBhIHJhdGlvbmFsIG51bWJlclxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5jZWlsKCkgPT4gKDUgLyAxKVxuICAgICAqKi9cbiAgICBcImNlaWxcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIGlmIChpc05hTih0aGlzW1wiblwiXSkgfHwgaXNOYU4odGhpc1tcImRcIl0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihNYXRoLmNlaWwocGxhY2VzICogdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdKSwgcGxhY2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZmxvb3Igb2YgYSByYXRpb25hbCBudW1iZXJcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykuZmxvb3IoKSA9PiAoNCAvIDEpXG4gICAgICoqL1xuICAgIFwiZmxvb3JcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIGlmIChpc05hTih0aGlzW1wiblwiXSkgfHwgaXNOYU4odGhpc1tcImRcIl0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihNYXRoLmZsb29yKHBsYWNlcyAqIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSksIHBsYWNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykucm91bmQoKSA9PiAoNCAvIDEpXG4gICAgICoqL1xuICAgIFwicm91bmRcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIGlmIChpc05hTih0aGlzW1wiblwiXSkgfHwgaXNOYU4odGhpc1tcImRcIl0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihNYXRoLnJvdW5kKHBsYWNlcyAqIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSksIHBsYWNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGludmVyc2Ugb2YgdGhlIGZyYWN0aW9uLCBtZWFucyBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIGFyZSBleGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oWy0zLCA0XSkuaW52ZXJzZSgpID0+IC00IC8gM1xuICAgICAqKi9cbiAgICBcImludmVyc2VcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzW1wic1wiXSAqIHRoaXNbXCJkXCJdLCB0aGlzW1wiblwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uIHRvIHNvbWUgcmF0aW9uYWwgZXhwb25lbnQsIGlmIHBvc3NpYmxlXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKC0xLDIpLnBvdygtMykgPT4gLThcbiAgICAgKi9cbiAgICBcInBvd1wiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgICAvLyBUcml2aWFsIGNhc2Ugd2hlbiBleHAgaXMgYW4gaW50ZWdlclxuXG4gICAgICBpZiAoUFsnZCddID09PSAxKSB7XG5cbiAgICAgICAgaWYgKFBbJ3MnXSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oTWF0aC5wb3codGhpc1sncyddICogdGhpc1tcImRcIl0sIFBbJ24nXSksIE1hdGgucG93KHRoaXNbXCJuXCJdLCBQWyduJ10pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oTWF0aC5wb3codGhpc1sncyddICogdGhpc1tcIm5cIl0sIFBbJ24nXSksIE1hdGgucG93KHRoaXNbXCJkXCJdLCBQWyduJ10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOZWdhdGl2ZSByb290cyBiZWNvbWUgY29tcGxleFxuICAgICAgLy8gICAgICgtYS9iKV4oYy9kKSA9IHhcbiAgICAgIC8vIDw9PiAoLTEpXihjL2QpICogKGEvYileKGMvZCkgPSB4XG4gICAgICAvLyA8PT4gKGNvcyhwaSkgKyBpKnNpbihwaSkpXihjL2QpICogKGEvYileKGMvZCkgPSB4ICAgICAgICAgIyByb3RhdGUgMSBieSAxODDCsFxuICAgICAgLy8gPD0+IChjb3MoYypwaS9kKSArIGkqc2luKGMqcGkvZCkpICogKGEvYileKGMvZCkgPSB4ICAgICAgICMgRGVNb2l2cmUncyBmb3JtdWxhIGluIFEgKCBodHRwczovL3Byb29md2lraS5vcmcvd2lraS9EZV9Nb2l2cmUlMjdzX0Zvcm11bGEvUmF0aW9uYWxfSW5kZXggKVxuICAgICAgLy8gRnJvbSB3aGljaCBmb2xsb3dzIHRoYXQgb25seSBmb3IgYz0wIHRoZSByb290IGlzIG5vbi1jb21wbGV4LiBjL2QgaXMgYSByZWR1Y2VkIGZyYWN0aW9uLCBzbyB0aGF0IHNpbihjL2RwaSk9MCBvY2N1cnMgZm9yIGQ9MSwgd2hpY2ggaXMgaGFuZGxlZCBieSBvdXIgdHJpdmlhbCBjYXNlLlxuICAgICAgaWYgKHRoaXNbJ3MnXSA8IDApIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBOb3cgcHJpbWUgZmFjdG9yIG4gYW5kIGRcbiAgICAgIHZhciBOID0gZmFjdG9yaXplKHRoaXNbJ24nXSk7XG4gICAgICB2YXIgRCA9IGZhY3Rvcml6ZSh0aGlzWydkJ10pO1xuXG4gICAgICAvLyBFeHBvbmVudGlhdGUgYW5kIHRha2Ugcm9vdCBmb3IgbiBhbmQgZCBpbmRpdmlkdWFsbHlcbiAgICAgIHZhciBuID0gMTtcbiAgICAgIHZhciBkID0gMTtcbiAgICAgIGZvciAodmFyIGsgaW4gTikge1xuICAgICAgICBpZiAoayA9PT0gJzEnKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGsgPT09ICcwJykge1xuICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIE5ba10qPSBQWyduJ107XG5cbiAgICAgICAgaWYgKE5ba10gJSBQWydkJ10gPT09IDApIHtcbiAgICAgICAgICBOW2tdLz0gUFsnZCddO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgIG4qPSBNYXRoLnBvdyhrLCBOW2tdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayBpbiBEKSB7XG4gICAgICAgIGlmIChrID09PSAnMScpIGNvbnRpbnVlO1xuICAgICAgICBEW2tdKj0gUFsnbiddO1xuXG4gICAgICAgIGlmIChEW2tdICUgUFsnZCddID09PSAwKSB7XG4gICAgICAgICAgRFtrXS89IFBbJ2QnXTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICBkKj0gTWF0aC5wb3coaywgRFtrXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChQWydzJ10gPCAwKSB7XG4gICAgICAgIHJldHVybiBuZXdGcmFjdGlvbihkLCBuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihuLCBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIHJhdGlvbmFsIG51bWJlcnMgYXJlIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmVxdWFscyhbOTgsIDVdKTtcbiAgICAgKiovXG4gICAgXCJlcXVhbHNcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gPT09IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTsgLy8gU2FtZSBhcyBjb21wYXJlKCkgPT09IDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIHJhdGlvbmFsIG51bWJlcnMgYXJlIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmVxdWFscyhbOTgsIDVdKTtcbiAgICAgKiovXG4gICAgXCJjb21wYXJlXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG4gICAgICB2YXIgdCA9ICh0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gLSBQW1wic1wiXSAqIFBbXCJuXCJdICogdGhpc1tcImRcIl0pO1xuICAgICAgcmV0dXJuICgwIDwgdCkgLSAodCA8IDApO1xuICAgIH0sXG5cbiAgICBcInNpbXBsaWZ5XCI6IGZ1bmN0aW9uKGVwcykge1xuXG4gICAgICBpZiAoaXNOYU4odGhpc1snbiddKSB8fCBpc05hTih0aGlzWydkJ10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBlcHMgPSBlcHMgfHwgMC4wMDE7XG5cbiAgICAgIHZhciB0aGlzQUJTID0gdGhpc1snYWJzJ10oKTtcbiAgICAgIHZhciBjb250ID0gdGhpc0FCU1sndG9Db250aW51ZWQnXSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvbnQubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgcyA9IG5ld0ZyYWN0aW9uKGNvbnRbaSAtIDFdLCAxKTtcbiAgICAgICAgZm9yICh2YXIgayA9IGkgLSAyOyBrID49IDA7IGstLSkge1xuICAgICAgICAgIHMgPSBzWydpbnZlcnNlJ10oKVsnYWRkJ10oY29udFtrXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc1snc3ViJ10odGhpc0FCUylbJ2FicyddKCkudmFsdWVPZigpIDwgZXBzKSB7XG4gICAgICAgICAgcmV0dXJuIHNbJ211bCddKHRoaXNbJ3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgZGl2aXNpYmxlXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmRpdmlzaWJsZSgxLjUpO1xuICAgICAqL1xuICAgIFwiZGl2aXNpYmxlXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG4gICAgICByZXR1cm4gISghKFBbXCJuXCJdICogdGhpc1tcImRcIl0pIHx8ICgodGhpc1tcIm5cIl0gKiBQW1wiZFwiXSkgJSAoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZyYWN0aW9uXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMTAwLic5MTgyMydcIikudmFsdWVPZigpID0+IDEwMC45MTgyMzkxODIzOTE4M1xuICAgICAqKi9cbiAgICAndmFsdWVPZic6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nLWZyYWN0aW9uIHJlcHJlc2VudGF0aW9uIG9mIGEgRnJhY3Rpb24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9GcmFjdGlvbih0cnVlKSA9PiBcIjQgMS8zXCJcbiAgICAgKiovXG4gICAgJ3RvRnJhY3Rpb24nOiBmdW5jdGlvbihleGNsdWRlV2hvbGUpIHtcblxuICAgICAgdmFyIHdob2xlLCBzdHIgPSBcIlwiO1xuICAgICAgdmFyIG4gPSB0aGlzW1wiblwiXTtcbiAgICAgIHZhciBkID0gdGhpc1tcImRcIl07XG4gICAgICBpZiAodGhpc1tcInNcIl0gPCAwKSB7XG4gICAgICAgIHN0cis9ICctJztcbiAgICAgIH1cblxuICAgICAgaWYgKGQgPT09IDEpIHtcbiAgICAgICAgc3RyKz0gbjtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVXaG9sZSAmJiAod2hvbGUgPSBNYXRoLmZsb29yKG4gLyBkKSkgPiAwKSB7XG4gICAgICAgICAgc3RyKz0gd2hvbGU7XG4gICAgICAgICAgc3RyKz0gXCIgXCI7XG4gICAgICAgICAgbiU9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIrPSBuO1xuICAgICAgICBzdHIrPSAnLyc7XG4gICAgICAgIHN0cis9IGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGF0ZXggcmVwcmVzZW50YXRpb24gb2YgYSBGcmFjdGlvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxLiczJ1wiKS50b0xhdGV4KCkgPT4gXCJcXGZyYWN7NH17M31cIlxuICAgICAqKi9cbiAgICAndG9MYXRleCc6IGZ1bmN0aW9uKGV4Y2x1ZGVXaG9sZSkge1xuXG4gICAgICB2YXIgd2hvbGUsIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgbiA9IHRoaXNbXCJuXCJdO1xuICAgICAgdmFyIGQgPSB0aGlzW1wiZFwiXTtcbiAgICAgIGlmICh0aGlzW1wic1wiXSA8IDApIHtcbiAgICAgICAgc3RyKz0gJy0nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCA9PT0gMSkge1xuICAgICAgICBzdHIrPSBuO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoZXhjbHVkZVdob2xlICYmICh3aG9sZSA9IE1hdGguZmxvb3IobiAvIGQpKSA+IDApIHtcbiAgICAgICAgICBzdHIrPSB3aG9sZTtcbiAgICAgICAgICBuJT0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cis9IFwiXFxcXGZyYWN7XCI7XG4gICAgICAgIHN0cis9IG47XG4gICAgICAgIHN0cis9ICd9eyc7XG4gICAgICAgIHN0cis9IGQ7XG4gICAgICAgIHN0cis9ICd9JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29udGludWVkIGZyYWN0aW9uIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiNy84XCIpLnRvQ29udGludWVkKCkgPT4gWzAsMSw3XVxuICAgICAqL1xuICAgICd0b0NvbnRpbnVlZCc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdDtcbiAgICAgIHZhciBhID0gdGhpc1snbiddO1xuICAgICAgdmFyIGIgPSB0aGlzWydkJ107XG4gICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTihiKSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIHJlcy5wdXNoKE1hdGguZmxvb3IoYSAvIGIpKTtcbiAgICAgICAgdCA9IGEgJSBiO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IHdoaWxlIChhICE9PSAxKTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZyYWN0aW9uIHdpdGggYWxsIGRpZ2l0c1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEwMC4nOTE4MjMnXCIpLnRvU3RyaW5nKCkgPT4gXCIxMDAuKDkxODIzKVwiXG4gICAgICoqL1xuICAgICd0b1N0cmluZyc6IGZ1bmN0aW9uKGRlYykge1xuXG4gICAgICB2YXIgTiA9IHRoaXNbXCJuXCJdO1xuICAgICAgdmFyIEQgPSB0aGlzW1wiZFwiXTtcblxuICAgICAgaWYgKGlzTmFOKE4pIHx8IGlzTmFOKEQpKSB7XG4gICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgfVxuXG4gICAgICBkZWMgPSBkZWMgfHwgMTU7IC8vIDE1ID0gZGVjaW1hbCBwbGFjZXMgd2hlbiBubyByZXBldGF0aW9uXG5cbiAgICAgIHZhciBjeWNMZW4gPSBjeWNsZUxlbihOLCBEKTsgLy8gQ3ljbGUgbGVuZ3RoXG4gICAgICB2YXIgY3ljT2ZmID0gY3ljbGVTdGFydChOLCBELCBjeWNMZW4pOyAvLyBDeWNsZSBzdGFydFxuXG4gICAgICB2YXIgc3RyID0gdGhpc1sncyddIDwgMCA/IFwiLVwiIDogXCJcIjtcblxuICAgICAgc3RyKz0gTiAvIEQgfCAwO1xuXG4gICAgICBOJT0gRDtcbiAgICAgIE4qPSAxMDtcblxuICAgICAgaWYgKE4pXG4gICAgICAgIHN0cis9IFwiLlwiO1xuXG4gICAgICBpZiAoY3ljTGVuKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGN5Y09mZjsgaS0tOykge1xuICAgICAgICAgIHN0cis9IE4gLyBEIHwgMDtcbiAgICAgICAgICBOJT0gRDtcbiAgICAgICAgICBOKj0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyKz0gXCIoXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBjeWNMZW47IGktLTspIHtcbiAgICAgICAgICBzdHIrPSBOIC8gRCB8IDA7XG4gICAgICAgICAgTiU9IEQ7XG4gICAgICAgICAgTio9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHN0cis9IFwiKVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlYzsgTiAmJiBpLS07KSB7XG4gICAgICAgICAgc3RyKz0gTiAvIEQgfCAwO1xuICAgICAgICAgIE4lPSBEO1xuICAgICAgICAgIE4qPSAxMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmVbXCJhbWRcIl0pIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEZyYWN0aW9uO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWN0aW9uLCBcIl9fZXNNb2R1bGVcIiwgeyAndmFsdWUnOiB0cnVlIH0pO1xuICAgIEZyYWN0aW9uWydkZWZhdWx0J10gPSBGcmFjdGlvbjtcbiAgICBGcmFjdGlvblsnRnJhY3Rpb24nXSA9IEZyYWN0aW9uO1xuICAgIG1vZHVsZVsnZXhwb3J0cyddID0gRnJhY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnRnJhY3Rpb24nXSA9IEZyYWN0aW9uO1xuICB9XG5cbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonYWJzJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0ID8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGguYWJzJyA6IE1hdGguYWJzIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1hYnMoICR7aW5wdXRzWzBdfSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguYWJzKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgYWJzID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGFicy5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBhYnNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonYWNjdW0nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgY29kZSxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBnZW5OYW1lID0gJ2dlbi4nICsgdGhpcy5uYW1lLFxuICAgICAgICBmdW5jdGlvbkJvZHlcblxuICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG5cbiAgICBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdID0gdGhpcy5pbml0aWFsVmFsdWVcblxuICAgIGZ1bmN0aW9uQm9keSA9IHRoaXMuY2FsbGJhY2soIGdlbk5hbWUsIGlucHV0c1swXSwgaW5wdXRzWzFdLCBgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1gIClcblxuICAgIC8vZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IHRoaXMgfSkgXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWUgKyAnX3ZhbHVlJ1xuICAgIFxuICAgIHJldHVybiBbIHRoaXMubmFtZSArICdfdmFsdWUnLCBmdW5jdGlvbkJvZHkgXVxuICB9LFxuXG4gIGNhbGxiYWNrKCBfbmFtZSwgX2luY3IsIF9yZXNldCwgdmFsdWVSZWYgKSB7XG4gICAgbGV0IGRpZmYgPSB0aGlzLm1heCAtIHRoaXMubWluLFxuICAgICAgICBvdXQgPSAnJyxcbiAgICAgICAgd3JhcCA9ICcnXG4gICAgXG4gICAgLyogdGhyZWUgZGlmZmVyZW50IG1ldGhvZHMgb2Ygd3JhcHBpbmcsIHRoaXJkIGlzIG1vc3QgZXhwZW5zaXZlOlxuICAgICAqXG4gICAgICogMTogcmFuZ2UgezAsMX06IHkgPSB4IC0gKHggfCAwKVxuICAgICAqIDI6IGxvZzIodGhpcy5tYXgpID09IGludGVnZXI6IHkgPSB4ICYgKHRoaXMubWF4IC0gMSlcbiAgICAgKiAzOiBhbGwgb3RoZXJzOiBpZiggeCA+PSB0aGlzLm1heCApIHkgPSB0aGlzLm1heCAteFxuICAgICAqXG4gICAgICovXG5cbiAgICAvLyBtdXN0IGNoZWNrIGZvciByZXNldCBiZWZvcmUgc3RvcmluZyB2YWx1ZSBmb3Igb3V0cHV0XG4gICAgaWYoICEodHlwZW9mIHRoaXMuaW5wdXRzWzFdID09PSAnbnVtYmVyJyAmJiB0aGlzLmlucHV0c1sxXSA8IDEpICkgeyBcbiAgICAgIGlmKCB0aGlzLnJlc2V0VmFsdWUgIT09IHRoaXMubWluICkge1xuXG4gICAgICAgIG91dCArPSBgICBpZiggJHtfcmVzZXR9ID49MSApICR7dmFsdWVSZWZ9ID0gJHt0aGlzLnJlc2V0VmFsdWV9XFxuXFxuYFxuICAgICAgICAvL291dCArPSBgICBpZiggJHtfcmVzZXR9ID49MSApICR7dmFsdWVSZWZ9ID0gJHt0aGlzLm1pbn1cXG5cXG5gXG4gICAgICB9ZWxzZXtcbiAgICAgICAgb3V0ICs9IGAgIGlmKCAke19yZXNldH0gPj0xICkgJHt2YWx1ZVJlZn0gPSAke3RoaXMubWlufVxcblxcbmBcbiAgICAgICAgLy9vdXQgKz0gYCAgaWYoICR7X3Jlc2V0fSA+PTEgKSAke3ZhbHVlUmVmfSA9ICR7dGhpcy5pbml0aWFsVmFsdWV9XFxuXFxuYFxuICAgICAgfVxuICAgIH1cblxuICAgIG91dCArPSBgICB2YXIgJHt0aGlzLm5hbWV9X3ZhbHVlID0gJHt2YWx1ZVJlZn1cXG5gXG4gICAgXG4gICAgaWYoIHRoaXMuc2hvdWxkV3JhcCA9PT0gZmFsc2UgJiYgdGhpcy5zaG91bGRDbGFtcCA9PT0gdHJ1ZSApIHtcbiAgICAgIG91dCArPSBgICBpZiggJHt2YWx1ZVJlZn0gPCAke3RoaXMubWF4IH0gKSAke3ZhbHVlUmVmfSArPSAke19pbmNyfVxcbmBcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSBgICAke3ZhbHVlUmVmfSArPSAke19pbmNyfVxcbmAgLy8gc3RvcmUgb3V0cHV0IHZhbHVlIGJlZm9yZSBhY2N1bXVsYXRpbmcgIFxuICAgIH1cblxuICAgIGlmKCB0aGlzLm1heCAhPT0gSW5maW5pdHkgICYmIHRoaXMuc2hvdWxkV3JhcE1heCApIHdyYXAgKz0gYCAgaWYoICR7dmFsdWVSZWZ9ID49ICR7dGhpcy5tYXh9ICkgJHt2YWx1ZVJlZn0gLT0gJHtkaWZmfVxcbmBcbiAgICBpZiggdGhpcy5taW4gIT09IC1JbmZpbml0eSAmJiB0aGlzLnNob3VsZFdyYXBNaW4gKSB3cmFwICs9IGAgIGlmKCAke3ZhbHVlUmVmfSA8ICR7dGhpcy5taW59ICkgJHt2YWx1ZVJlZn0gKz0gJHtkaWZmfVxcbmBcblxuICAgIC8vaWYoIHRoaXMubWluID09PSAwICYmIHRoaXMubWF4ID09PSAxICkgeyBcbiAgICAvLyAgd3JhcCA9ICBgICAke3ZhbHVlUmVmfSA9ICR7dmFsdWVSZWZ9IC0gKCR7dmFsdWVSZWZ9IHwgMClcXG5cXG5gXG4gICAgLy99IGVsc2UgaWYoIHRoaXMubWluID09PSAwICYmICggTWF0aC5sb2cyKCB0aGlzLm1heCApIHwgMCApID09PSBNYXRoLmxvZzIoIHRoaXMubWF4ICkgKSB7XG4gICAgLy8gIHdyYXAgPSAgYCAgJHt2YWx1ZVJlZn0gPSAke3ZhbHVlUmVmfSAmICgke3RoaXMubWF4fSAtIDEpXFxuXFxuYFxuICAgIC8vfSBlbHNlIGlmKCB0aGlzLm1heCAhPT0gSW5maW5pdHkgKXtcbiAgICAvLyAgd3JhcCA9IGAgIGlmKCAke3ZhbHVlUmVmfSA+PSAke3RoaXMubWF4fSApICR7dmFsdWVSZWZ9IC09ICR7ZGlmZn1cXG5cXG5gXG4gICAgLy99XG5cbiAgICBvdXQgPSBvdXQgKyB3cmFwICsgJ1xcbidcblxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuICBkZWZhdWx0cyA6IHsgbWluOjAsIG1heDoxLCByZXNldFZhbHVlOjAsIGluaXRpYWxWYWx1ZTowLCBzaG91bGRXcmFwOnRydWUsIHNob3VsZFdyYXBNYXg6IHRydWUsIHNob3VsZFdyYXBNaW46dHJ1ZSwgc2hvdWxkQ2xhbXA6ZmFsc2UgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW5jciwgcmVzZXQ9MCwgcHJvcGVydGllcyApID0+IHtcbiAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgICAgIFxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCBcbiAgICB7IFxuICAgICAgdWlkOiAgICBnZW4uZ2V0VUlEKCksXG4gICAgICBpbnB1dHM6IFsgaW5jciwgcmVzZXQgXSxcbiAgICAgIG1lbW9yeToge1xuICAgICAgICB2YWx1ZTogeyBsZW5ndGg6MSwgaWR4Om51bGwgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvdG8uZGVmYXVsdHMsXG4gICAgcHJvcGVydGllcyBcbiAgKVxuXG4gIGlmKCBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5zaG91bGRXcmFwTWF4ID09PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5zaG91bGRXcmFwTWluID09PSB1bmRlZmluZWQgKSB7XG4gICAgaWYoIHByb3BlcnRpZXMuc2hvdWxkV3JhcCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgdWdlbi5zaG91bGRXcmFwTWluID0gdWdlbi5zaG91bGRXcmFwTWF4ID0gcHJvcGVydGllcy5zaG91bGRXcmFwXG4gICAgfVxuICB9XG5cbiAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLnJlc2V0VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcbiAgICB1Z2VuLnJlc2V0VmFsdWUgPSB1Z2VuLm1pblxuICB9XG5cbiAgaWYoIHVnZW4uaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQgKSB1Z2VuLmluaXRpYWxWYWx1ZSA9IHVnZW4ubWluXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAndmFsdWUnLCB7XG4gICAgZ2V0KCkgIHsgXG4gICAgICAvL2NvbnNvbGUubG9nKCAnZ2VuOicsIGdlbiwgZ2VuLm1lbW9yeSApXG4gICAgICByZXR1cm4gZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLm1lbW9yeS52YWx1ZS5pZHggXSBcbiAgICB9LFxuICAgIHNldCh2KSB7IGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF0gPSB2IH1cbiAgfSlcblxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2Fjb3MnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcblxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQgPyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyAnYWNvcyc6IGlzV29ya2xldCA/ICdNYXRoLmFjb3MnIDpNYXRoLmFjb3MgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfWFjb3MoICR7aW5wdXRzWzBdfSApYCBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLmFjb3MoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBhY29zID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGFjb3MuaW5wdXRzID0gWyB4IF1cbiAgYWNvcy5pZCA9IGdlbi5nZXRVSUQoKVxuICBhY29zLm5hbWUgPSBgJHthY29zLmJhc2VuYW1lfXthY29zLmlkfWBcblxuICByZXR1cm4gYWNvc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBtdWwgICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBzdWIgICAgICA9IHJlcXVpcmUoICcuL3N1Yi5qcycgKSxcbiAgICBkaXYgICAgICA9IHJlcXVpcmUoICcuL2Rpdi5qcycgKSxcbiAgICBkYXRhICAgICA9IHJlcXVpcmUoICcuL2RhdGEuanMnICksXG4gICAgcGVlayAgICAgPSByZXF1aXJlKCAnLi9wZWVrLmpzJyApLFxuICAgIGFjY3VtICAgID0gcmVxdWlyZSggJy4vYWNjdW0uanMnICksXG4gICAgaWZlbHNlICAgPSByZXF1aXJlKCAnLi9pZmVsc2VpZi5qcycgKSxcbiAgICBsdCAgICAgICA9IHJlcXVpcmUoICcuL2x0LmpzJyApLFxuICAgIGJhbmcgICAgID0gcmVxdWlyZSggJy4vYmFuZy5qcycgKSxcbiAgICBlbnYgICAgICA9IHJlcXVpcmUoICcuL2Vudi5qcycgKSxcbiAgICBhZGQgICAgICA9IHJlcXVpcmUoICcuL2FkZC5qcycgKSxcbiAgICBwb2tlICAgICA9IHJlcXVpcmUoICcuL3Bva2UuanMnICksXG4gICAgbmVxICAgICAgPSByZXF1aXJlKCAnLi9uZXEuanMnICksXG4gICAgYW5kICAgICAgPSByZXF1aXJlKCAnLi9hbmQuanMnICksXG4gICAgZ3RlICAgICAgPSByZXF1aXJlKCAnLi9ndGUuanMnICksXG4gICAgbWVtbyAgICAgPSByZXF1aXJlKCAnLi9tZW1vLmpzJyApLFxuICAgIHV0aWxpdGllcz0gcmVxdWlyZSggJy4vdXRpbGl0aWVzLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gKCBhdHRhY2tUaW1lID0gNDQxMDAsIGRlY2F5VGltZSA9IDQ0MTAwLCBfcHJvcHMgKSA9PiB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBzaGFwZTonZXhwb25lbnRpYWwnLCBhbHBoYTo1LCB0cmlnZ2VyOm51bGwgfSwgX3Byb3BzIClcbiAgY29uc3QgX2JhbmcgPSBwcm9wcy50cmlnZ2VyICE9PSBudWxsID8gcHJvcHMudHJpZ2dlciA6IGJhbmcoKSxcbiAgICAgICAgcGhhc2UgPSBhY2N1bSggMSwgX2JhbmcsIHsgbWluOjAsIG1heDogSW5maW5pdHksIGluaXRpYWxWYWx1ZTotSW5maW5pdHksIHNob3VsZFdyYXA6ZmFsc2UgfSlcbiAgICAgIFxuICBsZXQgYnVmZmVyRGF0YSwgYnVmZmVyRGF0YVJldmVyc2UsIGRlY2F5RGF0YSwgb3V0LCBidWZmZXJcblxuICAvL2NvbnNvbGUubG9nKCAnc2hhcGU6JywgcHJvcHMuc2hhcGUsICdhdHRhY2sgdGltZTonLCBhdHRhY2tUaW1lLCAnZGVjYXkgdGltZTonLCBkZWNheVRpbWUgKVxuICBsZXQgY29tcGxldGVGbGFnID0gZGF0YSggWzBdIClcbiAgXG4gIC8vIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50IHRvIHVzZSBleGlzdGluZyBwaGFzZSBhY2N1bXVsYXRvciBmb3IgbGluZWFyIGVudmVsb3Blc1xuICBpZiggcHJvcHMuc2hhcGUgPT09ICdsaW5lYXInICkge1xuICAgIG91dCA9IGlmZWxzZSggXG4gICAgICBhbmQoIGd0ZSggcGhhc2UsIDApLCBsdCggcGhhc2UsIGF0dGFja1RpbWUgKSksXG4gICAgICBkaXYoIHBoYXNlLCBhdHRhY2tUaW1lICksXG5cbiAgICAgIGFuZCggZ3RlKCBwaGFzZSwgMCksICBsdCggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lICkgKSApLFxuICAgICAgc3ViKCAxLCBkaXYoIHN1YiggcGhhc2UsIGF0dGFja1RpbWUgKSwgZGVjYXlUaW1lICkgKSxcbiAgICAgIFxuICAgICAgbmVxKCBwaGFzZSwgLUluZmluaXR5KSxcbiAgICAgIHBva2UoIGNvbXBsZXRlRmxhZywgMSwgMCwgeyBpbmxpbmU6MCB9KSxcblxuICAgICAgMCBcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyRGF0YSA9IGVudih7IGxlbmd0aDoxMDI0LCB0eXBlOnByb3BzLnNoYXBlLCBhbHBoYTpwcm9wcy5hbHBoYSB9KVxuICAgIGJ1ZmZlckRhdGFSZXZlcnNlID0gZW52KHsgbGVuZ3RoOjEwMjQsIHR5cGU6cHJvcHMuc2hhcGUsIGFscGhhOnByb3BzLmFscGhhLCByZXZlcnNlOnRydWUgfSlcblxuICAgIG91dCA9IGlmZWxzZSggXG4gICAgICBhbmQoIGd0ZSggcGhhc2UsIDApLCBsdCggcGhhc2UsIGF0dGFja1RpbWUgKSApLCBcbiAgICAgIHBlZWsoIGJ1ZmZlckRhdGEsIGRpdiggcGhhc2UsIGF0dGFja1RpbWUgKSwgeyBib3VuZG1vZGU6J2NsYW1wJyB9ICksIFxuXG4gICAgICBhbmQoIGd0ZShwaGFzZSwwKSwgbHQoIHBoYXNlLCBhZGQoIGF0dGFja1RpbWUsIGRlY2F5VGltZSApICkgKSwgXG4gICAgICBwZWVrKCBidWZmZXJEYXRhUmV2ZXJzZSwgZGl2KCBzdWIoIHBoYXNlLCBhdHRhY2tUaW1lICksIGRlY2F5VGltZSApLCB7IGJvdW5kbW9kZTonY2xhbXAnIH0pLFxuXG4gICAgICBuZXEoIHBoYXNlLCAtSW5maW5pdHkgKSxcbiAgICAgIHBva2UoIGNvbXBsZXRlRmxhZywgMSwgMCwgeyBpbmxpbmU6MCB9KSxcblxuICAgICAgMFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHVzaW5nV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSApIHtcbiAgICBvdXQubm9kZSA9IG51bGxcbiAgICB1dGlsaXRpZXMucmVnaXN0ZXIoIG91dCApXG4gIH1cblxuICAvLyBuZWVkZWQgZm9yIGdpYmJlcmlzaC4uLiBnZXR0aW5nIHRoaXMgdG8gd29yayByaWdodCB3aXRoIHdvcmtsZXRzXG4gIC8vIHZpYSBwcm9taXNlcyB3aWxsIHByb2JhYmx5IGJlIHRyaWNreVxuICBvdXQuaXNDb21wbGV0ZSA9ICgpPT4ge1xuICAgIGlmKCB1c2luZ1dvcmtsZXQgPT09IHRydWUgJiYgb3V0Lm5vZGUgIT09IG51bGwgKSB7XG4gICAgICBjb25zdCBwID0gbmV3IFByb21pc2UoIHJlc29sdmUgPT4ge1xuICAgICAgICBvdXQubm9kZS5nZXRNZW1vcnlWYWx1ZSggY29tcGxldGVGbGFnLm1lbW9yeS52YWx1ZXMuaWR4LCByZXNvbHZlIClcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBwXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gZ2VuLm1lbW9yeS5oZWFwWyBjb21wbGV0ZUZsYWcubWVtb3J5LnZhbHVlcy5pZHggXVxuICAgIH1cbiAgfVxuXG4gIG91dC50cmlnZ2VyID0gKCk9PiB7XG4gICAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSAmJiBvdXQubm9kZSAhPT0gbnVsbCApIHtcbiAgICAgIG91dC5ub2RlLnBvcnQucG9zdE1lc3NhZ2UoeyBrZXk6J3NldCcsIGlkeDpjb21wbGV0ZUZsYWcubWVtb3J5LnZhbHVlcy5pZHgsIHZhbHVlOjAgfSlcbiAgICB9ZWxzZXtcbiAgICAgIGdlbi5tZW1vcnkuaGVhcFsgY29tcGxldGVGbGFnLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSAwXG4gICAgfVxuICAgIF9iYW5nLnRyaWdnZXIoKVxuICB9XG5cbiAgcmV0dXJuIG91dCBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmNvbnN0IHByb3RvID0geyBcbiAgYmFzZW5hbWU6J2FkZCcsXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXQ9JycsXG4gICAgICAgIHN1bSA9IDAsIG51bUNvdW50ID0gMCwgYWRkZXJBdEVuZCA9IGZhbHNlLCBhbHJlYWR5RnVsbFN1bW1lZCA9IHRydWVcblxuICAgIGlmKCBpbnB1dHMubGVuZ3RoID09PSAwICkgcmV0dXJuIDBcblxuICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSBgXG5cbiAgICBpbnB1dHMuZm9yRWFjaCggKHYsaSkgPT4ge1xuICAgICAgaWYoIGlzTmFOKCB2ICkgKSB7XG4gICAgICAgIG91dCArPSB2XG4gICAgICAgIGlmKCBpIDwgaW5wdXRzLmxlbmd0aCAtMSApIHtcbiAgICAgICAgICBhZGRlckF0RW5kID0gdHJ1ZVxuICAgICAgICAgIG91dCArPSAnICsgJ1xuICAgICAgICB9XG4gICAgICAgIGFscmVhZHlGdWxsU3VtbWVkID0gZmFsc2VcbiAgICAgIH1lbHNle1xuICAgICAgICBzdW0gKz0gcGFyc2VGbG9hdCggdiApXG4gICAgICAgIG51bUNvdW50KytcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYoIG51bUNvdW50ID4gMCApIHtcbiAgICAgIG91dCArPSBhZGRlckF0RW5kIHx8IGFscmVhZHlGdWxsU3VtbWVkID8gc3VtIDogJyArICcgKyBzdW1cbiAgICB9XG5cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCAuLi5hcmdzICkgPT4ge1xuICBjb25zdCBhZGQgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIGFkZC5pZCA9IGdlbi5nZXRVSUQoKVxuICBhZGQubmFtZSA9IGFkZC5iYXNlbmFtZSArIGFkZC5pZFxuICBhZGQuaW5wdXRzID0gYXJnc1xuXG4gIHJldHVybiBhZGRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgbXVsICAgICAgPSByZXF1aXJlKCAnLi9tdWwuanMnICksXG4gICAgc3ViICAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnICksXG4gICAgZGl2ICAgICAgPSByZXF1aXJlKCAnLi9kaXYuanMnICksXG4gICAgZGF0YSAgICAgPSByZXF1aXJlKCAnLi9kYXRhLmpzJyApLFxuICAgIHBlZWsgICAgID0gcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgICBhY2N1bSAgICA9IHJlcXVpcmUoICcuL2FjY3VtLmpzJyApLFxuICAgIGlmZWxzZSAgID0gcmVxdWlyZSggJy4vaWZlbHNlaWYuanMnICksXG4gICAgbHQgICAgICAgPSByZXF1aXJlKCAnLi9sdC5qcycgKSxcbiAgICBiYW5nICAgICA9IHJlcXVpcmUoICcuL2JhbmcuanMnICksXG4gICAgZW52ICAgICAgPSByZXF1aXJlKCAnLi9lbnYuanMnICksXG4gICAgcGFyYW0gICAgPSByZXF1aXJlKCAnLi9wYXJhbS5qcycgKSxcbiAgICBhZGQgICAgICA9IHJlcXVpcmUoICcuL2FkZC5qcycgKSxcbiAgICBndHAgICAgICA9IHJlcXVpcmUoICcuL2d0cC5qcycgKSxcbiAgICBub3QgICAgICA9IHJlcXVpcmUoICcuL25vdC5qcycgKSxcbiAgICBhbmQgICAgICA9IHJlcXVpcmUoICcuL2FuZC5qcycgKSxcbiAgICBuZXEgICAgICA9IHJlcXVpcmUoICcuL25lcS5qcycgKSxcbiAgICBwb2tlICAgICA9IHJlcXVpcmUoICcuL3Bva2UuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGF0dGFja1RpbWU9NDQsIGRlY2F5VGltZT0yMjA1MCwgc3VzdGFpblRpbWU9NDQxMDAsIHN1c3RhaW5MZXZlbD0uNiwgcmVsZWFzZVRpbWU9NDQxMDAsIF9wcm9wcyApID0+IHtcbiAgbGV0IGVudlRyaWdnZXIgPSBiYW5nKCksXG4gICAgICBwaGFzZSA9IGFjY3VtKCAxLCBlbnZUcmlnZ2VyLCB7IG1heDogSW5maW5pdHksIHNob3VsZFdyYXA6ZmFsc2UsIGluaXRpYWxWYWx1ZTpJbmZpbml0eSB9KSxcbiAgICAgIHNob3VsZFN1c3RhaW4gPSBwYXJhbSggMSApLFxuICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICBzaGFwZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgIGFscGhhOiA1LFxuICAgICAgICAgdHJpZ2dlclJlbGVhc2U6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIF9wcm9wcyApLFxuICAgICAgYnVmZmVyRGF0YSwgZGVjYXlEYXRhLCBvdXQsIGJ1ZmZlciwgc3VzdGFpbkNvbmRpdGlvbiwgcmVsZWFzZUFjY3VtLCByZWxlYXNlQ29uZGl0aW9uXG5cblxuICBjb25zdCBjb21wbGV0ZUZsYWcgPSBkYXRhKCBbMF0gKVxuXG4gIGJ1ZmZlckRhdGEgPSBlbnYoeyBsZW5ndGg6MTAyNCwgYWxwaGE6cHJvcHMuYWxwaGEsIHNoaWZ0OjAsIHR5cGU6cHJvcHMuc2hhcGUgfSlcblxuICBzdXN0YWluQ29uZGl0aW9uID0gcHJvcHMudHJpZ2dlclJlbGVhc2UgXG4gICAgPyBzaG91bGRTdXN0YWluXG4gICAgOiBsdCggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXN0YWluVGltZSApIClcblxuICByZWxlYXNlQWNjdW0gPSBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgID8gZ3RwKCBzdWIoIHN1c3RhaW5MZXZlbCwgYWNjdW0oIGRpdiggc3VzdGFpbkxldmVsLCByZWxlYXNlVGltZSApICwgMCwgeyBzaG91bGRXcmFwOmZhbHNlIH0pICksIDAgKVxuICAgIDogc3ViKCBzdXN0YWluTGV2ZWwsIG11bCggZGl2KCBzdWIoIHBoYXNlLCBhZGQoIGF0dGFja1RpbWUsIGRlY2F5VGltZSwgc3VzdGFpblRpbWUgKSApLCByZWxlYXNlVGltZSApLCBzdXN0YWluTGV2ZWwgKSApLCBcblxuICByZWxlYXNlQ29uZGl0aW9uID0gcHJvcHMudHJpZ2dlclJlbGVhc2VcbiAgICA/IG5vdCggc2hvdWxkU3VzdGFpbiApXG4gICAgOiBsdCggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXN0YWluVGltZSwgcmVsZWFzZVRpbWUgKSApXG5cbiAgb3V0ID0gaWZlbHNlKFxuICAgIC8vIGF0dGFjayBcbiAgICBsdCggcGhhc2UsICBhdHRhY2tUaW1lICksIFxuICAgIHBlZWsoIGJ1ZmZlckRhdGEsIGRpdiggcGhhc2UsIGF0dGFja1RpbWUgKSwgeyBib3VuZG1vZGU6J2NsYW1wJyB9ICksIFxuXG4gICAgLy8gZGVjYXlcbiAgICBsdCggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lICkgKSwgXG4gICAgcGVlayggYnVmZmVyRGF0YSwgc3ViKCAxLCBtdWwoIGRpdiggc3ViKCBwaGFzZSwgIGF0dGFja1RpbWUgKSwgIGRlY2F5VGltZSApLCBzdWIoIDEsICBzdXN0YWluTGV2ZWwgKSApICksIHsgYm91bmRtb2RlOidjbGFtcCcgfSksXG5cbiAgICAvLyBzdXN0YWluXG4gICAgYW5kKCBzdXN0YWluQ29uZGl0aW9uLCBuZXEoIHBoYXNlLCBJbmZpbml0eSApICksXG4gICAgcGVlayggYnVmZmVyRGF0YSwgIHN1c3RhaW5MZXZlbCApLFxuXG4gICAgLy8gcmVsZWFzZVxuICAgIHJlbGVhc2VDb25kaXRpb24sIC8vbHQoIHBoYXNlLCAgYXR0YWNrVGltZSArICBkZWNheVRpbWUgKyAgc3VzdGFpblRpbWUgKyAgcmVsZWFzZVRpbWUgKSxcbiAgICBwZWVrKCBcbiAgICAgIGJ1ZmZlckRhdGEsXG4gICAgICByZWxlYXNlQWNjdW0sIFxuICAgICAgLy9zdWIoICBzdXN0YWluTGV2ZWwsIG11bCggZGl2KCBzdWIoIHBoYXNlLCAgYXR0YWNrVGltZSArICBkZWNheVRpbWUgKyAgc3VzdGFpblRpbWUpLCAgcmVsZWFzZVRpbWUgKSwgIHN1c3RhaW5MZXZlbCApICksIFxuICAgICAgeyBib3VuZG1vZGU6J2NsYW1wJyB9XG4gICAgKSxcblxuICAgIG5lcSggcGhhc2UsIEluZmluaXR5ICksXG4gICAgcG9rZSggY29tcGxldGVGbGFnLCAxLCAwLCB7IGlubGluZTowIH0pLFxuXG4gICAgMFxuICApXG4gICBcbiAgY29uc3QgdXNpbmdXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICBpZiggdXNpbmdXb3JrbGV0ID09PSB0cnVlICkge1xuICAgIG91dC5ub2RlID0gbnVsbFxuICAgIHV0aWxpdGllcy5yZWdpc3Rlciggb3V0IClcbiAgfVxuXG4gIG91dC50cmlnZ2VyID0gKCk9PiB7XG4gICAgc2hvdWxkU3VzdGFpbi52YWx1ZSA9IDFcbiAgICBlbnZUcmlnZ2VyLnRyaWdnZXIoKVxuICB9XG4gXG4gIC8vIG5lZWRlZCBmb3IgZ2liYmVyaXNoLi4uIGdldHRpbmcgdGhpcyB0byB3b3JrIHJpZ2h0IHdpdGggd29ya2xldHNcbiAgLy8gdmlhIHByb21pc2VzIHdpbGwgcHJvYmFibHkgYmUgdHJpY2t5XG4gIG91dC5pc0NvbXBsZXRlID0gKCk9PiB7XG4gICAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSAmJiBvdXQubm9kZSAhPT0gbnVsbCApIHtcbiAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICAgIG91dC5ub2RlLmdldE1lbW9yeVZhbHVlKCBjb21wbGV0ZUZsYWcubWVtb3J5LnZhbHVlcy5pZHgsIHJlc29sdmUgKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHBcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIGNvbXBsZXRlRmxhZy5tZW1vcnkudmFsdWVzLmlkeCBdXG4gICAgfVxuICB9XG5cblxuICBvdXQucmVsZWFzZSA9ICgpPT4ge1xuICAgIHNob3VsZFN1c3RhaW4udmFsdWUgPSAwXG4gICAgLy8gWFhYIHByZXR0eSBuYXN0eS4uLiBncmFicyBhY2N1bSBpbnNpZGUgb2YgZ3RwIGFuZCByZXNldHMgdmFsdWUgbWFudWFsbHlcbiAgICAvLyB1bmZvcnR1bmF0ZWx5IGVudlRyaWdnZXIgd29uJ3Qgd29yayBhcyBpdCdzIGJhY2sgdG8gMCBieSB0aGUgdGltZSB0aGUgcmVsZWFzZSBibG9jayBpcyB0cmlnZ2VyZWQuLi5cbiAgICBpZiggdXNpbmdXb3JrbGV0ICYmIG91dC5ub2RlICE9PSBudWxsICkge1xuICAgICAgb3V0Lm5vZGUucG9ydC5wb3N0TWVzc2FnZSh7IGtleTonc2V0JywgaWR4OnJlbGVhc2VBY2N1bS5pbnB1dHNbMF0uaW5wdXRzWzFdLm1lbW9yeS52YWx1ZS5pZHgsIHZhbHVlOjAgfSlcbiAgICB9ZWxzZXtcbiAgICAgIGdlbi5tZW1vcnkuaGVhcFsgcmVsZWFzZUFjY3VtLmlucHV0c1swXS5pbnB1dHNbMV0ubWVtb3J5LnZhbHVlLmlkeCBdID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQgXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidhbmQnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSAoJHtpbnB1dHNbMF19ICE9PSAwICYmICR7aW5wdXRzWzFdfSAhPT0gMCkgfCAwXFxuXFxuYFxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gYCR7dGhpcy5uYW1lfWBcblxuICAgIHJldHVybiBbIGAke3RoaXMubmFtZX1gLCBvdXQgXVxuICB9LFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIGluMiApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBpbjEsIGluMiBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidhc2luJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldCA/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdhc2luJzogaXNXb3JrbGV0ID8gJ01hdGguc2luJyA6IE1hdGguYXNpbiB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9YXNpbiggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguYXNpbiggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IGFzaW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgYXNpbi5pbnB1dHMgPSBbIHggXVxuICBhc2luLmlkID0gZ2VuLmdldFVJRCgpXG4gIGFzaW4ubmFtZSA9IGAke2FzaW4uYmFzZW5hbWV9e2FzaW4uaWR9YFxuXG4gIHJldHVybiBhc2luXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2F0YW4nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0ID8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ2F0YW4nOiBpc1dvcmtsZXQgPyAnTWF0aC5hdGFuJyA6IE1hdGguYXRhbiB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9YXRhbiggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguYXRhbiggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IGF0YW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgYXRhbi5pbnB1dHMgPSBbIHggXVxuICBhdGFuLmlkID0gZ2VuLmdldFVJRCgpXG4gIGF0YW4ubmFtZSA9IGAke2F0YW4uYmFzZW5hbWV9e2F0YW4uaWR9YFxuXG4gIHJldHVybiBhdGFuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgaGlzdG9yeSA9IHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gICAgbXVsICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBzdWIgICAgID0gcmVxdWlyZSggJy4vc3ViLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gKCBkZWNheVRpbWUgPSA0NDEwMCApID0+IHtcbiAgbGV0IHNzZCA9IGhpc3RvcnkgKCAxICksXG4gICAgICB0NjAgPSBNYXRoLmV4cCggLTYuOTA3NzU1Mjc4OTIxIC8gZGVjYXlUaW1lIClcblxuICBzc2QuaW4oIG11bCggc3NkLm91dCwgdDYwICkgKVxuXG4gIHNzZC5vdXQudHJpZ2dlciA9ICgpPT4ge1xuICAgIHNzZC52YWx1ZSA9IDFcbiAgfVxuXG4gIHJldHVybiBzdWIoIDEsIHNzZC5vdXQgKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgZ2VuKCkge1xuICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG4gICAgXG4gICAgbGV0IG91dCA9IFxuYCAgdmFyICR7dGhpcy5uYW1lfSA9IG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dXG4gIGlmKCAke3RoaXMubmFtZX0gPT09IDEgKSBtZW1vcnlbJHt0aGlzLm1lbW9yeS52YWx1ZS5pZHh9XSA9IDAgICAgICBcbiAgICAgIFxuYFxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9IFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggX3Byb3BzICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICksXG4gICAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgbWluOjAsIG1heDoxIH0sIF9wcm9wcyApXG5cbiAgdWdlbi5uYW1lID0gJ2JhbmcnICsgZ2VuLmdldFVJRCgpXG5cbiAgdWdlbi5taW4gPSBwcm9wcy5taW5cbiAgdWdlbi5tYXggPSBwcm9wcy5tYXhcblxuICBjb25zdCB1c2luZ1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gIGlmKCB1c2luZ1dvcmtsZXQgPT09IHRydWUgKSB7XG4gICAgdWdlbi5ub2RlID0gbnVsbFxuICAgIHV0aWxpdGllcy5yZWdpc3RlciggdWdlbiApXG4gIH1cblxuICB1Z2VuLnRyaWdnZXIgPSAoKSA9PiB7XG4gICAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSAmJiB1Z2VuLm5vZGUgIT09IG51bGwgKSB7XG4gICAgICB1Z2VuLm5vZGUucG9ydC5wb3N0TWVzc2FnZSh7IGtleTonc2V0JywgaWR4OnVnZW4ubWVtb3J5LnZhbHVlLmlkeCwgdmFsdWU6dWdlbi5tYXggfSlcbiAgICB9ZWxzZXtcbiAgICAgIGdlbi5tZW1vcnkuaGVhcFsgdWdlbi5tZW1vcnkudmFsdWUuaWR4IF0gPSB1Z2VuLm1heCBcbiAgICB9XG4gIH1cblxuICB1Z2VuLm1lbW9yeSA9IHtcbiAgICB2YWx1ZTogeyBsZW5ndGg6MSwgaWR4Om51bGwgfVxuICB9XG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2Jvb2wnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIG91dCA9IGAke2lucHV0c1swXX0gPT09IDAgPyAwIDogMWBcbiAgICBcbiAgICAvL2dlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGBnZW4uZGF0YS4ke3RoaXMubmFtZX1gXG5cbiAgICAvL3JldHVybiBbIGBnZW4uZGF0YS4ke3RoaXMubmFtZX1gLCAnICcgK291dCBdXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgdWlkOiAgICAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogICAgIFsgaW4xIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidjZWlsJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0ID8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGguY2VpbCcgOiBNYXRoLmNlaWwgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfWNlaWwoICR7aW5wdXRzWzBdfSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguY2VpbCggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IGNlaWwgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgY2VpbC5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBjZWlsXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpLFxuICAgIGZsb29yPSByZXF1aXJlKCcuL2Zsb29yLmpzJyksXG4gICAgc3ViICA9IHJlcXVpcmUoJy4vc3ViLmpzJyksXG4gICAgbWVtbyA9IHJlcXVpcmUoJy4vbWVtby5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2NsaXAnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgY29kZSxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXRcblxuICAgIG91dCA9XG5cbmAgdmFyICR7dGhpcy5uYW1lfSA9ICR7aW5wdXRzWzBdfVxuICBpZiggJHt0aGlzLm5hbWV9ID4gJHtpbnB1dHNbMl19ICkgJHt0aGlzLm5hbWV9ID0gJHtpbnB1dHNbMl19XG4gIGVsc2UgaWYoICR7dGhpcy5uYW1lfSA8ICR7aW5wdXRzWzFdfSApICR7dGhpcy5uYW1lfSA9ICR7aW5wdXRzWzFdfVxuYFxuICAgIG91dCA9ICcgJyArIG91dFxuICAgIFxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xLCBtaW49LTEsIG1heD0xICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IFxuICAgIG1pbiwgXG4gICAgbWF4LFxuICAgIHVpZDogICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogWyBpbjEsIG1pbiwgbWF4IF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2NvcycsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcblxuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldCA/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdjb3MnOiBpc1dvcmtsZXQgPyAnTWF0aC5jb3MnIDogTWF0aC5jb3MgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfWNvcyggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguY29zKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgY29zID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGNvcy5pbnB1dHMgPSBbIHggXVxuICBjb3MuaWQgPSBnZW4uZ2V0VUlEKClcbiAgY29zLm5hbWUgPSBgJHtjb3MuYmFzZW5hbWV9e2Nvcy5pZH1gXG5cbiAgcmV0dXJuIGNvc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidjb3VudGVyJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGNvZGUsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgZ2VuTmFtZSA9ICdnZW4uJyArIHRoaXMubmFtZSxcbiAgICAgICAgZnVuY3Rpb25Cb2R5XG4gICAgICAgXG4gICAgaWYoIHRoaXMubWVtb3J5LnZhbHVlLmlkeCA9PT0gbnVsbCApIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG4gICAgZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLm1lbW9yeS52YWx1ZS5pZHggXSA9IHRoaXMuaW5pdGlhbFZhbHVlXG4gICAgXG4gICAgZnVuY3Rpb25Cb2R5ICA9IHRoaXMuY2FsbGJhY2soIGdlbk5hbWUsIGlucHV0c1swXSwgaW5wdXRzWzFdLCBpbnB1dHNbMl0sIGlucHV0c1szXSwgaW5wdXRzWzRdLCAgYG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dYCwgYG1lbW9yeVske3RoaXMubWVtb3J5LndyYXAuaWR4fV1gICApXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWUgKyAnX3ZhbHVlJ1xuICAgXG4gICAgaWYoIGdlbi5tZW1vWyB0aGlzLndyYXAubmFtZSBdID09PSB1bmRlZmluZWQgKSB0aGlzLndyYXAuZ2VuKClcblxuICAgIHJldHVybiBbIHRoaXMubmFtZSArICdfdmFsdWUnLCBmdW5jdGlvbkJvZHkgXVxuICB9LFxuXG4gIGNhbGxiYWNrKCBfbmFtZSwgX2luY3IsIF9taW4sIF9tYXgsIF9yZXNldCwgbG9vcHMsIHZhbHVlUmVmLCB3cmFwUmVmICkge1xuICAgIGxldCBkaWZmID0gdGhpcy5tYXggLSB0aGlzLm1pbixcbiAgICAgICAgb3V0ID0gJycsXG4gICAgICAgIHdyYXAgPSAnJ1xuICAgIC8vIG11c3QgY2hlY2sgZm9yIHJlc2V0IGJlZm9yZSBzdG9yaW5nIHZhbHVlIGZvciBvdXRwdXRcbiAgICBpZiggISh0eXBlb2YgdGhpcy5pbnB1dHNbM10gPT09ICdudW1iZXInICYmIHRoaXMuaW5wdXRzWzNdIDwgMSkgKSB7IFxuICAgICAgb3V0ICs9IGAgIGlmKCAke19yZXNldH0gPj0gMSApICR7dmFsdWVSZWZ9ID0gJHtfbWlufVxcbmBcbiAgICB9XG5cbiAgICBvdXQgKz0gYCAgdmFyICR7dGhpcy5uYW1lfV92YWx1ZSA9ICR7dmFsdWVSZWZ9O1xcbiAgJHt2YWx1ZVJlZn0gKz0gJHtfaW5jcn1cXG5gIC8vIHN0b3JlIG91dHB1dCB2YWx1ZSBiZWZvcmUgYWNjdW11bGF0aW5nICBcbiAgICBcbiAgICBpZiggdHlwZW9mIHRoaXMubWF4ID09PSAnbnVtYmVyJyAmJiB0aGlzLm1heCAhPT0gSW5maW5pdHkgJiYgdHlwZW9mIHRoaXMubWluICE9PSAnbnVtYmVyJyApIHtcbiAgICAgIHdyYXAgPSBcbmAgIGlmKCAke3ZhbHVlUmVmfSA+PSAke3RoaXMubWF4fSAmJiAgJHtsb29wc30gPiAwKSB7XG4gICAgJHt2YWx1ZVJlZn0gLT0gJHtkaWZmfVxuICAgICR7d3JhcFJlZn0gPSAxXG4gIH1lbHNle1xuICAgICR7d3JhcFJlZn0gPSAwXG4gIH1cXG5gXG4gICAgfWVsc2UgaWYoIHRoaXMubWF4ICE9PSBJbmZpbml0eSAmJiB0aGlzLm1pbiAhPT0gSW5maW5pdHkgKSB7XG4gICAgICB3cmFwID0gXG5gICBpZiggJHt2YWx1ZVJlZn0gPj0gJHtfbWF4fSAmJiAgJHtsb29wc30gPiAwKSB7XG4gICAgJHt2YWx1ZVJlZn0gLT0gJHtfbWF4fSAtICR7X21pbn1cbiAgICAke3dyYXBSZWZ9ID0gMVxuICB9ZWxzZSBpZiggJHt2YWx1ZVJlZn0gPCAke19taW59ICYmICAke2xvb3BzfSA+IDApIHtcbiAgICAke3ZhbHVlUmVmfSArPSAke19tYXh9IC0gJHtfbWlufVxuICAgICR7d3JhcFJlZn0gPSAxXG4gIH1lbHNle1xuICAgICR7d3JhcFJlZn0gPSAwXG4gIH1cXG5gXG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gJ1xcbidcbiAgICB9XG5cbiAgICBvdXQgPSBvdXQgKyB3cmFwXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluY3I9MSwgbWluPTAsIG1heD1JbmZpbml0eSwgcmVzZXQ9MCwgbG9vcHM9MSwgIHByb3BlcnRpZXMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbiggeyBpbml0aWFsVmFsdWU6IDAsIHNob3VsZFdyYXA6dHJ1ZSB9LCBwcm9wZXJ0aWVzIClcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IFxuICAgIG1pbjogICAgbWluLCBcbiAgICBtYXg6ICAgIG1heCxcbiAgICBpbml0aWFsVmFsdWU6IGRlZmF1bHRzLmluaXRpYWxWYWx1ZSxcbiAgICB2YWx1ZTogIGRlZmF1bHRzLmluaXRpYWxWYWx1ZSxcbiAgICB1aWQ6ICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6IFsgaW5jciwgbWluLCBtYXgsIHJlc2V0LCBsb29wcyBdLFxuICAgIG1lbW9yeToge1xuICAgICAgdmFsdWU6IHsgbGVuZ3RoOjEsIGlkeDogbnVsbCB9LFxuICAgICAgd3JhcDogIHsgbGVuZ3RoOjEsIGlkeDogbnVsbCB9IFxuICAgIH0sXG4gICAgd3JhcCA6IHtcbiAgICAgIGdlbigpIHsgXG4gICAgICAgIGlmKCB1Z2VuLm1lbW9yeS53cmFwLmlkeCA9PT0gbnVsbCApIHtcbiAgICAgICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdWdlbi5tZW1vcnkgKVxuICAgICAgICB9XG4gICAgICAgIGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgICAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgbWVtb3J5WyAke3VnZW4ubWVtb3J5LndyYXAuaWR4fSBdYFxuICAgICAgICByZXR1cm4gYG1lbW9yeVsgJHt1Z2VuLm1lbW9yeS53cmFwLmlkeH0gXWAgXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0cyApXG4gXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ3ZhbHVlJywge1xuICAgIGdldCgpIHtcbiAgICAgIGlmKCB0aGlzLm1lbW9yeS52YWx1ZS5pZHggIT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQoIHYgKSB7XG4gICAgICBpZiggdGhpcy5tZW1vcnkudmFsdWUuaWR4ICE9PSBudWxsICkge1xuICAgICAgICBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdID0gdiBcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICB1Z2VuLndyYXAuaW5wdXRzID0gWyB1Z2VuIF1cbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcbiAgdWdlbi53cmFwLm5hbWUgPSB1Z2VuLm5hbWUgKyAnX3dyYXAnXG4gIHJldHVybiB1Z2VuXG59IFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGFjY3VtPSByZXF1aXJlKCAnLi9waGFzb3IuanMnICksXG4gICAgZGF0YSA9IHJlcXVpcmUoICcuL2RhdGEuanMnICksXG4gICAgcGVlayA9IHJlcXVpcmUoICcuL3BlZWsuanMnICksXG4gICAgbXVsICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBwaGFzb3I9cmVxdWlyZSggJy4vcGhhc29yLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonY3ljbGUnLFxuXG4gIGluaXRUYWJsZSgpIHsgICAgXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIDEwMjQgKVxuXG4gICAgZm9yKCBsZXQgaSA9IDAsIGwgPSBidWZmZXIubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgYnVmZmVyWyBpIF0gPSBNYXRoLnNpbiggKCBpIC8gbCApICogKCBNYXRoLlBJICogMiApIClcbiAgICB9XG5cbiAgICBnZW4uZ2xvYmFscy5jeWNsZSA9IGRhdGEoIGJ1ZmZlciwgMSwgeyBpbW11dGFibGU6dHJ1ZSB9IClcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBmcmVxdWVuY3k9MSwgcmVzZXQ9MCwgX3Byb3BzICkgPT4ge1xuICBpZiggdHlwZW9mIGdlbi5nbG9iYWxzLmN5Y2xlID09PSAndW5kZWZpbmVkJyApIHByb3RvLmluaXRUYWJsZSgpIFxuICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgbWluOjAgfSwgX3Byb3BzIClcblxuICBjb25zdCB1Z2VuID0gcGVlayggZ2VuLmdsb2JhbHMuY3ljbGUsIHBoYXNvciggZnJlcXVlbmN5LCByZXNldCwgcHJvcHMgKSlcbiAgdWdlbi5uYW1lID0gJ2N5Y2xlJyArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgICB1dGlsaXRpZXMgPSByZXF1aXJlKCAnLi91dGlsaXRpZXMuanMnICksXG4gICAgICBwZWVrID0gcmVxdWlyZSgnLi9wZWVrLmpzJyksXG4gICAgICBwb2tlID0gcmVxdWlyZSgnLi9wb2tlLmpzJylcblxuY29uc3QgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidkYXRhJyxcbiAgZ2xvYmFsczoge30sXG4gIG1lbW86e30sXG5cbiAgZ2VuKCkge1xuICAgIGxldCBpZHhcbiAgICAvL2NvbnNvbGUubG9nKCAnZGF0YSBuYW1lOicsIHRoaXMubmFtZSwgcHJvdG8ubWVtbyApXG4gICAgLy9kZWJ1Z2dlclxuICAgIGlmKCBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGxldCB1Z2VuID0gdGhpc1xuICAgICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5LCB0aGlzLmltbXV0YWJsZSApIFxuICAgICAgaWR4ID0gdGhpcy5tZW1vcnkudmFsdWVzLmlkeFxuICAgICAgaWYoIHRoaXMuYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2VuLm1lbW9yeS5oZWFwLnNldCggdGhpcy5idWZmZXIsIGlkeCApXG4gICAgICAgIH1jYXRjaCggZSApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyggZSApXG4gICAgICAgICAgdGhyb3cgRXJyb3IoICdlcnJvciB3aXRoIHJlcXVlc3QuIGFza2luZyBmb3IgJyArIHRoaXMuYnVmZmVyLmxlbmd0aCArJy4gY3VycmVudCBpbmRleDogJyArIGdlbi5tZW1vcnlJbmRleCArICcgb2YgJyArIGdlbi5tZW1vcnkuaGVhcC5sZW5ndGggKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2dlbi5kYXRhWyB0aGlzLm5hbWUgXSA9IHRoaXNcbiAgICAgIC8vcmV0dXJuICdnZW4ubWVtb3J5JyArIHRoaXMubmFtZSArICcuYnVmZmVyJ1xuICAgICAgaWYoIHRoaXMubmFtZS5pbmRleE9mKCdkYXRhJykgPT09IC0xICkge1xuICAgICAgICBwcm90by5tZW1vWyB0aGlzLm5hbWUgXSA9IGlkeFxuICAgICAgfWVsc2V7XG4gICAgICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGlkeFxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgLy9jb25zb2xlLmxvZyggJ3VzaW5nIGdlbiBkYXRhIG1lbW8nLCBwcm90by5tZW1vWyB0aGlzLm5hbWUgXSApXG4gICAgICBpZHggPSBnZW4ubWVtb1sgdGhpcy5uYW1lIF1cbiAgICB9XG4gICAgcmV0dXJuIGlkeFxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggeCwgeT0xLCBwcm9wZXJ0aWVzICkgPT4ge1xuICBsZXQgdWdlbiwgYnVmZmVyLCBzaG91bGRMb2FkID0gZmFsc2VcbiAgXG4gIGlmKCBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5nbG9iYWwgIT09IHVuZGVmaW5lZCApIHtcbiAgICBpZiggZ2VuLmdsb2JhbHNbIHByb3BlcnRpZXMuZ2xvYmFsIF0gKSB7XG4gICAgICByZXR1cm4gZ2VuLmdsb2JhbHNbIHByb3BlcnRpZXMuZ2xvYmFsIF1cbiAgICB9XG4gIH1cblxuICBpZiggdHlwZW9mIHggPT09ICdudW1iZXInICkge1xuICAgIGlmKCB5ICE9PSAxICkge1xuICAgICAgYnVmZmVyID0gW11cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgeTsgaSsrICkge1xuICAgICAgICBidWZmZXJbIGkgXSA9IG5ldyBGbG9hdDMyQXJyYXkoIHggKVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggeCApXG4gICAgfVxuICB9ZWxzZSBpZiggQXJyYXkuaXNBcnJheSggeCApICkgeyAvLyEgKHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgKSApIHtcbiAgICBsZXQgc2l6ZSA9IHgubGVuZ3RoXG4gICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSApXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrICkge1xuICAgICAgYnVmZmVyWyBpIF0gPSB4WyBpIF1cbiAgICB9XG4gIH1lbHNlIGlmKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKSB7XG4gICAgLy9idWZmZXIgPSB7IGxlbmd0aDogeSA+IDEgPyB5IDogZ2VuLnNhbXBsZXJhdGUgKiA2MCB9IC8vIFhYWCB3aGF0Pz8/XG4gICAgLy9pZiggcHJvdG8ubWVtb1sgeCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBidWZmZXIgPSB7IGxlbmd0aDogeSA+IDEgPyB5IDogMSB9IC8vIFhYWCB3aGF0Pz8/XG4gICAgICBzaG91bGRMb2FkID0gdHJ1ZVxuICAgIC8vfWVsc2V7XG4gICAgICAvL2J1ZmZlciA9IHByb3RvLm1lbW9bIHggXVxuICAgIC8vfVxuICB9ZWxzZSBpZiggeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcbiAgICBidWZmZXIgPSB4XG4gIH1cbiAgXG4gIHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApIFxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIFxuICB7IFxuICAgIGJ1ZmZlcixcbiAgICBuYW1lOiBwcm90by5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKSxcbiAgICBkaW06ICBidWZmZXIgIT09IHVuZGVmaW5lZCA/IGJ1ZmZlci5sZW5ndGggOiAxLCAvLyBYWFggaG93IGRvIHdlIGR5bmFtaWNhbGx5IGFsbG9jYXRlIHRoaXM/XG4gICAgY2hhbm5lbHMgOiAxLFxuICAgIG9ubG9hZDogbnVsbCxcbiAgICAvL3RoZW4oIGZuYyApIHtcbiAgICAvLyAgdWdlbi5vbmxvYWQgPSBmbmNcbiAgICAvLyAgcmV0dXJuIHVnZW5cbiAgICAvL30sXG4gICAgaW1tdXRhYmxlOiBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5pbW11dGFibGUgPT09IHRydWUgPyB0cnVlIDogZmFsc2UsXG4gICAgbG9hZCggZmlsZW5hbWUsIF9fcmVzb2x2ZSApIHtcbiAgICAgIGxldCBwcm9taXNlID0gdXRpbGl0aWVzLmxvYWRTYW1wbGUoIGZpbGVuYW1lLCB1Z2VuIClcbiAgICAgIHByb21pc2UudGhlbiggX2J1ZmZlciA9PiB7IFxuICAgICAgICBwcm90by5tZW1vWyB4IF0gPSBfYnVmZmVyXG4gICAgICAgIHVnZW4ubmFtZSA9IGZpbGVuYW1lXG4gICAgICAgIHVnZW4ubWVtb3J5LnZhbHVlcy5sZW5ndGggPSB1Z2VuLmRpbSA9IF9idWZmZXIubGVuZ3RoXG5cbiAgICAgICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHVnZW4ubWVtb3J5LCB1Z2VuLmltbXV0YWJsZSApIFxuICAgICAgICBnZW4ubWVtb3J5LmhlYXAuc2V0KCBfYnVmZmVyLCB1Z2VuLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgICAgaWYoIHR5cGVvZiB1Z2VuLm9ubG9hZCA9PT0gJ2Z1bmN0aW9uJyApIHVnZW4ub25sb2FkKCBfYnVmZmVyICkgXG4gICAgICAgIF9fcmVzb2x2ZSggdWdlbiApXG4gICAgICB9KVxuICAgIH0sXG4gICAgbWVtb3J5IDoge1xuICAgICAgdmFsdWVzOiB7IGxlbmd0aDpidWZmZXIgIT09IHVuZGVmaW5lZCA/IGJ1ZmZlci5sZW5ndGggOiAxLCBpZHg6bnVsbCB9XG4gICAgfVxuICB9LFxuICBwcm9wZXJ0aWVzXG4gIClcblxuICBcbiAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCApIHtcbiAgICBpZiggcHJvcGVydGllcy5nbG9iYWwgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGdlbi5nbG9iYWxzWyBwcm9wZXJ0aWVzLmdsb2JhbCBdID0gdWdlblxuICAgIH1cbiAgICBpZiggcHJvcGVydGllcy5tZXRhID09PSB0cnVlICkge1xuICAgICAgZm9yKCBsZXQgaSA9IDAsIGxlbmd0aCA9IHVnZW4uYnVmZmVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sIGksIHtcbiAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBlZWsoIHVnZW4sIGksIHsgbW9kZTonc2ltcGxlJywgaW50ZXJwOidub25lJyB9IClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICAgIHJldHVybiBwb2tlKCB1Z2VuLCB2LCBpIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJldHVyblZhbHVlXG4gIGlmKCBzaG91bGRMb2FkID09PSB0cnVlICkge1xuICAgIHJldHVyblZhbHVlID0gbmV3IFByb21pc2UoIChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICAgICAgLy91Z2VuLmxvYWQoIHgsIHJlc29sdmUgKVxuICAgICAgbGV0IHByb21pc2UgPSB1dGlsaXRpZXMubG9hZFNhbXBsZSggeCwgdWdlbiApXG4gICAgICBwcm9taXNlLnRoZW4oIF9idWZmZXIgPT4geyBcbiAgICAgICAgcHJvdG8ubWVtb1sgeCBdID0gX2J1ZmZlclxuICAgICAgICB1Z2VuLm1lbW9yeS52YWx1ZXMubGVuZ3RoID0gdWdlbi5kaW0gPSBfYnVmZmVyLmxlbmd0aFxuXG4gICAgICAgIHVnZW4uYnVmZmVyID0gX2J1ZmZlclxuICAgICAgICAvL2dlbi5vbmNlKCAnbWVtb3J5IGluaXQnLCAoKT0+IHtcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKCBcIkNBTExFRFwiLCB1Z2VuLm1lbW9yeSApXG4gICAgICAgIC8vICBnZW4ucmVxdWVzdE1lbW9yeSggdWdlbi5tZW1vcnksIHVnZW4uaW1tdXRhYmxlICkgXG4gICAgICAgIC8vICBnZW4ubWVtb3J5LmhlYXAuc2V0KCBfYnVmZmVyLCB1Z2VuLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgICAgLy8gIGlmKCB0eXBlb2YgdWdlbi5vbmxvYWQgPT09ICdmdW5jdGlvbicgKSB1Z2VuLm9ubG9hZCggX2J1ZmZlciApIFxuICAgICAgICAvL30pXG4gICAgICAgIFxuICAgICAgICByZXNvbHZlKCB1Z2VuIClcbiAgICAgIH0pICAgICBcbiAgICB9KVxuICB9ZWxzZSBpZiggcHJvdG8ubWVtb1sgeCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBnZW4ub25jZSggJ21lbW9yeSBpbml0JywgKCk9PiB7XG4gICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdWdlbi5tZW1vcnksIHVnZW4uaW1tdXRhYmxlICkgXG4gICAgICBnZW4ubWVtb3J5LmhlYXAuc2V0KCB1Z2VuLmJ1ZmZlciwgdWdlbi5tZW1vcnkudmFsdWVzLmlkeCApXG4gICAgICBpZiggdHlwZW9mIHVnZW4ub25sb2FkID09PSAnZnVuY3Rpb24nICkgdWdlbi5vbmxvYWQoIHVnZW4uYnVmZmVyICkgXG4gICAgfSlcblxuICAgIHJldHVyblZhbHVlID0gdWdlblxuICB9ZWxzZXtcbiAgICByZXR1cm5WYWx1ZSA9IHVnZW5cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZSBcbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGhpc3RvcnkgPSByZXF1aXJlKCAnLi9oaXN0b3J5LmpzJyApLFxuICAgIHN1YiAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnICksXG4gICAgYWRkICAgICA9IHJlcXVpcmUoICcuL2FkZC5qcycgKSxcbiAgICBtdWwgICAgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIG1lbW8gICAgPSByZXF1aXJlKCAnLi9tZW1vLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEgKSA9PiB7XG4gIGxldCB4MSA9IGhpc3RvcnkoKSxcbiAgICAgIHkxID0gaGlzdG9yeSgpLFxuICAgICAgZmlsdGVyXG5cbiAgLy9IaXN0b3J5IHgxLCB5MTsgeSA9IGluMSAtIHgxICsgeTEqMC45OTk3OyB4MSA9IGluMTsgeTEgPSB5OyBvdXQxID0geTtcbiAgZmlsdGVyID0gbWVtbyggYWRkKCBzdWIoIGluMSwgeDEub3V0ICksIG11bCggeTEub3V0LCAuOTk5NyApICkgKVxuICB4MS5pbiggaW4xIClcbiAgeTEuaW4oIGZpbHRlciApXG5cbiAgcmV0dXJuIGZpbHRlclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGhpc3RvcnkgPSByZXF1aXJlKCAnLi9oaXN0b3J5LmpzJyApLFxuICAgIG11bCAgICAgPSByZXF1aXJlKCAnLi9tdWwuanMnICksXG4gICAgdDYwICAgICA9IHJlcXVpcmUoICcuL3Q2MC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggZGVjYXlUaW1lID0gNDQxMDAsIHByb3BzICkgPT4ge1xuICBsZXQgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHsgaW5pdFZhbHVlOjEgfSwgcHJvcHMgKSxcbiAgICAgIHNzZCA9IGhpc3RvcnkgKCBwcm9wZXJ0aWVzLmluaXRWYWx1ZSApXG5cbiAgc3NkLmluKCBtdWwoIHNzZC5vdXQsIHQ2MCggZGVjYXlUaW1lICkgKSApXG5cbiAgc3NkLm91dC50cmlnZ2VyID0gKCk9PiB7XG4gICAgc3NkLnZhbHVlID0gMVxuICB9XG5cbiAgcmV0dXJuIHNzZC5vdXQgXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZ2VuICA9IHJlcXVpcmUoICcuL2dlbi5qcycgICksXG4gICAgICBkYXRhID0gcmVxdWlyZSggJy4vZGF0YS5qcycgKSxcbiAgICAgIHBva2UgPSByZXF1aXJlKCAnLi9wb2tlLmpzJyApLFxuICAgICAgcGVlayA9IHJlcXVpcmUoICcuL3BlZWsuanMnICksXG4gICAgICBzdWIgID0gcmVxdWlyZSggJy4vc3ViLmpzJyAgKSxcbiAgICAgIHdyYXAgPSByZXF1aXJlKCAnLi93cmFwLmpzJyApLFxuICAgICAgYWNjdW09IHJlcXVpcmUoICcuL2FjY3VtLmpzJyksXG4gICAgICBtZW1vID0gcmVxdWlyZSggJy4vbWVtby5qcycgKVxuXG5jb25zdCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2RlbGF5JyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGlucHV0c1swXVxuICAgIFxuICAgIHJldHVybiBpbnB1dHNbMF1cbiAgfSxcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7IHNpemU6IDUxMiwgaW50ZXJwOidub25lJyB9XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIHRhcHMsIHByb3BlcnRpZXMgKSA9PiB7XG4gIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIGxldCB3cml0ZUlkeCwgcmVhZElkeCwgZGVsYXlkYXRhXG5cbiAgaWYoIEFycmF5LmlzQXJyYXkoIHRhcHMgKSA9PT0gZmFsc2UgKSB0YXBzID0gWyB0YXBzIF1cbiAgXG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRzLCBwcm9wZXJ0aWVzIClcblxuICBjb25zdCBtYXhUYXBTaXplID0gTWF0aC5tYXgoIC4uLnRhcHMgKVxuICBpZiggcHJvcHMuc2l6ZSA8IG1heFRhcFNpemUgKSBwcm9wcy5zaXplID0gbWF4VGFwU2l6ZVxuXG4gIGRlbGF5ZGF0YSA9IGRhdGEoIHByb3BzLnNpemUgKVxuICBcbiAgdWdlbi5pbnB1dHMgPSBbXVxuXG4gIHdyaXRlSWR4ID0gYWNjdW0oIDEsIDAsIHsgbWF4OnByb3BzLnNpemUsIG1pbjowIH0pXG4gIFxuICBmb3IoIGxldCBpID0gMDsgaSA8IHRhcHMubGVuZ3RoOyBpKysgKSB7XG4gICAgdWdlbi5pbnB1dHNbIGkgXSA9IHBlZWsoIGRlbGF5ZGF0YSwgd3JhcCggc3ViKCB3cml0ZUlkeCwgdGFwc1tpXSApLCAwLCBwcm9wcy5zaXplICkseyBtb2RlOidzYW1wbGVzJywgaW50ZXJwOnByb3BzLmludGVycCB9KVxuICB9XG4gIFxuICB1Z2VuLm91dHB1dHMgPSB1Z2VuLmlucHV0cyAvLyBYWFggdWdoLCBVZ2gsIFVHSCEgYnV0IGkgZ3Vlc3MgaXQgd29ya3MuXG5cbiAgcG9rZSggZGVsYXlkYXRhLCBpbjEsIHdyaXRlSWR4IClcblxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7Z2VuLmdldFVJRCgpfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGhpc3RvcnkgPSByZXF1aXJlKCAnLi9oaXN0b3J5LmpzJyApLFxuICAgIHN1YiAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSApID0+IHtcbiAgbGV0IG4xID0gaGlzdG9yeSgpXG4gICAgXG4gIG4xLmluKCBpbjEgKVxuXG4gIGxldCB1Z2VuID0gc3ViKCBpbjEsIG4xLm91dCApXG4gIHVnZW4ubmFtZSA9ICdkZWx0YScrZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5jb25zdCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2RpdicsXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXQ9YCAgdmFyICR7dGhpcy5uYW1lfSA9IGAsXG4gICAgICAgIGRpZmYgPSAwLCBcbiAgICAgICAgbnVtQ291bnQgPSAwLFxuICAgICAgICBsYXN0TnVtYmVyID0gaW5wdXRzWyAwIF0sXG4gICAgICAgIGxhc3ROdW1iZXJJc1VnZW4gPSBpc05hTiggbGFzdE51bWJlciApLCBcbiAgICAgICAgZGl2QXRFbmQgPSBmYWxzZVxuXG4gICAgaW5wdXRzLmZvckVhY2goICh2LGkpID0+IHtcbiAgICAgIGlmKCBpID09PSAwICkgcmV0dXJuXG5cbiAgICAgIGxldCBpc051bWJlclVnZW4gPSBpc05hTiggdiApLFxuICAgICAgICBpc0ZpbmFsSWR4ICAgPSBpID09PSBpbnB1dHMubGVuZ3RoIC0gMVxuXG4gICAgICBpZiggIWxhc3ROdW1iZXJJc1VnZW4gJiYgIWlzTnVtYmVyVWdlbiApIHtcbiAgICAgICAgbGFzdE51bWJlciA9IGxhc3ROdW1iZXIgLyB2XG4gICAgICAgIG91dCArPSBsYXN0TnVtYmVyXG4gICAgICB9ZWxzZXtcbiAgICAgICAgb3V0ICs9IGAke2xhc3ROdW1iZXJ9IC8gJHt2fWBcbiAgICAgIH1cblxuICAgICAgaWYoICFpc0ZpbmFsSWR4ICkgb3V0ICs9ICcgLyAnIFxuICAgIH0pXG5cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgZGl2ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBcbiAgT2JqZWN0LmFzc2lnbiggZGl2LCB7XG4gICAgaWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBhcmdzLFxuICB9KVxuXG4gIGRpdi5uYW1lID0gZGl2LmJhc2VuYW1lICsgZGl2LmlkXG4gIFxuICByZXR1cm4gZGl2XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4nICksXG4gICAgd2luZG93cyA9IHJlcXVpcmUoICcuL3dpbmRvd3MnICksXG4gICAgZGF0YSAgICA9IHJlcXVpcmUoICcuL2RhdGEnICksXG4gICAgcGVlayAgICA9IHJlcXVpcmUoICcuL3BlZWsnICksXG4gICAgcGhhc29yICA9IHJlcXVpcmUoICcuL3BoYXNvcicgKSxcbiAgICBkZWZhdWx0cyA9IHtcbiAgICAgIHR5cGU6J3RyaWFuZ3VsYXInLCBsZW5ndGg6MTAyNCwgYWxwaGE6LjE1LCBzaGlmdDowLCByZXZlcnNlOmZhbHNlIFxuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wcyA9PiB7XG4gIFxuICBsZXQgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0cywgcHJvcHMgKVxuICBsZXQgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggcHJvcGVydGllcy5sZW5ndGggKVxuXG4gIGxldCBuYW1lID0gcHJvcGVydGllcy50eXBlICsgJ18nICsgcHJvcGVydGllcy5sZW5ndGggKyAnXycgKyBwcm9wZXJ0aWVzLnNoaWZ0ICsgJ18nICsgcHJvcGVydGllcy5yZXZlcnNlICsgJ18nICsgcHJvcGVydGllcy5hbHBoYVxuICBpZiggdHlwZW9mIGdlbi5nbG9iYWxzLndpbmRvd3NbIG5hbWUgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7IFxuXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgYnVmZmVyWyBpIF0gPSB3aW5kb3dzWyBwcm9wZXJ0aWVzLnR5cGUgXSggcHJvcGVydGllcy5sZW5ndGgsIGksIHByb3BlcnRpZXMuYWxwaGEsIHByb3BlcnRpZXMuc2hpZnQgKVxuICAgIH1cblxuICAgIGlmKCBwcm9wZXJ0aWVzLnJldmVyc2UgPT09IHRydWUgKSB7IFxuICAgICAgYnVmZmVyLnJldmVyc2UoKVxuICAgIH1cbiAgICBnZW4uZ2xvYmFscy53aW5kb3dzWyBuYW1lIF0gPSBkYXRhKCBidWZmZXIgKVxuICB9XG5cbiAgbGV0IHVnZW4gPSBnZW4uZ2xvYmFscy53aW5kb3dzWyBuYW1lIF0gXG4gIHVnZW4ubmFtZSA9ICdlbnYnICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2VxJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSwgb3V0XG5cbiAgICBvdXQgPSB0aGlzLmlucHV0c1swXSA9PT0gdGhpcy5pbnB1dHNbMV0gPyAxIDogYCAgdmFyICR7dGhpcy5uYW1lfSA9ICgke2lucHV0c1swXX0gPT09ICR7aW5wdXRzWzFdfSkgfCAwXFxuXFxuYFxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gYCR7dGhpcy5uYW1lfWBcblxuICAgIHJldHVybiBbIGAke3RoaXMubmFtZX1gLCBvdXQgXVxuICB9LFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIGluMiApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBpbjEsIGluMiBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2V4cCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGguZXhwJyA6IE1hdGguZXhwIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1leHAoICR7aW5wdXRzWzBdfSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguZXhwKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgZXhwID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGV4cC5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBleHBcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90XG4gKiB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyXG4gKiB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBvcmlnaW5hbGx5IGZyb206XG4vLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9hdWRpb3dvcmtsZXQtcG9seWZpbGxcbi8vIEkgYW0gbW9kaWZ5aW5nIGl0IHRvIGFjY2VwdCB2YXJpYWJsZSBidWZmZXIgc2l6ZXNcbi8vIGFuZCB0byBnZXQgcmlkIG9mIHNvbWUgc3RyYW5nZSBnbG9iYWwgaW5pdGlhbGl6YXRpb24gdGhhdCBzZWVtcyByZXF1aXJlZCB0byB1c2UgaXRcbi8vIHdpdGggYnJvd3NlcmlmeS4gQWxzbywgSSBhZGRlZCBjaGFuZ2VzIHRvIGZpeCBhIGJ1ZyBpbiBTYWZhcmkgZm9yIHRoZSBBdWRpb1dvcmtsZXRQcm9jZXNzb3Jcbi8vIHByb3BlcnR5IG5vdCBoYXZpbmcgYSBwcm90b3R5cGUgKHNlZTpodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9hdWRpb3dvcmtsZXQtcG9seWZpbGwvcHVsbC8yNSlcbi8vIFRPRE86IFdoeSBpcyB0aGVyZSBhbiBpZnJhbWUgaW52b2x2ZWQ/IChyZWFsbS5qcylcblxuY29uc3QgUmVhbG0gPSByZXF1aXJlKCAnLi9yZWFsbS5qcycgKVxuXG5jb25zdCBBV1BGID0gZnVuY3Rpb24oIHNlbGYgPSB3aW5kb3csIGJ1ZmZlclNpemUgPSA0MDk2ICkge1xuICBjb25zdCBQQVJBTVMgPSBbXVxuICBsZXQgbmV4dFBvcnRcblxuICBpZiAodHlwZW9mIEF1ZGlvV29ya2xldE5vZGUgIT09ICdmdW5jdGlvbicgfHwgIShcImF1ZGlvV29ya2xldFwiIGluIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUpKSB7XG4gICAgc2VsZi5BdWRpb1dvcmtsZXROb2RlID0gZnVuY3Rpb24gQXVkaW9Xb3JrbGV0Tm9kZSAoY29udGV4dCwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgcHJvY2Vzc29yID0gZ2V0UHJvY2Vzc29yc0ZvckNvbnRleHQoY29udGV4dClbbmFtZV07XG4gICAgICBjb25zdCBvdXRwdXRDaGFubmVscyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQgPyBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudFswXSA6IDI7XG4gICAgICBjb25zdCBzY3JpcHRQcm9jZXNzb3IgPSBjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvciggYnVmZmVyU2l6ZSwgMiwgb3V0cHV0Q2hhbm5lbHMpO1xuXG4gICAgICBzY3JpcHRQcm9jZXNzb3IucGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChwcm9jZXNzb3IucHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2Nlc3Nvci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IHByb2Nlc3Nvci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKS5nYWluO1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBwcm9wLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAvLyBAVE9ETyB0aGVyZSdzIG5vIGdvb2Qgd2F5IHRvIGNvbnN0cnVjdCB0aGUgcHJveHkgQXVkaW9QYXJhbSBoZXJlXG4gICAgICAgICAgc2NyaXB0UHJvY2Vzc29yLnBhcmFtZXRlcnMuc2V0KHByb3AubmFtZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbWMgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIG5leHRQb3J0ID0gbWMucG9ydDI7XG4gICAgICBjb25zdCBpbnN0ID0gbmV3IHByb2Nlc3Nvci5Qcm9jZXNzb3Iob3B0aW9ucyB8fCB7fSk7XG4gICAgICBuZXh0UG9ydCA9IG51bGw7XG5cbiAgICAgIHNjcmlwdFByb2Nlc3Nvci5wb3J0ID0gbWMucG9ydDE7XG4gICAgICBzY3JpcHRQcm9jZXNzb3IucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgc2NyaXB0UHJvY2Vzc29yLmluc3RhbmNlID0gaW5zdDtcbiAgICAgIHNjcmlwdFByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IG9uQXVkaW9Qcm9jZXNzO1xuICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3NvcjtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KChzZWxmLkF1ZGlvQ29udGV4dCB8fCBzZWxmLndlYmtpdEF1ZGlvQ29udGV4dCkucHJvdG90eXBlLCAnYXVkaW9Xb3JrbGV0Jywge1xuICAgICAgZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCRhdWRpb1dvcmtsZXQgfHwgKHRoaXMuJCRhdWRpb1dvcmtsZXQgPSBuZXcgc2VsZi5BdWRpb1dvcmtsZXQodGhpcykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogWFhYIC0gQURERUQgVE8gT1ZFUkNPTUUgUFJPQkxFTSBJTiBTQUZBUkkgV0hFUkUgQVVESU9XT1JLTEVUUFJPQ0VTU09SIFBST1RPVFlQRSBJUyBOT1QgQU4gT0JKRUNUICovXG4gICAgY29uc3QgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBvcnQgPSBuZXh0UG9ydFxuICAgIH1cbiAgICBBdWRpb1dvcmtsZXRQcm9jZXNzb3IucHJvdG90eXBlID0ge31cblxuICAgIHNlbGYuQXVkaW9Xb3JrbGV0ID0gY2xhc3MgQXVkaW9Xb3JrbGV0IHtcbiAgICAgIGNvbnN0cnVjdG9yIChhdWRpb0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy4kJGNvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIGFkZE1vZHVsZSAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4ociA9PiB7XG4gICAgICAgICAgaWYgKCFyLm9rKSB0aHJvdyBFcnJvcihyLnN0YXR1cyk7XG4gICAgICAgICAgcmV0dXJuIHIudGV4dCgpO1xuICAgICAgICB9KS50aGVuKCBjb2RlID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy4kJGNvbnRleHQuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aGlzLiQkY29udGV4dC5jdXJyZW50VGltZSxcbiAgICAgICAgICAgIEF1ZGlvV29ya2xldFByb2Nlc3NvcixcbiAgICAgICAgICAgIHJlZ2lzdGVyUHJvY2Vzc29yOiAobmFtZSwgUHJvY2Vzc29yKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvcnMgPSBnZXRQcm9jZXNzb3JzRm9yQ29udGV4dCh0aGlzLiQkY29udGV4dCk7XG4gICAgICAgICAgICAgIHByb2Nlc3NvcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgcmVhbG0sXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBQcm9jZXNzb3IsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogUHJvY2Vzc29yLnBhcmFtZXRlckRlc2NyaXB0b3JzIHx8IFtdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnRleHQuc2VsZiA9IGNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgcmVhbG0gPSBuZXcgUmVhbG0oY29udGV4dCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICByZWFsbS5leGVjKCgob3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zcGlsZSkgfHwgU3RyaW5nKShjb2RlKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBvbkF1ZGlvUHJvY2VzcyAoZSkge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICB0aGlzLnBhcmFtZXRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgYXJyID0gUEFSQU1TWysraW5kZXhdIHx8IChQQVJBTVNbaW5kZXhdID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJ1ZmZlclNpemUpKTtcbiAgICAgIC8vIEBUT0RPIHByb3BlciB2YWx1ZXMgaGVyZSBpZiBwb3NzaWJsZVxuICAgICAgYXJyLmZpbGwodmFsdWUudmFsdWUpO1xuICAgICAgcGFyYW1ldGVyc1trZXldID0gYXJyO1xuICAgIH0pO1xuICAgIHRoaXMucHJvY2Vzc29yLnJlYWxtLmV4ZWMoXG4gICAgICAnc2VsZi5zYW1wbGVSYXRlPXNhbXBsZVJhdGU9JyArIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICsgJzsnICtcbiAgICAgICdzZWxmLmN1cnJlbnRUaW1lPWN1cnJlbnRUaW1lPScgKyB0aGlzLmNvbnRleHQuY3VycmVudFRpbWVcbiAgICApO1xuICAgIGNvbnN0IGlucHV0cyA9IGNoYW5uZWxUb0FycmF5KGUuaW5wdXRCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dHMgPSBjaGFubmVsVG9BcnJheShlLm91dHB1dEJ1ZmZlcik7XG4gICAgdGhpcy5pbnN0YW5jZS5wcm9jZXNzKFtpbnB1dHNdLCBbb3V0cHV0c10sIHBhcmFtZXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbm5lbFRvQXJyYXkgKGNoKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaC5udW1iZXJPZkNoYW5uZWxzOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGNoLmdldENoYW5uZWxEYXRhKGkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJvY2Vzc29yc0ZvckNvbnRleHQgKGF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybiBhdWRpb0NvbnRleHQuJCRwcm9jZXNzb3JzIHx8IChhdWRpb0NvbnRleHQuJCRwcm9jZXNzb3JzID0ge30pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQVdQRlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mXG4gKiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVRcbiAqIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZVxuICogTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXJcbiAqIHRoZSBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVhbG0gKHNjb3BlLCBwYXJlbnRFbGVtZW50KSB7XG4gIGNvbnN0IGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGZyYW1lLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDotOTk5cHg7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChmcmFtZSk7XG4gIGNvbnN0IHdpbiA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgbGV0IHZhcnMgPSAndmFyIHdpbmRvdywkaG9vayc7XG4gIGZvciAoY29uc3QgaSBpbiB3aW4pIHtcbiAgICBpZiAoIShpIGluIHNjb3BlKSAmJiBpICE9PSAnZXZhbCcpIHtcbiAgICAgIHZhcnMgKz0gJywnO1xuICAgICAgdmFycyArPSBpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gc2NvcGUpIHtcbiAgICB2YXJzICs9ICcsJztcbiAgICB2YXJzICs9IGk7XG4gICAgdmFycyArPSAnPXNlbGYuJztcbiAgICB2YXJzICs9IGk7XG4gIH1cbiAgY29uc3Qgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKFxuICAgIGBmdW5jdGlvbiAkaG9vayhzZWxmLGNvbnNvbGUpIHtcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgJHt2YXJzfTtyZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIGV2YWwoYXJndW1lbnRzWzBdKX19YFxuICApKTtcbiAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgdGhpcy5leGVjID0gd2luLiRob29rLmNhbGwoc2NvcGUsIHNjb3BlLCBjb25zb2xlKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidmbG9vcicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIC8vZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IE1hdGguZmxvb3IgfSlcblxuICAgICAgb3V0ID0gYCggJHtpbnB1dHNbMF19IHwgMCApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IGlucHV0c1swXSB8IDBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBmbG9vciA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBmbG9vci5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBmbG9vclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidmb2xkJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGNvZGUsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgb3V0XG5cbiAgICBvdXQgPSB0aGlzLmNyZWF0ZUNhbGxiYWNrKCBpbnB1dHNbMF0sIHRoaXMubWluLCB0aGlzLm1heCApIFxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lICsgJ192YWx1ZSdcblxuICAgIHJldHVybiBbIHRoaXMubmFtZSArICdfdmFsdWUnLCBvdXQgXVxuICB9LFxuXG4gIGNyZWF0ZUNhbGxiYWNrKCB2LCBsbywgaGkgKSB7XG4gICAgbGV0IG91dCA9XG5gIHZhciAke3RoaXMubmFtZX1fdmFsdWUgPSAke3Z9LFxuICAgICAgJHt0aGlzLm5hbWV9X3JhbmdlID0gJHtoaX0gLSAke2xvfSxcbiAgICAgICR7dGhpcy5uYW1lfV9udW1XcmFwcyA9IDBcblxuICBpZigke3RoaXMubmFtZX1fdmFsdWUgPj0gJHtoaX0pe1xuICAgICR7dGhpcy5uYW1lfV92YWx1ZSAtPSAke3RoaXMubmFtZX1fcmFuZ2VcbiAgICBpZigke3RoaXMubmFtZX1fdmFsdWUgPj0gJHtoaX0pe1xuICAgICAgJHt0aGlzLm5hbWV9X251bVdyYXBzID0gKCgke3RoaXMubmFtZX1fdmFsdWUgLSAke2xvfSkgLyAke3RoaXMubmFtZX1fcmFuZ2UpIHwgMFxuICAgICAgJHt0aGlzLm5hbWV9X3ZhbHVlIC09ICR7dGhpcy5uYW1lfV9yYW5nZSAqICR7dGhpcy5uYW1lfV9udW1XcmFwc1xuICAgIH1cbiAgICAke3RoaXMubmFtZX1fbnVtV3JhcHMrK1xuICB9IGVsc2UgaWYoJHt0aGlzLm5hbWV9X3ZhbHVlIDwgJHtsb30pe1xuICAgICR7dGhpcy5uYW1lfV92YWx1ZSArPSAke3RoaXMubmFtZX1fcmFuZ2VcbiAgICBpZigke3RoaXMubmFtZX1fdmFsdWUgPCAke2xvfSl7XG4gICAgICAke3RoaXMubmFtZX1fbnVtV3JhcHMgPSAoKCR7dGhpcy5uYW1lfV92YWx1ZSAtICR7bG99KSAvICR7dGhpcy5uYW1lfV9yYW5nZS0gMSkgfCAwXG4gICAgICAke3RoaXMubmFtZX1fdmFsdWUgLT0gJHt0aGlzLm5hbWV9X3JhbmdlICogJHt0aGlzLm5hbWV9X251bVdyYXBzXG4gICAgfVxuICAgICR7dGhpcy5uYW1lfV9udW1XcmFwcy0tXG4gIH1cbiAgaWYoJHt0aGlzLm5hbWV9X251bVdyYXBzICYgMSkgJHt0aGlzLm5hbWV9X3ZhbHVlID0gJHtoaX0gKyAke2xvfSAtICR7dGhpcy5uYW1lfV92YWx1ZVxuYFxuICAgIHJldHVybiAnICcgKyBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xLCBtaW49MCwgbWF4PTEgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgbWluLCBcbiAgICBtYXgsXG4gICAgdWlkOiAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBbIGluMSBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonZ2F0ZScsXG4gIGNvbnRyb2xTdHJpbmc6bnVsbCwgLy8gaW5zZXJ0IGludG8gb3V0cHV0IGNvZGVnZW4gZm9yIGRldGVybWluaW5nIGluZGV4aW5nXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcbiAgICBcbiAgICBnZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5tZW1vcnkgKVxuICAgIFxuICAgIGxldCBsYXN0SW5wdXRNZW1vcnlJZHggPSAnbWVtb3J5WyAnICsgdGhpcy5tZW1vcnkubGFzdElucHV0LmlkeCArICcgXScsXG4gICAgICAgIG91dHB1dE1lbW9yeVN0YXJ0SWR4ID0gdGhpcy5tZW1vcnkubGFzdElucHV0LmlkeCArIDEsXG4gICAgICAgIGlucHV0U2lnbmFsID0gaW5wdXRzWzBdLFxuICAgICAgICBjb250cm9sU2lnbmFsID0gaW5wdXRzWzFdXG4gICAgXG4gICAgLyogXG4gICAgICogd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IGNvbnRyb2wgaW5wdXRzIGVxdWFscyBvdXIgbGFzdCBpbnB1dFxuICAgICAqIGlmIHNvLCB3ZSBzdG9yZSB0aGUgc2lnbmFsIGlucHV0IGluIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHlcbiAgICAgKiBzZWxlY3RlZCBpbmRleC4gSWYgbm90LCB3ZSBwdXQgMCBpbiB0aGUgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFzdCBzZWxlY3RlZCBpbmRleCxcbiAgICAgKiBjaGFuZ2UgdGhlIHNlbGVjdGVkIGluZGV4LCBhbmQgdGhlbiBzdG9yZSB0aGUgc2lnbmFsIGluIHB1dCBpbiB0aGUgbWVtZXJ5IGFzc29pY2F0ZWRcbiAgICAgKiB3aXRoIHRoZSBuZXdseSBzZWxlY3RlZCBpbmRleFxuICAgICAqL1xuICAgIFxuICAgIG91dCA9XG5cbmAgaWYoICR7Y29udHJvbFNpZ25hbH0gIT09ICR7bGFzdElucHV0TWVtb3J5SWR4fSApIHtcbiAgICBtZW1vcnlbICR7bGFzdElucHV0TWVtb3J5SWR4fSArICR7b3V0cHV0TWVtb3J5U3RhcnRJZHh9ICBdID0gMCBcbiAgICAke2xhc3RJbnB1dE1lbW9yeUlkeH0gPSAke2NvbnRyb2xTaWduYWx9XG4gIH1cbiAgbWVtb3J5WyAke291dHB1dE1lbW9yeVN0YXJ0SWR4fSArICR7Y29udHJvbFNpZ25hbH0gXSA9ICR7aW5wdXRTaWduYWx9XG5cbmBcbiAgICB0aGlzLmNvbnRyb2xTdHJpbmcgPSBpbnB1dHNbMV1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZVxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICB0aGlzLm91dHB1dHMuZm9yRWFjaCggdiA9PiB2LmdlbigpIClcblxuICAgIHJldHVybiBbIG51bGwsICcgJyArIG91dCBdXG4gIH0sXG5cbiAgY2hpbGRnZW4oKSB7XG4gICAgaWYoIHRoaXMucGFyZW50LmluaXRpYWxpemVkID09PSBmYWxzZSApIHtcbiAgICAgIGdlbi5nZXRJbnB1dHMoIHRoaXMgKSAvLyBwYXJlbnQgZ2F0ZSBpcyBvbmx5IGlucHV0IG9mIGEgZ2F0ZSBvdXRwdXQsIHNob3VsZCBvbmx5IGJlIGdlbidkIG9uY2UuXG4gICAgfVxuXG4gICAgaWYoIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcblxuICAgICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gYG1lbW9yeVsgJHt0aGlzLm1lbW9yeS52YWx1ZS5pZHh9IF1gXG4gICAgfVxuICAgIFxuICAgIHJldHVybiAgYG1lbW9yeVsgJHt0aGlzLm1lbW9yeS52YWx1ZS5pZHh9IF1gXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGNvbnRyb2wsIGluMSwgcHJvcGVydGllcyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgZGVmYXVsdHMgPSB7IGNvdW50OiAyIH1cblxuICBpZiggdHlwZW9mIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCApIE9iamVjdC5hc3NpZ24oIGRlZmF1bHRzLCBwcm9wZXJ0aWVzIClcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7XG4gICAgb3V0cHV0czogW10sXG4gICAgdWlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogIFsgaW4xLCBjb250cm9sIF0sXG4gICAgbWVtb3J5OiB7XG4gICAgICBsYXN0SW5wdXQ6IHsgbGVuZ3RoOjEsIGlkeDpudWxsIH1cbiAgICB9LFxuICAgIGluaXRpYWxpemVkOmZhbHNlXG4gIH0sXG4gIGRlZmF1bHRzIClcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHtnZW4uZ2V0VUlEKCl9YFxuXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgdWdlbi5jb3VudDsgaSsrICkge1xuICAgIHVnZW4ub3V0cHV0cy5wdXNoKHtcbiAgICAgIGluZGV4OmksXG4gICAgICBnZW46IHByb3RvLmNoaWxkZ2VuLFxuICAgICAgcGFyZW50OnVnZW4sXG4gICAgICBpbnB1dHM6IFsgdWdlbiBdLFxuICAgICAgbWVtb3J5OiB7XG4gICAgICAgIHZhbHVlOiB7IGxlbmd0aDoxLCBpZHg6bnVsbCB9XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZWQ6ZmFsc2UsXG4gICAgICBuYW1lOiBgJHt1Z2VuLm5hbWV9X291dCR7Z2VuLmdldFVJRCgpfWBcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiBnZW4uanNcbiAqXG4gKiBsb3ctbGV2ZWwgY29kZSBnZW5lcmF0aW9uIGZvciB1bml0IGdlbmVyYXRvcnNcbiAqXG4gKi9cbmNvbnN0IE1lbW9yeUhlbHBlciA9IHJlcXVpcmUoICdtZW1vcnktaGVscGVyJyApXG5jb25zdCBFRSA9IHJlcXVpcmUoICdldmVudHMnICkuRXZlbnRFbWl0dGVyXG5cbmNvbnN0IGdlbiA9IHtcblxuICBhY2N1bTowLFxuICBnZXRVSUQoKSB7IHJldHVybiB0aGlzLmFjY3VtKysgfSxcbiAgZGVidWc6ZmFsc2UsXG4gIHNhbXBsZXJhdGU6IDQ0MTAwLCAvLyBjaGFuZ2Ugb24gYXVkaW9jb250ZXh0IGNyZWF0aW9uXG4gIHNob3VsZExvY2FsaXplOiBmYWxzZSxcbiAgZ3JhcGg6bnVsbCxcbiAgZ2xvYmFsczp7XG4gICAgd2luZG93czoge30sXG4gIH0sXG4gIG1vZGU6J3dvcmtsZXQnLFxuICBcbiAgLyogY2xvc3VyZXNcbiAgICpcbiAgICogRnVuY3Rpb25zIHRoYXQgYXJlIGluY2x1ZGVkIGFzIGFyZ3VtZW50cyB0byBtYXN0ZXIgY2FsbGJhY2suIEV4YW1wbGVzOiBNYXRoLmFicywgTWF0aC5yYW5kb20gZXRjLlxuICAgKiBYWFggU2hvdWxkIHByb2JhYmx5IGJlIHJlbmFtZWQgY2FsbGJhY2tQcm9wZXJ0aWVzIG9yIHNvbWV0aGluZyBzaW1pbGFyLi4uIGNsb3N1cmVzIGFyZSBubyBsb25nZXIgdXNlZC5cbiAgICovXG5cbiAgY2xvc3VyZXM6IG5ldyBTZXQoKSxcbiAgcGFyYW1zOiAgIG5ldyBTZXQoKSxcbiAgaW5wdXRzOiAgIG5ldyBTZXQoKSxcblxuICBwYXJhbWV0ZXJzOiBuZXcgU2V0KCksXG4gIGVuZEJsb2NrOiBuZXcgU2V0KCksXG4gIGhpc3RvcmllczogbmV3IE1hcCgpLFxuXG4gIG1lbW86IHt9LFxuXG4gIC8vZGF0YToge30sXG4gIFxuICAvKiBleHBvcnRcbiAgICpcbiAgICogcGxhY2UgZ2VuIGZ1bmN0aW9ucyBpbnRvIGFub3RoZXIgb2JqZWN0IGZvciBlYXNpZXIgcmVmZXJlbmNlXG4gICAqL1xuXG4gIGV4cG9ydCggb2JqICkge30sXG5cbiAgYWRkVG9FbmRCbG9jayggdiApIHtcbiAgICB0aGlzLmVuZEJsb2NrLmFkZCggJyAgJyArIHYgKVxuICB9LFxuICBcbiAgcmVxdWVzdE1lbW9yeSggbWVtb3J5U3BlYywgaW1tdXRhYmxlPWZhbHNlICkge1xuICAgIGZvciggbGV0IGtleSBpbiBtZW1vcnlTcGVjICkge1xuICAgICAgbGV0IHJlcXVlc3QgPSBtZW1vcnlTcGVjWyBrZXkgXVxuXG4gICAgICAvL2NvbnNvbGUubG9nKCAncmVxdWVzdGluZyAnICsga2V5ICsgJzonICwgSlNPTi5zdHJpbmdpZnkoIHJlcXVlc3QgKSApXG5cbiAgICAgIGlmKCByZXF1ZXN0Lmxlbmd0aCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBjb25zb2xlLmxvZyggJ3VuZGVmaW5lZCBsZW5ndGggZm9yOicsIGtleSApXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5pZHggPSBnZW4ubWVtb3J5LmFsbG9jKCByZXF1ZXN0Lmxlbmd0aCwgaW1tdXRhYmxlIClcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlTWVtb3J5KCBhbW91bnQ9NDA5NiwgdHlwZSApIHtcbiAgICBjb25zdCBtZW0gPSBNZW1vcnlIZWxwZXIuY3JlYXRlKCBhbW91bnQsIHR5cGUgKVxuICAgIHJldHVybiBtZW1cbiAgfSxcblxuICBjcmVhdGVDYWxsYmFjayggdWdlbiwgbWVtLCBkZWJ1ZyA9IGZhbHNlLCBzaG91bGRJbmxpbmVNZW1vcnk9ZmFsc2UsIG1lbVR5cGUgPSBGbG9hdDY0QXJyYXkgKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gQXJyYXkuaXNBcnJheSggdWdlbiApICYmIHVnZW4ubGVuZ3RoID4gMSxcbiAgICAgICAgY2FsbGJhY2ssIFxuICAgICAgICBjaGFubmVsMSwgY2hhbm5lbDJcblxuICAgIGlmKCB0eXBlb2YgbWVtID09PSAnbnVtYmVyJyB8fCBtZW0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHRoaXMubWVtb3J5ID0gdGhpcy5jcmVhdGVNZW1vcnkoIG1lbSwgbWVtVHlwZSApXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLm1lbW9yeSA9IG1lbVxuICAgIH1cbiAgICBcbiAgICB0aGlzLm91dHB1dElkeCA9IHRoaXMubWVtb3J5LmFsbG9jKCAyLCB0cnVlIClcbiAgICB0aGlzLmVtaXQoICdtZW1vcnkgaW5pdCcgKVxuXG4gICAgLy9jb25zb2xlLmxvZyggJ2NiIG1lbW9yeTonLCBtZW0gKVxuICAgIHRoaXMuZ3JhcGggPSB1Z2VuXG4gICAgdGhpcy5tZW1vID0ge30gXG4gICAgdGhpcy5lbmRCbG9jay5jbGVhcigpXG4gICAgdGhpcy5jbG9zdXJlcy5jbGVhcigpXG4gICAgdGhpcy5pbnB1dHMuY2xlYXIoKVxuICAgIHRoaXMucGFyYW1zLmNsZWFyKClcbiAgICB0aGlzLmdsb2JhbHMgPSB7IHdpbmRvd3M6e30gfVxuICAgIFxuICAgIHRoaXMucGFyYW1ldGVycy5jbGVhcigpXG4gICAgXG4gICAgdGhpcy5mdW5jdGlvbkJvZHkgPSBcIiAgJ3VzZSBzdHJpY3QnXFxuXCJcbiAgICBpZiggc2hvdWxkSW5saW5lTWVtb3J5PT09ZmFsc2UgKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9uQm9keSArPSB0aGlzLm1vZGUgPT09ICd3b3JrbGV0JyA/IFxuICAgICAgICBcIiAgdmFyIG1lbW9yeSA9IHRoaXMubWVtb3J5XFxuXFxuXCIgOlxuICAgICAgICBcIiAgdmFyIG1lbW9yeSA9IGdlbi5tZW1vcnlcXG5cXG5cIlxuICAgIH1cblxuICAgIC8vIGNhbGwgLmdlbigpIG9uIHRoZSBoZWFkIG9mIHRoZSBncmFwaCB3ZSBhcmUgZ2VuZXJhdGluZyB0aGUgY2FsbGJhY2sgZm9yXG4gICAgLy9jb25zb2xlLmxvZyggJ0hFQUQnLCB1Z2VuIClcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IDEgKyBpc1N0ZXJlbzsgaSsrICkge1xuICAgICAgaWYoIHR5cGVvZiB1Z2VuW2ldID09PSAnbnVtYmVyJyApIGNvbnRpbnVlXG5cbiAgICAgIC8vbGV0IGNoYW5uZWwgPSBpc1N0ZXJlbyA/IHVnZW5baV0uZ2VuKCkgOiB1Z2VuLmdlbigpLFxuICAgICAgbGV0IGNoYW5uZWwgPSBpc1N0ZXJlbyA/IHRoaXMuZ2V0SW5wdXQoIHVnZW5baV0gKSA6IHRoaXMuZ2V0SW5wdXQoIHVnZW4gKSwgXG4gICAgICAgICAgYm9keSA9ICcnXG5cbiAgICAgIC8vIGlmIC5nZW4oKSByZXR1cm5zIGFycmF5LCBhZGQgdWdlbiBjYWxsYmFjayAoZ3JhcGhPdXRwdXRbMV0pIHRvIG91ciBvdXRwdXQgZnVuY3Rpb25zIGJvZHlcbiAgICAgIC8vIGFuZCB0aGVuIHJldHVybiBuYW1lIG9mIHVnZW4uIElmIC5nZW4oKSBvbmx5IGdlbmVyYXRlcyBhIG51bWJlciAoZm9yIHJlYWxseSBzaW1wbGUgZ3JhcGhzKVxuICAgICAgLy8ganVzdCByZXR1cm4gdGhhdCBudW1iZXIgKGdyYXBoT3V0cHV0WzBdKS5cbiAgICAgIGJvZHkgKz0gQXJyYXkuaXNBcnJheSggY2hhbm5lbCApID8gY2hhbm5lbFsxXSArICdcXG4nICsgY2hhbm5lbFswXSA6IGNoYW5uZWxcblxuICAgICAgLy8gc3BsaXQgYm9keSB0byBpbmplY3QgcmV0dXJuIGtleXdvcmQgb24gbGFzdCBsaW5lXG4gICAgICBib2R5ID0gYm9keS5zcGxpdCgnXFxuJylcbiAgICAgXG4gICAgICAvL2lmKCBkZWJ1ZyApIGNvbnNvbGUubG9nKCAnZnVuY3Rpb25Cb2R5IGxlbmd0aCcsIGJvZHkgKVxuICAgICAgXG4gICAgICAvLyBuZXh0IGxpbmUgaXMgdG8gYWNjb21tb2RhdGUgbWVtbyBhcyBncmFwaCBoZWFkXG4gICAgICBpZiggYm9keVsgYm9keS5sZW5ndGggLTEgXS50cmltKCkuaW5kZXhPZignbGV0JykgPiAtMSApIHsgYm9keS5wdXNoKCAnXFxuJyApIH0gXG5cbiAgICAgIC8vIGdldCBpbmRleCBvZiBsYXN0IGxpbmVcbiAgICAgIGxldCBsYXN0aWR4ID0gYm9keS5sZW5ndGggLSAxXG5cbiAgICAgIC8vIGluc2VydCByZXR1cm4ga2V5d29yZFxuICAgICAgYm9keVsgbGFzdGlkeCBdID0gJyAgbWVtb3J5WycgKyAodGhpcy5vdXRwdXRJZHggKyBpKSArICddICA9ICcgKyBib2R5WyBsYXN0aWR4IF0gKyAnXFxuJ1xuXG4gICAgICB0aGlzLmZ1bmN0aW9uQm9keSArPSBib2R5LmpvaW4oJ1xcbicpXG4gICAgfVxuICAgIFxuICAgIHRoaXMuaGlzdG9yaWVzLmZvckVhY2goIHZhbHVlID0+IHtcbiAgICAgIGlmKCB2YWx1ZSAhPT0gbnVsbCApXG4gICAgICAgIHZhbHVlLmdlbigpICAgICAgXG4gICAgfSlcblxuICAgIGNvbnN0IHJldHVyblN0YXRlbWVudCA9IGlzU3RlcmVvID8gYCAgcmV0dXJuIFsgbWVtb3J5WyR7dGhpcy5vdXRwdXRJZHh9XSwgbWVtb3J5WyR7dGhpcy5vdXRwdXRJZHggKyAxfV0gXWAgOiBgICByZXR1cm4gbWVtb3J5WyR7dGhpcy5vdXRwdXRJZHh9XWBcbiAgICBcbiAgICB0aGlzLmZ1bmN0aW9uQm9keSA9IHRoaXMuZnVuY3Rpb25Cb2R5LnNwbGl0KCdcXG4nKVxuXG4gICAgaWYoIHRoaXMuZW5kQmxvY2suc2l6ZSApIHsgXG4gICAgICB0aGlzLmZ1bmN0aW9uQm9keSA9IHRoaXMuZnVuY3Rpb25Cb2R5LmNvbmNhdCggQXJyYXkuZnJvbSggdGhpcy5lbmRCbG9jayApIClcbiAgICAgIHRoaXMuZnVuY3Rpb25Cb2R5LnB1c2goIHJldHVyblN0YXRlbWVudCApXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmZ1bmN0aW9uQm9keS5wdXNoKCByZXR1cm5TdGF0ZW1lbnQgKVxuICAgIH1cbiAgICAvLyByZWFzc2VtYmxlIGZ1bmN0aW9uIGJvZHlcbiAgICB0aGlzLmZ1bmN0aW9uQm9keSA9IHRoaXMuZnVuY3Rpb25Cb2R5LmpvaW4oJ1xcbicpXG5cbiAgICAvLyB3ZSBjYW4gb25seSBkeW5hbWljYWxseSBjcmVhdGUgYSBuYW1lZCBmdW5jdGlvbiBieSBkeW5hbWljYWxseSBjcmVhdGluZyBhbm90aGVyIGZ1bmN0aW9uXG4gICAgLy8gdG8gY29uc3RydWN0IHRoZSBuYW1lZCBmdW5jdGlvbiEgc2hlZXNoLi4uXG4gICAgLy9cbiAgICBpZiggc2hvdWxkSW5saW5lTWVtb3J5ID09PSB0cnVlICkge1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzLmFkZCggJ21lbW9yeScgKVxuICAgIH1cblxuICAgIGxldCBwYXJhbVN0cmluZyA9ICcnXG4gICAgaWYoIHRoaXMubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgZm9yKCBsZXQgbmFtZSBvZiB0aGlzLnBhcmFtZXRlcnMudmFsdWVzKCkgKSB7XG4gICAgICAgIHBhcmFtU3RyaW5nICs9IG5hbWUgKyAnLCdcbiAgICAgIH1cbiAgICAgIHBhcmFtU3RyaW5nID0gcGFyYW1TdHJpbmcuc2xpY2UoMCwtMSlcbiAgICB9XG5cbiAgICBjb25zdCBzZXBhcmF0b3IgPSB0aGlzLnBhcmFtZXRlcnMuc2l6ZSAhPT0gMCAmJiB0aGlzLmlucHV0cy5zaXplID4gMCA/ICcsICcgOiAnJ1xuXG4gICAgbGV0IGlucHV0U3RyaW5nID0gJydcbiAgICBpZiggdGhpcy5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICBmb3IoIGxldCB1Z2VuIG9mIHRoaXMuaW5wdXRzLnZhbHVlcygpICkge1xuICAgICAgICBpbnB1dFN0cmluZyArPSB1Z2VuLm5hbWUgKyAnLCdcbiAgICAgIH1cbiAgICAgIGlucHV0U3RyaW5nID0gaW5wdXRTdHJpbmcuc2xpY2UoMCwtMSlcbiAgICB9XG5cbiAgICBsZXQgYnVpbGRTdHJpbmcgPSB0aGlzLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgICAgPyBgcmV0dXJuIGZ1bmN0aW9uKCAke2lucHV0U3RyaW5nfSAke3NlcGFyYXRvcn0gJHtwYXJhbVN0cmluZ30gKXsgXFxuJHsgdGhpcy5mdW5jdGlvbkJvZHkgfVxcbn1gXG4gICAgICA6IGByZXR1cm4gZnVuY3Rpb24gZ2VuKCAkeyBbLi4udGhpcy5wYXJhbWV0ZXJzXS5qb2luKCcsJykgfSApeyBcXG4keyB0aGlzLmZ1bmN0aW9uQm9keSB9XFxufWBcbiAgICBcbiAgICBpZiggdGhpcy5kZWJ1ZyB8fCBkZWJ1ZyApIGNvbnNvbGUubG9nKCBidWlsZFN0cmluZyApIFxuXG4gICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oIGJ1aWxkU3RyaW5nICkoKVxuXG4gICAgLy8gYXNzaWduIHByb3BlcnRpZXMgdG8gbmFtZWQgZnVuY3Rpb25cbiAgICBmb3IoIGxldCBkaWN0IG9mIHRoaXMuY2xvc3VyZXMudmFsdWVzKCkgKSB7XG4gICAgICBsZXQgbmFtZSA9IE9iamVjdC5rZXlzKCBkaWN0IClbMF0sXG4gICAgICAgICAgdmFsdWUgPSBkaWN0WyBuYW1lIF1cblxuICAgICAgY2FsbGJhY2tbIG5hbWUgXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgZm9yKCBsZXQgZGljdCBvZiB0aGlzLnBhcmFtcy52YWx1ZXMoKSApIHtcbiAgICAgIGxldCBuYW1lID0gT2JqZWN0LmtleXMoIGRpY3QgKVswXSxcbiAgICAgICAgICB1Z2VuID0gZGljdFsgbmFtZSBdXG4gICAgICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggY2FsbGJhY2ssIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7IHJldHVybiB1Z2VuLnZhbHVlIH0sXG4gICAgICAgIHNldCh2KXsgdWdlbi52YWx1ZSA9IHYgfVxuICAgICAgfSlcbiAgICAgIC8vY2FsbGJhY2tbIG5hbWUgXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgY2FsbGJhY2subWVtYmVycyA9IHRoaXMuY2xvc3VyZXNcbiAgICBjYWxsYmFjay5kYXRhID0gdGhpcy5kYXRhXG4gICAgY2FsbGJhY2sucGFyYW1zID0gdGhpcy5wYXJhbXNcbiAgICBjYWxsYmFjay5pbnB1dHMgPSB0aGlzLmlucHV0c1xuICAgIGNhbGxiYWNrLnBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnMvLy5zbGljZSggMCApXG4gICAgY2FsbGJhY2sub3V0ID0gdGhpcy5tZW1vcnkuaGVhcC5zdWJhcnJheSggdGhpcy5vdXRwdXRJZHgsIHRoaXMub3V0cHV0SWR4ICsgMiApXG4gICAgY2FsbGJhY2suaXNTdGVyZW8gPSBpc1N0ZXJlb1xuXG4gICAgLy9pZiggTWVtb3J5SGVscGVyLmlzUHJvdG90eXBlT2YoIHRoaXMubWVtb3J5ICkgKSBcbiAgICBjYWxsYmFjay5tZW1vcnkgPSB0aGlzLm1lbW9yeS5oZWFwXG5cbiAgICB0aGlzLmhpc3Rvcmllcy5jbGVhcigpXG5cbiAgICByZXR1cm4gY2FsbGJhY2tcbiAgfSxcbiAgXG4gIC8qIGdldElucHV0c1xuICAgKlxuICAgKiBDYWxsZWQgYnkgZWFjaCBpbmRpdmlkdWFsIHVnZW4gd2hlbiB0aGVpciAuZ2VuKCkgbWV0aG9kIGlzIGNhbGxlZCB0byByZXNvbHZlIHRoZWlyIHZhcmlvdXMgaW5wdXRzLlxuICAgKiBJZiBhbiBpbnB1dCBpcyBhIG51bWJlciwgcmV0dXJuIHRoZSBudW1iZXIuIElmXG4gICAqIGl0IGlzIGFuIHVnZW4sIGNhbGwgLmdlbigpIG9uIHRoZSB1Z2VuLCBtZW1vaXplIHRoZSByZXN1bHQgYW5kIHJldHVybiB0aGUgcmVzdWx0LiBJZiB0aGVcbiAgICogdWdlbiBoYXMgcHJldmlvdXNseSBiZWVuIG1lbW9pemVkIHJldHVybiB0aGUgbWVtb2l6ZWQgdmFsdWUuXG4gICAqXG4gICAqL1xuICBnZXRJbnB1dHMoIHVnZW4gKSB7XG4gICAgcmV0dXJuIHVnZW4uaW5wdXRzLm1hcCggZ2VuLmdldElucHV0ICkgXG4gIH0sXG5cbiAgZ2V0SW5wdXQoIGlucHV0ICkge1xuICAgIGxldCBpc09iamVjdCA9IHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcsXG4gICAgICAgIHByb2Nlc3NlZElucHV0XG5cbiAgICBpZiggaXNPYmplY3QgKSB7IC8vIGlmIGlucHV0IGlzIGEgdWdlbi4uLiBcbiAgICAgIC8vY29uc29sZS5sb2coIGlucHV0Lm5hbWUsIGdlbi5tZW1vWyBpbnB1dC5uYW1lIF0gKVxuICAgICAgaWYoIGdlbi5tZW1vWyBpbnB1dC5uYW1lIF0gKSB7IC8vIGlmIGl0IGhhcyBiZWVuIG1lbW9pemVkLi4uXG4gICAgICAgIHByb2Nlc3NlZElucHV0ID0gZ2VuLm1lbW9bIGlucHV0Lm5hbWUgXVxuICAgICAgfWVsc2UgaWYoIEFycmF5LmlzQXJyYXkoIGlucHV0ICkgKSB7XG4gICAgICAgIGdlbi5nZXRJbnB1dCggaW5wdXRbMF0gKVxuICAgICAgICBnZW4uZ2V0SW5wdXQoIGlucHV0WzFdIClcbiAgICAgIH1lbHNleyAvLyBpZiBub3QgbWVtb2l6ZWQgZ2VuZXJhdGUgY29kZSAgXG4gICAgICAgIGlmKCB0eXBlb2YgaW5wdXQuZ2VuICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCAnbm8gZ2VuIGZvdW5kOicsIGlucHV0LCBpbnB1dC5nZW4gKVxuICAgICAgICAgIGlucHV0ID0gaW5wdXQuZ3JhcGhcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZSA9IGlucHV0LmdlbigpXG4gICAgICAgIC8vaWYoIGNvZGUuaW5kZXhPZiggJ09iamVjdCcgKSA+IC0xICkgY29uc29sZS5sb2coICdiYWQgaW5wdXQ6JywgaW5wdXQsIGNvZGUgKVxuICAgICAgICBcbiAgICAgICAgaWYoIEFycmF5LmlzQXJyYXkoIGNvZGUgKSApIHtcbiAgICAgICAgICBpZiggIWdlbi5zaG91bGRMb2NhbGl6ZSApIHtcbiAgICAgICAgICAgIGdlbi5mdW5jdGlvbkJvZHkgKz0gY29kZVsxXVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgZ2VuLmNvZGVOYW1lID0gY29kZVswXVxuICAgICAgICAgICAgZ2VuLmxvY2FsaXplZENvZGUucHVzaCggY29kZVsxXSApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coICdhZnRlciBHRU4nICwgdGhpcy5mdW5jdGlvbkJvZHkgKVxuICAgICAgICAgIHByb2Nlc3NlZElucHV0ID0gY29kZVswXVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBwcm9jZXNzZWRJbnB1dCA9IGNvZGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNleyAvLyBpdCBpbnB1dCBpcyBhIG51bWJlclxuICAgICAgcHJvY2Vzc2VkSW5wdXQgPSBpbnB1dFxuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRJbnB1dFxuICB9LFxuXG4gIHN0YXJ0TG9jYWxpemUoKSB7XG4gICAgdGhpcy5sb2NhbGl6ZWRDb2RlID0gW11cbiAgICB0aGlzLnNob3VsZExvY2FsaXplID0gdHJ1ZVxuICB9LFxuICBlbmRMb2NhbGl6ZSgpIHtcbiAgICB0aGlzLnNob3VsZExvY2FsaXplID0gZmFsc2VcblxuICAgIHJldHVybiBbIHRoaXMuY29kZU5hbWUsIHRoaXMubG9jYWxpemVkQ29kZS5zbGljZSgwKSBdXG4gIH0sXG5cbiAgZnJlZSggZ3JhcGggKSB7XG4gICAgaWYoIEFycmF5LmlzQXJyYXkoIGdyYXBoICkgKSB7IC8vIHN0ZXJlbyB1Z2VuXG4gICAgICBmb3IoIGxldCBjaGFubmVsIG9mIGdyYXBoICkge1xuICAgICAgICB0aGlzLmZyZWUoIGNoYW5uZWwgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggdHlwZW9mIGdyYXBoID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgaWYoIGdyYXBoLm1lbW9yeSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIGZvciggbGV0IG1lbW9yeUtleSBpbiBncmFwaC5tZW1vcnkgKSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeS5mcmVlKCBncmFwaC5tZW1vcnlbIG1lbW9yeUtleSBdLmlkeCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCBncmFwaC5pbnB1dHMgKSApIHtcbiAgICAgICAgICBmb3IoIGxldCB1Z2VuIG9mIGdyYXBoLmlucHV0cyApIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZSggdWdlbiApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmdlbi5fX3Byb3RvX18gPSBuZXcgRUUoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidndCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSBgICBcblxuICAgIGlmKCBpc05hTiggdGhpcy5pbnB1dHNbMF0gKSB8fCBpc05hTiggdGhpcy5pbnB1dHNbMV0gKSApIHtcbiAgICAgIG91dCArPSBgKCggJHtpbnB1dHNbMF19ID4gJHtpbnB1dHNbMV19KSB8IDAgKWBcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IGlucHV0c1swXSA+IGlucHV0c1sxXSA/IDEgOiAwIFxuICAgIH1cbiAgICBvdXQgKz0gJ1xcblxcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFt0aGlzLm5hbWUsIG91dF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGd0ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGd0LmlucHV0cyA9IFsgeCx5IF1cbiAgZ3QubmFtZSA9IGd0LmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIGd0XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidndGUnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gYCAgXG5cbiAgICBpZiggaXNOYU4oIHRoaXMuaW5wdXRzWzBdICkgfHwgaXNOYU4oIHRoaXMuaW5wdXRzWzFdICkgKSB7XG4gICAgICBvdXQgKz0gYCggJHtpbnB1dHNbMF19ID49ICR7aW5wdXRzWzFdfSB8IDAgKWBcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IGlucHV0c1swXSA+PSBpbnB1dHNbMV0gPyAxIDogMCBcbiAgICB9XG4gICAgb3V0ICs9ICdcXG5cXG4nXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWVcblxuICAgIHJldHVybiBbdGhpcy5uYW1lLCBvdXRdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBndCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBndC5pbnB1dHMgPSBbIHgseSBdXG4gIGd0Lm5hbWUgPSAnZ3RlJyArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiBndFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2d0cCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApIHx8IGlzTmFOKCB0aGlzLmlucHV0c1sxXSApICkge1xuICAgICAgb3V0ID0gYCgke2lucHV0c1sgMCBdfSAqICggKCAke2lucHV0c1swXX0gPiAke2lucHV0c1sxXX0gKSB8IDAgKSApYCBcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gaW5wdXRzWzBdICogKCAoIGlucHV0c1swXSA+IGlucHV0c1sxXSApIHwgMCApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGd0cCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBndHAuaW5wdXRzID0gWyB4LHkgXVxuXG4gIHJldHVybiBndHBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMT0wICkgPT4ge1xuICBsZXQgdWdlbiA9IHtcbiAgICBpbnB1dHM6IFsgaW4xIF0sXG4gICAgbWVtb3J5OiB7IHZhbHVlOiB7IGxlbmd0aDoxLCBpZHg6IG51bGwgfSB9LFxuICAgIHJlY29yZGVyOiBudWxsLFxuXG4gICAgaW4oIHYgKSB7XG4gICAgICBpZiggZ2VuLmhpc3Rvcmllcy5oYXMoIHYgKSApe1xuICAgICAgICBsZXQgbWVtb0hpc3RvcnkgPSBnZW4uaGlzdG9yaWVzLmdldCggdiApXG4gICAgICAgIHVnZW4ubmFtZSA9IG1lbW9IaXN0b3J5Lm5hbWVcbiAgICAgICAgcmV0dXJuIG1lbW9IaXN0b3J5XG4gICAgICB9XG5cbiAgICAgIGxldCBvYmogPSB7XG4gICAgICAgIGdlbigpIHtcbiAgICAgICAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdWdlbiApXG5cbiAgICAgICAgICBpZiggdWdlbi5tZW1vcnkudmFsdWUuaWR4ID09PSBudWxsICkge1xuICAgICAgICAgICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHVnZW4ubWVtb3J5IClcbiAgICAgICAgICAgIGdlbi5tZW1vcnkuaGVhcFsgdWdlbi5tZW1vcnkudmFsdWUuaWR4IF0gPSBpbjFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgaWR4ID0gdWdlbi5tZW1vcnkudmFsdWUuaWR4XG4gICAgICAgICAgXG4gICAgICAgICAgZ2VuLmFkZFRvRW5kQmxvY2soICdtZW1vcnlbICcgKyBpZHggKyAnIF0gPSAnICsgaW5wdXRzWyAwIF0gKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHJldHVybiB1Z2VuIHRoYXQgaXMgYmVpbmcgcmVjb3JkZWQgaW5zdGVhZCBvZiBzc2QuXG4gICAgICAgICAgLy8gdGhpcyBlZmZlY3RpdmVseSBtYWtlcyBhIGNhbGwgdG8gc3NkLnJlY29yZCgpIHRyYW5zcGFyZW50IHRvIHRoZSBncmFwaC5cbiAgICAgICAgICAvLyByZWNvcmRpbmcgaXMgdHJpZ2dlcmVkIGJ5IHByaW9yIGNhbGwgdG8gZ2VuLmFkZFRvRW5kQmxvY2suXG4gICAgICAgICAgZ2VuLmhpc3Rvcmllcy5zZXQoIHYsIG9iaiApXG5cbiAgICAgICAgICByZXR1cm4gaW5wdXRzWyAwIF1cbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogdWdlbi5uYW1lICsgJ19pbicrZ2VuLmdldFVJRCgpLFxuICAgICAgICBtZW1vcnk6IHVnZW4ubWVtb3J5XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5wdXRzWyAwIF0gPSB2XG4gICAgICBcbiAgICAgIHVnZW4ucmVjb3JkZXIgPSBvYmpcblxuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gICAgXG4gICAgb3V0OiB7XG4gICAgICAgICAgICBcbiAgICAgIGdlbigpIHtcbiAgICAgICAgaWYoIHVnZW4ubWVtb3J5LnZhbHVlLmlkeCA9PT0gbnVsbCApIHtcbiAgICAgICAgICBpZiggZ2VuLmhpc3Rvcmllcy5nZXQoIHVnZW4uaW5wdXRzWzBdICkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGdlbi5oaXN0b3JpZXMuc2V0KCB1Z2VuLmlucHV0c1swXSwgdWdlbi5yZWNvcmRlciApXG4gICAgICAgICAgfVxuICAgICAgICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB1Z2VuLm1lbW9yeSApXG4gICAgICAgICAgZ2VuLm1lbW9yeS5oZWFwWyB1Z2VuLm1lbW9yeS52YWx1ZS5pZHggXSA9IHBhcnNlRmxvYXQoIGluMSApXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkeCA9IHVnZW4ubWVtb3J5LnZhbHVlLmlkeFxuICAgICAgICAgXG4gICAgICAgIHJldHVybiAnbWVtb3J5WyAnICsgaWR4ICsgJyBdICdcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIHVpZDogZ2VuLmdldFVJRCgpLFxuICB9XG4gIFxuICB1Z2VuLm91dC5tZW1vcnkgPSB1Z2VuLm1lbW9yeSBcblxuICB1Z2VuLm5hbWUgPSAnaGlzdG9yeScgKyB1Z2VuLnVpZFxuICB1Z2VuLm91dC5uYW1lID0gdWdlbi5uYW1lICsgJ19vdXQnXG4gIHVnZW4uaW4uX25hbWUgID0gdWdlbi5uYW1lID0gJ19pbidcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sICd2YWx1ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiggdGhpcy5tZW1vcnkudmFsdWUuaWR4ICE9PSBudWxsICkge1xuICAgICAgICByZXR1cm4gZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLm1lbW9yeS52YWx1ZS5pZHggXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KCB2ICkge1xuICAgICAgaWYoIHRoaXMubWVtb3J5LnZhbHVlLmlkeCAhPT0gbnVsbCApIHtcbiAgICAgICAgZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLm1lbW9yeS52YWx1ZS5pZHggXSA9IHYgXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidpZmVsc2UnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgY29uZGl0aW9uYWxzID0gdGhpcy5pbnB1dHNbMF0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IGdlbi5nZXRJbnB1dCggY29uZGl0aW9uYWxzWyBjb25kaXRpb25hbHMubGVuZ3RoIC0gMV0gKSxcbiAgICAgICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfV9vdXQgPSAke2RlZmF1bHRWYWx1ZX1cXG5gIFxuXG4gICAgLy9jb25zb2xlLmxvZyggJ2NvbmRpdGlvbmFsczonLCB0aGlzLm5hbWUsIGNvbmRpdGlvbmFscyApXG5cbiAgICAvL2NvbnNvbGUubG9nKCAnZGVmYXVsdFZhbHVlOicsIGRlZmF1bHRWYWx1ZSApXG5cbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IGNvbmRpdGlvbmFscy5sZW5ndGggLSAyOyBpKz0gMiApIHtcbiAgICAgIGxldCBpc0VuZEJsb2NrID0gaSA9PT0gY29uZGl0aW9uYWxzLmxlbmd0aCAtIDMsXG4gICAgICAgICAgY29uZCAgPSBnZW4uZ2V0SW5wdXQoIGNvbmRpdGlvbmFsc1sgaSBdICksXG4gICAgICAgICAgcHJlYmxvY2sgPSBjb25kaXRpb25hbHNbIGkrMSBdLFxuICAgICAgICAgIGJsb2NrLCBibG9ja05hbWUsIG91dHB1dFxuXG4gICAgICAvL2NvbnNvbGUubG9nKCAncGInLCBwcmVibG9jayApXG5cbiAgICAgIGlmKCB0eXBlb2YgcHJlYmxvY2sgPT09ICdudW1iZXInICl7XG4gICAgICAgIGJsb2NrID0gcHJlYmxvY2tcbiAgICAgICAgYmxvY2tOYW1lID0gbnVsbFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCBnZW4ubWVtb1sgcHJlYmxvY2submFtZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgLy8gdXNlZCB0byBwbGFjZSBhbGwgY29kZSBkZXBlbmRlbmNpZXMgaW4gYXBwcm9wcmlhdGUgYmxvY2tzXG4gICAgICAgICAgZ2VuLnN0YXJ0TG9jYWxpemUoKVxuXG4gICAgICAgICAgZ2VuLmdldElucHV0KCBwcmVibG9jayApXG5cbiAgICAgICAgICBibG9jayA9IGdlbi5lbmRMb2NhbGl6ZSgpXG4gICAgICAgICAgYmxvY2tOYW1lID0gYmxvY2tbMF1cbiAgICAgICAgICBibG9jayA9IGJsb2NrWyAxIF0uam9pbignJylcbiAgICAgICAgICBibG9jayA9ICcgICcgKyBibG9jay5yZXBsYWNlKCAvXFxuL2dpLCAnXFxuICAnIClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgYmxvY2sgPSAnJ1xuICAgICAgICAgIGJsb2NrTmFtZSA9IGdlbi5tZW1vWyBwcmVibG9jay5uYW1lIF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXQgPSBibG9ja05hbWUgPT09IG51bGwgPyBcbiAgICAgICAgYCAgJHt0aGlzLm5hbWV9X291dCA9ICR7YmxvY2t9YCA6XG4gICAgICAgIGAke2Jsb2NrfSAgJHt0aGlzLm5hbWV9X291dCA9ICR7YmxvY2tOYW1lfWBcbiAgICAgIFxuICAgICAgaWYoIGk9PT0wICkgb3V0ICs9ICcgJ1xuICAgICAgb3V0ICs9IFxuYCBpZiggJHtjb25kfSA9PT0gMSApIHtcbiR7b3V0cHV0fVxuICB9YFxuXG4gICAgICBpZiggIWlzRW5kQmxvY2sgKSB7XG4gICAgICAgIG91dCArPSBgIGVsc2VgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgb3V0ICs9IGBcXG5gXG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gYCR7dGhpcy5uYW1lfV9vdXRgXG5cbiAgICByZXR1cm4gWyBgJHt0aGlzLm5hbWV9X291dGAsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIC4uLmFyZ3MgICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICksXG4gICAgICBjb25kaXRpb25zID0gQXJyYXkuaXNBcnJheSggYXJnc1swXSApID8gYXJnc1swXSA6IGFyZ3NcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7XG4gICAgdWlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogIFsgY29uZGl0aW9ucyBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2luJyxcblxuICBnZW4oKSB7XG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuXG4gICAgaWYoIGlzV29ya2xldCApIHtcbiAgICAgIGdlbi5pbnB1dHMuYWRkKCB0aGlzIClcbiAgICB9ZWxzZXtcbiAgICAgIGdlbi5wYXJhbWV0ZXJzLmFkZCggdGhpcy5uYW1lIClcbiAgICB9XG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBpc1dvcmtsZXQgPT09IHRydWUgPyB0aGlzLm5hbWUgKyAnW2ldJyA6IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIGdlbi5tZW1vWyB0aGlzLm5hbWUgXVxuICB9IFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggbmFtZSwgaW5wdXROdW1iZXI9MCwgY2hhbm5lbE51bWJlcj0wLCBkZWZhdWx0VmFsdWU9MCwgbWluPTAsIG1heD0xICkgPT4ge1xuICBsZXQgaW5wdXQgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgaW5wdXQuaWQgICA9IGdlbi5nZXRVSUQoKVxuICBpbnB1dC5uYW1lID0gbmFtZSAhPT0gdW5kZWZpbmVkID8gbmFtZSA6IGAke2lucHV0LmJhc2VuYW1lfSR7aW5wdXQuaWR9YFxuICBPYmplY3QuYXNzaWduKCBpbnB1dCwgeyBkZWZhdWx0VmFsdWUsIG1pbiwgbWF4LCBpbnB1dE51bWJlciwgY2hhbm5lbE51bWJlciB9KVxuXG4gIGlucHV0WzBdID0ge1xuICAgIGdlbigpIHtcbiAgICAgIGlmKCAhIGdlbi5wYXJhbWV0ZXJzLmhhcyggaW5wdXQubmFtZSApICkgZ2VuLnBhcmFtZXRlcnMuYWRkKCBpbnB1dC5uYW1lIClcbiAgICAgIHJldHVybiBpbnB1dC5uYW1lICsgJ1swXSdcbiAgICB9XG4gIH1cbiAgaW5wdXRbMV0gPSB7XG4gICAgZ2VuKCkge1xuICAgICAgaWYoICEgZ2VuLnBhcmFtZXRlcnMuaGFzKCBpbnB1dC5uYW1lICkgKSBnZW4ucGFyYW1ldGVycy5hZGQoIGlucHV0Lm5hbWUgKVxuICAgICAgcmV0dXJuIGlucHV0Lm5hbWUgKyAnWzFdJ1xuICAgIH1cbiAgfVxuXG5cbiAgcmV0dXJuIGlucHV0XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbGlicmFyeSA9IHtcbiAgZXhwb3J0KCBkZXN0aW5hdGlvbiApIHtcbiAgICBpZiggZGVzdGluYXRpb24gPT09IHdpbmRvdyApIHtcbiAgICAgIGRlc3RpbmF0aW9uLnNzZCA9IGxpYnJhcnkuaGlzdG9yeSAgICAvLyBoaXN0b3J5IGlzIHdpbmRvdyBvYmplY3QgcHJvcGVydHksIHNvIHVzZSBzc2QgYXMgYWxpYXNcbiAgICAgIGRlc3RpbmF0aW9uLmlucHV0ID0gbGlicmFyeS5pbiAgICAgICAvLyBpbiBpcyBhIGtleXdvcmQgaW4gamF2YXNjcmlwdFxuICAgICAgZGVzdGluYXRpb24udGVybmFyeSA9IGxpYnJhcnkuc3dpdGNoIC8vIHN3aXRjaCBpcyBhIGtleXdvcmQgaW4gamF2YXNjcmlwdFxuXG4gICAgICBkZWxldGUgbGlicmFyeS5oaXN0b3J5XG4gICAgICBkZWxldGUgbGlicmFyeS5pblxuICAgICAgZGVsZXRlIGxpYnJhcnkuc3dpdGNoXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggZGVzdGluYXRpb24sIGxpYnJhcnkgKVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWJyYXJ5LCAnc2FtcGxlcmF0ZScsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIGxpYnJhcnkuZ2VuLnNhbXBsZXJhdGUgfSxcbiAgICAgIHNldCh2KSB7fVxuICAgIH0pXG5cbiAgICBsaWJyYXJ5LmluID0gZGVzdGluYXRpb24uaW5wdXRcbiAgICBsaWJyYXJ5Lmhpc3RvcnkgPSBkZXN0aW5hdGlvbi5zc2RcbiAgICBsaWJyYXJ5LnN3aXRjaCA9IGRlc3RpbmF0aW9uLnRlcm5hcnlcblxuICAgIGRlc3RpbmF0aW9uLmNsaXAgPSBsaWJyYXJ5LmNsYW1wXG4gIH0sXG5cbiAgZ2VuOiAgICAgIHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgXG4gIGFiczogICAgICByZXF1aXJlKCAnLi9hYnMuanMnICksXG4gIHJvdW5kOiAgICByZXF1aXJlKCAnLi9yb3VuZC5qcycgKSxcbiAgcGFyYW06ICAgIHJlcXVpcmUoICcuL3BhcmFtLmpzJyApLFxuICBhZGQ6ICAgICAgcmVxdWlyZSggJy4vYWRkLmpzJyApLFxuICBzdWI6ICAgICAgcmVxdWlyZSggJy4vc3ViLmpzJyApLFxuICBtdWw6ICAgICAgcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICBkaXY6ICAgICAgcmVxdWlyZSggJy4vZGl2LmpzJyApLFxuICBhY2N1bTogICAgcmVxdWlyZSggJy4vYWNjdW0uanMnICksXG4gIGNvdW50ZXI6ICByZXF1aXJlKCAnLi9jb3VudGVyLmpzJyApLFxuICBzaW46ICAgICAgcmVxdWlyZSggJy4vc2luLmpzJyApLFxuICBjb3M6ICAgICAgcmVxdWlyZSggJy4vY29zLmpzJyApLFxuICB0YW46ICAgICAgcmVxdWlyZSggJy4vdGFuLmpzJyApLFxuICB0YW5oOiAgICAgcmVxdWlyZSggJy4vdGFuaC5qcycgKSxcbiAgYXNpbjogICAgIHJlcXVpcmUoICcuL2FzaW4uanMnICksXG4gIGFjb3M6ICAgICByZXF1aXJlKCAnLi9hY29zLmpzJyApLFxuICBhdGFuOiAgICAgcmVxdWlyZSggJy4vYXRhbi5qcycgKSwgIFxuICBwaGFzb3I6ICAgcmVxdWlyZSggJy4vcGhhc29yLmpzJyApLFxuICBkYXRhOiAgICAgcmVxdWlyZSggJy4vZGF0YS5qcycgKSxcbiAgcGVlazogICAgIHJlcXVpcmUoICcuL3BlZWsuanMnICksXG4gIGN5Y2xlOiAgICByZXF1aXJlKCAnLi9jeWNsZS5qcycgKSxcbiAgaGlzdG9yeTogIHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gIGRlbHRhOiAgICByZXF1aXJlKCAnLi9kZWx0YS5qcycgKSxcbiAgZmxvb3I6ICAgIHJlcXVpcmUoICcuL2Zsb29yLmpzJyApLFxuICBjZWlsOiAgICAgcmVxdWlyZSggJy4vY2VpbC5qcycgKSxcbiAgbWluOiAgICAgIHJlcXVpcmUoICcuL21pbi5qcycgKSxcbiAgbWF4OiAgICAgIHJlcXVpcmUoICcuL21heC5qcycgKSxcbiAgc2lnbjogICAgIHJlcXVpcmUoICcuL3NpZ24uanMnICksXG4gIGRjYmxvY2s6ICByZXF1aXJlKCAnLi9kY2Jsb2NrLmpzJyApLFxuICBtZW1vOiAgICAgcmVxdWlyZSggJy4vbWVtby5qcycgKSxcbiAgcmF0ZTogICAgIHJlcXVpcmUoICcuL3JhdGUuanMnICksXG4gIHdyYXA6ICAgICByZXF1aXJlKCAnLi93cmFwLmpzJyApLFxuICBtaXg6ICAgICAgcmVxdWlyZSggJy4vbWl4LmpzJyApLFxuICBjbGFtcDogICAgcmVxdWlyZSggJy4vY2xhbXAuanMnICksXG4gIHBva2U6ICAgICByZXF1aXJlKCAnLi9wb2tlLmpzJyApLFxuICBkZWxheTogICAgcmVxdWlyZSggJy4vZGVsYXkuanMnICksXG4gIGZvbGQ6ICAgICByZXF1aXJlKCAnLi9mb2xkLmpzJyApLFxuICBtb2QgOiAgICAgcmVxdWlyZSggJy4vbW9kLmpzJyApLFxuICBzYWggOiAgICAgcmVxdWlyZSggJy4vc2FoLmpzJyApLFxuICBub2lzZTogICAgcmVxdWlyZSggJy4vbm9pc2UuanMnICksXG4gIG5vdDogICAgICByZXF1aXJlKCAnLi9ub3QuanMnICksXG4gIGd0OiAgICAgICByZXF1aXJlKCAnLi9ndC5qcycgKSxcbiAgZ3RlOiAgICAgIHJlcXVpcmUoICcuL2d0ZS5qcycgKSxcbiAgbHQ6ICAgICAgIHJlcXVpcmUoICcuL2x0LmpzJyApLCBcbiAgbHRlOiAgICAgIHJlcXVpcmUoICcuL2x0ZS5qcycgKSwgXG4gIGJvb2w6ICAgICByZXF1aXJlKCAnLi9ib29sLmpzJyApLFxuICBnYXRlOiAgICAgcmVxdWlyZSggJy4vZ2F0ZS5qcycgKSxcbiAgdHJhaW46ICAgIHJlcXVpcmUoICcuL3RyYWluLmpzJyApLFxuICBzbGlkZTogICAgcmVxdWlyZSggJy4vc2xpZGUuanMnICksXG4gIGluOiAgICAgICByZXF1aXJlKCAnLi9pbi5qcycgKSxcbiAgdDYwOiAgICAgIHJlcXVpcmUoICcuL3Q2MC5qcycpLFxuICBtdG9mOiAgICAgcmVxdWlyZSggJy4vbXRvZi5qcycpLFxuICBsdHA6ICAgICAgcmVxdWlyZSggJy4vbHRwLmpzJyksICAgICAgICAvLyBUT0RPOiB0ZXN0XG4gIGd0cDogICAgICByZXF1aXJlKCAnLi9ndHAuanMnKSwgICAgICAgIC8vIFRPRE86IHRlc3RcbiAgc3dpdGNoOiAgIHJlcXVpcmUoICcuL3N3aXRjaC5qcycgKSxcbiAgbXN0b3NhbXBzOnJlcXVpcmUoICcuL21zdG9zYW1wcy5qcycgKSwgLy8gVE9ETzogbmVlZHMgdGVzdCxcbiAgc2VsZWN0b3I6IHJlcXVpcmUoICcuL3NlbGVjdG9yLmpzJyApLFxuICB1dGlsaXRpZXM6cmVxdWlyZSggJy4vdXRpbGl0aWVzLmpzJyApLFxuICBwb3c6ICAgICAgcmVxdWlyZSggJy4vcG93LmpzJyApLFxuICBhdHRhY2s6ICAgcmVxdWlyZSggJy4vYXR0YWNrLmpzJyApLFxuICBkZWNheTogICAgcmVxdWlyZSggJy4vZGVjYXkuanMnICksXG4gIHdpbmRvd3M6ICByZXF1aXJlKCAnLi93aW5kb3dzLmpzJyApLFxuICBlbnY6ICAgICAgcmVxdWlyZSggJy4vZW52LmpzJyApLFxuICBhZDogICAgICAgcmVxdWlyZSggJy4vYWQuanMnICApLFxuICBhZHNyOiAgICAgcmVxdWlyZSggJy4vYWRzci5qcycgKSxcbiAgaWZlbHNlOiAgIHJlcXVpcmUoICcuL2lmZWxzZWlmLmpzJyApLFxuICBiYW5nOiAgICAgcmVxdWlyZSggJy4vYmFuZy5qcycgKSxcbiAgYW5kOiAgICAgIHJlcXVpcmUoICcuL2FuZC5qcycgKSxcbiAgcGFuOiAgICAgIHJlcXVpcmUoICcuL3Bhbi5qcycgKSxcbiAgZXE6ICAgICAgIHJlcXVpcmUoICcuL2VxLmpzJyApLFxuICBuZXE6ICAgICAgcmVxdWlyZSggJy4vbmVxLmpzJyApLFxuICBleHA6ICAgICAgcmVxdWlyZSggJy4vZXhwLmpzJyApLFxuICBwcm9jZXNzOiAgcmVxdWlyZSggJy4vcHJvY2Vzcy5qcycgKSxcbiAgc2VxOiAgICAgIHJlcXVpcmUoICcuL3NlcS5qcycgKVxufVxuXG5saWJyYXJ5Lmdlbi5saWIgPSBsaWJyYXJ5XG5cbm1vZHVsZS5leHBvcnRzID0gbGlicmFyeVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidsdCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGAgIFxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApIHx8IGlzTmFOKCB0aGlzLmlucHV0c1sxXSApICkge1xuICAgICAgb3V0ICs9IGAoKCAke2lucHV0c1swXX0gPCAke2lucHV0c1sxXX0pIHwgMCAgKWBcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IGlucHV0c1swXSA8IGlucHV0c1sxXSA/IDEgOiAwIFxuICAgIH1cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFt0aGlzLm5hbWUsIG91dF1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBsdCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBsdC5pbnB1dHMgPSBbIHgseSBdXG4gIGx0Lm5hbWUgPSBsdC5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiBsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2x0ZScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGAgIFxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApIHx8IGlzTmFOKCB0aGlzLmlucHV0c1sxXSApICkge1xuICAgICAgb3V0ICs9IGAoICR7aW5wdXRzWzBdfSA8PSAke2lucHV0c1sxXX0gfCAwICApYFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gaW5wdXRzWzBdIDw9IGlucHV0c1sxXSA/IDEgOiAwIFxuICAgIH1cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFt0aGlzLm5hbWUsIG91dF1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBsdCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBsdC5pbnB1dHMgPSBbIHgseSBdXG4gIGx0Lm5hbWUgPSAnbHRlJyArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiBsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2x0cCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApIHx8IGlzTmFOKCB0aGlzLmlucHV0c1sxXSApICkge1xuICAgICAgb3V0ID0gYCgke2lucHV0c1sgMCBdfSAqICgoICR7aW5wdXRzWzBdfSA8ICR7aW5wdXRzWzFdfSApIHwgMCApIClgIFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBpbnB1dHNbMF0gKiAoKCBpbnB1dHNbMF0gPCBpbnB1dHNbMV0gKSB8IDAgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBsdHAgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgbHRwLmlucHV0cyA9IFsgeCx5IF1cblxuICByZXR1cm4gbHRwXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonbWF4JyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSB8fCBpc05hTiggaW5wdXRzWzFdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGgubWF4JyA6IE1hdGgubWF4IH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1tYXgoICR7aW5wdXRzWzBdfSwgJHtpbnB1dHNbMV19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5tYXgoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApLCBwYXJzZUZsb2F0KCBpbnB1dHNbMV0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IG1heCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBtYXguaW5wdXRzID0gWyB4LHkgXVxuXG4gIHJldHVybiBtYXhcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidtZW1vJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9ICR7aW5wdXRzWzBdfVxcbmBcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9IFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChpbjEsbWVtb05hbWUpID0+IHtcbiAgbGV0IG1lbW8gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIFxuICBtZW1vLmlucHV0cyA9IFsgaW4xIF1cbiAgbWVtby5pZCAgID0gZ2VuLmdldFVJRCgpXG4gIG1lbW8ubmFtZSA9IG1lbW9OYW1lICE9PSB1bmRlZmluZWQgPyBtZW1vTmFtZSArICdfJyArIGdlbi5nZXRVSUQoKSA6IGAke21lbW8uYmFzZW5hbWV9JHttZW1vLmlkfWBcblxuICByZXR1cm4gbWVtb1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J21pbicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgfHwgaXNOYU4oIGlucHV0c1sxXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IGlzV29ya2xldCA/ICdNYXRoLm1pbicgOiBNYXRoLm1pbiB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9bWluKCAke2lucHV0c1swXX0sICR7aW5wdXRzWzFdfSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGgubWluKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSwgcGFyc2VGbG9hdCggaW5wdXRzWzFdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBtaW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgbWluLmlucHV0cyA9IFsgeCx5IF1cblxuICByZXR1cm4gbWluXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgYWRkID0gcmVxdWlyZSgnLi9hZGQuanMnKSxcbiAgICBtdWwgPSByZXF1aXJlKCcuL211bC5qcycpLFxuICAgIHN1YiA9IHJlcXVpcmUoJy4vc3ViLmpzJyksXG4gICAgbWVtbz0gcmVxdWlyZSgnLi9tZW1vLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgaW4yLCB0PS41ICkgPT4ge1xuICBsZXQgdWdlbiA9IG1lbW8oIGFkZCggbXVsKGluMSwgc3ViKDEsdCApICksIG11bCggaW4yLCB0ICkgKSApXG4gIHVnZW4ubmFtZSA9ICdtaXgnICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICguLi5hcmdzKSA9PiB7XG4gIGxldCBtb2QgPSB7XG4gICAgaWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBhcmdzLFxuXG4gICAgZ2VuKCkge1xuICAgICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgICBvdXQ9JygnLFxuICAgICAgICAgIGRpZmYgPSAwLCBcbiAgICAgICAgICBudW1Db3VudCA9IDAsXG4gICAgICAgICAgbGFzdE51bWJlciA9IGlucHV0c1sgMCBdLFxuICAgICAgICAgIGxhc3ROdW1iZXJJc1VnZW4gPSBpc05hTiggbGFzdE51bWJlciApLCBcbiAgICAgICAgICBtb2RBdEVuZCA9IGZhbHNlXG5cbiAgICAgIGlucHV0cy5mb3JFYWNoKCAodixpKSA9PiB7XG4gICAgICAgIGlmKCBpID09PSAwICkgcmV0dXJuXG5cbiAgICAgICAgbGV0IGlzTnVtYmVyVWdlbiA9IGlzTmFOKCB2ICksXG4gICAgICAgICAgICBpc0ZpbmFsSWR4ICAgPSBpID09PSBpbnB1dHMubGVuZ3RoIC0gMVxuXG4gICAgICAgIGlmKCAhbGFzdE51bWJlcklzVWdlbiAmJiAhaXNOdW1iZXJVZ2VuICkge1xuICAgICAgICAgIGxhc3ROdW1iZXIgPSBsYXN0TnVtYmVyICUgdlxuICAgICAgICAgIG91dCArPSBsYXN0TnVtYmVyXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG91dCArPSBgJHtsYXN0TnVtYmVyfSAlICR7dn1gXG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzRmluYWxJZHggKSBvdXQgKz0gJyAlICcgXG4gICAgICB9KVxuXG4gICAgICBvdXQgKz0gJyknXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBtb2Rcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonbXN0b3NhbXBzJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICByZXR1cm5WYWx1ZVxuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZSB9ID0gJHtnZW4uc2FtcGxlcmF0ZX0gLyAxMDAwICogJHtpbnB1dHNbMF19IFxcblxcbmBcbiAgICAgXG4gICAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBvdXRcbiAgICAgIFxuICAgICAgcmV0dXJuVmFsdWUgPSBbIHRoaXMubmFtZSwgb3V0IF1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gZ2VuLnNhbXBsZXJhdGUgLyAxMDAwICogdGhpcy5pbnB1dHNbMF1cblxuICAgICAgcmV0dXJuVmFsdWUgPSBvdXRcbiAgICB9ICAgIFxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IG1zdG9zYW1wcyA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBtc3Rvc2FtcHMuaW5wdXRzID0gWyB4IF1cbiAgbXN0b3NhbXBzLm5hbWUgPSBwcm90by5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiBtc3Rvc2FtcHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidtdG9mJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IE1hdGguZXhwIH0pXG5cbiAgICAgIG91dCA9IGAoICR7dGhpcy50dW5pbmd9ICogZ2VuLmV4cCggLjA1Nzc2MjI2NSAqICgke2lucHV0c1swXX0gLSA2OSkgKSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IHRoaXMudHVuaW5nICogTWF0aC5leHAoIC4wNTc3NjIyNjUgKiAoIGlucHV0c1swXSAtIDY5KSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggeCwgcHJvcHMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIGRlZmF1bHRzID0geyB0dW5pbmc6NDQwIH1cbiAgXG4gIGlmKCBwcm9wcyAhPT0gdW5kZWZpbmVkICkgT2JqZWN0LmFzc2lnbiggcHJvcHMuZGVmYXVsdHMgKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIGRlZmF1bHRzIClcbiAgdWdlbi5pbnB1dHMgPSBbIHggXVxuICBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxuY29uc3QgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOiAnbXVsJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGAsXG4gICAgICAgIHN1bSA9IDEsIG51bUNvdW50ID0gMCwgbXVsQXRFbmQgPSBmYWxzZSwgYWxyZWFkeUZ1bGxTdW1tZWQgPSB0cnVlXG5cbiAgICBpbnB1dHMuZm9yRWFjaCggKHYsaSkgPT4ge1xuICAgICAgaWYoIGlzTmFOKCB2ICkgKSB7XG4gICAgICAgIG91dCArPSB2XG4gICAgICAgIGlmKCBpIDwgaW5wdXRzLmxlbmd0aCAtMSApIHtcbiAgICAgICAgICBtdWxBdEVuZCA9IHRydWVcbiAgICAgICAgICBvdXQgKz0gJyAqICdcbiAgICAgICAgfVxuICAgICAgICBhbHJlYWR5RnVsbFN1bW1lZCA9IGZhbHNlXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYoIGkgPT09IDAgKSB7XG4gICAgICAgICAgc3VtID0gdlxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzdW0gKj0gcGFyc2VGbG9hdCggdiApXG4gICAgICAgIH1cbiAgICAgICAgbnVtQ291bnQrK1xuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiggbnVtQ291bnQgPiAwICkge1xuICAgICAgb3V0ICs9IG11bEF0RW5kIHx8IGFscmVhZHlGdWxsU3VtbWVkID8gc3VtIDogJyAqICcgKyBzdW1cbiAgICB9XG5cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCAuLi5hcmdzICkgPT4ge1xuICBjb25zdCBtdWwgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIFxuICBPYmplY3QuYXNzaWduKCBtdWwsIHtcbiAgICAgIGlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgICAgaW5wdXRzOiBhcmdzLFxuICB9KVxuICBcbiAgbXVsLm5hbWUgPSBtdWwuYmFzZW5hbWUgKyBtdWwuaWRcblxuICByZXR1cm4gbXVsXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOiduZXEnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIG91dCA9IC8qdGhpcy5pbnB1dHNbMF0gIT09IHRoaXMuaW5wdXRzWzFdID8gMSA6Ki8gYCAgdmFyICR7dGhpcy5uYW1lfSA9ICgke2lucHV0c1swXX0gIT09ICR7aW5wdXRzWzFdfSkgfCAwXFxuXFxuYFxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH0sXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgaW4yICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICBbIGluMSwgaW4yIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonbm9pc2UnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0XG5cbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdub2lzZScgOiBpc1dvcmtsZXQgPyAnTWF0aC5yYW5kb20nIDogTWF0aC5yYW5kb20gfSlcblxuICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSAke3JlZn1ub2lzZSgpXFxuYFxuICAgIFxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCBvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBub2lzZSA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgbm9pc2UubmFtZSA9IHByb3RvLm5hbWUgKyBnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gbm9pc2Vcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidub3QnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIGlmKCBpc05hTiggdGhpcy5pbnB1dHNbMF0gKSApIHtcbiAgICAgIG91dCA9IGAoICR7aW5wdXRzWzBdfSA9PT0gMCA/IDEgOiAwIClgXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9ICFpbnB1dHNbMF0gPT09IDAgPyAxIDogMFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IG5vdCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBub3QuaW5wdXRzID0gWyB4IF1cblxuICByZXR1cm4gbm90XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBkYXRhID0gcmVxdWlyZSggJy4vZGF0YS5qcycgKSxcbiAgICBwZWVrID0gcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgICBtdWwgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3BhbicsIFxuICBpbml0VGFibGUoKSB7ICAgIFxuICAgIGxldCBidWZmZXJMID0gbmV3IEZsb2F0MzJBcnJheSggMTAyNCApLFxuICAgICAgICBidWZmZXJSID0gbmV3IEZsb2F0MzJBcnJheSggMTAyNCApXG5cbiAgICBjb25zdCBhbmdUb1JhZCA9IE1hdGguUEkgLyAxODBcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IDEwMjQ7IGkrKyApIHsgXG4gICAgICBsZXQgcGFuID0gaSAqICggOTAgLyAxMDI0IClcbiAgICAgIGJ1ZmZlckxbaV0gPSBNYXRoLmNvcyggcGFuICogYW5nVG9SYWQgKSBcbiAgICAgIGJ1ZmZlclJbaV0gPSBNYXRoLnNpbiggcGFuICogYW5nVG9SYWQgKVxuICAgIH1cblxuICAgIGdlbi5nbG9iYWxzLnBhbkwgPSBkYXRhKCBidWZmZXJMLCAxLCB7IGltbXV0YWJsZTp0cnVlIH0pXG4gICAgZ2VuLmdsb2JhbHMucGFuUiA9IGRhdGEoIGJ1ZmZlclIsIDEsIHsgaW1tdXRhYmxlOnRydWUgfSlcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBsZWZ0SW5wdXQsIHJpZ2h0SW5wdXQsIHBhbiA9LjUsIHByb3BlcnRpZXMgKSA9PiB7XG4gIGlmKCBnZW4uZ2xvYmFscy5wYW5MID09PSB1bmRlZmluZWQgKSBwcm90by5pbml0VGFibGUoKVxuXG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBsZWZ0SW5wdXQsIHJpZ2h0SW5wdXQgXSxcbiAgICBsZWZ0OiAgICBtdWwoIGxlZnRJbnB1dCwgcGVlayggZ2VuLmdsb2JhbHMucGFuTCwgcGFuLCB7IGJvdW5kbW9kZTonY2xhbXAnIH0pICksXG4gICAgcmlnaHQ6ICAgbXVsKCByaWdodElucHV0LCBwZWVrKCBnZW4uZ2xvYmFscy5wYW5SLCBwYW4sIHsgYm91bmRtb2RlOidjbGFtcCcgfSkgKVxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6ICdwYXJhbScsXG5cbiAgZ2VuKCkge1xuICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG4gICAgXG4gICAgZ2VuLnBhcmFtcy5hZGQoIHRoaXMgKVxuXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuXG4gICAgaWYoIGlzV29ya2xldCApIGdlbi5wYXJhbWV0ZXJzLmFkZCggdGhpcy5uYW1lIClcblxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmluaXRpYWxWYWx1ZVxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gaXNXb3JrbGV0ID8gdGhpcy5uYW1lIDogYG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dYFxuXG4gICAgcmV0dXJuIGdlbi5tZW1vWyB0aGlzLm5hbWUgXVxuICB9IFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggcHJvcE5hbWU9MCwgdmFsdWU9MCwgbWluPTAsIG1heD0xICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgXG4gIGlmKCB0eXBlb2YgcHJvcE5hbWUgIT09ICdzdHJpbmcnICkge1xuICAgIHVnZW4ubmFtZSA9IHVnZW4uYmFzZW5hbWUgKyBnZW4uZ2V0VUlEKClcbiAgICB1Z2VuLmluaXRpYWxWYWx1ZSA9IHByb3BOYW1lXG4gIH1lbHNle1xuICAgIHVnZW4ubmFtZSA9IHByb3BOYW1lXG4gICAgdWdlbi5pbml0aWFsVmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgdWdlbi5taW4gPSBtaW5cbiAgdWdlbi5tYXggPSBtYXhcbiAgdWdlbi5kZWZhdWx0VmFsdWUgPSB1Z2VuLmluaXRpYWxWYWx1ZVxuXG4gIC8vIGZvciBzdG9yaW5nIHdvcmtsZXQgbm9kZXMgb25jZSB0aGV5J3JlIGluc3RhbnRpYXRlZFxuICB1Z2VuLndhYXBpID0gbnVsbFxuXG4gIHVnZW4uaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ3ZhbHVlJywge1xuICAgIGdldCgpIHtcbiAgICAgIGlmKCB0aGlzLm1lbW9yeS52YWx1ZS5pZHggIT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdXG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQoIHYgKSB7XG4gICAgICBpZiggdGhpcy5tZW1vcnkudmFsdWUuaWR4ICE9PSBudWxsICkge1xuICAgICAgICBpZiggdGhpcy5pc1dvcmtsZXQgJiYgdGhpcy53YWFwaSAhPT0gbnVsbCApIHtcbiAgICAgICAgICB0aGlzLndhYXBpLnZhbHVlID0gdlxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdID0gdlxuICAgICAgICB9IFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICB1Z2VuLm1lbW9yeSA9IHtcbiAgICB2YWx1ZTogeyBsZW5ndGg6MSwgaWR4Om51bGwgfVxuICB9XG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIlxuY29uc3QgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgICBkYXRhVWdlbiA9IHJlcXVpcmUoJy4vZGF0YS5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3BlZWsnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgZ2VuTmFtZSA9ICdnZW4uJyArIHRoaXMubmFtZSxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXQsIGZ1bmN0aW9uQm9keSwgbmV4dCwgbGVuZ3RoSXNMb2cyLCBpZHhcbiAgICBcbiAgICBpZHggPSBpbnB1dHNbMV1cbiAgICBsZW5ndGhJc0xvZzIgPSAoTWF0aC5sb2cyKCB0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCApIHwgMCkgID09PSBNYXRoLmxvZzIoIHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoIClcblxuICAgIGlmKCB0aGlzLm1vZGUgIT09ICdzaW1wbGUnICkge1xuXG4gICAgZnVuY3Rpb25Cb2R5ID0gYCAgdmFyICR7dGhpcy5uYW1lfV9kYXRhSWR4ICA9ICR7aWR4fSwgXG4gICAgICAke3RoaXMubmFtZX1fcGhhc2UgPSAke3RoaXMubW9kZSA9PT0gJ3NhbXBsZXMnID8gaW5wdXRzWzBdIDogaW5wdXRzWzBdICsgJyAqICcgKyAodGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGgpIH0sIFxuICAgICAgJHt0aGlzLm5hbWV9X2luZGV4ID0gJHt0aGlzLm5hbWV9X3BoYXNlIHwgMCxcXG5gXG5cbiAgICBpZiggdGhpcy5ib3VuZG1vZGUgPT09ICd3cmFwJyApIHtcbiAgICAgIG5leHQgPSBsZW5ndGhJc0xvZzIgP1xuICAgICAgYCggJHt0aGlzLm5hbWV9X2luZGV4ICsgMSApICYgKCR7dGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGh9IC0gMSlgIDpcbiAgICAgIGAke3RoaXMubmFtZX1faW5kZXggKyAxID49ICR7dGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGh9ID8gJHt0aGlzLm5hbWV9X2luZGV4ICsgMSAtICR7dGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGh9IDogJHt0aGlzLm5hbWV9X2luZGV4ICsgMWBcbiAgICB9ZWxzZSBpZiggdGhpcy5ib3VuZG1vZGUgPT09ICdjbGFtcCcgKSB7XG4gICAgICBuZXh0ID0gXG4gICAgICAgIGAke3RoaXMubmFtZX1faW5kZXggKyAxID49ICR7dGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGggLSAxfSA/ICR7dGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGggLSAxfSA6ICR7dGhpcy5uYW1lfV9pbmRleCArIDFgXG4gICAgfSBlbHNlIGlmKCB0aGlzLmJvdW5kbW9kZSA9PT0gJ2ZvbGQnIHx8IHRoaXMuYm91bmRtb2RlID09PSAnbWlycm9yJyApIHtcbiAgICAgIG5leHQgPSBcbiAgICAgICAgYCR7dGhpcy5uYW1lfV9pbmRleCArIDEgPj0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDF9ID8gJHt0aGlzLm5hbWV9X2luZGV4IC0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDF9IDogJHt0aGlzLm5hbWV9X2luZGV4ICsgMWBcbiAgICB9ZWxzZXtcbiAgICAgICBuZXh0ID0gXG4gICAgICBgJHt0aGlzLm5hbWV9X2luZGV4ICsgMWAgICAgIFxuICAgIH1cblxuICAgIGlmKCB0aGlzLmludGVycCA9PT0gJ2xpbmVhcicgKSB7ICAgICAgXG4gICAgZnVuY3Rpb25Cb2R5ICs9IGAgICAgICAke3RoaXMubmFtZX1fZnJhYyAgPSAke3RoaXMubmFtZX1fcGhhc2UgLSAke3RoaXMubmFtZX1faW5kZXgsXG4gICAgICAke3RoaXMubmFtZX1fYmFzZSAgPSBtZW1vcnlbICR7dGhpcy5uYW1lfV9kYXRhSWR4ICsgICR7dGhpcy5uYW1lfV9pbmRleCBdLFxuICAgICAgJHt0aGlzLm5hbWV9X25leHQgID0gJHtuZXh0fSxgXG4gICAgICBcbiAgICAgIGlmKCB0aGlzLmJvdW5kbW9kZSA9PT0gJ2lnbm9yZScgKSB7XG4gICAgICAgIGZ1bmN0aW9uQm9keSArPSBgXG4gICAgICAke3RoaXMubmFtZX1fb3V0ICAgPSAke3RoaXMubmFtZX1faW5kZXggPj0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDF9IHx8ICR7dGhpcy5uYW1lfV9pbmRleCA8IDAgPyAwIDogJHt0aGlzLm5hbWV9X2Jhc2UgKyAke3RoaXMubmFtZX1fZnJhYyAqICggbWVtb3J5WyAke3RoaXMubmFtZX1fZGF0YUlkeCArICR7dGhpcy5uYW1lfV9uZXh0IF0gLSAke3RoaXMubmFtZX1fYmFzZSApXFxuXFxuYFxuICAgICAgfWVsc2V7XG4gICAgICAgIGZ1bmN0aW9uQm9keSArPSBgXG4gICAgICAke3RoaXMubmFtZX1fb3V0ICAgPSAke3RoaXMubmFtZX1fYmFzZSArICR7dGhpcy5uYW1lfV9mcmFjICogKCBtZW1vcnlbICR7dGhpcy5uYW1lfV9kYXRhSWR4ICsgJHt0aGlzLm5hbWV9X25leHQgXSAtICR7dGhpcy5uYW1lfV9iYXNlIClcXG5cXG5gXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBmdW5jdGlvbkJvZHkgKz0gYCAgICAgICR7dGhpcy5uYW1lfV9vdXQgPSBtZW1vcnlbICR7dGhpcy5uYW1lfV9kYXRhSWR4ICsgJHt0aGlzLm5hbWV9X2luZGV4IF1cXG5cXG5gXG4gICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gbW9kZSBpcyBzaW1wbGVcbiAgICAgIGZ1bmN0aW9uQm9keSA9IGBtZW1vcnlbICR7aWR4fSArICR7IGlucHV0c1swXSB9IF1gXG4gICAgICBcbiAgICAgIHJldHVybiBmdW5jdGlvbkJvZHlcbiAgICB9XG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWUgKyAnX291dCdcblxuICAgIHJldHVybiBbIHRoaXMubmFtZSsnX291dCcsIGZ1bmN0aW9uQm9keSBdXG4gIH0sXG5cbiAgZGVmYXVsdHMgOiB7IGNoYW5uZWxzOjEsIG1vZGU6J3BoYXNlJywgaW50ZXJwOidsaW5lYXInLCBib3VuZG1vZGU6J3dyYXAnIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGlucHV0X2RhdGEsIGluZGV4PTAsIHByb3BlcnRpZXMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIC8vY29uc29sZS5sb2coIGRhdGFVZ2VuLCBnZW4uZGF0YSApXG5cbiAgLy8gWFhYIHdoeSBpcyBkYXRhVWdlbiBub3QgdGhlIGFjdHVhbCBmdW5jdGlvbj8gc29tZSB0eXBlIG9mIGJyb3dzZXJpZnkgbm9uc2Vuc2UuLi5cbiAgY29uc3QgZmluYWxEYXRhID0gdHlwZW9mIGlucHV0X2RhdGEuYmFzZW5hbWUgPT09ICd1bmRlZmluZWQnID8gZ2VuLmxpYi5kYXRhKCBpbnB1dF9kYXRhICkgOiBpbnB1dF9kYXRhXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgXG4gICAgeyBcbiAgICAgICdkYXRhJzogICAgIGZpbmFsRGF0YSxcbiAgICAgIGRhdGFOYW1lOiAgIGZpbmFsRGF0YS5uYW1lLFxuICAgICAgdWlkOiAgICAgICAgZ2VuLmdldFVJRCgpLFxuICAgICAgaW5wdXRzOiAgICAgWyBpbmRleCwgZmluYWxEYXRhIF0sXG4gICAgfSxcbiAgICBwcm90by5kZWZhdWx0cyxcbiAgICBwcm9wZXJ0aWVzIFxuICApXG4gIFxuICB1Z2VuLm5hbWUgPSB1Z2VuLmJhc2VuYW1lICsgdWdlbi51aWRcblxuICByZXR1cm4gdWdlblxufVxuXG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGFjY3VtID0gcmVxdWlyZSggJy4vYWNjdW0uanMnICksXG4gICAgbXVsICAgPSByZXF1aXJlKCAnLi9tdWwuanMnICksXG4gICAgcHJvdG8gPSB7IGJhc2VuYW1lOidwaGFzb3InIH0sXG4gICAgZGl2ICAgPSByZXF1aXJlKCAnLi9kaXYuanMnIClcblxuY29uc3QgZGVmYXVsdHMgPSB7IG1pbjogLTEsIG1heDogMSB9XG5cbm1vZHVsZS5leHBvcnRzID0gKCBmcmVxdWVuY3kgPSAxLCByZXNldCA9IDAsIF9wcm9wcyApID0+IHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdHMsIF9wcm9wcyApXG5cbiAgY29uc3QgcmFuZ2UgPSBwcm9wcy5tYXggLSBwcm9wcy5taW5cblxuICBjb25zdCB1Z2VuID0gdHlwZW9mIGZyZXF1ZW5jeSA9PT0gJ251bWJlcicgXG4gICAgPyBhY2N1bSggKGZyZXF1ZW5jeSAqIHJhbmdlKSAvIGdlbi5zYW1wbGVyYXRlLCByZXNldCwgcHJvcHMgKSBcbiAgICA6IGFjY3VtKCBcbiAgICAgICAgZGl2KCBcbiAgICAgICAgICBtdWwoIGZyZXF1ZW5jeSwgcmFuZ2UgKSxcbiAgICAgICAgICBnZW4uc2FtcGxlcmF0ZVxuICAgICAgICApLCBcbiAgICAgICAgcmVzZXQsIHByb3BzIFxuICAgIClcblxuICB1Z2VuLm5hbWUgPSBwcm90by5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpLFxuICAgIG11bCAgPSByZXF1aXJlKCcuL211bC5qcycpLFxuICAgIHdyYXAgPSByZXF1aXJlKCcuL3dyYXAuanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidwb2tlJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGRhdGFOYW1lID0gJ21lbW9yeScsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgaWR4LCBvdXQsIHdyYXBwZWRcbiAgICBcbiAgICBpZHggPSB0aGlzLmRhdGEuZ2VuKClcblxuICAgIC8vZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcbiAgICAvL3dyYXBwZWQgPSB3cmFwKCB0aGlzLmlucHV0c1sxXSwgMCwgdGhpcy5kYXRhTGVuZ3RoICkuZ2VuKClcbiAgICAvL2lkeCA9IHdyYXBwZWRbMF1cbiAgICAvL2dlbi5mdW5jdGlvbkJvZHkgKz0gd3JhcHBlZFsxXVxuICAgIGxldCBvdXRwdXRTdHIgPSB0aGlzLmlucHV0c1sxXSA9PT0gMCA/XG4gICAgICBgICAke2RhdGFOYW1lfVsgJHtpZHh9IF0gPSAke2lucHV0c1swXX1cXG5gIDpcbiAgICAgIGAgICR7ZGF0YU5hbWV9WyAke2lkeH0gKyAke2lucHV0c1sxXX0gXSA9ICR7aW5wdXRzWzBdfVxcbmBcblxuICAgIGlmKCB0aGlzLmlubGluZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgZ2VuLmZ1bmN0aW9uQm9keSArPSBvdXRwdXRTdHJcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBbIHRoaXMuaW5saW5lLCBvdXRwdXRTdHIgXVxuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSAoIGRhdGEsIHZhbHVlLCBpbmRleCwgcHJvcGVydGllcyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgZGVmYXVsdHMgPSB7IGNoYW5uZWxzOjEgfSBcblxuICBpZiggcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICkgT2JqZWN0LmFzc2lnbiggZGVmYXVsdHMsIHByb3BlcnRpZXMgKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgZGF0YSxcbiAgICBkYXRhTmFtZTogICBkYXRhLm5hbWUsXG4gICAgZGF0YUxlbmd0aDogZGF0YS5idWZmZXIubGVuZ3RoLFxuICAgIHVpZDogICAgICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICAgICBbIHZhbHVlLCBpbmRleCBdLFxuICB9LFxuICBkZWZhdWx0cyApXG5cblxuICB1Z2VuLm5hbWUgPSB1Z2VuLmJhc2VuYW1lICsgdWdlbi51aWRcbiAgXG4gIGdlbi5oaXN0b3JpZXMuc2V0KCB1Z2VuLm5hbWUsIHVnZW4gKVxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3BvdycsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApIHx8IGlzTmFOKCBpbnB1dHNbMV0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyAncG93JzogaXNXb3JrbGV0ID8gJ01hdGgucG93JyA6IE1hdGgucG93IH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1wb3coICR7aW5wdXRzWzBdfSwgJHtpbnB1dHNbMV19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCB0eXBlb2YgaW5wdXRzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dHNbMF1bMF0gPT09ICcoJyApIHtcbiAgICAgICAgaW5wdXRzWzBdID0gaW5wdXRzWzBdLnNsaWNlKDEsLTEpXG4gICAgICB9XG4gICAgICBpZiggdHlwZW9mIGlucHV0c1sxXSA9PT0gJ3N0cmluZycgJiYgaW5wdXRzWzFdWzBdID09PSAnKCcgKSB7XG4gICAgICAgIGlucHV0c1sxXSA9IGlucHV0c1sxXS5zbGljZSgxLC0xKVxuICAgICAgfVxuXG4gICAgICBvdXQgPSBNYXRoLnBvdyggcGFyc2VGbG9hdCggaW5wdXRzWzBdICksIHBhcnNlRmxvYXQoIGlucHV0c1sxXSkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeCx5KSA9PiB7XG4gIGxldCBwb3cgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgcG93LmlucHV0cyA9IFsgeCx5IF1cbiAgcG93LmlkID0gZ2VuLmdldFVJRCgpXG4gIHBvdy5uYW1lID0gYCR7cG93LmJhc2VuYW1lfXtwb3cuaWR9YFxuXG4gIHJldHVybiBwb3dcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcbmNvbnN0IHByb3RvID0ge1xuICBiYXNlbmFtZToncHJvY2VzcycsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsnJyt0aGlzLmZ1bmNuYW1lXSA6IHRoaXMuZnVuYyB9KVxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGdlblsnJHt0aGlzLmZ1bmNuYW1lfSddKGBcblxuICAgIGlucHV0cy5mb3JFYWNoKCAodixpLGFyciApID0+IHtcbiAgICAgIG91dCArPSBhcnJbIGkgXVxuICAgICAgaWYoIGkgPCBhcnIubGVuZ3RoIC0gMSApIG91dCArPSAnLCdcbiAgICB9KVxuXG4gICAgb3V0ICs9ICcpXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gW3RoaXMubmFtZSwgb3V0XVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHByb2Nlc3MgPSB7fS8vIE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgY29uc3QgaWQgPSBnZW4uZ2V0VUlEKClcbiAgcHJvY2Vzcy5uYW1lID0gJ3Byb2Nlc3MnICsgaWQgXG5cbiAgcHJvY2Vzcy5mdW5jID0gbmV3IEZ1bmN0aW9uKCAuLi5hcmdzIClcblxuICAvL2dlbi5nbG9iYWxzWyBwcm9jZXNzLm5hbWUgXSA9IHByb2Nlc3MuZnVuY1xuXG4gIHByb2Nlc3MuY2FsbCA9IGZ1bmN0aW9uKCAuLi5hcmdzICApIHtcbiAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gICAgb3V0cHV0LmZ1bmNuYW1lID0gcHJvY2Vzcy5uYW1lXG4gICAgb3V0cHV0LmZ1bmMgPSBwcm9jZXNzLmZ1bmNcbiAgICBvdXRwdXQubmFtZSA9ICdwcm9jZXNzX291dF8nICsgaWRcbiAgICBvdXRwdXQucHJvY2VzcyA9IHByb2Nlc3NcblxuICAgIG91dHB1dC5pbnB1dHMgPSBhcmdzXG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICByZXR1cm4gcHJvY2VzcyBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBoaXN0b3J5ID0gcmVxdWlyZSggJy4vaGlzdG9yeS5qcycgKSxcbiAgICBzdWIgICAgID0gcmVxdWlyZSggJy4vc3ViLmpzJyApLFxuICAgIGFkZCAgICAgPSByZXF1aXJlKCAnLi9hZGQuanMnICksXG4gICAgbXVsICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBtZW1vICAgID0gcmVxdWlyZSggJy4vbWVtby5qcycgKSxcbiAgICBkZWx0YSAgID0gcmVxdWlyZSggJy4vZGVsdGEuanMnICksXG4gICAgd3JhcCAgICA9IHJlcXVpcmUoICcuL3dyYXAuanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZToncmF0ZScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIHBoYXNlICA9IGhpc3RvcnkoKSxcbiAgICAgICAgaW5NaW51czEgPSBoaXN0b3J5KCksXG4gICAgICAgIGdlbk5hbWUgPSAnZ2VuLicgKyB0aGlzLm5hbWUsXG4gICAgICAgIGZpbHRlciwgc3VtLCBvdXRcblxuICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiB0aGlzIH0pIFxuXG4gICAgb3V0ID0gXG5gIHZhciAke3RoaXMubmFtZX1fZGlmZiA9ICR7aW5wdXRzWzBdfSAtICR7Z2VuTmFtZX0ubGFzdFNhbXBsZVxuICBpZiggJHt0aGlzLm5hbWV9X2RpZmYgPCAtLjUgKSAke3RoaXMubmFtZX1fZGlmZiArPSAxXG4gICR7Z2VuTmFtZX0ucGhhc2UgKz0gJHt0aGlzLm5hbWV9X2RpZmYgKiAke2lucHV0c1sxXX1cbiAgaWYoICR7Z2VuTmFtZX0ucGhhc2UgPiAxICkgJHtnZW5OYW1lfS5waGFzZSAtPSAxXG4gICR7Z2VuTmFtZX0ubGFzdFNhbXBsZSA9ICR7aW5wdXRzWzBdfVxuYFxuICAgIG91dCA9ICcgJyArIG91dFxuXG4gICAgcmV0dXJuIFsgZ2VuTmFtZSArICcucGhhc2UnLCBvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIHJhdGUgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgcGhhc2U6ICAgICAgMCxcbiAgICBsYXN0U2FtcGxlOiAwLFxuICAgIHVpZDogICAgICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICAgICBbIGluMSwgcmF0ZSBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J3JvdW5kJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiBpc1dvcmtsZXQgPyAnTWF0aC5yb3VuZCcgOiBNYXRoLnJvdW5kIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1yb3VuZCggJHtpbnB1dHNbMF19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IHJvdW5kID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIHJvdW5kLmlucHV0cyA9IFsgeCBdXG5cbiAgcmV0dXJuIHJvdW5kXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonc2FoJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSwgb3V0XG5cbiAgICAvL2dlbi5kYXRhWyB0aGlzLm5hbWUgXSA9IDBcbiAgICAvL2dlbi5kYXRhWyB0aGlzLm5hbWUgKyAnX2NvbnRyb2wnIF0gPSAwXG5cbiAgICBnZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5tZW1vcnkgKVxuXG5cbiAgICBvdXQgPSBcbmAgdmFyICR7dGhpcy5uYW1lfV9jb250cm9sID0gbWVtb3J5WyR7dGhpcy5tZW1vcnkuY29udHJvbC5pZHh9XSxcbiAgICAgICR7dGhpcy5uYW1lfV90cmlnZ2VyID0gJHtpbnB1dHNbMV19ID4gJHtpbnB1dHNbMl19ID8gMSA6IDBcblxuICBpZiggJHt0aGlzLm5hbWV9X3RyaWdnZXIgIT09ICR7dGhpcy5uYW1lfV9jb250cm9sICApIHtcbiAgICBpZiggJHt0aGlzLm5hbWV9X3RyaWdnZXIgPT09IDEgKSBcbiAgICAgIG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dID0gJHtpbnB1dHNbMF19XG4gICAgXG4gICAgbWVtb3J5WyR7dGhpcy5tZW1vcnkuY29udHJvbC5pZHh9XSA9ICR7dGhpcy5uYW1lfV90cmlnZ2VyXG4gIH1cbmBcbiAgICBcbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1gLy9gZ2VuLmRhdGEuJHt0aGlzLm5hbWV9YFxuXG4gICAgcmV0dXJuIFsgYG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dYCwgJyAnICtvdXQgXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIGNvbnRyb2wsIHRocmVzaG9sZD0wLCBwcm9wZXJ0aWVzICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICksXG4gICAgICBkZWZhdWx0cyA9IHsgaW5pdDowIH1cblxuICBpZiggcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICkgT2JqZWN0LmFzc2lnbiggZGVmYXVsdHMsIHByb3BlcnRpZXMgKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgbGFzdFNhbXBsZTogMCxcbiAgICB1aWQ6ICAgICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgICAgWyBpbjEsIGNvbnRyb2wsdGhyZXNob2xkIF0sXG4gICAgbWVtb3J5OiB7XG4gICAgICBjb250cm9sOiB7IGlkeDpudWxsLCBsZW5ndGg6MSB9LFxuICAgICAgdmFsdWU6ICAgeyBpZHg6bnVsbCwgbGVuZ3RoOjEgfSxcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzIClcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3NlbGVjdG9yJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSwgb3V0LCByZXR1cm5WYWx1ZSA9IDBcbiAgICBcbiAgICBzd2l0Y2goIGlucHV0cy5sZW5ndGggKSB7XG4gICAgICBjYXNlIDIgOlxuICAgICAgICByZXR1cm5WYWx1ZSA9IGlucHV0c1sxXVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyA6XG4gICAgICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX1fb3V0ID0gJHtpbnB1dHNbMF19ID09PSAxID8gJHtpbnB1dHNbMV19IDogJHtpbnB1dHNbMl19XFxuXFxuYDtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBbIHRoaXMubmFtZSArICdfb3V0Jywgb3V0IF1cbiAgICAgICAgYnJlYWs7ICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCA9IFxuYCB2YXIgJHt0aGlzLm5hbWV9X291dCA9IDBcbiAgc3dpdGNoKCAke2lucHV0c1swXX0gKyAxICkge1xcbmBcblxuICAgICAgICBmb3IoIGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIG91dCArPWAgICAgY2FzZSAke2l9OiAke3RoaXMubmFtZX1fb3V0ID0gJHtpbnB1dHNbaV19OyBicmVhaztcXG5gIFxuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9ICcgIH1cXG5cXG4nXG4gICAgICAgIFxuICAgICAgICByZXR1cm5WYWx1ZSA9IFsgdGhpcy5uYW1lICsgJ19vdXQnLCAnICcgKyBvdXQgXVxuICAgIH1cblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZSArICdfb3V0J1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlXG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCAuLi5pbnB1dHMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBcbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHNcbiAgfSlcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgYWNjdW0gPSByZXF1aXJlKCAnLi9hY2N1bS5qcycgKSxcbiAgICBjb3VudGVyPSByZXF1aXJlKCAnLi9jb3VudGVyLmpzJyApLFxuICAgIHBlZWsgID0gcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgICBzc2QgICA9IHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gICAgZGF0YSAgPSByZXF1aXJlKCAnLi9kYXRhLmpzJyApLFxuICAgIHByb3RvID0geyBiYXNlbmFtZTonc2VxJyB9XG5cbm1vZHVsZS5leHBvcnRzID0gKCBkdXJhdGlvbnMgPSAxMTAyNSwgdmFsdWVzID0gWzAsMV0sIHBoYXNlSW5jcmVtZW50ID0gMSkgPT4ge1xuICBsZXQgY2xvY2tcbiAgXG4gIGlmKCBBcnJheS5pc0FycmF5KCBkdXJhdGlvbnMgKSApIHtcbiAgICAvLyB3ZSB3YW50IGEgY291bnRlciB0aGF0IGlzIHVzaW5nIG91ciBjdXJyZW50XG4gICAgLy8gcmF0ZSB2YWx1ZSwgYnV0IHdlIHdhbnQgdGhlIHJhdGUgdmFsdWUgdG8gYmUgZGVyaXZlZCBmcm9tXG4gICAgLy8gdGhlIGNvdW50ZXIuIG11c3QgaW5zZXJ0IGEgc2luZ2xlLXNhbXBsZSBkZWFseSB0byBhdm9pZFxuICAgIC8vIGluZmluaXRlIGxvb3AuXG4gICAgY29uc3QgY2xvY2syID0gY291bnRlciggMCwgMCwgZHVyYXRpb25zLmxlbmd0aCApXG4gICAgY29uc3QgX19kdXJhdGlvbnMgPSBwZWVrKCBkYXRhKCBkdXJhdGlvbnMgKSwgY2xvY2syLCB7IG1vZGU6J3NpbXBsZScgfSkgXG4gICAgY2xvY2sgPSBjb3VudGVyKCBwaGFzZUluY3JlbWVudCwgMCwgX19kdXJhdGlvbnMgKVxuICAgIFxuICAgIC8vIGFkZCBvbmUgc2FtcGxlIGRlbGF5IHRvIGF2b2lkIGNvZGVnZW4gbG9vcFxuICAgIGNvbnN0IHMgPSBzc2QoKVxuICAgIHMuaW4oIGNsb2NrLndyYXAgKVxuICAgIGNsb2NrMi5pbnB1dHNbMF0gPSBzLm91dFxuICB9ZWxzZXtcbiAgICAvLyBpZiB0aGUgcmF0ZSBhcmd1bWVudCBpcyBhIHNpbmdsZSB2YWx1ZSB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gZG8gYW55dGhpbmcgdHJpY2t5LlxuICAgIGNsb2NrID0gY291bnRlciggcGhhc2VJbmNyZW1lbnQsIDAsIGR1cmF0aW9ucyApXG4gIH1cbiAgXG4gIGNvbnN0IHN0ZXBwZXIgPSBhY2N1bSggY2xvY2sud3JhcCwgMCwgeyBtaW46MCwgbWF4OnZhbHVlcy5sZW5ndGggfSlcbiAgIFxuICBjb25zdCB1Z2VuID0gcGVlayggZGF0YSggdmFsdWVzICksIHN0ZXBwZXIsIHsgbW9kZTonc2ltcGxlJyB9KVxuXG4gIHVnZW4ubmFtZSA9IHByb3RvLmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpXG4gIHVnZW4udHJpZ2dlciA9IGNsb2NrLndyYXBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J3NpZ24nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IGlzV29ya2xldCA/ICdNYXRoLnNpZ24nIDogTWF0aC5zaWduIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1zaWduKCAke2lucHV0c1swXX0gKWBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLnNpZ24oIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBzaWduID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIHNpZ24uaW5wdXRzID0gWyB4IF1cblxuICByZXR1cm4gc2lnblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidzaW4nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyAnc2luJzogaXNXb3JrbGV0ID8gJ01hdGguc2luJyA6IE1hdGguc2luIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1zaW4oICR7aW5wdXRzWzBdfSApYCBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLnNpbiggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IHNpbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBzaW4uaW5wdXRzID0gWyB4IF1cbiAgc2luLmlkID0gZ2VuLmdldFVJRCgpXG4gIHNpbi5uYW1lID0gYCR7c2luLmJhc2VuYW1lfXtzaW4uaWR9YFxuXG4gIHJldHVybiBzaW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBoaXN0b3J5ID0gcmVxdWlyZSggJy4vaGlzdG9yeS5qcycgKSxcbiAgICBzdWIgICAgID0gcmVxdWlyZSggJy4vc3ViLmpzJyApLFxuICAgIGFkZCAgICAgPSByZXF1aXJlKCAnLi9hZGQuanMnICksXG4gICAgbXVsICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBtZW1vICAgID0gcmVxdWlyZSggJy4vbWVtby5qcycgKSxcbiAgICBndCAgICAgID0gcmVxdWlyZSggJy4vZ3QuanMnICksXG4gICAgZGl2ICAgICA9IHJlcXVpcmUoICcuL2Rpdi5qcycgKSxcbiAgICBfc3dpdGNoID0gcmVxdWlyZSggJy4vc3dpdGNoLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIHNsaWRlVXAgPSAxLCBzbGlkZURvd24gPSAxICkgPT4ge1xuICBsZXQgeTEgPSBoaXN0b3J5KDApLFxuICAgICAgZmlsdGVyLCBzbGlkZUFtb3VudFxuXG4gIC8veSAobikgPSB5IChuLTEpICsgKCh4IChuKSAtIHkgKG4tMSkpL3NsaWRlKSBcbiAgc2xpZGVBbW91bnQgPSBfc3dpdGNoKCBndChpbjEseTEub3V0KSwgc2xpZGVVcCwgc2xpZGVEb3duIClcblxuICBmaWx0ZXIgPSBtZW1vKCBhZGQoIHkxLm91dCwgZGl2KCBzdWIoIGluMSwgeTEub3V0ICksIHNsaWRlQW1vdW50ICkgKSApXG5cbiAgeTEuaW4oIGZpbHRlciApXG5cbiAgcmV0dXJuIGZpbHRlclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxuY29uc3QgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidzdWInLFxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgb3V0PTAsXG4gICAgICAgIGRpZmYgPSAwLFxuICAgICAgICBuZWVkc1BhcmVucyA9IGZhbHNlLCBcbiAgICAgICAgbnVtQ291bnQgPSAwLFxuICAgICAgICBsYXN0TnVtYmVyID0gaW5wdXRzWyAwIF0sXG4gICAgICAgIGxhc3ROdW1iZXJJc1VnZW4gPSBpc05hTiggbGFzdE51bWJlciApLCBcbiAgICAgICAgc3ViQXRFbmQgPSBmYWxzZSxcbiAgICAgICAgaGFzVWdlbnMgPSBmYWxzZSxcbiAgICAgICAgcmV0dXJuVmFsdWUgPSAwXG5cbiAgICB0aGlzLmlucHV0cy5mb3JFYWNoKCB2YWx1ZSA9PiB7IGlmKCBpc05hTiggdmFsdWUgKSApIGhhc1VnZW5zID0gdHJ1ZSB9KVxuXG4gICAgb3V0ID0gJyAgdmFyICcgKyB0aGlzLm5hbWUgKyAnID0gJ1xuXG4gICAgaW5wdXRzLmZvckVhY2goICh2LGkpID0+IHtcbiAgICAgIGlmKCBpID09PSAwICkgcmV0dXJuXG5cbiAgICAgIGxldCBpc051bWJlclVnZW4gPSBpc05hTiggdiApLFxuICAgICAgICAgIGlzRmluYWxJZHggICA9IGkgPT09IGlucHV0cy5sZW5ndGggLSAxXG5cbiAgICAgIGlmKCAhbGFzdE51bWJlcklzVWdlbiAmJiAhaXNOdW1iZXJVZ2VuICkge1xuICAgICAgICBsYXN0TnVtYmVyID0gbGFzdE51bWJlciAtIHZcbiAgICAgICAgb3V0ICs9IGxhc3ROdW1iZXJcbiAgICAgICAgcmV0dXJuXG4gICAgICB9ZWxzZXtcbiAgICAgICAgbmVlZHNQYXJlbnMgPSB0cnVlXG4gICAgICAgIG91dCArPSBgJHtsYXN0TnVtYmVyfSAtICR7dn1gXG4gICAgICB9XG5cbiAgICAgIGlmKCAhaXNGaW5hbElkeCApIG91dCArPSAnIC0gJyBcbiAgICB9KVxuXG4gICAgb3V0ICs9ICdcXG4nXG5cbiAgICByZXR1cm5WYWx1ZSA9IFsgdGhpcy5uYW1lLCBvdXQgXVxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCAuLi5hcmdzICkgPT4ge1xuICBsZXQgc3ViID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHN1Yiwge1xuICAgIGlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogYXJnc1xuICB9KVxuICAgICAgIFxuICBzdWIubmFtZSA9ICdzdWInICsgc3ViLmlkXG5cbiAgcmV0dXJuIHN1YlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonc3dpdGNoJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSwgb3V0XG5cbiAgICBpZiggaW5wdXRzWzFdID09PSBpbnB1dHNbMl0gKSByZXR1cm4gaW5wdXRzWzFdIC8vIGlmIGJvdGggcG90ZW50aWFsIG91dHB1dHMgYXJlIHRoZSBzYW1lIGp1c3QgcmV0dXJuIG9uZSBvZiB0aGVtXG4gICAgXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfV9vdXQgPSAke2lucHV0c1swXX0gPT09IDEgPyAke2lucHV0c1sxXX0gOiAke2lucHV0c1syXX1cXG5gXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgJHt0aGlzLm5hbWV9X291dGBcblxuICAgIHJldHVybiBbIGAke3RoaXMubmFtZX1fb3V0YCwgb3V0IF1cbiAgfSxcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggY29udHJvbCwgaW4xID0gMSwgaW4yID0gMCApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBjb250cm9sLCBpbjEsIGluMiBdLFxuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOid0NjAnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIHJldHVyblZhbHVlXG5cbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbICdleHAnIF06IGlzV29ya2xldCA/ICdNYXRoLmV4cCcgOiBNYXRoLmV4cCB9KVxuXG4gICAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gJHtyZWZ9ZXhwKCAtNi45MDc3NTUyNzg5MjEgLyAke2lucHV0c1swXX0gKVxcblxcbmBcbiAgICAgXG4gICAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBvdXRcbiAgICAgIFxuICAgICAgcmV0dXJuVmFsdWUgPSBbIHRoaXMubmFtZSwgb3V0IF1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5leHAoIC02LjkwNzc1NTI3ODkyMSAvIGlucHV0c1swXSApXG5cbiAgICAgIHJldHVyblZhbHVlID0gb3V0XG4gICAgfSAgICBcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCB0NjAgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgdDYwLmlucHV0cyA9IFsgeCBdXG4gIHQ2MC5uYW1lID0gcHJvdG8uYmFzZW5hbWUgKyBnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gdDYwXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3RhbicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICd0YW4nOiBpc1dvcmtsZXQgPyAnTWF0aC50YW4nIDogTWF0aC50YW4gfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXRhbiggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGgudGFuKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgdGFuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIHRhbi5pbnB1dHMgPSBbIHggXVxuICB0YW4uaWQgPSBnZW4uZ2V0VUlEKClcbiAgdGFuLm5hbWUgPSBgJHt0YW4uYmFzZW5hbWV9e3Rhbi5pZH1gXG5cbiAgcmV0dXJuIHRhblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOid0YW5oJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ3RhbmgnOiBpc1dvcmtsZXQgPyAnTWF0aC50YW4nIDogTWF0aC50YW5oIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn10YW5oKCAke2lucHV0c1swXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC50YW5oKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgdGFuaCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICB0YW5oLmlucHV0cyA9IFsgeCBdXG4gIHRhbmguaWQgPSBnZW4uZ2V0VUlEKClcbiAgdGFuaC5uYW1lID0gYCR7dGFuaC5iYXNlbmFtZX17dGFuaC5pZH1gXG5cbiAgcmV0dXJuIHRhbmhcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBsdCAgICAgID0gcmVxdWlyZSggJy4vbHQuanMnICksXG4gICAgYWNjdW0gICA9IHJlcXVpcmUoICcuL2FjY3VtLmpzJyApLFxuICAgIGRpdiAgICAgPSByZXF1aXJlKCAnLi9kaXYuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGZyZXF1ZW5jeT00NDAsIHB1bHNld2lkdGg9LjUgKSA9PiB7XG4gIGxldCBncmFwaCA9IGx0KCBhY2N1bSggZGl2KCBmcmVxdWVuY3ksIDQ0MTAwICkgKSwgcHVsc2V3aWR0aCApXG5cbiAgZ3JhcGgubmFtZSA9IGB0cmFpbiR7Z2VuLmdldFVJRCgpfWBcblxuICByZXR1cm4gZ3JhcGhcbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFXUEYgPSByZXF1aXJlKCAnLi9leHRlcm5hbC9hdWRpb3dvcmtsZXQtcG9seWZpbGwuanMnICksXG4gICAgICBnZW4gID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgICAgZGF0YSA9IHJlcXVpcmUoICcuL2RhdGEuanMnIClcblxubGV0IGlzU3RlcmVvID0gZmFsc2VcblxuY29uc3QgdXRpbGl0aWVzID0ge1xuICBjdHg6IG51bGwsXG4gIGJ1ZmZlcnM6IHt9LFxuICBpc1N0ZXJlbzpmYWxzZSxcblxuICBjbGVhcigpIHtcbiAgICBpZiggdGhpcy53b3JrbGV0Tm9kZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgdGhpcy53b3JrbGV0Tm9kZS5kaXNjb25uZWN0KClcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSAoKSA9PiAwXG4gICAgfVxuICAgIHRoaXMuY2xlYXIuY2FsbGJhY2tzLmZvckVhY2goIHYgPT4gdigpIClcbiAgICB0aGlzLmNsZWFyLmNhbGxiYWNrcy5sZW5ndGggPSAwXG5cbiAgICB0aGlzLmlzU3RlcmVvID0gZmFsc2VcblxuICAgIGlmKCBnZW4uZ3JhcGggIT09IG51bGwgKSBnZW4uZnJlZSggZ2VuLmdyYXBoIClcbiAgfSxcblxuICBjcmVhdGVDb250ZXh0KCBidWZmZXJTaXplID0gMjA0OCApIHtcbiAgICBjb25zdCBBQyA9IHR5cGVvZiBBdWRpb0NvbnRleHQgPT09ICd1bmRlZmluZWQnID8gd2Via2l0QXVkaW9Db250ZXh0IDogQXVkaW9Db250ZXh0XG4gICAgXG4gICAgLy8gdGVsbCBwb2x5ZmlsbCBnbG9iYWwgb2JqZWN0IGFuZCBidWZmZXJzaXplXG4gICAgQVdQRiggd2luZG93LCBidWZmZXJTaXplIClcblxuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYoIHR5cGVvZiBBQyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IEFDKHsgbGF0ZW5jeUhpbnQ6LjAxMjUgfSlcblxuICAgICAgICBnZW4uc2FtcGxlcmF0ZSA9IHRoaXMuY3R4LnNhbXBsZVJhdGVcblxuICAgICAgICBpZiggZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBzdGFydCApXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgc3RhcnQgKVxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHN0YXJ0IClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG15U291cmNlID0gdXRpbGl0aWVzLmN0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxuICAgICAgICBteVNvdXJjZS5jb25uZWN0KCB1dGlsaXRpZXMuY3R4LmRlc3RpbmF0aW9uIClcbiAgICAgICAgbXlTb3VyY2Uuc3RhcnQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgc3RhcnQgKVxuICAgIH1lbHNle1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBzdGFydCApXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBzdGFydCApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBjcmVhdGVTY3JpcHRQcm9jZXNzb3IoKSB7XG4gICAgdGhpcy5ub2RlID0gdGhpcy5jdHguY3JlYXRlU2NyaXB0UHJvY2Vzc29yKCAxMDI0LCAwLCAyIClcbiAgICB0aGlzLmNsZWFyRnVuY3Rpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIDAgfVxuICAgIGlmKCB0eXBlb2YgdGhpcy5jYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcgKSB0aGlzLmNhbGxiYWNrID0gdGhpcy5jbGVhckZ1bmN0aW9uXG5cbiAgICB0aGlzLm5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiggYXVkaW9Qcm9jZXNzaW5nRXZlbnQgKSB7XG4gICAgICB2YXIgb3V0cHV0QnVmZmVyID0gYXVkaW9Qcm9jZXNzaW5nRXZlbnQub3V0cHV0QnVmZmVyO1xuXG4gICAgICB2YXIgbGVmdCA9IG91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSggMCApLFxuICAgICAgICAgIHJpZ2h0PSBvdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoIDEgKSxcbiAgICAgICAgICBpc1N0ZXJlbyA9IHV0aWxpdGllcy5pc1N0ZXJlb1xuXG4gICAgIGZvciggdmFyIHNhbXBsZSA9IDA7IHNhbXBsZSA8IGxlZnQubGVuZ3RoOyBzYW1wbGUrKyApIHtcbiAgICAgICAgdmFyIG91dCA9IHV0aWxpdGllcy5jYWxsYmFjaygpXG5cbiAgICAgICAgaWYoIGlzU3RlcmVvID09PSBmYWxzZSApIHtcbiAgICAgICAgICBsZWZ0WyBzYW1wbGUgXSA9IHJpZ2h0WyBzYW1wbGUgXSA9IG91dCBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbGVmdFsgc2FtcGxlICBdID0gb3V0WzBdXG4gICAgICAgICAgcmlnaHRbIHNhbXBsZSBdID0gb3V0WzFdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5vZGUuY29ubmVjdCggdGhpcy5jdHguZGVzdGluYXRpb24gKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvLyByZW1vdmUgc3RhcnRpbmcgc3R1ZmYgYW5kIGFkZCB0YWJzXG4gIHByZXR0eVByaW50Q2FsbGJhY2soIGNiICkge1xuICAgIC8vIGdldCByaWQgb2YgXCJmdW5jdGlvbiBnZW5cIiBhbmQgc3RhcnQgd2l0aCBwYXJlbnRoZXNpc1xuICAgIC8vIGNvbnN0IHNob3J0ZW5kQ0IgPSBjYi50b1N0cmluZygpLnNsaWNlKDkpXG4gICAgY29uc3QgY2JTcGxpdCA9IGNiLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpXG4gICAgY29uc3QgY2JUcmltID0gY2JTcGxpdC5zbGljZSggMywgLTIgKVxuICAgIGNvbnN0IGNiVGFiYmVkID0gY2JUcmltLm1hcCggdiA9PiAnICAgICAgJyArIHYgKSBcbiAgICBcbiAgICByZXR1cm4gY2JUYWJiZWQuam9pbignXFxuJylcbiAgfSxcblxuICBjcmVhdGVQYXJhbWV0ZXJEZXNjcmlwdG9ycyggY2IgKSB7XG4gICAgLy8gW3tuYW1lOiAnYW1wbGl0dWRlJywgZGVmYXVsdFZhbHVlOiAwLjI1LCBtaW5WYWx1ZTogMCwgbWF4VmFsdWU6IDF9XTtcbiAgICBsZXQgcGFyYW1TdHIgPSAnJ1xuXG4gICAgLy9mb3IoIGxldCB1Z2VuIG9mIGNiLnBhcmFtcy52YWx1ZXMoKSApIHtcbiAgICAvLyAgcGFyYW1TdHIgKz0gYHsgbmFtZTonJHt1Z2VuLm5hbWV9JywgZGVmYXVsdFZhbHVlOiR7dWdlbi52YWx1ZX0sIG1pblZhbHVlOiR7dWdlbi5taW59LCBtYXhWYWx1ZToke3VnZW4ubWF4fSB9LFxcbiAgICAgIGBcbiAgICAvL31cbiAgICBmb3IoIGxldCB1Z2VuIG9mIGNiLnBhcmFtcy52YWx1ZXMoKSApIHtcbiAgICAgIHBhcmFtU3RyICs9IGB7IG5hbWU6JyR7dWdlbi5uYW1lfScsIGF1dG9tYXRpb25SYXRlOidrLXJhdGUnLCBkZWZhdWx0VmFsdWU6JHt1Z2VuLmRlZmF1bHRWYWx1ZX0sIG1pblZhbHVlOiR7dWdlbi5taW59LCBtYXhWYWx1ZToke3VnZW4ubWF4fSB9LFxcbiAgICAgIGBcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtU3RyXG4gIH0sXG5cbiAgY3JlYXRlUGFyYW1ldGVyRGVyZWZlcmVuY2VzKCBjYiApIHtcbiAgICBsZXQgc3RyID0gY2IucGFyYW1zLnNpemUgPiAwID8gJ1xcbiAgICAgICcgOiAnJ1xuICAgIGZvciggbGV0IHVnZW4gb2YgY2IucGFyYW1zLnZhbHVlcygpICkge1xuICAgICAgc3RyICs9IGBjb25zdCAke3VnZW4ubmFtZX0gPSBwYXJhbWV0ZXJzLiR7dWdlbi5uYW1lfVswXVxcbiAgICAgIGBcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH0sXG5cbiAgY3JlYXRlUGFyYW1ldGVyQXJndW1lbnRzKCBjYiApIHtcbiAgICBsZXQgIHBhcmFtTGlzdCA9ICcnXG4gICAgZm9yKCBsZXQgdWdlbiBvZiBjYi5wYXJhbXMudmFsdWVzKCkgKSB7XG4gICAgICBwYXJhbUxpc3QgKz0gdWdlbi5uYW1lICsgJ1tpXSwnXG4gICAgfVxuICAgIHBhcmFtTGlzdCA9IHBhcmFtTGlzdC5zbGljZSggMCwgLTEgKVxuXG4gICAgcmV0dXJuIHBhcmFtTGlzdFxuICB9LFxuXG4gIGNyZWF0ZUlucHV0RGVyZWZlcmVuY2VzKCBjYiApIHtcbiAgICBsZXQgc3RyID0gY2IuaW5wdXRzLnNpemUgPiAwID8gJ1xcbicgOiAnJ1xuICAgIGZvciggbGV0IGlucHV0IG9mICBjYi5pbnB1dHMudmFsdWVzKCkgKSB7XG4gICAgICBzdHIgKz0gYGNvbnN0ICR7aW5wdXQubmFtZX0gPSBpbnB1dHNbICR7aW5wdXQuaW5wdXROdW1iZXJ9IF1bICR7aW5wdXQuY2hhbm5lbE51bWJlcn0gXVxcbiAgICAgIGBcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH0sXG5cblxuICBjcmVhdGVJbnB1dEFyZ3VtZW50cyggY2IgKSB7XG4gICAgbGV0ICBwYXJhbUxpc3QgPSAnJ1xuICAgIGZvciggbGV0IGlucHV0IG9mIGNiLmlucHV0cy52YWx1ZXMoKSApIHtcbiAgICAgIHBhcmFtTGlzdCArPSBpbnB1dC5uYW1lICsgJ1tpXSwnXG4gICAgfVxuICAgIHBhcmFtTGlzdCA9IHBhcmFtTGlzdC5zbGljZSggMCwgLTEgKVxuXG4gICAgcmV0dXJuIHBhcmFtTGlzdFxuICB9LFxuICAgICAgXG4gIGNyZWF0ZUZ1bmN0aW9uRGVyZWZlcmVuY2VzKCBjYiApIHtcbiAgICBsZXQgbWVtYmVyU3RyaW5nID0gY2IubWVtYmVycy5zaXplID4gMCA/ICdcXG4nIDogJydcbiAgICBsZXQgbWVtbyA9IHt9XG4gICAgZm9yKCBsZXQgZGljdCBvZiBjYi5tZW1iZXJzLnZhbHVlcygpICkge1xuICAgICAgY29uc3QgbmFtZSA9IE9iamVjdC5rZXlzKCBkaWN0IClbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGRpY3RbIG5hbWUgXVxuXG4gICAgICBpZiggbWVtb1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSBjb250aW51ZVxuICAgICAgbWVtb1sgbmFtZSBdID0gdHJ1ZVxuXG4gICAgICBtZW1iZXJTdHJpbmcgKz0gYCAgICAgIGNvbnN0ICR7bmFtZX0gPSAke3ZhbHVlfVxcbmBcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtYmVyU3RyaW5nXG4gIH0sXG5cbiAgY3JlYXRlV29ya2xldFByb2Nlc3NvciggZ3JhcGgsIG5hbWUsIGRlYnVnLCBtZW09NDQxMDAqMTAgKSB7XG4gICAgLy9jb25zdCBtZW0gPSBNZW1vcnlIZWxwZXIuY3JlYXRlKCA0MDk2LCBGbG9hdDY0QXJyYXkgKVxuICAgIGNvbnN0IGNiID0gZ2VuLmNyZWF0ZUNhbGxiYWNrKCBncmFwaCwgbWVtLCBkZWJ1ZyApXG4gICAgY29uc3QgaW5wdXRzID0gY2IuaW5wdXRzXG5cbiAgICAvLyBnZXQgYWxsIGlucHV0cyBhbmQgY3JlYXRlIGFwcHJvcHJpYXRlIGF1ZGlvcGFyYW0gaW5pdGlhbGl6ZXJzXG4gICAgY29uc3QgcGFyYW1ldGVyRGVzY3JpcHRvcnMgPSB0aGlzLmNyZWF0ZVBhcmFtZXRlckRlc2NyaXB0b3JzKCBjYiApXG4gICAgY29uc3QgcGFyYW1ldGVyRGVyZWZlcmVuY2VzID0gdGhpcy5jcmVhdGVQYXJhbWV0ZXJEZXJlZmVyZW5jZXMoIGNiIClcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLmNyZWF0ZVBhcmFtZXRlckFyZ3VtZW50cyggY2IgKVxuICAgIGNvbnN0IGlucHV0RGVyZWZlcmVuY2VzID0gdGhpcy5jcmVhdGVJbnB1dERlcmVmZXJlbmNlcyggY2IgKVxuICAgIGNvbnN0IGlucHV0TGlzdCA9IHRoaXMuY3JlYXRlSW5wdXRBcmd1bWVudHMoIGNiICkgICBcbiAgICBjb25zdCBtZW1iZXJTdHJpbmcgPSB0aGlzLmNyZWF0ZUZ1bmN0aW9uRGVyZWZlcmVuY2VzKCBjYiApXG5cbiAgICAvLyBjaGFuZ2Ugb3V0cHV0IGJhc2VkIG9uIG51bWJlciBvZiBjaGFubmVscy5cbiAgICBjb25zdCBnZW5pc2hPdXRwdXRMaW5lID0gY2IuaXNTdGVyZW8gPT09IGZhbHNlXG4gICAgICA/IGBsZWZ0WyBpIF0gPSBtZW1vcnlbMF1gXG4gICAgICA6IGBsZWZ0WyBpIF0gPSBtZW1vcnlbMF07XFxuXFx0XFx0cmlnaHRbIGkgXSA9IG1lbW9yeVsxXVxcbmBcblxuICAgIGNvbnN0IHByZXR0eUNhbGxiYWNrID0gdGhpcy5wcmV0dHlQcmludENhbGxiYWNrKCBjYiApXG5cbiAgICAvKioqKiogYmVnaW4gY2FsbGJhY2sgY29kZSAqKioqL1xuICAgIC8vIG5vdGUgdGhhdCB3ZSBoYXZlIHRvIGNoZWNrIHRvIHNlZSB0aGF0IG1lbW9yeSBoYXMgYmVlbiBwYXNzZWRcbiAgICAvLyB0byB0aGUgd29ya2VyIGJlZm9yZSBydW5uaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgb3RoZXJ3aXNlXG4gICAgLy8gaXQgY2FuIGJlIHBhc3NlZCB0b28gc2xvd2x5IGFuZCBmYWlsIG9uIG9jY2Fzc2lvblxuXG4gICAgY29uc3Qgd29ya2xldENvZGUgPSBgXG5jbGFzcyAke25hbWV9UHJvY2Vzc29yIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHtcblxuICBzdGF0aWMgZ2V0IHBhcmFtZXRlckRlc2NyaXB0b3JzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgICR7IHBhcmFtZXRlckRlc2NyaXB0b3JzIH0gICAgICBcbiAgICBdXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG4gXG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICkge1xuICAgIHN1cGVyKCBvcHRpb25zIClcbiAgICB0aGlzLnBvcnQub25tZXNzYWdlID0gdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQoIHRoaXMgKVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaGFuZGxlTWVzc2FnZSggZXZlbnQgKSB7XG4gICAgaWYoIGV2ZW50LmRhdGEua2V5ID09PSAnaW5pdCcgKSB7XG4gICAgICB0aGlzLm1lbW9yeSA9IGV2ZW50LmRhdGEubWVtb3J5XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgIH1lbHNlIGlmKCBldmVudC5kYXRhLmtleSA9PT0gJ3NldCcgKSB7XG4gICAgICB0aGlzLm1lbW9yeVsgZXZlbnQuZGF0YS5pZHggXSA9IGV2ZW50LmRhdGEudmFsdWVcbiAgICB9ZWxzZSBpZiggZXZlbnQuZGF0YS5rZXkgPT09ICdnZXQnICkge1xuICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHsga2V5OidyZXR1cm4nLCBpZHg6ZXZlbnQuZGF0YS5pZHgsIHZhbHVlOnRoaXMubWVtb3J5W2V2ZW50LmRhdGEuaWR4XSB9KSAgICAgXG4gICAgfVxuICB9XG5cbiAgcHJvY2VzcyggaW5wdXRzLCBvdXRwdXRzLCBwYXJhbWV0ZXJzICkge1xuICAgIGlmKCB0aGlzLmluaXRpYWxpemVkID09PSB0cnVlICkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1swXVxuICAgICAgY29uc3QgbGVmdCAgID0gb3V0cHV0WyAwIF1cbiAgICAgIGNvbnN0IHJpZ2h0ICA9IG91dHB1dFsgMSBdXG4gICAgICBjb25zdCBsZW4gICAgPSBsZWZ0Lmxlbmd0aFxuICAgICAgY29uc3QgbWVtb3J5ID0gdGhpcy5tZW1vcnkgJHtwYXJhbWV0ZXJEZXJlZmVyZW5jZXN9JHtpbnB1dERlcmVmZXJlbmNlc30ke21lbWJlclN0cmluZ31cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAgJHtwcmV0dHlDYWxsYmFja31cbiAgICAgICAgJHtnZW5pc2hPdXRwdXRMaW5lfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG4gICAgXG5yZWdpc3RlclByb2Nlc3NvciggJyR7bmFtZX0nLCAke25hbWV9UHJvY2Vzc29yKWBcblxuICAgIFxuICAgIC8qKioqKiBlbmQgY2FsbGJhY2sgY29kZSAqKioqKi9cblxuXG4gICAgaWYoIGRlYnVnID09PSB0cnVlICkgY29uc29sZS5sb2coIHdvcmtsZXRDb2RlIClcblxuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoXG4gICAgICAgIFsgd29ya2xldENvZGUgXSwgXG4gICAgICAgIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfVxuICAgICAgKVxuICAgIClcblxuICAgIHJldHVybiBbIHVybCwgd29ya2xldENvZGUsIGlucHV0cywgY2IucGFyYW1zLCBjYi5pc1N0ZXJlbyBdIFxuICB9LFxuXG4gIHJlZ2lzdGVyZWRGb3JOb2RlQXNzaWdubWVudDogW10sXG4gIHJlZ2lzdGVyKCB1Z2VuICkge1xuICAgIGlmKCB0aGlzLnJlZ2lzdGVyZWRGb3JOb2RlQXNzaWdubWVudC5pbmRleE9mKCB1Z2VuICkgPT09IC0xICkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRm9yTm9kZUFzc2lnbm1lbnQucHVzaCggdWdlbiApXG4gICAgfVxuICB9LFxuXG4gIHBsYXlXb3JrbGV0KCBncmFwaCwgbmFtZSwgZGVidWc9ZmFsc2UsIG1lbT00NDEwMCAqIDYwICkge1xuICAgIHV0aWxpdGllcy5jbGVhcigpXG5cbiAgICBjb25zdCBbIHVybCwgY29kZVN0cmluZywgaW5wdXRzLCBwYXJhbXMsIGlzU3RlcmVvIF0gPSB1dGlsaXRpZXMuY3JlYXRlV29ya2xldFByb2Nlc3NvciggZ3JhcGgsIG5hbWUsIGRlYnVnLCBtZW0gKVxuXG4gICAgY29uc3Qgbm9kZVByb21pc2UgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICBcbiAgICAgIHV0aWxpdGllcy5jdHguYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSggdXJsICkudGhlbiggKCk9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtsZXROb2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUoIHV0aWxpdGllcy5jdHgsIG5hbWUsIHsgb3V0cHV0Q2hhbm5lbENvdW50OlsgaXNTdGVyZW8gPyAyIDogMSBdIH0pXG5cbiAgICAgICAgd29ya2xldE5vZGUuY2FsbGJhY2tzID0ge31cbiAgICAgICAgd29ya2xldE5vZGUub25tZXNzYWdlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgIGlmKCBldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXR1cm4nICkge1xuICAgICAgICAgICAgd29ya2xldE5vZGUuY2FsbGJhY2tzWyBldmVudC5kYXRhLmlkeCBdKCBldmVudC5kYXRhLnZhbHVlIClcbiAgICAgICAgICAgIGRlbGV0ZSB3b3JrbGV0Tm9kZS5jYWxsYmFja3NbIGV2ZW50LmRhdGEuaWR4IF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrbGV0Tm9kZS5nZXRNZW1vcnlWYWx1ZSA9IGZ1bmN0aW9uKCBpZHgsIGNiICkge1xuICAgICAgICAgIHRoaXMud29ya2xldENhbGxiYWNrc1sgaWR4IF0gPSBjYlxuICAgICAgICAgIHRoaXMud29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZSh7IGtleTonZ2V0JywgaWR4OiBpZHggfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgd29ya2xldE5vZGUucG9ydC5wb3N0TWVzc2FnZSh7IGtleTonaW5pdCcsIG1lbW9yeTpnZW4ubWVtb3J5LmhlYXAgfSlcbiAgICAgICAgdXRpbGl0aWVzLndvcmtsZXROb2RlID0gd29ya2xldE5vZGVcblxuICAgICAgICB1dGlsaXRpZXMucmVnaXN0ZXJlZEZvck5vZGVBc3NpZ25tZW50LmZvckVhY2goIHVnZW4gPT4gdWdlbi5ub2RlID0gd29ya2xldE5vZGUgKVxuICAgICAgICB1dGlsaXRpZXMucmVnaXN0ZXJlZEZvck5vZGVBc3NpZ25tZW50Lmxlbmd0aCA9IDBcblxuICAgICAgICAvLyBhc3NpZ24gYWxsIHBhcmFtcyBhcyBwcm9wZXJ0aWVzIG9mIG5vZGUgZm9yIGVhc2llciByZWZlcmVuY2UgXG4gICAgICAgIGZvciggbGV0IGRpY3Qgb2YgaW5wdXRzLnZhbHVlcygpICkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBPYmplY3Qua2V5cyggZGljdCApWzBdXG4gICAgICAgICAgY29uc3QgcGFyYW0gPSB3b3JrbGV0Tm9kZS5wYXJhbWV0ZXJzLmdldCggbmFtZSApXG4gICAgICBcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHdvcmtsZXROb2RlLCBuYW1lLCB7XG4gICAgICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggbGV0IHVnZW4gb2YgcGFyYW1zLnZhbHVlcygpICkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSB1Z2VuLm5hbWVcbiAgICAgICAgICBjb25zdCBwYXJhbSA9IHdvcmtsZXROb2RlLnBhcmFtZXRlcnMuZ2V0KCBuYW1lIClcbiAgICAgICAgICB1Z2VuLndhYXBpID0gcGFyYW0gXG4gICAgICAgICAgLy8gaW5pdGlhbGl6ZT9cbiAgICAgICAgICBwYXJhbS52YWx1ZSA9IHVnZW4uZGVmYXVsdFZhbHVlXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHdvcmtsZXROb2RlLCBuYW1lLCB7XG4gICAgICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB1dGlsaXRpZXMuY29uc29sZSApIHV0aWxpdGllcy5jb25zb2xlLnNldFZhbHVlKCBjb2RlU3RyaW5nIClcblxuICAgICAgICB3b3JrbGV0Tm9kZS5jb25uZWN0KCB1dGlsaXRpZXMuY3R4LmRlc3RpbmF0aW9uIClcblxuICAgICAgICByZXNvbHZlKCB3b3JrbGV0Tm9kZSApXG4gICAgICB9KVxuXG4gICAgfSlcblxuICAgIHJldHVybiBub2RlUHJvbWlzZVxuICB9LFxuICBcbiAgcGxheUdyYXBoKCBncmFwaCwgZGVidWcsIG1lbT00NDEwMCoxMCwgbWVtVHlwZT1GbG9hdDMyQXJyYXkgKSB7XG4gICAgdXRpbGl0aWVzLmNsZWFyKClcbiAgICBpZiggZGVidWcgPT09IHVuZGVmaW5lZCApIGRlYnVnID0gZmFsc2VcbiAgICAgICAgICBcbiAgICB0aGlzLmlzU3RlcmVvID0gQXJyYXkuaXNBcnJheSggZ3JhcGggKVxuXG4gICAgdXRpbGl0aWVzLmNhbGxiYWNrID0gZ2VuLmNyZWF0ZUNhbGxiYWNrKCBncmFwaCwgbWVtLCBkZWJ1ZywgZmFsc2UsIG1lbVR5cGUgKVxuICAgIFxuICAgIGlmKCB1dGlsaXRpZXMuY29uc29sZSApIHV0aWxpdGllcy5jb25zb2xlLnNldFZhbHVlKCB1dGlsaXRpZXMuY2FsbGJhY2sudG9TdHJpbmcoKSApXG5cbiAgICByZXR1cm4gdXRpbGl0aWVzLmNhbGxiYWNrXG4gIH0sXG5cbiAgbG9hZFNhbXBsZSggc291bmRGaWxlUGF0aCwgZGF0YSApIHtcbiAgICBjb25zdCBpc0xvYWRlZCA9IHV0aWxpdGllcy5idWZmZXJzWyBzb3VuZEZpbGVQYXRoIF0gIT09IHVuZGVmaW5lZFxuXG4gICAgbGV0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgcmVxLm9wZW4oICdHRVQnLCBzb3VuZEZpbGVQYXRoLCB0cnVlIClcbiAgICByZXEucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJyBcbiAgICBcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSxyZWplY3QpID0+IHtcbiAgICAgIGlmKCAhaXNMb2FkZWQgKSB7XG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXVkaW9EYXRhID0gcmVxLnJlc3BvbnNlXG5cbiAgICAgICAgICB1dGlsaXRpZXMuY3R4LmRlY29kZUF1ZGlvRGF0YSggYXVkaW9EYXRhLCAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJ1ZmZlciA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKVxuICAgICAgICAgICAgdXRpbGl0aWVzLmJ1ZmZlcnNbIHNvdW5kRmlsZVBhdGggXSA9IGRhdGEuYnVmZmVyXG4gICAgICAgICAgICByZXNvbHZlKCBkYXRhLmJ1ZmZlciApXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHNldFRpbWVvdXQoICgpPT4gcmVzb2x2ZSggdXRpbGl0aWVzLmJ1ZmZlcnNbIHNvdW5kRmlsZVBhdGggXSApLCAwIClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYoICFpc0xvYWRlZCApIHJlcS5zZW5kKClcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxufVxuXG51dGlsaXRpZXMuY2xlYXIuY2FsbGJhY2tzID0gW11cblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsaXRpZXNcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKlxuICogbWFueSB3aW5kb3dzIGhlcmUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb3JiYW5icm9vay9kc3AuanMvYmxvYi9tYXN0ZXIvZHNwLmpzXG4gKiBzdGFydGluZyBhdCBsaW5lIDE0MjdcbiAqIHRha2VuIDgvMTUvMTZcbiovIFxuXG5jb25zdCB3aW5kb3dzID0gbW9kdWxlLmV4cG9ydHMgPSB7IFxuICBiYXJ0bGV0dCggbGVuZ3RoLCBpbmRleCApIHtcbiAgICByZXR1cm4gMiAvIChsZW5ndGggLSAxKSAqICgobGVuZ3RoIC0gMSkgLyAyIC0gTWF0aC5hYnMoaW5kZXggLSAobGVuZ3RoIC0gMSkgLyAyKSkgXG4gIH0sXG5cbiAgYmFydGxldHRIYW5uKCBsZW5ndGgsIGluZGV4ICkge1xuICAgIHJldHVybiAwLjYyIC0gMC40OCAqIE1hdGguYWJzKGluZGV4IC8gKGxlbmd0aCAtIDEpIC0gMC41KSAtIDAuMzggKiBNYXRoLmNvcyggMiAqIE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSlcbiAgfSxcblxuICBibGFja21hbiggbGVuZ3RoLCBpbmRleCwgYWxwaGEgKSB7XG4gICAgbGV0IGEwID0gKDEgLSBhbHBoYSkgLyAyLFxuICAgICAgICBhMSA9IDAuNSxcbiAgICAgICAgYTIgPSBhbHBoYSAvIDJcblxuICAgIHJldHVybiBhMCAtIGExICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSkgKyBhMiAqIE1hdGguY29zKDQgKiBNYXRoLlBJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpXG4gIH0sXG5cbiAgY29zaW5lKCBsZW5ndGgsIGluZGV4ICkge1xuICAgIHJldHVybiBNYXRoLmNvcyhNYXRoLlBJICogaW5kZXggLyAobGVuZ3RoIC0gMSkgLSBNYXRoLlBJIC8gMilcbiAgfSxcblxuICBnYXVzcyggbGVuZ3RoLCBpbmRleCwgYWxwaGEgKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KE1hdGguRSwgLTAuNSAqIE1hdGgucG93KChpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpIC8gKGFscGhhICogKGxlbmd0aCAtIDEpIC8gMiksIDIpKVxuICB9LFxuXG4gIGhhbW1pbmcoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIDAuNTQgLSAwLjQ2ICogTWF0aC5jb3MoIE1hdGguUEkgKiAyICogaW5kZXggLyAobGVuZ3RoIC0gMSkpXG4gIH0sXG5cbiAgaGFubiggbGVuZ3RoLCBpbmRleCApIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyggTWF0aC5QSSAqIDIgKiBpbmRleCAvIChsZW5ndGggLSAxKSkgKVxuICB9LFxuXG4gIGxhbmN6b3MoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgbGV0IHggPSAyICogaW5kZXggLyAobGVuZ3RoIC0gMSkgLSAxO1xuICAgIHJldHVybiBNYXRoLnNpbihNYXRoLlBJICogeCkgLyAoTWF0aC5QSSAqIHgpXG4gIH0sXG5cbiAgcmVjdGFuZ3VsYXIoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIDFcbiAgfSxcblxuICB0cmlhbmd1bGFyKCBsZW5ndGgsIGluZGV4ICkge1xuICAgIHJldHVybiAyIC8gbGVuZ3RoICogKGxlbmd0aCAvIDIgLSBNYXRoLmFicyhpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpKVxuICB9LFxuXG4gIC8vIHBhcmFib2xhXG4gIHdlbGNoKCBsZW5ndGgsIF9pbmRleCwgaWdub3JlLCBzaGlmdD0wICkge1xuICAgIC8vd1tuXSA9IDEgLSBNYXRoLnBvdyggKCBuIC0gKCAoTi0xKSAvIDIgKSApIC8gKCggTi0xICkgLyAyICksIDIgKVxuICAgIGNvbnN0IGluZGV4ID0gc2hpZnQgPT09IDAgPyBfaW5kZXggOiAoX2luZGV4ICsgTWF0aC5mbG9vciggc2hpZnQgKiBsZW5ndGggKSkgJSBsZW5ndGhcbiAgICBjb25zdCBuXzFfb3ZlcjIgPSAobGVuZ3RoIC0gMSkgLyAyIFxuXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdyggKCBpbmRleCAtIG5fMV9vdmVyMiApIC8gbl8xX292ZXIyLCAyIClcbiAgfSxcbiAgaW52ZXJzZXdlbGNoKCBsZW5ndGgsIF9pbmRleCwgaWdub3JlLCBzaGlmdD0wICkge1xuICAgIC8vd1tuXSA9IDEgLSBNYXRoLnBvdyggKCBuIC0gKCAoTi0xKSAvIDIgKSApIC8gKCggTi0xICkgLyAyICksIDIgKVxuICAgIGxldCBpbmRleCA9IHNoaWZ0ID09PSAwID8gX2luZGV4IDogKF9pbmRleCArIE1hdGguZmxvb3IoIHNoaWZ0ICogbGVuZ3RoICkpICUgbGVuZ3RoXG4gICAgY29uc3Qgbl8xX292ZXIyID0gKGxlbmd0aCAtIDEpIC8gMlxuXG4gICAgcmV0dXJuIE1hdGgucG93KCAoIGluZGV4IC0gbl8xX292ZXIyICkgLyBuXzFfb3ZlcjIsIDIgKVxuICB9LFxuXG4gIHBhcmFib2xhKCBsZW5ndGgsIGluZGV4ICkge1xuICAgIGlmKCBpbmRleCA8PSBsZW5ndGggLyAyICkge1xuICAgICAgcmV0dXJuIHdpbmRvd3MuaW52ZXJzZXdlbGNoKCBsZW5ndGggLyAyLCBpbmRleCApIC0gMVxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIDEgLSB3aW5kb3dzLmludmVyc2V3ZWxjaCggbGVuZ3RoIC8gMiwgaW5kZXggLSBsZW5ndGggLyAyIClcbiAgICB9XG4gIH0sXG5cbiAgZXhwb25lbnRpYWwoIGxlbmd0aCwgaW5kZXgsIGFscGhhICkge1xuICAgIHJldHVybiBNYXRoLnBvdyggaW5kZXggLyBsZW5ndGgsIGFscGhhIClcbiAgfSxcblxuICBsaW5lYXIoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIGluZGV4IC8gbGVuZ3RoXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgZmxvb3I9IHJlcXVpcmUoJy4vZmxvb3IuanMnKSxcbiAgICBzdWIgID0gcmVxdWlyZSgnLi9zdWIuanMnKSxcbiAgICBtZW1vID0gcmVxdWlyZSgnLi9tZW1vLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTond3JhcCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBjb2RlLFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIHNpZ25hbCA9IGlucHV0c1swXSwgbWluID0gaW5wdXRzWzFdLCBtYXggPSBpbnB1dHNbMl0sXG4gICAgICAgIG91dCwgZGlmZlxuXG4gICAgLy9vdXQgPSBgKCgoJHtpbnB1dHNbMF19IC0gJHt0aGlzLm1pbn0pICUgJHtkaWZmfSAgKyAke2RpZmZ9KSAlICR7ZGlmZn0gKyAke3RoaXMubWlufSlgXG4gICAgLy9jb25zdCBsb25nIG51bVdyYXBzID0gbG9uZygodi1sbykvcmFuZ2UpIC0gKHYgPCBsbyk7XG4gICAgLy9yZXR1cm4gdiAtIHJhbmdlICogZG91YmxlKG51bVdyYXBzKTsgICBcbiAgICBcbiAgICBpZiggdGhpcy5taW4gPT09IDAgKSB7XG4gICAgICBkaWZmID0gbWF4XG4gICAgfWVsc2UgaWYgKCBpc05hTiggbWF4ICkgfHwgaXNOYU4oIG1pbiApICkge1xuICAgICAgZGlmZiA9IGAke21heH0gLSAke21pbn1gXG4gICAgfWVsc2V7XG4gICAgICBkaWZmID0gbWF4IC0gbWluXG4gICAgfVxuXG4gICAgb3V0ID1cbmAgdmFyICR7dGhpcy5uYW1lfSA9ICR7aW5wdXRzWzBdfVxuICBpZiggJHt0aGlzLm5hbWV9IDwgJHt0aGlzLm1pbn0gKSAke3RoaXMubmFtZX0gKz0gJHtkaWZmfVxuICBlbHNlIGlmKCAke3RoaXMubmFtZX0gPiAke3RoaXMubWF4fSApICR7dGhpcy5uYW1lfSAtPSAke2RpZmZ9XG5cbmBcblxuICAgIHJldHVybiBbIHRoaXMubmFtZSwgJyAnICsgb3V0IF1cbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgbWluPTAsIG1heD0xICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IFxuICAgIG1pbiwgXG4gICAgbWF4LFxuICAgIHVpZDogICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogWyBpbjEsIG1pbiwgbWF4IF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgQW5hbHlzaXMgPSB7XG4gIGNyZWF0ZSggQXVkaW8gKSB7XG4gICAgY29uc3QgYW5hbHlzaXMgPSB7fVxuXG4gICAgZm9yKCBsZXQgYW5hbHlzaXNOYW1lIGluIEdpYmJlcmlzaC5hbmFseXNpcyApIHtcbiAgICAgIGNvbnN0IGdpYmJlcmlzaENvbnN0cnVjdG9yID0gR2liYmVyaXNoLmFuYWx5c2lzWyBhbmFseXNpc05hbWUgXVxuXG4gICAgICBjb25zdCBtZXRob2RzID0gQW5hbHlzaXMuZGVzY3JpcHRpb25zWyBhbmFseXNpc05hbWUgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEFuYWx5c2lzLmRlc2NyaXB0aW9uc1sgYW5hbHlzaXNOYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOiB7IHR5cGU6J2FuYWx5c2lzJyB9LFxuICAgICAgICBuYW1lOmFuYWx5c2lzTmFtZSxcbiAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgY2F0ZWdvcnk6J2FuYWx5c2lzJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8sIGZhbHNlLCB0cnVlIClcbiAgICAgIGFuYWx5c2lzWyBhbmFseXNpc05hbWUgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICBjb25zdCB1Z2VuID0gY29uc3RydWN0b3IoIC4uLmFyZ3MgKVxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5zZXQoIHVnZW4uaWQsIHVnZW4gKVxuICAgICAgICB1Z2VuLm91dCA9IHVnZW4uX193cmFwcGVkX18ub3V0XG4gICAgICAgIFxuICAgICAgICBpZiggYW5hbHlzaXNOYW1lID09PSAnRm9sbG93JyApIHtcbiAgICAgICAgICBsZXQgbSA9IHVnZW4uX193cmFwcGVkX18ubXVsdGlwbGllciB8fCAxXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAnbXVsdGlwbGllcicsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gbSB9LFxuICAgICAgICAgICAgc2V0KHYpIHsgbSA9IHY7IHVnZW4uX193cmFwcGVkX18ubXVsdGlwbGllciA9IG0gfVxuICAgICAgICAgIH0pIFxuICAgICAgICAgIGxldCBvID0gdWdlbi5fX3dyYXBwZWRfXy5vZmZzZXQgfHwgMFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ29mZnNldCcsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gbyB9LFxuICAgICAgICAgICAgc2V0KHYpIHsgbyA9IHY7IHVnZW4uX193cmFwcGVkX18ub2Zmc2V0ID0gbyB9XG4gICAgICAgICAgfSkgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVnZW5cbiAgICAgIH0gXG5cbiAgICB9XG4gICAgcmV0dXJuIGFuYWx5c2lzXG4gIH0sXG5cbiAgZGVzY3JpcHRpb25zOiB7XG4gICAgLy9TU0Q6IHsgbWV0aG9kczpbICdsaXN0ZW4nIF0gfVxuICAgIC8vQ2hvcnVzOnsgbWV0aG9kczpbXSB9LFxuICB9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBbmFseXNpcyBcbiIsImNvbnN0IEdpYmJlcmlzaCAgID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuY29uc3QgSW5zdHJ1bWVudHMgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50cy5qcycgKVxuY29uc3QgT3NjaWxsYXRvcnMgPSByZXF1aXJlKCAnLi9vc2NpbGxhdG9ycy5qcycgKVxuY29uc3QgRWZmZWN0cyAgICAgPSByZXF1aXJlKCAnLi9lZmZlY3RzLmpzJyApXG5jb25zdCBGaWx0ZXJzICAgICA9IHJlcXVpcmUoICcuL2ZpbHRlcnMuanMnIClcbmNvbnN0IEJpbm9wcyAgICAgID0gcmVxdWlyZSggJy4vYmlub3BzLmpzJyApXG5jb25zdCBBbmFseXNpcyAgICA9IHJlcXVpcmUoICcuL2FuYWx5c2lzLmpzJyApXG5jb25zdCBFbnZlbG9wZXMgICA9IHJlcXVpcmUoICcuL2VudmVsb3Blcy5qcycgKVxuY29uc3QgQnVzc2VzICAgICAgPSByZXF1aXJlKCAnLi9idXNzZXMuanMnIClcbmNvbnN0IEVuc2VtYmxlICAgID0gcmVxdWlyZSggJy4vZW5zZW1ibGUuanMnIClcbmNvbnN0IFV0aWxpdHkgICAgID0gcmVxdWlyZSggJy4vdXRpbGl0eS5qcycgKVxuY29uc3QgRnJlZXNvdW5kICAgPSByZXF1aXJlKCAnLi9mcmVlc291bmQuanMnIClcbmNvbnN0IEdlbiAgICAgICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5jb25zdCBXYXZlUGF0dGVybiA9IHJlcXVpcmUoICcuL3dhdmVQYXR0ZXJuLmpzJyApXG5jb25zdCBXYXZlT2JqZWN0cyA9IHJlcXVpcmUoICcuL3dhdmVPYmplY3RzLmpzJyApXG4vL2NvbnN0IENvcmUgICAgICAgID0gcmVxdWlyZSggJ2dpYmJlci5jb3JlLmxpYicgKVxuY29uc3QgQVdQRiAgICAgICAgPSByZXF1aXJlKCAnLi9leHRlcm5hbC9hdWRpb3dvcmtsZXQtcG9seWZpbGwuanMnIClcbi8vY29uc3QgQXJwICAgICAgICAgPSByZXF1aXJlKCAnLi9hcnAuanMnIClcblxuY29uc3QgQXVkaW8gPSB7XG4gIENsb2NrOiByZXF1aXJlKCAnLi9jbG9jay5qcycgKSxcbiAgVGhlb3J5OiByZXF1aXJlKCAnLi90aGVvcnkuanMnICksXG4gIFByZXNldHM6IHJlcXVpcmUoICcuL3ByZXNldHMuanMnICksXG4gIF9fTWFrZTogcmVxdWlyZSggJy4vbWFrZS5qcycgKSxcbiAgaW5pdGlhbGl6ZWQ6ZmFsc2UsXG4gIGF1dG9Db25uZWN0OnRydWUsXG4gIHNob3VsZERlbGF5OmZhbHNlLFxuICBpbnN0cnVtZW50czp7fSxcbiAgb3NjaWxsYXRvcnM6e30sXG4gIGVmZmVjdHM6e30sXG4gIGV4cG9ydFRhcmdldDpudWxsLFxuXG4gIGV4cG9ydCggb2JqICkge1xuICAgIGlmKCBBdWRpby5pbml0aWFsaXplZCApeyBcbiAgICAgIE9iamVjdC5hc3NpZ24oIFxuICAgICAgICBvYmosIFxuICAgICAgICB0aGlzLmluc3RydW1lbnRzLCBcbiAgICAgICAgdGhpcy5vc2NpbGxhdG9ycyxcbiAgICAgICAgdGhpcy5lZmZlY3RzLFxuICAgICAgICB0aGlzLmZpbHRlcnMsXG4gICAgICAgIHRoaXMuYnVzc2VzLCBcbiAgICAgICAgdGhpcy5lbnZlbG9wZXMsIFxuICAgICAgICB0aGlzLndhdmVPYmplY3RzLCBcbiAgICAgICAgdGhpcy5iaW5vcHMsIFxuICAgICAgICB0aGlzLmFuYWx5c2lzIFxuICAgICAgKVxuICAgICAgXG4gICAgICBVdGlsaXR5LmV4cG9ydCggb2JqIClcbiAgICAgIHRoaXMuR2VuLmV4cG9ydCggb2JqIClcblxuICAgICAgb2JqLkdpYmJlcmlzaCA9IHRoaXMuR2liYmVyaXNoXG5cbiAgICAgIG9iai5nZW4gPSB0aGlzLkdlbi5tYWtlXG4gICAgICBvYmoubGZvID0gdGhpcy5HZW4uY29tcG9zaXRlcy5sZm9cbiAgICAgIG9iai5FbnNlbWJsZSA9IHRoaXMuRW5zZW1ibGVcbiAgICAgIG9iai5EcnVtcyA9IHRoaXMuRHJ1bXNcbiAgICAgIG9iai5FRHJ1bXMgPSB0aGlzLkVEcnVtc1xuICAgICAgb2JqLlRoZW9yeSA9IHRoaXMuVGhlb3J5XG4gICAgICBvYmouRnJlZXNvdW5kID0gdGhpcy5GcmVlc291bmRcbiAgICAgIG9iai5DbG9jayA9IHRoaXMuQ2xvY2tcbiAgICAgIG9iai5DbG9jay5leHBvcnQoIG9iaiApXG4gICAgICBvYmouV2F2ZVBhdHRlcm4gPSB0aGlzLldhdmVQYXR0ZXJuXG4gICAgICBvYmouR2VuID0gdGhpcy5HZW5cbiAgICAgIG9iai5zdG9wID0gdGhpcy5zdG9wXG5cbiAgICAgIG9iai5PdXQgPSB0aGlzLk91dFxuICAgICAgb2JqLk1ha2UgPSB0aGlzLk1ha2VcbiAgICAgIG9iai5mdXR1cmUgPSB0aGlzLkdpYmJlcmlzaC51dGlsaXRpZXMuZnV0dXJlXG4gICAgfWVsc2V7XG4gICAgICBBdWRpby5leHBvcnRUYXJnZXQgPSBvYmpcbiAgICB9IFxuICB9LFxuXG4gIF9fZGVmYXVsdHMgOiB7XG4gICAgd29ya2xldFBhdGg6ICcuLi9kaXN0L2dpYmJlcmlzaF93b3JrbGV0LmpzJyxcbiAgICBjdHg6ICAgICAgICAgbnVsbCxcbiAgICBidWZmZXJTaXplOiAgMjA0OCxcbiAgICBsYXRlbmN5SGludDogLjA1XG4gIH0sXG5cbiAgaW5pdCggb3B0aW9ucywgR2liYmVyICApIHtcbiAgICBsZXQgeyB3b3JrbGV0UGF0aCwgY3R4LCBidWZmZXJTaXplLCBsYXRlbmN5SGludCB9ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMuX19kZWZhdWx0cywgb3B0aW9ucyApIFxuICAgIHRoaXMuR2liYmVyID0gR2liYmVyXG4gICAgdGhpcy5Db3JlID0gR2liYmVyXG5cbiAgICAvLyBYWFggc2hvdWxkIHByb2JhYmx5IGp1c3QgY2FsbCBBdWRpby5Db3JlLmNyZWF0ZVByb3BlcnR5IHRvIGF2b2lkIGNvbmZ1c2lvbi4uLlxuICAgIHRoaXMuY3JlYXRlUHJvcGVydHkgPSBHaWJiZXIuY3JlYXRlUHJvcGVydHlcblxuICAgIEdpYmJlci5BdWRpbyA9IHRoaXNcbiAgICB0aGlzLkdpYmJlcmlzaCA9IEdpYmJlcmlzaFxuXG4gICAgR2liYmVyaXNoLndvcmtsZXRQYXRoID0gd29ya2xldFBhdGggXG5cbiAgICB0aGlzLmNyZWF0ZVB1YlN1YigpXG5cbiAgICBjb25zdCBBQyA9IHR5cGVvZiBBdWRpb0NvbnRleHQgPT09ICd1bmRlZmluZWQnID8gd2Via2l0QXVkaW9Db250ZXh0IDogQXVkaW9Db250ZXh0XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IEFDXG4gICAgQVdQRiggd2luZG93LCBidWZmZXJTaXplICkgXG5cbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmKCBjdHggPT09IG51bGwgKSB7XG4gICAgICAgIGN0eCA9IG5ldyBBQyh7IGxhdGVuY3lIaW50IH0pXG4gICAgICAgIC8vY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC5pbml0KCA0NDEwMCo2MCoyMCwgY3R4ICkudGhlbiggcHJvY2Vzc29yTm9kZSA9PiB7XG4gICAgICAgIC8vIFhYWCByZW1vdmUgb25jZSBnaWJiZXIuY29yZS5saWIgaGFzIGJlZW4gcHJvcGVybHkgaW50ZWdyYXRlZCBcbiAgICAgICAgQXVkaW8uQ29yZS5BdWRpbyA9IEF1ZGlvLkNvcmUuYXVkaW8gPSBBdWRpb1xuXG4gICAgICAgIEF1ZGlvLkdpYmJlcmlzaCA9IEdpYmJlcmlzaFxuXG4gICAgICAgIEF1ZGlvLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgICBBdWRpby5ub2RlID0gcHJvY2Vzc29yTm9kZVxuICAgICAgICBBdWRpby5VZ2VuID0gVWdlblxuICAgICAgICBBdWRpby5NYWtlID0gQXVkaW8uX19NYWtlKCBBdWRpbyApXG4gICAgICAgIEF1ZGlvLkdlbiA9IEdlbiggQXVkaW8gKVxuICAgICAgICBBdWRpby5HZW4uaW5pdCgpXG4gICAgICAgIEF1ZGlvLkdlbi5leHBvcnQoIEF1ZGlvLkdlbi51Z2VucyApXG4gICAgICAgIEF1ZGlvLlRoZW9yeS5pbml0KCB3aW5kb3cuR2liYmVyIClcbiAgICAgICAgQXVkaW8uVXRpbGl0aWVzID0gVXRpbGl0eVxuICAgICAgICBBdWRpby5XYXZlUGF0dGVybiA9IFdhdmVQYXR0ZXJuKCBBdWRpbyApXG4gICAgICAgIEF1ZGlvLmN0eCA9IGN0eFxuICAgICAgICBBdWRpby5PdXQgPSBHaWJiZXJpc2gub3V0cHV0XG4gICAgICAgIFxuICAgICAgICAvLyBtdXN0IHdhaXQgZm9yIEdlbiB0byBiZSBpbml0aWFsaXplZFxuICAgICAgICBBdWRpby5DbG9jay5pbml0KCBBdWRpby5HZW4sIEF1ZGlvIClcblxuICAgICAgICBBdWRpby5jcmVhdGVVZ2VucygpXG4gICAgICAgIFxuICAgICAgICBpZiggQXVkaW8uZXhwb3J0VGFyZ2V0ICE9PSBudWxsICkgQXVkaW8uZXhwb3J0KCBBdWRpby5leHBvcnRUYXJnZXQgKVxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQuX19wb3N0TWVzc2FnZSA9IEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2VcblxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlID0gZnVuY3Rpb24oIGRpY3QgKSB7XG4gICAgICAgICAgaWYoIEF1ZGlvLnNob3VsZERlbGF5ID09PSB0cnVlICkgZGljdC5kZWxheSA9IHRydWVcblxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQuX19wb3N0TWVzc2FnZSggZGljdCApXG4gICAgICAgIH1cblxuICAgICAgICBBdWRpby5leHBvcnQoIHdpbmRvdyApXG5cbiAgICAgICAgLy9jb25zdCBkcnVtcyA9IEF1ZGlvLkRydW1zKCd4Km8tJylcbiAgICAgICAgLy9kcnVtcy5kaXNjb25uZWN0KClcbiAgICAgICAgLy9kcnVtcy5zdG9wKClcblxuICAgICAgICAvLyBzdG9yZSBsYXN0IGxvY2F0aW9uIGluIG1lbW9yeS4uLiB3ZSBjYW4gY2xlYXIgZXZlcnl0aGluZyBlbHNlIGluIEdpYmJlci5jbGVhcjkpXG4gICAgICAgIGNvbnN0IG1lbUlkeCA9IE9iamVjdC5rZXlzKCBHaWJiZXJpc2gubWVtb3J5Lmxpc3QgKS5yZXZlcnNlKClbMF1cbiAgICAgICAgdGhpcy5fX21lbW9yeUVuZCA9IHBhcnNlSW50KCBtZW1JZHggKSArIEdpYmJlcmlzaC5tZW1vcnkubGlzdFsgbWVtSWR4IF1cblxuICAgICAgICAvLyBYWFggdGhpcyBmb3JjZXMgdGhlIGdpYmJlcmlzaCBzY2hlZHVsZXIgdG8gc3RhcnRcbiAgICAgICAgLy8gcnVubmluZywgYnV0IGl0J3MgYWJvdXQgYXMgaGFja3kgYXMgaXQgY2FuIGdldC4uLlxuICAgICAgICAvL2NvbnN0IF9fc3RhcnQgPSBBdWRpby5pbnN0cnVtZW50cy5TeW50aCgpLmNvbm5lY3QoKVxuICAgICAgICAvL19fc3RhcnQuZGlzY29ubmVjdCgpXG5cbiAgICAgICAgLy9BdWRpby5HaWJiZXJpc2guZ2VuaXNoaS5nZW4uaGlzdG9yaWVzLmNsZWFyKClcbiAgICAgICAgQXVkaW8uY2xlYXIoKVxuXG4gICAgICAgIHJlc29sdmUoIFtBdWRpbywnQXVkaW8nXSApXG4gICAgICB9KVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHBcbiAgfSxcblxuICByZXN0YXJ0KCkge1xuICAgIEdpYmJlci5jbGVhcigpXG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5jbG9zZSgpXG4gICAgd2luZG93LncgPSBHaWJiZXJpc2gud29ya2xldFxuICAgIEdpYmJlcmlzaC53b3JrbGV0LmRpc2Nvbm5lY3QoKVxuXG4gICAgR2liYmVyaXNoLmluaXQoIDQ0MTAwKjYwKjIwLCB1bmRlZmluZWQsICd3b3JrbGV0JywgdHJ1ZSApLnRoZW4oIHByb2Nlc3Nvck5vZGUgPT4ge1xuICAgICAgQXVkaW8ub3V0ID0gR2liYmVyaXNoLm91dHB1dFxuICAgICAgQXVkaW8ubm9kZSA9IHByb2Nlc3Nvck5vZGVcblxuICAgICAgQXVkaW8uVGhlb3J5LmRlbGV0ZVByb3BlcnRpZXMoKVxuICAgICAgQXVkaW8uVGhlb3J5LmluaXQoIHdpbmRvdy5HaWJiZXIgKVxuXG4gICAgICBBdWRpby5pbml0aWFsaXplZCA9IHRydWVcbiAgICAgIEF1ZGlvLm5vZGUgPSBwcm9jZXNzb3JOb2RlXG4gICAgICBBdWRpby5PdXQgPSBHaWJiZXJpc2gub3V0cHV0XG5cbiAgICAgIEF1ZGlvLk1ha2UgPSBBdWRpby5fX01ha2UoIEF1ZGlvIClcbiAgICAgIEF1ZGlvLkdlbiA9IEdlbiggQXVkaW8gKVxuICAgICAgQXVkaW8uR2VuLmluaXQoKVxuICAgICAgQXVkaW8uR2VuLmV4cG9ydCggQXVkaW8uR2VuLnVnZW5zIClcblxuICAgICAgQXVkaW8uV2F2ZVBhdHRlcm4gPSBXYXZlUGF0dGVybiggQXVkaW8gKVxuICAgICAgQXVkaW8uY3JlYXRlVWdlbnMoKVxuICAgICAgICBcbiAgICAgIEF1ZGlvLkNsb2NrLmluaXQoIEF1ZGlvLkdlbiwgQXVkaW8gKVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0Ll9fcG9zdE1lc3NhZ2UgPSBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlID0gZnVuY3Rpb24oIGRpY3QgKSB7XG4gICAgICAgIGlmKCBBdWRpby5zaG91bGREZWxheSA9PT0gdHJ1ZSApIGRpY3QuZGVsYXkgPSB0cnVlXG5cbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5fX3Bvc3RNZXNzYWdlKCBkaWN0IClcbiAgICAgIH1cblxuICAgICAgQXVkaW8uZXhwb3J0KCB3aW5kb3cgKVxuICAgICAgR2liYmVyLmV4cG9ydCggd2luZG93IClcblxuICAgICAgY29uc3QgbWVtSWR4ID0gT2JqZWN0LmtleXMoIEdpYmJlcmlzaC5tZW1vcnkubGlzdCApLnJldmVyc2UoKVswXVxuICAgICAgdGhpcy5fX21lbW9yeUVuZCA9IHBhcnNlSW50KCBtZW1JZHggKSArIEdpYmJlcmlzaC5tZW1vcnkubGlzdFsgbWVtSWR4IF1cblxuICAgICAgLy8gWFhYIHRoaXMgZm9yY2VzIHRoZSBnaWJiZXJpc2ggc2NoZWR1bGVyIHRvIHN0YXJ0XG4gICAgICAvLyBydW5uaW5nLCBidXQgaXQncyBhYm91dCBhcyBoYWNreSBhcyBpdCBjYW4gZ2V0Li4uXG4gICAgICBjb25zdCBfX3N0YXJ0ID0gQXVkaW8uaW5zdHJ1bWVudHMuU3ludGgoKS5jb25uZWN0KClcbiAgICAgIF9fc3RhcnQuZGlzY29ubmVjdCgpXG5cbiAgICAgIC8vQXVkaW8uR2liYmVyaXNoLmdlbmlzaGkuZ2VuLmhpc3Rvcmllcy5jbGVhcigpXG5cbiAgICAgIC8vQXVkaW8uY2xlYXIoKVxuICAgICAgY29uc29sZS5sb2coICdhdWRpbyBlbmdpbmUgc3VjY2Vzc2Z1bGx5IHJlc3RhcnRlZC4nIClcbiAgICAgIEF1ZGlvLnB1Ymxpc2goICdyZXN0YXJ0JyApXG4gICAgfSlcbiAgfSxcblxuICAvLyBYWFggc3RvcCBjbG9jayBmcm9tIGJlaW5nIGNsZWFyZWQuXG4gIGNsZWFyKCkgeyBcbiAgICBHaWJiZXJpc2guY2xlYXIoKSBcbiAgICBBdWRpby5DbG9jay5pbml0KCBBdWRpby5HZW4sIEF1ZGlvIClcblxuICAgIC8vIHRoZSBpZGVhIGlzIHRoYXQgd2Ugb25seSBjbGVhciBtZW1vcnkgdGhhdCB3YXMgZmlsbGVkIGFmdGVyXG4gICAgLy8gdGhlIGluaXRpYWwgR2liYmVyIGluaXRpYWxpemF0aW9uLi4uIHRoaXMgc3RvcHMgb2JqZWN0c1xuICAgIC8vIGxpa2UgQ2xvY2sgYW5kIFRoZW9yeSBmcm9tIGhhdmluZyB0aGVpciBtZW1vcnkgY2xlYXJlZCBhbmRcbiAgICAvLyBmcm9tIGhhdmluZyB0byByZS1pbml0aWFsaXplIHRoZW0uXG5cbiAgICAvLyBmaWxsIG1lbW9yeSB3aXRoIHplcm9zIGZyb20gdGhlIGVuZCBpbml0aWFsaXphdGlvbiBibG9jayBvbndhcmRzXG4gICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwLmZpbGwoIDAsIHRoaXMuX19tZW1vcnlFbmQgKVxuXG4gICAgLy8gZ2V0IGxvY2F0aW9ucyBvZiBhbGwgbWVtb3J5IGJsb2Nrc1xuICAgIGNvbnN0IG1lbUtleXMgPSBPYmplY3Qua2V5cyggR2liYmVyaXNoLm1lbW9yeS5saXN0IClcblxuICAgIC8vIGdldCBpZHggb2YgZmluYWwgaW5pdGlhbGl6YXRpb24gYmxvY2tcbiAgICBjb25zdCBlbmRJZHggPSAgbWVtS2V5cy5pbmRleE9mKCAnJyt0aGlzLl9fbWVtb3J5RW5kIClcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYmxvY2tzIGFmdGVyIGZpbmFsIGluaXRpYWx6YXRpb24gYmxvY2tcbiAgICAvLyBhbmQgZGVsZXRlIHRoZW0gaW4gdGhlIG1lbW9yeSBsaXN0Li4uIHRoZXkndmUgYWxyZWFkeVxuICAgIC8vIGJlZW4gemVyb2VkIG91dC5cbiAgICBmb3IoIGxldCBpID0gZW5kSWR4OyBpIDwgbWVtS2V5cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGRlbGV0ZSBHaWJiZXJpc2gubWVtb3J5Lmxpc3RbIG1lbUtleXNbIGkgXSBdXG4gICAgfVxuICAgIFxuICAgIEF1ZGlvLnB1Ymxpc2goJ2NsZWFyJylcbiAgfSxcblxuICBzdG9wKCkge1xuICAgIEdpYmJlci5TZXEuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RvcCgpIClcbiAgfSxcblxuICBzdGFydCgpIHtcbiAgICBHaWJiZXIuU2VxLnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0YXJ0KCkgKVxuICB9LFxuICBvbmxvYWQoKSB7fSxcblxuICBjcmVhdGVVZ2VucygpIHtcbiAgICAvL0NvcmUuZXhwb3J0KCB0aGlzLCB0aGlzIClcblxuICAgIHRoaXMuRnJlZXNvdW5kID0gRnJlZXNvdW5kKCB0aGlzIClcbiAgICB0aGlzLmJpbm9wcyA9IEJpbm9wcy5jcmVhdGUoIHRoaXMgKVxuICAgIHRoaXMuYW5hbHlzaXMgPSBBbmFseXNpcy5jcmVhdGUoIHRoaXMgKVxuICAgIHRoaXMub3NjaWxsYXRvcnMgPSBPc2NpbGxhdG9ycy5jcmVhdGUoIHRoaXMgKVxuICAgIHRoaXMuaW5zdHJ1bWVudHMgPSBJbnN0cnVtZW50cy5jcmVhdGUoIHRoaXMgKSBcbiAgICB0aGlzLmVudmVsb3BlcyAgID0gRW52ZWxvcGVzLmNyZWF0ZSggdGhpcyApXG4gICAgdGhpcy5maWx0ZXJzICAgICA9IEZpbHRlcnMuY3JlYXRlKCB0aGlzIClcbiAgICB0aGlzLmVmZmVjdHMgPSBFZmZlY3RzLmNyZWF0ZSggdGhpcyApXG4gICAgdGhpcy5idXNzZXMgPSBCdXNzZXMuY3JlYXRlKCB0aGlzIClcbiAgICB0aGlzLkVuc2VtYmxlID0gRW5zZW1ibGUoIHRoaXMgKVxuICAgIHRoaXMud2F2ZU9iamVjdHMgPSBXYXZlT2JqZWN0cyggdGhpcyApXG5cbiAgICBjb25zdCBQYXR0ZXJuID0gdGhpcy5Db3JlLl9fUGF0dGVyblxuICAgIFBhdHRlcm4udHJhbnNmZXIoIHRoaXMsIFBhdHRlcm4udG9TdHJpbmcoKSApXG5cbiAgICBcbiAgICBjb25zdCBkcnVtcyA9IHJlcXVpcmUoICcuL2RydW1zLmpzJyApKCB0aGlzIClcbiAgICBPYmplY3QuYXNzaWduKCB0aGlzLCBkcnVtcyApXG4gIH0sXG5cbiAgcHJpbnRjYigpIHsgXG4gICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBhZGRyZXNzOidjYWxsYmFjaycgfSkgXG4gIH0sXG4gIHByaW50b2JqKCBvYmogKSB7XG4gICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBhZGRyZXNzOidwcmludCcsIG9iamVjdDpvYmouaWQgfSkgXG4gIH0sXG4gIHNlbmQoIG1zZyApe1xuICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBtc2cgKVxuICB9LFxuXG4gIGNyZWF0ZVB1YlN1YigpIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnB1YmV2ZW50cyA9IHt9XG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbigga2V5LCBmY24gKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBldmVudHNbIGtleSBdID0gW11cbiAgICAgIH1cbiAgICAgIGV2ZW50c1sga2V5IF0ucHVzaCggZmNuIClcbiAgICB9XG5cbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oIGtleSwgZmNuICkge1xuICAgICAgaWYoIHR5cGVvZiBldmVudHNbIGtleSBdICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgY29uc3QgYXJyID0gZXZlbnRzWyBrZXkgXVxuXG4gICAgICAgIGFyci5zcGxpY2UoIGFyci5pbmRleE9mKCBmY24gKSwgMSApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24oIGtleSwgZGF0YSApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGV2ZW50c1sga2V5IF1cblxuICAgICAgICBhcnIuZm9yRWFjaCggdiA9PiB2KCBkYXRhICkgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVNYXBwaW5nKCBmcm9tLCB0bywgbmFtZSwgd3JhcHBlZFRvICkge1xuICAgIGlmKCBmcm9tLl9fdXNlTWFwcGluZyA9PT0gZmFsc2UgKSB7XG4gICAgICB0b1sgbmFtZSBdLnZhbHVlID0gZnJvbVxuICAgIH1lbHNlIGlmKCBmcm9tLnR5cGUgPT09ICdhdWRpbycgKSB7XG4gICAgICBjb25zdCBmID0gdG9bICdfXycgKyBuYW1lIF0uZm9sbG93ID0gRm9sbG93KHsgaW5wdXQ6IGZyb20gfSlcblxuICAgICAgbGV0IG0gPSBmLm11bHRpcGxpZXJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdG9bIG5hbWUgXSwgJ211bHRpcGxpZXInLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIG0gfSxcbiAgICAgICAgc2V0KHYpIHsgbSA9IHY7IGYubXVsdGlwbGllciA9IG0gfVxuICAgICAgfSlcblxuICAgICAgbGV0IG8gPSBmLm9mZnNldFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0b1sgbmFtZSBdLCAnb2Zmc2V0Jywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBvIH0sXG4gICAgICAgIHNldCh2KSB7IG8gPSB2OyBmLm9mZnNldCA9IG8gfVxuICAgICAgfSlcblxuICAgICAgd3JhcHBlZFRvWyBuYW1lIF0gPSBmXG4gICAgICAvL3RvWyAnX18nK25hbWVdLnZhbHVlID0gZlxuXG4gICAgfWVsc2UgaWYoIGZyb20udHlwZSA9PT0gJ2dlbicgKSB7XG4gICAgICAvLyBnZW4gb2JqZWN0cyBjYW4gYmUgcmVmZXJyZWQgdG8gd2l0aG91dCB0aGUgZ3JhcGhpY3MvYXVkaW8gYWJzdHJhY3Rpb24sXG4gICAgICAvLyBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBoYXZlIG5vIC5yZW5kZXIoKSBmdW5jdGlvbiwgYW5kIGRvbid0IG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgICAgIGNvbnN0IGdlbiA9IGZyb20ucmVuZGVyICE9PSB1bmRlZmluZWQgPyBmcm9tLnJlbmRlcigpIDogZnJvbVxuXG4gICAgICB3cmFwcGVkVG9bIG5hbWUgXSA9IGdlblxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVHZXR0ZXIoIG9iaiwgbmFtZSApIHsgcmV0dXJuICgpID0+IG9ialsgJ19fJyArIG5hbWUgXSB9LFxuXG4gIGNyZWF0ZVNldHRlciggb2JqLCBuYW1lLCBwb3N0LCB0cmFuc2Zvcm09bnVsbCwgaXNQb2x5PWZhbHNlICkge1xuICAgIGlmKCB0eXBlb2Ygb2JqLl9fd3JhcHBlZF9fID09PSAnb2JqZWN0JyApIHtcbiAgICAgIGxldCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggb2JqLl9fd3JhcHBlZF9fLCBuYW1lIClcblxuICAgICAgaWYoIGRlc2MgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmouX193cmFwcGVkX18sIG5hbWUsICB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgIG9ialsgJ19fJytuYW1lIF0udmFsdWUgPSB2XG4gICAgICAgICAgICBpZiggZGVzYy5zZXQgKSB7XG4gICAgICAgICAgICAgIGRlc2Muc2V0KCB2IClcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBvYmouX193cmFwcGVkX18udmFsdWUgPSB2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZXR0ZXIgPSB2ID0+IHtcbiAgICAgIGxldCB2YWx1ZSwgc2hvdWxkU2VuZCA9IHRydWVcblxuXG4gICAgICBpZiggdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB2ID09PSBudWxsICkge1xuICAgICAgICB2YWx1ZSA9IHRyYW5zZm9ybSAhPT0gbnVsbCA/IHRyYW5zZm9ybSggdiApIDogdlxuXG4gICAgICAgIGlmKCBpc1BvbHkgPT09IHRydWUgKSB7XG4gICAgICAgICAgY29uc3QgX193cmFwcGVkT2JqZWN0ID0gb2JqLl9fd3JhcHBlZF9fXG4gICAgICAgICAgY29uc3Qgdm9pY2UgPSBfX3dyYXBwZWRPYmplY3Qudm9pY2VzWyBfX3dyYXBwZWRPYmplY3Qudm9pY2VDb3VudCAlIF9fd3JhcHBlZE9iamVjdC52b2ljZXMubGVuZ3RoIF1cbiAgICAgICAgICB2b2ljZVsgbmFtZSBdID0gdmFsdWVcblxuICAgICAgICAgIHNob3VsZFNlbmQgPSBmYWxzZVxuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidwcm9wZXJ0eScsXG4gICAgICAgICAgICBvYmplY3Q6dm9pY2UuaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KSBcblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvYmpbICdfXycrbmFtZV0udmFsdWUgPSB2XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB2LnR5cGUgPT09ICdnZW4nICkge1xuICAgICAgICAvLyBnZW4gb2JqZWN0cyBjYW4gYmUgcmVmZXJyZWQgdG8gd2l0aG91dCB0aGUgZ3JhcGhpY3MvYXVkaW8gYWJzdHJhY3Rpb24sXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIGhhdmUgbm8gLnJlbmRlcigpIGZ1bmN0aW9uLCBhbmQgZG9uJ3QgbmVlZCB0byBiZSByZW5kZXJlZFxuXG4gICAgICAgIHYgPSB0cmFuc2Zvcm0gIT09IG51bGwgPyB0cmFuc2Zvcm0oIHYgKSA6IHYgICAgICAgXG4gICAgICAgIGNvbnN0IGdlbiA9IHYucmVuZGVyICE9PSB1bmRlZmluZWQgPyB2LnJlbmRlcigpIDogdiBcblxuICAgICAgICBvYmpbJ19fJysgbmFtZSBdLnZhbHVlID0gZ2VuIFxuICAgICAgICB2YWx1ZSA9IHsgaWQ6IGdlbi5pZCB9XG4gICAgICB9ZWxzZSBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkgeyAvLyYmIHR5cGVvZiB2ICE9PSBudWxsICkge1xuICAgICAgICAvL2lmKCBvYmouX191c2VNYXBwaW5nID09PSBmYWxzZSB8fCBuYW1lID09PSAnaW5wdXQnICkge1xuICAgICAgICAvLyAgb2JqWyAnX18nK25hbWVdLnZhbHVlID0gdlxuICAgICAgICAvLyAgdmFsdWUgPSB2ICE9PSBudWxsID8geyBpZDp2LmlkIH0gOiB2XG4gICAgICAgIC8vfWVsc2V7XG4gICAgICAgIC8vICAvL0F1ZGlvLmNyZWF0ZU1hcHBpbmcoIHYsIG9iaiwgbmFtZSwgb2JqLl9fd3JhcHBlZF9fIClcbiAgICAgICAgLy8gIGNvbnN0IGYgPSBvYmpbICdfXycgKyBuYW1lIF0uZm9sbG93ID0gRm9sbG93KHsgaW5wdXQ6IHYgfSlcblxuICAgICAgICAvLyAgbGV0IG0gPSBmLm11bHRpcGxpZXJcbiAgICAgICAgLy8gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqWyBuYW1lIF0sICdtdWx0aXBsaWVyJywge1xuICAgICAgICAvLyAgICBnZXQoKSB7IHJldHVybiBtIH0sXG4gICAgICAgIC8vICAgIHNldCh2KSB7IG0gPSB2OyBmLm11bHRpcGxpZXIgPSBtIH1cbiAgICAgICAgLy8gIH0pXG5cbiAgICAgICAgLy8gIGxldCBvID0gZi5vZmZzZXRcbiAgICAgICAgLy8gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqWyBuYW1lIF0sICdvZmZzZXQnLCB7XG4gICAgICAgIC8vICAgIGdldCgpIHsgcmV0dXJuIG8gfSxcbiAgICAgICAgLy8gICAgc2V0KHYpIHsgbyA9IHY7IGYub2Zmc2V0ID0gbyB9XG4gICAgICAgIC8vICB9KVxuXG4gICAgICAgICAgLy93cmFwcGVkVG9bIG5hbWUgXSA9IGZcbiAgICAgICAgICAvL29ialsgJ19fJytuYW1lIF0udmFsdWUgPSBmLl9fd3JhcHBlZF9fXG4gICAgICAgICAgLy92YWx1ZSA9IHsgaWQ6Zi5pZCB9XG4gICAgICAgICAgb2JqWyAnX18nK25hbWUgXS52YWx1ZSA9IHYuX193cmFwcGVkX19cbiAgICAgICAgICB2YWx1ZSA9IHsgaWQ6di5pZCB9XG4gICAgICAgIC8vfVxuICAgICAgICAgICAgICAgLy9cbiAgICAgICAgLy9vYmpbICdfXycrbmFtZV0udmFsdWUgPSB2XG4gICAgICAgIC8vdmFsdWUgPSB2ICE9PSBudWxsID8geyBpZDp2LmlkIH0gOiB2XG4gICAgICB9XG5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICYmIHNob3VsZFNlbmQgPT09IHRydWUgKSB7XG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFkZHJlc3M6J3Byb3BlcnR5JyxcbiAgICAgICAgICBvYmplY3Q6b2JqLmlkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSkgXG4gICAgICB9XG4gICAgICBpZiggcG9zdCAhPT0gbnVsbCApIHtcbiAgICAgICAgcG9zdC5jYWxsKCBvYmogKVxuICAgICAgfSAgICAgXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIEF1ZGlvLnB1Ymxpc2goIGBwcm9wZXJ0eS5zZXQ6JHtvYmouaWR9YCwgb2JqLCB2IClcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0dGVyXG4gIH0sXG5cbiAgY3JlYXRlRmFkZSggZnJvbT1udWxsLCB0bz1udWxsLCB0aW1lPTEsIG9iaiwgbmFtZSwgZGVsYXk9MCApIHtcbiAgICBpZiggZnJvbSA9PT0gbnVsbCApIGZyb20gPSBvYmpbIG5hbWUgXS52YWx1ZVxuICAgIGlmKCB0byA9PT0gbnVsbCApIHRvID0gb2JqWyBuYW1lIF0udmFsdWVcblxuICAgIHRpbWUgPSBBdWRpby5DbG9jay50aW1lKCB0aW1lIClcblxuICAgIC8vIFhYWCBvbmx5IGNvdmVycyBjb25kaXRpb24gd2hlcmUgcmFtcHMgZnJvbSBmYWRlcyBhcmUgYXNzaWduZWQuLi5cbiAgICAvLyBkb2VzIHRoaXMgbmVlZCB0byBiZSBtb3JlIGdlbmVyaWM/XG4gICAgaWYoIGlzTmFOKCBmcm9tICkgJiYgZnJvbS5fX3dyYXBwZWRfXy51Z2VuTmFtZS5pbmRleE9mKCdyYW1wJykgPiAtMSApIHtcbiAgICAgIGZyb20gPSBmcm9tLnRvLnZhbHVlXG4gICAgfVxuICAgIGlmKCBpc05hTiggdG8gKSAmJiB0by5fX3dyYXBwZWRfXy51Z2VuTmFtZS5pbmRleE9mKCdyYW1wJykgPiAtMSApIHtcbiAgICAgIHRvID0gdG8udG8udmFsdWVcbiAgICB9XG5cbiAgICBsZXQgcmFtcCA9IEF1ZGlvLmVudmVsb3Blcy5SYW1wKHsgZnJvbSwgdG8sIGxlbmd0aDp0aW1lLCBzaG91bGRMb29wOmZhbHNlIH0pXG4gICAgLy8gdGhpcyBpcyBhIGtleSB0byBub3QgdXNlIGFuIGVudmVsb3BlIGZvbGxvd2VyIGZvciBtYXBwaW5nXG4gICAgcmFtcC5fX3VzZU1hcHBpbmcgPSBmYWxzZVxuXG4gICAgaWYoIGRlbGF5ID09PSAwICkge1xuICAgICAgb2JqWyBuYW1lIF0gPSByYW1wXG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1dHVyZSggKG9iaixuYW1lLHJhbXApID0+IHsgXG4gICAgICAgIG9ialsgbmFtZSBdID0gcmFtcCBcbiAgICAgIH0sIGRlbGF5LCB7IG9iaiwgbmFtZSwgcmFtcDpyYW1wLl9fd3JhcHBlZF9fIH0gKVxuICAgIH1cblxuICAgIGlmKCByYW1wLl9fd3JhcHBlZF9fID09PSB1bmRlZmluZWQgKSByYW1wLl9fd3JhcHBlZF9fID0ge31cbiAgICByYW1wLl9fd3JhcHBlZF9fLnZhbHVlcyA9IFtdXG5cbiAgICByYW1wLl9fd3JhcHBlZF9fLm91dHB1dCA9IHYgPT4ge1xuICAgICAgaWYoIHJhbXAuX193cmFwcGVkX18gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmFtcC5fX3dyYXBwZWRfXy52YWx1ZXMudW5zaGlmdCggdiApXG4gICAgICAgIHdoaWxlKCByYW1wLl9fd3JhcHBlZF9fLnZhbHVlcy5sZW5ndGggPiA2MCApIHJhbXAuX193cmFwcGVkX18udmFsdWVzLnBvcCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFtcC5fX3dyYXBwZWRfXy5maW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gcmFtcC5fX3dyYXBwZWRfX1xuXG4gICAgICAvLyBYWFggSSBjYW4ndCBxdWl0ZSBmaWd1cmUgb3V0IHdoeSBJIGhhdmUgdG8gd2FpdCB0byByZXNldCB0aGUgcHJvcGVydHkgXG4gICAgICAvLyB2YWx1ZSBoZXJlLi4uIGlmIEkgZG9uJ3QsIHRoZW4gdGhlIGZhZGUgdWdlbiBzdGF5cyBhc3NpZ25lZCBpbiB0aGUgd29ya2xldCBwcm9jZXNzb3IuXG4gICAgICAvLyBhbmQgMCBkb2Vzbid0IHdvcmshXG4gICAgICBzZXRUaW1lb3V0KCAoKT0+IG9ialsgbmFtZSBdID0gc3RvcmUudG8gPT09IDAgPyAuMDAwMDAxIDogc3RvcmUudG8sIDAgKVxuICAgICAgc3RvcmUud2lkZ2V0LmNsZWFyKClcbiAgICB9XG5cbiAgICByYW1wLl9fd3JhcHBlZF9fLmZyb20gPSBmcm9tXG4gICAgcmFtcC5fX3dyYXBwZWRfXy50byA9IHRvXG5cbiAgICByZXR1cm4gb2JqXG4gIH0sXG5cbiAgLy8gd2hhdCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IChhdXRvbWFnaWNrYWxseT8pXG4gIC8vIGZpbHRlcmVkIHRocm91Z2ggQXVkaW8uQ2xvY2sudGltZSgpP1xuICB0aW1lUHJvcHMgOiB7XG4gICAgU3ludGg6WyAnYXR0YWNrJywgJ2RlY2F5JywgJ3N1c3RhaW4nLCAncmVsZWFzZScgXSxcbiAgICBQb2x5U3ludGg6WyAnYXR0YWNrJywgJ2RlY2F5JywgJ3N1c3RhaW4nLCAncmVsZWFzZScgXSxcbiAgICBDb21wbGV4OlsgJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnIF0sXG4gICAgUG9seUNvbXBsZXg6WyAnYXR0YWNrJywgJ2RlY2F5JywgJ3N1c3RhaW4nLCAncmVsZWFzZScgXSxcbiAgICBGTTpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIFBvbHlGTTpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIE1vbm9zeW50aDpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIFBvbHlNb25vOlsgJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnIF0sXG4gICAgRGVsYXk6WyAndGltZScgXSwgXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdWRpb1xuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgQmlub3BzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGJpbm9wcyA9IHt9XG5cbiAgICBmb3IoIGxldCBiaW5vcE5hbWUgaW4gR2liYmVyaXNoLmJpbm9wcyApIHtcbiAgICAgIGNvbnN0IGdpYmJlcmlzaENvbnN0cnVjdG9yID0gR2liYmVyaXNoLmJpbm9wc1sgYmlub3BOYW1lIF1cblxuICAgICAgY29uc3QgbWV0aG9kcyA9IEJpbm9wcy5kZXNjcmlwdGlvbnNbIGJpbm9wTmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogQmlub3BzLmRlc2NyaXB0aW9uc1sgYmlub3BOYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzLFxuICAgICAgICBtZXRob2RzOm1ldGhvZHMsXG4gICAgICAgIG5hbWU6Ymlub3BOYW1lLFxuICAgICAgICBjYXRlZ29yeTonYmlub3BzJ1xuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24ucHJvcGVydGllcy50eXBlID0gJ2Jpbm9wJ1xuXG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8sIGZhbHNlLCB0cnVlIClcbiAgICAgIGJpbm9wc1sgYmlub3BOYW1lIF0gPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgICAgY29uc3QgdWdlbiA9IGNvbnN0cnVjdG9yKCAuLi5hcmdzIClcbiAgICAgICAgdWdlblswXSA9IHVnZW4uX193cmFwcGVkX19bMF1cbiAgICAgICAgdWdlblsxXSA9IHVnZW4uX193cmFwcGVkX19bMV1cblxuICAgICAgICByZXR1cm4gdWdlblxuICAgICAgfSBcbiAgICB9XG4gICAgcmV0dXJuIGJpbm9wc1xuICB9LFxuXG4gIGRlc2NyaXB0aW9uczoge1xuICAgIC8vQ2hvcnVzOnsgbWV0aG9kczpbXSB9LFxuICB9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCaW5vcHNcbiIsImNvbnN0IEdpYmJlcmlzaCA9IHJlcXVpcmUoICdnaWJiZXJpc2gtZHNwJyApXG5jb25zdCBVZ2VuICAgICAgPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5cbmNvbnN0IEJ1c3NlcyA9IHtcbiAgY3JlYXRlKCBBdWRpbyApIHtcbiAgICBjb25zdCBidXNzZXMgPSB7fVxuXG4gICAgY29uc3QgYnVzRGVzY3JpcHRpb24gPSB7IFxuICAgICAgcHJvcGVydGllczpHaWJiZXJpc2guQnVzLmRlZmF1bHRzLFxuICAgICAgbWV0aG9kczpudWxsLFxuICAgICAgbmFtZTonQnVzJyxcbiAgICAgIGNhdGVnb3J5OidtaXNjJ1xuICAgIH1cblxuICAgIGJ1c3Nlcy5CdXMgPSBVZ2VuKCBHaWJiZXJpc2guQnVzLCBidXNEZXNjcmlwdGlvbiwgQXVkaW8gKVxuICAgIGJ1c3Nlcy5fX0J1cyA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgbGV0IHByb3BzXG4gICAgICBpZiggYXJncy5sZW5ndGggPiAxIHx8IGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgcHJvcHMgPSB7IGlucHV0czphcmdzIH1cbiAgICAgIH1lbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgcHJvcHMgPSBhcmdzWzBdXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwcm9wcyAhPT0gdW5kZWZpbmVkID8gYnVzc2VzLl9fQnVzKCBwcm9wcyApIDogYnVzc2VzLl9fQnVzKClcbiAgICB9XG5cbiAgICBjb25zdCBidXMyRGVzY3JpcHRpb24gPSB7IFxuICAgICAgcHJvcGVydGllczpHaWJiZXJpc2guQnVzMi5kZWZhdWx0cyxcbiAgICAgIG1ldGhvZHM6bnVsbCxcbiAgICAgIG5hbWU6J0J1czInLFxuICAgICAgY2F0ZWdvcnk6J21pc2MnXG4gICAgfVxuXG4gICAgYnVzc2VzLkJ1czIgPSBVZ2VuKCBHaWJiZXJpc2guQnVzMiwgYnVzMkRlc2NyaXB0aW9uLCBBdWRpbyApXG4gICAgYnVzc2VzLl9fQnVzMiA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgbGV0IHByb3BzXG4gICAgICBpZiggYXJncy5sZW5ndGggPiAxIHx8IChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycgJiYgYXJnc1swXS50eXBlICE9PSAnZW5zZW1ibGUnICkpIHtcbiAgICAgICAgcHJvcHMgPSB7IGlucHV0czphcmdzIH1cbiAgICAgIH1lbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgcHJvcHMgPSBhcmdzWzBdXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwcm9wcyAhPT0gdW5kZWZpbmVkID8gYnVzc2VzLl9fQnVzMiggcHJvcHMgKSA6IGJ1c3Nlcy5fX0J1czIoKVxuICAgIH1cblxuICAgIHJldHVybiBidXNzZXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1c3Nlc1xuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IHNlcmlhbGl6ZSA9IHJlcXVpcmUoICdzZXJpYWxpemUtamF2YXNjcmlwdCcgKVxuXG4vLyBYWFggbXVzdCB1c2UgZm9ybSBrZXk6ZnVuY3Rpb24oKSB7fSBkdWUgdG8gc2VyaWFsaXphdGlvblxuY29uc3QgQ2xvY2sgPSB7XG4gIF9fYmVhdENvdW50OjAsXG4gIGlkOm51bGwsXG4gIG5vZ2liYmVyaXNoOnRydWUsXG4gIGJwbToxNDAsXG4gIF9fbGFzdEJQTToxNDAsXG4gIHNlcTpudWxsLFxuXG4gIGV4cG9ydDpmdW5jdGlvbiggb2JqICkge1xuICAgIG9iai5idG9zID0gQ2xvY2suYnRvcy5iaW5kKCBDbG9jayApXG4gICAgb2JqLmJ0b21zID0gQ2xvY2suYnRvbXMuYmluZCggQ2xvY2sgKVxuICAgIG9iai5zdG9iID0gQ2xvY2suc3RvYi5iaW5kKCBDbG9jayApXG4gIH0sXG5cbiAgc3RvcmU6ZnVuY3Rpb24oKSB7IFxuICAgIEdpYmJlcmlzaC5DbG9jayA9IHRoaXNcbiAgICB0aGlzLmJlYXRDb3VudCA9IDBcbiAgICB0aGlzLnF1ZXVlID0gW11cbiAgICB0aGlzLmluaXQoKVxuICB9LFxuXG4gIGFkZFRvUXVldWU6ZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgIGFyZ3MgPSBhcmdzWzBdXG4gICAgICBhcmdzLmZvckVhY2goIHYgPT4gR2liYmVyaXNoLkNsb2NrLnF1ZXVlLnB1c2goIHYgKSApXG4gICAgfWVsc2V7XG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWRkcmVzczogJ21ldGhvZCcsXG4gICAgICAgIG9iamVjdDogdGhpcy5pZCxcbiAgICAgICAgbmFtZTogJ2FkZFRvUXVldWUnLFxuICAgICAgICBhcmdzOiBzZXJpYWxpemUoIGFyZ3MgKSxcbiAgICAgICAgZnVuY3Rpb25zOiB0cnVlXG4gICAgICB9KSBcbiAgICB9XG4gIH0sXG5cbiAgaW5pdDpmdW5jdGlvbiggR2VuLCBBdWRpbyApIHtcbiAgICAvLyBuZWVkZWQgc28gdGhhdCB3aGVuIHRoZSBjbG9jayBpcyByZS1pbml0aWFsaXplZCAoZm9yIGV4YW1wbGUsIGFmdGVyIGNsZWFyaW5nKVxuICAgIC8vIGdpYmJlciB3b24ndCB0cnkgYW5kIHNlcmlhbGl6ZWQgaXRzIHNlcXVlbmNlclxuICAgIHRoaXMuc2VxID0gbnVsbFxuXG4gICAgY29uc3QgY2xvY2tGdW5jID0gKCk9PiB7XG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWRkcmVzczogJ2JlYXQnLFxuICAgICAgICB2YWx1ZTogdGhpcy5iZWF0Q291bnRcbiAgICAgIH0pIFxuXG4gICAgICBpZiggdGhpcy5iZWF0Q291bnQrKyAlIDQgPT09IDAgKSB7XG4gICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IucGxheVF1ZXVlKCkvLy5mb3JFYWNoKCBmID0+IHsgZigpIH0gKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgdGhpcy5pZCA9IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcbiAgICAgIHRoaXMuYXVkaW9DbG9jayA9IG51bGxcbiAgICAgIHRoaXMuX19yYXRlID0gbnVsbFxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWRkcmVzczonYWRkJyxcbiAgICAgICAgcHJvcGVydGllczpzZXJpYWxpemUoIENsb2NrICksXG4gICAgICAgIGlkOnRoaXMuaWQsXG4gICAgICAgIHBvc3Q6ICdzdG9yZScgICAgXG4gICAgICB9KVxuICAgICAgXG4gICAgICBsZXQgYnBtID0gdGhpcy5fX2xhc3RCUE1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2JwbScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gYnBtIH0sXG4gICAgICAgIHNldCh2KXsgXG4gICAgICAgICAgYnBtID0gdlxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RCUE0gPSB2XG4gICAgICAgICAgICBpZiggQXVkaW8uR2liYmVyLlRpZGFsICE9PSB1bmRlZmluZWQgKSBBdWRpby5HaWJiZXIuVGlkYWwuY3BzID0gYnBtLzEyMC8yXG4gICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgYWRkcmVzczonc2V0JyxcbiAgICAgICAgICAgICAgb2JqZWN0OnRoaXMuaWQsXG4gICAgICAgICAgICAgIG5hbWU6J2JwbScsXG4gICAgICAgICAgICAgIHZhbHVlOmJwbSBcbiAgICAgICAgICAgIH0pIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5hdWRpb0Nsb2NrID0gR2VuLm1ha2UoIEdlbi51Z2Vucy5hYnMoMSkgKVxuICAgICAgLy90aGlzLl9fcmF0ZSA9IHRoaXMuYXVkaW9DbG9jay5fX3AwIFxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdyYXRlJywge1xuICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5hdWRpb0Nsb2NrIH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICB0aGlzLmF1ZGlvQ2xvY2sucDAgPSB2XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAvLyAgYWRkcmVzczonc2V0JyxcbiAgICAgIC8vICB2YWx1ZTogR2VuLm1ha2UoIEdlbi51Z2Vucy5hYnMoMSkgKSxcbiAgICAgIC8vICBvYmplY3Q6dGhpcy5pZCxcbiAgICAgIC8vICBuYW1lOidhdWRpb0Nsb2NrJ1xuICAgICAgLy99KVxuXG4gICAgICB0aGlzLmJwbSA9IHRoaXMuX19sYXN0QlBNXG4gICAgfVxuXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApXG4gICAgICB0aGlzLnNlcSA9IEdpYmJlcmlzaC5TZXF1ZW5jZXIubWFrZSggWyBjbG9ja0Z1bmMgXSwgWyAoKT0+R2liYmVyaXNoLkNsb2NrLnRpbWUoIDEvNCApIF0gKS5zdGFydCgpXG5cbiAgfSxcblxuICBjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICBpZiggdGhpcy5hdWRpb0Nsb2NrICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnB1c2goIHRoaXMuYXVkaW9DbG9jayApXG4gICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgY29uc29sZS5sb2coICdjbG9jayBjb25uZWN0ZWQnIClcbiAgICB9XG4gIH0sXG5cbiAgLy8gdGltZSBhY2NlcHRzIGFuIGlucHV0IHZhbHVlIGFuZCBjb252ZXJ0cyBpdCBpbnRvIHNhbXBsZXMuIHRoZSBpbnB1dCB2YWx1ZVxuICAvLyBtYXkgYmUgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzLCBiZWF0cyBvciBzYW1wbGVzLlxuICB0aW1lOiBmdW5jdGlvbiggaW5wdXRUaW1lID0gMCApIHtcbiAgICBsZXQgb3V0cHV0VGltZSA9IGlucHV0VGltZVxuXG4gICAgLy8gaWYgaW5wdXQgaXMgYW4gYW5ub3RhdGVkIHRpbWUgdmFsdWUgc3VjaCBhcyB3aGF0IGlzIHJldHVybmVkXG4gICAgLy8gYnkgc2FtcGxlcygpIG9yIG1zKCkuLi5cbiAgICAvLyBjb25zb2xlLmxvZyggJ2lucHV0IHRpbWU6JyAsIGlucHV0VGltZSApXG4gICAgaWYoIGlzTmFOKCBpbnB1dFRpbWUgKSApIHtcbiAgICAgIGlmKCB0eXBlb2YgaW5wdXRUaW1lID09PSAnb2JqZWN0JyApIHsgXG4gICAgICAgIGlmKCBpbnB1dFRpbWUudHlwZSA9PT0gJ3NhbXBsZXMnICkge1xuICAgICAgICAgIG91dHB1dFRpbWUgPSBpbnB1dFRpbWUudmFsdWVcbiAgICAgICAgfWVsc2UgaWYoIGlucHV0VGltZS50eXBlID09PSAnbXMnICkge1xuICAgICAgICAgIG91dHB1dFRpbWUgPSB0aGlzLm1zdG9zKCBpbnB1dFRpbWUudmFsdWUgKSBcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICB9ZWxzZXtcbiAgICAgIC8vIFhYWCA0IGlzIGEgbWFnaWMgbnVtYmVyLCBuZWVkcyB0byBhY2NvdW50IGZvciB0aGUgY3VycmVudCB0aW1lIHNpZ25hdHVyZVxuICAgICAgb3V0cHV0VGltZSA9IHRoaXMuYnRvcyggaW5wdXRUaW1lICogNCApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRwdXRUaW1lXG4gIH0sXG5cbiAgLy8gZG9lcyBub3Qgd29yay4uLiBzYXlzIEdpYmJlcmlzaCBjYW4ndCBiZSBmb3VuZD8gSSBndWVzcyBHaWJiZXJpc2ggaXNuJ3QgaW4gdGhlXG4gIC8vIGdsb2JhbCBzY29wZSBvZiB0aGUgd29ya2xldD9cbiAgVGltZTogZnVuY3Rpb24oIGlucHV0VGltZSApIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCBgcmV0dXJuIEdpYmJlcmlzaC5DbG9jay50aW1lKCAke2lucHV0VGltZX0gKWAgKVxuICB9LFxuXG4gIG1zdG9zOiBmdW5jdGlvbiggbXMgKSB7XG4gICAgcmV0dXJuICggbXMgLyAxMDAwICkgKiBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGVcbiAgfSxcblxuICAvLyBjb252ZXJ0IGJlYXRzIHRvIHNhbXBsZXNcbiAgYnRvczogZnVuY3Rpb24oIGJlYXRzICkge1xuICAgIGNvbnN0IHNhbXBsZXNQZXJCZWF0ID0gR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gKHRoaXMuYnBtIC8gNjAgKVxuICAgIHJldHVybiBzYW1wbGVzUGVyQmVhdCAqIGJlYXRzIFxuICB9LFxuXG4gIC8vIGNvbnZlcnQgc2FtcGxlcyB0byBiZWF0cyAoZm9yIHBhdHRlcm4gdmlzdWFsaXphdGlvbnMpXG4gIHN0b2I6IGZ1bmN0aW9uKCBzYW1wbGVzICkge1xuICAgIGNvbnN0IHNhbXBsZXNQZXJCZWF0ID0gR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gKHRoaXMuYnBtIC8gNjAgKVxuICAgIHJldHVybiAoc2FtcGxlcyAvIHNhbXBsZXNQZXJCZWF0KSAqIC4yNSAvLyBYWFggbWFnaWMgbnVtYmVyIHNob3VsZCBiZSBkZW5vbWluYXRvciBvZiB0aW1lIHNpZ25hdHVyZSBcbiAgfSxcbiAgLy8gY29udmVydCBiZWF0cyB0byBtaWxsaXNlY29uZHNcbiAgYnRvbXM6IGZ1bmN0aW9uKCBiZWF0cyApIHtcbiAgICBjb25zdCBzYW1wbGVzUGVyTXMgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyAxMDAwXG4gICAgcmV0dXJuIGJlYXRzICogc2FtcGxlc1Blck1zXG4gIH0sXG5cbiAgbXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICByZXR1cm4geyB0eXBlOidtcycsIHZhbHVlIH1cbiAgfSxcblxuICBzYW1wbGVzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgcmV0dXJuIHsgdHlwZTonc2FtcGxlcycsIHZhbHVlIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrXG4iLCJjb25zdCBVZ2VuID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuY29uc3QgUHJlc2V0cyA9IHJlcXVpcmUoICcuL3ByZXNldHMuanMnIClcblxubGV0IEF1ZGlvID0gbnVsbFxuXG5jb25zdCBhZGRNZXRob2QgPSAoIG9iaiwgbmFtZSwgX192YWx1ZSA9IDEsIHByb3BPdmVycmlkZU5hbWUgKSA9PiB7XG4gIGlmKCBwcm9wT3ZlcnJpZGVOYW1lID09PSB1bmRlZmluZWQgKSBwcm9wT3ZlcnJpZGVOYW1lID0gbmFtZVxuXG4gIG9ialsgJ19fJyArIG5hbWUgXSA9IHsgXG4gICAgdmFsdWU6IF9fdmFsdWUsXG4gICAgaXNQcm9wZXJ0eTp0cnVlLFxuICAgIHNlcXVlbmNlcnM6W10sXG4gICAgbW9kczpbXSxcbiAgICBuYW1lLFxuXG4gICAgc2VxKCB2YWx1ZXMsIHRpbWluZ3MsIG51bWJlciA9IDAsIGRlbGF5ID0gMCApIHtcbiAgICAgIGxldCBwcmV2U2VxID0gb2JqWydfXycrbmFtZV0uc2VxdWVuY2Vyc1sgbnVtYmVyIF0gXG4gICAgICBpZiggcHJldlNlcSAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgcHJldlNlcS5zdG9wKCk7IHByZXZTZXEuY2xlYXIoKTsgXG4gICAgICAgIGxldCBpZHggPSBvYmouX19zZXF1ZW5jZXJzLmluZGV4T2YoIHByZXZTZXEgKVxuICAgICAgICBvYmouX19zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClcbiAgICAgIH1cblxuICAgICAgLy8gWFhYIHlvdSBoYXZlIHRvIGFkZCBhIG1ldGhvZCB0aGF0IGRvZXMgYWxsIHRoaXMgc2hpdCBvbiB0aGUgd29ya2xldC4gY3JhcC5cbiAgICAgIG9ialsnX18nK25hbWVdLnNlcXVlbmNlcnNbIG51bWJlciBdID0gb2JqWydfXycrbmFtZV1bIG51bWJlciBdID0gQXVkaW8uQ29yZS5TZXEoeyBcbiAgICAgICAgdmFsdWVzLCBcbiAgICAgICAgdGltaW5ncywgXG4gICAgICAgIHRhcmdldDpvYmouX193cmFwcGVkX18sIFxuICAgICAgICBrZXk6bmFtZSxcbiAgICAgICAgcmF0ZTpBdWRpby5DbG9jay5hdWRpb0Nsb2NrXG4gICAgICB9KVxuICAgICAgLnN0YXJ0KCBBdWRpby5DbG9jay50aW1lKCBkZWxheSApIClcblxuICAgICAgb2JqLl9fc2VxdWVuY2Vycy5wdXNoKCBvYmpbJ19fJytuYW1lXVsgbnVtYmVyIF0gKVxuXG4gICAgICAvLyByZXR1cm4gb2JqZWN0IGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgIHJldHVybiBvYmpcbiAgICB9LFxuICB9XG5cbiAgQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgYWRkcmVzczonYWRkTWV0aG9kJyxcbiAgICBrZXk6bmFtZSxcbiAgICBmdW5jdGlvbjpgZnVuY3Rpb24oICR7bmFtZX0gKSB7XG4gICAgICAgIGZvciggbGV0IGlucHV0IG9mIHRoaXMuaW5wdXRzICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICkgaW5wdXRbICcke3Byb3BPdmVycmlkZU5hbWV9JyBdID0gJHtuYW1lfVxuICAgICAgICB9XG4gICAgICB9YCxcbiAgICBpZDpvYmouaWQsXG4gICAgZGVsYXk6QXVkaW8uc2hvdWxkRGVsYXlcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgIGdldCgpIHsgcmV0dXJuIHRoaXNbICdfXycgKyBuYW1lIF0gfSxcbiAgICBzZXQodil7IFxuICAgICAgdGhpc1sgJ19fJyArIG5hbWUgXS52YWx1ZSA9IHZcbiAgICAgIGZvciggbGV0IHNhbXBsZXIgb2YgdGhpcy5zYW1wbGVycyApIHNhbXBsZXJbIHByb3BPdmVycmlkZU5hbWUgXSA9IHRoaXNbICdfXycgKyBuYW1lIF0udmFsdWUgXG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBfX0F1ZGlvICkge1xuICBBdWRpbyA9IF9fQXVkaW9cblxuICBjb25zdCBEcnVtcyA9IGZ1bmN0aW9uKCBzY29yZSwgdGltZSwgLi4uYXJncyApIHsgXG4gICAgLy8gWFhYIHdoYXQgdXJsIHByZWZpeCBzaG91bGQgSSBiZSB1c2luZz9cblxuICAgIGNvbnN0IHRlbXAgPSBBdWRpby5hdXRvQ29ubmVjdFxuICAgIEF1ZGlvLmF1dG9Db25uZWN0ID0gZmFsc2VcbiAgICBjb25zdCBrICA9IEF1ZGlvLmluc3RydW1lbnRzLlNhbXBsZXIoeyBmaWxlbmFtZTonLi9yZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrLndhdicgfSlcbiAgICBjb25zdCBzICA9IEF1ZGlvLmluc3RydW1lbnRzLlNhbXBsZXIoeyBmaWxlbmFtZTonLi9yZXNvdXJjZXMvYXVkaW9maWxlcy9zbmFyZS53YXYnIH0pXG4gICAgY29uc3QgY2ggPSBBdWRpby5pbnN0cnVtZW50cy5TYW1wbGVyKHsgZmlsZW5hbWU6Jy4vcmVzb3VyY2VzL2F1ZGlvZmlsZXMvaGF0LndhdicgfSlcbiAgICBjb25zdCBvaCA9IEF1ZGlvLmluc3RydW1lbnRzLlNhbXBsZXIoeyBmaWxlbmFtZTonLi9yZXNvdXJjZXMvYXVkaW9maWxlcy9vcGVuaGF0LndhdicgfSlcbiAgICBBdWRpby5hdXRvQ29ubmVjdCA9IHRlbXBcblxuICAgIGNvbnN0IGRydW1zID0gQXVkaW8uRW5zZW1ibGUoe1xuICAgICAgJ2tkJzogeyB0YXJnZXQ6aywgIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidraWNrJyB9LFxuICAgICAgWzBdOiB7IHRhcmdldDprLCAgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J2tpY2snIH0sXG4gICAgICAnc2QnOiB7IHRhcmdldDpzLCAgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J3NuYXJlJyB9LFxuICAgICAgJ3NuJzogeyB0YXJnZXQ6cywgIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidzbmFyZScgfSxcbiAgICAgIFsxXTogeyB0YXJnZXQ6cywgIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidzbmFyZScgfSxcbiAgICAgICdjaCc6IHsgdGFyZ2V0OmNoLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTonY2xvc2VkSGF0JyB9LFxuICAgICAgWzJdOiB7IHRhcmdldDpjaCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J2Nsb3NlZEhhdCcgfSxcbiAgICAgICdvaCc6IHsgdGFyZ2V0Om9oLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTonb3BlbkhhdCcgfSxcbiAgICAgIFszXTogeyB0YXJnZXQ6b2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidvcGVuSGF0JyB9LFxuICAgIH0pXG5cbiAgICBpZiggQXVkaW8uYXV0b0Nvbm5lY3QgPT09IHRydWUgKSBkcnVtcy5jb25uZWN0KClcblxuICAgIGRydW1zLl9fc2VxdWVuY2VycyA9IFsgXVxuICAgIC8vaWYoIHR5cGVvZiBzY29yZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgLy8gIGRydW1zLnNlcSA9IEF1ZGlvLlNlcSh7XG4gICAgLy8gICAgdGFyZ2V0OmRydW1zLFxuICAgIC8vICAgIGtleToncGxheScsXG4gICAgLy8gICAgdmFsdWVzOnNjb3JlLnNwbGl0KCcnKSxcbiAgICAvLyAgICB0aW1pbmdzOnRpbWUgPT09IHVuZGVmaW5lZCA/IDEgLyBzY29yZS5sZW5ndGggOiB0aW1lXG4gICAgLy8gIH0pLnN0YXJ0KClcbiAgICBcblxuICAgIC8vICBkcnVtcy52YWx1ZXMgPSBkcnVtcy5zZXEudmFsdWVzXG4gICAgLy8gIGRydW1zLnRpbWluZ3MgPSBkcnVtcy5zZXEudGltaW5nc1xuXG4gICAgLy8gIGRydW1zLl9fc2VxdWVuY2Vycy5wdXNoKCBkcnVtcy5zZXEgKVxuICAgIC8vfWVsc2V7XG4gICAgLy8gIEdpYmJlci5hZGRTZXF1ZW5jaW5nKCBkcnVtcywgJ3BsYXknLCAwIClcbiAgICAvL31cblxuICAgIGRydW1zLnNhbXBsZXJzID0gWyBrLHMsY2gsb2ggXVxuXG4gICAgYWRkTWV0aG9kKCBkcnVtcywgJ3BpdGNoJywgMSwgJ3JhdGUnIClcbiAgICBhZGRNZXRob2QoIGRydW1zLCAnc3RhcnQnLCAwIClcbiAgICBhZGRNZXRob2QoIGRydW1zLCAnZW5kJywgMSApXG5cbiAgICBwcm9wcyA9IFByZXNldHMucHJvY2VzcyggeyBuYW1lOidEcnVtcycsIGNhdGVnb3J5OidpbnN0cnVtZW50cycgfSwgYXJncywgQXVkaW8gKVxuICAgIGlmKCBwcm9wcyAhPT0gdW5kZWZpbmVkICYmIHByb3BzLl9fcHJlc2V0SW5pdF9fICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBPYmplY3QuYXNzaWduKCBkcnVtcywgcHJvcHMgKVxuICAgICAgaWYoIHByb3BzLl9fcHJlc2V0SW5pdF9fICE9PSB1bmRlZmluZWQgKSBwcm9wcy5fX3ByZXNldEluaXRfXy5jYWxsKCBkcnVtcywgQXVkaW8gKVxuICAgIH1cblxuICAgIGRydW1zLm5hbWUgPSAnRHJ1bXMnXG4gICAgcmV0dXJuIGRydW1zXG4gIH1cblxuICBjb25zdCBFRHJ1bXMgPSBmdW5jdGlvbiggIC4uLmFyZ3MgKSB7XG4gICAgY29uc3QgdGVtcCA9IEF1ZGlvLmF1dG9Db25uZWN0XG4gICAgQXVkaW8uYXV0b0Nvbm5lY3QgPSBmYWxzZVxuICAgIFxuICAgIGNvbnN0IGtkID0gQXVkaW8uaW5zdHJ1bWVudHMuS2ljaygpXG4gICAgY29uc3Qgc2QgPSBBdWRpby5pbnN0cnVtZW50cy5TbmFyZSgpXG4gICAgY29uc3QgY2ggPSBBdWRpby5pbnN0cnVtZW50cy5IYXQoeyBkZWNheTouMSwgZ2FpbjouMyB9KVxuICAgIGNvbnN0IG9oID0gQXVkaW8uaW5zdHJ1bWVudHMuSGF0KHsgZGVjYXk6LjUsIGdhaW46LjMgfSlcbiAgICBjb25zdCBjcCA9IEF1ZGlvLmluc3RydW1lbnRzLkNsYXAoKVxuICAgIGNvbnN0IGNiID0gQXVkaW8uaW5zdHJ1bWVudHMuQ293YmVsbCh7IGdhaW46LjY1IH0pXG4gICAgXG4gICAgQXVkaW8uYXV0b0Nvbm5lY3QgPSB0ZW1wXG4gICAgXG4gICAgY29uc3QgZHJ1bXMgPSBBdWRpby5FbnNlbWJsZSh7XG4gICAgICAna2QnOiB7IHRhcmdldDprZCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J2tpY2snIH0sXG4gICAgICBbMF06IHsgdGFyZ2V0OmtkLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTona2ljaycgfSxcbiAgICAgIFsxXTogeyB0YXJnZXQ6c2QsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidzbmFyZScgfSxcbiAgICAgICdzZCc6IHsgdGFyZ2V0OnNkLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTonc25hcmUnIH0sXG4gICAgICBbMl06IHsgdGFyZ2V0OmNoLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuMl0sIG5hbWU6J2Nsb3NlZEhhdCcgfSxcbiAgICAgICdjaCc6IHsgdGFyZ2V0OmNoLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuMl0sIG5hbWU6J2Nsb3NlZEhhdCcgfSxcbiAgICAgIFszXTogeyB0YXJnZXQ6b2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy4yXSwgbmFtZTonb3BlbkhhdCcgfSxcbiAgICAgICdvaCc6IHsgdGFyZ2V0Om9oLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuMl0sIG5hbWU6J29wZW5IYXQnIH0sXG4gICAgICBbNF06IHsgdGFyZ2V0OmNwLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuNV0sIG5hbWU6J2NsYXAnIH0sXG4gICAgICAnY3AnOiB7IHRhcmdldDpjcCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbLjVdLCBuYW1lOidjbGFwJyB9LFxuICAgICAgWzVdOiB7IHRhcmdldDpjYiwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbLjVdLCBuYW1lOidjb3diZWxsJyB9LFxuICAgICAgJ2NiJzogeyB0YXJnZXQ6Y2IsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy41XSwgbmFtZTonY293YmVsbCcgfSxcbiAgICB9KVxuXG4gICAgLy9pZiggdHlwZW9mIHNjb3JlID09PSAnc3RyaW5nJyApIHtcbiAgICAvLyAgZHJ1bXMuc2VxID0gQXVkaW8uU2VxKHtcbiAgICAvLyAgICB0YXJnZXQ6ZHJ1bXMsXG4gICAgLy8gICAga2V5OidwbGF5JyxcbiAgICAvLyAgICB2YWx1ZXM6c2NvcmUuc3BsaXQoJycpLFxuICAgIC8vICAgIHRpbWluZ3M6dGltZSA9PT0gdW5kZWZpbmVkID8gMSAvIHNjb3JlLmxlbmd0aCA6IHRpbWUsXG4gICAgLy8gICAgcmF0ZTpBdWRpby5DbG9jay5hdWRpb0Nsb2NrXG4gICAgLy8gIH0pLnN0YXJ0KClcblxuICAgIC8vICBkcnVtcy52YWx1ZXMgPSBkcnVtcy5zZXEudmFsdWVzXG4gICAgLy8gIGRydW1zLnRpbWluZ3MgPSBkcnVtcy5zZXEudGltaW5nc1xuICAgIC8vfVxuXG4gICAgaWYoIEF1ZGlvLmF1dG9Db25uZWN0ID09PSB0cnVlICkgZHJ1bXMuY29ubmVjdCgpXG5cbiAgICBwcm9wcyA9IFByZXNldHMucHJvY2VzcyggeyBuYW1lOidFRHJ1bXMnLCBjYXRlZ29yeTonaW5zdHJ1bWVudHMnIH0sIGFyZ3MsIEF1ZGlvIClcbiAgICBpZiggcHJvcHMgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5fX3ByZXNldEluaXRfXyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgcHJvcHMuX19wcmVzZXRJbml0X18uY2FsbCggZHJ1bXMsIEF1ZGlvIClcbiAgICB9XG5cbiAgICAvL2RydW1zLnRpZGFsID0gcGF0dGVybiA9PiB7XG4gICAgLy8gIGlmKCBkcnVtcy5fX3RpZGFsICE9PSB1bmRlZmluZWQgKSBkcnVtcy5fX3RpZGFsLnN0b3AoKVxuXG4gICAgLy8gIGRydW1zLl9fdGlkYWwgPSBBdWRpby5UaWRhbCh7XG4gICAgLy8gICAgdGFyZ2V0OmRydW1zLFxuICAgIC8vICAgIGtleToncGxheScsXG4gICAgLy8gICAgcGF0dGVyblxuICAgIC8vICB9KS5zdGFydCgpXG5cbiAgICAvLyAgcmV0dXJuIGRydW1zXG4gICAgLy99XG5cbiAgICBkcnVtcy5uYW1lID0gJ0VEcnVtcydcbiAgICByZXR1cm4gZHJ1bXNcbiAgfVxuXG4gIHJldHVybiB7IERydW1zLCBFRHJ1bXMgfVxufVxuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgRWZmZWN0cyA9IHtcbiAgY3JlYXRlKCBBdWRpbyApIHtcbiAgICBjb25zdCBlZmZlY3RzID0ge31cbiAgICBjb25zdCBwb29sRWZmZWN0cyA9IFsnRnJlZXZlcmInLCAnUGxhdGUnLCAnQnVmZmVyU2h1ZmZsZXInXVxuICAgIEdpYmJlcmlzaC5lZmZlY3RzID0gR2liYmVyaXNoLmZ4XG5cbiAgICBmb3IoIGxldCBlZmZlY3ROYW1lIGluIEdpYmJlcmlzaC5lZmZlY3RzICkge1xuICAgICAgY29uc3QgZ2liYmVyaXNoQ29uc3RydWN0b3IgPSBHaWJiZXJpc2guZWZmZWN0c1sgZWZmZWN0TmFtZSBdXG5cbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBFZmZlY3RzLmRlc2NyaXB0aW9uc1sgZWZmZWN0TmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogRWZmZWN0cy5kZXNjcmlwdGlvbnNbIGVmZmVjdE5hbWUgXS5tZXRob2RzXG5cbiAgICAgIC8vIFhYWCBob3cgZG8gd2UgbWFrZSB0aGlzIG1vcmUgZ2VuZXJpYyBmb3IgYW55IG1vZGVsIG9mIHJldmVyYiAvIGFueSB0eXBlIG9mIGRpc3RvcnRpb24gZXRjLlxuICAgICAgY29uc3QgcmVwbGFjZU5hbWUgPSBlZmZlY3ROYW1lID09PSAnRnJlZXZlcmInID8gJ1JldmVyYicgOiBlZmZlY3ROYW1lIFxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzIHx8IHt9LCBcbiAgICAgICAgbWV0aG9kczptZXRob2RzLFxuICAgICAgICBuYW1lOnJlcGxhY2VOYW1lLFxuICAgICAgICBjYXRlZ29yeTonZWZmZWN0cydcbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9uLnByb3BlcnRpZXMudHlwZSA9ICdmeCdcblxuICAgICAgY29uc3Qgc2hvdWxkVXNlUG9vbCA9IHBvb2xFZmZlY3RzLmluZGV4T2YoIGVmZmVjdE5hbWUgKSA+IC0xIFxuXG4gICAgICBlZmZlY3RzWyBlZmZlY3ROYW1lIF0gPSBVZ2VuKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvLCBzaG91bGRVc2VQb29sIClcbiAgICAgIFxuICAgICAgZWZmZWN0c1sgZWZmZWN0TmFtZSBdLnByZXNldHMgPSBBdWRpby5QcmVzZXRzLmVmZmVjdHNbIGVmZmVjdE5hbWUgXSBcbiAgICAgIGlmKCBlZmZlY3RzWyBlZmZlY3ROYW1lIF0ucHJlc2V0cyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICBlZmZlY3RzWyBlZmZlY3ROYW1lIF0ucHJlc2V0cy5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS50YWJsZSggdGhpcyApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBlZmZlY3RzWyBlZmZlY3ROYW1lIF0ucHJlc2V0cyA9IHsgaW5zcGVjdCgpIHsgY29uc29sZS5sb2coIGAke2VmZmVjdE5hbWV9IGhhcyBubyBwcmVzZXRzLmAgKSB9IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlZmZlY3RzLlJldmVyYiA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgbGV0IGFyZ3Byb3BzID0gbnVsbFxuICAgICAgaWYoIGFyZ3MubGVuZ3RoID09PSAxICkge1xuICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICkgYXJncHJvcHMgPSBhcmdzWzBdXG4gICAgICB9ZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDIgKSB7XG4gICAgICAgIGFyZ3Byb3BzID0gYXJnc1sxXVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgeyBtb2RlbDowIH0sIGFyZ3Byb3BzIClcblxuICAgICAgbGV0IHVnZW4gPSBudWxsXG4gICAgICBzd2l0Y2goIHByb3BzLm1vZGVsICkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdWdlbiA9IGVmZmVjdHMuRnJlZXZlcmIoLi4uYXJncyApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1Z2VuXG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHNcbiAgfSxcblxuICBkZXNjcmlwdGlvbnM6IHtcbiAgICAvL0Nob3J1czp7IG1ldGhvZHM6W10gfSxcbiAgfSxcbiAgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWZmZWN0c1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggQXVkaW8gKSB7XG4gIGNvbnN0IEdpYmJlcmlzaCA9IEF1ZGlvLkdpYmJlcmlzaFxuICBjb25zdCBFbnNlbWJsZSA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcbiAgICBjb25zdCBjcCA9IHtcbiAgICAgIHNob3VsZEFkZFRvVWdlbjp0cnVlXG4gICAgfVxuXG4gICAgZm9yKCBsZXQga2V5IGluIHByb3BzICkge1xuICAgICAgY29uc3QgZGljdCA9IHByb3BzWyBrZXkgXVxuICAgICAgY29uc3QgdGFyZ2V0ID0gZGljdC50YXJnZXRcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGRpY3QubWV0aG9kXG4gICAgICBjb25zdCBhcmdzID0gZGljdC5hcmdzXG4gICAgICBjcFsga2V5IF0gPSB7XG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCAuLi5hcmdzICkgeyBcbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5nZXQoIHRoaXMudGFyZ2V0IClbIHRoaXMubWV0aG9kIF0oIC4uLmFyZ3MgKSBcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0OnRhcmdldC5pZCxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBhcmdzLFxuICAgICAgICBuYW1lOmRpY3QubmFtZVxuICAgICAgfVxuXG4gICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eSggY3BbIGtleSBdLCAnbG91ZG5lc3MnLCB7XG4gICAgICAvLyAgc2V0KHYpIHtcbiAgICAgIC8vICAgIGNvbnNvbGUubG9nKCAnbG91ZG5lc3M6JywgdiwgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCB0aGlzLnRhcmdldCApKVxuICAgICAgLy8gICAgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCB0aGlzLnRhcmdldCApLmxvdWRuZXNzID0gdlxuICAgICAgLy8gIH1cbiAgICAgIC8vfSlcbiAgICAgIGNwWyBkaWN0Lm5hbWUgXSA9IHRhcmdldFxuICAgIH1cblxuICAgIGNwLnBsYXkgPSBmdW5jdGlvbiggX19rZXkgKSB7XG4gICAgICBjb25zdCBrZXkgPSBpc05hTihfX2tleSkgPyBfX2tleSA6IHBhcnNlSW50KCBfX2tleSApIFxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCB0aGlzWyBrZXkgXS50YXJnZXQgKVsgdGhpc1sga2V5IF0ubWV0aG9kIF0oIC4uLnRoaXNbIGtleSBdLmFyZ3MgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIHByb3BzWyBrZXkgXS50YXJnZXRbIHRoaXNbIGtleSBdLm1ldGhvZCBdKCAuLi50aGlzWyBrZXkgXS5hcmdzIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbnMgPSBBdWRpby5idXNzZXMuQnVzMiggY3AgKVxuICAgIGVucy5fX2lzRW5zZW1ibGUgPSB0cnVlXG5cbiAgICBmb3IoIGxldCBrZXkgaW4gcHJvcHMgKSB7XG4gICAgICBwcm9wc1sga2V5IF0udGFyZ2V0LmNvbm5lY3QoIGVucyApXG4gICAgfVxuICAgIFxuICAgIGVucy50aWRhbHMgPSBbXVxuXG4gICAgZW5zLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGVucy50aWRhbHMuZm9yRWFjaCggdCA9PiB0LnN0b3AoKSApXG4gICAgICBlbnMuX19zZXF1ZW5jZXJzLmZvckVhY2goIHQgPT4gdC5zdG9wKCkgKVxuICAgIH1cbiAgICBlbnMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGVucy50aWRhbHMuZm9yRWFjaCggdCA9PiB0LnN0YXJ0KCkgKVxuICAgICAgZW5zLl9fc2VxdWVuY2Vycy5mb3JFYWNoKCB0ID0+IHQuc3RhcnQoKSApXG4gICAgfVxuXG4gICAgZW5zLnRpZGFsID0gKHBhdHRlcm4sbnVtPTApID0+IHtcbiAgICAgIGNvbnN0IHQgPSAgQXVkaW8uR2liYmVyLlRpZGFsKHtcbiAgICAgICAgdGFyZ2V0OmVucyxcbiAgICAgICAga2V5OidwbGF5JyxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfSlcblxuICAgICAgaWYoIHQgIT09IG51bGwgKSB7XG4gICAgICAgIGlmKCBlbnMudGlkYWxzWyBudW0gXSAhPT0gdW5kZWZpbmVkICkgZW5zLnRpZGFsc1sgbnVtIF0uc3RvcCgpXG5cbiAgICAgICAgZW5zLnRpZGFsc1sgbnVtIF0gPSB0XG4gICAgICAgIHQuc3RhcnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5zXG4gICAgfVxuICAgIGVucy5fX3NlcXVlbmNlcnMgPSBbXVxuXG4gICAgZW5zLnNlcSA9ICh2YWx1ZXMsdGltaW5ncyxudW09MCxvZmZzZXQ9MCkgPT4ge1xuICAgICAgaWYoIGVucy5fX3NlcXVlbmNlcnNbIG51bSBdICE9PSB1bmRlZmluZWQgKSBlbnMuX19zZXF1ZW5jZXJzWyBudW0gXS5zdG9wKClcblxuICAgICAgZW5zLl9fc2VxdWVuY2Vyc1sgbnVtIF0gPSBBdWRpby5HaWJiZXIuU2VxKHtcbiAgICAgICAgdGFyZ2V0OmVucyxcbiAgICAgICAga2V5OidwbGF5JyxcbiAgICAgICAgdmFsdWVzLHRpbWluZ3Msb2Zmc2V0XG4gICAgICB9KS5zdGFydCgpXG5cbiAgICAgIHJldHVybiBlbnNcbiAgICB9XG5cbiAgICByZXR1cm4gZW5zXG4gIH1cblxuICByZXR1cm4gRW5zZW1ibGVcbn1cbiIsImNvbnN0IEdpYmJlcmlzaCA9IHJlcXVpcmUoICdnaWJiZXJpc2gtZHNwJyApXG5jb25zdCBVZ2VuICAgICAgPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5cbmNvbnN0IEVudmVsb3BlcyA9IHtcbiAgY3JlYXRlKCBBdWRpbyApIHtcbiAgICBjb25zdCBlbnZlbG9wZXMgPSB7fVxuXG4gICAgZm9yKCBsZXQgZW52ZWxvcGVOYW1lIGluIEdpYmJlcmlzaC5lbnZlbG9wZXMgKSB7XG4gICAgICBjb25zdCBnaWJiZXJpc2hDb25zdHJ1Y3RvciA9IEdpYmJlcmlzaC5lbnZlbG9wZXNbIGVudmVsb3BlTmFtZSBdXG5cbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBFbnZlbG9wZXMuZGVzY3JpcHRpb25zWyBlbnZlbG9wZU5hbWUgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEVudmVsb3Blcy5kZXNjcmlwdGlvbnNbIGVudmVsb3BlTmFtZSBdLm1ldGhvZHNcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0geyBcbiAgICAgICAgcHJvcGVydGllczpnaWJiZXJpc2hDb25zdHJ1Y3Rvci5kZWZhdWx0cyB8fCB7fSwgXG4gICAgICAgIG1ldGhvZHM6bWV0aG9kcyxcbiAgICAgICAgbmFtZTplbnZlbG9wZU5hbWUsXG4gICAgICAgIGNhdGVnb3J5OidlbnZlbG9wZXMnXG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbi5wcm9wZXJ0aWVzLnR5cGUgPSAnZW52ZWxvcGUnXG5cbiAgICAgIGVudmVsb3Blc1sgZW52ZWxvcGVOYW1lIF0gPSBVZ2VuKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvIClcbiAgICB9XG4gICAgcmV0dXJuIGVudmVsb3Blc1xuICB9LFxuXG4gIGRlc2NyaXB0aW9uczoge1xuICAgIC8vQ2hvcnVzOnsgbWV0aG9kczpbXSB9LFxuICB9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnZlbG9wZXNcbiIsIlxuXG4vKipcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdFxuICogdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVFxuICogV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxuICogdGhlIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWFsbSAoc2NvcGUsIHBhcmVudEVsZW1lbnQpIHtcbiAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgZnJhbWUuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOi05OTlweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGZyYW1lKTtcbiAgY29uc3Qgd2luID0gZnJhbWUuY29udGVudFdpbmRvdztcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICBsZXQgdmFycyA9ICd2YXIgd2luZG93LCRob29rJztcbiAgZm9yIChjb25zdCBpIGluIHdpbikge1xuICAgIGlmICghKGkgaW4gc2NvcGUpICYmIGkgIT09ICdldmFsJykge1xuICAgICAgdmFycyArPSAnLCc7XG4gICAgICB2YXJzICs9IGk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaSBpbiBzY29wZSkge1xuICAgIHZhcnMgKz0gJywnO1xuICAgIHZhcnMgKz0gaTtcbiAgICB2YXJzICs9ICc9c2VsZi4nO1xuICAgIHZhcnMgKz0gaTtcbiAgfVxuICBjb25zdCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXG4gICAgYGZ1bmN0aW9uICRob29rKHNlbGYsY29uc29sZSkge1widXNlIHN0cmljdFwiO1xuICAgICAgICAke3ZhcnN9O3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gZXZhbChhcmd1bWVudHNbMF0pfX1gXG4gICkpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB0aGlzLmV4ZWMgPSB3aW4uJGhvb2suY2FsbChzY29wZSwgc2NvcGUsIGNvbnNvbGUpO1xufVxuIiwiXG4vLyBTZWUgYWxsIHNjYWxlcyBhdDogaHR0cDovL2FiYmVybmllLmdpdGh1Yi5pby90dW5lL3NjYWxlcy5odG1sXG5cblxuY29uc3QgVHVuZSA9IGZ1bmN0aW9uKCl7XG5cblx0Ly8gdGhlIHNjYWxlIGFzIHJhdGlvc1xuXHR0aGlzLnNjYWxlID0gW11cblxuXHQvLyBpL28gbW9kZXNcblx0dGhpcy5tb2RlID0ge1xuXHRcdG91dHB1dDogXCJmcmVxdWVuY3lcIixcblx0XHRpbnB1dDogXCJzdGVwXCJcblx0fVxuXG5cdC8vIEVUIG1ham9yLCBmb3IgcmVmZXJlbmNlXG5cdHRoaXMuZXRtYWpvcj0gWyAyNjEuNjI1NTgsXG5cdFx0MjkzLjY2NDc2NCxcblx0XHQzMjkuNjI3NTYzLFxuXHRcdDM0OS4yMjgyNDEsXG5cdFx0MzkxLjk5NTQyMixcblx0XHQ0NDAsXG5cdFx0NDkzLjg4MzMwMSxcblx0XHQ1MjMuMjUxMTZcblx0XVxuXG4gIFxuICB0aGlzLlR1bmluZ0xpc3QgPSBudWxsXG5cdC8vIFJvb3QgZnJlcXVlbmN5LlxuXHR0aGlzLnRvbmljID0gNDQwXG5cblx0Y29uc29sZS5sb2coXCJ7e3t7IFR1bmUuanMgdjAuMSBMb2FkZWQgfX19fVwiKTtcblxufVxuXG4vKiBTZXQgdGhlIHRvbmljIGZyZXF1ZW5jeSAqL1xuXG5UdW5lLnByb3RvdHlwZS50b25pY2l6ZSA9IGZ1bmN0aW9uKG5ld1RvbmljKSB7XG5cdHRoaXMudG9uaWMgPSBuZXdUb25pY1xufVxuXG4vKiBSZXR1cm4gZGF0YSBpbiB0aGUgbW9kZSB5b3UgYXJlIGluIChmcmVxLCByYXRpbywgb3IgbWlkaSkgKi9cblxuVHVuZS5wcm90b3R5cGUubm90ZSA9IGZ1bmN0aW9uKGlucHV0LG9jdGF2ZSl7XG5cblx0dmFyIG5ld3ZhbHVlO1xuXG5cdGlmICh0aGlzLm1vZGUub3V0cHV0ID09IFwiZnJlcXVlbmN5XCIpIHsgXG5cdFx0bmV3dmFsdWUgPSB0aGlzLmZyZXF1ZW5jeShpbnB1dCxvY3RhdmUpXG5cdH0gZWxzZSBpZiAodGhpcy5tb2RlLm91dHB1dCA9PSBcInJhdGlvXCIpIHsgXG5cdFx0bmV3dmFsdWUgPSB0aGlzLnJhdGlvKGlucHV0LG9jdGF2ZSlcblx0fSBlbHNlIGlmICh0aGlzLm1vZGUub3V0cHV0ID09IFwiTUlESVwiKSB7IFxuXHRcdG5ld3ZhbHVlID0gdGhpcy5NSURJKGlucHV0LG9jdGF2ZSlcblx0fSBlbHNlIHtcblx0XHRuZXd2YWx1ZSA9IHRoaXMuZnJlcXVlbmN5KGlucHV0LG9jdGF2ZSlcblx0fVxuXG5cdFxuXHRyZXR1cm4gbmV3dmFsdWU7XG5cbn1cblxuXG4vKiBSZXR1cm4gZnJlcSBkYXRhICovXG5cblR1bmUucHJvdG90eXBlLmZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHN0ZXBJbiwgb2N0YXZlSW4pIHtcblxuXHRpZiAodGhpcy5tb2RlLmlucHV0ID09IFwibWlkaVwiIHx8IHRoaXMubW9kZS5pbnB1dCA9PSBcIk1JRElcIiApIHtcblx0XHR0aGlzLnN0ZXBJbiArPSA2MFxuXHR9XG5cdFxuXHQvLyB3aGF0IG9jdGF2ZSBpcyBvdXIgaW5wdXRcblx0dmFyIG9jdGF2ZSA9IE1hdGguZmxvb3Ioc3RlcEluL3RoaXMuc2NhbGUubGVuZ3RoKVxuXG5cdGlmIChvY3RhdmVJbikgeyBcblx0XHRvY3RhdmUgKz0gb2N0YXZlSW5cblx0fVxuXHRcblx0Ly8gd2hpY2ggc2NhbGUgZGVncmVlICgwIC0gc2NhbGUgbGVuZ3RoKSBpcyBvdXIgaW5wdXRcblx0dmFyIHNjYWxlRGVncmVlID0gc3RlcEluICUgdGhpcy5zY2FsZS5sZW5ndGhcblxuXHR3aGlsZSAoc2NhbGVEZWdyZWUgPCAwKSB7XG5cdFx0c2NhbGVEZWdyZWUgKz0gdGhpcy5zY2FsZS5sZW5ndGhcblx0fVxuXHRcblx0dmFyIGZyZXEgPSB0aGlzLnRvbmljKnRoaXMuc2NhbGVbc2NhbGVEZWdyZWVdXG5cdFxuXHRmcmVxID0gZnJlcSooTWF0aC5wb3coMixvY3RhdmUpKVxuXHRcblx0Ly8gdHJ1bmNhdGUgaXJyYXRpb25hbCBudW1iZXJzXG5cdGZyZXEgPSBNYXRoLmZsb29yKGZyZXEqMTAwMDAwMDAwMDAwKS8xMDAwMDAwMDAwMDBcblx0XG5cdHJldHVybiBmcmVxXG5cbn1cblxuLyogRm9yY2UgcmV0dXJuIHJhdGlvIGRhdGEgKi9cblxuVHVuZS5wcm90b3R5cGUucmF0aW8gPSBmdW5jdGlvbihzdGVwSW4sIG9jdGF2ZUluKSB7XG5cblx0aWYgKHRoaXMubW9kZS5pbnB1dCA9PSBcIm1pZGlcIiB8fCB0aGlzLm1vZGUuaW5wdXQgPT0gXCJNSURJXCIgKSB7XG5cdFx0dGhpcy5zdGVwSW4gKz0gNjBcblx0fVxuXHRcblx0Ly8gd2hhdCBvY3RhdmUgaXMgb3VyIGlucHV0XG5cdHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKHN0ZXBJbi90aGlzLnNjYWxlLmxlbmd0aClcblxuXHRpZiAob2N0YXZlSW4pIHsgXG5cdFx0b2N0YXZlICs9IG9jdGF2ZUluXG5cdH1cblx0XG5cdC8vIHdoaWNoIHNjYWxlIGRlZ3JlZSAoMCAtIHNjYWxlIGxlbmd0aCkgaXMgb3VyIGlucHV0XG5cdHZhciBzY2FsZURlZ3JlZSA9IHN0ZXBJbiAlIHRoaXMuc2NhbGUubGVuZ3RoXG5cblx0Ly8gd2hhdCByYXRpbyBpcyBvdXIgaW5wdXQgdG8gb3VyIGtleVxuXHR2YXIgcmF0aW8gPSBNYXRoLnBvdygyLG9jdGF2ZSkqdGhpcy5zY2FsZVtzY2FsZURlZ3JlZV1cblxuXHRyYXRpbyA9IE1hdGguZmxvb3IocmF0aW8qMTAwMDAwMDAwMDAwKS8xMDAwMDAwMDAwMDBcblxuXHRyZXR1cm4gcmF0aW9cblxufVxuXG4vKiBGb3JjZSByZXR1cm4gYWRqdXN0ZWQgTUlESSBkYXRhICovXG5cblR1bmUucHJvdG90eXBlLk1JREkgPSBmdW5jdGlvbihzdGVwSW4sb2N0YXZlSW4pIHtcblxuXHR2YXIgbmV3dmFsdWUgPSB0aGlzLmZyZXF1ZW5jeShzdGVwSW4sb2N0YXZlSW4pXG5cblx0dmFyIG4gPSA2OSArIDEyKk1hdGgubG9nKG5ld3ZhbHVlLzQ0MCkvTWF0aC5sb2coMilcblxuXHRuID0gTWF0aC5mbG9vcihuKjEwMDAwMDAwMDApLzEwMDAwMDAwMDBcblxuXHRyZXR1cm4gblxuXG59XG5cbi8qIExvYWQgYSBuZXcgc2NhbGUgKi9cblxuVHVuZS5wcm90b3R5cGUubG9hZFNjYWxlID0gZnVuY3Rpb24obmFtZSl7XG5cblx0LyogbG9hZCB0aGUgc2NhbGUgKi9cblx0dmFyIGZyZXFzID0gdGhpcy5UdW5pbmdMaXN0W25hbWVdLmZyZXF1ZW5jaWVzXG5cdHRoaXMuc2NhbGUgPSBbXVxuXHRmb3IgKHZhciBpPTA7aTxmcmVxcy5sZW5ndGgtMTtpKyspIHtcblx0XHR0aGlzLnNjYWxlLnB1c2goZnJlcXNbaV0vZnJlcXNbMF0pXG5cdH1cblxuXHQvKiB2aXN1YWxpemUgaW4gY29uc29sZSAqL1xuXHQvL2NvbnNvbGUubG9nKFwiIFwiKTtcblx0Ly9jb25zb2xlLmxvZyhcIkxPQURFRCBcIituYW1lKTtcblx0Ly9jb25zb2xlLmxvZyh0aGlzLlR1bmluZ0xpc3RbbmFtZV0uZGVzY3JpcHRpb24pO1xuXHQvL2NvbnNvbGUubG9nKHRoaXMuc2NhbGUpO1xuXHQvL3ZhciB2aXMgPSBbXTtcblx0Ly9mb3IgKHZhciBpPTA7aTwxMDA7aSsrKSB7XG5cdC8vICB2aXNbaV0gPSBcIiBcIjtcblx0Ly99XG5cdC8vZm9yICh2YXIgaT0wO2k8dGhpcy5zY2FsZS5sZW5ndGg7aSsrKSB7XG5cdC8vICB2YXIgc3BvdCA9IE1hdGgucm91bmQodGhpcy5zY2FsZVtpXSAqIDEwMCAtIDEwMCk7XG5cdC8vICBpZiAoaTwxMCkge1xuXHQvLyAgICB2aXMuc3BsaWNlKHNwb3QsMSxpKzEpO1xuXHQvLyAgfSBlbHNlIHtcblx0Ly8gICAgdmlzLnNwbGljZShzcG90LDUsaSsxKTtcblx0Ly8gIH1cblx0Ly99XG5cdC8vdmFyIHRleHR2aXMgPSBcIlwiO1xuXHQvL2ZvciAodmFyIGk9MDtpPHZpcy5sZW5ndGg7aSsrKSB7XG5cdC8vICB0ZXh0dmlzICs9IHZpc1tpXTtcblx0Ly99XG5cdC8vY29uc29sZS5sb2cobmFtZSlcblx0Ly9jb25zb2xlLmxvZyh0ZXh0dmlzKVxuXHQvLy8vIEVUIHNjYWxlIHZpc1xuXHQvL3ZhciB2aXMgPSBbXTtcblx0Ly9mb3IgKHZhciBpPTA7aTwxMDA7aSsrKSB7XG5cdC8vICB2aXNbaV0gPSBcIiBcIjtcblx0Ly99XG5cdC8vZm9yICh2YXIgaT0wO2k8dGhpcy5ldG1ham9yLmxlbmd0aDtpKyspIHtcblx0Ly8gIHZhciBzcG90ID0gTWF0aC5yb3VuZCh0aGlzLmV0bWFqb3JbaV0vdGhpcy5ldG1ham9yWzBdICogMTAwIC0gMTAwKTtcblx0Ly8gIGlmIChpPDEwKSB7XG5cdC8vICAgIHZpcy5zcGxpY2Uoc3BvdCwxLGkrMSk7XG5cdC8vICB9IGVsc2Uge1xuXHQvLyAgICB2aXMuc3BsaWNlKHNwb3QsNSxpKzEpO1xuXHQvLyAgfVxuXHRcdFxuXHQvL31cblx0Ly92YXIgdGV4dHZpcyA9IFwiXCI7XG5cdC8vZm9yICh2YXIgaT0wO2k8dmlzLmxlbmd0aDtpKyspIHtcblx0Ly8gIHRleHR2aXMgKz0gdmlzW2ldO1xuXHQvL31cblx0Ly9jb25zb2xlLmxvZyh0ZXh0dmlzKVxuXHQvL2NvbnNvbGUubG9nKFwiZXF1YWwtdGVtcGVyZWQgbWFqb3IgKHJlZmVyZW5jZSlcIilcbn1cblxuLyogU2VhcmNoIHRoZSBuYW1lcyBvZiB0dW5pbmdzXG5cdCBSZXR1cm5zIGFuIGFycmF5IG9mIG5hbWVzIG9mIHR1bmluZ3MgKi9cblxuVHVuZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24obGV0dGVycykge1xuXHR2YXIgcG9zc2libGUgPSBbXVxuXHRmb3IgKHZhciBrZXkgaW4gdGhpcy5UdW5pbmdMaXN0KSB7XG5cdFx0aWYgKGtleS50b0xvd2VyQ2FzZSgpLmluZGV4T2YobGV0dGVycy50b0xvd2VyQ2FzZSgpKSE9LTEpIHtcblx0XHRcdHBvc3NpYmxlLnB1c2goa2V5KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcG9zc2libGVcbn1cblxuLyogUmV0dXJuIGEgY29sbGVjdGlvbiBvZiBub3RlcyBhcyBhbiBhcnJheSAqL1xuXG5UdW5lLnByb3RvdHlwZS5jaG9yZCA9IGZ1bmN0aW9uKG1pZGlzKSB7XG5cdHZhciBvdXRwdXQgPSBbXVxuXHRmb3IgKHZhciBpPTA7aTxtaWRpcy5sZW5ndGg7aSsrKSB7XG5cdFx0b3V0cHV0LnB1c2godGhpcy5ub3RlKG1pZGlzW2ldKSlcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qIENoYW5nZSB0aGUgdG9uaWMgZnJlcXVlbmN5PyAqL1xuXG5UdW5lLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24obmV3bWlkaSwgbmV3ZnJlcSkge1xuXHR0aGlzLnJvb3RGcmVxID0gbmV3ZnJlcVxuXHQvLyBub3Qgd29ya2luZyBub3cgLi4uIG5lZWRzIG11Y2ggd29yay5cblx0Ly8gc2V0S2V5IGlzIG5vdCB0cmFuc3Bvc2luZyBub3csIGVpdGhlci5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUdW5lXG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuXG5jb25zdCBmaWx0ZXJOYW1lcyA9IFtcbiAgXCJub25lXCIsIFwiRmlsdGVyMjRNb29nXCIsIFwiRmlsdGVyMjRUQjMwM1wiLCBcIkZpbHRlcjEyU1ZGXCIsIFwiRmlsdGVyMTJCaXF1YWRcIiwgXCJGaWx0ZXIyNENsYXNzaWNcIlxuXVxuXG5jb25zdCBGaWx0ZXJzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB7fVxuXG4gICAgZm9yKCBsZXQgZmlsdGVyTmFtZSBpbiBHaWJiZXJpc2guZmlsdGVycyApIHtcbiAgICAgIGNvbnN0IGdpYmJlcmlzaENvbnN0cnVjdG9yID0gR2liYmVyaXNoLmZpbHRlcnNbIGZpbHRlck5hbWUgXVxuXG4gICAgICBjb25zdCBtZXRob2RzID0gRmlsdGVycy5kZXNjcmlwdGlvbnNbIGZpbHRlck5hbWUgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEZpbHRlcnMuZGVzY3JpcHRpb25zWyBmaWx0ZXJOYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzIHx8IHt9LCBcbiAgICAgICAgbWV0aG9kczptZXRob2RzLFxuICAgICAgICBuYW1lOmZpbHRlck5hbWUsXG4gICAgICAgIGNhdGVnb3J5OidlZmZlY3RzJ1xuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24uX19kZWZhdWx0c19fID0geyBpc1N0ZXJlbyA6IHRydWUgfVxuICAgICAgZGVzY3JpcHRpb24ucHJvcGVydGllcy5pc1N0ZXJlbyA9IHRydWVcbiAgICAgIGRlc2NyaXB0aW9uLnByb3BlcnRpZXMudHlwZSA9ICdmeCdcblxuICAgICAgZmlsdGVyc1sgZmlsdGVyTmFtZSBdID0gVWdlbiggZ2liYmVyaXNoQ29uc3RydWN0b3IsIGRlc2NyaXB0aW9uLCBBdWRpbywgZmFsc2UgKVxuICAgIH1cblxuICAgIGZpbHRlcnMuTFBGID0gZmlsdGVycy5GaWx0ZXIyNE1vb2dcblxuICAgIGZpbHRlcnMuRmlsdGVyID0gZnVuY3Rpb24oIHByb3BzICkge1xuICAgICAgaWYoIHByb3BzID09PSB1bmRlZmluZWQgKSBwcm9wcyA9IHsgbW9kZWw6IDEgfVxuICAgICAgaWYoIHByb3BzLm1vZGVsID09PSB1bmRlZmluZWQgKSBwcm9wcy5tb2RlbCA9IDFcblxuICAgICAgY29uc3QgbmFtZSA9IGZpbHRlck5hbWVzWyBwcm9wcy5tb2RlbCBdXG5cbiAgICAgIGRlbGV0ZSBwcm9wcy5tb2RlbFxuXG4gICAgICByZXR1cm4gZmlsdGVyc1sgbmFtZSBdKCBwcm9wcyApIFxuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0geyBcbiAgICAgIHByb3BlcnRpZXM6IE9iamVjdC5hc3NpZ24oIHt9LCBHaWJiZXJpc2guZmlsdGVyc1sgJ0ZpbHRlcjEyQmlxdWFkJyBdLmRlZmF1bHRzLCB7IG1vZGU6MSB9ICksXG4gICAgICBtZXRob2RzOm51bGwsXG4gICAgICBuYW1lOidIUEYnLFxuICAgICAgY2F0ZWdvcnk6J2VmZmVjdHMnLFxuICAgICAgX19kZWZhdWx0c19fOiB7IG1vZGU6MSB9XG4gICAgfVxuICAgXG4gICAgZmlsdGVycy5IUEYgPSBVZ2VuKCBHaWJiZXJpc2guZmlsdGVyc1sgJ0ZpbHRlcjEyQmlxdWFkJyBdLCBkZXNjcmlwdGlvbiwgQXVkaW8sIGZhbHNlIClcblxuICAgIHJldHVybiBmaWx0ZXJzXG4gIH0sXG5cbiAgZGVzY3JpcHRpb25zOiB7XG4gICAgLy9DaG9ydXM6eyBtZXRob2RzOltdIH0sXG4gIH0sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcnNcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEF1ZGlvICkge1xuICBjb25zdCB0b2tlbiA9ICc2YTAwZjgwYmEwMmIyNzU1YTA0NGNjNGVmMDA0ZmViZmM0Y2NkNDc2J1xuXG4gIGNvbnN0IEZyZWVzb3VuZCA9IGZ1bmN0aW9uKCBxdWVyeSwgb3B0aW9ucyApIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHsgY291bnQ6MSwgbWF4Vm9pY2VzOjEsIHBhblZvaWNlczp0cnVlIH0sIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgPyBxdWVyeSA6IG9wdGlvbnMgKVxuICAgIGNvbnN0IHNhbXBsZXIgPSBBdWRpby5pbnN0cnVtZW50cy5NdWx0aXNhbXBsZXIoIHByb3BzIClcbiAgICBzZXRUaW1lb3V0KCAoKT0+cXVlcmllc1sgdHlwZW9mIHF1ZXJ5IF0oIHF1ZXJ5LCBzYW1wbGVyLCBwcm9wcy5jb3VudCApLCAwIClcbiBcbiAgICByZXR1cm4gc2FtcGxlclxuICB9XG5cbiAgRnJlZXNvdW5kLmxvYWRlZCA9IHt9XG4gIEZyZWVzb3VuZC5xdWVyaWVzID0ge31cblxuICBGcmVlc291bmQuZGVmYXVsdHMgPSB7XG4gICAgc29ydDogJ2Rvd25sb2FkcycsXG4gICAgc2luZ2xlOnRydWUsXG4gICAgZmlsZW5hbWU6ZmFsc2UsXG4gICAgbWluOiAwLFxuICAgIG1heDogLjUsXG4gICAgcmV2ZXJzZTpmYWxzZSxcbiAgICBjb3VudDoxNVxuICB9XG5cbiAgLy8gYWRkIEZyZWVzb3VuZFs1XSBub3RhdGlvbi4uLlxuICBmb3IoIGxldCBpID0gMDsgaSA8IDIwOyBpKysgKSB7XG4gICAgRnJlZXNvdW5kWyBpIF0gPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgaWYoIGFyZ3MubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgIGFyZ3NbMV0ubWF4Vm9pY2VzID0gaSB8fCAxXG4gICAgICAgICAgICB9IFxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYXJnc1sxXSA9IHsgbWF4Vm9pY2VzOmkgfHwgMSB9XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICkge1xuICAgICAgICAgIGFyZ3NbMF0ubWF4Vm9pY2VzID0gaSB8fCAxXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBhcmdzWzBdID0geyBtYXhWb2ljZXM6aSB8fCAxIH1cbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiBGcmVlc291bmQoIC4uLmFyZ3MgKSBcbiAgICB9XG4gIH1cblxuICBjb25zdCBxdWVyaWVzID0ge1xuICAgIG51bWJlciggaWQsIHNhbXBsZXIsIG51bT0wICkge1xuICAgICAgaWYgKHR5cGVvZiBGcmVlc291bmQubG9hZGVkWyBpZCBdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmZXRjaCggYGh0dHBzOi8vZnJlZXNvdW5kLm9yZy9hcGl2Mi9zb3VuZHMvJHtpZH0vPyZmb3JtYXQ9anNvbiZ0b2tlbj0ke3Rva2VufWAgKVxuICAgICAgICAgIC50aGVuKCByZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkgKVxuICAgICAgICAgIC50aGVuKCBqc29uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBqc29uLnByZXZpZXdzWyAncHJldmlldy1ocS1tcDMnIF1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2FtcGxlci5sb2FkU2FtcGxlKCBwYXRoIClcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdsb2FkaW5nOicsIHBhdGggKVxuICAgICAgICAgIH0pIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCBBdWRpby5HaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgIHNhbXBsZXIuc2FtcGxlcnNbIG51bSBdLmxvYWRCdWZmZXIoIEZyZWVzb3VuZC5sb2FkZWRbIGlkIF0gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHNlYXJjaCBmb3IgdGV4dCBxdWVyeSwgYW5kIHRoZW4gdXNlIHJldHVybmVkIGlkIHRvIFxuICAgIC8vIGZldGNoIGJ5IG51bWJlciBcbiAgICBzdHJpbmcoIHF1ZXJ5LCBzYW1wbGVyLCBjb3VudCwgb3JpZ2luYWxRdWVyeSApIHtcbiAgICAgIHNhbXBsZXIubGVuZ3RoID0gY291bnRcbiAgICAgIGxldCBxdWVyeVN0cmluZyA9J2h0dHBzOi8vZnJlZXNvdW5kLm9yZy9hcGl2Mi9zZWFyY2gvdGV4dC8/J1xuXG4gICAgICBjb25zb2xlLmdyb3VwKCdRdWVyeWluZyBGcmVlc291bmQgZm9yOiAnICsgb3JpZ2luYWxRdWVyeSB8fCBxdWVyeSApXG4gICAgICBpZiggcXVlcnkuaW5kZXhPZiggJ3F1ZXJ5JyApID4gLTEgKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nICs9IHF1ZXJ5XG4gICAgICAgIHF1ZXJ5U3RyaW5nICs9IGAmdG9rZW49JHt0b2tlbn0mZmllbGRzPW5hbWUsaWQscHJldmlld3MsdXNlcm5hbWUsbGljZW5zZSZwYWdlX3NpemU9JHtjb3VudH0gYFxuICAgICAgfWVsc2V7XG4gICAgICAgIHF1ZXJ5U3RyaW5nICs9IGBxdWVyeT0ke3F1ZXJ5fSZ0b2tlbj0ke3Rva2VufSZmaWVsZHM9bmFtZSxpZCxwcmV2aWV3cyx1c2VybmFtZSxsaWNlbnNlJmZpbHRlcj1vcmlnaW5hbF9maWxlbmFtZToke3F1ZXJ5LnNwbGl0KCcgJylbMF19IGFjX3NpbmdsZV9ldmVudDp0cnVlJnNvcnQ9ZG93bmxvYWRzX2Rlc2MmcGFnZV9zaXplPSR7Y291bnR9YFxuXG4gICAgICB9XG5cbiAgICAgIGZldGNoKCBxdWVyeVN0cmluZyApXG4gICAgICAgIC50aGVuKCBkYXRhID0+IGRhdGEuanNvbigpIClcbiAgICAgICAgLnRoZW4oIHNvdW5kcyA9PiB7XG4gICAgICAgICAgaWYoIHNvdW5kcy5yZXN1bHRzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBpZiggc291bmRzLnJlc3VsdHMubGVuZ3RoID4gY291bnQgKSBzb3VuZHMucmVzdWx0cyA9IHNvdW5kcy5yZXN1bHRzLnNsaWNlKDAsY291bnQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJWMke3NvdW5kcy5yZXN1bHRzLmxlbmd0aH0gc291bmRzIGZvdW5kLiBTdGFydGluZyBkb3dubG9hZHM6YCwgYGJhY2tncm91bmQ6YmxhY2s7Y29sb3I6d2hpdGVgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCVjTm8gc291bmRzIHdlcmUgZm91bmQgZm9yIHRoaXMgcXVlcnkhYCwgYGJhY2tncm91bmQ6cmVkO2NvbG9yOndoaXRlYClcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FtcGxlci5sZW5ndGggPSBjb3VudCA8IHNvdW5kcy5yZXN1bHRzLmxlbmd0aCA/IGNvdW50IDogc291bmRzLnJlc3VsdHMubGVuZ3RoXG4gICAgICAgICAgY29uc29sZS50YWJsZSggc291bmRzLnJlc3VsdHMubWFwKCByPT4oe2ZpbGU6ci5uYW1lLGF1dGhvcjpyLnVzZXJuYW1lLGxpY2Vuc2U6J0NDLycrci5saWNlbnNlLnNwbGl0KCcvJykuc2xpY2UoNCkuam9pbignLycpfSkgKSApXG4gICAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBzYW1wbGVyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc291bmRzLnJlc3VsdHNbaV1cbiAgICAgICAgICAgIGlmKCByZXN1bHQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXN1bHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSByZXN1bHQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHJlc3VsdC5wcmV2aWV3c1sgJ3ByZXZpZXctaHEtbXAzJyBdIFxuXG4gICAgICAgICAgICAgIGlmKCBGcmVlc291bmQubG9hZGVkWyB1cmwgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIGAlYyR7ZmlsZW5hbWV9YCwgYGNvbG9yOndoaXRlO2JhY2tncm91bmQ6IzMzMzMzMztgIClcblxuICAgICAgICAgICAgICAgIHNhbXBsZXIubG9hZFNhbXBsZSggdXJsLCAoX19zYW1wbGVyLGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgRnJlZXNvdW5kLmxvYWRlZFsgdXJsIF0gPSBidWZmZXIuZGF0YS5idWZmZXJcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vIFhYWCBtZW1vaW5nIHRoZSBmaWxlcyBjYXVzZXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdyZXVzaW5nIGZyZWVzb3VuZCBmaWxlOicsIGZpbGVuYW1lIClcbiAgICAgICAgICAgICAgICAgIHNhbXBsZXIubG9hZFNhbXBsZSggdXJsLCBudWxsLCBGcmVlc291bmQubG9hZGVkWyB1cmwgXSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBvYmplY3QoIHF1ZXJ5T2JqLCBzYW1wbGVyICkge1xuICAgICAgY29uc3QgcSA9IE9iamVjdC5hc3NpZ24oIHt9LCBGcmVlc291bmQuZGVmYXVsdHMsIHF1ZXJ5T2JqIClcbiBcbiAgICAgIGxldCBxdWVyeSA9IGBxdWVyeT0ke3EucXVlcnl9JmZvcm1hdD1qc29uYFxuICBcbiAgICAgIHF1ZXJ5ICs9IGAmZmlsdGVyPWR1cmF0aW9uOlske3EubWlufSBUTyAke3EubWF4fV1gXG4gICAgICBpZiggcS5zaW5nbGUgKSBxdWVyeSArPSBgIGFjX3NpbmdsZV9ldmVudDp0cnVlYFxuICAgICAgaWYoIHEuZmlsZW5hbWUgKSBxdWVyeSArPSBgIG9yaWdpbmFsX2ZpbGVuYW1lOiR7cS5xdWVyeX1gXG5cbiAgICAgIGxldCBzb3J0ID0gcS5zb3J0XG5cbiAgICAgIC8vIHVzZXIgZXJyb3IgY2hlY2tcbiAgICAgIGlmKCBzb3J0ID09PSAncmF0aW5ncycgKSBzb3J0ID0gJ3JhdGluZydcblxuICAgICAgc29ydCArPSBxLnJldmVyc2UgPyAnX2FzYycgOiAnX2Rlc2MnXG5cbiAgICAgIHF1ZXJ5ICs9IGAmc29ydD0ke3NvcnR9YFxuXG4gICAgICBxdWVyaWVzLnN0cmluZyggcXVlcnksIHNhbXBsZXIsIHEuY291bnQsIHEucXVlcnkgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBGcmVlc291bmRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEF1ZGlvICkge1xuICBcbmNvbnN0IGJpbm9wcyA9IFsgXG4gICdtaW4nLCdtYXgnLCdhZGQnLCdzdWInLCdtdWwnLCdkaXYnLCdyZGl2JywnbW9kJyxcbiAgJ2FuZCcsJ29yJywnZ3QnLCdlcScsJ2VxcCcsJ2d0ZScsJ2d0ZXAnLCdndHAnLCdsdCcsJ2x0ZScsJ2x0ZXAnLCdsdHAnLCduZXEnLFxuICAnc3RlcCcgXG5dXG5cbmNvbnN0IG1vbm9wcyA9IFtcbiAgJ2FicycsJ2Fjb3MnLCdhY29zaCcsJ2FzaW4nLCdhc2luaCcsJ2F0YW4nLCdhdGFuMicsJ2F0YW5oJywnY29zJywnY29zaCcsXG4gICdzaW4nLCdzaW5oJywndGFuJywndGFuaCcsICdmbG9vcicsXG4gICdjZWlsJywgJ3JvdW5kJywgJ3NpZ24nLCAndHJ1bmMnLCAnZnJhY3QnLCAncGFyYW0nLCAnaW4nLFxuXVxuXG5jb25zdCBub29wcyA9IFtcbiAgJ25vaXNlJ1xuXVxuXG5jb25zdCBHZW4gID0ge1xuICBsYXN0Q29ubmVjdGVkOltdLFxuICBuYW1lczpbXSxcbiAgY29ubmVjdGVkOiBbXSxcblxuICBpc0dlbjp0cnVlLFxuICBkZWJ1ZzpmYWxzZSxcblxuICB3YXZldGFibGUoIGZyZXF1ZW5jeSwgcHJvcHMgKSB7XG4gICAgY29uc3QgZyA9IEF1ZGlvLkdpYmJlcmlzaC5nZW5pc2ggXG4gICAgbGV0IGRhdGFQcm9wcyA9IHsgaW1tdXRhYmxlOnRydWUgfVxuXG4gICAgLy8gdXNlIGdsb2JhbCByZWZlcmVuY2VzIGlmIGFwcGxpY2FibGVcbiAgICBpZiggcHJvcHMubmFtZSAhPT0gdW5kZWZpbmVkICkgZGF0YVByb3BzLmdsb2JhbCA9IHByb3BzLm5hbWVcblxuICAgIGNvbnN0IGJ1ZmZlciA9IEdlbi51Z2Vucy5kYXRhKCBwcm9wcy5idWZmZXIsIDEsIGRhdGFQcm9wcyApXG5cbiAgICByZXR1cm4gR2VuLnVnZW5zLnBlZWsoIGJ1ZmZlciwgR2VuLnVnZW5zLnBoYXNvciggZnJlcXVlbmN5LCAwLCB7IG1pbjowIH0gKSApXG4gIH0sXG5cbiAgaW5pdCgpIHtcbiAgICBHZW4udWdlbnMud2F2ZXRhYmxlID0gR2VuLl9fd2F2ZXRhYmxlXG4gICAgR2VuLmNyZWF0ZUJpbm9wRnVuY3Rpb25zKClcbiAgICBHZW4uY3JlYXRlTW9ub3BGdW5jdGlvbnMoKVxuXG4gICAgR2VuLm5hbWVzLnB1c2goIC4uLmJpbm9wcyApXG4gICAgR2VuLm5hbWVzLnB1c2goIC4uLm1vbm9wcyApXG4gICAgR2VuLm5hbWVzLnB1c2goIC4uLk9iamVjdC5rZXlzKCBHZW4uY29uc3RhbnRzICkgKVxuICAgIEdlbi5uYW1lcy5wdXNoKCAuLi5PYmplY3Qua2V5cyggR2VuLmZ1bmN0aW9ucyApIClcbiAgICAvL0dlbi5uYW1lcy5wdXNoKCAuLi5PYmplY3Qua2V5cyggR2VuLmNvbXBvc2l0ZXMgKSApXG4gICAgR2VuLm5hbWVzLnB1c2goICdnZW4nIClcbiAgICBHZW4ubmFtZXMucHVzaCggJ2xmbycgKVxuICAgIEdlbi5uYW1lcy5wdXNoKCAnc2luZScgKVxuICAgIEdlbi5uYW1lcy5wdXNoKCAnc3F1YXJlJyApXG4gICAgR2VuLm5hbWVzLnB1c2goICd0cmknIClcbiAgICBHZW4ubmFtZXMucHVzaCggJ3NhdycgKVxuXG4gICAgLy9HaWJiZXIuc3Vic2NyaWJlKCAnY2xlYXInLCAoKT0+IEdlbi5sYXN0Q29ubmVjdGVkLmxlbmd0aCA9IDAgKVxuICB9LFxuXG4gIC8vIGlmIHByb3BlcnR5IGlzICE9PSB1Z2VuIChpdCdzIGEgbnVtYmVyKSBhIFBhcmFtIG11c3QgYmUgbWFkZSB1c2luZyBhIGRlZmF1bHRcbiAgY3JlYXRlKCBuYW1lICkge1xuICAgIC8vIHJhdGUgbmVlZHMgY3VzdG9tIGZ1bmN0aW9uIHRvIHNraXAgc2VxdWVuY2luZyBpbnB1dCBhbmQgb25seSBzZXF1ZW5jZSByYXRlIGFkanVzdG1lbnRcblxuICAgIGNvbnN0IHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKVxuXG4gICAgaWYoIG5hbWUgPT09ICdyYXRlJyApIHJldHVybiBHZW4uY3JlYXRlUmF0ZSggbmFtZSwgLi4ucGFyYW1zIClcblxuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoIHRoaXMgKVxuICAgIGxldCBjb3VudCA9IDBcbiAgICBcbiAgICBvYmoubmFtZSA9IG5hbWVcbiAgICBvYmouYWN0aXZlID0gZmFsc2VcbiAgICBcbiAgICBmb3IoIGxldCBrZXkgb2YgR2VuLmZ1bmN0aW9uc1sgbmFtZSBdLnByb3BlcnRpZXMgKSB7IFxuICAgICAgbGV0IHZhbHVlID0gcGFyYW1zWyBjb3VudCsrIF0gfHwgMFxuICAgICAgb2JqWyBrZXkgXSA9IHYgPT4ge1xuICAgICAgICBpZiggdiA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB2YWx1ZSA9IHZcbiAgICAgICAgICBpZiggb2JqLmFjdGl2ZSApIHtcbiAgICAgICAgICAgIGlmKCBvYmouX19jbGllbnQgPT09ICdsaXZlJyApIHtcbiAgICAgICAgICAgICAgR2liYmVyLkNvbW11bmljYXRpb24uc2VuZCggYGdlbnAgJHtvYmoucGFyYW1JRH0gJHtvYmpbIGtleSBdLnVpZH0gJHt2fWAgKSBcbiAgICAgICAgICAgIH1lbHNlIGlmKCBvYmouX19jbGllbnQgPT09ICdtYXgnICkge1xuICAgICAgICAgICAgICBHaWJiZXIuQ29tbXVuaWNhdGlvbi5zZW5kKCBgc2lnICR7b2JqLnBhcmFtSUR9IHBhcmFtICR7b2JqWyBrZXkgXS51aWR9ICR7dn1gLCAnbWF4JyApIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqWyBrZXkgXS51aWQgPSBHZW4uZ2V0VUlEKClcbiBcbiAgICAgIC8vIFhYWCBHaWJiZXIuYWRkU2VxdWVuY2luZ1RvTWV0aG9kKCBvYmosIGtleSApXG4gICAgfVxuXG4gICAgLy8gYWNjb21vZGF0ZSBub24tYXVkaW8tcmF0ZSBvcHRpb25zLiBkdXJpbmcgY29kZWdlbiB0aGUgY29tcGlsZXJcbiAgICAvLyB3aWxsIGNoZWNrIGZvciB0aGUgb3B0aW9ucyBwcm9wZXJ0eTsgaWYgaXQgZXhpc3RzIGl0IHdpbGwgd3JpdGVcbiAgICAvLyB0aGUgb3B0aW9ucyBpbnRvIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICBpZiggcGFyYW1zLmxlbmd0aCA+IEdlbi5mdW5jdGlvbnNbIG5hbWUgXS5wcm9wZXJ0aWVzLmxlbmd0aCApIHtcbiAgICAgIG9iai5vcHRpb25zID0gcGFyYW1zWyBHZW4uZnVuY3Rpb25zWyBuYW1lIF0ucHJvcGVydGllcy5sZW5ndGggXVxuICAgIH1cblxuICAgIHJldHVybiBvYmpcbiAgfSxcblxuICBjcmVhdGVSYXRlKCBuYW1lICkge1xuICAgIGxldCBvYmogPSBPYmplY3QuY3JlYXRlKCB0aGlzICksXG4gICAgICAgIGNvdW50ID0gMCxcbiAgICAgICAgcGFyYW0gPSBhcmd1bWVudHNbMV0gXG4gICAgXG4gICAgb2JqLm5hbWUgPSAncmF0ZScgXG4gICAgb2JqLmFjdGl2ZSA9IGZhbHNlXG4gICAgXG4gICAgbGV0IHZhbHVlID0gcGFyYW1cbiAgICAvL2NvbnNvbGUubG9nKCAndmFsdWU6JywgdmFsdWUsICdhcmdzOicsIGFyZ3VtZW50cyApXG4gICAgb2JqWyAwIF0gPSB2ID0+IHtcbiAgICAgIGlmKCB2ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfWVsc2V7XG4gICAgICAgIHZhbHVlID0gdlxuICAgICAgICBpZiggb2JqLmFjdGl2ZSApIHtcbiAgICAgICAgICBHaWJiZXIuQ29tbXVuaWNhdGlvbi5zZW5kKCBgZ2VucCAke29iai5wYXJhbUlEfSAke29ialsgMCBdLnVpZH0gJHt2fWAgKSBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIEdlbi5nZXRVSUQoKSAvLyBsZWF2ZSAwIGJlaGluZC4uLlxuICAgIG9ialsgMCBdLnVpZCA9IEdlbi5nZXRVSUQoKVxuXG4gICAgR2liYmVyLmFkZFNlcXVlbmNpbmdUb01ldGhvZCggb2JqLCAnMCcgKVxuXG4gICAgcmV0dXJuIG9ialxuICB9LFxuIFxuICBjcmVhdGVCaW5vcEZ1bmN0aW9ucygpIHtcbiAgICBmb3IoIGxldCBrZXkgb2YgYmlub3BzICkge1xuICAgICAgR2VuLmZ1bmN0aW9uc1sga2V5IF0gPSB7XG4gICAgICAgIHByb3BlcnRpZXM6WycwJywnMSddLCBzdHI6a2V5XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZU1vbm9wRnVuY3Rpb25zKCkge1xuICAgIGZvciggbGV0IGtleSBvZiBtb25vcHMgKSB7XG4gICAgICBHZW4uZnVuY3Rpb25zWyBrZXkgXSA9IHtcbiAgICAgICAgcHJvcGVydGllczpbJzAnXSwgc3RyOmtleVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhc3NpZ25UcmFja0FuZFBhcmFtSUQ6IGZ1bmN0aW9uKCB0cmFjaywgaWQgKSB7XG4gICAgdGhpcy5wYXJhbUlEID0gaWRcbiAgICB0aGlzLnRyYWNrID0gdHJhY2tcblxuICAgIGxldCBjb3VudCA9IDAsIHBhcmFtXG4gICAgd2hpbGUoIHBhcmFtID0gdGhpc1sgY291bnQrKyBdICkge1xuICAgICAgaWYoIHR5cGVvZiBwYXJhbSgpID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgcGFyYW0oKS5hc3NpZ25UcmFja0FuZFBhcmFtSUQoIHRyYWNrLCBpZCApXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIGZvciggbGV0IHVnZW4gb2YgR2VuLmNvbm5lY3RlZCApIHtcbiAgICAgIEdpYmJlci5Db21tdW5pY2F0aW9uLnNlbmQoIGB1bmdlbiAke3VnZW4ucGFyYW1JRH1gIClcbiAgICB9XG5cbiAgICBHZW4uY29ubmVjdGVkLmxlbmd0aCA9IDBcbiAgfSxcblxuICBjb25zdGFudHM6IHtcbiAgICBkZWd0b3JhZDogTWF0aC5QSSAvIDE4MCxcbiAgICBFIDogICAgICAgTWF0aC5FLFxuICAgIGhhbGZwaTogICBNYXRoLlBJIC8gMixcbiAgICBpbnZwaSA6ICAgTWF0aC5QSSAqIC0gMSxcbiAgICBsbjEwICA6ICAgTWF0aC5MTjEwLFxuICAgIGxuMiAgIDogICBNYXRoLkxOMixcbiAgICBsb2cxMGU6ICAgTWF0aC5MT0cxMEUsXG4gICAgbG9nMmUgOiAgIE1hdGguTE9HMkUsXG4gICAgcGkgICAgOiAgIE1hdGguUEksICBcbiAgICBzcXJ0MiA6ICAgTWF0aC5TUVJUMixcbiAgICBzcXJ0MV8yOiAgTWF0aC5TUVJUMV8yLFxuICAgIHR3b3BpIDogICBNYXRoLlBJICogMixcbiAgICBzYW1wbGVyYXRlOiAnc2FtcGxlcmF0ZSdcbiAgfSxcblxuICBmdW5jdGlvbnM6IHtcbiAgICBwaGFzb3I6IHsgcHJvcGVydGllczpbICcwJywnMScgXSwgIHN0cjoncGhhc29yJyB9LFxuICAgIGN5Y2xlOiAgeyBwcm9wZXJ0aWVzOlsgJzAnIF0sICBzdHI6J2N5Y2xlJyB9LFxuICAgIHBoYXNvck46eyBwcm9wZXJ0aWVzOlsgJzAnLCcxJyBdLCAgc3RyOidwaGFzb3JOJyB9LFxuICAgIGN5Y2xlTjogeyBwcm9wZXJ0aWVzOlsgJzAnIF0sICBzdHI6J2N5Y2xlTicgfSxcbiAgICB0cmFpbjogIHsgcHJvcGVydGllczpbICcwJywnMScgXSwgIHN0cjondHJhaW4nIH0sXG4gICAgcmF0ZTogICB7IHByb3BlcnRpZXM6WyAnMCcgXSwgc3RyOidyYXRlJyB9LFxuICAgIG5vaXNlOiAgeyBwcm9wZXJ0aWVzOltdLCBzdHI6J25vaXNlJyB9LFxuICAgIGFjY3VtOiAgeyBwcm9wZXJ0aWVzOlsgJzAnLCcxJyBdLCBzdHI6J2FjY3VtJyB9LFxuICAgIGNvdW50ZXI6eyBwcm9wZXJ0aWVzOlsgJzAnLCcxJyBdLCBzdHI6J2NvdW50ZXInIH0sXG4gICAgc2NhbGU6ICB7IHByb3BlcnRpZXM6IFsnMCcsICcxJywgJzInLCAnMyddLCBzdHI6J3NjYWxlJyB9LFxuICAgIHNhaDogICAgeyBwcm9wZXJ0aWVzOiBbJzAnLCAnMScsICcyJ10sIHN0cjonc2FoJyB9LFxuICAgIGNsYW1wOiAgeyBwcm9wZXJ0aWVzOiBbJzAnLCAnMScsICcyJ10sIHN0cjonY2xhbXAnIH0sXG4gICAgdGVybmFyeTp7IHByb3BlcnRpZXM6IFsnMCcsICcxJywgJzInXSwgc3RyOidzd2l0Y2gnIH0sXG4gICAgc2VsZWN0b3I6eyBwcm9wZXJ0aWVzOiBbJzAnLCAnMScsICcyJ10sIHN0cjonc2VsZWN0b3InIH0sXG4gICAgcGVlazogICB7IHByb3BlcnRpZXM6WycwJywnMSddLCBzdHI6J3BlZWsnIH0sXG4gICAgZGF0YTogICB7IHByb3BlcnRpZXM6W10sIHN0cjonZGF0YScgfVxuICB9LFxuXG4gIF9jb3VudDogMCxcblxuICBnZXRVSUQoKSB7XG4gICAgcmV0dXJuICdwJyArIEdlbi5fY291bnQrK1xuICB9LFxuXG4gIHRpbWU6ICd0aW1lJyxcblxuICBvdXQoKSB7XG4gICAgbGV0IHBhcmFtQXJyYXkgPSBbXSxcbiAgICAgICAgYm9keSwgb3V0XG4gICAgXG4gICAgYm9keSA9IHRoaXMuZ2VuKCBwYXJhbUFycmF5IClcblxuICAgIG91dCA9IHBhcmFtQXJyYXkuam9pbiggJzsnIClcblxuICAgIGlmKCBwYXJhbUFycmF5Lmxlbmd0aCApIHtcbiAgICAgIG91dCArPSAnOydcbiAgICB9XG4gICAgXG4gICAgb3V0ICs9ICdvdXQxPSdcbiAgICBvdXQgKz0gYm9keSArICc7J1xuICAgIFxuICAgIGlmKCBHZW4uZGVidWcgKSBjb25zb2xlLmxvZyggb3V0IClcblxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuICBnZW5NYXgoIHBhcmFtQXJyYXkgKSB7XG4gICAgbGV0IGRlZiA9IEdlbi5mdW5jdGlvbnNbIHRoaXMubmFtZSBdLFxuICAgICAgICBzdHIgPSBkZWYuc3RyICsgJygnLFxuICAgICAgICBjb3VudCA9IDBcbiAgICBcbiAgICAvLyB0ZWxsIEdpYmJlciB0aGF0IHRoaXMgZ2VuIG9iamVjdCBpcyBwYXJ0IG9mIGFuIGFjdGl2ZSBnZW4gZ3JhcGhcbiAgICAvLyBzbyB0aGF0IGNoYW5nZXMgdG8gaXQgYXJlIGZvcndhcmRlZCB0byBtNGxcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWVcblxuICAgIGlmKCB0aGlzLm5hbWUgPT09ICdyYXRlJyApIHtcbiAgICAgIHN0ciArPSAnaW4xLCAnXG4gICAgICBsZXQgcE5hbWUgPSB0aGlzWyAwIF0udWlkXG4gICAgICBzdHIgKz0gcE5hbWVcbiAgICAgIHBhcmFtQXJyYXkucHVzaCggYFBhcmFtICR7cE5hbWV9KCR7dGhpc1swXSgpfSlgIClcbiAgICB9ZWxzZXtcbiAgICAgIGZvciggbGV0IHByb3BlcnR5IG9mIGRlZi5wcm9wZXJ0aWVzICkge1xuICAgICAgICBsZXQgcCA9IHRoaXNbIHByb3BlcnR5IF0oKSxcbiAgICAgICAgICAgIHVpZCA9IHRoaXNbIHByb3BlcnR5IF0udWlkXG4gICAgICAgIFxuICAgICAgICAvL2NvbnNvbGUubG9nKCB0aGlzLm5hbWUsIHByb3BlcnR5LCBkZWYucHJvcGVydGllcywgdWlkIClcbiAgICAgICAgaWYoIEdlbi5pc1Byb3RvdHlwZU9mKCBwICkgKSB7XG4gICAgICAgICAgc3RyICs9IHAuZ2VuKCBwYXJhbUFycmF5IClcbiAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBwID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICBsZXQgcE5hbWUgPSB1aWRcbiAgICAgICAgICBzdHIgKz0gcE5hbWVcbiAgICAgICAgICBwYXJhbUFycmF5LnB1c2goIGBQYXJhbSAke3BOYW1lfSgke3B9KWAgKVxuICAgICAgICB9ZWxzZSBpZiggcCA9PT0gR2VuLnRpbWUgKSB7XG4gICAgICAgICAgc3RyICs9IHBcbiAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBwID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICBzdHIgKz0gcFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ0NPREVHRU4gRVJST1I6JywgcCApXG4gICAgICAgIH1cblxuICAgICAgICBpZiggY291bnQrKyA8IGRlZi5wcm9wZXJ0aWVzLmxlbmd0aCAtIDEgKSBzdHIgKz0gJywnXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHN0ciArPSAnKSdcblxuICAgIHJldHVybiBzdHJcbiAgfSxcblxuICBnZW4oIHBhcmFtQXJyYXkgKSB7XG4gICAgbGV0IGRlZiA9IEdlbi5mdW5jdGlvbnNbIHRoaXMubmFtZSBdLFxuICAgICAgICBzdHIgPSBgZy4ke2RlZi5zdHJ9KGAsXG4gICAgICAgIGNvdW50ID0gMFxuICAgIFxuICAgIC8vIHRlbGwgR2liYmVyIHRoYXQgdGhpcyBnZW4gb2JqZWN0IGlzIHBhcnQgb2YgYW4gYWN0aXZlIGdlbiBncmFwaFxuICAgIC8vIHNvIHRoYXQgY2hhbmdlcyB0byBpdCBhcmUgZm9yd2FyZGVkIHRvIG00bFxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZVxuXG4gICAgZm9yKCBsZXQgcHJvcGVydHkgb2YgZGVmLnByb3BlcnRpZXMgKSB7XG4gICAgICBsZXQgcCA9IHRoaXNbIHByb3BlcnR5IF0oKSxcbiAgICAgICAgICB1aWQgPSB0aGlzWyBwcm9wZXJ0eSBdLnVpZFxuICAgICAgXG4gICAgICAvL2NvbnNvbGUubG9nKCB0aGlzLm5hbWUsIHByb3BlcnR5LCBkZWYucHJvcGVydGllcywgdWlkIClcbiAgICAgIGlmKCBHZW4uaXNQcm90b3R5cGVPZiggcCApICkge1xuICAgICAgICBzdHIgKz0gcC5nZW4oIHBhcmFtQXJyYXkgKVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiBwID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgbGV0IHBOYW1lID0gJ3AnK3BhcmFtQXJyYXkubGVuZ3RoXG4gICAgICAgIC8vc3RyICs9IHBOYW1lXG4gICAgICAgIHBhcmFtQXJyYXkucHVzaCggW2Ake3BOYW1lfWAsIHAgXSApXG4gICAgICAgIHN0ciArPSBgZy5pbignJHtwTmFtZX0nKWBcbiAgICAgIH1lbHNlIGlmKCBwID09PSBHZW4udGltZSApIHtcbiAgICAgICAgc3RyICs9IHBcbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgcCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHN0ciArPSBwXG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc29sZS5sb2coICdDT0RFR0VOIEVSUk9SOicsIHAgKVxuICAgICAgfVxuXG4gICAgICBpZiggY291bnQrKyA8IGRlZi5wcm9wZXJ0aWVzLmxlbmd0aCAtIDEgKSBzdHIgKz0gJywnXG4gICAgfVxuXG4gICAgaWYoIHRoaXMub3B0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgc3RyICs9ICcsJyArIEpTT04uc3RyaW5naWZ5KCB0aGlzLm9wdGlvbnMgKVxuICAgIH1cbiAgICBcbiAgICBzdHIgKz0gJyknXG5cbiAgICByZXR1cm4gc3RyXG4gIH0sXG5cbiAgY29tcG9zaXRlczogeyBcbiAgICBzaW5lKCBmcmVxdWVuY3k9MiwgYW1wPTQsIGNlbnRlcj0wLCBzaG91bGRSb3VuZD1mYWxzZSApIHtcbiAgICAgIHJldHVybiBHZW4uY29tcG9zaXRlcy5sZm8oICdzaW5lJywgZnJlcXVlbmN5LCBhbXAsIGNlbnRlciwgc2hvdWxkUm91bmQgKVxuICAgIH0sXG4gICAgc2luZXIoIGZyZXF1ZW5jeT0yLCBhbXA9NCwgY2VudGVyPTAgKSB7XG4gICAgICByZXR1cm4gR2VuLmNvbXBvc2l0ZXMubGZvKCAnc2luZScsIGZyZXF1ZW5jeSwgYW1wLCBjZW50ZXIsIHRydWUgKVxuICAgIH0sXG4gICAgc3F1YXJlKCBmcmVxdWVuY3k9MiwgYW1wPTQsIGNlbnRlcj0wICkge1xuICAgICAgcmV0dXJuIEdlbi5jb21wb3NpdGVzLmxmbyggJ3NxdWFyZScsIGZyZXF1ZW5jeSwgYW1wLCBjZW50ZXIgKVxuICAgIH0sXG4gICAgc2F3KCBmcmVxdWVuY3k9MiwgYW1wPTQsIGNlbnRlcj0wICkge1xuICAgICAgcmV0dXJuIEdlbi5jb21wb3NpdGVzLmxmbyggJ3NhdycsIGZyZXF1ZW5jeSwgYW1wLCBjZW50ZXIgKVxuICAgIH0sXG4gICAgdHJpKCBmcmVxdWVuY3k9MiwgYW1wPTQsIGNlbnRlcj0wICkge1xuICAgICAgcmV0dXJuIEdlbi5jb21wb3NpdGVzLmxmbyggJ3RyaScsIGZyZXF1ZW5jeSwgYW1wLCBjZW50ZXIgKVxuICAgIH0sXG4gICAgbGZvKCB0eXBlID0gJ3NpbmUnLCBmcmVxdWVuY3kgPSAyLCBhbXAgPSAuNSwgY2VudGVyID0gLjUsIHNob3VsZFJvdW5kID0gZmFsc2UgKSB7XG4gICAgICBjb25zdCBnID0gR2VuLnVnZW5zIFxuICAgICAgY29uc3QgZ2liYmVyaXNoPSBBdWRpby5HaWJiZXJpc2hcbiAgICAgIGxldCBvc2NcblxuICAgICAgc3dpdGNoKCB0eXBlICkge1xuICAgICAgICBjYXNlICdzYXcnOlxuICAgICAgICAgIG9zYyA9IGcucGhhc29yKCBmcmVxdWVuY3kgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgb3NjID0gZy5hZGQoIGcubXVsKCBnLmd0KCBnLnBoYXNvciggZnJlcXVlbmN5ICksIDAgKSwgMiApLCAtMSApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnbm9pc2UnOlxuICAgICAgICAgIG9zYyA9IGcuc3ViKCBnLm11bCggZy5ub2lzZSgpLCAyICksIDEgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgY2FzZSAndHJpJzpcbiAgICAgICAgICBjb25zdCBwID0gZy5waGFzb3IoIGZyZXF1ZW5jeSApXG4gICAgICAgICAgb3NjID0gZy5zdWIoXG4gICAgICAgICAgICAxLCBcbiAgICAgICAgICAgIGcubXVsKCBcbiAgICAgICAgICAgICAgNCwgXG4gICAgICAgICAgICAgIGcuYWJzKFxuICAgICAgICAgICAgICAgIGcuc3ViKCBcbiAgICAgICAgICAgICAgICAgIGcucm91bmQoIHAgKSxcbiAgICAgICAgICAgICAgICAgIHBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgICBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzaW5lJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvc2MgPSBnLmN5Y2xlKCBmcmVxdWVuY3kgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IF9tdWwgICA9IGcubXVsKCBvc2MsIGFtcCApLFxuICAgICAgICAgICAgX2FkZCAgID0gZy5hZGQoIGNlbnRlciwgX211bCApIFxuXG4gICAgICBjb25zdCBsZm8gPSBzaG91bGRSb3VuZCA/IEdlbi5tYWtlKCBnLnJvdW5kKCBfYWRkICkgKSA6IEdlbi5tYWtlKCBfYWRkIClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIGxmbywge1xuICAgICAgICBmcmVxdWVuY3k6IHtcbiAgICAgICAgICBzZXQodikgeyBsZm8ucDEgPSB2IH0sXG4gICAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIGxmby5wMSB9XG4gICAgICAgIH0sXG4gICAgICAgIGdhaW46IHtcbiAgICAgICAgICBzZXQodikgeyBsZm8ucDIgPSB2IH0sXG4gICAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIGxmby5wMiB9XG4gICAgICAgIH0sXG4gICAgICAgIGJpYXM6IHtcbiAgICAgICAgICBzZXQodikgeyBsZm8ucDAgPSB2IH0sXG4gICAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIGxmby5wMCB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGxmby5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBHZW4uY29tcG9zaXRlcy5sZm8oIHR5cGUsIHRoaXMuZnJlcXVlbmN5LnZhbHVlLCB0aGlzLmdhaW4udmFsdWUsIHRoaXMuYmlhcy52YWx1ZSApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZm9cbiAgICB9LFxuXG4gICAgZmFkZSggdGltZSA9IDEsIGZyb20gPSAxLCB0byA9IDAgKSB7XG4gICAgICBsZXQgZyA9IEdlbi51Z2Vuc1xuICAgICAgbGV0IGZhZGUsIGFtdCwgYmVhdHNJblNlY29uZHMgPSB0aW1lICogKCA2MCAvIEdpYmJlci5MaXZlLkxPTS5icG0gKVxuICAgICBcbiAgICAgIGlmKCBmcm9tID4gdG8gKSB7XG4gICAgICAgIGFtdCA9IGZyb20gLSB0b1xuXG4gICAgICAgIGZhZGUgPSBnLmd0cCggZy5zdWIoIGZyb20sIGcuYWNjdW0oIGcuZGl2KCBhbXQsIGcubXVsKGJlYXRzSW5TZWNvbmRzLCBnLnNhbXBsZXJhdGUgKSApLCAwICkgKSwgdG8gKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGFtdCA9IHRvIC0gZnJvbVxuICAgICAgICBmYWRlID0gZy5hZGQoIGZyb20sIGcubHRwKCBnLmFjY3VtKCBnLmRpdiggYW10LCBnLm11bCggYmVhdHNJblNlY29uZHMsIGcuc2FtcGxlcmF0ZSApICksIDAgKSwgdG8gKSApXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFhYWCBzaG91bGQgdGhpcyBiZSBhdmFpbGFibGUgaW4gbXM/IG1zVG9CZWF0cygpP1xuICAgICAgbGV0IG51bWJlYXRzID0gdGltZSAvIDRcbiAgICAgIGZhZGUuc2hvdWxkS2lsbCA9IHtcbiAgICAgICAgYWZ0ZXI6IG51bWJlYXRzLCBcbiAgICAgICAgZmluYWw6IHRvXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWRlXG4gICAgfSxcbiAgICBcbiAgICAvL2JlYXRzKCBudW0gKSB7XG4gICAgLy8gIHJldHVybiBHZW4udWdlbnMucmF0ZSggbnVtIClcbiAgICAvLyAgLy8gYmVhdCggbiApID0+IHJhdGUoaW4xLCBuKVxuICAgIC8vICAvLyBmaW5hbCBzdHJpbmcgc2hvdWxkIGJlIHJhdGUoIGluMSwgbnVtIClcbiAgICAvL31cbiAgICBiZWF0cyggYiApIHtcbiAgICAgIHJldHVybiBHZW4udWdlbnMucGhhc29yKCBBdWRpby5VdGlsaXRpZXMuYnRvZiggYiApLCAwLCB7IG1pbjowIH0gKVxuICAgIH0sIFxuICAgIGJlYXRzMiggYiApIHtcbiAgICAgIHJldHVybiBHZW4udWdlbnMucGhhc29yKCBcbiAgICAgICAgQXVkaW8uVXRpbGl0aWVzLmJ0b2YoIGIgKSwgXG4gICAgICAgIDAsIFxuICAgICAgICB7IG1pbjowIH0gKVxuICAgIH0sIFxuICB9LFxuXG4gIHVnZW5zOnt9LFxuXG4gIGV4cG9ydCggb2JqICkge1xuICAgIGZvciggbGV0IGtleSBpbiBHZW4uZnVuY3Rpb25zICkge1xuICAgICAgdGhpcy51Z2Vuc1sga2V5IF0gPSBHZW4uY3JlYXRlLmJpbmQoIEdlbiwga2V5IClcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCB0aGlzLnVnZW5zLCBHZW4uY29uc3RhbnRzIClcbiAgICBPYmplY3QuYXNzaWduKCB0aGlzLnVnZW5zLCBHZW4uY29tcG9zaXRlcyApXG5cbiAgICBjb25zdCBfX2luID0gdGhpcy51Z2Vucy5pblxuICAgIGRlbGV0ZSB0aGlzLnVnZW5zLmluXG4gICAgT2JqZWN0LmFzc2lnbiggb2JqLCB0aGlzLnVnZW5zIClcbiAgICB0aGlzLnVnZW5zLmluID0gX19pblxuICB9LFxuXG5cbiAgLy8gZGVmZXIgY3JlYXRpbmcgZ2VuaXNoIG9iamVjdCB1bnRpbCB3ZSBrbm93IHdoZXRoZXJcbiAgLy8gdGhpcyB3aWxsIGJlIHVzZWQgYnkgYW4gYXVkaW8gb3IgdmlzdWFsIG9iamVjdFxuICBtYWtlKCBncmFwaCwgcHJvcGVydHlOYW1lcyApIHtcbiAgICBjb25zdCBkZWZlciA9IHsgXG4gICAgICBncmFwaCwgXG4gICAgICBfX2dyYXBoOmdyYXBoLFxuICAgICAgcHJvcGVydHlOYW1lcyxcbiAgICAgIHR5cGU6J2dlbicsXG4gICAgICBpZDogQXVkaW8uR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKSxcbiAgICAgIHJlbmRlcmVkOm51bGwsXG4gICAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gR2VuLm1ha2UoIHRoaXMuX19ncmFwaCApXG4gICAgICB9LFxuICAgICAgcmVuZGVyKCBzYW1wbGVyYXRlPTQ0MTAwLCB0eXBlPSdhdWRpbycgKSB7XG4gICAgICAgIGlmKCB0eXBlID09PSAnYXVkaW8nICkge1xuICAgICAgICAgIGlmKCB0aGlzLnJlbmRlcmVkID09PSBudWxsICkgeyBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBHZW4uX19tYWtlKCB0aGlzLmdyYXBoLCB0aGlzLnByb3BlcnR5TmFtZXMsIGRlZmVyIClcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5yZW5kZXJlZC5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfX1xuICAgICAgICAgICAgZm9yKCBsZXQga2V5IGluIHByb3BzICkgeyBcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBrZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnJlbmRlcmVkWyBrZXldIH0sXG4gICAgICAgICAgICAgICAgc2V0KHYpe1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFsga2V5IF0gPSB2IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLndpZGdldCA9IHRoaXMud2lkZ2V0XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLl9fZ3JhcGggPSBncmFwaFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IEF1ZGlvLkdpYmJlcmlzaC5nZW5pc2guc2FtcGxlcmF0ZVxuICAgICAgICBjb25zdCBnID0gQXVkaW8uR2liYmVyaXNoLmdlbmlzaFxuXG4gICAgICAgIEF1ZGlvLkdpYmJlcmlzaC5nZW5pc2guZ2VuLnNhbXBsZXJhdGUgPSBzYW1wbGVyYXRlXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdXG4gICAgICAgIGNvbnN0IF9fZ3JhcGggPSBldmFsKCBncmFwaC5nZW4oIHBhcmFtcyApIClcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBnLmdlbi5jcmVhdGVDYWxsYmFjayggX19ncmFwaCApXG4gICAgICAgIEF1ZGlvLkdpYmJlcmlzaC5nZW5pc2guZ2VuLnNhbXBsZXJhdGUgPSBzdG9yZSAgICAgIFxuXG4gICAgICAgIGNvbnN0IG91dCA9IGNhbGxiYWNrLmJpbmQoIG51bGwsIC4uLnBhcmFtcy5tYXAoIHYgPT4gdlsxXSApLCBnLm1lbW9yeSApXG5cbiAgICAgICAgLy8gYW5ub3RhdGlvbnMgY2FuIGJlIGFkZGVkIHRvIHRoZSBvcmlnaW5hbCBkZWZlciwgc28gc3RvcmUgdGhlIGRlZmVyXG4gICAgICAgIC8vIHRvIGFjY2VzcyB0aGUgYW5ub3RhdGlvbnMgbGF0ZXJcbiAgICAgICAgb3V0LnByZSA9IGRlZmVyIFxuXG4gICAgICAgIHJldHVybiBvdXRcbiAgICAgIH0sXG5cbiAgICAgIC8vIFhYWCBjb25uZWN0aW5nIGdlbiBvYmplY3RzIHRvIGF1ZGlvIHByb3BlcnRpZXMgbm8gbG9uZ2VyIHNlZW1zXG4gICAgICAvLyB0byB3b3JrLi4uIG11c3QgYmUgYXNzaWduZWQuIEZJWFxuICAgICAgY29ubmVjdCggdGFyZ2V0ICkge1xuICAgICAgICBpZiggdGFyZ2V0LnR5cGUgPT09ICdhdWRpbycgKSB7XG4gICAgICAgICAgaWYoIHRoaXMucmVuZGVyZWQgPT09IG51bGwgKSB7IFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IEdlbi5fX21ha2UoIHRoaXMuZ3JhcGgsIHRoaXMucHJvcGVydHlOYW1lcywgZGVmZXIgKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbmRlcmVkLmNvbm5lY3QoIHRhcmdldCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJcbiAgfSxcblxuICBfX21ha2UoIGdyYXBoLCBwcm9wZXJ0eU5hbWVzLCB0YXJnZXQgKSB7XG4gICAgY29uc3QgdWdlbiA9IEF1ZGlvLkdpYmJlcmlzaC5wcm90b3R5cGVzLlVnZW5cbiAgICBjb25zdCBnID0gQXVkaW8uR2liYmVyaXNoLmdlbmlzaFxuXG4gICAgLy8gc3RvcmUgcHJvcGVydGllcyBvZiBvdXIgZ2VuIG9iamVjdCBpbiB0aGlzIGFycmF5XG4gICAgLy8gdGhleSB3aWxsIHRoZW4gYmVjb21lIHByb3BlcnRpZXMgb2Ygb3VyIEdpYmJlciBvYmplY3RcbiAgICBjb25zdCBwYXJhbUFycmF5ID0gW11cblxuICAgIC8vIGdldCBnZW5pc2guanMgY29kZWxldCBmb3Igb3VyIGdyYXBoXG4gICAgY29uc3QgZ2VuQ29kZSA9IGdyYXBoLmdlbiggcGFyYW1BcnJheSApXG5cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXJ0aWVzIG9iamVjdCBvdXQgb2Ygb3VyIHBhcmFtQXJyYXlcbiAgICBjb25zdCBwYXJhbXMgPSB7fVxuICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtQXJyYXkgKSB7XG4gICAgICBwYXJhbXNbIHBhcmFtWzBdIF0gPSBwYXJhbVsxXVxuICAgIH0gXG5cbiAgICBjb25zdCBpZCA9IEdlbi5nZXRVSUQoKVxuXG4gICAgcGFyYW1zLmlkID0gQXVkaW8uR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgLy8gcGFzcyBhIGNvbnN0cnVjdG9yIHRvIG91ciB3b3JrbGV0IHByb2Nlc3NvclxuICAgIEF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgIGFkZHJlc3M6J2FkZE1ldGhvZCcsIFxuICAgICAgaWQ6LTEsXG4gICAgICBrZXk6J0dlbicgKyBpZCxcbiAgICAgIGZ1bmN0aW9uOmBmdW5jdGlvbigpIHsgXG4gICAgICAgIGNvbnN0IGcgPSBHaWJiZXJpc2guZ2VuaXNoOyBcbiAgICAgICAgY29uc3QgbXltb2QgPSBPYmplY3QuY3JlYXRlKCBHaWJiZXJpc2gucHJvdG90eXBlcy5VZ2VuICk7IFxuICAgICAgICBHaWJiZXJpc2guZmFjdG9yeSggbXltb2QsICR7Z2VuQ29kZX0sICdHZW4ke2lkfScsICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX0sIG51bGwsIHRydWUgKTsgXG4gICAgICAgIHJldHVybiBteW1vZDsgXG4gICAgICB9YFxuICAgIH0pXG5cbiAgICAvLyBjcmVhdGUgYSB3b3JrbGV0LXNpZGUgR2liYmVyaXNoIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgbWFrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbXltb2QgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIC8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGRvZXNuJ3QgbWF0dGVyIGluIHRoZSB3b3JrbGV0LCBvbmx5IGluIHRoZSBwcm9jZXNzb3JcbiAgICAgIC8vIHNvIHdlIGNhbiBqdXN0IGlucHV0IHplcm9lcy4gaG1tbW0uLi4gSSBndWVzIGl0IHByb2JhYmx5IG1hdHRlcnMgZm9yXG4gICAgICAvLyBzZXF1ZW5jaW5nP1xuICAgICAgXG4gICAgICByZXR1cm4gQXVkaW8uR2liYmVyaXNoLmZhY3RvcnkoIG15bW9kLCBnLmFkZCgwLDApLCAnR2VuJytpZCwgcGFyYW1zIClcbiAgICB9XG5cbiAgICAvLyBYWFggZG8gSSByZWFsbHkgaGF2ZSB0byBtYWtlIGEgR2liYmVyaXNoIGNvbnN0cnVjdG9yIGFuZCBhIEdpYmJlciBjb25zdHJ1Y3RvciB0b1xuICAgIC8vIHR1cm4gYSBnZW5pc2ggZ3JhcGggaW50byBhIEdpYmJlciB1Z2VuPyBJcyB0aGVyZSBhIHNob3J0Y3V0IHRvIHRha2U/IElzIGl0IHdvcnRoXG4gICAgLy8gd3JpdGluZyBjdXN0b20gY29kZSBmb3I/XG5cbiAgICAvLyBjcmVhdGUgYSBHaWJiZXIgY29uc3RydWN0b3IgdXNpbmcgb3VyIEdpYmJlcmlzaCBjb25zdHJ1Y3RvclxuICAgIGxldCB0ZW1wID0gcGFyYW1zLmlkXG4gICAgLy9kZWxldGUgcGFyYW1zLmlkXG4gICAgY29uc3QgTWFrZSA9IEF1ZGlvLlVnZW4oIG1ha2UsIHsgbmFtZTonR2VuJytpZCwgcHJvcGVydGllczpwYXJhbXMsIG1ldGhvZHM6W119LCBBdWRpbyApXG5cbiAgICAvLyBjcmVhdGUgR2liYmVyIHVnZW4gYW5kIHBhc3MgaW4gcHJvcGVydGllcyBkaWN0aW9uYXJ5IHRvIGluaXRhaWxpemVcbiAgICBjb25zdCBvdXQgPSBNYWtlKHsgcGFyYW1zIH0pXG4gICAgb3V0Ll9fd3JhcHBlZF9fLmlkID0gdGVtcCBcbiAgICBvdXQuX193cmFwcGVkX18uY29ubmVjdGVkID0gW11cblxuICAgIGxldCBjb3VudCA9IDBcbiAgICBvdXQuX193cmFwcGVkX18ub3V0cHV0ID0gb3V0Lm91dHB1dCA9IGZ1bmN0aW9uKCB2ICkge1xuICAgICAgLy9pZiggQXVkaW8uR2liYmVyLkVudmlyb25tZW50ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIC8vIFhYWCBzaG91bGQgdGhlc2UgYmUgYXZlcmFnZWQgaW5zdGVhZCBvZiBvbmx5IHRha2luZyBldmVyeSBzaXh0aCBzYW1wbGUgKHJvdWdobHlcbiAgICAgICAgLy8gY29ycmVzcG9uZHMgdG8gNTggZnJhbWVzIGEgc2Vjb25kKVxuICAgICAgICBpZiggY291bnQrKyAlIDYgPT09IDAgKSB7XG4gICAgICAgICAgLy8gWFhYIHRoaXMgc2hvdWxkbid0IGhhcHBlbiBoZXJlLCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIGFubm90YXRpb24gaXMgY3JlYXRlZC5cbiAgICAgICAgICBpZiggQXVkaW8uR2liYmVyLkVudmlyb25tZW50LkFubm90YXRpb25zLndhdmVmb3JtLndpZGdldHNbIHRlbXAgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgQXVkaW8uR2liYmVyLkVudmlyb25tZW50LkFubm90YXRpb25zLndhdmVmb3JtLndpZGdldHNbIHRlbXAgXSA9IG91dC53aWRnZXRcbiAgICAgICAgICB9XG4gICAgICAgICAgQXVkaW8uR2liYmVyLkVudmlyb25tZW50LkFubm90YXRpb25zLndhdmVmb3JtLnVwZGF0ZVdpZGdldCggb3V0LndpZGdldCwgdiwgZmFsc2UgKVxuICAgICAgICB9XG4gICAgICAvL31cblxuICAgICAgb3V0Lm91dHB1dC52YWx1ZSA9IHZcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbGx5IG1hcCB1c2VyIHByb3ZpZGVkIG5hbWVzIHRvIHAgdmFsdWVzIGZvciBiZXR0ZXIgY29udHJvbCAvIHNlcXVlbmNpbmdcbiAgICBpZiggQXJyYXkuaXNBcnJheSggcHJvcGVydHlOYW1lcyApKSB7XG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgaSBdXG4gICAgICAgIGlmKCBvdXRbICdwJytpIF0gIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eU5hbWUgIT09IG51bGwgJiYgcHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBvdXRbICdfXycrcHJvcGVydHlOYW1lIF0gPSBvdXRbICdwJytpIF1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG91dCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICBnZXQoKSB7IHJldHVybiBvdXRbICdfXycgKyBwcm9wZXJ0eU5hbWUgXSB9LFxuICAgICAgICAgICAgc2V0KHYpe1xuICAgICAgICAgICAgICBpZiggdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwgKSByZXR1cm5cbiAgICAgICAgICAgICAgb3V0WyAnX18nICsgcHJvcGVydHlOYW1lIF0udmFsdWUgPSB2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgICBnZXQoKSB7IHJldHVybiBvdXRbICdfXycgKyBwcm9wZXJ0eU5hbWUgXSB9LFxuICAgICAgICAgICAgc2V0KHYpe1xuICAgICAgICAgICAgICBpZiggdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwgKSByZXR1cm5cbiAgICAgICAgICAgICAgb3V0WyAnX18nICsgcHJvcGVydHlOYW1lIF0udmFsdWUgPSB2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICB9IFxuICAgICAgfVxuICAgIH1cblxuXG4gICAgb3V0LmlkID0gdGVtcFxuICAgIG91dC5fX2lzR2VuID0gb3V0Ll9fd3JhcHBlZF9fLl9faXNHZW4gPSB0cnVlXG4gICAgb3V0LnR5cGUgPSAnZ2VuJ1xuXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbkdlbi5pbml0KClcblxucmV0dXJuIEdlbiBcbn1cbiIsImNvbnN0IEdpYmJlcmlzaCA9IHJlcXVpcmUoICdnaWJiZXJpc2gtZHNwJyApXG5jb25zdCBVZ2VuICAgICAgPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5cbmNvbnN0IEluc3RydW1lbnRzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGluc3RydW1lbnRzID0ge31cbiAgICAvL2NvbnN0IHBvb2xlZEluc3RydW1lbnRzID0gWydTeW50aCcsJ01vbm9zeW50aCcsJ0ZNJ11cbiAgICBmb3IoIGxldCBpbnN0cnVtZW50TmFtZSBpbiBHaWJiZXJpc2guaW5zdHJ1bWVudHMgKSB7XG4gICAgICBjb25zdCBnaWJiZXJpc2hDb25zdHJ1Y3RvciA9IEdpYmJlcmlzaC5pbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXVxuICAgICAgaWYoIHR5cGVvZiBnaWJiZXJpc2hDb25zdHJ1Y3Rvci5kZWZhdWx0cyA9PT0gJ29iamVjdCcgKSBnaWJiZXJpc2hDb25zdHJ1Y3Rvci5kZWZhdWx0cy5vY3RhdmUgPSAwXG5cbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBJbnN0cnVtZW50cy5kZXNjcmlwdGlvbnNbIGluc3RydW1lbnROYW1lIF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBJbnN0cnVtZW50cy5kZXNjcmlwdGlvbnNbIGluc3RydW1lbnROYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzLCBcbiAgICAgICAgbWV0aG9kczptZXRob2RzLFxuICAgICAgICBuYW1lOmluc3RydW1lbnROYW1lLFxuICAgICAgICBjYXRlZ29yeTonaW5zdHJ1bWVudHMnXG4gICAgICB9XG5cbiAgICAgIC8vY29uc3Qgc2hvdWxkUG9vbCA9IHBvb2xlZEluc3RydW1lbnRzLmluZGV4T2YoIGluc3RydW1lbnROYW1lICkgPiAtMVxuICAgICAgaW5zdHJ1bWVudHNbIGluc3RydW1lbnROYW1lIF0gPSBVZ2VuKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvLCBmYWxzZSApIFxuXG4gICAgICAvLyBmb3IgcG9seSBub3RhdGlvbiBsaWtlIFN5bnRoWzNdKClcbiAgICAgIC8vIGNyZWF0ZSBvciBleHRlbmQgZGljdGlvbmFyeSB3aXRoIG1heFZvaWNlcyBwcm9wZXJ0eVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCAyMDsgaSsrICkge1xuICAgICAgICBpbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXVtpXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICBpZiggYXJncy5sZW5ndGggPiAxICkge1xuICAgICAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzFdLm1heFZvaWNlcyA9IGkgfHwgMVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSB7IG1heFZvaWNlczppIHx8IDEgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICBhcmdzWzBdLm1heFZvaWNlcyA9IGkgfHwgMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYXJnc1swXSA9IHsgbWF4Vm9pY2VzOmkgfHwgMSB9XG4gICAgICAgICAgfSBcblxuICAgICAgICAgIC8vIHVzZSBtb25vcGhvbmljIHZlcnNpb24gaWYgdm9pY2UgY291bnQgaXMgMSBvciBsZXNzXG4gICAgICAgICAgbGV0IG5hbWVcbiAgICAgICAgICBpZiggaSA+IDEgKSB7XG4gICAgICAgICAgICBuYW1lID0gaW5zdHJ1bWVudE5hbWUgPT09ICdTYW1wbGVyJyA/ICdNdWx0aXNhbXBsZXInIDogJ1BvbHknK2luc3RydW1lbnROYW1lXG4gICAgICAgICAgICBpZiggbmFtZSA9PT0gJ1BvbHlNb25vc3ludGgnICkgbmFtZSA9ICdQb2x5TW9ubycgXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBuYW1lID0gaW5zdHJ1bWVudE5hbWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudHNbIG5hbWUgXSggLi4uYXJncyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICBpbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXS5wcmVzZXRzID0gQXVkaW8uUHJlc2V0cy5pbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXSBcbiAgICAgIGlmKCBpbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXS5wcmVzZXRzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdLnByZXNldHMuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUudGFibGUoIHRoaXMgKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaW5zdHJ1bWVudHNbIGluc3RydW1lbnROYW1lIF0ucHJlc2V0cyA9IHsgaW5zcGVjdCgpIHsgY29uc29sZS5sb2coIGAke2luc3RydW1lbnROYW1lfSBoYXMgbm8gcHJlc2V0cy5gICkgfSB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RydW1lbnRzLlBsdWNrID0gaW5zdHJ1bWVudHMuS2FycGx1c1xuICAgIHJldHVybiBpbnN0cnVtZW50c1xuICB9LFxuXG4gIGRlc2NyaXB0aW9uczoge1xuICAgIENsYXA6e1xuICAgICAgbWV0aG9kczpbICd0cmlnZ2VyJyBdLFxuICAgIH0sICAgXG4gICAgQ29uZ2E6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIENsYXZlOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBDb3diZWxsOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBGTTp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgSGF0OntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBLYXJwbHVzOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBLaWNrOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBNb25vc3ludGg6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFNhbXBsZXI6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywgJ3RyaWdnZXInLCAnbG9hZEZpbGUnLCAnbG9hZEJ1ZmZlcicgXSxcbiAgICB9LFxuICAgIE11bHRpc2FtcGxlcjp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCAndHJpZ2dlcicsICdwaWNrJywgJ3BpY2tGaWxlJywgJ3BpY2twbGF5JywgJ2xvYWRTYW1wbGUnLCAnc2V0cGFuJywgJ3NldHJhdGUnIF0sIFxuICAgIH0sXG4gICAgU291bmRmb250OntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsICd0cmlnZ2VyJywgJ21pZGlub3RlJywgJ21pZGljaG9yZCcsICdjaG9yZCcsICdsb2FkJywgJ3NldHBhbicsICdzZXRyYXRlJyBdLCBcbiAgICB9LFxuICAgIFNuYXJlOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBTeW50aDp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgQ29tcGxleDp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgVG9tOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBQb2x5U3ludGg6e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgUG9seUNvbXBsZXg6e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgUG9seUZNOntcbiAgICAgIG1ldGhvZHM6WyAnY2hvcmQnLCdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFBvbHlLYXJwbHVzOntcbiAgICAgIG1ldGhvZHM6WyAnY2hvcmQnLCdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFBvbHlNb25vOntcbiAgICAgIG1ldGhvZHM6WyAnY2hvcmQnLCdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFBvbHlDb25nYTp7XG4gICAgICBtZXRob2RzOlsgJ2Nob3JkJywnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBQb2x5VG9tOntcbiAgICAgIG1ldGhvZHM6WyAnY2hvcmQnLCdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICB9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnN0cnVtZW50c1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggQXVkaW8gKSB7XG4gIGNvbnN0IEdpYmJlcmlzaCA9IEF1ZGlvLkdpYmJlcmlzaFxuXG4gIGNvbnN0IGZuYyA9IGZ1bmN0aW9uKCBwcm9wcyApe1xuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5uYW1lXG4gICAgY29uc3QgdHlwZSA9IHByb3BzLnR5cGVcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJvcHMucHJvcGVydGllcyB8fCB7fVxuICAgIGNvbnN0IGJsb2NrID0gYFxuICAgIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBHaWJiZXJpc2gucHJvdG90eXBlc1sgJyR7dHlwZX0nIF0gKVxuICAgIGNvbnN0IGdyYXBoZm5jID0gJHtwcm9wcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpfVxuXG4gICAgY29uc3QgcHJveHkgPSBHaWJiZXJpc2guZmFjdG9yeSggdWdlbiwgZ3JhcGhmbmMoKSwgJyR7bmFtZX0nLCAke0pTT04uc3RyaW5naWZ5KHByb3BlcnRpZXMpfSApXG4gICAgcmV0dXJuIHByb3h5YFxuXG4gICAgR2liYmVyaXNoWyBuYW1lIF0gPSBuZXcgRnVuY3Rpb24oIGJsb2NrIClcblxuICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgbmFtZSxcbiAgICAgIGFkZHJlc3M6J2FkZENvbnN0cnVjdG9yJyxcbiAgICAgIGNvbnN0cnVjdG9yU3RyaW5nOmBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICAgICAgY29uc3QgZm5jID0gJHtHaWJiZXJpc2hbIG5hbWUgXS50b1N0cmluZygpfVxuXG4gICAgICByZXR1cm4gZm5jXG4gICAgfWBcbiAgICB9KVxuXG4gICAgY29uc3Qgb3V0ID0gQXVkaW8uVWdlbiggXG4gICAgICBHaWJiZXJpc2hbIG5hbWUgIF0sXG4gICAgICB7IHByb3BlcnRpZXMsIG1ldGhvZHM6W10sIG5hbWUsIGNhdGVnb3J5OidpbnN0cnVtZW50cyd9LFxuICAgICAgQXVkaW8gXG4gICAgKVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHJldHVybiBmbmNcbn1cblxuLyogZXhhbXBsZSB1c2U6XG5kZWYgPSB7XG4gIG5hbWU6J015c2luZScsXG4gIHR5cGU6J1VnZW4nLFxuICBwcm9wZXJ0aWVzOnsgZnJlcXVlbmN5OjIyMCB9LFxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZ2VuID0gR2liYmVyaXNoLmdlbmlzaFxuICAgIGNvbnN0IGdyYXBoID0gZ2VuLmN5Y2xlKCBnZW4uaW4oJ2ZyZXF1ZW5jeScpIClcbiAgICByZXR1cm4gZ3JhcGhcbiAgfVxufVxuIFxuTXlzaW5lID0gTWFrZSggZGVmIClcbnNpbmUgPSBTKClcbnNpbmUuZnJlcXVlbmN5LnNlcSggWzExMCwyMjAsMzMwXSwgMS84IClcbnNpbmUuY29ubmVjdCgpXG4qL1xuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgT3NjaWxsYXRvcnMgPSB7XG4gIGNyZWF0ZSggQXVkaW8gKSB7XG4gICAgY29uc3Qgb3NjaWxsYXRvcnMgPSB7fVxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgZnJlcXVlbmN5OjIyMCwgZ2FpbjouMjUsIHB1bHNld2lkdGg6LjVcbiAgICB9XG4gICAgZm9yKCBsZXQgb3NjaWxsYXRvck5hbWUgaW4gR2liYmVyaXNoLm9zY2lsbGF0b3JzICkge1xuICAgICAgY29uc3QgZ2liYmVyaXNoQ29uc3RydWN0b3IgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnNbIG9zY2lsbGF0b3JOYW1lIF1cblxuICAgICAgLy9jb25zdCBtZXRob2RzID0gT3NjaWxsYXRvcnMuZGVzY3JpcHRpb25zWyBvc2NpbGxhdG9yTmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogT3NjaWxsYXRvcnMuZGVzY3JpcHRpb25zWyBvc2NpbGxhdG9yTmFtZSBdLm1ldGhvZHNcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0geyBcbiAgICAgICAgcHJvcGVydGllczpkZWZhdWx0cywgXG4gICAgICAgIG1ldGhvZHM6W10sXG4gICAgICAgIG5hbWU6b3NjaWxsYXRvck5hbWUsXG4gICAgICAgIGNhdGVnb3J5Oidvc2NpbGxhdG9ycydcbiAgICAgIH1cblxuICAgICAgb3NjaWxsYXRvcnNbIG9zY2lsbGF0b3JOYW1lIF0gPSBVZ2VuKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvIClcblxuICAgIH1cbiAgICByZXR1cm4gb3NjaWxsYXRvcnNcbiAgfSxcblxuICBkZXNjcmlwdGlvbnM6IHt9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPc2NpbGxhdG9yc1xuIiwiY29uc3QgUHJlc2V0cyA9IHtcbiAgcHJvY2VzcyggZGVzY3JpcHRpb24sIGFyZ3MsIEF1ZGlvICkge1xuICAgIGxldCBvdXRwdXRcblxuICAgIC8vIGlmIHRoZSBjb25zdHJ1Y3RvciBhcnVnbWVudCBpcyBub3QgYSBzdHJpbmcgdGhlbiBubyBwcmVzZXQgaXMgYmVpbmcgdXNlZFxuICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICBvdXRwdXQgPSBhcmdzWyAwIF0gIFxuICAgIH1lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKXtcbiAgICAgIGlmKCBhcmdzWzBdID09PSAnaW5zcGVjdCcgKSByZXR1cm4gbnVsbFxuICAgICAgb3V0cHV0ID0ge31cbiAgICAgIGNvbnN0IHByZXNldCA9IFByZXNldHNbIGRlc2NyaXB0aW9uLmNhdGVnb3J5IF1bIGRlc2NyaXB0aW9uLm5hbWUgXVsgYXJnc1swXSBdXG5cbiAgICAgIGlmKCBwcmVzZXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgZm9yKCBsZXQga2V5IGluIHByZXNldCApIHtcbiAgICAgICAgICBpZigga2V5ID09PSAncHJlc2V0SW5pdCcgKSBjb250aW51ZVxuICAgICAgICAgIGxldCB2YWx1ZSA9IHByZXNldFsga2V5IF1cblxuICAgICAgICAgIC8vIGlmIGEgdmFsdWUgaXMgYSBmdW5jdGlvbiwgcnVuIHRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIG5ldyB2YWx1ZS4gdGhlc2VcbiAgICAgICAgICAvLyBwcmVzZXQgZnVuY3Rpb25zIGFyZSBwYXNzZWQgdGhlIG1haW4gYXVkaW8gb2JqZWN0LCB3aGljaCB0aGV5IGNhbiB0eXBpY2FsbHlcbiAgICAgICAgICAvLyB1c2UsIGZvciBleGFtcGxlLCB0byBxdWVyeSB0aGUgY3VycmVudCBzYW1wbGUgcmF0ZS5cbiAgICAgICAgICBvdXRwdXRbIGtleSBdID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoIEF1ZGlvICkgOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggcHJlc2V0LnByZXNldEluaXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBvdXRwdXQuX19wcmVzZXRJbml0X18gPSBwcmVzZXQucHJlc2V0SW5pdCBcbiAgICAgICAgfSBcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLndhcm4oIGBUaGUgcHJlc2V0ICR7YXJnc1swXX0gZm9yIHRoZSAke2Rlc2NyaXB0aW9uLmNhdGVnb3J5LnNsaWNlKDAsLTEpfSAke2Rlc2NyaXB0aW9uLm5hbWV9IGRvZXMgbm90IGV4aXN0LmAgKVxuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gZXh0cmEgYXJndW1lbnQgdG8gbW9kaWZ5IHRoZSBwcmVzZXQuLi5cbiAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oIG91dHB1dCwgYXJnc1sxXSApXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBvdXRwdXQgPSB7fVxuICAgIH1cbiAgICBcbiAgICBpZiggZGVzY3JpcHRpb24uX19kZWZhdWx0c19fICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBjb25zb2xlLmxvZyggJ2RlZmF1bHRzOicsIGRlc2NyaXB0aW9uLl9fZGVmYXVsdHNfXyApXG4gICAgICBPYmplY3QuYXNzaWduKCBvdXRwdXQsIGRlc2NyaXB0aW9uLl9fZGVmYXVsdHNfXyApXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFxuICB9LFxuXG4gIGluc3RydW1lbnRzOiB7XG4gICAgQ29tcGxleDogcmVxdWlyZSggJy4vcHJlc2V0cy9jb21wbGV4X3ByZXNldHMuanMnICksXG4gICAgU3ludGg6IHJlcXVpcmUoICcuL3ByZXNldHMvc3ludGhfcHJlc2V0cy5qcycgKSxcbiAgICBGTTogICAgcmVxdWlyZSggJy4vcHJlc2V0cy9mbV9wcmVzZXRzLmpzJyApLFxuICAgIE1vbm9zeW50aDogcmVxdWlyZSggJy4vcHJlc2V0cy9tb25vc3ludGhfcHJlc2V0cy5qcycgKSxcbiAgICBQb2x5TW9ubzogcmVxdWlyZSggJy4vcHJlc2V0cy9tb25vc3ludGhfcHJlc2V0cy5qcycgKSxcbiAgICBTbmFyZTogcmVxdWlyZSggJy4vcHJlc2V0cy9zbmFyZV9wcmVzZXRzLmpzJyApLFxuICAgIEtpY2s6IHJlcXVpcmUoICcuL3ByZXNldHMva2lja19wcmVzZXRzLmpzJyApLFxuICAgIEhhdDogcmVxdWlyZSggJy4vcHJlc2V0cy9oYXRfcHJlc2V0cy5qcycgKSxcblxuICAgIEVEcnVtczogcmVxdWlyZSggJy4vcHJlc2V0cy9lZHJ1bXNfcHJlc2V0cy5qcycgKSxcbiAgICBEcnVtczogIHJlcXVpcmUoICcuL3ByZXNldHMvZHJ1bXNfcHJlc2V0cy5qcycgKSxcbiAgICBNdWx0aXNhbXBsZXI6IHJlcXVpcmUoICcuL3ByZXNldHMvbXVsdGlzYW1wbGVyLmpzJyApLFxuICAgIFNvdW5kZm9udDogICAgcmVxdWlyZSggJy4vcHJlc2V0cy9zb3VuZGZvbnRfcHJlc2V0cy5qcycgKVxuICB9LFxuXG4gIGVmZmVjdHM6IHtcbiAgICBDaG9ydXM6IHJlcXVpcmUoICcuL3ByZXNldHMvY2hvcnVzX3ByZXNldHMuanMnICksXG4gICAgRGlzdG9ydGlvbjogcmVxdWlyZSggJy4vcHJlc2V0cy9kaXN0b3J0aW9uX3ByZXNldHMuanMnICksXG4gICAgRmxhbmdlcjogcmVxdWlyZSggJy4vcHJlc2V0cy9mbGFuZ2VyX3ByZXNldHMuanMnICksXG4gICAgUmV2ZXJiOiByZXF1aXJlKCAnLi9wcmVzZXRzL3JldmVyYi5qcycgKSxcbiAgICBEZWxheTogcmVxdWlyZSggJy4vcHJlc2V0cy9kZWxheV9wcmVzZXRzLmpzJyApLFxuICB9LFxuXG4gIG1pc2M6IHtcbiAgICBCdXMyOiByZXF1aXJlKCAnLi9wcmVzZXRzL2J1czJfcHJlc2V0cy5qcycgKVxuICB9XG5cbn1cblxuUHJlc2V0cy5pbnN0cnVtZW50cy5TYW1wbGVyICAgPSBQcmVzZXRzLmluc3RydW1lbnRzLk11bHRpc2FtcGxlclxuUHJlc2V0cy5pbnN0cnVtZW50cy5Qb2x5U3ludGggPSBQcmVzZXRzLmluc3RydW1lbnRzLlN5bnRoXG5QcmVzZXRzLmluc3RydW1lbnRzLlBvbHlGTSA9IFByZXNldHMuaW5zdHJ1bWVudHMuRk1cblByZXNldHMuaW5zdHJ1bWVudHMuUG9seU1vbm8gPSBQcmVzZXRzLmluc3RydW1lbnRzLk1vbm9zeW50aFxuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldHNcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICdzcGFjZXZlcmInOiB7XG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC52ZXJiID0gYXVkaW8uZWZmZWN0cy5GcmVldmVyYih7IHJvb21TaXplOi45ODUsIGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC52ZXJiIClcbiAgICB9XG4gIH0sXG4gICdlY2hvdmVyYi4xLzMnOiB7XG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5kZWxheSA9IGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvMywgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6LjUgfSlcbiAgICAgIHRoaXMuZngucmV2ZXJiICA9IGF1ZGlvLmVmZmVjdHMuRnJlZXZlcmIoeyByb29tU2l6ZTouOTg1LCBkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZnguZGVsYXkgKVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZngucmV2ZXJiIClcbiAgICAgIHRoaXMuZmVlZGJhY2sgPSB0aGlzLmZ4LmRlbGF5LmZlZWRiYWNrXG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLmZ4LmRlbGF5LnRpbWVcbiAgICAgIHRoaXMucm9vbVNpemUgPSB0aGlzLmZ4LnJldmVyYi5yb29tU2l6ZVxuICAgIH1cbiAgfSxcbiAgJ2VjaG92ZXJiLjEvNic6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouMzUsIHdldGRyeTouNSB9KVxuICAgICAgdGhpcy5meC52ZXJiICA9IGF1ZGlvLmVmZmVjdHMuRnJlZXZlcmIoeyByb29tU2l6ZTouOTg1LCBkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZnguZGVsYXksIHRoaXMuZngucmV2ZXJiIClcbiAgICAgIHRoaXMuZmVlZGJhY2sgPSB0aGlzLmZ4LmRlbGF5LmZlZWRiYWNrXG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLmZ4LmRlbGF5LnRpbWVcbiAgICAgIHRoaXMucm9vbVNpemUgPSB0aGlzLmZ4LnJldmVyYi5yb29tU2l6ZVxuICAgIH1cbiAgfSxcbiAgJ2RlbGF5LjEvNic6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouMzUsIHdldGRyeTouNSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZnguZGVsYXkgKVxuICAgICAgdGhpcy5mZWVkYmFjayA9IHRoaXMuZnguZGVsYXkuZmVlZGJhY2tcbiAgICAgIHRoaXMudGltZSA9IHRoaXMuZnguZGVsYXkudGltZVxuICAgIH1cbiAgfSxcbiAgJ2RlbGF5LjEvMyc6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS8zLCBmZWVkYmFjazouMzUsIHdldGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSApXG4gICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5meC5kZWxheS5mZWVkYmFja1xuICAgICAgdGhpcy50aW1lID0gdGhpcy5meC5kZWxheS50aW1lXG4gICAgfVxuICB9LCBcbiAgJ2RlbGF5LjEvNi5mYic6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouODI1LCB3ZXRkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZGVsYXkgKSBcbiAgICB9XG4gIH0sXG4gICdkZWxheS4xLzMuZmInOiB7XG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5kZWxheSA9IGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvMywgZmVlZGJhY2s6LjgyNSwgd2V0ZHJ5OjEgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmRlbGF5IClcbiAgICB9XG4gIH0sXG4gICdkZWxheS4xLzUnOiB7XG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5kZWxheSA9IGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvNSwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZnguZGVsYXkgKVxuICAgICAgdGhpcy5mZWVkYmFjayA9IHRoaXMuZnguZGVsYXkuZmVlZGJhY2tcbiAgICAgIHRoaXMudGltZSA9IHRoaXMuZnguZGVsYXkudGltZVxuICAgIH1cbiAgfSxcbiAgJ2RlbGF5LjEvOCc6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS84LCBmZWVkYmFjazouMzUsIHdldGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSApXG4gICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5meC5kZWxheS5mZWVkYmFja1xuICAgICAgdGhpcy50aW1lID0gdGhpcy5meC5kZWxheS50aW1lXG4gICAgfVxuICB9LFxuICAnZGVsYXkuMS85Jzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzksIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5OjEgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmZ4LmRlbGF5IClcbiAgICB9XG4gIH0sXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBsdXNoOiB7XG4gICAgZmFzdEZyZXF1ZW5jeTo0LFxuICAgIGZhc3RHYWluOi40MjUsXG4gICAgc2xvd0dhaW46My41LFxuICAgIHNsb3dGcmVxdWVuY3k6MSxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICBjb25zdCBnZW4gPSBhdWRpby5HZW4udWdlbnNcbiAgICAgIHRoaXMubW9kMSA9IGF1ZGlvLkdlbi5tYWtlKCBhdWRpby5HZW4udWdlbnMuY3ljbGUoLjEpICkuY29ubmVjdCggdGhpcy5mYXN0RnJlcXVlbmN5IClcbiAgICAgIC8vdGhpcy5mYXN0R2FpbiA9ICBhdWRpby5HZW4ubWFrZSggZ2VuLmFkZCggLjQyNSwgZ2VuLmN5Y2xlKC4xKSApIClcbiAgICAgIHRoaXMubW9kMiA9IGF1ZGlvLkdlbi5tYWtlKCBhdWRpby5HZW4udWdlbnMuY3ljbGUoLjA1KSApLmNvbm5lY3QoIHRoaXMuc2xvd0dhaW4gKVxuICAgICAgLy90aGlzLnNsb3dHYWluID0gYXVkaW8uR2VuLm1ha2UoIGdlbi5hZGQoIDQuNSwgZ2VuLmN5Y2xlKC4wNSkgKSApXG4gICAgfVxuICB9LFxuXG4gIHdhcmJseToge1xuICAgIGZhc3RGcmVxdWVuY3k6NCxcbiAgICBzbG93R2FpbjozLFxuICAgIHNsb3dGcmVxdWVuY3k6MSxcbiAgICBmYXN0R2FpbjoxLjUsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5tb2QxID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5jeWNsZSguMSkgKS5jb25uZWN0KCB0aGlzLmZhc3RGcmVxdWVuY3kgKVxuICAgICAgdGhpcy5tb2QyID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5jeWNsZSguMDUpICkuY29ubmVjdCggdGhpcy5zbG93R2FpbiApXG4gICAgfVxuICB9XG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAncGx1Y2tlZCc6IHtcbiAgICBiaWFzOi4zNSxcbiAgICBnYWluOjEsXG4gICAgZGVjYXk6MS81LFxuICAgIHByZWdhaW46NCxcbiAgICBkZXNjcmlwdGlvbjonYSBzaG9ydCwgY2xlYW4gc291bmRpbmcgcHJlc2V0IHdpdGggYSBtaW5pbXVtIG9mIGRpc3RvcnRpb24vd2F2ZWZvbGRpbmcuJ1xuICB9LFxuICBcbiAgJ3BlcmMnOiB7XG4gICAgYmlhczouMzUsXG4gICAgZ2FpbjoxLFxuICAgIGRlY2F5OjEvNSxcbiAgICBwcmVnYWluOjUsXG4gICAgZGVzY3JpcHRpb246J2Egc2hvcnQsIGNsZWFuIHNvdW5kaW5nIHByZXNldCB3aXRoIGEgbWluaW11bSBvZiBkaXN0b3J0aW9uL3dhdmVmb2xkaW5nLidcbiAgfSxcblxuICBzdGFiOiB7XG4gICAgd2F2ZWZvcm06J3NhdycsIFxuICAgIGRlY2F5OjEvNCwgXG4gICAgYmlhczouMSwgXG4gICAgZmlsdGVyTXVsdDowLCBcbiAgICBjdXRvZmY6LjgsIFxuICAgIFE6LjE1LCBcbiAgICBwcmVnYWluOjEwLCBcbiAgICBwb3N0Z2FpbjouMjUsIFxuICAgIGZpbHRlck1vZGVsOjIsIFxuICAgIHNhdHVyYXRpb246NTAsXG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LnB1c2goIGF1ZGlvLmVmZmVjdHMuRGlzdG9ydGlvbignZWFyc2hyZWQnKSApXG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjonYSBzaG9ydCwgaGVhdmlseSBkaXN0b3J0ZWQgYW5kIGZpbHRlcmVkIHNvdW5kLiBpbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgQ29tcGxleCB3YXZlZm9sZGluZywgdGhpcyBwcmVzZXQgYWxzbyBhZGRzIGFuIGFkZGl0aW9uYWwgRGlzdG9ydGlvbiBlZmZlY3QgKHByZXNldCBlYXJzcmVkKS4nXG4gIH1cblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICcxLzMnIDoge1xuICAgIHRpbWU6MS8zLCBmZWVkYmFjazouMzUsIHdldGRyeToxIFxuICB9LFxuICAnMS82JyA6IHtcbiAgICB0aW1lOjEvNiwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS84JyA6IHtcbiAgICB0aW1lOjEvOCwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS85JyA6IHtcbiAgICB0aW1lOjEvOSwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS8zLmZiJyA6IHtcbiAgICB0aW1lOjEvMywgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6MSBcbiAgfSxcbiAgJzEvNi5mYicgOiB7XG4gICAgdGltZToxLzYsIGZlZWRiYWNrOi44NSwgd2V0ZHJ5OjFcbiAgfSxcbiAgJzEvOC5mYicgOiB7XG4gICAgdGltZToxLzgsIGZlZWRiYWNrOi44NSwgd2V0ZHJ5OjFcbiAgfSxcbiAgJzEvOS5mYicgOiB7XG4gICAgdGltZToxLzksIGZlZWRiYWNrOi44NSwgd2V0ZHJ5OjFcbiAgfSxcbiAgJzEvMy5kcnknIDoge1xuICAgIHRpbWU6MS8zLCBmZWVkYmFjazouMzUsIHdldGRyeTouNSBcbiAgfSxcbiAgJzEvNi5kcnknIDoge1xuICAgIHRpbWU6MS82LCBmZWVkYmFjazouMzUsIHdldGRyeTouNVxuICB9LFxuICAnMS84LmRyeScgOiB7XG4gICAgdGltZToxLzgsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41XG4gIH0sXG4gICcxLzkuZHJ5JyA6IHtcbiAgICB0aW1lOjEvOSwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6LjVcbiAgfSxcbiAgJzEvMy5kcnkuZmInIDoge1xuICAgIHRpbWU6MS8zLCBmZWVkYmFjazouODUsIHdldGRyeTouNSBcbiAgfSxcbiAgJzEvNi5kcnkuZmInIDoge1xuICAgIHRpbWU6MS82LCBmZWVkYmFjazouMzUsIHdldGRyeTouNVxuICB9LFxuICAnMS84LmRyeS5mYicgOiB7XG4gICAgdGltZToxLzgsIGZlZWRiYWNrOi44NSwgd2V0ZHJ5Oi41XG4gIH0sXG4gICcxLzkuZHJ5LmZiJyA6IHtcbiAgICB0aW1lOjEvOSwgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6LjVcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgY3J1bmNoOiB7XG4gICAgcHJlZ2FpbjoxMCwgXG4gICAgcG9zdGdhaW46LjM1XG4gIH0sXG5cbiAgZWFyc2hyZWQ6IHtcbiAgIHByZWdhaW46IDUwMCxcbiAgIHBvc3RnYWluOiAuMDYsXG4gICBzaGFwZTE6IC4wMDEsXG4gICBzaGFwZTI6IC0zXG4gIH0sXG5cbiAgYmFzczoge1xuICAgIHByZWdhaW46MTAsXG4gICAgcG9zdGdhaW46LjM1LFxuICAgIHNoYXBlMTozLFxuICAgIHNoYXBlMjoxMFxuICB9LFxuXG4gIG1lZGl1bToge1xuICAgIHByZWdhaW46NDAsXG4gICAgcG9zdGdhaW46LjEyNS80XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGVhcnNocmVkOiB7XG4gICAgLy8gdW5mb3J0dW5hdGVseSB5b3UgY2FuJ3Qgd3JpdGUgbm9ybWFsIHByZXNldHMgZm9yXG4gICAgLy8gRHJ1bXMgYW5kIEVEcnVtcywgYmVjYXVzZSB0aGV5IGRvbid0IGdvIHRocm91Z2hcbiAgICAvLyB0aGUgVWdlbiBjb25zdHJ1Y3RvciBpbiB0aGUgdHlwaWNhbCB3YXkgKHRoZXkgYXJlXG4gICAgLy8gcHJvY2Vzc2VkIGFzIGJ1c3NlcykuIEl0IHdvdWxkIGFsc29cbiAgICAvLyBiZSBkaWZmaWN1bHQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gZHJ1bSBjb21wb25lbnRzIChzbmFyZSxraWNrIGV0Yy4pIHVzaW5nIHRoZSBzdGFuZGFyZFxuICAgIC8vIHByZXNldCBmb3JtYXQuIEZvciB0aGVzZSByZWFzb25zLCBhbGwgcHJvcGVydHkgYXNzaWdubWVudFxuICAgIC8vIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIGluaXRpYWxpemF0aW9uLiBcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguYWRkKCBhdWRpby5lZmZlY3RzLkRpc3RvcnRpb24oJ2VhcnNocmVkJykgKVxuICAgIH1cbiAgfSxcblxuICBocGY6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIC8vIFhYWCBoYXZlIHRvIHNwZWNpZnkgaW5wdXQgYmVjYXVzZSBvZiBmaWx0ZXIgZXJyb3JzLi4uXG4gICAgICBjb25zdCBocGYgPSBhdWRpby5maWx0ZXJzLkZpbHRlcjEyQmlxdWFkKHsgaW5wdXQ6dGhpcywgbW9kZToxLCBjdXRvZmY6LjI1LCBROi41LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggaHBmIClcbiAgICAgIHRoaXMuaHBmID0gaHBmXG4gICB9XG4gIH0sXG4gIGxwZjoge1xuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgLy8gWFhYIGhhdmUgdG8gc3BlY2lmeSBpbnB1dCBiZWNhdXNlIG9mIGZpbHRlciBlcnJvcnMuLi5cbiAgICAgIGNvbnN0IGxwZiA9IGF1ZGlvLmZpbHRlcnMuRmlsdGVyMjRNb29nKHsgaW5wdXQ6dGhpcywgbW9kZTowLCBjdXRvZmY6LjI1LCBROi43NSwgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIGxwZiApXG4gICAgICB0aGlzLmxwZiA9IGxwZlxuICAgIH1cbiAgfVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBlYXJzaHJlZDoge1xuICAgIC8vIHVuZm9ydHVuYXRlbHkgeW91IGNhbid0IHdyaXRlIG5vcm1hbCBwcmVzZXRzIGZvclxuICAgIC8vIERydW1zIGFuZCBFRHJ1bXMsIGJlY2F1c2UgdGhleSBkb24ndCBnbyB0aHJvdWdoXG4gICAgLy8gdGhlIFVnZW4gY29uc3RydWN0b3IgaW4gdGhlIHR5cGljYWwgd2F5ICh0aGV5IGFyZVxuICAgIC8vIHByb2Nlc3NlZCBhcyBidXNzZXMpLiBJdCB3b3VsZCBhbHNvXG4gICAgLy8gYmUgZGlmZmljdWx0IHRvIGRlZmluZSBwcm9wZXJ0aWVzIGZvciB0aGUgaW5kaXZpZHVhbFxuICAgIC8vIGRydW0gY29tcG9uZW50cyAoc25hcmUsa2ljayBldGMuKSB1c2luZyB0aGUgc3RhbmRhcmRcbiAgICAvLyBwcmVzZXQgZm9ybWF0LiBGb3IgdGhlc2UgcmVhc29ucywgYWxsIHByb3BlcnR5IGFzc2lnbm1lbnRcbiAgICAvLyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciBpbml0aWFsaXphdGlvbi4gXG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmFkZCggYXVkaW8uZWZmZWN0cy5EaXN0b3J0aW9uKCdlYXJzaHJlZCcpIClcblxuICAgICAgdGhpcy5raWNrLmZyZXF1ZW5jeSA9IDU1XG4gICAgICB0aGlzLmtpY2suZGVjYXkgPSAuOTc1XG5cbiAgICAgIHRoaXMuc25hcmUudHVuZSA9IC4yNVxuICAgICAgdGhpcy5zbmFyZS5zbmFwcHkgPSAxLjVcbiAgICB9XG4gIH0sXG5cbiAgd2FyYmx5OiB7XG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICBjb25zdCBiYyA9IGF1ZGlvLmVmZmVjdHMuQml0Q3J1c2hlcih7IGlucHV0OnRoaXMsIHNhbXBsZVJhdGU6LjM1LCBiaXREZXB0aDouNSwgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIGJjIClcbiAgICAgIHRoaXMuYml0Y3J1c2hlciA9IGJjXG4gICAgICBjb25zdCBmbGFuZ2VyID0gYXVkaW8uZWZmZWN0cy5GbGFuZ2VyKHsgaW5wdXQ6dGhpcywgZnJlcXVlbmN5Oi44LCBmZWVkYmFjazouOTM1LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggZmxhbmdlciApXG4gICAgICB0aGlzLmZsYW5nZXIgPSBmbGFuZ2VyXG4gICAgICB0aGlzLmdhaW4udmFsdWUgKj0gMS4zNVxuICAgfVxuICB9LFxuICBocGY6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIGNvbnN0IGhwZiA9IGF1ZGlvLmZpbHRlcnMuRmlsdGVyMTJCaXF1YWQoeyBpbnB1dDp0aGlzLCBtb2RlOjEsIGN1dG9mZjouMzUsIGlzU3RlcmVvOnRydWUgfSlcbiAgICAgIHRoaXMuZnguYWRkKCBocGYgKVxuICAgICAgdGhpcy5ocGYgPSBocGZcbiAgIH1cbiAgfSxcbiAgbHBmOiB7XG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICBjb25zdCBscGYgPSBhdWRpby5maWx0ZXJzLkZpbHRlcjI0TW9vZyh7IGlucHV0OnRoaXMsIG1vZGU6MSwgY3V0b2ZmOi4zNSwgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIGxwZiApXG4gICAgICB0aGlzLmxwZiA9IGxwZlxuICAgIH1cbiAgfSxcbiAgc2hvcnQ6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMua2ljay5kZWNheSA9IC44XG4gICAgICB0aGlzLnNuYXJlLmRlY2F5ID0gLjA1XG4gICAgICB0aGlzLmNsb3NlZEhhdC5kZWNheSA9IC4wNVxuICAgICAgdGhpcy5vcGVuSGF0LmRlY2F5ID0gLjJcbiAgICAgIHRoaXMuY293YmVsbC5kZWNheSA9IC4xXG4gICAgfVxuICB9LFxuICBsb25nOiB7XG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICB0aGlzLmtpY2suZGVjYXkgPSAuOTc1XG4gICAgICB0aGlzLnNuYXJlLmRlY2F5ID0gLjFcbiAgICAgIHRoaXMuY2xvc2VkSGF0LmRlY2F5ID0gLjFcbiAgICAgIHRoaXMub3BlbkhhdC5kZWNheSA9IC4yNVxuICAgIH1cbiAgfVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW9kZXJhdGU6IHtcbiAgICBmZWVkYmFjazogLjI1LFxuICAgIGZyZXF1ZW5jeTouNSxcbiAgICBvZmZzZXQ6LjFcbiAgfSxcblxuICBleHRyZW1lOiB7XG4gICAgZmVlZGJhY2s6Ljg1LFxuICAgIG9mZnNldDouMDUsXG4gICAgZnJlcXVlbmN5OjRcbiAgfSxcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgYmFzcyA6IHtcbiAgICBjbVJhdGlvOjEsXG4gICAgaW5kZXg6MyxcbiAgICBhdHRhY2s6MS8yNTYsXG4gICAgZGVjYXk6MS8xNixcbiAgICBvY3RhdmU6LTJcbiAgfSxcbiAgZGVlcGJhc3MgOiB7XG4gICAgY21SYXRpbzoxLFxuICAgIGluZGV4OjMsXG4gICAgYXR0YWNrOjEvMjU2LFxuICAgIGRlY2F5OjEvMixcbiAgICBvY3RhdmU6LTMsXG4gICAgZmVlZGJhY2s6LjAwNVxuICB9LFxuICBraWNrOntcbiAgICBhdHRhY2sgOiAxLzQwOTYsXG4gICAgaW5kZXggOiA1LFxuICAgIGNtUmF0aW8gOiA0LzMsXG4gICAgZGVjYXkgOiAxLzQsXG4gICAgb2N0YXZlIDogLTMsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJ1xuICB9LFxuXG4gIHBlcmM6e1xuICAgIGF0dGFjayA6IDEvNDA5NixcbiAgICBpbmRleCA6IC41LFxuICAgIGNtUmF0aW8gOiA0LzMsXG4gICAgZGVjYXkgOiAxLzgsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJyxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICBpZiggdGhpcy52b2ljZXMgJiYgdGhpcy52b2ljZXMubGVuZ3RoID4gMSApIHtcbiAgICAgICAgdGhpcy5zcHJlYWQoIC45OSApXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gICdiYXNzLmVsZWN0cm8nIDoge1xuICAgIGNtUmF0aW86MSxcbiAgICBpbmRleDozLFxuICAgIGF0dGFjazoxLzI1NixcbiAgICBkZWNheToxLzE2LFxuICAgIG9jdGF2ZTotMixcbiAgICBmaWx0ZXJNb2RlbDoyLFxuICAgIHNhdHVyYXRpb246MjAwLFxuICAgIFE6LjI1LFxuICAgIGN1dG9mZjouNjgzNVxuICB9LFxuXG4gIGdsb2NrZW5zcGllbCA6IHtcbiAgICBjbVJhdGlvXHQ6IDMuNTMwNyxcbiAgICBpbmRleCBcdDogMSxcbiAgICBhdHRhY2tcdDogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoIDEgKSxcbiAgICBkZWNheVx0OiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyggMTAwMCApLFxuICB9LFxuXG4gICdnbG9ja2Vuc3BpZWwuc2hvcnQnIDoge1xuICAgIGNtUmF0aW9cdDogMy41MzA3LFxuICAgIGluZGV4IFx0OiAxLFxuICAgIGF0dGFja1x0OiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyggMSApLFxuICAgIGRlY2F5XHQgIDogMS8xMixcbiAgICBvY3RhdmUgIDogMSxcbiAgICBnYWluICAgIDouMDUgXG4gIH0sXG5cbiAgZnJvZyA6IHsgLy9sanBcbiAgICBjbVJhdGlvOiAwLjEsXG4gICAgaW5kZXg6IDIuMCxcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCAzMDAgKSwgXG4gICAgZGVjYXk6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCA1IClcbiAgfSxcblxuICBnb25nIDoge1xuICAgIGNtUmF0aW86IDEuNCxcblx0ICBpbmRleDogLjk1LFxuXHQgIGF0dGFjazogMS8yNTYsXG5cdCAgZGVjYXk6IDIsXG5cdH0sXG5cbiAgZHJ1bSA6IHtcblx0ICBjbVJhdGlvOiAxLjQwMDA3LFxuXHQgIGluZGV4OiAyLFxuXHQgIGF0dGFjazogMS8yMDQ4LFxuICAgIGRlY2F5OiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxMDAwKSBcblx0fSxcblxuXHRkcnVtMjoge1xuXHRcdGNtUmF0aW86IDEgKyBNYXRoLnNxcnQoMiksXG5cdFx0aW5kZXg6IC4yLFxuXHRcdGF0dGFjazogMS8yNTYsXG5cdFx0ZGVjYXk6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKDIwKSBcbiAgfSxcblxuXHRicmFzcyA6IHtcbiAgICBtYXhWb2ljZXM6NCxcblx0ICBjbVJhdGlvIDogMSAvIDEuMDAwNyxcblx0XHRpbmRleFx0OiA1LFxuXHRcdGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoMTAwKSxcblx0XHRkZWNheVx0OiAxLFxuICAgIGdhaW46LjUsXG4gIH0sXG5cblx0Y2xhcmluZXQgOiB7XG5cdFx0Y21SYXRpb1x0OiAzIC8gMixcblx0XHRpbmRleFx0OiAxLjUsXG5cdFx0YXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyggNTAgKSwgXG5cdFx0ZGVjYXk6ICBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyggMjAwIClcbiAgfSxcblxuICBmdW4gOiB7XG4gICAgZGVjYXk6MS8yLFxuICAgIGZlZWRiYWNrOiAuMDAxNSxcbiAgICBnYWluOi4xXG4gIH0sXG5cbiAgY2hpcnA6IHtcblx0XHRhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCAxICksIFxuICAgIGluZGV4IDogMS4xNSxcbiAgICBnbGlkZSA6IDEsXG4gICAgZmVlZGJhY2sgOiAuNSxcbiAgICBjbVJhdGlvIDogMS41LFxuICAgIGRlY2F5IDogMS80LFxuICAgIG9jdGF2ZSA6IDEsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJ1xuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hvcnQ6IHtcbiAgICBkZWNheTouMDFcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZGVlcDoge1xuICAgIGZyZXF1ZW5jeTo1NSxcbiAgICBkZWNheTouOTYsXG4gIH0sXG5cbiAgdGlnaHQ6IHtcbiAgICBmcmVxdWVuY3k6ODAsIFxuICAgIGRlY2F5Oi44NSxcbiAgICB0b25lOi41XG4gIH0sXG5cbiAgbG9uZzoge1xuICAgIGZyZXF1ZW5jeTo4MCxcbiAgICBkZWNheTouOTc1LFxuICB9LFxuXG4gIGJvb206IHtcbiAgICBmcmVxdWVuY3k6NTUsXG4gICAgZGVjYXk6Ljk5LFxuICAgIHRvbmU6LjA1XG4gIH1cblxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAnc2hvcnQuZHJ5JyA6IHsgXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyguMjUpLCBcbiAgICBkZWNheTogMS8xMixcbiAgICBjdXRvZmY6LjMsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNdWx0OjNcbiAgfSxcblxuICBhcnB5IDoge1xuICAgIGFudGlhbGlhczp0cnVlLFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoLjUpLFxuICAgIGRlY2F5OiAxLzE2LCBcbiAgICBnYWluOjAuMixcbiAgICBjdXRvZmY6LjE1LFxuICAgIGZpbHRlck11bHQ6MSxcbiAgICBROi4zLFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTW9kZToxXG4gIH0sXG5cbiAgbGVhZCA6IHtcbiAgICBwcmVzZXRJbml0IDogZnVuY3Rpb24oIGF1ZGlvICkgeyB0aGlzLmZ4LnB1c2goIGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvNiwgZmVlZGJhY2s6LjY1IH0pICkgIH0sXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyguNSksXG4gICAgZGVjYXk6IDEvMiwgXG4gICAgb2N0YXZlMzowLFxuICAgIGN1dG9mZjoxLFxuICAgIGZpbHRlck11bHQ6Mi41LFxuICAgIFE6Ljk3NSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck1vZGU6MVxuICB9LFxuICAvLyBub3QgYXMgYnJpZ2h0IC8gbG91ZFxuICBsZWFkMiA6IHtcbiAgICBwcmVzZXRJbml0IDogZnVuY3Rpb24oIGF1ZGlvICkgeyB0aGlzLmZ4LnB1c2goIGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvNiwgZmVlZGJhY2s6LjY1IH0pICkgIH0sXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyguNSksXG4gICAgZGVjYXk6IDEvMiwgXG4gICAgb2N0YXZlMzowLFxuICAgIGN1dG9mZjoxLFxuICAgIGZpbHRlck11bHQ6Mi41LFxuICAgIFE6LjgsXG4gICAgZ2FpbjouMTc1LFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTW9kZToxXG4gIH0sXG5cbiAgZGlydHk6IHsgXG4gICAgZ2FpbjouMzI1LFxuICAgIGZpbHRlck1vZGVsOjIsXG4gICAgYXR0YWNrOjEvMjA0OCwgXG4gICAgZGVjYXk6MS80LCBcbiAgICBjdXRvZmY6MS41LCBcbiAgICBmaWx0ZXJNdWx0OjQsIFxuICAgIHNhdHVyYXRpb246MTAwMDAsIFxuICAgIFE6LjIyNSwgXG4gICAgZGV0dW5lMjotLjUwNSxcbiAgICBkZXR1bmUzOi0uNTA3NSxcbiAgICBvY3RhdmU6LTIsXG4gICAgd2F2ZWZvcm06J3B3bScsIFxuICAgIHB1bHNld2lkdGg6LjE1IFxuICB9LFxuXG4gIHdpbnNvbWUgOiB7XG4gICAgcHJlc2V0SW5pdCA6IGZ1bmN0aW9uKCBhdWRpbyApIHsgXG4gICAgICB0aGlzLmxmbyA9IGF1ZGlvLm9zY2lsbGF0b3JzLlNpbmUoeyBmcmVxdWVuY3k6MiwgZ2FpbjouMDc1IH0pXG4gICAgICB0aGlzLmxmby5jb25uZWN0KCB0aGlzLmN1dG9mZiApXG4gICAgICB0aGlzLmxmby5jb25uZWN0KCB0aGlzLmRldHVuZTIgKVxuICAgICAgdGhpcy5sZm8uY29ubmVjdCggdGhpcy5kZXR1bmUzIClcbiAgICB9LFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoMSksIFxuICAgIGRlY2F5OjEsXG4gICAgY3V0b2ZmOi4yLFxuICB9LFxuXG4gIHBsdWNrRWNobzoge1xuICAgIHByZXNldEluaXQgOiBmdW5jdGlvbiggYXVkaW8gKSB7IHRoaXMuZngucHVzaCggYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouNjUgfSkgKSAgfSxcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKC4xKSxcbiAgICBkZWNheTogMS8xNiwgXG4gICAgb2N0YXZlMzowLFxuICAgIGN1dG9mZjouMTUsXG4gICAgZmlsdGVyTXVsdDoxLFxuICAgIFE6LjUsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNb2RlOjEsXG4gICAgcGFuVm9pY2VzOnRydWVcbiAgfSxcblxuICBiYXNzUGFkIDogeyBcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKC4xKSxcbiAgICBkZWNheTogMixcdFxuICAgIG9jdGF2ZTotNCxcbiAgICBjdXRvZmY6IC4yMjUsXG4gICAgZmlsdGVyTXVsdDozLjUsXG4gICAgUTouNSxcbiAgICBkZXR1bmUyOjEuMDEyNSxcbiAgICBkZXR1bmUzOjEtLjAxMjVcbiAgfSxcblxuICB3YXJibGUgOiB7IFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoMSksXG4gICAgZGVjYXk6IDEvMixcdFxuICAgIG9jdGF2ZTogLTMsXG4gICAgb2N0YXZlMiA6IC0xLFxuICAgIGN1dG9mZjogLjgsXG4gICAgZmlsdGVyTXVsdDozLFxuICAgIFE6Ljc1LFxuICAgIGRldHVuZTI6LjAyNzUsXG4gICAgZGV0dW5lMzotLjAyNzVcbiAgfSwgXG4gIGRhcms6IHsgXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheTogMSxcdFxuICAgIG9jdGF2ZTogLTMsXG4gICAgb2N0YXZlMiA6IC0xLFxuICAgIGN1dG9mZjogMS41LFxuICAgIGZpbHRlck11bHQ6MyxcbiAgICBROi43NSxcbiAgICBkZXR1bmUyOi4wMTI1LFxuICAgIGRldHVuZTM6LS4wMTI1XG4gIH0sXG4gIGJhc3M6IHsgXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheTogMS80LFx0XG4gICAgb2N0YXZlOiAtMyxcbiAgICBjdXRvZmY6IC4zNSxcbiAgICBmaWx0ZXJNdWx0OjMsXG4gICAgUTouMTUsXG4gICAgZ2xpZGU6MTI1MCxcbiAgICB3YXZlZm9ybToncHdtJyxcbiAgICBwdWxzZXdpZHRoOi40NSxcbiAgICBkZXR1bmUyOi4wMDUsXG4gICAgZGV0dW5lMzotLjAwNVxuICB9LFxuICBiYXNzMiA6IHtcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKDEpLCBcbiAgICBkZWNheTpcdDEvNixcbiAgICBvY3RhdmU6IC0yLFxuICAgIG9jdGF2ZTIgOiAwLFxuICAgIG9jdGF2ZTMgOiAwLCAgICAgIFxuICAgIGN1dG9mZjogLjUsXG4gICAgZmlsdGVyTXVsdDoyLFxuICAgIFE6LjUsXG4gICAgZ2FpbjouMzVcbiAgfSxcbiAgXG4gIGVkZ3k6IHtcbiAgICBkZWNheToxLzgsXG4gICAgYXR0YWNrOjEvMTAyNCxcbiAgICBvY3RhdmU6IC0yLFxuICAgIG9jdGF2ZTI6IC0xLFxuICAgIGN1dG9mZjogLjUsXG4gICAgZmlsdGVyTXVsdDozLFxuICAgIFE6Ljc1LCBcbiAgICB3YXZlZm9ybToncHdtJywgXG4gICAgcHVsc2V3aWR0aDouMixcbiAgICBkZXR1bmUyOjAsXG4gICAgZ2FpbjouMlxuICB9LFxuXG4gIGVhc3kgOiB7XG4gICAgYXR0YWNrOiBhdWRpbz0+IGF1ZGlvLkNsb2NrLm1zKDEpLFxuICAgIGRlY2F5OjIsXG4gICAgY3V0b2ZmOi4zLFxuICAgIGdsaWRlOi45OTk1LFxuICB9LFxuICBcbiAgZWFzeWZ4IDoge1xuICAgIGF0dGFjazogYXVkaW89PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheToyLFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguYWRkKCBhdWRpby5lZmZlY3RzLkRlbGF5KCBDbG9jay50aW1lKDEvNiksIC4zKSApXG4gICAgfSxcbiAgICBjdXRvZmY6LjEyNSxcbiAgICBnbGlkZToxMDAwLFxuICAgIGRldHVuZTI6LjAwMSxcbiAgICBkZXR1bmUzOi0uMDAxLFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTXVsdDo0LFxuICAgIFE6LjUsXG4gIH0sXG4gIGNob3Jkczoge1xuICAgIGF0dGFjazogYXVkaW89PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheToxLzIsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5hZGQoIGF1ZGlvLmVmZmVjdHMuRGVsYXkoIENsb2NrLnRpbWUoMS82KSwgLjUpIClcbiAgICB9LFxuICAgIGFtcDouMyxcbiAgICBvY3RhdmUyOjAsXG4gICAgb2N0YXZlMzowLFxuICAgIGN1dG9mZjouNSxcbiAgICBnbGlkZTouOTk5NSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck11bHQ6MyxcbiAgICBROi43NSxcbiAgfSxcblxuICB3YW5kZXI6IHtcbiAgICBhdHRhY2s6IDEvMixcbiAgICBkZWNheTogIDIsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge30sXG4gICAgYW1wOi4yLFxuICAgIGRldHVuZTI6LjUwMSxcbiAgICBkZXR1bmUzOi0uNTAxLFxuICAgIGN1dG9mZjouMixcbiAgICBnbGlkZTo1MDAwLFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTXVsdDoxLjUsXG4gICAgUTouMjUsXG4gIH0sXG5cbiAgJ2Nob3Jkcy5zaG9ydCc6IHtcbiAgICBhdHRhY2s6IGF1ZGlvPT4gYXVkaW8uQ2xvY2subXMoMSksXG4gICAgZGVjYXk6MS84LFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgZGVsYXk6YXVkaW8uQ2xvY2sudGltZSgxLzgpLCBmZWVkYmFjazouNSwgd2V0ZHJ5Oi4yNSB9KSBcbiAgICAgIHRoaXMuZngucHVzaCggdGhpcy5kZWxheSApXG4gICAgfSxcbiAgICBhbXA6LjMsXG4gICAgb2N0YXZlMjowLFxuICAgIG9jdGF2ZTM6MCxcbiAgICBjdXRvZmY6LjM1LFxuICAgIGdsaWRlOjEsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNdWx0OjMsXG4gICAgUTouNSxcbiAgfSxcblxuICBqdW1wOiB7IFxuICAgIGRlY2F5OjEvMjA0OCwgXG4gICAgdXNlQURTUjp0cnVlLCBcbiAgICBzdXN0YWluOjEvNCwgXG4gICAgcmVsZWFzZToxLzEwMjQsICBcbiAgICBtYXhWb2ljZXM6MywgXG4gICAgY3V0b2ZmOjM1LCBcbiAgICBmaWx0ZXJNdWx0OjAsXG4gICAgZGV0dW5lMjouMDEsXG4gICAgZGV0dW5lMzotLjAxIFxuICB9LFxuXG4gIHNoaW55YmFzczI6IHtcbiAgICBROi4xMjUsXG4gICAgY3V0b2ZmOjM1LFxuICAgIHVzZUFEU1I6dHJ1ZSxcbiAgICBkZWNheToxLzEwLFxuICAgIHN1c3RhaW46MS80LFxuICAgIGZpbHRlck11bHQ6MCxcbiAgICByZWxlYXNlOjEvMTAyNCxcbiAgICBvY3RhdmU6LTMsXG4gICAgcGFuVm9pY2VzOnRydWVcbiAgfSxcbiAgc2hpbnliYXNzOiB7XG4gICAgUTouMTI1LFxuICAgIGN1dG9mZjo1LFxuICAgIHVzZUFEU1I6ZmFsc2UsXG4gICAgYXR0YWNrOjEvMTAyNCxcbiAgICBkZWNheToxLzEwLFxuICAgIGZpbHRlck11bHQ6MCxcbiAgICBvY3RhdmU6LTMsXG4gICAgcGFuVm9pY2VzOnRydWVcbiAgfSxcblxuICAnYmFzcy5tdXRlZCc6IHtcbiAgICBROi40NSxcbiAgICBjdXRvZmY6LjUsXG4gICAgdXNlQURTUjp0cnVlLFxuICAgIHNoYXBlOidleHBvbmVudGlhbCcsXG4gICAgZGVjYXk6MS84LFxuICAgIHN1c3RhaW46MS80LFxuICAgIHJlbGVhc2U6MS8xMDI0LFxuICAgIG9jdGF2ZTotMyxcbiAgICBwYW5Wb2ljZXM6dHJ1ZSxcbiAgICBmaWx0ZXJNdWx0Oi41XG4gIH0sXG4gICdiYXNzLnN0YWInOiB7XG4gICAgUTouMzUsXG4gICAgZGV0dW5lMjoxLjUsXG4gICAgZGV0dW5lMzouNSxcbiAgICBjdXRvZmY6LjUsXG4gICAgdXNlQURTUjp0cnVlLFxuICAgIHNoYXBlOidleHBvbmVudGlhbCcsXG4gICAgZGVjYXk6MS8xMCxcbiAgICBzdXN0YWluOjEvNCxcbiAgICByZWxlYXNlOjEvMTAyNCxcbiAgICBvY3RhdmU6LTMsXG4gICAgZmlsdGVyTXVsdDoxLjg1LFxuICAgIGdhaW46Ljc1XG4gIH0sXG4gIHNob3J0OiB7IFxuICAgIGF0dGFjazoxLzQwOTYsXG4gICAgZGVjYXk6MS8xNiwgXG4gICAgbWF4Vm9pY2VzOjMsIFxuICAgIGN1dG9mZjoxLjUsIFxuICAgIGZpbHRlck11bHQ6MCxcbiAgICB1c2VBRFNSOmZhbHNlLFxuICAgIGdhaW46LjVcbiAgfSxcblxuICBub2lzZToge1xuICAgIGRlY2F5OjEvMixcbiAgICBjdXRvZmY6LjMsXG4gICAgZ2xpZGU6MTAwMDAsXG4gICAgZGV0dW5lMzowLFxuICAgIGRldHVuZTI6MCxcbiAgICBmaWx0ZXJNdWx0OjAsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkgeyB0aGlzLmZ4LmFkZCggYXVkaW8uZWZmZWN0cy5HYWluKC4xKSwgYXVkaW8uZWZmZWN0cy5EZWxheSgxLzYsLjc1KSApIH1cbiAgfSxcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZHJ1bXM6IHsgXG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2sud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9oYXQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9zbmFyZS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL29wZW5oYXQud2F2J1xuICAgIF0sXG4gICAgcHJlc2V0SW5pdCgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gNFxuICAgIH1cbiAgfSxcbiAgdGVzdDoge1xuICAgIGZpbGVzOltcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvb3BlbmhhdC53YXYnXG4gICAgXSxcbiAgICBwcmVzZXRJbml0KCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAyXG4gICAgfVxuICB9LFxuICBiZWF0Ym94OiB7XG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvXmsud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L15wLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9edHNzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC84LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9hLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9iLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9kLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9kb3Qud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L2R1Zi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvZi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvay53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvaC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvbS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvbi53YXYnLFxuICAgIF0sXG4gICAgcHJlc2V0SW5pdCgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTRcbiAgICB9XG4gIH0sXG4gIGJsZWVwczoge1xuICAgIGZpbGVzOltcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA2M19fc3RhbXBlcmFkYW1fX2JsZWVwMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDY0X19zdGFtcGVyYWRhbV9fYmxlZXAyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjVfX3N0YW1wZXJhZGFtX19jbGFwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjZfX3N0YW1wZXJhZGFtX19jbGljay53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDY3X19zdGFtcGVyYWRhbV9fY2xpY2sxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjhfX3N0YW1wZXJhZGFtX19nMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDY5X19zdGFtcGVyYWRhbV9fZzIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3MF9fc3RhbXBlcmFkYW1fX2czLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNzFfX3N0YW1wZXJhZGFtX19nNC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDcyX19zdGFtcGVyYWRhbV9fZzUud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3M19fc3RhbXBlcmFkYW1fX2c2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNzRfX3N0YW1wZXJhZGFtX19nNy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDc1X19zdGFtcGVyYWRhbV9fZzgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3Nl9fc3RhbXBlcmFkYW1fX2c5LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNzdfX3N0YW1wZXJhZGFtX19nbGl0Y2gud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3OF9fc3RhbXBlcmFkYW1fX2hhdHQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3OV9fc3RhbXBlcmFkYW1fX2hpdC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDgwX19zdGFtcGVyYWRhbV9faGl0dC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDgxX19zdGFtcGVyYWRhbV9faHVtLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwODJfX3N0YW1wZXJhZGFtX19raWsud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA4M19fc3RhbXBlcmFkYW1fX3NuYXIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA4NF9fc3RhbXBlcmFkYW1fX3dhLndhdicsXG4gICAgXSxcbiAgICBwcmVzZXRJbml0KCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAyMlxuICAgIH1cbiAgfSxcbiAgY3I3MDMwOiB7XG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2NyNzAzMC82ODYwMl9fYmlyZGZsdV9fYm9uZ283MDMwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvY3I3MDMwLzY4NjAzX19iaXJkZmx1X19jbGF2ZTcwMzAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9jcjcwMzAvNjg2MDZfX2JpcmRmbHVfX2hhdGNsb3NlZDcwMzAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9jcjcwMzAvNjg2MDdfX2JpcmRmbHVfX2hhdG9wZW43MDMwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvY3I3MDMwLzY4NjA4X19iaXJkZmx1X19raWNrNzAzMC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2NyNzAzMC82ODYwOV9fYmlyZGZsdV9fc25hcmU3MDMwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvY3I3MDMwLzY4NjEwX19iaXJkZmx1X190b203MDMwLndhdicsXG4gICAgXSxcbiAgICBwcmVzZXRJbml0KCl7XG4gICAgICB0aGlzLmxlbmd0aCA9IDdcbiAgICB9XG4gIH0sXG4gIGtpY2tzOiB7XG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwMF9fbmV0ci1zaV9fa2ljay0zMi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwMV9fbmV0ci1zaV9fa2ljay0zMy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwMl9fbmV0ci1zaV9fa2ljay0yNy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwM19fbmV0ci1zaV9fa2ljay0yOC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwNF9fbmV0ci1zaV9fa2ljay0yNS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwNV9fbmV0ci1zaV9fa2ljay0yNi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwNl9fbmV0ci1zaV9fa2ljay0zMC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwN19fbmV0ci1zaV9fa2ljay0zMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwOF9fbmV0ci1zaV9fa2ljay0yOS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIwOV9fbmV0ci1zaV9fa2ljay0zLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjExX19uZXRyLXNpX19raWNrLTQyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjEyX19uZXRyLXNpX19raWNrLTQxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjEzX19uZXRyLXNpX19raWNrLTM1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE0X19uZXRyLXNpX19raWNrLTM0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE1X19uZXRyLXNpX19raWNrLTM3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE2X19uZXRyLXNpX19raWNrLTM2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE3X19uZXRyLXNpX19raWNrLTM5LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE4X19uZXRyLXNpX19raWNrLTM4LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjE5X19uZXRyLXNpX19raWNrLTQwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjIwX19uZXRyLXNpX19raWNrLTQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMjJfX25ldHItc2lfX2tpY2stODcud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMjNfX25ldHItc2lfX2tpY2stOS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyNF9fbmV0ci1zaV9fa2ljay04My53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyNV9fbmV0ci1zaV9fa2ljay04NC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyNl9fbmV0ci1zaV9fa2ljay04NS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyN19fbmV0ci1zaV9fa2ljay04Ni53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyOF9fbmV0ci1zaV9fa2ljay04LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI5X19uZXRyLXNpX19raWNrLTgwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjMwX19uZXRyLXNpX19raWNrLTgxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjMxX19uZXRyLXNpX19raWNrLTgyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjMyX19uZXRyLXNpX19raWNrLTIwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjMzX19uZXRyLXNpX19raWNrLTIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzRfX25ldHItc2lfX2tpY2stMTkud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzVfX25ldHItc2lfX2tpY2stMTgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzZfX25ldHItc2lfX2tpY2stMjQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzdfX25ldHItc2lfX2tpY2stMjMud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzhfX25ldHItc2lfX2tpY2stMjIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzlfX25ldHItc2lfX2tpY2stMjEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDBfX25ldHItc2lfX2tpY2stMjUtMi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0MV9fbmV0ci1zaV9fa2ljay0yNS0xLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQyX19uZXRyLXNpX19raWNrLTEyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQzX19uZXRyLXNpX19raWNrLTExLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQ0X19uZXRyLXNpX19raWNrLTEwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQ1X19uZXRyLXNpX19raWNrLTEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDZfX25ldHItc2lfX2tpY2stMTUud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDdfX25ldHItc2lfX2tpY2stMTQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDhfX25ldHItc2lfX2tpY2stMTQtMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0OV9fbmV0ci1zaV9fa2ljay0xMy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1MF9fbmV0ci1zaV9fa2ljay0xNy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1MV9fbmV0ci1zaV9fa2ljay0xNi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1Ml9fbmV0ci1zaV9fa2ljay02Ny53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1M19fbmV0ci1zaV9fa2ljay02OC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1NF9fbmV0ci1zaV9fa2ljay02NS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1NV9fbmV0ci1zaV9fa2ljay02Ni53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1Nl9fbmV0ci1zaV9fa2ljay02My53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1N19fbmV0ci1zaV9fa2ljay02NC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1OF9fbmV0ci1zaV9fa2ljay02MS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI1OV9fbmV0ci1zaV9fa2ljay02MnMud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNjBfX25ldHItc2lfX2tpY2stNjkud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNjFfX25ldHItc2lfX2tpY2stNy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2Ml9fbmV0ci1zaV9fa2ljay03NS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2M19fbmV0ci1zaV9fa2ljay03NC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2NF9fbmV0ci1zaV9fa2ljay03Ny53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2NV9fbmV0ci1zaV9fa2ljay03Ni53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2Nl9fbmV0ci1zaV9fa2ljay03MS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2N19fbmV0ci1zaV9fa2ljay03MC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2OF9fbmV0ci1zaV9fa2ljay03My53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2OV9fbmV0ci1zaV9fa2ljay03Mi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3MF9fbmV0ci1zaV9fa2ljay03OS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3MV9fbmV0ci1zaV9fa2ljay03OC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3Ml9fbmV0ci1zaV9fa2ljay00My53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3M19fbmV0ci1zaV9fa2ljay00NC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3NF9fbmV0ci1zaV9fa2ljay00NS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3NV9fbmV0ci1zaV9fa2ljay00Ni53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3Nl9fbmV0ci1zaV9fa2ljay00Ny53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3N19fbmV0ci1zaV9fa2ljay00OC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3OF9fbmV0ci1zaV9fa2ljay00OS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI3OV9fbmV0ci1zaV9fa2ljay01LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjgwX19uZXRyLXNpX19raWNrLTUwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjgxX19uZXRyLXNpX19raWNrLTUxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjgyX19uZXRyLXNpX19raWNrLTYwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjgzX19uZXRyLXNpX19raWNrLTYud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODRfX25ldHItc2lfX2tpY2stNTkud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODVfX25ldHItc2lfX2tpY2stNTgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODZfX25ldHItc2lfX2tpY2stNTcud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODdfX25ldHItc2lfX2tpY2stNTYud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODhfX25ldHItc2lfX2tpY2stNTUud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODlfX25ldHItc2lfX2tpY2stNTQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyOTBfX25ldHItc2lfX2tpY2stNTMud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyOTFfX25ldHItc2lfX2tpY2stNTIud2F2JyxcbiAgICBdLFxuICAgIHByZXNldEluaXQoKSB7IHRoaXMubGVuZ3RoID0gOTAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAnc3BhY2UnOiB7XG4gICAgcm9vbVNpemU6Ljk4NSwgXG4gICAgZHJ5OjEgXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIHNuYXBweToge1xuICAgIGRlY2F5Oi4xMjUsXG4gICAgc25hcHB5OjEuNSxcbiAgICB0dW5lOi4xXG4gIH0sXG5cbiAgZHVsbDoge1xuICAgIHNuYXBweTouMTUsXG4gICAgZGVjYXk6LjE1LFxuICAgIHR1bmU6LS4xXG4gIH1cblxufVxuIiwiIGNvbnN0IG5hbWVzID0gW1xuICAgIFwiQWNvdXN0aWMgR3JhbmQgUGlhbm9cIixcbiAgICBcIkJyaWdodCBBY291c3RpYyBQaWFub1wiLFxuICAgIFwiRWxlY3RyaWMgR3JhbmQgUGlhbm9cIixcbiAgICBcIkhvbmt5LXRvbmsgUGlhbm9cIixcbiAgICBcIkVsZWN0cmljIFBpYW5vIDFcIixcbiAgICBcIkVsZWN0cmljIFBpYW5vIDJcIixcbiAgICBcIkhhcnBzaWNob3JkXCIsXG4gICAgXCJDbGF2aVwiLFxuICAgIFwiQ2VsZXN0YVwiLFxuICAgIFwiR2xvY2tlbnNwaWVsXCIsXG4gICAgXCJNdXNpYyBCb3hcIixcbiAgICBcIlZpYnJhcGhvbmVcIixcbiAgICBcIk1hcmltYmFcIixcbiAgICBcIlh5bG9waG9uZVwiLFxuICAgIFwiVHVidWxhciBCZWxsc1wiLFxuICAgIFwiRHVsY2ltZXJcIixcbiAgICBcIkRyYXdiYXIgT3JnYW5cIixcbiAgICBcIlBlcmN1c3NpdmUgT3JnYW5cIixcbiAgICBcIlJvY2sgT3JnYW5cIixcbiAgICBcIkNodXJjaCBPcmdhblwiLFxuICAgIFwiUmVlZCBPcmdhblwiLFxuICAgIFwiQWNjb3JkaW9uXCIsXG4gICAgXCJIYXJtb25pY2FcIixcbiAgICBcIlRhbmdvIEFjY29yZGlvblwiLFxuICAgIFwiQWNvdXN0aWMgR3VpdGFyIChueWxvbilcIixcbiAgICBcIkFjb3VzdGljIEd1aXRhciAoc3RlZWwpXCIsXG4gICAgXCJFbGVjdHJpYyBHdWl0YXIgKGphenopXCIsXG4gICAgXCJFbGVjdHJpYyBHdWl0YXIgKGNsZWFuKVwiLFxuICAgIFwiRWxlY3RyaWMgR3VpdGFyIChtdXRlZClcIixcbiAgICBcIk92ZXJkcml2ZW4gR3VpdGFyXCIsXG4gICAgXCJEaXN0b3J0aW9uIEd1aXRhclwiLFxuICAgIFwiR3VpdGFyIGhhcm1vbmljc1wiLFxuICAgIFwiQWNvdXN0aWMgQmFzc1wiLFxuICAgIFwiRWxlY3RyaWMgQmFzcyAoZmluZ2VyKVwiLFxuICAgIFwiRWxlY3RyaWMgQmFzcyAocGljaylcIixcbiAgICBcIkZyZXRsZXNzIEJhc3NcIixcbiAgICBcIlNsYXAgQmFzcyAxXCIsXG4gICAgXCJTbGFwIEJhc3MgMlwiLFxuICAgIFwiU3ludGggQmFzcyAxXCIsXG4gICAgXCJTeW50aCBCYXNzIDJcIixcbiAgICBcIlZpb2xpblwiLFxuICAgIFwiVmlvbGFcIixcbiAgICBcIkNlbGxvXCIsXG4gICAgXCJDb250cmFiYXNzXCIsXG4gICAgXCJUcmVtb2xvIFN0cmluZ3NcIixcbiAgICBcIlBpenppY2F0byBTdHJpbmdzXCIsXG4gICAgXCJPcmNoZXN0cmFsIEhhcnBcIixcbiAgICBcIlRpbXBhbmlcIixcbiAgICBcIlN0cmluZyBFbnNlbWJsZSAxXCIsXG4gICAgXCJTdHJpbmcgRW5zZW1ibGUgMlwiLFxuICAgIFwiU3ludGhTdHJpbmdzIDFcIixcbiAgICBcIlN5bnRoU3RyaW5ncyAyXCIsXG4gICAgXCJDaG9pciBBYWhzXCIsXG4gICAgXCJWb2ljZSBPb2hzXCIsXG4gICAgXCJTeW50aCBWb2ljZVwiLFxuICAgIFwiT3JjaGVzdHJhIEhpdFwiLFxuICAgIFwiVHJ1bXBldFwiLFxuICAgIFwiVHJvbWJvbmVcIixcbiAgICBcIlR1YmFcIixcbiAgICBcIk11dGVkIFRydW1wZXRcIixcbiAgICBcIkZyZW5jaCBIb3JuXCIsXG4gICAgXCJCcmFzcyBTZWN0aW9uXCIsXG4gICAgXCJTeW50aEJyYXNzIDFcIixcbiAgICBcIlN5bnRoQnJhc3MgMlwiLFxuICAgIFwiU29wcmFubyBTYXhcIixcbiAgICBcIkFsdG8gU2F4XCIsXG4gICAgXCJUZW5vciBTYXhcIixcbiAgICBcIkJhcml0b25lIFNheFwiLFxuICAgIFwiT2JvZVwiLFxuICAgIFwiRW5nbGlzaCBIb3JuXCIsXG4gICAgXCJCYXNzb29uXCIsXG4gICAgXCJDbGFyaW5ldFwiLFxuICAgIFwiUGljY29sb1wiLFxuICAgIFwiRmx1dGVcIixcbiAgICBcIlJlY29yZGVyXCIsXG4gICAgXCJQYW4gRmx1dGVcIixcbiAgICBcIkJsb3duIEJvdHRsZVwiLFxuICAgIFwiU2hha3VoYWNoaVwiLFxuICAgIFwiV2hpc3RsZVwiLFxuICAgIFwiT2NhcmluYVwiLFxuICAgIFwiTGVhZCAxIChzcXVhcmUpXCIsXG4gICAgXCJMZWFkIDIgKHNhd3Rvb3RoKVwiLFxuICAgIFwiTGVhZCAzIChjYWxsaW9wZSlcIixcbiAgICBcIkxlYWQgNCAoY2hpZmYpXCIsXG4gICAgXCJMZWFkIDUgKGNoYXJhbmcpXCIsXG4gICAgXCJMZWFkIDYgKHZvaWNlKVwiLFxuICAgIFwiTGVhZCA3IChmaWZ0aHMpXCIsXG4gICAgXCJMZWFkIDggKGJhc3MgKyBsZWFkKVwiLFxuICAgIFwiUGFkIDEgKG5ldyBhZ2UpXCIsXG4gICAgXCJQYWQgMiAod2FybSlcIixcbiAgICBcIlBhZCAzIChwb2x5c3ludGgpXCIsXG4gICAgXCJQYWQgNCAoY2hvaXIpXCIsXG4gICAgXCJQYWQgNSAoYm93ZWQpXCIsXG4gICAgXCJQYWQgNiAobWV0YWxsaWMpXCIsXG4gICAgXCJQYWQgNyAoaGFsbylcIixcbiAgICBcIlBhZCA4IChzd2VlcClcIixcbiAgICBcIkZYIDEgKHJhaW4pXCIsXG4gICAgXCJGWCAyIChzb3VuZHRyYWNrKVwiLFxuICAgIFwiRlggMyAoY3J5c3RhbClcIixcbiAgICBcIkZYIDQgKGF0bW9zcGhlcmUpXCIsXG4gICAgXCJGWCA1IChicmlnaHRuZXNzKVwiLFxuICAgIFwiRlggNiAoZ29ibGlucylcIixcbiAgICBcIkZYIDcgKGVjaG9lcylcIixcbiAgICBcIkZYIDggKHNjaS1maSlcIixcbiAgICBcIlNpdGFyXCIsXG4gICAgXCJCYW5qb1wiLFxuICAgIFwiU2hhbWlzZW5cIixcbiAgICBcIktvdG9cIixcbiAgICBcIkthbGltYmFcIixcbiAgICBcIkJhZyBwaXBlXCIsXG4gICAgXCJGaWRkbGVcIixcbiAgICBcIlNoYW5haVwiLFxuICAgIFwiVGlua2xlIEJlbGxcIixcbiAgICBcIkFnb2dvXCIsXG4gICAgXCJTdGVlbCBEcnVtc1wiLFxuICAgIFwiV29vZGJsb2NrXCIsXG4gICAgXCJUYWlrbyBEcnVtXCIsXG4gICAgXCJNZWxvZGljIFRvbVwiLFxuICAgIFwiU3ludGggRHJ1bVwiLFxuICAgIFwiUmV2ZXJzZSBDeW1iYWxcIixcbiAgICBcIkd1aXRhciBGcmV0IE5vaXNlXCIsXG4gICAgXCJCcmVhdGggTm9pc2VcIixcbiAgICBcIlNlYXNob3JlXCIsXG4gICAgXCJCaXJkIFR3ZWV0XCIsXG4gICAgXCJUZWxlcGhvbmUgUmluZ1wiLFxuICAgIFwiSGVsaWNvcHRlclwiLFxuICAgIFwiQXBwbGF1c2VcIixcbiAgICBcIkd1bnNob3RcIlxuICBdXG5cbm1vZHVsZS5leHBvcnRzID0ge31cblxuZm9yKCBsZXQgbmFtZSBvZiBuYW1lcyApIHtcbiAgbW9kdWxlLmV4cG9ydHNbIG5hbWUgXSA9IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbywgcHJvcHMgKSB7XG4gICAgICB0aGlzLmxvYWQoIG5hbWVzLmluZGV4T2YoIG5hbWUgKSwgcHJvcHMgPT09IHVuZGVmaW5lZCA/IDAgOiBwcm9wcy5iYW5rIHx8IDAgKVxuICAgIH1cbiAgfVxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBhY2lkQmFzczoge1xuICAgIFE6LjksXG4gICAgZmlsdGVyTW9kZWw6MixcbiAgICBmaWx0ZXJNdWx0OjQsXG4gICAgY3V0b2ZmOjEuMjUsXG4gICAgc2F0dXJhdGlvbjozLjUsXG4gICAgYXR0YWNrOjEvODE5MixcbiAgICBkZWNheToxLzEwLFxuICAgIG9jdGF2ZTotMyxcbiAgICBnbGlkZToyMDAwLFxuICAgIGRlc2NyaXB0aW9uOmBBIHNhd3Rvb3RoIGZlZWRpbmcgYSBUQjMwMy1zdHlsZSBsb3dwYXNzIGZpbHRlciwgd2l0aCBoaWdoIFEgc2V0dGluZ3MgYW5kIGEgc2hvcnQgZW52ZWxvcGUuYFxuICB9LFxuXG4gIGFjaWRCYXNzMjoge1xuICAgIFE6LjcsXG4gICAgZmlsdGVyTW9kZWw6MixcbiAgICBmaWx0ZXJNdWx0OjMuNSxcbiAgICBjdXRvZmY6LjUsXG4gICAgc2F0dXJhdGlvbjoxMCxcbiAgICBhdHRhY2s6MS84MTkyLFxuICAgIGRlY2F5OjEvMTAsXG4gICAgb2N0YXZlOi0yLFxuICAgIGdsaWRlOjEwMFxuICB9LFxuXG4gICdiYXNzLmhvbGxvdyc6IHtcbiAgICBROi4yLFxuICAgIGZpbHRlck1vZGVsOjIsXG4gICAgZmlsdGVyTXVsdDo0LFxuICAgIGN1dG9mZjoxLjI1LFxuICAgIHNhdHVyYXRpb246MjAsXG4gICAgYXR0YWNrOjEvODE5MixcbiAgICBkZWNheToxLzQsXG4gICAgb2N0YXZlOi0zLFxuICAgIGdsaWRlOjEwMDBcbiAgfSxcblxuICAnYmxlZXAuZHJ5JzogeyBcbiAgICBhdHRhY2s6MS8yNTYsIGRlY2F5OjEvMzIsIFxuICAgIHdhdmVmb3JtOidzaW5lJyBcbiAgfSxcbiAgJ2JsZWVwJzogeyBcbiAgICBhdHRhY2s6MS8yNTYsIGRlY2F5OjEvMzIsIFxuICAgIHdhdmVmb3JtOidzaW5lJyBcbiAgfSxcblxuICAnYmxlZXAuZWNobyc6IHsgXG4gICAgd2F2ZWZvcm06J3NpbmUnLCBcbiAgICBhdHRhY2s6MS8yNTYsIGRlY2F5OjEvMzIsIFxuICAgIGdhaW46LjI1LFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZngucHVzaCggYXVkaW8uZWZmZWN0cy5EZWxheSh7IGZlZWRiYWNrOi41LCB0aW1lOjEvMTIgfSkgKVxuICAgIH1cbiAgfSxcblxuICBzaGltbWVyOiB7XG4gICAgYXR0YWNrOjEvMTI4LCBkZWNheToyLFxuICAgIHdhdmVmb3JtOidwd20nLFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgY3V0b2ZmOjEsXG4gICAgZmlsdGVyTXVsdDoxLFxuICAgIFE6LjYsXG4gICAgbWF4Vm9pY2VzOjMsXG4gICAgZ2FpbjouMSxcbiAgICBhbnRpYWxpYXM6ZmFsc2UsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5hZGQoIGF1ZGlvLmVmZmVjdHMuQ2hvcnVzKCd3YXJibHknKSApXG4gICAgICB0aGlzLnB3bW9kID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5tdWwoIGF1ZGlvLkdlbi51Z2Vucy5jeWNsZSg4KSwgLjI3NSApIClcbiAgICAgIHRoaXMucHdtb2QuY29ubmVjdCggdGhpcy5wdWxzZXdpZHRoIClcbiAgICB9XG4gIH0sXG5cbiAgc3RyaW5nUGFkOiB7XG4gICAgYXR0YWNrOjEvMiwgZGVjYXk6MS41LCBnYWluOi4wMTUsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5jaG9ydXMgPSBhdWRpby5lZmZlY3RzLkNob3J1cygnbHVzaCcpXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5jaG9ydXMgIClcbiAgICB9XG4gIH0sXG5cbiAgY3J5OiB7XG4gICAgYXR0YWNrOjEvMiwgZGVjYXk6MS41LCBnYWluOi4wNDUsXG4gICAgcGFuVm9pY2VzOnRydWUsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5jaG9ydXMgPSBhdWRpby5lZmZlY3RzLkNob3J1cygnbHVzaCcsIHsgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuY2hvcnVzICApXG4gICAgICB0aGlzLmJpdENydXNoZXIgPSBhdWRpby5lZmZlY3RzLkJpdENydXNoZXIoeyBiaXREZXB0aDouNSwgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuYml0Q3J1c2hlciApXG4gICAgICAvLy8vIGdlbiggLjUgKyBjeWNsZSggYnRvZigxNikgKSAqIC4zNVxuICAgICAgdGhpcy5zcm1vZCA9IGF1ZGlvLkdlbi5tYWtlKCBhdWRpby5HZW4udWdlbnMuYWRkKCAuNSwgYXVkaW8uR2VuLnVnZW5zLm11bCggYXVkaW8uR2VuLnVnZW5zLmN5Y2xlKC4xMjUvMiksIC4zNSApICkgKVxuICAgICAgdGhpcy5iaXRDcnVzaGVyLnNhbXBsZVJhdGUgPSB0aGlzLnNybW9kXG4gICAgICB0aGlzLmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouNzUgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmRlbGF5IClcbiAgICB9XG4gIH0sXG5cbiAgYnJhc3M6IHtcbiAgICBhdHRhY2s6MS82LCBkZWNheToxLjUsIGdhaW46LjA1LFxuICAgIGZpbHRlck1vZGVsOjEsIFE6LjU1NzUsIGN1dG9mZjoyLFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguYWRkKCBhdWRpby5lZmZlY3RzLkNob3J1cygnbHVzaCcpIClcbiAgICAgIHRoaXMuY2hvcnVzID0gdGhpcy5meFswXVxuICAgIH1cbiAgfSxcblxuICAnYnJhc3Muc2hvcnQnOntcbiAgICBnYWluOi43NSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGFudGlhbGlhczp0cnVlLFxuICAgIGF0dGFjazoxLzMyLFxuICAgIGRlY2F5OjEvMTYsXG4gICAgZmlsdGVyTXVsdDozLFxuICAgIGN1dG9mZjouMTc1LFxuICAgIFE6LjZcbiAgfSxcblxuICAncHdtLnNxdWVhayc6e1xuICAgIHdhdmVmb3JtOidwd20nLFxuICAgIGF0dGFjazoxLzQwOTYsXG4gICAgZGVjYXk6MS8xNixcbiAgICBROi44LFxuICAgIGN1dG9mZjouNjUsXG4gICAgc2F0dXJhdGlvbjo1LFxuICAgIGZpbHRlck1vZGVsOjIsXG4gICAgZ2xpZGU6NTAwXG4gIH0sXG5cbiAgJ3B3bS5zaG9ydCc6e1xuICAgIGF0dGFjazoxLzEwMjQsXG4gICAgZGVjYXk6MS84LFxuICAgIGFudGlhbGlhczp0cnVlLFxuICAgIHdhdmVmb3JtOidwd20nXG4gIH0sXG5cbiAgY2hpcnA6IHsgZmlsdGVyTW9kZWw6MiwgY3V0b2ZmOi4zMjUsIGRlY2F5OjEvMTYgfSwgXG5cbiAgJ3NxdWFyZS5wZXJjJzogeyBcbiAgICB3YXZlZm9ybTonc3F1YXJlJywgXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJywgXG4gICAgYW50aWFsaWFzOnRydWUsIFxuICAgIGZpbHRlck1vZGVsOjIsIFxuICAgIGN1dG9mZjouMjUsIFxuICAgIGRlY2F5OjEvOCxcbiAgICBwYW5Wb2ljZXM6dHJ1ZVxuICB9LFxuXG4gICdzcXVhcmUucGVyYy5sb25nJzogeyBcbiAgICB3YXZlZm9ybTonc3F1YXJlJywgXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJywgXG4gICAgYW50aWFsaWFzOnRydWUsIFxuICAgIGZpbHRlck1vZGVsOjIsIFxuICAgIGN1dG9mZjouMjUsIFxuICAgIGRlY2F5OjIsXG4gICAgcGFuVm9pY2VzOnRydWVcbiAgfSxcblxuICByaG9kZXM6e1xuICAgIHdhdmVmb3JtOidzaW5lJyxcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMudHJlbW9sbyA9IGF1ZGlvLmVmZmVjdHMuVHJlbW9sbygpXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy50cmVtb2xvIClcbiAgICB9LFxuICAgIGRlY2F5OjQsXG4gICAgZ2FpbjouMTI1LFxuICAgIHNoYXBlOidleHBvbmVudGlhbCdcbiAgfSxcblxuICBibGFuazoge1xuICAgIGZpbHRlck1vZGVsOjAsXG4gICAgd2F2ZWZvcm06J3NpbmUnLFxuICAgIGFudGlhbGlhczpmYWxzZVxuICB9XG59XG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3Qgc2VyaWFsaXplID0gcmVxdWlyZSggJ3NlcmlhbGl6ZS1qYXZhc2NyaXB0JyApXG5jb25zdCBUdW5lICAgICAgPSByZXF1aXJlKCAnLi9leHRlcm5hbC90dW5lLWFwaS1vbmx5LmpzJyApXG5cbmxldCBHaWJiZXIgPSBudWxsXG5cbmNvbnN0IFRoZW9yeSA9IHtcbiAgLy8gbmVlZGVkIHRvIGZvcmNlIGxpYnJhcnkgdG8gYmUgc2VyaWFsaXplZCBmb3IgdHJhbnNwb3J0IHRvIFxuICAvLyB3b3JrbGV0IHByb2Nlc3NvciwgbXVzdCB1c2Uga2V5OmZ1bmN0aW9uKCkge30gZm9ybWF0XG4gIC8vIGZvciBtZXRob2RzIGZvciBzZXJpYWxpemUgdG8gd29ya1xuICBfX1R1bmU6VHVuZSxcblxuICBUdW5lOm51bGwsXG4gIGlkOm51bGwsXG4gIHR5cGU6ICdBdWRpbycsXG4gIG5vZ2liYmVyaXNoOnRydWUsXG4gIHF1YWxpdHk6J21pbm9yJyxcbiAgYmFzZU51bWJlcjo2MCxcbiAgX190dW5pbmc6J2V0JyxcbiAgX19tb2RlOiAnYWVvbGlhbicsXG4gIF9fcm9vdDo0NDAsXG4gIF9fb2Zmc2V0OjAsXG4gIF9fZGVncmVlOidpJyxcbiAgX19sb2FkaW5nUHJlZml4Oidqcy9leHRlcm5hbC90dW5lLmpzb24vJywgXG4gIF9fdHVuaW5nczp7XG4gICAgZXQ6IHtcbiAgICAgIHJvb3Q6JzYwJyxcbiAgICAgIG1vZGU6J2Fic29sdXRlJyxcbiAgICAgIGZyZXF1ZW5jaWVzOltcbiAgICAgICAgMjYxLjYyNTU4LFxuICAgICAgICAyNzcuMTgyNjE3LFxuICAgICAgICAyOTMuNjY0NzY0LFxuICAgICAgICAzMTEuMTI2OTg0LFxuICAgICAgICAzMjkuNjI3NTYzLFxuICAgICAgICAzNDkuMjI4MjQxLFxuICAgICAgICAzNjkuOTk0NDE1LFxuICAgICAgICAzOTEuOTk1NDIyLFxuICAgICAgICA0MTUuMzA0Njg4LFxuICAgICAgICA0NDAsXG4gICAgICAgIDQ2Ni4xNjM3NTcsXG4gICAgICAgIDQ5My44ODMzMDEsXG4gICAgICAgIDUyMy4yNTEwODM3MjczNjNcbiAgICAgIF0sXG4gICAgICBkZXNjcmlwdGlvbjonZXF1YWwgdGVtcGVyZWQgKGVkbyknXG4gICAgfVxuICB9LCAgXG5cbiAgbW9kZXM6IHtcbiAgICBpb25pYW46ICAgICBbMCwyLDQsNSw3LDksMTFdLFxuICAgIGRvcmlhbjogICAgIFswLDIsMyw1LDcsOSwxMF0sXG4gICAgcGhyeWdpYW46ICAgWzAsMSwzLDUsNyw4LDEwXSxcbiAgICBseWRpYW46ICAgICBbMCwyLDQsNiw3LDksMTFdLFxuICAgIG1peG9seWRpYW46IFswLDIsNCw1LDcsOSwxMF0sXG4gICAgYWVvbGlhbjogICAgWzAsMiwzLDUsNyw4LDEwXSxcbiAgICBsb2NyaWFuOiAgICBbMCwxLDMsNSw2LDgsMTBdLFxuICAgIG1lbG9kaWNtaW5vcjpbMCwyLDMsNSw3LDgsMTFdLFxuICAgIHdob2xlSGFsZjogIFswLDIsMyw1LDYsOCw5LDExXSxcbiAgICBoYWxmV2hvbGU6ICBbMCwxLDMsNCw2LDcsOSwxMF0sXG4gICAgY2hyb21hdGljOiAgWzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTFdLFxuICB9LFxuXG4gIHN0b3JlOmZ1bmN0aW9uKCkgeyBcbiAgICBHaWJiZXJpc2guVGhlb3J5ID0gdGhpc1xuXG4gICAgdGhpcy5UdW5lLlR1bmluZ0xpc3QgPSB0aGlzLl9fdHVuaW5nc1xuXG4gICAgdGhpcy5pbml0UHJvcGVydGllcygpXG4gIH0sXG5cbiAgc2V0dXAoIHR1bmluZz0nZXQnLCBtb2RlPSdhZW9saWFuJyApIHtcbiAgICB0aGlzLnR1bmluZyA9IHR1bmluZ1xuICAgIHRoaXMubW9kZSA9IG1vZGVcbiAgfSwgXG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0dWFydG1lbW8vMzc2NjQ0OVxuICBfX25vdGVUb0ZyZXEoIG5vdGUgKSB7XG4gICAgbm90ZSA9IG5vdGUudG9VcHBlckNhc2UoKSBcblxuICAgIGxldCBub3RlcyA9IFsnQScsICdBIycsICdCJywgJ0MnLCAnQyMnLCAnRCcsICdEIycsICdFJywgJ0YnLCAnRiMnLCAnRycsICdHIyddLFxuICAgICAgICBvY3RhdmUsXG4gICAgICAgIGtleU51bWJlclxuXG4gICAgaWYgKG5vdGUubGVuZ3RoID09PSAzKSB7XG4gICAgICBvY3RhdmUgPSBub3RlLmNoYXJBdCgyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvY3RhdmUgPSBub3RlLmNoYXJBdCgxKVxuICAgIH1cbiAgICBrZXlOdW1iZXIgPSBub3Rlcy5pbmRleE9mKG5vdGUuc2xpY2UoMCwgLTEpKVxuICAgIGlmIChrZXlOdW1iZXIgPCAzKSB7XG4gICAgICBrZXlOdW1iZXIgPSBrZXlOdW1iZXIgKyAxMiArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGtleU51bWJlciA9IGtleU51bWJlciArICgob2N0YXZlIC0gMSkgKiAxMikgKyAxXG4gICAgfVxuXG4gICAgcmV0dXJuIDQ0MCAqIE1hdGgucG93KDIsIChrZXlOdW1iZXItIDQ5KSAvIDEyKVxuICB9LFxuXG4gIGRlbGV0ZVByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgZGVsZXRlIHRoaXMuX19yb290XG4gICAgICBkZWxldGUgdGhpcy5fX3R1bmluZ1xuICAgICAgZGVsZXRlIHRoaXMuX19tb2RlXG4gICAgICBkZWxldGUgdGhpcy5fX29mZnNldFxuICAgICAgZGVsZXRlIHRoaXMuX19kZWdyZWVcblxuICAgICAgVGhlb3J5Lm1hcmt1cCA9IHtcbiAgICAgICAgdGV4dE1hcmtlcnMgOiB7fSxcbiAgICAgICAgY3NzQ2xhc3Nlczoge31cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX3Jvb3QgPSA0NDBcbiAgICAgIHRoaXMuX190dW5pbmcgPSAnZXQnXG4gICAgICB0aGlzLl9fb2Zmc2V0ID0gMFxuICAgICAgdGhpcy5fX2RlZ3JlZSA9ICdpJ1xuICAgICAgdGhpcy5fX21vZGUgPSAnYWVvbGlhbidcbiAgICB9XG4gIH0sXG5cbiAgaW5pdFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgR2liYmVyLmNyZWF0ZVByb3BlcnR5KCBcbiAgICAgICAgdGhpcywgJ3Jvb3QnLCA0NDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgVGhlb3J5Ll9fcm9vdC52YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICBUaGVvcnkucm9vdCA9IFRoZW9yeS5fX25vdGVUb0ZyZXEoIFRoZW9yeS5fX3Jvb3QudmFsdWUgKVxuICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAxXG4gICAgICApXG5cbiAgICAgIEdpYmJlci5jcmVhdGVQcm9wZXJ0eSggXG4gICAgICAgIHRoaXMsICd0dW5pbmcnLCAnZXQnLCBcbiAgICAgICAgZnVuY3Rpb24oKSB7IC8vIFhYWCB3aHkgZG9lc24ndCB0aGlzIHdvcms/Pz8gZHVwbGljYXRlZCBiZWxvdy4uLiBcbiAgICAgICAgICB0aGlzLmxvYWRTY2FsZSggdGhpcy5fX3R1bmluZy52YWx1ZSApIFxuICAgICAgICB9LFxuICAgICAgICAxXG4gICAgICApXG5cbiAgICAgIEdpYmJlci5jcmVhdGVQcm9wZXJ0eSggdGhpcywgJ21vZGUnLCAnYWVvbGlhbicsIG51bGwsIDAgKVxuICAgICAgR2liYmVyLmNyZWF0ZVByb3BlcnR5KCB0aGlzLCAnb2Zmc2V0JywgMCwgbnVsbCwgMCApXG4gICAgICBHaWJiZXIuY3JlYXRlUHJvcGVydHkoIHRoaXMsICdkZWdyZWUnLCAnaScsIG51bGwsIDAgKVxuXG4gICAgICAvL3NldFRpbWVvdXQoICgpPT4gVGhlb3J5LnR1bmluZyA9ICdldCcsIDI1MCApXG4gICAgICB0aGlzLnR1bmluZyA9ICdldCdcbiAgICAgIC8vdGhpcy5sb2FkU2NhbGUoJ2V0JylcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuX19pbml0RGVncmVlcygpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Jvb3QnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuX19yb290IH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2PT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19ub3RlVG9GcmVxKCB2IClcbiAgICAgICAgICB9IFxuICAgICAgICAgIHRoaXMuX19yb290ID0gdlxuICAgICAgICAgIHRoaXMuVHVuZS50b25pY2l6ZSggdGhpcy5fX3Jvb3QgKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICd0dW5pbmcnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuX190dW5pbmcgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICB0aGlzLl9fdHVuaW5nID0gdlxuICAgICAgICAgIC8vdGhpcy5sb2FkU2NhbGUoIHYgKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdtb2RlJywge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gdGhpcy5fX21vZGUgfSxcbiAgICAgICAgc2V0KHYpIHsgXG4gICAgICAgICAgaWYoIHRoaXMubW9kZXNbIHYgXSAhPT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwgKSB7XG4gICAgICAgICAgICB0aGlzLl9fbW9kZSA9IHYgXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBgVGhlIG1vZGUgXCIke3Z9XCIgaXMgbm90IHZhbGlkLiBWYWxpZCBtb2RlcyBpbmNsdWRlICR7T2JqZWN0LmtleXModGhpcy5tb2RlcykudG9TdHJpbmcoKX0sIGFuZCBudWxsLiBObyBjaGFuZ2UgdG8gVGhlb3J5Lm1vZGUgd2FzIGFwcGxpZWQuYCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdvZmZzZXQnLCB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiB0aGlzLl9fb2Zmc2V0IH0sXG4gICAgICAgIHNldCh2KSB7IHRoaXMuX19vZmZzZXQgPSB2IH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2RlZ3JlZScsIHsgXG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuX19kZWdyZWUgfSxcbiAgICAgICAgc2V0KCBfX2RlZ3JlZSApIHtcbiAgICAgICAgICBpZiggdHlwZW9mIF9fZGVncmVlICA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICBjb25zdCBkZWdyZWUgPSB0aGlzLl9fZGVncmVlc1sgdGhpcy5xdWFsaXR5IF1bIF9fZGVncmVlIF1cbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9fZGVncmVlID0gZGVncmVlXG4gICAgICAgICAgICAvL3RoaXMucm9vdE51bWJlciA9IGRlZ3JlZS5vZmZzZXQgKyB0aGlzLmJhc2VOdW1iZXJcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGRlZ3JlZS5tb2RlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLmRlZ3JlZSA9ICdpJ1xuICAgIH1cbiAgfSxcblxuICBfX2RlZ3JlZXM6IHsgbWFqb3I6e30sIG1pbm9yOnt9IH0sXG5cbiAgX19pbml0RGVncmVlczpmdW5jdGlvbigpIHtcbiAgICBjb25zdCBiYXNlID0gWyAnaScsICdpaScsICdpaWknLCAnaXYnLCAndicsICd2aScsICd2aWknIF1cblxuICAgIGNvbnN0IHNjYWxlcyA9IFsgeyBuYW1lOidtaW5vcicsIHZhbHVlczp0aGlzLm1vZGVzLmFlb2xpYW4gfSwgeyBuYW1lOidtYWpvcicsIHZhbHVlczp0aGlzLm1vZGVzLmlvbmlhbiB9IF1cblxuICAgIGZvciggbGV0IHNjYWxlIG9mIHNjYWxlcyApIHtcbiAgICAgIGxldCBuYW1lID0gc2NhbGUubmFtZVxuICAgICAgbGV0IHZhbHVlcyA9IHNjYWxlLnZhbHVlc1xuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNvbnN0IGNob3JkID0gYmFzZVsgaSBdXG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bIGNob3JkIF0gPSB7IG1vZGU6J2Flb2xpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctJytjaG9yZCBdID0geyBtb2RlOidhZW9saWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonYWVvbGlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMjQgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKycrY2hvcmQgXSA9IHsgbW9kZTonYWVvbGlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKysnK2Nob3JkIF0gPSB7IG1vZGU6J2Flb2xpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGJhc2VbIGkgXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bIGNob3JkIF0gPSB7IG1vZGU6J2lvbmlhbicsIG9mZnNldDogdmFsdWVzW2ldIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0nK2Nob3JkIF0gPSB7IG1vZGU6J2lvbmlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLS0nK2Nob3JkIF0gPSB7IG1vZGU6J2lvbmlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMjQgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKycrY2hvcmQgXSA9IHsgbW9kZTonaW9uaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrKycrY2hvcmQgXSA9IHsgbW9kZTonaW9uaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAyNCB9XG4gICAgICB9XG5cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY29uc3QgY2hvcmQgPSBiYXNlWyBpIF0gKyAnNydcbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgY2hvcmQgXSA9IHsgbW9kZTonZG9yaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLScrY2hvcmQgXSA9IHsgbW9kZTonZG9yaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonZG9yaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAyNCB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrJytjaG9yZCBdID0geyBtb2RlOidkb3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysrJytjaG9yZCBdID0geyBtb2RlOidkb3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGJhc2VbIGkgXS50b1VwcGVyQ2FzZSgpICsgJzcnXG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bIGNob3JkIF0gPSB7IG1vZGU6J21peG9seWRpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctJytjaG9yZCBdID0geyBtb2RlOidtaXhvbHlkaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonbWl4b2x5ZGlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMjQgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKycrY2hvcmQgXSA9IHsgbW9kZTonbWl4b2x5ZGlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKysnK2Nob3JkIF0gPSB7IG1vZGU6J21peG9seWRpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGJhc2VbIGkgXSArICdvJ1xuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyBjaG9yZCBdID0geyBtb2RlOidsb2NyaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLScrY2hvcmQgXSA9IHsgbW9kZTonbG9jcmlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLS0nK2Nob3JkIF0gPSB7IG1vZGU6J2xvY3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSAtIDI0IH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysnK2Nob3JkIF0gPSB7IG1vZGU6J2xvY3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysrJytjaG9yZCBdID0geyBtb2RlOidsb2NyaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAyNCB9XG4gICAgICB9XG5cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY29uc3QgY2hvcmQgPSBiYXNlWyBpIF0gKyAnTTcnXG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bIGNob3JkIF0gPSB7IG1vZGU6J21lbG9kaWNtaW5vcicsIG9mZnNldDogdmFsdWVzW2ldIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0nK2Nob3JkIF0gPSB7IG1vZGU6J21lbG9kaWNtaW5vcicsIG9mZnNldDogdmFsdWVzW2ldIC0gMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLS0nK2Nob3JkIF0gPSB7IG1vZGU6J21lbG9kaWNtaW5vcicsIG9mZnNldDogdmFsdWVzW2ldIC0gMjQgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKycrY2hvcmQgXSA9IHsgbW9kZTonbWVsb2RpY21pbm9yJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrKycrY2hvcmQgXSA9IHsgbW9kZTonbWVsb2RpY21pbm9yJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAyNCB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGluaXQ6ZnVuY3Rpb24oIF9fR2liYmVyICkge1xuICAgIEdpYmJlciA9IF9fR2liYmVyXG5cbiAgICB0aGlzLlR1bmUgPSBuZXcgdGhpcy5fX1R1bmUoKVxuICAgIHRoaXMuVHVuZS5UdW5pbmdMaXN0ID0gdGhpcy5fX3R1bmluZ3NcblxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgdGhpcy5pZCA9IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgICAgLy8gY2FuJ3Qgc2VuZCBwcm90b3R5cGUgbWV0aG9kcyBvZiBUdW5lIG92ZXIgcHJvY2Vzc29yXG4gICAgICAvLyBzbyB0aGV5IG5lZWQgdG8gYmUgZXhwbGljaXRseSBhc3NpZ25lZFxuICAgICAgdGhpcy5UdW5lLmxvYWRTY2FsZSA9IHRoaXMuVHVuZS5fX3Byb3RvX18ubG9hZFNjYWxlXG4gICAgICB0aGlzLlR1bmUubm90ZSA9IHRoaXMuVHVuZS5fX3Byb3RvX18ubm90ZVxuICAgICAgdGhpcy5UdW5lLmZyZXF1ZW5jeSA9IHRoaXMuVHVuZS5fX3Byb3RvX18uZnJlcXVlbmN5XG4gICAgICB0aGlzLlR1bmUudG9uaWNpemUgPSB0aGlzLlR1bmUuX19wcm90b19fLnRvbmljaXplXG4gICAgICB0aGlzLlR1bmUucmF0aW8gPSB0aGlzLlR1bmUuX19wcm90b19fLnJhdGlvXG4gICAgICB0aGlzLlR1bmUuTUlESSA9IHRoaXMuVHVuZS5fX3Byb3RvX18uTUlESVxuICAgICAgXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWRkcmVzczonYWRkJyxcbiAgICAgICAgcHJvcGVydGllczpzZXJpYWxpemUoIFRoZW9yeSApLFxuICAgICAgICBpZDp0aGlzLmlkLFxuICAgICAgICBwb3N0OidzdG9yZSdcbiAgICAgIH0pXG5cbiAgICAgIEdpYmJlci5zdWJzY3JpYmUoICdjbGVhcicsICgpID0+IHRoaXMucmVzZXQoKSApXG4gICAgICB0aGlzLmluaXRQcm9wZXJ0aWVzKClcbiAgICB9XG5cbiAgICB0aGlzLl9faW5pdERlZ3JlZXMoKVxuICB9LFxuXG4gIHJlc2V0OmZ1bmN0aW9uKCkge1xuICAgIFRoZW9yeS5yb290ID0gNDQwXG4gICAgVGhlb3J5Lm1vZGUgPSAnYWVvbGlhbidcbiAgICBUaGVvcnkudHVuaW5nID0gJ2V0J1xuICAgIFRoZW9yeS5kZWdyZWUgPSAnaSdcbiAgICBUaGVvcnkub2Zmc2V0ID0gMFxuICB9LFxuXG4gIGZyZWV6ZTpmdW5jdGlvbigpIHtcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIEdpYmJlci5UaGVvcnkuZGVncmVlLnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0b3AoKSApICBcbiAgICAgIEdpYmJlci5UaGVvcnkub2Zmc2V0LnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0b3AoKSApICBcbiAgICAgIEdpYmJlci5UaGVvcnkubW9kZS5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdG9wKCkgKSAgXG4gICAgICBHaWJiZXIuVGhlb3J5LnJvb3Quc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RvcCgpICkgIFxuICAgIH1cbiAgfSxcblxuICB0aGF3OmZ1bmN0aW9uKCkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgdGhpcy5kZWdyZWUuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RhcnQoKSApICBcbiAgICAgIHRoaXMub2Zmc2V0LnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0YXJ0KCkgKSAgXG4gICAgICB0aGlzLm1vZGUuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RhcnQoKSApICBcbiAgICAgIHRoaXMucm9vdC5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdGFydCgpICkgIFxuICAgIH1cbiAgfSxcblxuICBsb2FkU2NhbGU6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgLy8gaWYgdGhlIHNjYWxlIGlzIGFscmVhZHkgbG9hZGVkLi4uXG4gICAgICBpZiggdGhpcy5fX3R1bmluZ3NbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICB0aGlzLl9fdHVuaW5nLnZhbHVlID0gbmFtZVxuICAgICAgICB0aGlzLlR1bmUubG9hZFNjYWxlKCBuYW1lIClcblxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBhZGRyZXNzOidtZXRob2QnLFxuICAgICAgICAgIG9iamVjdDp0aGlzLmlkLFxuICAgICAgICAgIG5hbWU6J2xvYWRTY2FsZScsXG4gICAgICAgICAgYXJnczpbbmFtZV1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9fbG9hZGluZ1ByZWZpeCArIG5hbWUgKyAnLmpzJyBcbiAgICAgIGZldGNoKCBwYXRoIClcbiAgICAgICAgLmNhdGNoKCBjb25zb2xlLmVyciApXG4gICAgICAgIC50aGVuKCBkYXRhID0+IHtcbiAgICAgICAgICBpZiggZGF0YS5vayApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmpzb24oKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciggYFRoZSB0dW5pbmcgJHtuYW1lfSB3YXNuJ3QgZm91bmQuIFBsZWFzZSB2aXNpdCBodHRwOi8vYWJiZXJuaWUuZ2l0aHViLmlvL3R1bmUvc2NhbGVzLmh0bWwgdG8gZmluZCB0aGUgbmFtZXMgb2YgdmFsaWQgdHVuaW5ncy5gKSBcbiAgICAgICAgICB9IFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigganNvbiA9PiB7XG4gICAgICAgICAgdGhpcy5fX3R1bmluZy52YWx1ZSA9IG5hbWVcbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J2FkZFRvUHJvcGVydHknLFxuICAgICAgICAgICAgb2JqZWN0OnRoaXMuaWQsXG4gICAgICAgICAgICBuYW1lOidfX3R1bmluZ3MnLFxuICAgICAgICAgICAga2V5Om5hbWUsXG4gICAgICAgICAgICB2YWx1ZTpqc29uXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczonbWV0aG9kJyxcbiAgICAgICAgICAgIG9iamVjdDp0aGlzLmlkLFxuICAgICAgICAgICAgbmFtZTonbG9hZFNjYWxlJyxcbiAgICAgICAgICAgIGFyZ3M6W25hbWVdXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHRoaXMuX190dW5pbmdzWyBuYW1lIF0gPSBqc29uXG4gICAgICAgICAgdGhpcy5UdW5lLmxvYWRTY2FsZSggbmFtZSApXG4gICAgICAgIH0pXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLlR1bmUubG9hZFNjYWxlKCBuYW1lIClcbiAgICB9XG4gIH0sXG5cbiAgLy8gUkVNRU1CRVIgVEhBVCBUSEUgLm5vdGUgTUVUSE9EIElTIEFMU08gTU9OS0VZLVBBVENIRURcbiAgLy8gSU4gdWdlbi5qcywgVEhJUyBJUyBXSEVSRSBNT1NUIE9GIFRIRSBBV1BST0NFU1NPUiBOT1RFXG4gIC8vIE1FVEhPRCBJUyBJTVBMRU1FTlRFRC5cbiAgbm90ZTogZnVuY3Rpb24oIF9faWR4LCBvY3RhdmU9MCwgcm91bmQ9dHJ1ZSApIHtcbiAgICBsZXQgZmluYWxJZHgsIG1vZGUgPSBudWxsLCBfX2Zsb2F0ID0gX19pZHggJSAxLCBiYXNlT2N0YXZlLCBuZXh0T2N0YXZlXG5cbiAgICBsZXQgaXNJbnQgPSBfX2Zsb2F0ID09PSAwXG4gICAgaWYoICFpc0ludCAmJiByb3VuZD09PXRydWUgKSB7XG4gICAgICBfX2lkeCA9IE1hdGgucm91bmQoIF9faWR4IClcbiAgICAgIGlzSW50ID0gdHJ1ZVxuICAgIH1cbiAgICBcbiAgICBsZXQgYmFzZUluZGV4ID0gX19pZHggPCAwID8gTWF0aC5jZWlsKCBfX2lkeCApIDogTWF0aC5mbG9vciggX19pZHggKSxcbiAgICAgICAgbmV4dEluZGV4ID0gX19pZHggPj0gMCA/IGJhc2VJbmRleCArIDEgOiBiYXNlSW5kZXggLSAxXG5cbiAgICBiYXNlSW5kZXggKz0gR2liYmVyaXNoLlRoZW9yeS5fX29mZnNldFxuICAgIG5leHRJbmRleCArPSBHaWJiZXJpc2guVGhlb3J5Ll9fb2Zmc2V0XG5cbiAgICBpZiggR2liYmVyaXNoLlRoZW9yeS5tb2RlICE9PSAnY2hyb21hdGljJyAmJiBHaWJiZXJpc2guVGhlb3J5Lm1vZGUgIT09IG51bGwgKSB7XG4gICAgICBtb2RlID0gR2liYmVyaXNoLlRoZW9yeS5tb2Rlc1sgR2liYmVyaXNoLlRoZW9yeS5tb2RlIF1cbiAgICAgIGJhc2VPY3RhdmUgPSBNYXRoLmZsb29yKCBiYXNlSW5kZXggLyBtb2RlLmxlbmd0aCApXG4gICAgICBuZXh0T2N0YXZlID0gTWF0aC5mbG9vciggbmV4dEluZGV4IC8gbW9kZS5sZW5ndGggKVxuICAgICAgXG4gICAgICAvLyBYWFggdGhpcyBsb29rcyBjcmF6eSB1Z2x5IGJ1dCB3b3JrcyB3aXRoIG5lZ2F0aXZlIG5vdGUgbnVtYmVycy4uLlxuICAgICAgYmFzZUluZGV4ID0gYmFzZUluZGV4IDwgMCBcbiAgICAgICAgPyBtb2RlWyAobW9kZS5sZW5ndGggLSAoTWF0aC5hYnMoIGJhc2VJbmRleCApICUgbW9kZS5sZW5ndGgpKSAlIG1vZGUubGVuZ3RoIF0gXG4gICAgICAgIDogbW9kZVsgTWF0aC5hYnMoIGJhc2VJbmRleCApICUgbW9kZS5sZW5ndGggXVxuXG4gICAgICBpZiggIWlzSW50ICkge1xuICAgICAgICBuZXh0SW5kZXggPSBuZXh0SW5kZXggPCAwIFxuICAgICAgICAgID8gbW9kZVsgKG1vZGUubGVuZ3RoIC0gKE1hdGguYWJzKCBuZXh0SW5kZXggKSAlIG1vZGUubGVuZ3RoKSkgJSBtb2RlLmxlbmd0aCBdIFxuICAgICAgICAgIDogbW9kZVsgTWF0aC5hYnMoIG5leHRJbmRleCApICUgbW9kZS5sZW5ndGggXVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgLy8gbnVsbCBtb2RlIGFsc28gbWVhbnMgdG8gdXNlICdjaHJvbWF0aWMnIG1vZGVcbiAgICAgIG1vZGUgPSBHaWJiZXJpc2guVGhlb3J5Lm1vZGVzWyAnY2hyb21hdGljJyBdXG4gICAgICBjb25zdCBsID0gR2liYmVyaXNoLlRoZW9yeS5UdW5lLnNjYWxlLmxlbmd0aCBcbiAgICAgIGJhc2VPY3RhdmUgPSBNYXRoLmZsb29yKCBiYXNlSW5kZXggLyBsIClcbiAgICAgIG5leHRPY3RhdmUgPSBNYXRoLmZsb29yKCBiYXNlSW5kZXggLyBsIClcblxuICAgICAgYmFzZUluZGV4ID0gYmFzZUluZGV4IDwgMCBcbiAgICAgICAgPyBtb2RlWyAobCAtIChNYXRoLmFicyggYmFzZUluZGV4ICkgJSBsKSkgJSBsIF0gXG4gICAgICAgIDogbW9kZVsgTWF0aC5hYnMoIGJhc2VJbmRleCApICUgbCBdXG5cbiAgICAgIGlmKCAhaXNJbnQgKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG5leHRJbmRleCA8IDAgXG4gICAgICAgICAgPyBtb2RlWyAobCAtIChNYXRoLmFicyggbmV4dEluZGV4ICkgJSBsKSkgJSBsIF0gXG4gICAgICAgICAgOiBtb2RlWyBNYXRoLmFicyggbmV4dEluZGV4ICkgJSBsIF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXNlSW5kZXggKz0gdGhpcy5fX2RlZ3JlZS5vZmZzZXRcbiAgICBuZXh0SW5kZXggKz0gdGhpcy5fX2RlZ3JlZS5vZmZzZXRcblxuICAgIGxldCBvdXRwdXRGcmVxID0gMFxuICAgIGlmKCAhaXNJbnQgKSB7XG4gICAgICBjb25zdCBmcmVxMCA9IEdpYmJlcmlzaC5UaGVvcnkuVHVuZS5ub3RlKCBiYXNlSW5kZXgsIGJhc2VPY3RhdmUgKVxuICAgICAgY29uc3QgZnJlcTEgPSBHaWJiZXJpc2guVGhlb3J5LlR1bmUubm90ZSggbmV4dEluZGV4LCBuZXh0T2N0YXZlIClcbiAgICAgIGxldCAgIGRpZmYgID0gZnJlcTEgLSBmcmVxMFxuICAgICAgaWYoIF9faWR4IDwgMCApIGRpZmYgKj0gLTFcbiAgICAgIG91dHB1dEZyZXEgPSBmcmVxMCArIChkaWZmKl9fZmxvYXQpXG4gICAgfWVsc2V7XG4gICAgICBvdXRwdXRGcmVxID0gR2liYmVyaXNoLlRoZW9yeS5UdW5lLm5vdGUoIGJhc2VJbmRleCwgYmFzZU9jdGF2ZSApXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEZyZXEgXG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGhlb3J5XG4iLCJjb25zdCBQcmVzZXRzID0gcmVxdWlyZSggJy4vcHJlc2V0cy5qcycgKVxuY29uc3QgVGhlb3J5ICA9IHJlcXVpcmUoICcuL3RoZW9yeS5qcycgKVxuY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcblxuLy8gR2liYmVyIHVnZW5zIGFyZSBlc3NlbnRpYWxseSB3cmFwcGVycyBhcm91bmQgdW5kZXJseWluZyBnaWJiZXJpc2ggXG4vLyB1Z2VucywgcHJvdmlkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yIHJhcGlkbHkgc2VxdWVuY2luZ1xuLy8gYW5kIG1vZHVsYXRpbmcgdGhlbS5cblxuY29uc3QgcG9vbFNpemUgPSAxMlxuXG4vLyBEUlkgbWV0aG9kIGZvciByZW1vdmluZyBhIHNlcXVlbmNlIGFuZCBpdHMgYXNzb2NpYXRlZCBhbm5vdGF0aW9ucy5cbmNvbnN0IHJlbW92ZVNlcSA9IGZ1bmN0aW9uKCBvYmosIHNlcSApIHtcbiAgY29uc3QgaWR4ID0gb2JqLl9fc2VxdWVuY2Vycy5pbmRleE9mKCBzZXEgKVxuICBvYmouX19zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClcbiAgc2VxLnN0b3AoKVxuICBzZXEuY2xlYXIoKVxufVxuXG5jb25zdCBjcmVhdGVNYXBwaW5nID0gZnVuY3Rpb24oIGZyb20sIHRvLCBuYW1lLCB3cmFwcGVkVG8gKSB7XG4gIGlmKCBmcm9tLl9fdXNlTWFwcGluZyA9PT0gZmFsc2UgKSB7XG4gICAgd3JhcHBlZFRvWyBuYW1lIF0gPSBmcm9tXG4gIH1lbHNlIGlmKCBmcm9tLnR5cGUgPT09ICdhdWRpbycgKSB7XG4gICAgY29uc3QgZiA9IHRvWyAnX18nICsgbmFtZSBdLmZvbGxvdyA9IEZvbGxvdyh7IGlucHV0OiBmcm9tIH0pXG5cbiAgICBsZXQgbSA9IGYubXVsdGlwbGllclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdG9bIG5hbWUgXSwgJ211bHRpcGxpZXInLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBtIH0sXG4gICAgICBzZXQodikgeyBtID0gdjsgZi5tdWx0aXBsaWVyID0gbSB9XG4gICAgfSlcblxuICAgIGxldCBvID0gZi5vZmZzZXRcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRvWyBuYW1lIF0sICdvZmZzZXQnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBvIH0sXG4gICAgICBzZXQodikgeyBvID0gdjsgZi5vZmZzZXQgPSBvIH1cbiAgICB9KVxuXG4gICAgd3JhcHBlZFRvWyBuYW1lIF0gPSBmXG4gIH1lbHNlIGlmKCBmcm9tLnR5cGUgPT09ICdnZW4nICkge1xuICAgIC8vIGdlbiBvYmplY3RzIGNhbiBiZSByZWZlcnJlZCB0byB3aXRob3V0IHRoZSBncmFwaGljcy9hdWRpbyBhYnN0cmFjdGlvbixcbiAgICAvLyBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBoYXZlIG5vIC5yZW5kZXIoKSBmdW5jdGlvbiwgYW5kIGRvbid0IG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgICBjb25zdCBnZW4gPSBmcm9tLnJlbmRlciAhPT0gdW5kZWZpbmVkID8gZnJvbS5yZW5kZXIoKSA6IGZyb21cblxuICAgIHdyYXBwZWRUb1sgbmFtZSBdID0gZ2VuXG4gIH1cbn1cblxuY29uc3QgVWdlbiA9IGZ1bmN0aW9uKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvLCBzaG91bGRVc2VQb29sID0gZmFsc2UsIGlzQmlub3AgPSBmYWxzZSApIHtcblxuICBsZXQgICBwb29sQ291bnQgPSBwb29sU2l6ZVxuICBjb25zdCBwb29sID0gW11cblxuICBjb25zdCBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBQcmVzZXRzLnByb2Nlc3MoIGRlc2NyaXB0aW9uLCBhcmdzLCBBdWRpbyApIFxuICAgIGNvbnN0IHRpbWVQcm9wcyA9IEF1ZGlvLnRpbWVQcm9wc1sgZGVzY3JpcHRpb24ubmFtZSBdID09PSB1bmRlZmluZWQgPyBbXSA6IEF1ZGlvLnRpbWVQcm9wc1sgZGVzY3JpcHRpb24ubmFtZSBdXG5cbiAgICBpZiggdGltZVByb3BzLmxlbmd0aCA+IDAgKSB7XG4gICAgICBmb3IoIGxldCBrZXkgaW4gcHJvcGVydGllcyApIHtcbiAgICAgICAgaWYoIHRpbWVQcm9wcy5pbmRleE9mKCBrZXkgKSA+IC0xICkge1xuICAgICAgICAgIHByb3BlcnRpZXNbIGtleSBdID0gQXVkaW8uQ2xvY2sudGltZSggcHJvcGVydGllc1sga2V5IF0gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gWFhYIGlmIHlvdSB3YW50IHRvIHVzZSBwb29saW5nIHlvdSBtdXN0IGFsc28gdW5jb21tZW50IG5lYXIgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuLi5cbiAgICAvLyBQb29saW5nIGNvdWxkIHdvcmsgZm9yIHJldmVyYnMgSUY6XG4gICAgLy8gMS4gVGhlcmUgd291bGQgaGF2ZSB0byBiZSBzZXBhcmF0ZSBtb25vIGFuZCBzdGVyZW8gcG9vbHMuMlxuICAgIC8vIDIuIFJldmVyYnMgd291bGQgbmVlZCB0byBydW4gd2l0aCAwIGlucHV0IGZvciBhIHdoaWxlIHNvIHRoYXQgdGhlIGZ1bmN0aW9ucyBhcmUgSklUJ2RcblxuICAgIC8vaWYoIHNob3VsZFVzZVBvb2wgJiYgcG9vbENvdW50IDwgcG9vbC5sZW5ndGggKSB7XG4gICAgLy8gIHBvb2xbIHBvb2xDb3VudCBdLmluVXNlID0gdHJ1ZVxuICAgIC8vICBjb25zdCBwb29sVWdlbiA9IHBvb2xbIHBvb2xDb3VudCBdLnVnZW5cbiAgICAvLyAgcG9vbENvdW50KytcbiAgICAvLyAgT2JqZWN0LmFzc2lnbiggcG9vbFVnZW4sIHByb3BlcnRpZXMsIGFyZ3MgKVxuICAgIC8vICBjb25zb2xlLmxvZyggJ3Bvb2wgdWdlbjonLCBwb29sVWdlbiApXG4gICAgLy8gIHJldHVybiBwb29sVWdlblxuICAgIC8vfVxuXG4gICAgbGV0IF9fd3JhcHBlZE9iamVjdFxuICAgIGlmKCBpc0Jpbm9wID09PSB0cnVlICkge1xuICAgICAgX193cmFwcGVkT2JqZWN0ID0gZ2liYmVyaXNoQ29uc3RydWN0b3IoIC4uLmFyZ3MgKSBcbiAgICB9ZWxzZXtcbiAgICAgIF9fd3JhcHBlZE9iamVjdCA9IGdpYmJlcmlzaENvbnN0cnVjdG9yKCBwcm9wZXJ0aWVzIClcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgb2JqID0geyBcbiAgICAgIF9fd3JhcHBlZF9fIDpfX3dyYXBwZWRPYmplY3QsXG4gICAgICBfX3NlcXVlbmNlcnMgOiBbXSwgXG4gICAgICBfX3RpZGFsczogW10sXG4gICAgICBuYW1lOmRlc2NyaXB0aW9uLm5hbWUsXG4gICAgICB0eXBlOidhdWRpbycsXG5cbiAgICAgIHN0b3AoIHRpbWU9bnVsbCApIHtcbiAgICAgICAgaWYoIHRpbWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX19zZXF1ZW5jZXJzICkgc2VxLnN0b3AoKVxuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fdGlkYWxzICkgc2VxLnN0b3AoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aW1lID0gQXVkaW8uQ2xvY2sudGltZSggdGltZSApXG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX19zZXF1ZW5jZXJzICkge1xuICAgICAgICAgICAgZnV0dXJlKCBzZXEgPT4gc2VxLnN0b3AoKSwgdGltZSwgeyBzZXEgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3RpZGFscyApIHtcbiAgICAgICAgICAgIGZ1dHVyZSggc2VxID0+IHNlcS5zdG9wKCksIHRpbWUsIHsgc2VxIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgcGxheSggdGltZT1udWxsICkge1xuICAgICAgICBpZiggdGltZSA9PT0gbnVsbCApIHtcbiAgICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3NlcXVlbmNlcnMgKSBzZXEuc3RhcnQoKVxuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fdGlkYWxzICkgc2VxLnN0YXJ0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGltZSA9IEF1ZGlvLkNsb2NrLnRpbWUoIHRpbWUgKVxuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fc2VxdWVuY2VycyApIHtcbiAgICAgICAgICAgIGZ1dHVyZSggc2VxID0+IHNlcS5zdGFydCgpLCB0aW1lLCB7IHNlcSB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fdGlkYWxzICkge1xuICAgICAgICAgICAgZnV0dXJlKCBzZXEgPT4gc2VxLnN0YXJ0KCksIHRpbWUsIHsgc2VxIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBjbGVhcigpIHtcbiAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX19zZXF1ZW5jZXJzICkge1xuICAgICAgICAgIHNlcS5jbGVhcigpXG4gICAgICAgIH1cbiAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX190aWRhbHMgKSB7XG4gICAgICAgICAgc2VxLmNsZWFyKClcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKCBHaWJiZXJpc2gubW9kZSwgX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZCApXG4gICAgICAgIGlmKCBfX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgZm9yKCBsZXQgY29ubmVjdGlvbiBvZiBfX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkICkge1xuICAgICAgICAgICAgaWYoIHRoaXMuZnguaW5kZXhPZiggY29ubmVjdGlvblsgMCBdICkgPT09IC0xICkge1xuICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoIGNvbm5lY3Rpb25bIDAgXSApXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoIHRoaXMuX19vbmNsZWFyICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgdGhpcy5fX29uY2xlYXIoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHBvbHkgbWV0aG9kc1xuICAgIGlmKCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1BvbHknKSA+IC0xIHx8IGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignTXVsdGknKSA+IC0xIHx8IGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignU291bmRmb250JykgPiAtMSApIHtcbiAgICAgIGxldCB1c2VQcm9wID0gZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdQb2x5JykgPiAtMVxuICAgICAgb2JqLnNwcmVhZCA9IGZ1bmN0aW9uKCBhbXQ9MSApIHtcbiAgICAgICAgaWYoIGFtdCA9PT0gMCApIHtcbiAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKCAoYyxpKSA9PiB7IFxuICAgICAgICAgICAgaWYoIHVzZVByb3AgKSBcbiAgICAgICAgICAgICAgYy5wYW4gPSAuNSBcbiAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgIGlmKCBvYmoubWF4Vm9pY2VzLnZhbHVlID4gMSApIG9iai5zZXRwYW4oaSwuNSkgXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9fd3JhcHBlZF9fLnZvaWNlc1xuICAgICAgICBjb25zdCBpbmNyID0gMS8oY2hpbGRyZW4ubGVuZ3RoLTEpICogYW10XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goIChjLGkpID0+IHtcbiAgICAgICAgICBpZiggdXNlUHJvcCApIFxuICAgICAgICAgICAgYy5wYW4gPSAoLjUgLSBhbXQvMikgKyBpICogaW5jclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmKCBvYmoubWF4Vm9pY2VzLnZhbHVlID4gMSApIG9iai5zZXRwYW4oIGksICguNS1hbXQvMikgKyBpICogaW5jciApXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgb2JqLnZvaWNlcyA9IG9iai5fX3dyYXBwZWRfXy52b2ljZXNcbiAgICAgIG9iai5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoICdJbnNwZWN0aW5nICcgKyBkZXNjcmlwdGlvbi5uYW1lIClcbiAgICAgICAgY29uc29sZS50YWJsZSggT2JqZWN0LmFzc2lnbih7fSwgb2JqLnZvaWNlc1swXS5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfXywgb2JqLl9fd3JhcHBlZF9fLl9fcHJvcGVydGllc19fICkgKVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgIH1cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgMjA7IGkrKyApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIGksIHsgZ2V0KCkgeyByZXR1cm4gb2JqLnZvaWNlc1tpXSB9IH0pXG4gICAgICB9XG4gICAgfVxuLy9idG9zOiBmdW5jdGlvbiggYmVhdHMgKSB7XG4vLyAgICBjb25zdCBzYW1wbGVzUGVyQmVhdCA9IEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZSAvICh0aGlzLmJwbSAvIDYwIClcbi8vICAgIHJldHVybiBzYW1wbGVzUGVyQmVhdCAqIGJlYXRzIFxuLy8gIH1cbiAgICAvLyB0cmFuc2Zvcm0gYmVhdCB2YWx1ZXMgdG8gc2FtcGxlc1xuICAgIC8vIGluIHRoZSBjYXNlIG9mIGEgZ2VuIGdyYXBoIGNvbnZlcnQgdG8gYSBuZXcgZ2VuIG9iamVjdFxuICAgIGNvbnN0IHRpbWV0cmFuc2Zvcm0gPSBmdW5jdGlvbiggdiApIHtcbiAgICAgIGNvbnN0IG91dCA9IHR5cGVvZiB2ID09PSAnbnVtYmVyJyBcbiAgICAgICAgPyBBdWRpby5DbG9jay50aW1lKCB2ICkgXG4gICAgICAgIDogdi50eXBlID09PSAnZ2VuJyBcbiAgICAgICAgICA/IEdlbi5tYWtlKCBcbiAgICAgICAgICAgICAgZ2VuaXNoLm11bCggXG4gICAgICAgICAgICAgICAgZ2VuaXNoLmRpdiggNDQxMDAsIGdlbmlzaC5kaXYoIENsb2NrLmJwbSwgNjAgKSApLFxuICAgICAgICAgICAgICAgIHYuZ3JhcGhcbiAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHZcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cblxuICAgIC8vIHdyYXAgcHJvcGVydGllcyBhbmQgYWRkIHNlcXVlbmNpbmcgdG8gdGhlbVxuICAgIGZvciggbGV0IHByb3BlcnR5TmFtZSBpbiBkZXNjcmlwdGlvbi5wcm9wZXJ0aWVzICkge1xuICAgICAgaWYoIF9fd3JhcHBlZE9iamVjdC5fX3JlcXVpcmVkUmVjb21waWxhdGlvbiAmJiBfX3dyYXBwZWRPYmplY3QuX19yZXF1aXJlc1JlY29tcGlsYXRpb24uaW5kZXhPZiggcHJvcGVydHlOYW1lICkgPiAtMSApIGNvbnRpbnVlXG4gICAgICAvLyBYWFggd2UgaGF2ZSB0byBwYXNzIGlkIGluIHRoZSB2YWx1ZXMgZGljdGlvbmFyeSB1bmRlciBcbiAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9ucyBpbnZvbG92aW5nIGdlbiB1Z2VucywgYnV0IHdlIGRvbid0IFxuICAgICAgLy8gd2FudCAuaWQgdG8gYmUgc2VxdWVuY2FibGUhXG4gICAgICBpZiggcHJvcGVydHlOYW1lICE9PSAnaWQnICYmIHByb3BlcnR5TmFtZSAhPT0gJ3R5cGUnICl7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRpbWVQcm9wcy5pbmRleE9mKCBwcm9wZXJ0eU5hbWUgKSA+IC0xIFxuICAgICAgICAgID8gdGltZXRyYW5zZm9ybVxuICAgICAgICAgIDogbnVsbCBcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IF9fd3JhcHBlZE9iamVjdFsgcHJvcGVydHlOYW1lIF0gPT09IHVuZGVmaW5lZCBcbiAgICAgICAgICA/IF9fd3JhcHBlZE9iamVjdC5fX3Byb3BlcnRpZXNfX1sgcHJvcGVydHlOYW1lIF1cbiAgICAgICAgICA6IF9fd3JhcHBlZE9iamVjdFsgcHJvcGVydHlOYW1lIF1cblxuICAgICAgICBBdWRpby5jcmVhdGVQcm9wZXJ0eSggb2JqLCBwcm9wZXJ0eU5hbWUsIHZhbHVlLCBudWxsLCAwLCB0cmFuc2Zvcm0gKVxuXG4gICAgICAgIC8vIGNyZWF0ZSBwZXItdm9pY2UgdmVyc2lvbiBvZiBwcm9wZXJ0eS4uLiB3aGF0IHByb3BlcnRpZXMgc2hvdWxkIGJlIGV4Y2x1ZGVkP1xuICAgICAgICBpZiggZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdQb2x5JykgPiAtMSB8fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ011bHRpJykgPiAtMSB8fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1NvdW5kZm9udCcpID4gLTEgKSB7XG4gICAgICAgICAgQXVkaW8uY3JlYXRlUHJvcGVydHkoIG9iaiwgcHJvcGVydHlOYW1lKydWJywgdmFsdWUsIG51bGwsIDAsIHRyYW5zZm9ybSwgdHJ1ZSApLy8sIHRpbWVQcm9wcywgQXVkaW8sIHRydWUgKVxuXG4gICAgICAgICAgLy9jcmVhdGVQcm9wZXJ0eSggb2JqLCBwcm9wZXJ0eU5hbWUsIF9fd3JhcHBlZE9iamVjdCwgdGltZVByb3BzLCBBdWRpbywgdHJ1ZSApXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHdheSB0byBhZGQgcHJvcGVydGllcyB0byBvYmplY3RzIGluIHRoZSBwcm9jZXNzb3IgdGhyZWFkXG4gICAgICAgICAgLy8gc28gd2UnbGwganVzdCBhZGQgYSBtZXRob2QuLi4gc2VxdWVuY2luZyB3aWxsIHN0aWxsIHdvcmsgdGhlIHNhbWUuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidhZGRNZXRob2QnLFxuICAgICAgICAgICAgaWQ6X193cmFwcGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAga2V5OnByb3BlcnR5TmFtZSsnVicsXG4gICAgICAgICAgICBmdW5jdGlvbjpgZnVuY3Rpb24oIHYgKSB7dGhpcy52b2ljZXNbIHRoaXMudm9pY2VDb3VudCAlIHRoaXMudm9pY2VzLmxlbmd0aCBdWyAnJHtwcm9wZXJ0eU5hbWV9JyBdID0gdiB9YFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZGVzY3JpcHRpb24ubWV0aG9kcyAhPT0gbnVsbCAmJiBkZXNjcmlwdGlvbi5tZXRob2RzLmluZGV4T2YoICdub3RlJyApID4gLTEgKSB7IFxuICAgICAgZGVzY3JpcHRpb24ubWV0aG9kcy5wdXNoKCAnbm90ZWYnIClcbiAgICAgIGRlc2NyaXB0aW9uLm1ldGhvZHMucHVzaCggJ25vdGVjJyApXG4gICAgfVxuXG4gICAgLy8gd3JhcCBtZXRob2RzIGFuZCBhZGQgc2VxdWVuY2luZyB0byB0aGVtXG4gICAgaWYoIGRlc2NyaXB0aW9uLm1ldGhvZHMgIT09IG51bGwgKSB7XG4gICAgICBmb3IoIGxldCBtZXRob2ROYW1lIG9mIGRlc2NyaXB0aW9uLm1ldGhvZHMgKSB7XG4gICAgICAgIGlmKCBtZXRob2ROYW1lICE9PSAnbm90ZScgfHwgZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdTYW1wbGVyJykgPiAtMSB8fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ011bHRpc2FtcGxlcicpID4gLTEgKSB7IC8vfHwgZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdTb3VuZGZvbnQnKSA+IC0xICkge1xuICAgICAgICAgIC8vb2JqWyBtZXRob2ROYW1lIF0gPSBfX3dyYXBwZWRPYmplY3RbIG1ldGhvZE5hbWUgXS5iaW5kKCBfX3dyYXBwZWRPYmplY3QgKVxuICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICAgICAgICBpZiggYXJncy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdFsgbWV0aG9kTmFtZSBdKClcbiAgICAgICAgICAgIH1lbHNleyAvL2lmKCBhcmdzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgLy9pZiggQXJyYXkuaXNBcnJheSggYXJnc1swXSApICkge1xuICAgICAgICAgICAgICAvLyAgb2JqWyBtZXRob2ROYW1lIF0uc2VxKCBhcmdzWzBdLCAxL2FyZ3NbMF0ubGVuZ3RoIClcbiAgICAgICAgICAgICAgLy99ZWxzZSBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAvLyAgb2JqWyBtZXRob2ROYW1lIF0udGlkYWwoIGFyZ3NbMF0gKVxuICAgICAgICAgICAgICAvL31lbHNle1xuICAgICAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdFsgbWV0aG9kTmFtZSBdKCAuLi5hcmdzIClcbiAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICB9LyplbHNle1xuICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBhIC50aWRhbCBvciBhIHNlcSBcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApIHsgLy8gbXVzdCBiZSB0aWRhbCB3aXRoIHRpZGFsIGlkICNcbiAgICAgICAgICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXS50aWRhbCggLi4uYXJncyApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnNlcSggLi4uYXJncyApICAvLyBtdXN0IGJlIHNlcXVlbmNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gaW4gdGhpcyBibG9jayB3ZSBhcmUgbW9ua2V5IHBhdGNoaW5nIHRoZSBub3RlIG1ldGhvZCBvZiBHaWJiZXJpc2ggc3ludGhzIHNvIHRoYXRcbiAgICAgICAgICAvLyB0aGV5IHVzZSBHaWJiZXIncyBoYXJtb25pYyBzeXN0ZW0gaW5zaWRlIHRoZSBBdWRpb1dvcmtsZXRQcm9jZXNzb3IuXG5cbiAgICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICAgICAgbGV0IHNob3VsZFNlbmROb3RlTm93ID0gZmFsc2VcbiAgICAgICAgICAgIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgIHNob3VsZFNlbmROb3RlTm93ID0gdHJ1ZVxuICAgICAgICAgICAgfWVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggYXJnc1swXSApICkge1xuICAgICAgICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnNlcSggYXJnc1swXSwgMS9hcmdzWzBdLmxlbmd0aCApXG4gICAgICAgICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0udGlkYWwoIGFyZ3NbMF0gKVxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzaG91bGRTZW5kTm90ZU5vdyA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIC8vIGNvdWxkIGJlIGEgLnRpZGFsIG9yIGEgc2VxIFxuICAgICAgICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkgeyAvLyBtdXN0IGJlIHRpZGFsIHdpdGggdGlkYWwgaWQgI1xuICAgICAgICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnRpZGFsKCAuLi5hcmdzIClcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxKCAuLi5hcmdzICkgIC8vIG11c3QgYmUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGJlIGZvciBkaXJlY3QgY2FsbHMgZnJvbSB0aGUgSURFXG4gICAgICAgICAgICBpZiggc2hvdWxkU2VuZE5vdGVOb3cgJiYgR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczonbWV0aG9kJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6X193cmFwcGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6bWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J2FkZE1ldGhvZCcsXG4gICAgICAgICAgICBpZDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICBrZXk6J25vdGVmJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uOmBmdW5jdGlvbiggbm90ZSwgX19sb3VkbmVzcz1udWxsICl7XG4gICAgICAgICAgICAgIGNvbnN0IGxvdWRuZXNzID0gX19sb3VkbmVzcyA9IG51bGwgPyB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzIDogX19sb3VkbmVzc1xuICAgICAgICAgICAgICB0aGlzLl9fX25vdGUoIG5vdGUsIGxvdWRuZXNzICkgXG4gICAgICAgICAgICB9YFxuICAgICAgICAgIH0pXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidhZGRNZXRob2QnLFxuICAgICAgICAgICAgaWQ6X193cmFwcGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAga2V5Oidub3RlYycsXG4gICAgICAgICAgICBmdW5jdGlvbjpgZnVuY3Rpb24oIG5vdGUsIF9fbG91ZG5lc3M9bnVsbCApe1xuICAgICAgICAgICAgICBjb25zdCBsb3VkbmVzcyA9IF9fbG91ZG5lc3MgPSBudWxsID8gdGhpcy5fX3RyaWdnZXJMb3VkbmVzcyA6IF9fbG91ZG5lc3NcbiAgICAgICAgICAgICAgdGhpcy5ub3RlKCBub3RlLCBsb3VkbmVzcywgZmFsc2UgKSBcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBhdCB0aGUgYWRkcmVzcyAnbW9ua2V5UGF0Y2gnLFxuICAgICAgICAgIC8vIEdpYmJlcmlzaCB3aWxsIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIG1ldGhvZCBpZGVudGlmaWVkIGJ5XG4gICAgICAgICAgLy8gdGhlICdrZXknIGZpZWxkLCBhbmQgdGhlbiBhc3NpZ24gaXQgYmFjayB0byB0aGUgb2JqZWN0IHByZWZhY2VkXG4gICAgICAgICAgLy8gd2l0aCBkb3VibGUgdW5kZXJzY29yZXMgKGUuZy4gX19ub3RlKS4gVGhlIGZ1bmN0aW9uIHRoYXQgaXMgYmVpbmdcbiAgICAgICAgICAvLyBwYXRjaGVkIGluIGNhbiB0aGVuIGNhbGwgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHVzaW5nIHRoZSBwcmVmYWNlZCBcbiAgICAgICAgICAvLyBuYW1lLCBhcyBpcyBkb25lIGluIHRoZSBsYXN0IGxpbmUgb2YgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uIGJlbG93LlxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczonbW9ua2V5UGF0Y2gnLFxuICAgICAgICAgICAgaWQ6X193cmFwcGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAga2V5Oidub3RlJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uOmBmdW5jdGlvbiggbm90ZSwgX19sb3VkbmVzcywgcm91bmQ9dHJ1ZSApeyBcbiAgICAgICAgICAgICAgY29uc3Qgb2N0YXZlID0gdGhpcy5vY3RhdmUgfHwgMFxuICAgICAgICAgICAgICBsZXQgbm90ZXNJbk9jdGF2ZSA9IDdcbiAgICAgICAgICAgICAgY29uc3QgbW9kZSA9IEdpYmJlcmlzaC5UaGVvcnkubW9kZVxuXG4gICAgICAgICAgICAgIGlmKCBtb2RlICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIG5vdGVzSW5PY3RhdmUgPSBtb2RlICE9PSAnY2hyb21hdGljJyA/IEdpYmJlcmlzaC5UaGVvcnkubW9kZXNbIG1vZGUgXS5sZW5ndGggOiBHaWJiZXJpc2guVGhlb3J5LlR1bmUuc2NhbGUubGVuZ3RoXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG5vdGVzSW5PY3RhdmUgPSBHaWJiZXJpc2guVGhlb3J5LlR1bmUuc2NhbGUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBvY3RhdmUgKiBub3Rlc0luT2N0YXZlXG4gICAgICAgICAgICAgIGxldCBfX25vdGUgPSBHaWJiZXJpc2guVGhlb3J5Lm5vdGUoIG5vdGUgKyBvZmZzZXQsIDAsIHJvdW5kIClcblxuICAgICAgICAgICAgICBjb25zdCBsb3VkbmVzcyA9IF9fbG91ZG5lc3MgPSBudWxsID8gdGhpcy5fX3RyaWdnZXJMb3VkbmVzcyA6IF9fbG91ZG5lc3NcbiAgICAgICAgICAgICAgdGhpcy5fX19ub3RlKCBfX25vdGUsIGxvdWRuZXNzICkgXG4gICAgICAgICAgICB9YFxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZiggbWV0aG9kTmFtZSA9PT0gJ25vdGVmJyApIHtcbiAgICAgICAgICBvYmoubm90ZWYgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5mcmVxdWVuY3kgPSBhcmdzWzBdXG4gICAgICAgICAgICBfX3dyYXBwZWRPYmplY3QudHJpZ2dlciggX193cmFwcGVkT2JqZWN0Ll9fdHJpZ2dlckxvdWRuZXNzIClcblxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtZXRob2ROYW1lID09PSAnbm90ZWMnICkge1xuICAgICAgICAgIG9iai5ub3RlYyA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICAgICAgLy9fX3dyYXBwZWRPYmplY3QuZnJlcXVlbmN5ID0gYXJnc1swXVxuICAgICAgICAgICAgLy9fX3dyYXBwZWRPYmplY3QudHJpZ2dlciggX193cmFwcGVkT2JqZWN0Ll9fdHJpZ2dlckxvdWRuZXNzIClcbiAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBhZGRyZXNzOidtZXRob2QnLFxuICAgICAgICAgICAgICBvYmplY3Q6X193cmFwcGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAgICBuYW1lOidub3RlYycsXG4gICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnNlcXVlbmNlcnMgPSBbXVxuICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXS50aWRhbHMgPSBbXVxuXG4gICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnNlcSA9IGZ1bmN0aW9uKCB2YWx1ZXMsIHRpbWluZ3MsIG51bWJlcj0wLCBkZWxheT0wLCBwcmlvcml0eT0xMDAwMCApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ21ldGhvZCBzZXE6JywgbWV0aG9kTmFtZSwgbnVtYmVyIClcbiAgICAgICAgICBsZXQgcHJldlNlcSA9IG9ialsgbWV0aG9kTmFtZSBdLnNlcXVlbmNlcnNbIG51bWJlciBdIFxuICAgICAgICAgIGlmKCBwcmV2U2VxICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICAgICAgY29uc3QgaWR4ID0gb2JqLl9fc2VxdWVuY2Vycy5pbmRleE9mKCBwcmV2U2VxIClcbiAgICAgICAgICAgIG9iai5fX3NlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgICAgICAgLy9wcmV2U2VxLnN0b3AoKVxuICAgICAgICAgICAgcHJldlNlcS5jbGVhcigpXG4gICAgICAgICAgICAvLyByZW1vdmVTZXEoIG9iaiwgcHJldlNlcSApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHMgPSBBdWRpby5Db3JlLlNlcSh7IHZhbHVlcywgdGltaW5ncywgdGFyZ2V0Om9iai8qX193cmFwcGVkT2JqZWN0Ki8sIGtleTptZXRob2ROYW1lLCBwcmlvcml0eSB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB0eXBlb2YgZGVsYXkgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICBzLnN0YXJ0KCBBdWRpby5DbG9jay50aW1lKCBkZWxheSApIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGRlbGF5LnNlcXMucHVzaCggcyApXG4gICAgICAgICAgfVxuICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnNlcXVlbmNlcnNbIG51bWJlciBdID0gb2JqWyBtZXRob2ROYW1lIF1bIG51bWJlciBdID0gcyBcbiAgICAgICAgICBvYmouX19zZXF1ZW5jZXJzLnB1c2goIHMgKVxuXG4gICAgICAgICAgLy8gcmV0dXJuIG9iamVjdCBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9XG4gICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnRpZGFsPSBmdW5jdGlvbiggcGF0dGVybiwgbnVtYmVyPTAsIGRlbGF5PTAgKSB7XG4gICAgICAgICAgbGV0IHByZXZTZXEgPSBvYmpbIG1ldGhvZE5hbWUgXS50aWRhbHNbIG51bWJlciBdIFxuICAgICAgICAgIGxldCBzID0gQXVkaW8uQ29yZS5UaWRhbCh7IHBhdHRlcm4sIHRhcmdldDpfX3dyYXBwZWRPYmplY3QsIGtleTptZXRob2ROYW1lIH0pXG4gICAgICAgICAgaWYoIHMgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBpZiggcHJldlNlcSAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgICAgICAgY29uc3QgaWR4ID0gb2JqLl9fdGlkYWxzLmluZGV4T2YoIHByZXZTZXEgKVxuICAgICAgICAgICAgICBvYmouX190aWRhbHMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgICAgICAgICBwcmV2U2VxLnN0b3AoKVxuICAgICAgICAgICAgICBwcmV2U2VxLmNsZWFyKClcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlU2VxKCBvYmosIHByZXZTZXEgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzLnN0YXJ0KCBBdWRpby5DbG9jay50aW1lKCBkZWxheSApIClcbiAgICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnRpZGFsc1sgbnVtYmVyIF0gPSBvYmpbIG1ldGhvZE5hbWUgXVsgbnVtYmVyIF0gPSBzIFxuICAgICAgICAgICAgb2JqLl9fdGlkYWxzLnB1c2goIHMgKVxuXG4gICAgICAgICAgICAvLyBYWFggbmVlZCB0byBjbGVhbiB0aGlzIHVwISB0aGlzIGlzIHNvbGVseSBoZXJlIGZvciBhbm5vdGF0aW9ucywgYW5kIHRvIFxuICAgICAgICAgICAgLy8gbWF0Y2ggd2hhdCBJIGRpZCBmb3IgZW5zZW1ibGVzLi4uIFxuICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uX190aWRhbCA9IHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXR1cm4gb2JqZWN0IGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGxldCBpZCA9IF9fd3JhcHBlZE9iamVjdC5pZFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggX193cmFwcGVkT2JqZWN0LCAnaWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6ZmFsc2UsXG4gICAgICBnZXQoKSB7IHJldHVybiBpZCB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyggJ3RyaWVkIHRvIGNoYW5nZSBpZDonLCBvYmogKVxuICAgICAgICAvL2RlYnVnZ2VyXG4gICAgICB9XG4gICAgfSlcbiAgICBvYmouaWQgPSBfX3dyYXBwZWRPYmplY3QuaWRcblxuICAgIG9iai5fX2ZvbGxvdyA9IG51bGxcblxuICAgIGNvbnN0IGZvbGxvd2NoZWNrID0gKCk9PiB7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgJ19fb3V0Jywge1xuICAgICAgY29uZmlndXJhYmxlOmZhbHNlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiggb2JqLl9fZm9sbG93ID09PSBudWxsICkge1xuICAgICAgICAgIG9iai5fX2ZvbGxvdyA9IEF1ZGlvLmFuYWx5c2lzLkZvbGxvdyh7IGlucHV0Om9iaiB9KSBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG9iai5fX2ZvbGxvdy5vdXRwdXRcbiAgICAgICAgIFxuICAgICAgICAvLyB3aWxsIHRha2UgYSBmZXcgYnVmZmVycyB0byBpbml0aWFsaXplLi4uXG4gICAgICAgIGlmKCBvdXRwdXQgPT09IHVuZGVmaW5lZCApIHJldHVybiAwXG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFsxXSA9PT0gdW5kZWZpbmVkID8gb3V0cHV0WzBdIDogb3V0cHV0WzBdICsgb3V0cHV0WzFdIFxuICAgICAgfSxcbiAgICAgIHNldCh2KSB7fVxuICAgIH0pXG5cbiAgICBvYmouaW5zcGVjdCA9ICgpPT4ge1xuICAgICAgY29uc29sZS5ncm91cCggJ0luc3BlY3RpbmcgJyArIGRlc2NyaXB0aW9uLm5hbWUgKVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBvYmouX193cmFwcGVkX18uX19wcm9wZXJ0aWVzX18gKVxuICAgICAgY29uc3QgcHJvcHMgPSB7fVxuICAgICAga2V5cy5mb3JFYWNoKCBrZXkgPT4ge1xuICAgICAgICBpZigga2V5WzBdICE9PSAnXycgKSB7XG4gICAgICAgICAgaWYoIG9ialsga2V5IF0gIT09IG51bGwgJiYgb2JqWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcHJvcHNbIGtleSBdID0gb2JqWyBrZXkgXS52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGNvbnNvbGUudGFibGUoIHByb3BzICkgXG4gICAgICAvL2NvbnNvbGUudGFibGUoIG9iai5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfXyApXG4gICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICB9XG5cbiAgICBvYmoub3V0ID0gZnVuY3Rpb24oIHNjYWxlPTEsIG9mZnNldD0wLCBidWZmZXJTaXplPW51bGwgKSB7XG4gICAgICAvLyBpZiB0aGUgYnVmZmVyIHNpemUgY2hhbmdlcy4uLlxuICAgICAgaWYoIGJ1ZmZlclNpemUgIT09IG51bGwgKSB7XG4gICAgICAgIGlmKCBvYmouX19mb2xsb3cgIT09IG51bGwgKSB7XG4gICAgICAgICAgaWYoIGJ1ZmZlclNpemUgIT09IG9iai5fX2ZvbGxvdy5fX3dyYXBwZWRfXy5idWZmZXJTaXplICkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3ByZXYgZm9sbG93JywgYnVmZmVyU2l6ZSwgb2JqLl9fZm9sbG93Ll9fd3JhcHBlZF9fLmJ1ZmZlclNpemUsIG9iai5fX2ZvbGxvdyApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IG9iai5fX2ZvbGxvd1xuICAgICAgICAgICAgLy8gWFhYIG5lZWQgdG8gcmVtb3ZlIHRoZSBwcmV2aW91cyBmb2xsb3cgZnJvbSB0aGUgZ3JhcGguLi5cbiAgICAgICAgICAgIG9iai5fX2ZvbGxvdyA9IEF1ZGlvLmFuYWx5c2lzLkZvbGxvdyh7IGlucHV0OkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLmdldCggb2JqLl9fZm9sbG93Ll9fd3JhcHBlZF9fLmlucHV0LmlkICksIGJ1ZmZlclNpemUgfSlcblxuICAgICAgICAgICAgQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGFkZHJlc3M6J2V2YWwnLFxuICAgICAgICAgICAgICBjb2RlOmBjb25zdCBpZHggPSBHaWJiZXJpc2guYW5hbHl6ZXJzLmZpbmRJbmRleCggdWdlbiA9PiB1Z2VuLmlkID09PSAke3RtcC5pZH0gKVxuICAgICAgICAgICAgICAgICAgICBpZiggaWR4ID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5zcGxpY2UoaWR4LDEpXG4gICAgICAgICAgICAgICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBVZ2VuLk9VVFBVVCA9PT0gVWdlbi5PVVRQVVRfRlVOQ1RJT04gKVxuICAgICAgICByZXR1cm4gKCk9PiBvYmouX19vdXQgKiBzY2FsZSArIG9mZnNldFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoIG9iai5fX291dCAqIHNjYWxlICkgKyBvZmZzZXQgXG4gICAgfVxuXG4gICAgLy8gWFhYIHdoZXJlIGRvZXMgc2hvdWxkQWRkVG9VZ2VuIGNvbWUgZnJvbT8gTm90IGZyb20gcHJlc2V0cy5qcy4uLlxuICAgIGlmKCBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5zaG91bGRBZGRUb1VnZW4gKSBPYmplY3QuYXNzaWduKCBvYmosIHByb3BlcnRpZXMgKVxuXG4gICAgLy8gY3JlYXRlIGZ4IGNoYWluaW5nIGFwaS4gZS5nLiBzeW50aC5meC5hZGQoIENob3J1cygpLCBGcmVldmVyYigpIClcbiAgICAvLyB3ZSB1c2UgdGhlICdhZGQnIG1ldGhvZCB0byBlbmFibGUgbWV0aG9kIGNoYWluaW5nIGFsb25nc2lkZSBpbnN0cnVtZW50IGNhbGxzIHRvXG4gICAgLy8gLmNvbm5lY3QoKSBhbmQgLnNlcSgpXG5cbiAgICBjb25zdCBfX2Z4ID0gW11cbiAgICBfX2Z4Ll9fcHVzaCA9IF9fZngucHVzaC5iaW5kKCBfX2Z4IClcbiAgICBfX2Z4LmFkZCA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgYXJncy5mb3JFYWNoKCBmeCA9PiBvYmouX19meC5wdXNoKCBmeCApIClcbiAgICAgIGNvbnNvbGUubG9nKCBgYWRkZWQgJHthcmdzLmxlbmd0aH0gZWZmZWN0KHMpIHRvICR7b2JqLm5hbWV9YCApXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuICAgIF9fZnguaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYoIF9fZngubGVuZ3RoID4gMCApXG4gICAgICAgIGNvbnNvbGUudGFibGUoIF9fZngubWFwKCBmeD0+ZngubmFtZSApIClcbiAgICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5sb2coIGB0aGVyZSBhcmUgbm8gZWZmZWN0cyBvbiAke29iai5uYW1lfSB0byBpbnNwZWN0LmAgKVxuICAgIH1cbiAgICBfX2Z4LnJlbW92ZSA9IGZ1bmN0aW9uKCBlZmZlY3Q9bnVsbCApIHtcbiAgICAgIGlmKCBlZmZlY3QgPT09IG51bGwgKSB7XG4gICAgICAgIG9iai5fX2Z4Lmxlbmd0aCA9IDBcbiAgICAgICAgY29uc29sZS5sb2coIGBhbGwgZWZmZWN0cyBmcm9tICR7b2JqLm5hbWV9IHdlcmUgcmVtb3ZlZC5gIClcbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgZWZmZWN0ID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgLy8gWFhYIGJyb2tlbiBmb3IgaW5kaWNlcyB0aGF0ICE9PSAwXG4gICAgICAgIGNvbnN0IGRlbCA9IG9iai5fX2Z4LnNwbGljZSggZWZmZWN0LCAxIClcbiAgICAgICAgY29uc29sZS5sb2coIGAke2RlbFswXS5uYW1lfSBhdCBmeCBzbG90ICR7ZWZmZWN0fSB3YXMgcmVtb3ZlZCBmcm9tICR7b2JqLm5hbWV9LmAgKSBcbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgZWZmZWN0ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgY29uc3QgaW5kZXhlc1RvRXJhc2UgPSBbXVxuICAgICAgICBfX2Z4LmZvckVhY2goIChfX2VmZmVjdCxpKSA9PiB7IGlmKCBlZmZlY3QgPT09IF9fZWZmZWN0Lm5hbWUgKSBpbmRleGVzVG9FcmFzZS5wdXNoKCBpICkgfSlcbiAgICAgICAgY29uc29sZS5sb2coIGAke2luZGV4ZXNUb0VyYXNlLmxlbmd0aH0gZWZmZWN0KHMpIHdlcmUgcmVtb3ZlZCBmcm9tICR7b2JqLm5hbWV9LmAgKSBcbiAgICAgICAgZm9yKCBsZXQgaSA9IF9fZngubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgaWYoIGluZGV4ZXNUb0VyYXNlLmluY2x1ZGVzKCBpICkgKSBfX2Z4LnNwbGljZSggaSwgMSApXG4gICAgICAgIH0gICBcbiAgICAgIH0gZWxzZSBpZiggdHlwZW9mIGVmZmVjdCA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IF9fZnguaW5kZXhPZiggZWZmZWN0IClcbiAgICAgICAgX19meC5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgIGNvbnNvbGUubG9nKCBgZWZmZWN0ICR7ZWZmZWN0Lm5hbWV9IHdhcyByZW1vdmVkIGZyb20gJHtvYmoubmFtZX0uYCApIFxuICAgICAgfVxuICAgIH1cbiAgICBvYmouX19meCA9IG5ldyBQcm94eSggX19meCwge1xuICAgICAgc2V0KCB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgKSB7XG5cbiAgICAgICAgY29uc3QgbGVuZ3RoQ2hlY2sgPSB0YXJnZXQubGVuZ3RoXG4gICAgICAgIGNvbnN0IG9sZCA9IHRhcmdldC5zbGljZSgwKVxuICAgICAgICB0YXJnZXRbIHByb3BlcnR5IF0gPSB2YWx1ZVxuICAgICAgICBcbiAgICAgICAgaWYoIHByb3BlcnR5ID09PSAnbGVuZ3RoJyApIHsgXG4gICAgICAgICAgaWYoIHRhcmdldC5sZW5ndGggPiAxICkge1xuICAgICAgICAgICAgLy8gWFhYIG5lZWQgdG8gc3RvcmUgYW5kIHJlYXNzaWduIHRvIGVuZCBjb25uZWN0aW9uXG4gICAgICAgICAgICB0YXJnZXRbIHRhcmdldC5sZW5ndGggLSAyIF0uZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB0YXJnZXRbIHRhcmdldC5sZW5ndGggLSAyIF0uY29ubmVjdCggdGFyZ2V0WyB0YXJnZXQubGVuZ3RoIC0gMSBdIClcbiAgICAgICAgICAgIHRhcmdldFsgdGFyZ2V0Lmxlbmd0aCAtIDEgXS5jb25uZWN0KClcbiAgICAgICAgICB9ZWxzZSBpZiggdGFyZ2V0Lmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWQgIT09IHVuZGVmaW5lZCA/X193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZC5zbGljZSgwKSA6IG51bGxcbiAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0KCB0YXJnZXRbIDAgXSApXG5cbiAgICAgICAgICAgIGlmKCBjb25uZWN0ZWQgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgIGZvciggbGV0IGNvbm5lY3Rpb24gb2YgY29ubmVjdGVkICkge1xuICAgICAgICAgICAgICAgIC8vIDAgaXMgYnVzLCAxIGlzIHVnZW4gYWRkaW5nIHRoZSBmeCwgMiBpcyBzZW5kIGFtb3VudFxuICAgICAgICAgICAgICAgIHRhcmdldFswXS5jb25uZWN0KCBjb25uZWN0aW9uWzBdLCBjb25uZWN0aW9uWzJdIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRhcmdldFswXS5jb25uZWN0KCBBdWRpby5NYXN0ZXIgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIGlmKCB2YWx1ZSA9PT0gMCAmJiBsZW5ndGhDaGVjayAhPT0gMCApIHtcbiAgICAgICAgICAgIC8vIHVnaC4uLlxuICAgICAgICAgICAgaWYoIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgaWYoIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWRbMF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBfX3dyYXBwZWRPYmplY3QuY29ubmVjdCggXG4gICAgICAgICAgICAgICAgICBfX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkWyAwIF1bIDAgXS5fX3dyYXBwZWRfXy5jb25uZWN0ZWRbIDAgXVsgMCBdLCBcbiAgICAgICAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWRbIDAgXVsgMCBdLl9fd3JhcHBlZF9fLmNvbm5lY3RlZFsgMCBdWyAyIF0gXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZFsgMCBdWyAwIF0uZGlzY29ubmVjdCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCAnZngnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBvYmouX19meCB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgY29uc3QgdG1wTGVuZ3RoID0gb2JqLl9fZngubGVuZ3RoXG4gICAgICAgIG9iai5fX2Z4Lmxlbmd0aCA9IDBcbiAgICAgICAgaWYoIEFycmF5LmlzQXJyYXkoIHYgKSApIHtcbiAgICAgICAgICB2LmZvckVhY2goIGVmZmVjdCA9PiBvYmouX19meC5wdXNoKCBlZmZlY3QgKSApIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvYmouX19meC5wdXNoKCB2ICkgXG4gICAgICAgIH1cblxuICAgICAgICBpZiggdG1wTGVuZ3RoID4gMCApIHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coIGAke3RtcExlbmd0aH0gZWZmZWN0KHMpIHdlcmUgcmVwbGFjZWQgd2l0aCAke29iai5fX2Z4Lmxlbmd0aH0gZWZmZWN0KHMpIG9uICR7b2JqLm5hbWV9YCApXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgaWYoIEFycmF5LmlzQXJyYXkoIHYgKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBgJHt2Lmxlbmd0aH0gZWZmZWN0KHMpIHdlcmUgYWRkZWQgdG8gdGhlIGZ4IGNoYWluIG9mICR7b2JqLm5hbWV9YCApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyggYGEgJHt2Lm5hbWV9IHdhcyBhZGRlZCB0byB0aGUgZnggY2hhaW4gIG9mICR7b2JqLm5hbWV9YCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIG9iai5jb25uZWN0ID0gKGRlc3QsbGV2ZWw9MSkgPT4ge1xuICAgICAgaWYoIHR5cGVvZiBkZXN0ICE9PSAnbnVtYmVyJyApIHtcbiAgICAgICAgaWYoIGRlc3QgIT09IHVuZGVmaW5lZCAmJiBkZXN0LmlzUHJvcGVydHkgPT09IHRydWUgKSB7XG4gICAgICAgICAgLy8gaWYgZmlyc3QgbW9kdWxhdGlvbiBmb3IgcHJvcGVydHksIHN0b3JlIGl0J3MgaW5pdGlhbFxuICAgICAgICAgIC8vIHZhbHVlIGJlZm9yZSBtb2R1bGF0aW5nIGl0LlxuICAgICAgICAgIGlmKCBkZXN0LnByZU1vZFZhbHVlID09PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICAgICAgZGVzdC5wcmVNb2RWYWx1ZSA9IGRlc3QudmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0Lm1vZHMucHVzaCggb2JqIClcblxuICAgICAgICAgIGNvbnN0IHN1bSA9IGRlc3QubW9kcy5jb25jYXQoIGRlc3QucHJlTW9kVmFsdWUgKVxuICAgICAgICAgIGNvbnN0IGFkZCA9IEF1ZGlvLmJpbm9wcy5BZGQoIC4uLnN1bSApIFxuICAgICAgICAgIC8vIGJlbG93IHdvcmtzIGZvciBvc2NpbGxhdG9ycywgYWJvdmUgd29ya3MgZm9yIGluc3RydW1lbnRzLi4uXG4gICAgICAgICAgLy9jb25zdCBhZGQgPSBHaWJiZXIuR2liYmVyaXNoLmJpbm9wcy5BZGQoIC4uLnN1bSApIFxuICAgICAgICAgIGFkZC5fX3VzZU1hcHBpbmcgPSBmYWxzZVxuICAgICAgICAgIGRlc3QuX19vd25lclsgZGVzdC5uYW1lIF0gPSBhZGRcblxuICAgICAgICAgIG9iai5fX3dyYXBwZWRfXy5jb25uZWN0ZWQucHVzaCggWyBkZXN0Ll9fb3duZXJbIGRlc3QubmFtZSBdLCBvYmogXSApXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIGlmIG5vIGZ4IGNoYWluLCBjb25uZWN0IGRpcmVjdGx5IHRvIG91dHB1dFxuICAgICAgICAgIGlmKCBvYmouZngubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmNvbm5lY3QoIGRlc3QsIGxldmVsIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY29ubmVjdCBsYXN0IGVmZmVjdCBpbiBjaGFpbiB0byBvdXRwdXRcbiAgICAgICAgICAgIG9iai5meFsgb2JqLmZ4Lmxlbmd0aCAtIDEgXS5fX3dyYXBwZWRfXy5jb25uZWN0KCBkZXN0LCBsZXZlbCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc29sZS5sb2coICclY1lvdSBjYW5ub3QgY29ubmVjdCB0byBhIG51bWJlcjsgcGVyaGFwcyB5b3UgbWVhbnQgdGhpcyB0byBiZSB0aGUgbGV2ZWwgZm9yIHlvdXIgY29ubmVjdGlvbj8nLCAnY29sb3I6d2hpdGU7YmFja2dyb3VuZDojOTAwJyApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmogXG4gICAgfSBcblxuICAgIG9iai5kaXNjb25uZWN0ID0gZGVzdCA9PiB7IFxuICAgICAgLy8gaWYgdGhlcmUncyBhbiBlZmZlY3QgY2hhaW4sIHdlIGRpc2Nvbm5lY3QgdGhhdCBpbiBhZGRpdGlvblxuICAgICAgLy8gdG8gZGlzY29ubmVjdGluZyB0aGUgdWdlbiBpdHNlbGYuXG4gICAgICBpZiggZGVzdCA9PT0gdW5kZWZpbmVkICYmIG9iai5meC5sZW5ndGggPiAwICkge1xuICAgICAgICBvYmouZnhbIG9iai5meC5sZW5ndGggLSAxIF0uZGlzY29ubmVjdCgpXG4gICAgICB9XG5cbiAgICAgIF9fd3JhcHBlZE9iamVjdC5kaXNjb25uZWN0KCk7IFxuICAgICAgXG4gICAgICByZXR1cm4gb2JqIFxuICAgIH0gXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgJ18nLCB7IGdldCgpIHsgb2JqLmRpc2Nvbm5lY3QoKTsgcmV0dXJuIG9iaiB9IH0pXG5cbiAgICAvLyBwcmVzZXRJbml0IGlzIGEgZnVuY3Rpb24gaW4gcHJlc2V0cyB0aGF0IHRyaWdnZXJzIGFjdGlvbnMgYWZ0ZXIgdGhlIHVnZW5cbiAgICAvLyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQuLi4gaXQgaXMgcHJpbWFyaWx5IHVzZWQgdG8gYWRkIGVmZmVjdHMgYW5kIG1vZHVsYXRpb25zXG4gICAgLy8gdG8gYSBwcmVzZXQuXG4gICAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLl9fcHJlc2V0SW5pdF9fICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBwcm9wZXJ0aWVzLl9fcHJlc2V0SW5pdF9fLmNhbGwoIG9iaiwgQXVkaW8sIGFyZ3NbMV0gKVxuICAgIH1cblxuICAgIC8vIG9ubHkgY29ubmVjdCBpZiBzaG91bGROb3RDb25uZWVjdCBkb2VzIG5vdCBlcXVhbCB0cnVlIChmb3IgTEZPcyBhbmQgb3RoZXIgbW9kdWxhdGlvbiBzb3VyY2VzKVxuICAgIGlmKCBvYmouX193cmFwcGVkX18udHlwZSA9PT0gJ2luc3RydW1lbnQnIHx8IG9iai5fX3dyYXBwZWRfXy50eXBlID09PSAnb3NjaWxsYXRvcicgfHwgZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdQb2x5JykgPiAtMSApIHtcbiAgICAgIGlmKCB0eXBlb2YgcHJvcGVydGllcyAhPT0gJ29iamVjdCcgfHwgcHJvcGVydGllcy5zaG91bGROb3RDb25uZWN0ICE9PSB0cnVlICkge1xuICAgICAgICBcbiAgICAgICAgaWYoIEF1ZGlvLmF1dG9Db25uZWN0ID09PSB0cnVlICkge1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB1Z2VuIGhhc24ndCBhbHJlYWR5IGJlZW4gY29ubmVjdGVkIHRocm91Z2ggdGhlIGZ4IGNoYWluLFxuICAgICAgICAgIC8vIHBvc3NpYmx5IHRocm91Z2ggaW5pdGlhbGl6YXRpb24gb2YgYSBwcmVzZXRcbiAgICAgICAgICBpZiggb2JqLmZ4Lmxlbmd0aCA9PT0gMCApIG9iai5jb25uZWN0KCBBdWRpby5NYXN0ZXIgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9ZWxzZSBpZiggb2JqLl9fd3JhcHBlZF9fLnR5cGUgPT09ICdlZmZlY3QnICkge1xuICAgICAgb2JqLmJ1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBiID0gQXVkaW8uYnVzc2VzLkJ1czIoKVxuICAgICAgICBiLmZ4LmFkZCggb2JqIClcblxuICAgICAgICBjb25zdCBwID0gbmV3IFByb3h5KCBiLCB7XG4gICAgICAgICAgc2V0KCB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ3NldDonLCB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgKVxuICAgICAgICAgICAgaWYoIGJbIHByb3BlcnR5IF0gPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eSAhPT0gJ2lucHV0JyApIHtcbiAgICAgICAgICAgICAgb2JqWyBwcm9wZXJ0eSBdID0gdmFsdWVcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBiWyBwcm9wZXJ0eSBdID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCggdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyICkge1xuICAgICAgICAgICAgaWYoIGJbIHByb3BlcnR5IF0gPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eSAhPT0gJ2lucHV0JyApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ialsgcHJvcGVydHkgXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJldHVybiBiWyBwcm9wZXJ0eSBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHAuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoICdJbnNwZWN0aW5nICcgKyBkZXNjcmlwdGlvbi5uYW1lICsgJyAnICsgJ0J1cycgKVxuXG4gICAgICAgICAgY29uc3Qgb2JqS2V5cyA9IE9iamVjdC5rZXlzKCBvYmouX193cmFwcGVkX18uX19wcm9wZXJ0aWVzX18gKVxuICAgICAgICAgIGNvbnN0IF9fb2JqID0ge31cbiAgICAgICAgICBvYmpLZXlzLmZvckVhY2goIGtleSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAna2V5OicsIGtleSwgb2JqLl9fd3JhcHBlZF9fIClcbiAgICAgICAgICAgIGlmKCBrZXlbMF0gIT09ICdfJyAmJiBrZXkgIT09ICdieXBhc3MnICYmIG9ialtrZXldICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIF9fb2JqWyBrZXkgXSA9IG9ialsga2V5IF0udmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb2JqWyBrZXkgXS52YWx1ZVxuICAgICAgICAgICAgICAgIDogb2JqLl9fd3JhcHBlZF9fLl9fcHJvcGVydGllc19fWyBrZXkgXS52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc29sZS5ncm91cCggZGVzY3JpcHRpb24ubmFtZS50b0xvd2VyQ2FzZSgpIClcbiAgICAgICAgICBjb25zb2xlLnRhYmxlKCBfX29iaiApXG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG5cbiAgICAgICAgICBjb25zb2xlLmdyb3VwKCdidXMnKVxuICAgICAgICAgIGNvbnNvbGUudGFibGUoIGIuX193cmFwcGVkX18uX19wcm9wZXJ0aWVzX18gKVxuICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuXG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcFxuICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKCBgJWMke2Rlc2NyaXB0aW9uLm5hbWV9IGNyZWF0ZWQuYCwgJ2NvbG9yOndoaXRlO2JhY2tncm91bmQ6IzAwOScgKVxuICAgIEF1ZGlvLnB1Ymxpc2goICduZXcgdWdlbicsIGRlc2NyaXB0aW9uLm5hbWUgKyAnIGNyZWF0ZWQnICApXG5cbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICAvL2lmKCBzaG91bGRVc2VQb29sICkge1xuICAvLyAgZm9yKCBsZXQgaT0wOyBpIDwgcG9vbFNpemU7IGkrKyApIHtcbiAgLy8gICAgcG9vbFsgaSBdID0ge1xuICAvLyAgICAgIGluVXNlOmZhbHNlLFxuICAvLyAgICAgIHVnZW46IGNvbnN0cnVjdG9yKClcbiAgLy8gICAgfVxuICAvLyAgfSBcblxuICAvLyAgcG9vbENvdW50ID0gMFxuICAvL31cbiAgXG4gIC8vVWdlbi5jcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yXG59XG5cblVnZW4uT1VUUFVUX0ZVTkNUSU9OID0gMFxuVWdlbi5PVVRQVVRfU0NBTEFSID0gMVxuVWdlbi5PVVRQVVQgPSAxXG5cblxubW9kdWxlLmV4cG9ydHMgPSBVZ2VuXG4iLCJjb25zdCBVdGlsaXR5ID0ge1xuICBybmRmKCBtaW49MCwgbWF4PTEsIG51bWJlciwgY2FuUmVwZWF0PXRydWUgKSB7XG4gICAgbGV0IG91dCA9IDBcbiAgXHRpZiggbnVtYmVyID09PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRsZXQgZGlmZiA9IG1heCAtIG1pbixcbiAgXHRcdCAgICByID0gTWF0aC5yYW5kb20oKSxcbiAgXHRcdCAgICByciA9IGRpZmYgKiByXG5cbiAgXHRcdG91dCA9ICBtaW4gKyBycjtcbiAgXHR9ZWxzZXtcbiAgICAgIGxldCBvdXRwdXQgPSBbXSxcbiAgXHRcdCAgICB0bXAgPSBbXVxuXG4gIFx0XHRmb3IoIGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrICkge1xuICBcdFx0XHRsZXQgbnVtXG4gICAgICAgIGlmKCBjYW5SZXBlYXQgKSB7XG4gICAgICAgICAgbnVtID0gVXRpbGl0eS5ybmRmKG1pbiwgbWF4KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBudW0gPSBVdGlsaXR5LnJuZGYoIG1pbiwgbWF4IClcbiAgICAgICAgICB3aGlsZSggdG1wLmluZGV4T2YoIG51bSApID4gLTEpIHtcbiAgICAgICAgICAgIG51bSA9IFV0aWxpdHkucm5kZiggbWluLCBtYXggKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0bXAucHVzaCggbnVtIClcbiAgICAgICAgfVxuICBcdFx0XHRvdXRwdXQucHVzaCggbnVtIClcbiAgXHRcdH1cblxuICBcdFx0b3V0ID0gb3V0cHV0XG4gIFx0fVxuXG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG4gIFJuZGYoIF9taW4gPSAwLCBfbWF4ID0gMSwgcXVhbnRpdHksIGNhblJlcGVhdD10cnVlICkge1xuICAgIC8vIGhhdmUgdG8gY29kZSBnZW4gZnVuY3Rpb24gdG8gaGFyZCBjb2RlIG1pbiAvIG1heCB2YWx1ZXMgaW5zaWRlLCBhcyBjbG9zdXJlc1xuICAgIC8vIG9yIGJvdW5kIHZhbHVlcyB3b24ndCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgd29ya2xldCBwb3J0LlhYWCBwZXJoYXBzIHRoZXJlIHNob3VsZFxuICAgIC8vIGJlIGEgd2F5IHRvIHRyYW5zZmVyIGEgZnVuY3Rpb24gYW5kIGl0cyB1cHZhbHVlcyB0aHJvdWdoIHRoZSB3b3JrbGV0PyBPVE9ILFxuICAgIC8vIGNvZGVnZW4gd29ya3MgZmluZS5cblxuICAgIGNvbnN0IGZuY1N0cmluZyA9IGBjb25zdCBtaW4gPSAke19taW59XG4gICAgY29uc3QgbWF4ID0gJHtfbWF4fSBcbiAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pblxuICAgIGNvbnN0IGNhblJlcGVhdCA9ICR7cXVhbnRpdHl9ID4gcmFuZ2UgPyB0cnVlIDogJHsgY2FuUmVwZWF0IH1cblxuICAgIGxldCBvdXRcblxuICAgIGlmKCAke3F1YW50aXR5fSA+IDEgKSB7IFxuICAgICAgb3V0ID0gW11cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgJHtxdWFudGl0eX07IGkrKyApIHtcbiAgICAgICAgbGV0IG51bSA9IG1pbiArIE1hdGgucmFuZG9tKCkgKiByYW5nZVxuXG4gICAgICAgIGlmKCBjYW5SZXBlYXQgPT09IGZhbHNlICkge1xuICAgICAgICAgIHdoaWxlKCBvdXQuaW5kZXhPZiggbnVtICkgPiAtMSApIHtcbiAgICAgICAgICAgIG51bSA9IG1pbiArIE1hdGgucmFuZG9tKCkgKiByYW5nZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRbIGkgXSA9IG51bVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgb3V0ID0gbWluICsgTWF0aC5yYW5kb20oKSAqIHJhbmdlIFxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7YFxuICAgIFxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oIGZuY1N0cmluZyApXG4gIH0sXG5cbiAgcm5kaSggbWluID0gMCwgbWF4ID0gMSwgbnVtYmVyLCBjYW5SZXBlYXQgPSB0cnVlICkge1xuICAgIGxldCByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgICAgb3V0XG4gICAgXG4gICAgaWYoIHJhbmdlIDwgbnVtYmVyICkgY2FuUmVwZWF0ID0gdHJ1ZVxuXG4gICAgaWYoIHR5cGVvZiBudW1iZXIgPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgcmFuZ2UgPSBtYXggLSBtaW5cbiAgICAgIG91dCA9IE1hdGgucm91bmQoIG1pbiArIE1hdGgucmFuZG9tKCkgKiByYW5nZSApXG4gICAgfWVsc2V7XG4gIFx0XHRsZXQgb3V0cHV0ID0gW10sXG4gIFx0XHQgICAgdG1wID0gW11cblxuICBcdFx0Zm9yKCBsZXQgaSA9IDA7IGkgPCBudW1iZXI7IGkrKyApIHtcbiAgXHRcdFx0bGV0IG51bVxuICBcdFx0XHRpZiggY2FuUmVwZWF0ICkge1xuICBcdFx0XHRcdG51bSA9IFV0aWxpdHkucm5kaSggbWluLCBtYXggKVxuICBcdFx0XHR9ZWxzZXtcbiAgXHRcdFx0XHRudW0gPSBVdGlsaXR5LnJuZGkoIG1pbiwgbWF4IClcbiAgXHRcdFx0XHR3aGlsZSggdG1wLmluZGV4T2YoIG51bSApID4gLTEgKSB7XG4gIFx0XHRcdFx0XHRudW0gPSBVdGlsaXR5LnJuZGkoIG1pbiwgbWF4IClcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0dG1wLnB1c2goIG51bSApXG4gIFx0XHRcdH1cbiAgXHRcdFx0b3V0cHV0LnB1c2goIG51bSApXG4gIFx0XHR9XG4gIFx0XHRvdXQgPSBvdXRwdXRcbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG4gIFJuZGkoIF9taW4gPSAwLCBfbWF4ID0gMSwgcXVhbnRpdHk9MSwgY2FuUmVwZWF0ID0gZmFsc2UgKSB7XG4gICAgLy8gaGF2ZSB0byBjb2RlIGdlbiBmdW5jdGlvbiB0byBoYXJkIGNvZGUgbWluIC8gbWF4IHZhbHVlcyBpbnNpZGUsIGFzIGNsb3N1cmVzXG4gICAgLy8gb3IgYm91bmQgdmFsdWVzIHdvbid0IGJlIHBhc3NlZCB0aHJvdWdoIHRoZSB3b3JrbGV0IHBvcnQuWFhYIHBlcmhhcHMgdGhlcmUgc2hvdWxkXG4gICAgLy8gYmUgYSB3YXkgdG8gdHJhbnNmZXIgYSBmdW5jdGlvbiBhbmQgaXRzIHVwdmFsdWVzIHRocm91Z2ggdGhlIHdvcmtsZXQ/IE9UT0gsXG4gICAgLy8gY29kZWdlbiB3b3JrcyBmaW5lLlxuXG4gICAgY29uc3QgZm5jU3RyaW5nID0gYGNvbnN0IG1pbiA9ICR7X21pbn1cbiAgICBjb25zdCBtYXggPSAke19tYXh9IFxuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluXG4gICAgY29uc3QgY2FuUmVwZWF0ID0gJHtxdWFudGl0eX0gPiByYW5nZSA/IHRydWUgOiAkeyBjYW5SZXBlYXQgfVxuXG4gICAgbGV0IG91dFxuXG4gICAgaWYoICR7cXVhbnRpdHl9ID4gMSApIHsgXG4gICAgICBvdXQgPSBbXVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCAke3F1YW50aXR5fTsgaSsrICkge1xuICAgICAgICBsZXQgbnVtID0gbWluICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIHJhbmdlICk7XG5cbiAgICAgICAgaWYoIGNhblJlcGVhdCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgd2hpbGUoIG91dC5pbmRleE9mKCBudW0gKSA+IC0xICkge1xuICAgICAgICAgICAgbnVtID0gbWluICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIHJhbmdlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dFsgaSBdID0gbnVtXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBvdXQgPSBtaW4gKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogcmFuZ2UgKTsgXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtgXG4gICAgXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbiggZm5jU3RyaW5nIClcbiAgfSxcblxuICB0aW1lKCB2ICkgeyByZXR1cm4gR2liYmVyLkF1ZGlvLkNsb2NrLnRpbWUoIHYgKSB9LFxuICBidG9mKCBiZWF0cyApIHsgcmV0dXJuIDEgLyAoYmVhdHMgKiAoIDYwIC8gR2liYmVyLkF1ZGlvLkNsb2NrLmJwbSApKSB9LFxuXG4gIHJhbmRvbSgpIHtcbiAgICB0aGlzLnJhbmRvbUZsYWcgPSB0cnVlXG4gICAgdGhpcy5yYW5kb21BcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIGVsZW1lbnRBcnJheTogZnVuY3Rpb24oIGxpc3QgKSB7XG4gICAgbGV0IG91dCA9IFtdXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICBvdXQucHVzaCggbGlzdC5pdGVtKCBpICkgKVxuICAgIH1cblxuICAgIHJldHVybiBvdXRcbiAgfSxcbiAgXG4gIF9fY2xhc3NMaXN0TWV0aG9kczogWyAndG9nZ2xlJywgJ2FkZCcsICdyZW1vdmUnIF0sXG5cbiAgY3JlYXRlKCBxdWVyeSApIHtcbiAgICBsZXQgZWxlbWVudExpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBxdWVyeSApLFxuICAgICAgICBhcnIgPSBVdGlsaXR5LmVsZW1lbnRBcnJheSggZWxlbWVudExpc3QgKVxuICAgIFxuICAgIGZvciggbGV0IG1ldGhvZCBvZiBVdGlsaXR5Ll9fY2xhc3NMaXN0TWV0aG9kcyApIHsgXG4gICAgICBhcnJbIG1ldGhvZCBdID0gc3R5bGUgPT4ge1xuICAgICAgICBmb3IoIGxldCBlbGVtZW50IG9mIGFyciApIHsgXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3RbIG1ldGhvZCBdKCBzdHlsZSApXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9LFxuXG4gIGNob3JkKCBwdHJuLCBvZmZzZXRzICkge1xuICAgIC8vIGdvdHRhIGNvZGVnZW4gZnVuY3Rpb24gZm9yIHdvcmtsZXQgcHJvY2Vzc29yLi4uIHNpbWlsYXIgdG8gUm5kaSBldGMuXG4gICAgbGV0IGZuY3N0ciA9IGBhcmdzLm92ZXJyaWRlID0gYXJnc1swXVxuICAgIGNvbnN0IHZhbHVlcyA9IFtdXFxuYFxuXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgZm5jc3RyICs9IGB2YWx1ZXNbJHtpfV0gPSBhcmdzWzBdICsgJHtvZmZzZXRzW2ldfVxcbmBcbiAgICB9XG5cbiAgICBmbmNzdHIgKz0gYGFyZ3NbMF0gPSB2YWx1ZXNcXG4gIHJldHVybiBhcmdzYFxuXG4gICAgY29uc3QgZm5jID0gbmV3IEZ1bmN0aW9uKCAnYXJncycsIGZuY3N0ciApXG5cbiAgICBwdHJuLmFkZEZpbHRlciggZm5jIClcblxuICAgIHJldHVybiBwdHJuXG4gIH0sXG5cbiAgZXhwb3J0KCBvYmogKSB7XG4gICAgb2JqLnJuZGkgPSB0aGlzLnJuZGlcbiAgICBvYmoucm5kZiA9IHRoaXMucm5kZlxuICAgIG9iai5SbmRpID0gdGhpcy5SbmRpXG4gICAgb2JqLlJuZGYgPSB0aGlzLlJuZGZcbiAgICBvYmouYnRvZiA9IHRoaXMuYnRvZlxuICAgIG9iai5jaG9yZCA9IHRoaXMuY2hvcmRcbiAgICBvYmoudGltZSA9IHRoaXMudGltZVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnJuZCA9IHRoaXMucmFuZG9tXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsaXR5XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG4gICBjb25zdCBnZW4gPSBHaWJiZXIuR2VuLm1ha2UgIFxuXG4gICAvLyB3aWxsIHVzZSB0aGlzIGluIGEgZmV3IHBsYWNlcy4uLlxuICAgY29uc3QgYmVhdHMgPSBiID0+IHtcbiAgICAgcmV0dXJuIHBoYXNvciggR2liYmVyLlV0aWxpdGllcy5idG9mKCBiICksIDAsIHsgbWluOjAgfSApXG4gICB9XG5cbiAgIC8vIG5lZWRzIHRvIHN1cHBvcnQgY2hhbmdpbmcgdmFsdWVzIGluIG1vcmUgdGhhbiBvbmUgcGxhY2VcbiAgIC8vIGluIHRoZSBncmFwaCwgaGVuY2UgdGhlIGFycmF5IG9mIF9fcGFyYW1zLlxuICAgY29uc3QgYWRkUHJvcCA9ICggb2JqLCBwcm9wLCBfX3BhcmFtcywgX192YWx1ZSApID0+IHtcbiAgICAgbGV0IHZhbHVlID0gX192YWx1ZVxuICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgcHJvcCwge1xuICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgIGdldCgpIHsgcmV0dXJuIHZhbHVlIH0sXG4gICAgICAgc2V0KHYpIHtcbiAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICAgZm9yKCBsZXQgX19wYXJhbSBvZiBfX3BhcmFtcyApIHtcbiAgICAgICAgICAgX19wYXJhbS52YWx1ZSA9IHZhbHVlXG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9KVxuICAgfVxuXG4gICBjb25zdCBXYXZlUGF0dGVybnMgPSB7XG4gICAgIEJlYXRzKCBudW1CZWF0cyApIHtcbiAgICAgICBjb25zdCB1Z2VuID0gZ2VuKCBiZWF0cyggbnVtQmVhdHMgKSApXG4gICAgICAgdWdlbi5pc0dlbiA9IHVnZW4uX193cmFwcGVkX18uaXNHZW4gPSB0cnVlXG4gICAgICAgXG4gICAgICAgcmV0dXJuIHVnZW4gXG4gICAgIH0sXG5cbiAgICAgU2luZVIoIHBlcmlvZCwgZ2FpbiwgYmlhcz0wICkge1xuICAgICAgIGNvbnN0IHVnZW4gPSAgZ2VuKCBmbG9vciggYWRkKCBiaWFzLCBtdWwoIGN5Y2xlKCBHaWJiZXIuVXRpbGl0aWVzLmJ0b2YoIHBlcmlvZCApICksIGdhaW4gKSApICksIFsnYmlhcycsICdwZXJpb2QnLCAnZ2FpbiddIClcbiAgICAgICB1Z2VuLmlzR2VuID0gdWdlbi5fX3dyYXBwZWRfXy5pc0dlbiA9IHRydWVcblxuICAgICAgIHJldHVybiB1Z2VuXG4gICAgIH0sXG5cbiAgICAgTGluZVIoIHBlcmlvZCwgZnJvbT0wLCB0bz0xICkge1xuICAgICAgIGNvbnN0IGIgPSBiZWF0cyggcGVyaW9kIClcblxuICAgICAgIGNvbnN0IGRpZmYgPSBzdWIoIHRvLCBmcm9tIClcbiAgICAgICBjb25zdCBtdWx0ID0gbXVsKCBiLCBkaWZmIClcbiAgICAgICBjb25zdCBhZGRlciA9IGFkZCggZnJvbSwgbXVsdCApXG4gICAgICAgY29uc3QgdWdlbiA9IGdlbiggcm91bmQoIGFkZGVyICkgKVxuICAgICAgIFxuICAgICAgIGFkZFByb3AoIHVnZW4sICdmcm9tJywgWyB1Z2VuLnAwLCB1Z2VuLnA0IF0sIGZyb20gKVxuICAgICAgIGFkZFByb3AoIHVnZW4sICd0bycsIFsgdWdlbi5wMyBdLCB0byApXG4gICAgICAgYWRkUHJvcCggdWdlbiwgJ3BlcmlvZCcsIFsgdWdlbi5wMSBdLCBwZXJpb2QgKVxuXG4gICAgICAgY29uc3Qgb2xkU2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdWdlbiwgJ3BlcmlvZCcgKS5zZXRcbiAgICAgICBjb25zdCBvbGRHZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB1Z2VuLCAncGVyaW9kJyApLmdldFxuXG4gICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAncGVyaW9kJywge1xuICAgICAgICAgZ2V0KCkgeyByZXR1cm4gb2xkR2V0dGVyKCkgfSxcbiAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgIG9sZFNldHRlciggYnRvZih2KSApXG4gICAgICAgICB9XG5cbiAgICAgICB9KVxuICAgICAgIFxuICAgICAgIHVnZW4uaXNHZW4gPSB1Z2VuLl9fd3JhcHBlZF9fLmlzR2VuID0gdHJ1ZVxuXG4gICAgICAgcmV0dXJuIHVnZW5cbiAgICAgfSxcblxuICAgICBMaW5lKCBwZXJpb2QsIGZyb209MCwgdG89MSApIHtcbiAgICAgICBjb25zdCBiID0gYmVhdHMoIHBlcmlvZCApXG5cbiAgICAgICBjb25zdCBkaWZmID0gc3ViKCB0bywgZnJvbSApXG4gICAgICAgY29uc3QgbXVsdCA9IG11bCggYiwgZGlmZiApXG4gICAgICAgY29uc3QgYWRkZXIgPSBhZGQoIGZyb20sIG11bHQgKVxuICAgICAgIGNvbnN0IHVnZW4gPSBnZW4oIGFkZGVyIClcbiAgICAgICBcbiAgICAgICBhZGRQcm9wKCB1Z2VuLCAnZnJvbScsIFsgdWdlbi5wMCwgdWdlbi5wNCBdLCBmcm9tIClcbiAgICAgICBhZGRQcm9wKCB1Z2VuLCAndG8nLCBbIHVnZW4ucDMgXSwgdG8gKVxuICAgICAgIGFkZFByb3AoIHVnZW4sICdwZXJpb2QnLCBbIHVnZW4ucDEgXSwgcGVyaW9kIClcblxuICAgICAgIGNvbnN0IG9sZFNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHVnZW4sICdwZXJpb2QnICkuc2V0XG4gICAgICAgY29uc3Qgb2xkR2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdWdlbiwgJ3BlcmlvZCcgKS5nZXRcblxuICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ3BlcmlvZCcsIHtcbiAgICAgICAgIGdldCgpIHsgcmV0dXJuIG9sZEdldHRlcigpIH0sXG4gICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgb2xkU2V0dGVyKCBidG9mKHYpIClcbiAgICAgICAgIH1cblxuICAgICAgIH0pXG5cbiAgICAgICB1Z2VuLmlzR2VuID0gdWdlbi5fX3dyYXBwZWRfXy5pc0dlbiA9IHRydWVcblxuICAgICAgIHJldHVybiB1Z2VuXG4gICAgIH1cbiAgIH1cblxuICAgLy8gc3RvcmVzIG5hbWVzIHNvIHRoYXQgYW5ub3RhdGlvbnMgd2lsbCBjb3JyZWN0bHkgaW50ZXJwcmV0IHRoaXMgYXMgYSBnZW4gb2JqZWN0XG4gICBmb3IoIGxldCBrZXkgaW4gV2F2ZVBhdHRlcm5zICkge1xuICAgICBHaWJiZXIuR2VuLm5hbWVzLnB1c2goIGtleSApXG4gICB9XG5cbiAgcmV0dXJuIFdhdmVQYXR0ZXJuc1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyICkge1xuXG4gIGNvbnN0IFdhdmVQYXR0ZXJuID0gZnVuY3Rpb24oIHVnZW4gKSB7XG4gICAgXG4gICAgY29uc3QgZm5jID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm5jLnVnZW4uX193cmFwcGVkX18uY2FsbGJhY2sub3V0WzBdIFxuICAgIH1cblxuICAgIGZuYy51Z2VuID0gdWdlblxuXG4gICAgcmV0dXJuIEdpYmJlci5QYXR0ZXJuKCBmbmMgKVxuICB9XG5cbiAgcmV0dXJuIFdhdmVQYXR0ZXJuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG5cbmxldCBQYXR0ZXJuID0gR2liYmVyLlBhdHRlcm5cblxubGV0IGZsYXR0ZW4gPSBmdW5jdGlvbigpe1xuICAgbGV0IGZsYXQgPSBbXVxuICAgZm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgbGV0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHRoaXNbIGkgXSkuc3BsaXQoJyAnKS5wb3AoKS5zcGxpdCggJ10nICkuc2hpZnQoKS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgaWYgKHR5cGUpIHsgXG4gICAgICAgZmxhdCA9IGZsYXQuY29uY2F0KCAvXihhcnJheXxjb2xsZWN0aW9ufGFyZ3VtZW50c3xvYmplY3QpJC8udGVzdCggdHlwZSApID8gZmxhdHRlbi5jYWxsKCB0aGlzW2ldICkgOiB0aGlzW2ldKSBcbiAgICAgfVxuICAgfVxuICAgcmV0dXJuIGZsYXRcbn1cblxubGV0IGNyZWF0ZVN0YXJ0aW5nQXJyYXkgPSBmdW5jdGlvbiggbGVuZ3RoLCBvbmVzICkge1xuICBsZXQgb3V0ID0gW11cbiAgZm9yKCBsZXQgaSA9IDA7IGkgPCBvbmVzOyBpKysgKSB7XG4gICAgb3V0LnB1c2goIFsxXSApXG4gIH1cbiAgZm9yKCBsZXQgaiA9IG9uZXM7IGogPCBsZW5ndGg7IGorKyApIHtcbiAgICBvdXQucHVzaCggMCApXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5sZXQgcHJpbnRBcnJheSA9IGZ1bmN0aW9uKCBhcnJheSApIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKysgKSB7XG4gICAgbGV0IG91dGVyRWxlbWVudCA9IGFycmF5WyBpIF1cbiAgICBpZiggQXJyYXkuaXNBcnJheSggb3V0ZXJFbGVtZW50ICkgKSB7XG4gICAgICBzdHIgKz0gJ1snXG4gICAgICBmb3IoIGxldCBqID0gMDsgaiA8IG91dGVyRWxlbWVudC5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgc3RyICs9IG91dGVyRWxlbWVudFsgaiBdXG4gICAgICB9XG4gICAgICBzdHIgKz0gJ10gJ1xuICAgIH1lbHNle1xuICAgICAgc3RyICs9IG91dGVyRWxlbWVudCArICcnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0clxufVxuXG5sZXQgYXJyYXlzRXF1YWwgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgaWYgKCBhID09PSBiICkgcmV0dXJuIHRydWVcbiAgaWYgKCBhID09IG51bGwgfHwgYiA9PSBudWxsICkgcmV0dXJuIGZhbHNlXG4gIGlmICggYS5sZW5ndGggIT0gYi5sZW5ndGggKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpICkge1xuICAgIGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmxldCBnZXRMYXJnZXN0QXJyYXlDb3VudCA9IGZ1bmN0aW9uKCBpbnB1dCApIHtcbiAgbGV0IGxlbmd0aCA9IDAsIGNvdW50ID0gMFxuXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKysgKSB7XG4gICAgaWYoIEFycmF5LmlzQXJyYXkoIGlucHV0WyBpIF0gKSApIHsgXG4gICAgICBpZiggaW5wdXRbIGkgXS5sZW5ndGggPiBsZW5ndGggKSB7XG4gICAgICAgIGxlbmd0aCA9IGlucHV0WyBpIF0ubGVuZ3RoXG4gICAgICAgIGNvdW50ID0gMVxuICAgICAgfWVsc2UgaWYoIGlucHV0WyBpIF0ubGVuZ3RoID09PSBsZW5ndGggKSB7XG4gICAgICAgIGNvdW50KytcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnRcbn1cblxubGV0IEV1Y2xpZCA9IGZ1bmN0aW9uKCBvbmVzLCBsZW5ndGgsIHRpbWUsIHJvdGF0aW9uICkge1xuICBsZXQgY291bnQgPSAwLFxuICAgICAgb3V0ID0gY3JlYXRlU3RhcnRpbmdBcnJheSggbGVuZ3RoLCBvbmVzICksXG4gICAgICBvbmVzQW5kWmVyb3NcblxuIFx0ZnVuY3Rpb24gSW5uZXIoIG4sayApIHtcbiAgICBsZXQgb3BlcmF0aW9uQ291bnQgPSBjb3VudCsrID09PSAwID8gayA6IGdldExhcmdlc3RBcnJheUNvdW50KCBvdXQgKSxcbiAgICAgICAgbW92ZUNhbmRpZGF0ZUNvdW50ID0gb3V0Lmxlbmd0aCAtIG9wZXJhdGlvbkNvdW50LFxuICAgICAgICBudW1iZXJPZk1vdmVzID0gb3BlcmF0aW9uQ291bnQgPj0gbW92ZUNhbmRpZGF0ZUNvdW50ID8gbW92ZUNhbmRpZGF0ZUNvdW50IDogb3BlcmF0aW9uQ291bnRcblxuICAgIGlmKCBudW1iZXJPZk1vdmVzID4gMSB8fCBjb3VudCA9PT0gMSApIHtcbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZNb3ZlczsgaSsrICkge1xuICAgICAgICBsZXQgd2lsbEJlTW92ZWQgPSBvdXQucG9wKCksIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCB3aWxsQmVNb3ZlZCApXG4gICAgICAgIG91dFsgaSBdLnB1c2goIHdpbGxCZU1vdmVkIClcbiAgICAgICAgaWYoIGlzQXJyYXkgKSB7IFxuICAgICAgICAgIGZsYXR0ZW4uY2FsbCggb3V0WyBpIF0gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIG4gJSBrICE9PSAwICkge1xuICAgICAgcmV0dXJuIElubmVyKCBrLCBuICUgayApXG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuIGZsYXR0ZW4uY2FsbCggb3V0IClcbiAgICB9XG4gIH1cbiAgXG4gIG9uZXNBbmRaZXJvcyA9IElubmVyKCBsZW5ndGgsIG9uZXMgKVxuXG4gIGxldCBwYXR0ZXJuID0gR2liYmVyLlBhdHRlcm4oIC4uLm9uZXNBbmRaZXJvcyApXG5cbiAgaWYoIGlzTmFOKCB0aW1lICkgfHwgdGltZSA9PT0gbnVsbCApIHRpbWUgPSAxIC8gb25lc0FuZFplcm9zLmxlbmd0aFxuXG4gIHBhdHRlcm4ub25yZW5kZXIgPSBmdW5jdGlvbiggcmVuZGVyZWQgKSB7XG4gICAgcmVuZGVyZWQudHlwZSA9ICdFdWNsaWQnXG5cbiAgICByZW5kZXJlZC50aW1lID0gdGltZVxuXG4gICAgcmVuZGVyZWQub3V0cHV0ID0geyB0aW1lLCBzaG91bGRFeGVjdXRlOiAwIH1cblxuICAgIHJlbmRlcmVkLmFkZEZpbHRlciggKCBhcmdzLCBwdHJuICkgPT4ge1xuICAgICAgbGV0IHZhbCA9IGFyZ3NbIDAgXVxuXG4gICAgICBwdHJuLm91dHB1dC50aW1lID0gR2liYmVyaXNoLkNsb2NrLnRpbWUoIHB0cm4udGltZSApXG4gICAgICBwdHJuLm91dHB1dC5zaG91bGRFeGVjdXRlID0gdmFsIFxuXG4gICAgICBhcmdzWyAwIF0gPSBwdHJuLm91dHB1dCBcblxuICAgICAgcmV0dXJuIGFyZ3NcbiAgICB9KVxuICB9XG5cbiAgcGF0dGVybi5yZXNlZWQgPSAoIC4uLmFyZ3MgKT0+IHtcbiAgICBsZXQgbiwga1xuICAgIFxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBhcmdzWzBdICkgKSB7XG4gICAgICBrID0gYXJnc1swXVswXVxuICAgICAgbiA9IGFyZ3NbMF1bMV1cbiAgICB9ZWxzZXtcbiAgICAgIGsgPSBhcmdzWzBdXG4gICAgICBuID0gYXJnc1sxXVxuICAgIH1cblxuICAgIGlmKCBuID09PSB1bmRlZmluZWQgKSBuID0gMTZcbiAgICBcbiAgICBvdXQgPSBjcmVhdGVTdGFydGluZ0FycmF5KCBuLGsgKVxuICAgIGxldCBfb25lc0FuZFplcm9zID0gSW5uZXIoIG4sayApXG4gICAgXG4gICAgcGF0dGVybi5zZXQoIF9vbmVzQW5kWmVyb3MgKVxuICAgIHBhdHRlcm4udGltZSA9IDEgLyBuXG5cbiAgICAvLyB0aGlzLmNoZWNrRm9yVXBkYXRlRnVuY3Rpb24oICdyZXNlZWQnLCBwYXR0ZXJuIClcblxuICAgIHJldHVybiBwYXR0ZXJuXG4gIH1cblxuICAvL0dpYmJlci5hZGRTZXF1ZW5jaW5nVG9NZXRob2QoIHBhdHRlcm4sICdyZXNlZWQnIClcblxuICAvLyBvdXQgPSBjYWxjdWxhdGVSaHl0aG1zKCBvbmVzQW5kWmVyb3MsIGR1ciApXG4gIC8vIG91dC5pbml0aWFsID0gb25lc0FuZFplcm9zXG4gIGlmKCB0eXBlb2Ygcm90YXRpb24gPT09ICdudW1iZXInICkgcGF0dGVybi5yb3RhdGUoIHJvdGF0aW9uIClcbiAgcmV0dXJuIHBhdHRlcm4gLy9vdXRcbn1cbi8vIEUoNSw4KSA9IFsgLjI1LCAuMTI1LCAuMjUsIC4xMjUsIC4yNSBdXG5sZXQgY2FsY3VsYXRlUmh5dGhtcyA9IGZ1bmN0aW9uKCB2YWx1ZXMsIGR1ciApIHtcbiAgbGV0IG91dCA9IFtdXG4gIFxuICBpZiggdHlwZW9mIGR1ciA9PT0gJ3VuZGVmaW5lZCcgKSBkdXIgPSAxIC8gdmFsdWVzLmxlbmd0aFxuXG4gIGxldCBpZHggPSAwLFxuICAgICAgY3VycmVudER1ciA9IDBcbiAgXG4gIHdoaWxlKCBpZHggPCB2YWx1ZXMubGVuZ3RoICkge1xuICAgIGlkeCsrXG4gICAgY3VycmVudER1ciArPSBkdXJcbiAgICBcbiAgICBpZiggdmFsdWVzWyBpZHggXSA9PSAxIHx8IGlkeCA9PT0gdmFsdWVzLmxlbmd0aCApIHtcbiAgICAgIG91dC5wdXNoKCBjdXJyZW50RHVyIClcbiAgICAgIGN1cnJlbnREdXIgPSAwXG4gICAgfSBcbiAgfVxuICBcbiAgcmV0dXJuIG91dFxufVxuXG5sZXQgYW5zd2VycyA9IHtcbiAgJzEsNCcgOiAnMTAwMCcsXG4gICcyLDMnIDogJzEwMScsXG4gICcyLDUnIDogJzEwMTAwJyxcbiAgJzMsNCcgOiAnMTAxMScsXG4gICczLDUnIDogJzEwMTAxJyxcbiAgJzMsNycgOiAnMTAxMDEwMCcsXG4gICczLDgnIDogJzEwMDEwMDEwJyxcbiAgJzQsNycgOiAnMTAxMDEwMScsXG4gICc0LDknIDogJzEwMTAxMDEwMCcsXG4gICc0LDExJzogJzEwMDEwMDEwMDEwJyxcbiAgJzUsNicgOiAnMTAxMTExJyxcbiAgJzUsNycgOiAnMTAxMTAxMScsXG4gICc1LDgnIDogJzEwMTEwMTEwJyxcbiAgJzUsOScgOiAnMTAxMDEwMTAxJyxcbiAgJzUsMTEnOiAnMTAxMDEwMTAxMDAnLFxuICAnNSwxMic6ICcxMDAxMDEwMDEwMTAnLFxuICAnNSwxNic6ICcxMDAxMDAxMDAxMDAxMDAwJyxcbiAgJzcsOCcgOiAnMTAxMTExMTEnLFxuICAnMTEsMjQnOiAnMTAwMTAxMDEwMTAxMDAxMDEwMTAxMDEwJ1xufVxuXG5FdWNsaWQudGVzdCA9IGZ1bmN0aW9uKCB0ZXN0S2V5ICkge1xuICBsZXQgZmFpbGVkID0gMCwgcGFzc2VkID0gMFxuXG4gIGlmKCB0eXBlb2YgdGVzdEtleSAhPT0gJ3N0cmluZycgKSB7XG4gICAgZm9yKCBsZXQga2V5IGluIGFuc3dlcnMgKSB7XG4gICAgICBsZXQgZXhwZWN0ZWRSZXN1bHQgPSBhbnN3ZXJzWyBrZXkgXSxcbiAgICAgICAgICByZXN1bHQgPSBmbGF0dGVuLmNhbGwoIEV1Y2xpZC5hcHBseSggbnVsbCwga2V5LnNwbGl0KCcsJykgKSApLmpvaW4oJycpXG5cbiAgICAgIGNvbnNvbGUubG9nKCByZXN1bHQsIGV4cGVjdGVkUmVzdWx0IClcblxuICAgICAgaWYoIHJlc3VsdCA9PT0gZXhwZWN0ZWRSZXN1bHQgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVCBQQVNTRURcIiwga2V5IClcbiAgICAgICAgcGFzc2VkKytcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRFU1QgRkFJTEVEXCIsIGtleSApXG4gICAgICAgIGZhaWxlZCsrXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiKioqKioqKioqKioqKioqKioqKioqKioqKioqKipURVNUIFJFU1VMVFMgLSBQYXNzZWQ6IFwiICsgcGFzc2VkICsgXCIsIEZhaWxlZDogXCIgKyBmYWlsZWQgKVxuICB9ZWxzZXtcbiAgICBsZXQgZXhwZWN0ZWRSZXN1bHQgPSBhbnN3ZXJzW3Rlc3RLZXldLFxuXHRcdFx0XHRyZXN1bHQgPSBmbGF0dGVuLmNhbGwoIEV1Y2xpZC5hcHBseSggbnVsbCwgdGVzdEtleS5zcGxpdCgnLCcpICkgKS5qb2luKCcnKVxuXG4gICAgY29uc29sZS5sb2coIHJlc3VsdCwgZXhwZWN0ZWRSZXN1bHQgKVxuXG4gICAgaWYoIHJlc3VsdCA9PSBleHBlY3RlZFJlc3VsdCApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVEVTVCBQQVNTRUQgRk9SXCIsIHRlc3RLZXkpXG4gICAgfWVsc2V7XG4gICAgICBjb25zb2xlLmxvZyhcIlRFU1QgRkFJTEVEIEZPUlwiLCB0ZXN0S2V5KVxuICAgIH1cbiAgfVxufVxuXG5yZXR1cm4gRXVjbGlkXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG5cbmNvbnN0IFBhdHRlcm4gPSBHaWJiZXIuUGF0dGVyblxuXG5jb25zdCBIZXggPSBmdW5jdGlvbiggaGV4U3RyaW5nLCB0aW1lID0gMS8xNiwgcm90YXRpb24gKSB7XG4gIGxldCBjb3VudCA9IDAsXG4gICAgICBvbmVzQW5kWmVyb3MgPSAnJ1xuXG4gIGlmKCB0eXBlb2YgaGV4U3RyaW5nID09PSAnc3RyaW5nJyApIHtcbiAgICBmb3IoIGxldCBjaHIgb2YgaGV4U3RyaW5nICkge1xuICAgICAgbGV0IG51bSA9IE51bWJlciggJzB4JytjaHIgKVxuXG4gICAgICBvbmVzQW5kWmVyb3MgKz0gKG51bSAmIDgpID4gMCA/IDEgOiAwXG4gICAgICBvbmVzQW5kWmVyb3MgKz0gKG51bSAmIDQpID4gMCA/IDEgOiAwXG4gICAgICBvbmVzQW5kWmVyb3MgKz0gKG51bSAmIDIpID4gMCA/IDEgOiAwXG4gICAgICBvbmVzQW5kWmVyb3MgKz0gKG51bSAmIDEpID4gMCA/IDEgOiAwXG4gICAgfVxuICB9ZWxzZXtcbiAgICBvbmVzQW5kWmVyb3MgPSBoZXhTdHJpbmcudG9TdHJpbmcoMilcbiAgICB3aGlsZSggb25lc0FuZFplcm9zLmxlbmd0aCA8IDE2ICkge1xuICAgICAgb25lc0FuZFplcm9zID0gJzAnK29uZXNBbmRaZXJvc1xuICAgIH1cbiAgfVxuXG4gIGxldCBfX29uZXNBbmRaZXJvcyA9IG9uZXNBbmRaZXJvcy5zcGxpdCgnJykgXG5cbiAgY29uc3QgcGF0dGVybiA9IEdpYmJlci5QYXR0ZXJuKCAuLi5fX29uZXNBbmRaZXJvcyApIFxuICBcbiAgcGF0dGVybi5vbnJlbmRlciA9IGZ1bmN0aW9uKCByZW5kZXJlZCApIHtcbiAgICByZW5kZXJlZC50eXBlID0gJ0hleCdcblxuICAgIHJlbmRlcmVkLnRpbWUgPSB0aW1lXG5cbiAgICByZW5kZXJlZC5vdXRwdXQgPSB7IHRpbWUsIHNob3VsZEV4ZWN1dGU6IDAgfVxuXG4gICAgcmVuZGVyZWQuYWRkRmlsdGVyKCAoIGFyZ3MsIHB0cm4gKSA9PiB7XG4gICAgICBsZXQgdmFsID0gYXJnc1sgMCBdXG5cbiAgICAgIHB0cm4ub3V0cHV0LnRpbWUgPSBHaWJiZXJpc2guQ2xvY2sudGltZSggcHRybi50aW1lIClcbiAgICAgIHB0cm4ub3V0cHV0LnNob3VsZEV4ZWN1dGUgPSBwYXJzZUludCh2YWwpIFxuXG4gICAgICBhcmdzWyAwIF0gPSBwdHJuLm91dHB1dCBcblxuICAgICAgcmV0dXJuIGFyZ3NcbiAgICB9KVxuICB9XG5cbiAgcGF0dGVybi5yZXNlZWQgPSAoIC4uLmFyZ3MgKT0+IHtcbiAgICBsZXQgbiwga1xuICAgIFxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBhcmdzWzBdICkgKSB7XG4gICAgICBrID0gYXJnc1swXVswXVxuICAgICAgbiA9IGFyZ3NbMF1bMV1cbiAgICB9ZWxzZXtcbiAgICAgIGsgPSBhcmdzWzBdXG4gICAgICBuID0gYXJnc1sxXVxuICAgIH1cblxuICAgIGlmKCBuID09PSB1bmRlZmluZWQgKSBuID0gMTZcbiAgICBcbiAgICBvdXQgPSBjcmVhdGVTdGFydGluZ0FycmF5KCBuLGsgKVxuICAgIGxldCBfb25lc0FuZFplcm9zID0gSW5uZXIoIG4sayApXG4gICAgXG4gICAgcGF0dGVybi5zZXQoIF9vbmVzQW5kWmVyb3MgKVxuICAgIHBhdHRlcm4udGltZSA9IDEgLyBuXG5cbiAgICAvLyB0aGlzLmNoZWNrRm9yVXBkYXRlRnVuY3Rpb24oICdyZXNlZWQnLCBwYXR0ZXJuIClcblxuICAgIHJldHVybiBwYXR0ZXJuXG4gIH1cblxuICAvL0dpYmJlci5hZGRTZXF1ZW5jaW5nVG9NZXRob2QoIHBhdHRlcm4sICdyZXNlZWQnIClcblxuICBpZiggdHlwZW9mIHJvdGF0aW9uID09PSAnbnVtYmVyJyApIHBhdHRlcm4ucm90YXRlKCByb3RhdGlvbiApXG5cbiAgcmV0dXJuIHBhdHRlcm5cbn1cblxucmV0dXJuIEhleFxuXG59XG4iLCJjb25zdCBHaWJiZXIgPSB7XG4gIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgZXhwb3J0VGFyZ2V0OiBudWxsLFxuICBwbHVnaW5zOiBbXSxcbiAgLy8gbmVlZGVkIHNvIGF1ZGlvIHBsdWdpbiBjYW4gdHJhbnNmZXIgcGF0dGVybiBmdW5jdGlvbiBzdHJpbmcgdG8gd29ya2xldFxuICBfX1BhdHRlcm46IHJlcXVpcmUoICcuL3BhdHRlcm4uanMnICksXG5cbiAgLyogXG4gICAqIGNvbnN0IHByb21pc2VzID0gR2liYmVyLmluaXQoW1xuICAgKiAgIHtcbiAgICogICAgIHBsdWdpbjpBdWRpbywgLy8gQXVkaW8gaXMgcmVxdWlyZWQsIGltcG9ydGVkLCBvciBncmFiYmVkIHZpYSA8c2NyaXB0PlxuICAgKiAgICAgb3B0aW9uczogeyB3b3JrbGV0UGF0aDonLi4vZGlzdC9naWJiZXJpc2hfd29ya2xldC5qcycgfVxuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgcGx1Z2luOkdyYXBoaWNzLFxuICAgKiAgICAgb3B0aW9uczp7IGNhbnZhczpkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnICkgfVxuICAgKiAgIH1cbiAgICogXSlcbiAgKi9cblxuICBpbml0KCBwbHVnaW5zICkgeyBcbiAgICB0aGlzLmNyZWF0ZVB1YlN1YiggdGhpcyApXG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2luc1xuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuXG4gICAgLy8gaW5pdCBlYWNoIHBsdWdpbiBhbmQgY29sbGVjdCBwcm9taXNlc1xuICAgIGZvciggbGV0IHBsdWdpbiBvZiBwbHVnaW5zICkge1xuICAgICAgcHJvbWlzZXMucHVzaCggXG4gICAgICAgIHBsdWdpbi5wbHVnaW4uaW5pdCggcGx1Z2luLm9wdGlvbnMsIHRoaXMgKSBcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoIChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZmluaXNoZWRJbml0UHJvbWlzZSA9IFByb21pc2UuYWxsKCBwcm9taXNlcyApLnRoZW4oIHZhbHVlcyA9PiB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLlBhdHRlcm4gPSB0aGlzLl9fUGF0dGVybiggdGhpcyApXG4gICAgICAgIHRoaXMuU2VxICAgICAgPSByZXF1aXJlKCAnLi9zZXEuanMnICAgICAgKSggdGhpcyApXG4gICAgICAgIHRoaXMuVGlkYWwgICAgPSByZXF1aXJlKCAnLi90aWRhbC5qcycgICAgKSggdGhpcyApXG4gICAgICAgIHRoaXMuRXVjbGlkICAgPSByZXF1aXJlKCAnLi9ldWNsaWQuanMnICAgKSggdGhpcyApXG4gICAgICAgIHRoaXMuSGV4ICAgICAgPSByZXF1aXJlKCAnLi9oZXguanMnICAgICAgKSggdGhpcyApIFxuICAgICAgICB0aGlzLlRyaWdnZXJzID0gcmVxdWlyZSggJy4vdHJpZ2dlcnMuanMnICkoIHRoaXMgKVxuICAgICAgICB0aGlzLlN0ZXBzICAgID0gcmVxdWlyZSggJy4vc3RlcHMuanMnICAgICkoIHRoaXMgKVxuXG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCB2ID0+IHtcbiAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdiApICkgXG4gICAgICAgICAgICB0aGlzWyB2WzFdIF0gPSB2WzBdXG4gICAgICAgIH0pXG5cbiAgICAgICAgR2liYmVyLnB1Ymxpc2goICdpbml0JyApXG4gICAgICAgIFxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgXG4gICAgcmV0dXJuIHBcbiAgfSxcblxuICBsb2coIC4uLmFyZ3MgKSB7XG4gICAgaWYoIEdpYmJlci5FbnZpcm9ubWVudCApIHtcbiAgICAgIEdpYmJlci5FbnZpcm9ubWVudC5sb2coIC4uLmFyZ3MgKVxuICAgIH1lbHNle1xuICAgICAgY29uc29sZS5sb2coIC4uLmFyZ3MgKVxuICAgIH1cbiAgfSxcblxuICBlcnJvciggLi4uYXJncyApIHtcbiAgICBpZiggR2liYmVyLkVudmlyb25tZW50ICkge1xuICAgICAgR2liYmVyLkVudmlyb25tZW50LmVycm9yKCAuLi5hcmdzIClcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoIC4uLmFyZ3MgKVxuICAgIH1cbiAgfSxcblxuICBleHBvcnQoIG9iaiApIHtcbiAgICAvLyBYWFggbXVzdCBrZWVwIHJlZmVyZW5jZSB0byBtYWluIHBhdHRlcm4gZnVuY3Rpb25cbiAgICAvLyBzbyBpdCBjYW4gYmUgc2VyaWFsaXplZCBhbmQgdHJhbnNmZXJyZWQgdG8gYXVkaW93b3JrbGV0ICBcbiAgICBvYmouUGF0dGVybiAgPSB0aGlzLlBhdHRlcm5cbiAgICBvYmouU2VxID0gdGhpcy5TZXFcbiAgICBvYmouVGlkYWwgPSB0aGlzLlRpZGFsXG4gICAgb2JqLkV1Y2xpZCA9IHRoaXMuRXVjbGlkXG4gICAgb2JqLkhleCA9IHRoaXMuSGV4XG4gICAgb2JqLlRyaWdnZXJzID0gdGhpcy5UcmlnZ2Vyc1xuICAgIG9iai5TdGVwcyA9IHRoaXMuU3RlcHNcblxuICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKCBwID0+IHtcbiAgICAgIHAucGx1Z2luLmV4cG9ydCggb2JqLCBHaWJiZXIgKSBcbiAgICB9KVxuXG4gICAgLy9vYmouQ2xvY2sgPSB0aGlzLkNsb2NrXG4gICAgLy9vYmouV2F2ZVBhdHRlcm4gPSB0aGlzLldhdmVQYXR0ZXJuXG4gIH0sXG5cbiAgLy8gWFhYIHN0b3AgY2xvY2sgZnJvbSBiZWluZyBjbGVhcmVkLlxuICBjbGVhcigpIHsgXG4gICAgZm9yKCBsZXQgcGx1Z2luIG9mIEdpYmJlci5wbHVnaW5zICkge1xuICAgICAgcGx1Z2luLnBsdWdpbi5jbGVhcigpXG4gICAgfVxuXG4gICAgdGhpcy5TZXEuY2xlYXIoKVxuICAgIHRoaXMuVGlkYWwuY2xlYXIoKVxuXG4gICAgdGhpcy5wdWJsaXNoKCAnY2xlYXInIClcbiAgfSxcblxuICBvbmxvYWQoKSB7fSxcblxuICBjcmVhdGVQdWJTdWIoIG9iaiApIHtcbiAgICBjb25zdCBldmVudHMgPSB7fVxuICAgIG9iai5zdWJzY3JpYmUgPSBmdW5jdGlvbigga2V5LCBmY24gKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBldmVudHNbIGtleSBdID0gW11cbiAgICAgIH1cbiAgICAgIGV2ZW50c1sga2V5IF0ucHVzaCggZmNuIClcbiAgICB9XG5cbiAgICBvYmoudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigga2V5LCBmY24gKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBjb25zdCBhcnIgPSBldmVudHNbIGtleSBdXG5cbiAgICAgICAgYXJyLnNwbGljZSggYXJyLmluZGV4T2YoIGZjbiApLCAxIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmoucHVibGlzaCA9IGZ1bmN0aW9uKCBrZXksIGRhdGEgKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBjb25zdCBhcnIgPSBldmVudHNbIGtleSBdXG5cbiAgICAgICAgYXJyLmZvckVhY2goIHYgPT4gdiggZGF0YSApIClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gV2hlbiBhIHByb3BlcnR5IGlzIGNyZWF0ZWQsIGEgcHJveHktaXNoIG9iamVjdCBpcyBtYWRlIHRoYXQgaXNcbiAgLy8gcHJlZmFjZWQgYnkgYSBkb3VibGUgdW5kZXJzY29yZS4gVGhpcyBvYmplY3QgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBcbiAgLy8gcHJvcGVydHksIHNlcXVlbmNlcnMgZm9yIHRoZSBwcm9wZXJ0eSwgYW5kIG1vZHVsYXRpb25zIGZvciB0aGUgcHJvcGVydHkuXG4gIC8vIEFsdGVybmF0aXZlIGdldHRlci9zZXR0ZXIgbWV0aG9kcyBjYW4gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cy5cbiAgY3JlYXRlUHJvcGVydHkoIG9iaiwgbmFtZSwgdmFsdWUsIHBvc3Q9bnVsbCwgcHJpb3JpdHk9MCwgdHJhbnNmb3JtPW51bGwsIGlzUG9seT1mYWxzZSApIHtcbiAgICBvYmpbICdfXycgKyBuYW1lIF0gPSB7IFxuICAgICAgdmFsdWUsXG4gICAgICBpc1Byb3BlcnR5OnRydWUsXG4gICAgICBzZXF1ZW5jZXJzOltdLFxuICAgICAgdGlkYWxzOltdLFxuICAgICAgbW9kczpbXSxcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOm9iai50eXBlLFxuICAgICAgX19vd25lcjpvYmosXG5cbiAgICAgIGZhZGUoIGZyb209MCwgdG89MSwgdGltZT00LCBkZWxheT0wICkge1xuICAgICAgICBHaWJiZXJbIG9iai50eXBlIF0uY3JlYXRlRmFkZSggZnJvbSwgdG8sIHRpbWUsIG9iaiwgbmFtZSwgZGVsYXkgKVxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgfVxuXG4gICAgR2liYmVyLmFkZFNlcXVlbmNpbmcoIG9iaiwgbmFtZSwgcHJpb3JpdHksIHZhbHVlLCAnX18nIClcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCBuYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgIGdldDogR2liYmVyWyBvYmoudHlwZSBdLmNyZWF0ZUdldHRlciggb2JqLCBuYW1lICksXG4gICAgICBzZXQ6IEdpYmJlclsgb2JqLnR5cGUgXS5jcmVhdGVTZXR0ZXIoIG9iaiwgbmFtZSwgcG9zdCwgdHJhbnNmb3JtLCBpc1BvbHkgKVxuICAgIH0pXG4gIH0sXG5cbiAgZ2V0VHlwZSggb2JqICkge1xuICAgIGxldCB0eXBlXG4gICAgc3dpdGNoKCBmcm9tLnR5cGUgKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdBdWRpbyc6XG4gICAgICAgIHR5cGUgPSBHaWJiZXIuQXVkaW9cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2dyYXBoaWNzJzpcbiAgICAgIGNhc2UgJ0dyYXBoaWNzJzpcbiAgICAgICAgdHlwZSA9IEdpYmJlci5HcmFwaGljc1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZ2VuJzpcbiAgICAgICAgdHlwZSA9ICdnZW4nXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVcbiAgfSxcblxuICBtYXBwaW5nczoge30sXG4gIFxuICBjcmVhdGVNYXBwaW5nKCBmcm9tLCB0bywgbmFtZSwgd3JhcHBlZFRvICkge1xuICAgIGNvbnN0IGZyb21saWIgPSB0aGlzLmdldFR5cGUoIGZyb20gKSxcbiAgICAgICAgICB0b2xpYiAgID0gdGhpcy5nZXRUeXBlKCB0byApXG5cblxuICAgIGlmKCBtYXBwaW5nc1sgdG9saWIgXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBtYXBwaW5nc1sgdG9saWIgXVsgZnJvbWxpYiBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcHBlciA9IG1hcHBpbmdzWyB0b2xpYiBdWyBmcm9tbGliIF1cblxuICAgICAgbWFwcGVyKCBuYW1lLCB0bywgZnJvbSApXG4gICAgfVxuXG4gIFxuICAgIC8vaWYoIGZyb20udHlwZSA9PT0gJ2F1ZGlvJyApIHtcbiAgICAvLyAgY29uc3QgZiA9IHRvWyAnX18nICsgbmFtZSBdLmZvbGxvdyA9IEZvbGxvdyh7IGlucHV0OiBmcm9tLCBidWZmZXJTaXplOjQwOTYgfSlcblxuICAgIC8vICBNYXJjaGluZy5jYWxsYmFja3MucHVzaCggdGltZSA9PiB7XG4gICAgLy8gICAgaWYoIGYub3V0cHV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgLy8gICAgICB0b1sgbmFtZSBdID0gZi5vdXRwdXRcbiAgICAvLyAgICB9XG4gICAgLy8gIH0pXG5cbiAgICAvLyAgbGV0IG0gPSBmLm11bHRpcGxpZXJcbiAgICAvLyAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0b1sgbmFtZSBdLCAnbXVsdGlwbGllcicsIHtcbiAgICAvLyAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAvLyAgICBnZXQoKSB7IHJldHVybiBtIH0sXG4gICAgLy8gICAgc2V0KHYpIHsgbSA9IHY7IGYubXVsdGlwbGllciA9IG0gfVxuICAgIC8vICB9KVxuXG4gICAgLy8gIGxldCBvID0gZi5vZmZzZXRcbiAgICAvLyAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0b1sgbmFtZSBdLCAnb2Zmc2V0Jywge1xuICAgIC8vICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgIC8vICAgIGdldCgpIHsgcmV0dXJuIG8gfSxcbiAgICAvLyAgICBzZXQodikgeyBvID0gdjsgZi5vZmZzZXQgPSBvIH1cbiAgICAvLyAgfSlcbiAgICAvL31lbHNlIGlmKCBmcm9tLnR5cGUgPT09ICdnZW4nICkge1xuICAgIC8vICBjb25zdCBnZW4gPSBmcm9tLnJlbmRlciggNjAsICdncmFwaGljcycgKVxuXG4gICAgLy8gIC8vIG5lZWRlZCBmb3IgYW5ub3RhdGlvbnNcbiAgICAvLyAgdG9bIG5hbWUgXS52YWx1ZS5pZCA9IHRvWyBuYW1lIF0udmFsdWUudmFyTmFtZVxuXG4gICAgLy8gIC8vIFhYWCBmaXggdGhlIHR3byBwb3NzaWJsZSBsb2NhdGlvbnMgZm9yIHRoZSBjYWxsYmFja1xuICAgIC8vICBpZiggdG9bIG5hbWUgXS52YWx1ZS5jYWxsYmFjayAhPT0gdW5kZWZpbmVkICkge1xuICAgIC8vICAgIGNvbnN0IGlkeCA9IE1hcmNoaW5nLmNhbGxiYWNrcy5pbmRleE9mKCB0b1sgbmFtZSBdLnZhbHVlLmNhbGxiYWNrIClcbiAgICAvLyAgICBNYXJjaGluZy5jYWxsYmFja3Muc3BsaWNlKCBpZHgsIDEgKVxuICAgIC8vICB9ZWxzZSBpZiggdG9bICdfXycrbmFtZSBdLmNhbGxiYWNrICE9PSB1bmRlZmluZWQgKSB7XG4gICAgLy8gICAgY29uc3QgaWR4ID0gTWFyY2hpbmcuY2FsbGJhY2tzLmluZGV4T2YoIHRvWyAnX18nK25hbWUgXS5jYWxsYmFjayApXG4gICAgLy8gICAgTWFyY2hpbmcuY2FsbGJhY2tzLnNwbGljZSggaWR4LCAxIClcbiAgICAvLyAgfVxuXG4gICAgLy8gIC8vIFhYWCBmaXggdGhlIHR3byBwb3NzaWJsZSBsb2NhdGlvbnMgZm9yIHRoZSBjYWxsYmFja1xuICAgIC8vICBpZiggdHlwZW9mIHRvWyBuYW1lIF0udmFsdWUgPT09ICdvYmplY3QnICkge1xuICAgIC8vICAgIHRvWyBuYW1lIF0udmFsdWUuY2FsbGJhY2sgPSB0ID0+IHtcbiAgICAvLyAgICAgIGNvbnN0IHZhbCA9IGdlbigpXG4gICAgLy8gICAgICB0b1sgbmFtZSBdID0gdmFsXG4gICAgLy8gICAgICAvL2NvbnNvbGUubG9nKCAndmFsOicsIHZhbCwgdG9bIG5hbWUgXS52YWx1ZS53aWRnZXQgIT09IHVuZGVmaW5lZCApXG4gICAgLy8gICAgICBsZXQgdGFyZ2V0ID0gdG9bIG5hbWUgXS52YWx1ZS53aWRnZXQgIT09IHVuZGVmaW5lZCA/IHRvWyBuYW1lIF0udmFsdWUud2lkZ2V0IDogZnJvbS53aWRnZXRcblxuICAgIC8vICAgICAgaWYoIHRhcmdldCA9PT0gdW5kZWZpbmVkICYmIHRvWyBuYW1lIF0udmFsdWUubWFyayAhPT0gdW5kZWZpbmVkICkgXG4gICAgLy8gICAgICAgIHRhcmdldCA9IHRvWyBuYW1lIF0udmFsdWUubWFyay5yZXBsYWNlZFdpdGhcblxuICAgIC8vICAgICAgR2liYmVyLkVudmlyb25tZW50LmNvZGVNYXJrdXAud2F2ZWZvcm0udXBkYXRlV2lkZ2V0KCB0YXJnZXQsIHZhbCwgZmFsc2UgKVxuICAgIC8vICAgIH1cbiAgICAvLyAgfWVsc2V7XG4gICAgLy8gICAgLy8gYXNzaWdubWVudCBoYWNrIHdoaWxlIERPTSBjcmVhdGlvbiBpcyB0YWtpbmcgcGxhY2UsXG4gICAgLy8gICAgLy8gb25seSBuZWVkZWQgZm9yIG1hcHBpbmdzIHRvIGluZGl2aWR1YWwgdmVjdG9yIGVsZW1lbnRzLlxuICAgIC8vICAgIGlmKCB0b1sgJ19fJytuYW1lIF0ud2lkZ2V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgLy8gICAgICBzZXRUaW1lb3V0KCAoKT0+IHRvWyAnX18nK25hbWUgXS53aWRnZXQgPSBnZW4ucHJlLndpZGdldCwgMTUwIClcbiAgICAvLyAgICB9XG5cbiAgICAvLyAgICB0b1sgJ19fJytuYW1lIF0uY2FsbGJhY2sgPSB0ID0+IHtcbiAgICAvLyAgICAgIGNvbnN0IHZhbCA9IGdlbigpXG4gICAgLy8gICAgICB0b1sgbmFtZSBdID0gdmFsXG4gICAgLy8gICAgICBHaWJiZXIuRW52aXJvbm1lbnQuY29kZU1hcmt1cC53YXZlZm9ybS51cGRhdGVXaWRnZXQoIHRvWyAnX18nK25hbWUgXS53aWRnZXQsIHZhbCwgZmFsc2UgKVxuICAgIC8vICAgIH1cbiAgICAvLyAgfVxuXG4gICAgLy8gIGlmKCB0eXBlb2YgdG9bIG5hbWUgXS52YWx1ZSAhPT0gJ29iamVjdCcgKSB7XG4gICAgLy8gICAgTWFyY2hpbmcuY2FsbGJhY2tzLnB1c2goIHRvWyAnX18nK25hbWUgXS5jYWxsYmFjayApXG4gICAgLy8gIH1lbHNle1xuICAgIC8vICAgIE1hcmNoaW5nLmNhbGxiYWNrcy5wdXNoKCB0b1sgbmFtZSBdLnZhbHVlLmNhbGxiYWNrIClcbiAgICAvLyAgfVxuICAgIC8vfVxuICB9LFxuXG4gIGFkZFNlcXVlbmNpbmcoIG9iaiwgbmFtZSwgcHJpb3JpdHksIHZhbHVlLCBwcmVmaXg9JycgKSB7XG4gICAgaWYoIG9ialsgcHJlZml4K25hbWUgXSA9PT0gdW5kZWZpbmVkICkgb2JqWyBwcmVmaXgrbmFtZSBdID0ge31cblxuICAgIG9ialsgcHJlZml4K25hbWUgXS5zZXF1ZW5jZXJzID0gW11cbiAgICBvYmpbIHByZWZpeCtuYW1lIF0uc2VxID0gZnVuY3Rpb24gKCB2YWx1ZXMsIHRpbWluZ3MsIG51bWJlciA9IDAsIGRlbGF5ID0gMCApIHtcbiAgICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgKSB2YWx1ZS5uYW1lID0gb2JqLm5hbWVcbiAgICAgIGNvbnN0IHR5cGUgPSBvYmoudHlwZSA9PT0gJ2dlbicgPyAnYXVkaW8nIDogb2JqLnR5cGVcbiAgICAgIEdpYmJlci5TZXEoeyBcbiAgICAgICAgdmFsdWVzLCBcbiAgICAgICAgdGltaW5ncywgXG4gICAgICAgIHRhcmdldDpvYmosXG4gICAgICAgIGtleTpuYW1lLFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgZGVsYXksXG4gICAgICAgIG51bWJlcixcbiAgICAgICAgc3RhbmRhbG9uZTpmYWxzZSxcbiAgICAgICAgbmFtZTpvYmoubmFtZVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIG9ialsgcHJlZml4K25hbWUgXS50aWRhbCA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCAgbnVtYmVyID0gMCwgZGVsYXkgPSAwICkge1xuICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB2YWx1ZS5uYW1lID0gb2JqLm5hbWVcbiAgICAgIGNvbnN0IHR5cGUgPSBvYmoudHlwZSA9PT0gJ2dlbicgPyAnYXVkaW8nIDogb2JqLnR5cGVcbiAgICAgIGNvbnN0IHMgPSBHaWJiZXIuVGlkYWwoeyBcbiAgICAgICAgcGF0dGVybiwgXG4gICAgICAgIHRhcmdldDpvYmosIFxuICAgICAgICBrZXk6bmFtZSxcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBkZWxheSxcbiAgICAgICAgc3RhbmRhbG9uZTpmYWxzZVxuICAgICAgfSlcblxuICAgICAgLy8gcmV0dXJuIG9iamVjdCBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuICB9XG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpYmJlciBcbiIsImNvbnN0IHBhdHRlcm5XcmFwcGVyID0gZnVuY3Rpb24oIEdpYmJlciApIHtcbiAgXCJ1c2Ugc3RyaWN0XCJcblxuICAvLyBoYWNrIHRvIHBhc3MgR2liYmVyaXNoIHRvIHBhdHRlcm4gZ2VuZXJhdG9yIGZyb20gd2l0aGluIHdvcmtsZXQgcHJvY2Vzc29yXG4gIGxldCBHaWJiZXJpc2hcbiAgaWYoIEdpYmJlci5HaWJiZXJpc2ggPT09IHVuZGVmaW5lZCApIHtcbiAgICBHaWJiZXJpc2ggPSBHaWJiZXIuQXVkaW8gIT09IHVuZGVmaW5lZCA/IEdpYmJlci5BdWRpby5HaWJiZXJpc2ggOiBHaWJiZXIgXG4gIH1lbHNle1xuICAgIEdpYmJlcmlzaCA9IEdpYmJlci5HaWJiZXJpc2hcbiAgfVxuXG4gIGxldCBQYXR0ZXJuUHJvdG8gPSBPYmplY3QuY3JlYXRlKCBmdW5jdGlvbigpe30gKVxuXG4gIC8vIHRoaXMgcHJvdG90eXBlIGlzIHNvbWV3aGF0IGxpbWl0ZWQsIGFzIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBhZGRcbiAgLy8gLnNlcSgpIG1ldGhvZHMgdG8gZXZlcnl0aGluZy4gVGhpcyBtZWFucyB0aGF0IGV2ZXJ5IHBhdHRlcm4gbmVlZHMgaXRzIG93blxuICAvLyBjb3B5IG9mIGVhY2ggbWV0aG9kLiBPbmUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gdXNlIGEgbW9yZSBjb21wcmVoZW5zaXZlXG4gIC8vIHByb3RvdHlwZSBhbmQgdGhlbiBwbGFjZSBwcm94aWVzIG9uIGVhY2ggbWV0aG9kIG9mIGVhY2ggcGF0dGVybiB0aGF0IGFjY2Vzc1xuICAvLyBvYmplY3Qtc3BlY2lmaWMgc2VxdWVuY2Vycy4uLiBidXQganVzdCBtYWtpbmcgY29waWVzIG9mIGFsbCBmdW5jdGlvbnMgaXMgY2VydGFpbmx5XG4gIC8vIHNpbXBsZXIuXG4gIE9iamVjdC5hc3NpZ24oIFBhdHRlcm5Qcm90bywge1xuICAgIHR5cGU6J3BhdHRlcm4nLFxuICAgIEROUjogLTk4NzY1NDMyMSxcbiAgICBjb25jYXQoIF9wYXR0ZXJuICkgeyB0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzLmNvbmNhdCggX3BhdHRlcm4udmFsdWVzICkgfSwgIFxuICAgIC8vdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnZhbHVlcy50b1N0cmluZygpIH0sXG4gICAgLy92YWx1ZU9mKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMgfSxcblxuICAgIF9fbWVzc2FnZSggIGtleSwgYXJncyApIHtcbiAgICAgIGlmKCB0aGlzLmNhdGVnb3J5ID09PSAnYXVkaW8nICkge1xuICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InIClcbiAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLm1lc3NhZ2VzLnB1c2goIHRoaXMuaWQsIGtleSwgYXJncyApXG4gICAgICB9IFxuICAgIH0sXG5cbiAgICBnZXRMZW5ndGgoKSB7XG4gICAgICBsZXQgbFxuICAgICAgaWYoIHRoaXMuc3RhcnQgPD0gdGhpcy5lbmQgKSB7XG4gICAgICAgIGwgPSB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKyAxXG4gICAgICB9ZWxzZXtcbiAgICAgICAgbCA9IHRoaXMudmFsdWVzLmxlbmd0aCArIHRoaXMuZW5kIC0gdGhpcy5zdGFydCArIDFcbiAgICAgIH1cbiAgICAgIHJldHVybiBsXG4gICAgfSxcblxuICAgIHJ1bkZpbHRlcnMoIHZhbCwgaWR4ICkge1xuICAgICAgbGV0IGFyZ3MgPSBbIHZhbCwgMSwgaWR4IF0gLy8gMSBpcyBwaGFzZU1vZGlmaWVyXG5cbiAgICAgIGZvciggbGV0IGZpbHRlciBvZiB0aGlzLmZpbHRlcnMgKSB7XG4gICAgICAgIGNvbnN0IF9fYXJncyA9IGFyZ3NcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzID0gZmlsdGVyKCBhcmdzLCB0aGlzICkgXG4gICAgICAgIH0gY2F0Y2goIGUgKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvciggZSApXG4gICAgICAgICAgY29uc29sZS5sb2coICdmaWx0ZXIgcHJvYmxlbT8nIClcbiAgICAgICAgICBjb25zb2xlLmxvZyggYHJlbW92aW5nIGJhZCBmaWx0ZXIgZnJvbSBwYXR0ZXJuOiAke2ZpbHRlci50b1N0cmluZygpfWAgKSBcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbHRlcnMuaW5kZXhPZiggZmlsdGVyIClcbiAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgICAgIGFyZ3MgPSBfX2FyZ3NcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBYWFggd2h5IGlzIHRoaXMgb25lIG9mZiBmcm9tIHRoZSB3b3JrbGV0LXNpZGUgcGF0dGVybiBpZD9cbiAgICAgIHRoaXMuX19tZXNzYWdlKCAndXBkYXRlLnZhbHVlJywgYXJncy5vdmVycmlkZSA9PT0gdW5kZWZpbmVkID8gYXJnc1swXSA6IGFyZ3Mub3ZlcnJpZGUgKSBcbiAgICAgIHRoaXMuX19tZXNzYWdlKCAndXBkYXRlLmN1cnJlbnRJbmRleCcsIGFyZ3NbMl0gKSBcbiAgICAgIGlmKCB0aGlzLmlzR2VuID09PSB0cnVlICkge1xuICAgICAgICB0aGlzLl9fbWVzc2FnZSggJ3dhdmVmb3JtUG9pbnQnLCBhcmdzLm92ZXJyaWRlID09PSB1bmRlZmluZWQgPyBhcmdzWzBdIDogYXJncy5vdmVycmlkZSApIFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJnc1xuICAgIH0sXG5cbiAgICBjaGVja0ZvclVwZGF0ZUZ1bmN0aW9uKCBuYW1lLCAuLi5hcmdzICkge1xuICAgICAgaWYoIHRoaXMuX19kZWxheUFubm90YXRpb25zID09PSB0cnVlICkge1xuICAgICAgICBzZXRUaW1lb3V0KCAoKT0+IHtcbiAgICAgICAgICBpZiggdGhpcy5saXN0ZW5lcnNbIG5hbWUgXSApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzWyBuYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICAgICAgICAgIH1lbHNlIGlmKCBQYXR0ZXJuLmxpc3RlbmVyc1sgbmFtZSBdICkge1xuICAgICAgICAgICAgUGF0dGVybi5saXN0ZW5lcnNbIG5hbWUgXS5hcHBseSggdGhpcywgYXJncyApXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1IClcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggdGhpcy5saXN0ZW5lcnNbIG5hbWUgXSApIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1sgbmFtZSBdLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgICAgICAgfWVsc2UgaWYoIFBhdHRlcm4ubGlzdGVuZXJzWyBuYW1lIF0gKSB7XG4gICAgICAgICAgUGF0dGVybi5saXN0ZW5lcnNbIG5hbWUgXS5hcHBseSggdGhpcywgYXJncyApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdXNlZCB3aGVuIF9vbmNoYW5nZSBoYXMgbm90IGJlZW4gYXNzaWduZWQgdG8gaW5kaXZpZHVhbCBwYXR0ZXJuc1xuICAgIF9vbmNoYW5nZSgpIHt9LFxuXG4gICAgLy8gWFhYIGl0IHdvdWxkIGJlIG5pY2UgaWYgZmlsdGVycyB1c2VkIGEgc2ltaWxhciBzdHlsZSB0byBmeCBjaGFpbnMuLi5cbiAgICAvLyBwYXR0ZXJuLmZpbHRlcnMuYWRkKCApIGV0Yy5cbiAgICBhZGRGaWx0ZXIoIGZpbHRlciwgbmFtZT1udWxsICkge1xuICAgICAgaWYoIG5hbWUgIT09IG51bGwgKSB7XG4gICAgICAgIGZpbHRlci5fX25hbWUgPSBuYW1lXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZmlsdGVycy5maW5kSW5kZXgoIGYgPT4gZi5fX25hbWUgPT09IG5hbWUgKVxuICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKCBpZHgsIDEgKSAgXG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlcnMucHVzaCggZmlsdGVyIClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIHJlbW92ZUZpbHRlciggaWR4PW51bGwgKSB7XG4gICAgICBpZiggaWR4ICE9PSBudWxsICkge1xuICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKCBpZHgsIDEgKSAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5maWx0ZXJzLmxlbmd0aCA9IDBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgaW5zcGVjdCgpIHtcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSBcbiAgICAgICAgY29uc29sZS50YWJsZSh7IHZhbHVlczp0aGlzLnZhbHVlcy50b1N0cmluZygpLCAnbnVtYmVyIG9mIGZpbHRlcnMnOnRoaXMuZmlsdGVycy5sZW5ndGgsIHBoYXNlOnRoaXMucGhhc2UgfSlcbiAgICB9LFxuXG4gICAgcmVuZGVyKCBjYXQ9J0F1ZGlvJyApIHtcbiAgICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRcbiAgICAgIGlmKCB0eXBlb2YgR2liYmVyWyBjYXQgXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIEdpYmJlclsgY2F0IF0ucGF0dGVyblJlbmRlciA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgR2liYmVyWyBjYXQgXS5wYXR0ZXJuUmVuZGVyKCB0aGlzIClcbiAgICAgIH1cbiAgICAgIGlmKCB0eXBlb2YgdGhpcy5vbnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgdGhpcy5vbnJlbmRlcigpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvcHkoKSB7XG4gICAgICBjb25zdCBwID0gUGF0dGVybiggLi4udGhpcy52YWx1ZXMgKVxuICAgICAgLy90aGlzLmZpbHRlcnMuZm9yRWFjaCggZiA9PiBwLmFkZEZpbHRlciggZiApIClcbiAgICAgIHAuc3RhcnQgPSB0aGlzLnN0YXJ0XG4gICAgICBwLmVuZCAgID0gdGhpcy5lbmRcbiAgICAgIHAucGhhc2UgPSB0aGlzLnBoYXNlXG5cbiAgICAgIHJldHVybiBwXG4gICAgfSxcblxuICAgIF9fbWV0aG9kTmFtZXM6ICBbXG4gICAgICAncm90YXRlJywnc3dpdGNoJywnaW52ZXJ0JywnZmxpcCcsXG4gICAgICAndHJhbnNwb3NlJywncmV2ZXJzZScsJ3NodWZmbGUnLCdzY2FsZScsXG4gICAgICAnc3RvcmUnLCAncmFuZ2UnLCAnc2V0JywgJ2ZyZWV6ZScsICd0aGF3JywgJ2RvdWJsZSdcbiAgICBdXG5cbiAgfSlcblxuICBjb25zdCBQYXR0ZXJuID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgLy9jb25zb2xlLmxvZyggJ2FyZ3NbMF06JywgYXJnc1swXS5pc1BhdHRlcm4sIGFyZ3NbMF0gKVxuICAgIC8vaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nICYmIGFyZ3NbMF0gIT09IG51bGwgJiYgYXJnc1swXS5pc1BhdHRlcm4gPT09IHRydWUgKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKCAnZ290IHBhdHRlcm4nIClcbiAgICAvLyAgcmV0dXJuIGFyZ3NbMF1cbiAgICAvL31cblxuICAgIGNvbnN0IGlzRnVuY3Rpb24gPSBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBpc0dlbiA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdLl9faXNHZW5cblxuICAgIC8vaWYoIGlzR2VuID09PSB0cnVlICkgeyBcbiAgICAvLyAgLy8gbXVzdCBoYXZlIGEgcHJpb3JpdHkgb3IgaXQgc2NyZXdzIHVzIGNvZGVnZW4gZm9yIGFuYWx5c2lzXG4gICAgLy8gIGFyZ3NbMF0ucHJpb3JpdHkgPSAwXG4gICAgLy8gIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggYXJnc1swXSApXG4gICAgLy8gIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG4gICAgLy99XG5cblxuICAgIGNvbnN0IGZuYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGxlbiA9IGZuYy5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBpZHgsIHZhbCwgYXJnc1xuXG4gICAgICBpZiggbGVuID09PSAxICkgeyBcbiAgICAgICAgaWR4ID0gMCBcbiAgICAgIH1lbHNle1xuICAgICAgICBpZHggPSBmbmMucGhhc2UgPiAtMSA/IE1hdGguZmxvb3IoIGZuYy5zdGFydCArIChmbmMucGhhc2UgJSBsZW4gKSApIDogTWF0aC5mbG9vciggZm5jLmVuZCArIChmbmMucGhhc2UgJSBsZW4gKSApXG4gICAgICB9XG5cbiAgICAgIGlmKCBpc0Z1bmN0aW9uICkge1xuICAgICAgICB2YWwgPSBmbmMudmFsdWVzWyAwIF0oKVxuICAgICAgICBhcmdzID0gZm5jLnJ1bkZpbHRlcnMoIHZhbCwgaWR4IClcbiAgICAgICAgdmFsID0gYXJnc1swXVxuICAgICAgfSBlbHNlIGlmKCBpc0dlbiA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdmFsID0gZm5jLnZhbHVlc1sgMCBdLmNhbGxiYWNrLm91dFswXVxuXG4gICAgICAgIGFyZ3MgPSBmbmMucnVuRmlsdGVycyggdmFsLCBpZHggKVxuICAgICAgICB2YWwgPSBhcmdzWzBdXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdmFsID0gZm5jLnZhbHVlc1sgTWF0aC5mbG9vciggaWR4ICUgZm5jLnZhbHVlcy5sZW5ndGggKSBdXG4gICAgICAgIGFyZ3MgPSBmbmMucnVuRmlsdGVycyggdmFsLCBpZHggKVxuICAgICAgXG4gICAgICAgIGZuYy5waGFzZSArPSBmbmMuc3RlcFNpemUgKiBhcmdzWyAxIF1cblxuXG4gICAgICAgIHZhbCA9IGFyZ3NbIDAgXVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGFuZCBpZiBzbyBldmFsdWF0ZSBpdFxuICAgICAgLy9pZiggdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgLy92YWwgPSB2YWwoKVxuICAgICAgLy99XG4gICAgICAvKmVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcbiAgICAgICAgLy8gaWYgdmFsIGlzIGFuIEFycmF5LCBsb29wIHRocm91Z2ggYXJyYXkgYW5kIGV2YWx1YXRlIGFueSBmdW5jdGlvbnMgZm91bmQgdGhlcmUuIFRPRE86IElTIFRISVMgU01BUlQ/XG5cbiAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBpZiggdHlwZW9mIHZhbFsgaSBdID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgdmFsWyBpIF0gPSB2YWxbIGkgXSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgICAvL1hYWCBpcyB0aGlzIG5lZWRlZD8gQWRkaW5nIGl0IGludGVyZmVyZXMgd2l0aCBTdGVwc1xuICAgICAgLy9pZiggdmFsID09PSBmbmMuRE5SICkgdmFsID0gbnVsbFxuXG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG5cblxuICAgIGxldCBvdXQgXG4gICAgT2JqZWN0LmFzc2lnbiggZm5jLCB7XG4gICAgICBjYXRlZ29yeTonYXVkaW8nLFxuICAgICAgc3RhcnQgOiAwLFxuICAgICAgZW5kICAgOiAwLFxuICAgICAgcGhhc2UgOiAwLFxuICAgICAgdmFsdWVzIDogYXJncywgXG4gICAgICBpc1BhdHRlcm46IHRydWUsXG4gICAgICBfX2Zyb3plbjpmYWxzZSxcbiAgICAgIC8vIHdyYXAgYW5ub3RhdGlvbiB1cGRhdGUgaW4gc2V0VGltZW91dCggZnVuYywgMCApXG4gICAgICBfX2RlbGF5QW5ub3RhdGlvbnM6ZmFsc2UsXG4gICAgICAvL3ZhbHVlcyA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdzdHJpbmcnIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApIDogYXJndW1lbnRzWzBdLnNwbGl0KCcnKSwgICAgXG4gICAgICBvcmlnaW5hbCA6IG51bGwsXG4gICAgICBzdG9yYWdlIDogW10sXG4gICAgICBzdGVwU2l6ZSA6IDEsXG4gICAgICBpbnRlZ2Vyc09ubHkgOiBmYWxzZSxcbiAgICAgIGZpbHRlcnMgOiBbXSxcbiAgICAgIF9fbGlzdGVuZXJzOiBbXSxcbiAgICAgIG9uY2hhbmdlIDogbnVsbCxcbiAgICAgIGlzb3A6dHJ1ZSxcbiAgICAgIGlzR2VuLFxuXG4gICAgICBmcmVlemUoIHNob3VsZEZyZWV6ZVRoZW9yeSA9IHRydWUgKSB7XG4gICAgICAgIGZuYy5fX2Zyb3plbiA9IHRydWVcbiAgICAgIH0sXG4gICAgICB0aGF3KCkge1xuICAgICAgICBmbmMuX19mcm96ZW4gPSBmYWxzZVxuICAgICAgICBHaWJiZXIuVGhlb3J5LnRoYXcoKVxuICAgICAgfSxcblxuICAgICAgc2V0U2VxKCBzZXEgKSB7XG4gICAgICAgIHRoaXMuc2VxID0gc2VxXG4gICAgICB9LFxuXG4gICAgICByYW5nZSguLi5hcmdzKSB7XG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnJhbmdlKCAuLi5hcmdzIClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgbGV0IHN0YXJ0LCBlbmRcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggYXJndW1lbnRzWzBdICkgKSB7XG4gICAgICAgICAgICBzdGFydCA9IGFyZ3VtZW50c1swXVswXVxuICAgICAgICAgICAgZW5kICAgPSBhcmd1bWVudHNbMF1bMV1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHN0YXJ0ID0gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICBlbmQgICA9IGFyZ3VtZW50c1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggc3RhcnQgPCBlbmQgKSB7XG4gICAgICAgICAgICBmbmMuc3RhcnQgPSBzdGFydFxuICAgICAgICAgICAgZm5jLmVuZCA9IGVuZFxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgZm5jLnN0YXJ0ID0gZW5kXG4gICAgICAgICAgICBmbmMuZW5kID0gc3RhcnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlRnVuY3Rpb24oICdyYW5nZScsIGZuYyApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuICAgICAgZG91YmxlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQuZG91YmxlKC4uLmFyZ3MpXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcblxuICAgICAgICAgIGZuYy52YWx1ZXMucHVzaCggLi4uZm5jLnZhbHVlcyApIFxuICAgICAgICAgIFxuICAgICAgICAgIGZuYy5lbmQgPSBmbmMudmFsdWVzLmxlbmd0aCAtIDFcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBpZiggZm5jLmVuZCA+IGZuYy52YWx1ZXMubGVuZ3RoIC0gMSApIHtcbiAgICAgICAgICAvLyAgIGZuYy5lbmQgPSBmbmMudmFsdWVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAvLyB9ZWxzZSBpZiggZm5jLmVuZCA8IClcbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ3ZhbHVlcycsIGZuYy52YWx1ZXMgKSBcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICdfb25jaGFuZ2UnLCB0cnVlICkgXG4gICAgICAgICAgfVxuICAgICAgICAgIGZuYy5fb25jaGFuZ2UoKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LCAgIFxuXG4gICAgICBzZXQoLi4uYXJncykge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5zZXQoLi4uYXJncylcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIGxldCBhcmdzID0gQXJyYXkuaXNBcnJheSggYXJndW1lbnRzWyAwIF0gKSA/IGFyZ3VtZW50c1sgMCBdIDogYXJndW1lbnRzXG4gICAgICAgICAgXG4gICAgICAgICAgZm5jLnZhbHVlcy5sZW5ndGggPSAwXG5cbiAgICAgICAgICBjb25zdCB0bXAgPSBbXSBcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBhcmdzW2ldLmlzUGF0dGVybiA9PT0gdHJ1ZSA/IGFyZ3NbIGkgXS5vcmlnaW5hbC5zbGljZSgwKSA6IGFyZ3NbIGkgXSBcbiAgICAgICAgICAgIHRtcC5wdXNoKCB2YWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmbmMudmFsdWVzID0gdG1wXG4gICAgICAgICAgXG4gICAgICAgICAgZm5jLmVuZCA9IGZuYy52YWx1ZXMubGVuZ3RoIC0gMVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmKCBmbmMuZW5kID4gZm5jLnZhbHVlcy5sZW5ndGggLSAxICkge1xuICAgICAgICAgIC8vICAgZm5jLmVuZCA9IGZuYy52YWx1ZXMubGVuZ3RoIC0gMVxuICAgICAgICAgIC8vIH1lbHNlIGlmKCBmbmMuZW5kIDwgKVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9XG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3NldCcsIGZuYy52YWx1ZXMgKSAvL2FyZ3MgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuICAgICAgIFxuICAgICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQucmV2ZXJzZSgpXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBsZXQgYXJyYXkgPSBmbmMudmFsdWVzLFxuICAgICAgICAgICAgICBsZWZ0ID0gbnVsbCxcbiAgICAgICAgICAgICAgcmlnaHQgPSBudWxsLFxuICAgICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgIHRlbXBvcmFyeTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgZm9yICggbGVmdCA9IDAsIHJpZ2h0ID0gbGVuZ3RoIC0gMTsgbGVmdCA8IHJpZ2h0OyBsZWZ0ICs9IDEsIHJpZ2h0IC09IDEgKSB7XG4gICAgICAgICAgICB0ZW1wb3JhcnkgPSBhcnJheVsgbGVmdCBdXG4gICAgICAgICAgICBhcnJheVsgbGVmdCBdID0gYXJyYXlbIHJpZ2h0IF1cbiAgICAgICAgICAgIGFycmF5WyByaWdodCBdID0gdGVtcG9yYXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ3ZhbHVlcycsIGFycmF5ICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgdHJ1ZSApIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZuYy5fb25jaGFuZ2UoICdyZXZlcnNlJywgbnVsbCApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgICAvLyBodW1hbml6ZTogZnVuY3Rpb24oIHJhbmRvbU1pbiwgcmFuZG9tTWF4ICkge1xuICAgLy8gICAgICBsZXQgbGFzdEFtdCA9IDBcbiAgIC8vXG4gICAvLyAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrICkge1xuICAgLy8gICAgICAgIGlmKCB0aGlzLmZpbHRlcnNbIGkgXS5odW1hbml6ZSApIHtcbiAgIC8vICAgICAgICAgIGxhc3RBbXQgPSB0aGlzLmZpbHRlcnNbIGkgXS5sYXN0QW10XG4gICAvLyAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKCBpLCAxIClcbiAgIC8vICAgICAgICAgIGJyZWFrO1xuICAgLy8gICAgICAgIH1cbiAgIC8vICAgICAgfVxuICAgLy9cbiAgIC8vICAgICAgbGV0IGZpbHRlciA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICAgLy8gICAgICAgIGNvbnNvbGUubG9nKCBmaWx0ZXIubGFzdEFtdCwgYXJnc1swXSlcbiAgIC8vICAgICAgICBhcmdzWyAwIF0gLT0gZmlsdGVyLmxhc3RBbXRcbiAgIC8vICAgICAgICBmaWx0ZXIubGFzdEFtdCA9IEdpYmJlci5DbG9jay50aW1lKCBHaWJiZXIuVXRpbGl0aWVzLnJuZGkoIHJhbmRvbU1pbiwgcmFuZG9tTWF4ICkgKVxuICAgLy9cbiAgIC8vICAgICAgICBjb25zb2xlLmxvZyggXCJMQVwiLCBmaWx0ZXIubGFzdEFtdCApXG4gICAvLyAgICAgICAgYXJnc1swXSArPSBmaWx0ZXIubGFzdEFtdFxuICAgLy9cbiAgIC8vICAgICAgICByZXR1cm4gYXJnc1xuICAgLy8gICAgICB9XG4gICAvLyAgICAgIGZpbHRlci5sYXN0QW10ID0gbGFzdEFtdFxuICAgLy8gICAgICBmaWx0ZXIuaHVtYW5pemUgPSB0cnVlXG4gICAvL1xuICAgLy8gICAgICB0aGlzLmZpbHRlcnMucHVzaCggZmlsdGVyIClcbiAgIC8vXG4gICAvLyAgICAgIHJldHVybiB0aGlzXG4gICAvLyAgICB9LFxuICAgICAgcmVwZWF0KCkge1xuICAgICAgICBsZXQgY291bnRzID0ge31cbiAgICAgIFxuICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0yICkge1xuICAgICAgICAgIGNvdW50c1sgYXJndW1lbnRzWyBpIF0gXSA9IHtcbiAgICAgICAgICAgIHBoYXNlOiAwLFxuICAgICAgICAgICAgdGFyZ2V0OiBhcmd1bWVudHNbIGkgKyAxIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCByZXBlYXRpbmcgPSBmYWxzZSwgcmVwZWF0VmFsdWUgPSBudWxsLCByZXBlYXRJbmRleCA9IG51bGxcbiAgICAgICAgbGV0IGZpbHRlciA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGFyZ3NbIDAgXSwgcGhhc2VNb2RpZmllciA9IGFyZ3NbIDEgXSwgb3V0cHV0ID0gYXJnc1xuICAgICAgICAgIFxuICAgICAgICAgIC8vY29uc29sZS5sb2coIGFyZ3MsIGNvdW50cyApXG4gICAgICAgICAgaWYoIHJlcGVhdGluZyA9PT0gZmFsc2UgJiYgY291bnRzWyB2YWx1ZSBdICkge1xuICAgICAgICAgICAgcmVwZWF0aW5nID0gdHJ1ZVxuICAgICAgICAgICAgcmVwZWF0VmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgcmVwZWF0SW5kZXggPSBhcmdzWzJdXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCByZXBlYXRpbmcgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBpZiggY291bnRzWyByZXBlYXRWYWx1ZSBdLnBoYXNlICE9PSBjb3VudHNbIHJlcGVhdFZhbHVlIF0udGFyZ2V0ICkge1xuICAgICAgICAgICAgICBvdXRwdXRbIDAgXSA9IHJlcGVhdFZhbHVlICAgICAgICAgICAgXG4gICAgICAgICAgICAgIG91dHB1dFsgMSBdID0gMFxuICAgICAgICAgICAgICBvdXRwdXRbIDIgXSA9IHJlcGVhdEluZGV4XG4gICAgICAgICAgICAgIC8vWyB2YWwsIDEsIGlkeCBdXG4gICAgICAgICAgICAgIGNvdW50c1sgcmVwZWF0VmFsdWUgXS5waGFzZSsrXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgY291bnRzWyByZXBlYXRWYWx1ZSBdLnBoYXNlID0gMFxuICAgICAgICAgICAgICBvdXRwdXRbIDEgXSA9IDFcbiAgICAgICAgICAgICAgaWYoIHZhbHVlICE9PSByZXBlYXRWYWx1ZSApIHsgXG4gICAgICAgICAgICAgICAgcmVwZWF0aW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY291bnRzWyByZXBlYXRWYWx1ZSBdLnBoYXNlKytcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgZm5jLmZpbHRlcnMucHVzaCggZmlsdGVyIClcbiAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuICAgIFxuICAgICAgcmVzZXQoKSB7IFxuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5yZXNldCgpXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICAvLyBYWFggcmVwbGFjZSB3aXRoIHNvbWUgdHlwZSBvZiBzdGFuZGFyZCBkZWVwIGNvcHlcbiAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggZm5jLm9yaWdpbmFsWzBdICkgKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBbXVxuICAgICAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBmbmMub3JpZ2luYWwubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNob3JkID0gZm5jLm9yaWdpbmFsWyBpIF1cbiAgICAgICAgICAgICAgYXJyWyBpIF0gPSBbXVxuICAgICAgICAgICAgICBmb3IoIGxldCBqID0gMDsgaiA8IGNob3JkLmxlbmd0aDsgaisrICkge1xuICAgICAgICAgICAgICAgIGFyclsgaSBdWyBqIF0gPSBjaG9yZFsgaiBdIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbmMudmFsdWVzID0gYXJyXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBmbmMudmFsdWVzID0gZm5jLm9yaWdpbmFsLnNsaWNlKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZm5jLnNldCggZm5jLm9yaWdpbmFsLnNsaWNlKCAwICkgKTtcbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ3ZhbHVlcycsIGZuYy52YWx1ZXMgKSBcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICdfb25jaGFuZ2UnLCB0cnVlICkgXG4gICAgICAgICAgfSAgXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3Jlc2V0JywgbnVsbCApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm5jIFxuICAgICAgfSxcblxuICAgICAgc3RvcmUoIHBvcyApIHsgZm5jLnN0b3JhZ2VbIHBvcyB8fCBmbmMuc3RvcmFnZS5sZW5ndGggXSA9IGZuYy52YWx1ZXMuc2xpY2UoIDAgKTsgcmV0dXJuIGZuYzsgfSxcblxuICAgICAgdHJhbnNwb3NlKCBhbXQgKSB7IFxuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC50cmFuc3Bvc2UoIGFtdCApXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGZuYy52YWx1ZXMubGVuZ3RoOyBpKysgKSB7IFxuICAgICAgICAgICAgbGV0IHZhbCA9IGZuYy52YWx1ZXNbIGkgXVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgIGZvciggbGV0IGogPSAwOyBqIDwgdmFsLmxlbmd0aDsgaisrICkge1xuICAgICAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsWyBqIF0gPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgICAgdmFsWyBqIF0gPSBmbmMuaW50ZWdlcnNPbmx5ID8gTWF0aC5yb3VuZCggdmFsWyBqIF0gKyBhbXQgKSA6IHZhbFsgaiBdICsgYW10XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgIGZuYy52YWx1ZXNbIGkgXSA9IGZuYy5pbnRlZ2Vyc09ubHkgPyBNYXRoLnJvdW5kKCBmbmMudmFsdWVzWyBpIF0gKyBhbXQgKSA6IGZuYy52YWx1ZXNbIGkgXSArIGFtdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIFsndHJhbnNwb3NlJywgYW10XSApIFxuICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAvL2ZuYy5fb25jaGFuZ2UoICd0cmFuc3Bvc2UnLCBhbXQgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuXG4gICAgICBzaHVmZmxlKCkgeyBcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQuc2h1ZmZsZSggKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgR2liYmVyLlV0aWxpdHkuc2h1ZmZsZSggZm5jLnZhbHVlcyApXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3NodWZmdWxlJywgbnVsbCApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG5cbiAgICAgIHNjYWxlKCBhbXQgKSB7IFxuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5zY2FsZSggYW10IClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIGZuYy52YWx1ZXMubWFwKCAodmFsLCBpZHgsIGFycmF5KSA9PiB7XG4gICAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgIGFycmF5WyBpZHggXSA9IHZhbC5tYXAoIGluc2lkZSAgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCB0eXBlb2YgaW5zaWRlID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmbmMuaW50ZWdlcnNPbmx5ID8gTWF0aC5yb3VuZCggaW5zaWRlICogYW10ICkgOiBpbnNpZGUgKiBhbXRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc2lkZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbIGlkeCBdID0gZm5jLmludGVnZXJzT25seSA/IE1hdGgucm91bmQoIHZhbCAqIGFtdCApIDogdmFsICogYW10XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9XG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3NjYWxlJywgYW10IClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcblxuICAgICAgZmxpcCgpIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQuZmxpcCggKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgbGV0IHN0YXJ0ID0gW10sXG4gICAgICAgICAgICAgIG9yZGVyZWQgPSBudWxsXG4gICAgICAgIFxuICAgICAgICAgIG9yZGVyZWQgPSBmbmMudmFsdWVzLmZpbHRlciggZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgbGV0IHNob3VsZFB1c2ggPSBzdGFydC5pbmRleE9mKCBlbGVtICkgPT09IC0xXG4gICAgICAgICAgICBpZiggc2hvdWxkUHVzaCApIHN0YXJ0LnB1c2goIGVsZW0gKVxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFB1c2hcbiAgICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgICBvcmRlcmVkID0gb3JkZXJlZC5zb3J0KCBmdW5jdGlvbiggYSxiICl7IHJldHVybiBhIC0gYiB9IClcbiAgICAgICAgXG4gICAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBmbmMudmFsdWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG9yZGVyZWQuaW5kZXhPZiggZm5jLnZhbHVlc1sgaSBdIClcbiAgICAgICAgICAgIGZuYy52YWx1ZXNbIGkgXSA9IG9yZGVyZWRbIG9yZGVyZWQubGVuZ3RoIC0gcG9zIC0gMSBdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9ICAgICAgIFxuICAgICAgICAgIGZuYy5fb25jaGFuZ2UoICdmbGlwJywgbnVsbCApXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuICAgICAgXG4gICAgICBpbnZlcnQoKSB7XG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLmludmVydCggKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgbGV0IHByaW1lMCA9IGZuYy52YWx1ZXNbIDAgXVxuICAgICAgICAgIFxuICAgICAgICAgIGZvciggbGV0IGkgPSAxOyBpIDwgZm5jLnZhbHVlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgZm5jLnZhbHVlc1sgaSBdID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgbGV0IGludmVyc2UgPSBwcmltZTAgKyAocHJpbWUwIC0gZm5jLnZhbHVlc1sgaSBdKVxuICAgICAgICAgICAgICBmbmMudmFsdWVzWyBpIF0gPSBpbnZlcnNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAnaW52ZXJ0JywgbnVsbCApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgXG4gICAgICBzd2l0Y2goIHRvICkge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5zd2l0Y2goIHRvIClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIGlmKCBmbmMuc3RvcmFnZVsgdG8gXSApIHtcbiAgICAgICAgICAgIGZuYy52YWx1ZXMgPSBmbmMuc3RvcmFnZVsgdG8gXS5zbGljZSggMCApXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGZuYy5fb25jaGFuZ2UoICdzd2l0Y2gnLCB0byApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgXG4gICAgICByb3RhdGUoIGFtdCApIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQucm90YXRlKCBhbXQgKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgaWYoIGFtdCA+IDAgKSB7XG4gICAgICAgICAgICB3aGlsZSggYW10ID4gMCApIHtcbiAgICAgICAgICAgICAgbGV0IGVuZCA9IGZuYy52YWx1ZXMucG9wKClcbiAgICAgICAgICAgICAgZm5jLnZhbHVlcy51bnNoaWZ0KCBlbmQgKVxuICAgICAgICAgICAgICBhbXQtLVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIGlmKCBhbXQgPCAwICkge1xuICAgICAgICAgICAgd2hpbGUoIGFtdCA8IDAgKSB7XG4gICAgICAgICAgICAgIGxldCBiZWdpbiA9IGZuYy52YWx1ZXMuc2hpZnQoKVxuICAgICAgICAgICAgICBmbmMudmFsdWVzLnB1c2goIGJlZ2luIClcbiAgICAgICAgICAgICAgYW10KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ3ZhbHVlcycsIGZuYy52YWx1ZXMgKSBcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICdfb25jaGFuZ2UnLCB0cnVlICkgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3JvdGF0ZScsIGFtdCApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFyKCkge1xuICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICBmb3IoIGxldCBrZXkgb2YgUGF0dGVyblByb3RvLl9fbWV0aG9kTmFtZXMgKSB7XG4gICAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IG91dFsga2V5IF0uc2VxdWVuY2Vycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gbW9zdCBjZXJ0YWlubHkgYmUgb3B0aW1pemVkLCBidXQgSSBoYWQgcmVhbCBwcm9ibGVtc1xuICAgICAgICAgICAgICAvLyBnZXR0aW5nIHRoaXMgY2xlYXJpbmcgdG8gd29yaywgcGVyaGFwcyByZWxhdGVkIHRvIHByb3h5IGJlaGF2aW9ycz9cbiAgICAgICAgICAgICAgY29uc3QgX19zZXEgPSBHaWJiZXIuU2VxLnNlcXVlbmNlcnMuZmluZCggcyA9PiBzLmlkID09PSBvdXRbIGtleSBdWyBpIF0uaWQgKVxuICAgICAgICAgICAgICBpZiggX19zZXEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IGFkZHJlc3M6J21ldGhvZCcsIG9iamVjdDpfX3NlcS5pZCwgbmFtZTonc3RvcCcsIGFyZ3M6W10gfSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgX19zZXEuc3RvcCgpXG4gICAgICAgICAgICAgICAgX19zZXEuY2xlYXIoKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gR2liYmVyLlNlcS5zZXF1ZW5jZXJzLmluZGV4T2YoIF9fc2VxIClcbiAgICAgICAgICAgICAgICBHaWJiZXIuU2VxLnNlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgICAgICAgICAgIF9fc2VxLnRhcmdldFsgX19zZXEua2V5IF1bMF0uc3RvcCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyBnZW5pc2gtYmFzZWQgcGF0dGVybnMgYXJlIGNvbm5lY3RlZCBhcyBhbmFseXplcnMgc28gdGhhdCB0aGV5XG4gICAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byBmZWVkIGludG8gYSBidXMgdG8gZ2V0IHJlbmRlcmVkLiB3ZSBtdXN0IHJlbW92ZSB0aGVtXG4gICAgICAgICAgLy8gZnJvbSB0aGUgYW5hbHlzaXMgYXJyYXkgdG8gZmluYWxpemUgY2xlYXJpbmcuXG4gICAgICAgICAgaWYoIG91dC5pc0dlbiA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IEdpYmJlcmlzaC5hbmFseXplcnMuaW5kZXhPZiggYXJnc1swXSApXG4gICAgICAgICAgICBpZiggaWR4ICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgICAgIEdpYmJlcmlzaC5hbmFseXplcnMuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIGZuYy5pZCA9IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgICAgaWYoIGlzR2VuID09PSB0cnVlICkge1xuICAgICAgICBmbmMud2F2ZWZvcm1Qb2ludCA9IHZhbCA9PiB7XG4gICAgICAgICAgLy8gYWNjb3VudHMgZm9yIGFubm95aW5nIGVkZ2UgY2FzZSB3aGVyZSB3YXZlIHBhdHRlcm4gaXNcbiAgICAgICAgICAvLyBpbmxpbmVkIHRvIGEgY2FsbCB0byAuc2VxXG4gICAgICAgICAgLy8gWFhYIGZpeCBpbiBwYXJzaW5nIG9yIHNvbWVob3cgZmlndXJlIG91dCBob3cgdG8gb25seSBkbyB0aGlzIG9uY2VcbiAgICAgICAgICBpZiggZm5jLndpZGdldCAhPT0gdW5kZWZpbmVkICkgZm5jLnZhbHVlc1swXS53aWRnZXQgPSBmbmMud2lkZ2V0XG4gICAgICAgICAgaWYoIGZuYy52YWx1ZXNbMF0ud2lkZ2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc2FtcGxlcyB0byBiZWF0c1xuICAgICAgICAgICAgaWYoIGZuYy5fX3BhdHRlcm5UeXBlID09PSAndGltaW5ncycgKSB7XG4gICAgICAgICAgICAgIHZhbCA9IEdpYmJlci5DbG9jay5zdG9iKCB2YWwgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5jLnZhbHVlc1swXS53aWRnZXQudmFsdWVzWyBmbmMudmFsdWVzWzBdLndpZGdldC52YWx1ZXMubGVuZ3RoIC0gMSBdID0geyB2YWx1ZTp2YWwgfSBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy9mbmMuZmlsdGVycy5wYXR0ZXJuID0gZm5jXG4gICAgLy8gY2FuIEkgcmVzb3RyZSB0aGlzIHdpdGhvdXQgbWFraW5nIHRoZSBvYmplY3Qgbm9uLXNlcmlhbGl6YWJsZT9cbiAgICAvL2ZuYy5yZXRyb2dyYWRlID0gZm5jLnJldmVyc2UuYmluZCggZm5jIClcbiAgICBcbiAgICBmbmMuZW5kID0gZm5jLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgXG4gICAgLypcbiAgICBmbmMuZmlsdGVycy50ZXN0ID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCAndGVzdCcgKSB9XG4gICAgXG4gICAgZm5jLmZpbHRlcnMuYWRkID0gZnVuY3Rpb24oIGYgKSB7XG4gICAgICB0aGlzLmZpbHRlcnMucHVzaCggZiApXG4gICAgfS5iaW5kKGZuYylcbiAgICBmbmMuZmlsdGVycy5yZW1vdmUgPSBmdW5jdGlvbiggaWR4ICkge1xuICAgICAgY29uc29sZS5sb2coICdmaWx0ZXI6JywgdGhpcyApXG4gICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgIH0uYmluZCggZm5jIClcbiAgICBmbmMuZmlsdGVycy5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyggYHRoZXJlIGFyZSBjdXJyZW5seSAke3RoaXMubGVuZ3RofSBmaWx0ZXJzIG9uIHRoaXMgcGF0dGVybmAgKVxuICAgIH0uYmluZChmbmMpXG4gICAgKi9cblxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBmbmMudmFsdWVzWzBdICkgKSB7XG4gICAgICBjb25zdCBhcnIgPSBbXVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBmbmMudmFsdWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGZuYy52YWx1ZXNbIGkgXVxuICAgICAgICBhcnJbIGkgXSA9IFtdXG4gICAgICAgIGZvciggbGV0IGogPSAwOyBqIDwgY2hvcmQubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgYXJyWyBpIF1bIGogXSA9IGNob3JkWyBqIF0gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZuYy5vcmlnaW5hbCA9IGFyclxuICAgIH1lbHNle1xuICAgICAgZm5jLm9yaWdpbmFsID0gZm5jLnZhbHVlcy5zbGljZSgwKVxuICAgIH1cblxuICAgIGZuYy5zdG9yYWdlWyAwIF0gPSBmbmMub3JpZ2luYWwuc2xpY2UoIDAgKVxuICAgIGZuYy5pbnRlZ2Vyc09ubHkgPSBmbmMudmFsdWVzLmV2ZXJ5KCBmdW5jdGlvbiggbiApIHsgcmV0dXJuIG4gPT09ICtuICYmIG4gPT09IChufDApOyB9KVxuICAgIFxuICAgIGZuYy5saXN0ZW5lcnMgPSB7fVxuICAgIGZuYy5zZXF1ZW5jZXMgPSB7fVxuXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG5cbiAgICAgIGZvciggbGV0IGtleSBvZiBQYXR0ZXJuUHJvdG8uX19tZXRob2ROYW1lcyApIHsgXG4gICAgICAgIEdpYmJlci5hZGRTZXF1ZW5jaW5nKCBmbmMsa2V5LDIsdW5kZWZpbmVkIClcbiAgICAgIH1cbiAgICAgIC8vZm9yKCBsZXQga2V5IG9mIFBhdHRlcm5Qcm90by5fX21ldGhvZE5hbWVzICkgeyBcbiAgICAgIC8vICBmbmMuc2VxdWVuY2Vyc1sga2V5IF0gPSBHaWJiZXIuQ29yZSAhPT0gdW5kZWZpbmVkIFxuICAgICAgLy8gICAgPyBHaWJiZXIuQ29yZS5hZGRTZXF1ZW5jaW5nKCBmbmMsIGtleSwgMiApIFxuICAgICAgLy8gICAgOiBHaWJiZXIuYWRkU2VxdWVuY2luZyggZm5jLGtleSwyIClcbiAgICAgIC8vfVxuICAgICAgZm5jLnNlcXVlbmNlcy5yZXNldCA9IEdpYmJlci5hZGRTZXF1ZW5jaW5nKCBmbmMsICdyZXNldCcsIDEgKVxuICAgIH1cbiAgICBcbiAgICAvLyBUT0RPOiBHaWJiZXIuY3JlYXRlUHJveHlQcm9wZXJ0aWVzKCBmbmMsIHsgJ3N0ZXBTaXplJzowLCAnc3RhcnQnOjAsICdlbmQnOjAgfSlcbiAgICBcbiAgICBmbmMuX19wcm90b19fID0gUGF0dGVyblByb3RvIFxuXG4gICAgbGV0IHBuID0gJydcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGZuYywgJ3BhdHRlcm5OYW1lJywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcG4gfSxcbiAgICAgIHNldChfX3BuKSB7XG4gICAgICAgIHBuID0gX19wblxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmbmMucmVuZGVyID0gZnVuY3Rpb24oIG1vZGU9J2F1ZGlvJyApIHtcbiAgICAgIGlmKCBtb2RlID09PSAnYXVkaW8nICkge1xuICAgICAgICAvLyAnaXNQYXR0ZXJuJyBpcyBhIGhhY2sgdG8gZm9yY2UgcGF0dGVybiBpbml0aWFsaXphdGlvbiBhcmd1bWVudHMgdG8gYmUgc3VibWl0dGVkIGFzXG4gICAgICAgIC8vIGEgbGlzdCwgaW5zdGVhZCBvZiBpbiBhIHByb3BlcnR5IGRpY3Rpb25hcnkuIFdoZW4gJ2lzUGF0dGVybicgaXMgdHJ1ZSwgZ2liYmVyaXNoXG4gICAgICAgIC8vIGxvb2tzIGZvciBhbiAnaW5wdXRzJyBwcm9wZXJ0eSBhbmQgdGhlbiBwYXNzZXMgaXRzIHZhbHVlIChhc3N1bWVkIHRvIGJlIGFuIGFycmF5KVxuICAgICAgICAvLyB1c2luZyB0aGUgc3ByZWFkIG9wZXJhdG9yIHRvIHRoZSBjb25zdHJ1Y3Rvci4gXG4gICAgICAgIG91dCA9IEdpYmJlcmlzaC5Qcm94eSggJ3BhdHRlcm4nLCB7IGlucHV0czpmbmMudmFsdWVzLCBpc1BhdHRlcm46dHJ1ZSwgZmlsdGVyczpmbmMuZmlsdGVycywgaWQ6Zm5jLmlkIH0sIGZuYyApIFxuXG4gICAgICAgIGlmKCBpc0dlbiA9PT0gdHJ1ZSApIHsgXG4gICAgICAgICAgLy8gbXVzdCBoYXZlIGEgcHJpb3JpdHkgb3IgaXQgc2NyZXdzIHVwIGNvZGVnZW4gZm9yIGFuYWx5c2lzXG4gICAgICAgICAgYXJnc1swXS5wcmlvcml0eSA9IDBcbiAgICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnB1c2goIGFyZ3NbMF0gKVxuICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGFyZ3MuZmlsdGVycyApIHtcbiAgICAgICAgYXJncy5maWx0ZXJzLmZvckVhY2goIGYgPT4gb3V0LmFkZEZpbHRlciggZiApIClcbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgYXJnc1swXS5maWx0ZXJzICkge1xuICAgICAgICBhcmdzWzBdLmZpbHRlcnMuZm9yRWFjaCggZiA9PiBvdXQuYWRkRmlsdGVyKCBmICkgKVxuICAgICAgfVxuXG4gICAgICBQYXR0ZXJuLmNoaWxkcmVuLnB1c2goIG91dCApXG5cbiAgICAgIGlmKCBmbmMub25yZW5kZXIgKSBmbmMub25yZW5kZXIoIG91dCApXG5cbiAgICAgIGZuYy5fX3JlbmRlcmVkID0gb3V0XG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHJldHVybiBmbmMucmVuZGVyKClcblxuICAgIHJldHVybiBmbmMgXG4gIH1cblxuICBQYXR0ZXJuLmxpc3RlbmVycyA9IHt9XG4gIFBhdHRlcm4uY2hpbGRyZW4gPSBbXVxuICBQYXR0ZXJuLl9faXNGcm96ZW4gPSBmYWxzZVxuICBQYXR0ZXJuLmZyZWV6ZSA9IGZ1bmN0aW9uKCBzaG91bGRGcmVlemVUaGVvcnkgPSB0cnVlICkge1xuICAgIFBhdHRlcm4uY2hpbGRyZW4uZm9yRWFjaCggcCA9PiBwLmZyZWV6ZSgpICkgXG4gICAgaWYoIHNob3VsZEZyZWV6ZVRoZW9yeSA9PT0gdHJ1ZSApIHtcbiAgICAgIEdpYmJlci5UaGVvcnkuZnJlZXplKClcbiAgICAgIFBhdHRlcm4uX19pc0Zyb3plbiA9IHRydWVcbiAgICB9XG4gIH1cbiAgUGF0dGVybi50aGF3ID0gKCk9PiB7XG4gICAgUGF0dGVybi5jaGlsZHJlbi5mb3JFYWNoKCBwID0+IHAudGhhdygpIClcbiAgICBpZiggUGF0dGVybi5fX2lzRnJvemVuID09PSB0cnVlICkge1xuICAgICAgR2liYmVyLlRoZW9yeS50aGF3KClcbiAgICAgIFBhdHRlcm4uX19pc0Zyb3plbiA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgUGF0dGVybi5leHBvcnQgPSBmdW5jdGlvbiggb2JqICkge1xuICAgIG9iai5mcmVlemUgPSBQYXR0ZXJuLmZyZWV6ZVxuICAgIG9iai50aGF3ICAgPSBQYXR0ZXJuLnRoYXdcbiAgfVxuXG4gIFBhdHRlcm4ubGlzdGVuZXJzLnJhbmdlID0gZnVuY3Rpb24oIGZuYyApIHtcbiAgICAvL2lmKCAhTm90YXRpb24uaXNSdW5uaW5nICkgcmV0dXJuXG4gICAgXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHJldHVyblxuXG4gICAgLy8gVE9ETzogZG9uJ3QgdXNlIEdpYmJlci5jdXJyZW50VHJhY2ssIHN0b3JlIHRoZSBvYmplY3QgaW4gdGhlIHBhdHRlcm5cbiAgICBsZXQgcmFuZ2VTdGFydCA9IGZuYy5tYXJrZXJzWyBmbmMuc3RhcnQgXS5maW5kKCksXG4gICAgICAgIHJhbmdlRW5kICAgPSBmbmMubWFya2Vyc1sgZm5jLmVuZCBdLmZpbmQoKVxuXG4gICAgaWYoICFmbmMucmFuZ2UuaW5pdCApIHtcbiAgICAgIGZuYy5yYW5nZS5pbml0ID0gdHJ1ZVxuICAgICAgdmFyIHB0cm5TdGFydCA9IGZuYy5tYXJrZXJzWyAwIF0uZmluZCgpLFxuICAgICAgICAgIHB0cm5FbmQgPSBmbmMubWFya2Vyc1sgZm5jLm1hcmtlcnMubGVuZ3RoIC0gMSBdLmZpbmQoKVxuXG4gICAgICAvL2ZuYy5jb2x1bW4uZWRpdG9yLm1hcmtUZXh0KCBwdHJuU3RhcnQuZnJvbSwgcHRybkVuZC50bywgeyBjbGFzc05hbWU6J3JhbmdlT3V0c2lkZScgfSlcbiAgICAgIEdpYmJlci5FbnZpcm9ubWVudC5lZGl0b3IubWFya1RleHQoIHB0cm5TdGFydC5mcm9tLCBwdHJuRW5kLnRvLCB7IGNsYXNzTmFtZToncmFuZ2VPdXRzaWRlJyB9KS8vY2xhc3NOYW1lOidwYXR0ZXJuLXVwZGF0ZS1yYW5nZS1vdXRzaWRlJyB9KVxuICAgICAgaWYoICFQYXR0ZXJuLmxpc3RlbmVycy5yYW5nZS5pbml0aWFsemllZCApIFBhdHRlcm4ubGlzdGVuZXJzLnJhbmdlLmluaXQoKVxuICAgIH1cblxuICAgIGlmKCBmbmMucmFuZ2UubWFyayApIGZuYy5yYW5nZS5tYXJrLmNsZWFyKClcbiAgICAvL2ZuYy5yYW5nZS5tYXJrID0gZm5jLmNvbHVtbi5lZGl0b3IubWFya1RleHQoIHJhbmdlU3RhcnQuZnJvbSwgcmFuZ2VFbmQudG8sIHsgY2xhc3NOYW1lOidyYW5nZUluc2lkZScgfSlcbiAgICAvLyBUT0RPOiBEb250IHVzZSBHRS5jb2RlbWlycm9yLi4uIGhvdyBlbHNlIGRvIEkgZ2V0IHRoaXM/IHN0b3JlZCBpbiBwYXR0ZXJuIGlzIGNyZWF0ZWQ/XG4gICAgZm5jLnJhbmdlLm1hcmsgPSBHaWJiZXIuRW52aXJvbm1lbnQuZWRpdG9yLm1hcmtUZXh0KCByYW5nZVN0YXJ0LmZyb20sIHJhbmdlRW5kLnRvLCB7IGNsYXNzTmFtZToncmFuZ2VJbnNpZGUnIH0pXG4gIH1cblxuICBQYXR0ZXJuLmxpc3RlbmVycy5yYW5nZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8kLmluamVjdENTUyh7IFxuICAgIC8vICAnLnJhbmdlT3V0c2lkZSc6IHtcbiAgICAvLyAgICAnY29sb3InOicjNjY2ICFpbXBvcnRhbnQnXG4gICAgLy8gIH0sXG4gICAgLy8gICcucmFuZ2VJbnNpZGUnOiB7XG4gICAgLy8gICAgJ2NvbG9yJzoncmdiYSgxMDIsIDE1MywgMjIxLCAxKSAhaW1wb3J0YW50J1xuICAgIC8vICB9XG4gICAgLy99KVxuICAgIFBhdHRlcm4ubGlzdGVuZXJzLnJhbmdlLmluaXRpYWxpemVkID0gdHJ1ZVxuICB9XG5cbiAgLy9QYXR0ZXJuLnByb3RvdHlwZSA9IFBhdHRlcm5Qcm90byovXG5cbiAgcmV0dXJuIFBhdHRlcm5cblxufVxuXG4vLyBoZWxwZXIgZnVuY3Rpb24gdG8gcGFzcyB0aGUgcGF0dGVybiBjb25zdHJ1Y3RvciB0byB0aGUgZ2liYmVyaXNoIHdvcmtsZXQgcHJvY2Vzc29yLlxucGF0dGVybldyYXBwZXIudHJhbnNmZXIgPSBmdW5jdGlvbiggQXVkaW8sIGNvbnN0cnVjdG9yU3RyaW5nICkge1xuICBpZiggQXVkaW8uR2liYmVyaXNoICE9PSB1bmRlZmluZWQgJiYgQXVkaW8uR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICBBdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGFkZHJlc3M6J2FkZENvbnN0cnVjdG9yJyxcbiAgICAgIG5hbWU6J1BhdHRlcm4nLFxuICAgICAgY29uc3RydWN0b3JTdHJpbmdcbiAgICB9KVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBwYXR0ZXJuV3JhcHBlclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyICkge1xuICBjb25zdCBhZGRWYWx1ZXNGaWx0ZXJzID0gKHNlcSxrZXksdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gc2VxLnZhbHVlc1xuICAgIGNvbnN0IF9fdmFsdWVzID0gc2VxLnZhbHVlc1xuXG4gICAgaWYoIF9fdmFsdWVzLnJhbmRvbUZsYWcgKSB7XG4gICAgICB2YWx1ZXMuYWRkRmlsdGVyKCAoIGFyZ3MscHRybiApID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwdHJuLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgIGNvbnN0IGlkeCA9IE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiByYW5nZSApXG4gICAgICAgIHJldHVybiBbIHB0cm4udmFsdWVzWyBpZHggXSwgMSwgaWR4IF0gXG4gICAgICB9KVxuICAgICAgLy9mb3IoIGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWVzLnJhbmRvbUFyZ3MubGVuZ3RoOyBpKz0yICkge1xuICAgICAgLy8gIHZhbHVlc1BhdHRlcm4ucmVwZWF0KCB0aGlzLnZhbHVlcy5yYW5kb21BcmdzWyBpIF0sIHRoaXMudmFsdWVzLnJhbmRvbUFyZ3NbIGkgKyAxIF0gKVxuICAgICAgLy99XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhdXRvdHJpZyBwYXR0ZXJuc1xuICAgIGlmKCBrZXkgPT09ICdub3RlJyB8fCBrZXkgPT09ICdjaG9yZCcgfHwga2V5ID09PSAndHJpZ2dlcicgfHwga2V5ID09PSAnbm90ZWYnIHx8IGtleSA9PT0gJ3BpY2twbGF5JyApIHtcbiAgICAgIHZhbHVlcy5hZGRGaWx0ZXIoICggYXJncyxwdHJuICkgPT4ge1xuICAgICAgICBpZiggcHRybi5zZXEudGFyZ2V0LmF1dG90cmlnICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgZm9yKCBsZXQgcyBvZiBwdHJuLnNlcS50YXJnZXQuYXV0b3RyaWcgKSB7XG4gICAgICAgICAgICBzLmZpcmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgICAgfSlcbiAgICB9IFxuICB9XG5cbiAgY29uc3QgYWRkVGltaW5nRmlsdGVycyA9IGZ1bmN0aW9uKCBzZXEsa2V5LHJlbmRlck1vZGUgKSB7XG4gICAgY29uc3QgX190aW1pbmdzID0gc2VxLnRpbWluZ3NcbiAgICBpZiggX190aW1pbmdzLnJhbmRvbUZsYWcgKSB7XG4gICAgICBfX3RpbWluZ3MuYWRkRmlsdGVyKCAoIGFyZ3MscHRybiApID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwdHJuLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgIGNvbnN0IGlkeCA9IE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiByYW5nZSApXG4gICAgICAgIHJldHVybiBbIHB0cm4udmFsdWVzWyBpZHggXSwgMSwgaWR4IF0gXG4gICAgICB9KVxuICAgICAgLy9mb3IoIGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWVzLnJhbmRvbUFyZ3MubGVuZ3RoOyBpKz0yICkge1xuICAgICAgLy8gIHZhbHVlc1BhdHRlcm4ucmVwZWF0KCB0aGlzLnZhbHVlcy5yYW5kb21BcmdzWyBpIF0sIHRoaXMudmFsdWVzLnJhbmRvbUFyZ3NbIGkgKyAxIF0gKVxuICAgICAgLy99XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyID0gcmVuZGVyTW9kZSA9PT0gJ0F1ZGlvJyBcbiAgICAgID8gKGFyZ3MscHRybikgPT4ge1xuICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInICkge1xuICAgICAgICAgIGFyZ3NbMF0gPSBHaWJiZXJpc2guQ2xvY2sudGltZSggYXJnc1swXSApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgIH1cbiAgICAgIDogKGFyZ3MscHRybikgPT4ge1xuICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInICkge1xuICAgICAgICAgIGFyZ3NbMF0gPSBHaWJiZXIuQ2xvY2sudGltZSggYXJnc1swXSApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgIH0gIFxuXG4gICAgc2VxLnRpbWluZ3MuYWRkRmlsdGVyKCAoYXJncyxwdHJuKT0+e1xuICAgICAgaWYoIGFyZ3NbMF0gPT09IDAgKSB7XG4gICAgICAgIHB0cm4uc2VxLnN0b3AoKVxuICAgICAgICBjb25zb2xlLndhcm4oICdzZXF1ZW5jZXIgYXR0ZW1wdGluZyB0byBmaXJlIHdpdGggYSB0aW1lIG9mIHplcm87IHRoaXMgd2lsbCByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcCwgc28gdGhlIHNlcXVlbmNlciBoYXMgYmVlbiBzdG9wcGVkLicgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NcbiAgICB9KVxuICAgIHNlcS50aW1pbmdzLmFkZEZpbHRlciggZmlsdGVyICkgXG4gIH1cblxuICBjb25zdCBTZXEgPSBmdW5jdGlvbiggcHJvcHMgKSB7IFxuICAgIGxldCAgIF9fdmFsdWVzICA9IHByb3BzLnZhbHVlc1xuICAgIGNvbnN0IF9fdGltaW5ncyA9IHByb3BzLnRpbWluZ3NcbiAgICBjb25zdCBkZWxheSAgICAgPSBwcm9wcy5kZWxheVxuICAgIGNvbnN0IHRhcmdldCAgICA9IHByb3BzLnRhcmdldFxuICAgIGNvbnN0IGtleSAgICAgICA9IHByb3BzLmtleVxuICAgIGNvbnN0IHByaW9yaXR5ICA9IHByb3BzLnByaW9yaXR5XG4gICAgbGV0ICAgcmF0ZSAgICAgID0gcHJvcHMucmF0ZSB8fCAxXG4gICAgbGV0ICAgZGVuc2l0eSAgID0gcHJvcHMuZGVuc2l0eSB8fCAxXG4gICAgbGV0ICAgYXV0b3RyaWcgID0gZmFsc2VcbiAgICBjb25zdCByZW5kZXIgICAgPSBwcm9wcy5yZW5kZXIgfHwgJ0F1ZGlvJ1xuXG4gICAgY29uc3QgR2liYmVyaXNoID0gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaCAhPT0gdW5kZWZpbmVkID8gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaCA6IG51bGxcblxuICAgIGlmKCBfX3ZhbHVlcy50eXBlID09PSAnZ2VuJyApIHtcbiAgICAgIF9fdmFsdWVzID0gX192YWx1ZXMucmVuZGVyKClcbiAgICB9XG5cbiAgICBpZiggQXJyYXkuaXNBcnJheSggX192YWx1ZXMgKSAmJiBfX3ZhbHVlcy5sZW5ndGggPD0gMCApIHRocm93IEVycm9yKCdhcnJheXMgcGFzc2VkIHRvIHNlcXVlbmNlcyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHZhbHVlIGluc2lkZSBvZiB0aGVtJylcbiAgICAvLyBjb252ZXJ0IHRvIHBhdHRlcm4gaWYgbmVlZGVkIGFuZCByZW5kZXJcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KCBfX3ZhbHVlcyApIFxuICAgICAgPyBHaWJiZXIuUGF0dGVybiggLi4uX192YWx1ZXMgKS5yZW5kZXIoKVxuICAgICAgOiB0eXBlb2YgX192YWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgX192YWx1ZXMuaXNQYXR0ZXJuIFxuICAgICAgICA/IF9fdmFsdWVzLnJlbmRlcigpXG4gICAgICAgIDogX192YWx1ZXMucmVxdWlyZXNSZW5kZXIgXG4gICAgICAgICAgPyBfX3ZhbHVlc1xuICAgICAgICAgIDogR2liYmVyLlBhdHRlcm4oIF9fdmFsdWVzICkucmVuZGVyKClcblxuICAgIC8vIGlmIGFuIGFycmF5IG9mIHZhbHVlcyBpcyBwYXNzZWQsIGxldCB1c2VycyBjYWxsIHBhdHRlcm4gbWV0aG9kIG9uIHRoYXQgYXJyYXksIGZvciBleGFtcGxlOlxuICAgIC8vIGEubm90ZS5zZXEoIGI9WzAsMSwyLDNdLCAxLzQgKVxuICAgIC8vIGIudHJhbnNwb3NlLnNlcSggMSwxIClcbiAgICBpZiggQXJyYXkuaXNBcnJheSggX192YWx1ZXMgKSApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oIF9fdmFsdWVzLCB2YWx1ZXMgKVxuICAgICAgX192YWx1ZXMuYWRkRmlsdGVyID0gdmFsdWVzLmFkZEZpbHRlci5iaW5kKCB2YWx1ZXMgKVxuICAgICAgX192YWx1ZXMucmVtb3ZlRmlsdGVyID0gdmFsdWVzLnJlbW92ZUZpbHRlci5iaW5kKCB2YWx1ZXMgKVxuICAgICAgX192YWx1ZXMuaW5zcGVjdCA9IHZhbHVlcy5pbnNwZWN0LmJpbmQoIHZhbHVlcyApXG4gICAgfSBlbHNlIGlmKCB0eXBlb2YgX192YWx1ZXMgPT09ICdvYmplY3QnICYmIF9fdmFsdWVzLnR5cGU9PT0nZ2VuJyApIHtcbiAgICAgIHByb3BzLnZhbHVlcy5hZGRGaWx0ZXIgPSB2YWx1ZXMuYWRkRmlsdGVyLmJpbmQoIHZhbHVlcyApXG4gICAgICBwcm9wcy52YWx1ZXMucmVtb3ZlRmlsdGVyID0gdmFsdWVzLnJlbW92ZUZpbHRlci5iaW5kKCB2YWx1ZXMgKVxuICAgICAgcHJvcHMudmFsdWVzLmluc3BlY3QgPSB2YWx1ZXMuaW5zcGVjdC5iaW5kKCB2YWx1ZXMgKVxuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgdGltZSB2YWx1ZXNcbiAgICBpZiggdGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBpZiggR2liYmVyWyByZW5kZXIgXS50aW1lUHJvcHNbIHRhcmdldC5uYW1lIF0gIT09IHVuZGVmaW5lZCBcbiAgICAgICAgJiYgR2liYmVyWyByZW5kZXIgXS50aW1lUHJvcHNbIHRhcmdldC5uYW1lIF0uaW5kZXhPZigga2V5ICkgIT09IC0xICApIHtcblxuICAgICAgICBjb25zdCBmaWx0ZXIgPSByZW5kZXIgPT09ICdBdWRpbycgXG4gICAgICAgICAgPyAoYXJncyxwdHJuKSA9PiB7XG4gICAgICAgICAgICAgIGFyZ3NbMF0gPSBHaWJiZXJpc2guQ2xvY2sudGltZSggYXJnc1swXSApXG4gICAgICAgICAgICAgIHJldHVybiBhcmdzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiAoYXJncyxwdHJuKSA9PiB7XG4gICAgICAgICAgICAgIGFyZ3NbMF0gPSBHaWJiZXIuQXVkaW8uQ2xvY2sudGltZSggYXJnc1swXSApXG4gICAgICAgICAgICAgIHJldHVybiBhcmdzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLmFkZEZpbHRlciggZmlsdGVyIClcbiAgICAgIH1cbiAgICB9XG4gXG4gICAgY29uc3QgdGltaW5ncyA9IEFycmF5LmlzQXJyYXkoIF9fdGltaW5ncyApIFxuICAgICAgPyBHaWJiZXIuUGF0dGVybiggLi4uX190aW1pbmdzICkucmVuZGVyKClcbiAgICAgIDogdHlwZW9mIF9fdGltaW5ncyA9PT0gJ2Z1bmN0aW9uJyAmJiBfX3RpbWluZ3MuaXNQYXR0ZXJuIFxuICAgICAgICA/IF9fdGltaW5ncy5yZW5kZXIoKVxuICAgICAgICA6IF9fdGltaW5ncyA9PT0gdW5kZWZpbmVkIHx8IF9fdGltaW5ncyA9PT0gbnVsbCBcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IF9fdGltaW5ncy5yZXF1aXJlc1JlbmRlclxuICAgICAgICAgICAgPyBfX3RpbWluZ3NcbiAgICAgICAgICAgIDogR2liYmVyLlBhdHRlcm4oIF9fdGltaW5ncyApLnJlbmRlcigpXG5cblxuICAgIGlmKCB0aW1pbmdzID09PSBudWxsICkgYXV0b3RyaWcgPSB0cnVlXG5cbiAgICBpZiggQXJyYXkuaXNBcnJheSggX190aW1pbmdzICkgKSB7XG4gICAgICBPYmplY3QuYXNzaWduKCBfX3RpbWluZ3MsIHRpbWluZ3MgKVxuICAgICAgX190aW1pbmdzLmFkZEZpbHRlciA9IHRpbWluZ3MuYWRkRmlsdGVyLmJpbmQoIHRpbWluZ3MgKVxuICAgIH1cbiAgICBpZiggYXV0b3RyaWcgPT09IGZhbHNlICkge1xuICAgICAgdGltaW5ncy5vdXRwdXQgPSB7IHRpbWU6J3RpbWUnLCBzaG91bGRFeGVjdXRlOjAgfVxuICAgICAgdGltaW5ncy5kZW5zaXR5ID0gMVxuXG4gICAgICAvLyBYWFggZGVsYXkgYW5ub3RhdGlvbnMgc28gdGhhdCB0aGV5IG9jY3VyIGFmdGVyIHZhbHVlcyBhbm5vdGF0aW9ucyBoYXZlIG9jY3VycmVkLiBUaGVyZSBtaWdodFxuICAgICAgLy8gbmVlZCB0byBiZSBtb3JlIGNoZWNrcyBmb3IgdGhpcyBmbGFnIGluIHRoZSB2YXJpb3VzIGFubm90YXRpb24gdXBkYXRlIGZpbGVzLi4uIHJpZ2h0IG5vd1xuICAgICAgLy8gdGhlIGNoZWNrIGlzIG9ubHkgaW4gY3JlYXRlQm9yZGVyQ3ljbGUuanMuXG4gICAgICB0aW1pbmdzLl9fZGVsYXlBbm5vdGF0aW9ucyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBhcnJheSBpcyBwYXNzZWQgdG8gdGhlIHNlcSwgZW5hYmxlIHVzZXJzIHRvIGNhbGwgcGF0dGVybiBtZXRob2RzIG9uIGFycmF5XG4gICAgLy9pZiggQXJyYXkuaXNBcnJheSggX190aW1pbmdzICkgKSBPYmplY3QuYXNzaWduKCBfX3RpbWluZ3MsIHRpbWluZ3MgKVxuXG4gICAgY29uc3QgY2xlYXIgPSByZW5kZXIgPT09ICdBdWRpbydcbiAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggdGhpcy52YWx1ZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlcy5jbGVhciAhPT0gdW5kZWZpbmVkICApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmNsZWFyKClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIHRoaXMudGltaW5ncyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudGltaW5ncyAhPT0gbnVsbCAmJiB0aGlzLnRpbWluZ3MuY2xlYXIgIT09IHVuZGVmaW5lZCApIHRoaXMudGltaW5ncy5jbGVhcigpXG5cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IFNlcS5zZXF1ZW5jZXJzLmluZGV4T2YoIHNlcSApXG4gICAgICAgICAgICBzZXEuc3RvcCgpXG4gICAgICAgICAgICBjb25zdCBfX3NlcSA9IFNlcS5zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClbMF1cbiAgICAgICAgICAgIGlmKCBfX3NlcSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBfX3NlcS5zdG9wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggdGhpcy52YWx1ZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlcy5jbGVhciAhPT0gdW5kZWZpbmVkICApIHRoaXMudmFsdWVzLmNsZWFyKClcbiAgICAgICAgICBpZiggdGhpcy50aW1pbmdzICE9PSB1bmRlZmluZWQgJiYgdGhpcy50aW1pbmdzICE9PSBudWxsICYmIHRoaXMudGltaW5ncy5jbGVhciAhPT0gdW5kZWZpbmVkICkgdGhpcy50aW1pbmdzLmNsZWFyKClcblxuICAgICAgICAgIGNvbnN0IGlkeCA9IFNlcS5zZXF1ZW5jZXJzLmluZGV4T2YoIHNlcSApXG4gICAgICAgICAgY29uc3QgX19zZXEgPSBTZXEuc2VxdWVuY2Vycy5zcGxpY2UoIGlkeCwgMSApWzBdXG4gICAgICAgICAgaWYoIF9fc2VxICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBfX3NlcS5zdG9wKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIHZhbHVlcy5fX3BhdHRlcm5UeXBlID0gJ3ZhbHVlcydcbiAgICBpZiggdGltaW5ncyAhPT0gbnVsbCApIHRpbWluZ3MuX19wYXR0ZXJuVHlwZSA9ICd0aW1pbmdzJ1xuXG4gICAgLy9jb25zdCBvZmZzZXRSYXRlID0gR2liYmVyaXNoLmJpbm9wcy5NdWwocmF0ZSwgR2liYmVyLkNsb2NrLkF1ZGlvQ2xvY2sgKVxuXG4gICAgLy8gWFhYIG5lZWQgdG8gZml4IHNvIHRoYXQgd2UgY2FuIHVzZSB0aGUgY2xvY2sgcmF0ZSBhcyB0aGUgYmFzZVxuICAgIC8vIFhYWCBuZWVkIHRvIGFic3RyYWN0IHRoaXMgc28gdGhhdCBhIGdyYXBoaWNzIHNlcXVlbmNlciBjb3VsZCBhbHNvIGJlIGNhbGxlZC4uLlxuICAgIGNvbnN0IHNlcSA9IEdpYmJlci5BdWRpby5HaWJiZXJpc2guU2VxdWVuY2VyKHsgdmFsdWVzLCB0aW1pbmdzLCBkZW5zaXR5LCB0YXJnZXQsIGtleSwgcHJpb3JpdHksIHJhdGU6MS8qR2liYmVyLkNsb2NrLkF1ZGlvQ2xvY2sqLywgY2xlYXIsIGF1dG90cmlnLCBtYWludGhyZWFkb25seTpwcm9wcy5tYWludGhyZWFkb25seSB9KVxuXG4gICAgaWYoIHZhbHVlcy5zZXRTZXEgKSB2YWx1ZXMuc2V0U2VxKCBzZXEgKVxuXG4gICAgYWRkVmFsdWVzRmlsdGVycyggc2VxLGtleSApXG5cbiAgICBpZiggYXV0b3RyaWcgPT09IGZhbHNlICkge1xuICAgICAgYWRkVGltaW5nRmlsdGVycyggc2VxLGtleSxyZW5kZXIgKVxuICAgICAgaWYoIHRpbWluZ3Muc2V0U2VxICkgdGltaW5ncy5zZXRTZXEoIHNlcSApXG4gICAgfWVsc2V7XG4gICAgICBpZiggdGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmKCB0YXJnZXQuYXV0b3RyaWcgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICB0YXJnZXQuYXV0b3RyaWcgPSBbXVxuICAgICAgICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J3Byb3BlcnR5JyxcbiAgICAgICAgICAgIG5hbWU6J2F1dG90cmlnJyxcbiAgICAgICAgICAgIHZhbHVlOltdLFxuICAgICAgICAgICAgb2JqZWN0OnRhcmdldC5pZFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgbmFtZSBrZXkgdmFsdWVcbiAgICAgICAgaWYoIEdpYmJlci5BdWRpby5HaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J2FkZE9iamVjdFRvUHJvcGVydHknLFxuICAgICAgICAgICAgbmFtZTonYXV0b3RyaWcnLFxuICAgICAgICAgICAgb2JqZWN0OnRhcmdldC5pZCxcbiAgICAgICAgICAgIGtleTp0YXJnZXQuYXV0b3RyaWcubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWU6c2VxLmlkXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0YXJnZXQuYXV0b3RyaWcucHVzaCggc2VxIClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHRocm93IEVycm9yKCd5b3UgbXVzdCBkZWZpbmUgdGltaW5ncyBmb3IgYW55IHNlcXVlbmNlIHdpdGhvdXQgYSB0YXJnZXQnKVxuICAgICAgfVxuICAgIH0gXG5cbiAgICAvL0dpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSBmYWxzZVxuICAgIC8vR2liYmVyLlVnZW4uY3JlYXRlUHJvcGVydHkoIHNlcSwgJ2RlbnNpdHknLCB0aW1pbmdzLCBbXSwgR2liYmVyIClcbiAgICAvL0dpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0cnVlXG5cbiAgICBTZXEuc2VxdWVuY2Vycy5wdXNoKCBzZXEgKVxuXG4gICAgLy8gaWYgeC55LnNlcSgpIGV0Yy4gXG4gICAgLy8gc3RhbmRhbG9uZSA9PT0gZmFsc2UgaXMgbW9zdCBjb21tb24gdXNlIGNhc2VcbiAgICBpZiggcHJvcHMuc3RhbmRhbG9uZSA9PT0gZmFsc2UgKSB7IFxuICAgICAgLy8gcmVxdWlyZWQgdGVybmFyeSBiZWNhdXNlIHBhdHRlcm4gbWV0aG9kcyBkb24ndCBoYXZlIF9fIHByZWZpeCBcbiAgICAgIGNvbnN0IHRhcmdldFByb3AgPSB0YXJnZXRbICdfXycgKyBrZXkgXSA9PT0gdW5kZWZpbmVkIFxuICAgICAgICA/IHRhcmdldFsga2V5IF0gXG4gICAgICAgIDogdGFyZ2V0WyAnX18nICsga2V5IF1cbiAgICAgIFxuICAgICAgY29uc3QgcHJldlNlcSA9IHRhcmdldFByb3Auc2VxdWVuY2Vyc1sgcHJvcHMubnVtYmVyIF0gXG4gICAgICBpZiggcHJldlNlcSAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgcHJldlNlcS5jbGVhcigpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIFhYWCB5b3UgaGF2ZSB0byBhZGQgYSBtZXRob2QgdGhhdCBkb2VzIGFsbCB0aGlzIHNoaXQgb24gdGhlIHdvcmtsZXQuIGNyYXAuXG4gICAgICB0YXJnZXRQcm9wLnNlcXVlbmNlcnNbIHByb3BzLm51bWJlciBdID0gc2VxXG4gICAgICB0YXJnZXRQcm9wWyBwcm9wcy5udW1iZXIgXSA9IHNlcSBcbiAgICAgIC8vdGFyZ2V0Ll9fc2VxdWVuY2Vycy5wdXNoKCBzZXEgKVxuICAgICAgaWYoIHR5cGVvZiBkZWxheSAhPT0gJ2Z1bmN0aW9uJyApIHsgXG4gICAgICAgIHNlcS5zdGFydCggR2liYmVyLkF1ZGlvLkNsb2NrLnRpbWUoIGRlbGF5ICkgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsYXkuc2Vxcy5wdXNoKCBzZXEgKVxuICAgICAgfVxuICAgIH1cblxuICAgIEdpYmJlci5wdWJsaXNoKCAnbmV3IHNlcXVlbmNlJywgc2VxIClcblxuICAgIHJldHVybiBzZXFcbiAgfVxuXG4gIFNlcS5zZXF1ZW5jZXJzID0gW11cbiAgU2VxLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgU2VxLnNlcXVlbmNlcnMuZm9yRWFjaCggc2VxID0+IHNlcS5jbGVhcigpIClcbiAgICAvL2ZvciggbGV0IGkgPSBTZXEuc2VxdWVuY2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAvLyAgU2VxLnNlcXVlbmNlcnNbIGkgXS5jbGVhcigpXG4gICAgLy99XG4gICAgU2VxLnNlcXVlbmNlcnMgPSBbXVxuICB9XG4gIFNlcS5ETlIgPSAtOTg3NjU0MzIxXG5cbiAgcmV0dXJuIFNlcVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG4gXG5jb25zdCBTdGVwcyA9IHtcbiAgdHlwZTonU3RlcHMnLFxuICBjcmVhdGUoIF9zdGVwcywgdGFyZ2V0ICkge1xuICAgIGNvbnN0IHN0ZXBzZXEgPSBPYmplY3QuY3JlYXRlKCBTdGVwcyApXG4gICAgXG4gICAgc3RlcHNlcS5zZXFzID0ge31cblxuICAgIGZvciggbGV0IF9rZXkgaW4gX3N0ZXBzICkge1xuICAgICAgbGV0IHZhbHVlcyA9IF9zdGVwc1sgX2tleSBdXG4gICAgICBjb25zdCBwYXJzZWRLZXkgPSBwYXJzZUludCggX2tleSApXG4gICAgICBjb25zdCBrZXkgPSBpc05hTiggcGFyc2VkS2V5ICkgPyBfa2V5IDogcGFyc2VkS2V5XG5cbiAgICAgIGxldCB1c2VzU3RyaW5nVmFsdWVzID0gZmFsc2VcbiAgICAgIGlmKCB2YWx1ZXMuaXNQYXR0ZXJuICE9PSB0cnVlICkge1xuICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdmFsdWVzICkgKSB7XG4gICAgICAgICAgdmFsdWVzID0gR2liYmVyLlBhdHRlcm4oIC4uLnZhbHVlcyApXG4gICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdmFsdWVzID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuc3BsaXQoJycpXG4gICAgICAgICAgdXNlc1N0cmluZ1ZhbHVlcyA9IHRydWVcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdmFsdWVzID0gR2liYmVyLlBhdHRlcm4oIHZhbHVlcyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VxID0gR2liYmVyLlNlcSh7XG4gICAgICAgIHZhbHVlczogdXNlc1N0cmluZ1ZhbHVlcyA/IHZhbHVlcyA6IGtleSxcbiAgICAgICAgdGltaW5nczogdXNlc1N0cmluZ1ZhbHVlcyA/ICBbIDEgIC8gdmFsdWVzLmxlbmd0aCBdIDogdmFsdWVzLFxuICAgICAgICAna2V5JzogdGFyZ2V0Ll9faXNFbnNlbWJsZSAhPT0gdHJ1ZSA/ICdub3RlJyA6ICd0cmlnZ2VyJywgXG4gICAgICAgIHRhcmdldDogdGFyZ2V0Ll9faXNFbnNlbWJsZSA/IHRhcmdldFsgdGFyZ2V0WyBrZXkgXS5uYW1lIF0gOiB0YXJnZXQsIFxuICAgICAgICBwcmlvcml0eTowXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBvbmx5VXNlc1ZlbG9jaXR5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZydcblxuXG4gICAgICBpZiggdXNlc1N0cmluZ1ZhbHVlcyApIHtcbiAgICAgICAgc2VxLnZhbHVlcy5hZGRGaWx0ZXIoIG5ldyBGdW5jdGlvbiggJ2FyZ3MnLCAncHRybicsIFxuICAgICAgICAgYGxldCBzeW0gPSBhcmdzWyAwIF0sXG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gcGFyc2VJbnQoIHN5bSwgMTYgKSAvIDE1XG5cbiAgICAgICAgICBpZiggaXNOYU4oIHZlbG9jaXR5ICkgKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IHN5bSA9PT0gJ3gnIFxuICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgOiBzeW0gPT09ICdYJ1xuICAgICAgICAgICAgICAgID8gMS41XG4gICAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGdldCBhY2Nlc3MgdG8gYmVhdCwgYmVhdE9mZnNldCBhbmQgc2NoZWR1bGVyP1xuICAgICAgICAgIGlmKCB2ZWxvY2l0eSAhPT0gMCApIHtcbiAgICAgICAgICAgICR7IG9ubHlVc2VzVmVsb2NpdHkgPyAnJyA6J3B0cm4uc2VxLnRhcmdldC5fX3RyaWdnZXJMb3VkbmVzcyA9IHZlbG9jaXR5JyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJnc1sgMCBdID0gc3ltID09PSAnLicgPyAtOTg3NjU0MzIxIDogJHt0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/ICd2ZWxvY2l0eScgOiBrZXkgfVxuXG4gICAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgYCkgKVxuICAgICAgfVxuXG4gICAgICBzdGVwc2VxLnNlcXNbIF9rZXkgXSA9IHNlcVxuICAgICAgc3RlcHNlcVsgX2tleSBdID0gdXNlc1N0cmluZ1ZhbHVlcyA/IHNlcS52YWx1ZXMgOiBzZXEudGltaW5nc1xuICAgIH1cblxuICAgIHN0ZXBzZXEuc3RhcnQoKVxuICAgIHN0ZXBzZXEuYWRkUGF0dGVybk1ldGhvZHMoKVxuXG4gICAgcmV0dXJuIHN0ZXBzZXFcbiAgfSxcbiAgXG4gIC8qIHR3byBwYXJ0czpcbiAgICogMS4gVGhlIGVhc3kgcGFydCwgbWFrZSBtZXRob2RzIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgKiAgICBhbmQgcnVuIG92ZXIgZXZlcnkgc2VxIGluc3RhbmNlIGluIHRoZSBzdGVwIHNlcXVlbmNlclxuICAgKiAyLiBUaGUgaGFyZCBwYXJ0LCBtYWtlIGFuIG9iamVjdCB0aGF0IGxpdmVzIGluIHRoZSBhdWRpbyB0aHJlYWRcbiAgICogICAgYW5kIGNhbiBiZSBzZXF1ZW5jZWQuIEl0IG5lZWRzIHJlZmVyZW5jZXMgdG8gYWxsIHNlcXVlbmNlcnMgaW4gdGhlIFxuICAgKiAgICBzdGVwIHNlcXVlbmNlci5cbiAgICovXG4gIGFkZFBhdHRlcm5NZXRob2RzKCkge1xuICAgIC8vIFhYWCBzaG91bGRuJ3QgdXNlIGF1ZGlvIGlkIGJ5IGRlZmF1bHQuLi4gc2lnaFxuICAgIGNvbnN0IGlkID0gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgIC8vIHN0b3JlIGlkcyBvZiBhbGwgY29udHJvbGxlZCBzZXF1ZW5jZXJzXG4gICAgY29uc3Qgc2VxSWRzID0gW11cbiAgICBmb3IoIGxldCBrZXkgaW4gdGhpcy5zZXFzICkge1xuICAgICAgc2VxSWRzLnB1c2goIHRoaXMuc2Vxc1sga2V5IF0uaWQgKVxuICAgIH1cblxuICAgIC8vIHRoaXMgb2JqZWN0IHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gYXVkaW8gdGhyZWFkXG4gICAgY29uc3Qgb2JqID0geyBpZCwgc2VxSWRzIH1cblxuICAgIGdyb3VwTWV0aG9kTmFtZXMuZm9yRWFjaCggbmFtZSA9PiB7XG4gICAgICAvLyBFQVNZIFBBUlQgXG4gICAgICB0aGlzWyBuYW1lIF0gPSBmdW5jdGlvbiggLi4uYXJncyApIHsgXG4gICAgICAgIGZvciggbGV0IGtleSBpbiB0aGlzLnNlcXMgKSB7IFxuICAgICAgICAgIHRoaXMuc2Vxc1sga2V5IF0udmFsdWVzWyBuYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKSBcbiAgICAgICAgfSBcbiAgICAgIH1cblxuICAgICAgdGhpc1sgbmFtZSBdLnNlcXVlbmNlcnMgPSBbXVxuICAgICAgdGhpc1sgbmFtZSBdLnNlcSA9ICggdmFsdWVzLCB0aW1pbmdzLCBudW1iZXIgPSAwLCBkZWxheSA9IDAgKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBHaWJiZXIuU2VxKHsgXG4gICAgICAgICAgdmFsdWVzLCBcbiAgICAgICAgICB0aW1pbmdzLCBcbiAgICAgICAgICB0YXJnZXQ6dGhpcy5fX3dyYXBwZWQsXG4gICAgICAgICAga2V5Om5hbWUsXG4gICAgICAgICAgcHJpb3JpdHk6MSxcbiAgICAgICAgfSkuc3RhcnQoKVxuICAgICAgICBcbiAgICAgICAgdGhpc1sgbmFtZSBdLnNlcXVlbmNlcnMucHVzaCggcyApXG5cbiAgICAgICAgLy8gbmVlZGVkIGZvciBhbm5vdGF0aW9uc1xuICAgICAgICB0aGlzWyBuYW1lIF1bIG51bWJlciBdID0gc1xuXG4gICAgICAgIHJldHVybiB0aGlzIFxuICAgICAgfSBcblxuICAgICAgLy8gc3RvcmUgZnVuY3Rpb24gYm9keSB0byBjcmVhdGUgZnVuY3Rpb24gaW4gYXVkaW8gdGhyZWFkIHJlcHJlc2VudGF0aW9uIG9mIHN0ZXBzXG4gICAgICAvLyBuZWVkcyB0byBiZSBvbmUgbGluZSBmb3Igc3RyaW5naWZ5IC8gcGFyc2luZ1xuICAgICAgLy8gWFhYIHVnaCBhcmd1bWVudHM/IGlzIHRoZXJlIGV2ZXIgbW9yZSB0aGFuIG9uZSBhcmd1bWVudD9cbiAgICAgIG9ialsgbmFtZSBdID0gYGZvciggbGV0IHNlcSBvZiB0aGlzLnNlcXMgKSB7IHNlcS52YWx1ZXMuJHtuYW1lfS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7IHNlcS50aW1pbmdzLiR7bmFtZX0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApfWBcbiAgICB9KVxuXG4gICAgLy8gSEFSRCBQQVJUXG4gICAgLy8gY29kZSB0byBiZSBldmFsdWF0ZWQgaW4gYXVkaW8gdGhyZWFkXG4gICAgLy8gMS4gY3JlYXRlIGEgbmV3IG9iamVjdCwgc3RlcHMsIGJhc3NlZCBvbiBzdHJpbmdpZnlpbmcgb2JqXG4gICAgLy8gMi4gYWRkIGFsbCBvZiB0aGUgdHJhbnNmb3JtIG1ldGhvZHNcbiAgICAvLyAzLiBzdG9yZSBhbGwgY29udHJvbGxlZCBzZXF1ZW5jZXJzIGluIHN0ZXBzLnNlcXMgYWZ0ZXIgZ2V0dGluZyByZWZlcmVuY2VzXG4gICAgLy8gICAgZnJvbSBHaWJiZXJpc2gudWdlbnMgXG4gICAgY29uc3QgY29kZSA9IGBjb25zdCBzdGVwcyA9IEpTT04ucGFyc2UoIFxcYCR7SlNPTi5zdHJpbmdpZnkob2JqKX1cXGAgKVxuICAgICAgY29uc3QgbWV0aG9kcyA9ICR7SlNPTi5zdHJpbmdpZnkoIGdyb3VwTWV0aG9kTmFtZXMgKSB9XG4gICAgICBzdGVwcy5zZXFzID0gc3RlcHMuc2VxSWRzLm1hcCggaWQgPT4gR2liYmVyaXNoLnVnZW5zLmdldCggaWQgKSApXG4gICAgICBmb3IoIGxldCBtZXRob2Qgb2YgbWV0aG9kcyApIHtcbiAgICAgICAgc3RlcHNbIG1ldGhvZCBdID0gbmV3IEZ1bmN0aW9uKCBzdGVwc1sgbWV0aG9kIF0gKSBcbiAgICAgIH1cbiAgICAgIEdpYmJlcmlzaC51Z2Vucy5zZXQoIHN0ZXBzLmlkLCBzdGVwcyApYFxuIFxuICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIGFkZHJlc3M6J2V2YWwnLFxuICAgICAgY29kZVxuICAgIH0pIFxuXG4gICAgdGhpcy5fX3dyYXBwZWQgPSBvYmpcbiAgfSxcblxuICBzdGFydCgpIHtcbiAgICBmb3IoIGxldCBrZXkgaW4gdGhpcy5zZXFzICkgeyBcbiAgICAgIHRoaXMuc2Vxc1sga2V5IF0uc3RhcnQoKVxuICAgIH1cbiAgfSxcblxuICBzdG9wKCkge1xuICAgIGZvciggbGV0IGtleSBpbiB0aGlzLnNlcXMgKSB7IFxuICAgICAgdGhpcy5zZXFzWyBrZXkgXS5zdG9wKClcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXIoKSB7IFxuICAgIHRoaXMuc3RvcCgpIFxuXG4gICAgZm9yKCBsZXQga2V5IGluIHRoaXMuc2VxcyApIHtcbiAgICAgIHRoaXMuc2Vxc1sga2V5IF0udGltaW5ncy5jbGVhcigpXG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgZ3JvdXBNZXRob2ROYW1lcyA9IFsgXG4gICdyb3RhdGUnLCAncmV2ZXJzZScsICd0cmFuc3Bvc2UnLCAncmFuZ2UnLFxuICAnc2h1ZmZsZScsICdzY2FsZScsICdyZXBlYXQnLCAnc3RvcmUnLCBcbiAgJ3Jlc2V0JywnZmxpcCcsICdpbnZlcnQnLCAnc2V0JywgJ2RvdWJsZSdcbl1cblxucmV0dXJuIFN0ZXBzLmNyZWF0ZVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG5cbiAgY29uc3QgU2VxID0gZnVuY3Rpb24oIHByb3BzICkgeyBcbiAgICBjb25zdCBwYXR0ZXJuICAgPSBwcm9wcy5wYXR0ZXJuXG4gICAgY29uc3QgdGFyZ2V0ICAgID0gcHJvcHMudGFyZ2V0XG4gICAgY29uc3Qga2V5ICAgICAgID0gcHJvcHMua2V5XG4gICAgY29uc3QgbnVtYmVyICAgID0gcHJvcHMubnVtYmVyXG4gICAgY29uc3QgZGVsYXkgICAgID0gcHJvcHMuZGVsYXlcbiAgICBjb25zdCBwcmlvcml0eSAgPSBwcm9wcy5wcmlvcml0eSB8fCAwXG4gICAgbGV0ICAgcmF0ZSAgICAgID0gcHJvcHMucmF0ZSB8fCAxXG4gICAgbGV0ICAgZGVuc2l0eSAgID0gcHJvcHMuZGVuc2l0eSB8fCAxXG4gICAgbGV0ICAgYXV0b3RyaWcgID0gZmFsc2VcblxuXG4gICAgY29uc3QgcmVuZGVyICAgID0gdGFyZ2V0LnR5cGUgIT09IHVuZGVmaW5lZCA/IHRhcmdldC50eXBlLnRvTG93ZXJDYXNlKCkgOiAnYXVkaW8nXG4gICAgLy9jb25zdCBHaWJiZXIuQXVkaW8uR2liYmVyaXNoID0gR2liYmVyLkdpYmJlci5BdWRpby5HaWJiZXJpc2ggIT09IHVuZGVmaW5lZCA/IEdpYmJlci5HaWJiZXIuQXVkaW8uR2liYmVyaXNoIDogbnVsbFxuXG4gICAgY29uc3QgY2xlYXIgPSByZW5kZXIgPT09ICdhdWRpbydcbiAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBTZXEuc2VxdWVuY2Vycy5pbmRleE9mKCBzZXEgKVxuICAgICAgICAgICAgc2VxLnN0b3AoKVxuICAgICAgICAgICAgY29uc3QgX19zZXEgPSBTZXEuc2VxdWVuY2Vycy5zcGxpY2UoIGlkeCwgMSApWzBdXG4gICAgICAgICAgICBpZiggX19zZXEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgX19zZXEuc3RvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaWR4ID0gU2VxLnNlcXVlbmNlcnMuaW5kZXhPZiggc2VxIClcbiAgICAgICAgICBjb25zdCBfX3NlcSA9IFNlcS5zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClbMF1cbiAgICAgICAgICBpZiggX19zZXEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIF9fc2VxLnN0b3AoKVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcnMgPSBbXG4gICAgICAvLyByZXBvcnQgYmFjayB0cmlnZ2VyZWQgdG9rZW5zIGZvciBhbm5vdGF0aW9uc1xuICAgICAgZnVuY3Rpb24oIHZhbCwgdGlkYWwsIHVpZCApIHtcbiAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLm1lc3NhZ2VzLnB1c2goIHRpZGFsLmlkLCAndXBkYXRlLnVpZCcsIHVpZCApICAgXG4gICAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5tZXNzYWdlcy5wdXNoKCB0aWRhbC5pZCwgJ3VwZGF0ZS52YWx1ZScsIHZhbCApICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfSBcbiAgICBdXG5cbiAgICBpZigga2V5ID09PSAnbm90ZScgfHwga2V5ID09PSAnY2hvcmQnIHx8IGtleSA9PT0gJ3RyaWdnZXInICkge1xuICAgICAgZmlsdGVycy5wdXNoKCAoIGFyZ3MsdGlkYWwgKSA9PiB7XG4gICAgICAgIGlmKCB0aWRhbC50YXJnZXQuYXV0b3RyaWcgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBmb3IoIGxldCBzIG9mIHRpZGFsLnRhcmdldC5hdXRvdHJpZyApIHtcbiAgICAgICAgICAgIHMuZmlyZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzXG4gICAgICB9KVxuICAgIH1cblxuICAgIGxldCBwXG4gICAgdHJ5IHtcbiAgICAgIHAgPSBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLlRpZGFsLlBhdHRlcm4oIHBhdHRlcm4gKSBcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIEdpYmJlci5wdWJsaXNoKCAnZXJyb3InLCBgXFxuWW91ciBUaWRhbCBwYXR0ZXJuICR7cGF0dGVybn0gdXNlZCBpbnZhbGlkIHN5bnRheC5cXG5gIClcbiAgICAgIC8vY29uc29sZS5sb2coYCVjXFxuWW91ciBUaWRhbCBwYXR0ZXJuICR7cGF0dGVybn0gdXNlZCBpbnZhbGlkIHN5bnRheC5cXG5gLCBgY29sb3I6d2hpdGU7YmFja2dyb3VuZDojOTAwYCApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmKCBrZXkgIT09ICdkZWdyZWUnICkge1xuICAgICAgY29uc3QgdG9rZW5zID0gWy4uLnBhdHRlcm4ubWF0Y2hBbGwoL1thLXpBLVpdKy9nKV0ubWFwKCB2PT52WzBdIClcbiAgICAgIGxldCB0b2tlbk5vdEZvdW5kID0gZmFsc2VcbiAgICAgIHRva2Vucy5mb3JFYWNoKCB0ID0+IHtcbiAgICAgICAgaWYoIHRhcmdldFsgdCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmVycm9yKFxuICAgICAgICAgIC8vICBgJWNcXG5Zb3VyIFRpZGFsIHBhdHRlcm4gaXMgdXNpbmcgYSB0b2tlbiAoJHt0fSkgdGhhdCBjYW4ndCBiZSBmb3VuZCBvbiB0aGUgdGFyZ2V0ZWQgaW5zdHJ1bWVudC5gLCBcbiAgICAgICAgICAvLyAgYGNvbG9yOndoaXRlO2JhY2tncm91bmQ6IzkwMGAgXG4gICAgICAgICAgLy8gICkgXG4gICAgICAgICAgXG4gICAgICAgICAgR2liYmVyLnB1Ymxpc2goICdlcnJvcicsIGBcXG5Zb3VyIFRpZGFsIHBhdHRlcm4gaXMgdXNpbmcgYSB0b2tlbiAoJHt0fSkgdGhhdCBjYW4ndCBiZSBmb3VuZCBvbiB0aGUgdGFyZ2V0ZWQgaW5zdHJ1bWVudC5cXG5gIClcbiAgICAgICAgICB0b2tlbk5vdEZvdW5kID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiggdG9rZW5Ob3RGb3VuZCA9PT0gdHJ1ZSApIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3Qgc2VxID0gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5UaWRhbCh7IHBhdHRlcm4sIHRhcmdldCwga2V5LCBwcmlvcml0eSwgZmlsdGVycywgbWFpbnRocmVhZG9ubHk6cHJvcHMubWFpbnRocmVhZG9ubHkgfSlcbiAgICBzZXEuY2xlYXIgPSBjbGVhclxuICAgIHNlcS51aWQgPSBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLlRpZGFsLmdldFVJRCgpXG4gICAgXG4gICAgLy9HaWJiZXIuQXVkaW8uR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IGZhbHNlXG4gICAgLy9BdWRpby5VZ2VuLmNyZWF0ZVByb3BlcnR5KCBzZXEsICdkZW5zaXR5JywgdGltaW5ncywgW10sIEF1ZGlvIClcbiAgICAvL0dpYmJlci5BdWRpby5HaWJiZXJpc2gucHJveHlFbmFibGVkID0gdHJ1ZVxuXG4gICAgR2liYmVyLmFkZFNlcXVlbmNpbmcoIHNlcSwgJ3JvdGF0ZScsIDEgKVxuXG4gICAgU2VxLnNlcXVlbmNlcnMucHVzaCggc2VxIClcblxuICAgIEdpYmJlci5zdWJzY3JpYmUoICdjbGVhcicsICgpPT4gc2VxLmNsZWFyKCkgKVxuXG4gICAgLy8gaWYgeC55LnRpZGFsKCkgZXRjLiBcbiAgICAvLyBzdGFuZGFsb25lID09PSBmYWxzZSBpcyBtb3N0IGNvbW1vbiB1c2UgY2FzZVxuICAgIGlmKCBwcm9wcy5zdGFuZGFsb25lID09PSBmYWxzZSApIHtcbiAgICAgIGxldCBwcmV2U2VxID0gdGFyZ2V0WyAnX18nICsga2V5IF0udGlkYWxzWyBudW1iZXIgXSBcbiAgICAgIGlmKCBwcmV2U2VxICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmKCB0YXJnZXQuX19zZXF1ZW5jZXJzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0Ll9fc2VxdWVuY2Vycy5pbmRleE9mKCBwcmV2U2VxIClcbiAgICAgICAgICB0YXJnZXQuX19zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFggc3RvcCgpIGRlc3Ryb3lzIGFuIGV4dHJhIHNlcXVlbmNlciBmb3Igc29tZSByZWFzb24/Pz8/XG4gICAgICAgIHByZXZTZXEuc3RvcCgpXG4gICAgICAgIHByZXZTZXEuY2xlYXIoKVxuICAgICAgICAvL3JlbW92ZVNlcSggb2JqLCBwcmV2U2VxIClcbiAgICAgIH1cblxuICAgICAgc2VxLnN0YXJ0KCBHaWJiZXIuQXVkaW8uQ2xvY2sudGltZSggZGVsYXkgKSApXG5cbiAgICAgIHRhcmdldFsgJ19fJyArIGtleSBdLnRpZGFsc1sgbnVtYmVyIF0gPSB0YXJnZXRbICdfXycgKyBrZXkgXVsgbnVtYmVyIF0gPSBzZXFcbiAgICB9XG5cbiAgICBHaWJiZXIucHVibGlzaCggJ25ldyB0aWRhbCcsIHNlcSApXG4gICAgcmV0dXJuIHNlcVxuICB9XG5cbiAgU2VxLnNlcXVlbmNlcnMgPSBbXVxuICBTZXEuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBTZXEuc2VxdWVuY2Vycy5mb3JFYWNoKCBzZXEgPT4gc2VxLmNsZWFyKCkgKVxuICAgIC8vZm9yKCBsZXQgaSA9IFNlcS5zZXF1ZW5jZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgIC8vICBTZXEuc2VxdWVuY2Vyc1sgaSBdLmNsZWFyKClcbiAgICAvL31cbiAgICBTZXEuc2VxdWVuY2VycyA9IFtdXG4gIH1cbiAgU2VxLkROUiA9IC05ODc2NTQzMjFcblxuICBsZXQgdmFsID0gMSBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBTZXEsICdjcHMnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gdmFsIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIHZhbCA9IHZcbiAgICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2guVGlkYWwuY3BzID0gdlxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gU2VxXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcblxuY29uc3QgUGF0dGVybiA9IEdpYmJlci5QYXR0ZXJuXG5cbmNvbnN0IFRyaWdnZXJzID0gZnVuY3Rpb24oIF9fdmFsdWVzICkge1xuICBjb25zdCB2YWx1ZXMgPSBfX3ZhbHVlcy5zcGxpdCgnJylcbiAgY29uc3QgcGF0dGVybiA9IFBhdHRlcm4oIC4uLnZhbHVlcyApIFxuICBwYXR0ZXJuLmlzUGF0dGVybiA9IHRydWVcbiAgcGF0dGVybi50eXBlID0gJ1RyaWdnZXJzJ1xuICAvLyBuZWVkIHRvIGRlZmluZSBjdXN0b20gZnVuY3Rpb24gdG8gdXNlIGtleSBhcyB2YWx1ZVxuICBwYXR0ZXJuLm9ucmVuZGVyID0gZnVuY3Rpb24oIHJlbmRlcmVkICkge1xuICAgIHJlbmRlcmVkLmFkZEZpbHRlciggbmV3IEZ1bmN0aW9uKCAnYXJncycsICdwdHJuJywgXG4gICAgIGBsZXQgc3ltID0gYXJnc1sgMCBdLFxuICAgICAgICAgIHZlbG9jaXR5ID0gcGFyc2VJbnQoIHN5bSwgMTYgKSAvIDE1XG5cbiAgICAgIGlmKCBpc05hTiggdmVsb2NpdHkgKSApIHtcbiAgICAgICAgdmVsb2NpdHkgPSAwXG4gICAgICB9XG5cbiAgICAgIGlmKCB2ZWxvY2l0eSAhPT0gMCApIHtcbiAgICAgICAgcHRybi5zZXEudGFyZ2V0Ll9fdHJpZ2dlckxvdWRuZXNzID0gdmVsb2NpdHlcbiAgICAgIH1cblxuICAgICAgcHRybi5vdXRwdXQgPSB7XG4gICAgICAgIHRpbWUgOiBHaWJiZXJpc2guQ2xvY2sudGltZSggJHsxL3ZhbHVlcy5sZW5ndGh9ICksXG4gICAgICAgIHNob3VsZEV4ZWN1dGU6IHN5bSAhPT0gJy4nID8gMSA6IDBcbiAgICAgIH1cblxuICAgICAgYXJnc1swXSA9IHB0cm4ub3V0cHV0XG5cbiAgICAgIHJldHVybiBhcmdzYFxuICAgICkpXG4gIH1cblxuICByZXR1cm4gcGF0dGVyblxufVxuXG5yZXR1cm4gVHJpZ2dlcnNcblxufVxuIiwibGV0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKVxuXG5sZXQgYW5hbHl6ZXIgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcblxuT2JqZWN0LmFzc2lnbiggYW5hbHl6ZXIsIHtcbiAgX190eXBlX186ICdhbmFseXplcicsXG4gIHByaW9yaXR5OjBcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gYW5hbHl6ZXJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgeyBJbiwgT3V0LCBTU0QgfSA9IHJlcXVpcmUoICcuL3NpbmdsZXNhbXBsZWRlbGF5LmpzJyAgKSggR2liYmVyaXNoIClcblxuICBjb25zdCBhbmFseXplcnMgPSB7XG4gICAgU1NELFxuICAgIFNTRF9JbjogSW4sXG4gICAgU1NEX091dDogT3V0LCBcbiAgICBGb2xsb3c6IHJlcXVpcmUoICcuL2ZvbGxvdy5kc3AuanMnICApKCBHaWJiZXJpc2ggKVxuICB9XG4gIGFuYWx5emVycy5Gb2xsb3dfb3V0ID0gYW5hbHl6ZXJzLkZvbGxvdy5vdXRcbiAgYW5hbHl6ZXJzLkZvbGxvd19pbiAgPSBhbmFseXplcnMuRm9sbG93LmluXG4gIFxuICBhbmFseXplcnMuZXhwb3J0ID0gdGFyZ2V0ID0+IHtcbiAgICBmb3IoIGxldCBrZXkgaW4gYW5hbHl6ZXJzICkge1xuICAgICAgaWYoIGtleSAhPT0gJ2V4cG9ydCcgKSB7XG4gICAgICAgIHRhcmdldFsga2V5IF0gPSBhbmFseXplcnNbIGtleSBdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFuYWx5emVyc1xuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGFuYWx5emVyID0gcmVxdWlyZSggJy4vYW5hbHl6ZXIuanMnICksXG4gICAgICB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgRm9sbG93ID0gZnVuY3Rpb24oIF9fcHJvcHMgKXtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBGb2xsb3cuZGVmYXVsdHMsIF9fcHJvcHMgKVxuXG4gICAgbGV0IGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2VcblxuICAgIGxldCBvdXQgPSBwcm9wcyBcblxuICAgIC8qIGlmIHdlIGFyZSBpbiB0aGUgbWFpbiB0aHJlYWQsXG4gICAgICogb25seSBzZW5kIGEgY29tbWFuZCB0byBtYWtlIGEgRm9sbG93IGluc3RhbmNlXG4gICAgICogdG8gdGhlIHByb2Nlc3NvciB0aHJlYWQgYW5kIGluY2x1ZGUgdGhlIGlkICNcbiAgICAgKiBvZiB0aGUgaW5wdXQgdWdlbi5cbiAgICAgKi9cblxuICAgIC8vY29uc29sZS5sb2coICdpc1N0ZXJlbzonLCBHaWJiZXJpc2gubW9kZSwgaXNTdGVyZW8sIHByb3BzLmlucHV0IClcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIC8vIHNlbmQgb2JqIHRvIGJlIG1hZGUgaW4gcHJvY2Vzc29yIHRocmVhZFxuICAgICAgcHJvcHMuaW5wdXQgPSB7IGlkOiBwcm9wcy5pbnB1dC5pZCB9XG4gICAgICBwcm9wcy5pc1N0ZXJlbyA9IGlzU3RlcmVvXG5cbiAgICAgIC8vIGNyZWF0ZXMgY2xhc2hlcyBpbiBwcm9jZXNzb3IgdGhyZWFkIHVubGVzc1xuICAgICAgLy8gd2Ugc2tpcCBhIG51bWJlciBoZXJlLi4uIG5pY2VcbiAgICAgIEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgICAgcHJvcHMub3ZlcnJpZGVpZCA9IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgICAgLy8gWFhYIHNlZW1zIGxpa2UgdGhpcyBpZCBnZXRzIG92ZXJyaWRkZW4gc29tZXdoZXJlXG4gICAgICAvLyBoZW5jZSAub3ZlcnJpZGVpZFxuICAgICAgcHJvcHMuaWQgPSBwcm9wcy5vdmVycmlkZWlkXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOidhZGQnLFxuXG4gICAgICAgIHByb3BlcnRpZXM6SlNPTi5zdHJpbmdpZnkoIHByb3BzICksXG5cbiAgICAgICAgbmFtZTpbJ2FuYWx5c2lzJywnRm9sbG93J11cbiAgICAgIH0pXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggcHJvcHMub3ZlcnJpZGVpZCwgb3V0IClcblxuICAgICAgbGV0IG11bHQgPSBwcm9wcy5tdWx0aXBsaWVyXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3V0LCAnbXVsdGlwbGllcicsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gbXVsdCB9LFxuICAgICAgICBzZXQodil7XG4gICAgICAgICAgbXVsdCA9IHZcbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgICBhZGRyZXNzOidzZXQnLCBcbiAgICAgICAgICAgIG9iamVjdDpwcm9wcy5vdmVycmlkZWlkLFxuICAgICAgICAgICAgbmFtZTonbXVsdGlwbGllcicsXG4gICAgICAgICAgICB2YWx1ZTptdWx0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgbGV0IG9mZnNldCA9IHByb3BzLm9mZnNldFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvdXQsICdvZmZzZXQnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIG9mZnNldCB9LFxuICAgICAgICBzZXQodil7XG4gICAgICAgICAgb2Zmc2V0ID0gdlxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgIGFkZHJlc3M6J3NldCcsIFxuICAgICAgICAgICAgb2JqZWN0OnByb3BzLm92ZXJyaWRlaWQsXG4gICAgICAgICAgICBuYW1lOidvZmZzZXQnLFxuICAgICAgICAgICAgdmFsdWU6b2Zmc2V0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9ZWxzZXtcbiAgICAgIC8vaXNTdGVyZW8gPSBwcm9wcy5pc1N0ZXJlb1xuXG4gICAgICBjb25zdCBidWZmZXIgPSBnLmRhdGEoIHByb3BzLmJ1ZmZlclNpemUsIDEgKVxuICAgICAgY29uc3QgaW5wdXQgID0gZy5pbiggJ2lucHV0JyApXG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gZy5pbiggJ211bHRpcGxpZXInIClcbiAgICAgIGNvbnN0IG9mZnNldCAgICAgPSBnLmluKCAnb2Zmc2V0JyApXG4gICAgICBcbiAgICAgIGNvbnN0IGZvbGxvd19vdXQgPSBPYmplY3QuY3JlYXRlKCBhbmFseXplciApXG4gICAgICBmb2xsb3dfb3V0LmlkID0gcHJvcHMuaWQgPSBfX3Byb3BzLm92ZXJyaWRlaWRcblxuICAgICAgbGV0IGF2ZyA9IGcuZGF0YSggMSwxLCB7IG1ldGE6dHJ1ZSB9ICkgLy8gb3V0cHV0OyBtYWtlIGF2YWlsYWJsZSBvdXRzaWRlIGpzZHNwIGJsb2NrXG4gICAgICBjb25zdCBpZHggPSBhdmcubWVtb3J5LnZhbHVlcy5pZHhcbiAgXG4gICAgICBjb25zdCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBtZW1vcnkgKSB7XG4gICAgICAgIHJldHVybiBhdmdbMF1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgaW5wdXQ6cHJvcHMuaW5wdXQsXG4gICAgICAgIGlzU3RlcmVvLFxuICAgICAgICBkaXJ0eTp0cnVlLFxuICAgICAgICBpbnB1dE5hbWVzOlsgJ2lucHV0JywgJ21lbW9yeScgXSxcbiAgICAgICAgaW5wdXRzOlsgcHJvcHMuaW5wdXQgXSxcbiAgICAgICAgaWQ6IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKCksXG5cbiAgICAgICAgX19wcm9wZXJ0aWVzX186IHsgaW5wdXQ6cHJvcHMuaW5wdXQgfSxcbiAgICAgIH1cblxuICAgICAgLy8gbm9uc2Vuc2UgdG8gbWFrZSBvdXIgY3VzdG9tIGZ1bmN0aW9uIHdvcmtcbiAgICAgIG91dC5jYWxsYmFjay51Z2VuTmFtZSA9IG91dC51Z2VuTmFtZSA9IGBmb2xsb3dfb3V0XyR7Zm9sbG93X291dC5pZH1gXG4gICAgICBvdXQuaWQgPSBfX3Byb3BzLm92ZXJyaWRlaWRcblxuICAgICAgLy8gYmVnaW4gaW5wdXQgdHJhY2tlclxuICAgICAgY29uc3QgZm9sbG93X2luID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbiAgICAgIGlmKCBpc1N0ZXJlbyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgaWYoIHByb3BzLm91dHB1dFN0ZXJlbyA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgeyBcbiAgICAgICAgICAgIFwidXNlIGpzZHNwXCJcbiAgICAgICAgICAgIC8vIHBoYXNlIHRvIHdyaXRlIHRvIGZvbGxvdyBidWZmZXJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclBoYXNlT3V0ID0gZy5hY2N1bSggMSwwLHsgbWF4OnByb3BzLmJ1ZmZlclNpemUsIG1pbjowIH0pXG5cbiAgICAgICAgICAgIC8vIGhvbGQgcnVubmluZyBzdW1cbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGcuZGF0YSggMSwgMSwgeyBtZXRhOnRydWUgfSlcblxuICAgICAgICAgICAgY29uc3QgbW9ubyA9IHByb3BzLmFicyA9PT0gdHJ1ZSA/IGcuYWJzKCBpbnB1dFswXSArIGlucHV0WzFdICkgOiBpbnB1dFswXSArIGlucHV0WzFdXG5cbiAgICAgICAgICAgIHN1bVswXSA9IHN1bVswXSArIG1vbm8gLSBnLnBlZWsoIGJ1ZmZlciwgYnVmZmVyUGhhc2VPdXQsIHsgbW9kZTonc2ltcGxlJyB9KVxuXG4gICAgICAgICAgICBnLnBva2UoIGJ1ZmZlciwgZy5hYnMoIG1vbm8gKSwgYnVmZmVyUGhhc2VPdXQgKVxuXG4gICAgICAgICAgICBhdmcgPSAoc3VtWzBdIC8gcHJvcHMuYnVmZmVyU2l6ZSkgKiBtdWx0aXBsaWVyICsgb2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBjb25zdCBidWZmZXJMID0gYnVmZmVyXG4gICAgICAgICAgY29uc3QgYnVmZmVyUiA9IGcuZGF0YSggcHJvcHMuYnVmZmVyU2l6ZSwgMSApXG5cbiAgICAgICAgICB7IFxuICAgICAgICAgICAgXCJ1c2UganNkc3BcIlxuICAgICAgICAgICAgLy8gcGhhc2UgdG8gd3JpdGUgdG8gZm9sbG93IGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyUGhhc2VPdXQgPSBnLmFjY3VtKCAxLDAseyBtYXg6cHJvcHMuYnVmZmVyU2l6ZSwgbWluOjAgfSlcblxuICAgICAgICAgICAgLy8gaG9sZCBydW5uaW5nIHN1bVxuICAgICAgICAgICAgY29uc3Qgc3VtTCA9IGcuZGF0YSggMSwgMSwgeyBtZXRhOnRydWUgfSlcbiAgICAgICAgICAgIGNvbnN0IHN1bVIgPSBnLmRhdGEoIDEsIDEsIHsgbWV0YTp0cnVlIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwcm9wcy5hYnMgPT09IHRydWUgID8gZy5hYnMoIGlucHV0WzBdICkgOiBpbnB1dFswXVxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBwcm9wcy5hYnMgPT09IHRydWUgPyBnLmFicyggaW5wdXRbMV0gKSA6IGlucHV0WzFdXG5cbiAgICAgICAgICAgIHN1bUxbMF0gPSBzdW1MWzBdICsgbGVmdCAtIGcucGVlayggYnVmZmVyTCwgYnVmZmVyUGhhc2VPdXQsIHsgbW9kZTonc2ltcGxlJyB9KVxuICAgICAgICAgICAgc3VtUlswXSA9IHN1bVJbMF0gKyByaWdodC0gZy5wZWVrKCBidWZmZXJSLCBidWZmZXJQaGFzZU91dCwgeyBtb2RlOidzaW1wbGUnIH0pXG5cbiAgICAgICAgICAgIGcucG9rZSggYnVmZmVyTCwgZy5hYnMoIGxlZnQgICksIGJ1ZmZlclBoYXNlT3V0IClcbiAgICAgICAgICAgIGcucG9rZSggYnVmZmVyUiwgZy5hYnMoIHJpZ2h0ICksIGJ1ZmZlclBoYXNlT3V0IClcblxuICAgICAgICAgICAgYXZnID0gW1xuICAgICAgICAgICAgICAoc3VtTFswXSAvIHByb3BzLmJ1ZmZlclNpemUpICogbXVsdGlwbGllciArIG9mZnNldCxcbiAgICAgICAgICAgICAgKHN1bVJbMF0gLyBwcm9wcy5idWZmZXJTaXplKSAqIG11bHRpcGxpZXIgKyBvZmZzZXQsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAge1xuICAgICAgICAgIFwidXNlIGpzZHNwXCJcbiAgICAgICAgICAvLyBwaGFzZSB0byB3cml0ZSB0byBmb2xsb3cgYnVmZmVyXG4gICAgICAgICAgY29uc3QgYnVmZmVyUGhhc2VPdXQgPSBnLmFjY3VtKCAxLDAseyBtYXg6cHJvcHMuYnVmZmVyU2l6ZSwgbWluOjAgfSlcblxuICAgICAgICAgIC8vIGhvbGQgcnVubmluZyBzdW1cbiAgICAgICAgICBjb25zdCBzdW0gPSBnLmRhdGEoIDEsIDEsIHsgbWV0YTp0cnVlIH0pXG5cbiAgICAgICAgICBjb25zdCBfX2lucHV0ID0gcHJvcHMuYWJzID09PSB0cnVlID8gZy5hYnMoIGlucHV0ICkgOiBpbnB1dFxuXG4gICAgICAgICAgc3VtWzBdID0gc3VtWzBdICsgX19pbnB1dCAtIGcucGVlayggYnVmZmVyLCBidWZmZXJQaGFzZU91dCwgeyBtb2RlOidzaW1wbGUnIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgZy5wb2tlKCBidWZmZXIsIGcuYWJzKCBpbnB1dCApLCBidWZmZXJQaGFzZU91dCApXG5cbiAgICAgICAgICBhdmcgPSAoc3VtWzBdIC8gcHJvcHMuYnVmZmVyU2l6ZSkgKiBtdWx0aXBsaWVyICsgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuICAgICAgcHJvcHMuaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgY29uc3QgcmVjb3JkID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgICAgICBmb2xsb3dfaW4sXG4gICAgICAgIGF2ZywgXG4gICAgICAgIFsnYW5hbHlzaXMnLCAnZm9sbG93X2luJ10sIFxuICAgICAgICBwcm9wc1xuICAgICAgKVxuXG4gICAgICAvLyBub25zZW5zZSB0byBtYWtlIG91ciBjdXN0b20gZnVuY3Rpb24gd29ya1xuICAgICAgcmVjb3JkLmNhbGxiYWNrLnVnZW5OYW1lID0gcmVjb3JkLnVnZW5OYW1lID0gYGZvbGxvd19pbl8ke2ZvbGxvd19vdXQuaWR9YFxuXG4gICAgICBpZiggR2liYmVyaXNoLmFuYWx5emVycy5pbmRleE9mKCByZWNvcmQgKSA9PT0gLTEgKSBHaWJiZXJpc2guYW5hbHl6ZXJzLnB1c2goIHJlY29yZCApXG5cbiAgICAgIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG5cbiAgICAgIEdpYmJlcmlzaC51Z2Vucy5zZXQoIF9fcHJvcHMub3ZlcnJpZGVpZCwgcmVjb3JkIClcblxuICAgICAgb3V0LnJlY29yZCA9IHJlY29yZFxuICAgIH1cblxuICAgIHJldHVybiBvdXRcblxuICB9XG4gXG4gIEZvbGxvdy5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIGJ1ZmZlclNpemU6MTAyNCxcbiAgICBtdWx0aXBsaWVyOjEsXG4gICAgYWJzOiB0cnVlLFxuICAgIG91dHB1dFN0ZXJlbzpmYWxzZSxcbiAgICBvZmZzZXQ6MFxuICB9XG5cbiAgcmV0dXJuIEZvbGxvd1xuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGFuYWx5emVyID0gcmVxdWlyZSggJy4vYW5hbHl6ZXIuanMnICksXG4gICAgICBwcm94eSAgICA9IHJlcXVpcmUoICcuLi93b3JrbGV0UHJveHkuanMnICksXG4gICAgICB1Z2VuICAgICA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiBcbi8vIGFuIFNTRCB1Z2VuIGlzIGluIGVmZmVjdCB0d28taW4tb25lLFxuLy8gb25lIGZvciBpbnB1dCBhbmQgb25lIGZvciBvdXRwdXQuICBcbiAgXG5jb25zdCBTU0QgPSBpbnB1dFByb3BzID0+IHtcbiAgY29uc3Qgc3NkID0gT2JqZWN0LmNyZWF0ZSggYW5hbHl6ZXIgKVxuXG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgU1NELmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgY29uc3QgaXNTdGVyZW8gPSBwcm9wcy5pc1N0ZXJlbyBcbiAgY29uc3QgaW5wdXQgICAgPSBnLmluKCAnaW5wdXQnIClcbiAgY29uc3QgaGlzdG9yeUwgPSBnLmhpc3RvcnkoMClcbiAgY29uc3QgaGlzdG9yeVIgPSBnLmhpc3RvcnkoMClcblxuICBzc2Qub3V0ID0gT3V0KCBbaGlzdG9yeUwsaGlzdG9yeVJdLCBwcm9wcyApXG4gIHNzZC5pbiAgPSAgSW4oIFtoaXN0b3J5TCxoaXN0b3J5Ul0sIHByb3BzIClcblxuICBzc2QubGlzdGVuID0gc3NkLmluLmxpc3RlblxuXG4gIHJldHVybiBzc2QgXG59XG5cbmNvbnN0IE91dCA9ICggaGlzdG9yaWVzLHByb3BzICkgPT4ge1xuICBsZXQgaGlzdG9yeVxuICAvLyBpZiB3ZSBkb24ndCBmaW5kIG91ciBoaXN0b3J5IHVnZW4gaW4gdGhlIHByb2Nlc3NvciB0aHJlYWQsXG4gIC8vIGp1c3QgZ28gYWhlYWQgYW5kIG1ha2UgYSBuZXcgb25lLCB0aGV5J3JlIGNoZWFwLi4uXG4gIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgY29uc3QgaWQgPSBBcnJheS5pc0FycmF5KCBoaXN0b3JpZXMgKSA/IGhpc3Rvcmllc1swXS5pZCA6IGhpc3Rvcmllcy5pZFxuICAgIGhpc3RvcnkgPSBHaWJiZXJpc2gudWdlbnMuZ2V0KCBpZCApXG4gICAgaWYoIGhpc3RvcnkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGhpc3RvcnkgPSBnLmhpc3RvcnkoIDAgKVxuICAgICAgR2liYmVyaXNoLnVnZW5zLnNldCggaWQsIGhpc3RvcnkgKVxuICAgIH1cbiAgICBpZiggcHJvcHMgPT09IHVuZGVmaW5lZCApIHByb3BzID0geyBpZCB9XG4gIH1lbHNle1xuICAgIGhpc3RvcnkgPSBoaXN0b3JpZXNbMF1cbiAgfVxuXG4gIHJldHVybiBHaWJiZXJpc2guZmFjdG9yeSggT2JqZWN0LmNyZWF0ZSggdWdlbiApLCBoaXN0b3J5Lm91dCwgWydhbmFseXNpcycsJ1NTRF9PdXQnXSwgcHJvcHMsIG51bGwgKVxufVxuXG5jb25zdCBJbiA9IGhpc3RvcmllcyA9PiB7XG4gIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApXG4gIGxldCBoaXN0b3J5TCwgaGlzdG9yeVJcbiAgXG4gIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIHRoZSBwcm9lc3NvciBpZCBpcyBhbHdheXMgb25lIG9mZiBmcm9tIHRoZSBtYWluIHRocmVhZCBpZFxuICAgIGhpc3RvcnlMID0gR2liYmVyaXNoLnVnZW5zLmdldCggaGlzdG9yaWVzLmlkIC0gMSApXG4gICAgaGlzdG9yeVIgPSBHaWJiZXJpc2gudWdlbnMuZ2V0KCBoaXN0b3JpZXMuaWQgKVxuICB9ZWxzZXtcbiAgICBoaXN0b3J5TCA9IGhpc3Rvcmllc1swXVxuICAgIGhpc3RvcnlSID0gaGlzdG9yaWVzWzFdXG4gIH1cblxuICAvLyBkZWxpYmVyYXRlIGxldFxuICBsZXQgc3NkaW4gPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgXG4gIHNzZGluLmxpc3RlbiA9IGZ1bmN0aW9uKCBpbnB1dCApIHtcbiAgICBzc2Rpbi5pbnB1dCA9IGlucHV0XG4gICAgLy8gY2hhbmdpbmcgdGhlIGlucHV0IG11c3QgdHJpZ2dlciBjb2RlZ2VuXG4gICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzICkgXG5cbiAgICBsZXQgaXNTdGVyZW8gPSBpbnB1dC5pc1N0ZXJlb1xuICAgIGlmKCBpbnB1dC5pc1N0ZXJlbyA9PT0gdW5kZWZpbmVkICYmIGlucHV0Lmlzb3AgPT09IHRydWUgKSB7XG4gICAgICBpc1N0ZXJlbyA9IGlucHV0LmlucHV0c1swXS5pc1N0ZXJlbyA9PT0gdHJ1ZSB8fCBpbnB1dC5pbnB1dHNbMV0uaXNTdGVyZW8gPT09IHRydWUgXG4gICAgfVxuICAgIGlmKCBpc1N0ZXJlbyA9PT0gdHJ1ZSAmJiBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICBjb25zdCBpZHggPSBoaXN0b3J5TC5ncmFwaC5tZW1vcnkudmFsdWUuaWR4ICAgICBcbiAgICAgIHNzZGluLmNhbGxiYWNrID0gZnVuY3Rpb24oIGlucHV0LCBtZW1vcnkgKSB7XG4gICAgICAgIG1lbW9yeVsgaWR4IF0gPSBpbnB1dFsgMCBdXG4gICAgICAgIG1lbW9yeVsgaWR4ICsgMSBdID0gaW5wdXRbIDEgXVxuICAgICAgICByZXR1cm4gMCAgICAgXG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gZWFjaCB1Z2VuIGNhbGxiYWNrIGlzIHBhc3NlZCB0byB0aGUgbWFzdGVyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAvLyBpdCBuZWVkcyB0byBoYXZlIGEgdWdlbk5hbWUgcHJvcGVydHk7IHdlJ2xsIGp1c3QgY29weSB0aGlzIG92ZXJcbiAgICAgIHNzZGluLmNhbGxiYWNrLnVnZW5OYW1lID0gc3NkaW4udWdlbk5hbWVcbiAgICB9XG4gIH1cblxuICBzc2RpbiA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzc2RpbiwgaW5wdXQsIFsnYW5hbHlzaXMnLCdTU0RfSW4nXSwgeyAnaW5wdXQnOjAgfSApXG5cbiAgLy8gb3ZlcndyaXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpbiB0aGUgcHJvY2Vzc29yIHRocmVhZC4uLlxuICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgIGNvbnN0IGlkeCA9IGhpc3RvcnlMLmdyYXBoLm1lbW9yeS52YWx1ZS5pZHhcbiAgICBcbiAgICBzc2Rpbi5jYWxsYmFjayA9IGZ1bmN0aW9uKCBpbnB1dCwgbWVtb3J5ICkge1xuICAgICAgbWVtb3J5WyBpZHggXSA9IGlucHV0XG4gICAgICByZXR1cm4gMCAgICAgXG4gICAgfVxuXG4gICAgLy8gd2hlbiBlYWNoIHVnZW4gY2FsbGJhY2sgaXMgcGFzc2VkIHRvIHRoZSBtYXN0ZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAvLyBpdCBuZWVkcyB0byBoYXZlIGEgdWdlbk5hbWUgcHJvcGVydHk7IHdlJ2xsIGp1c3QgY29weSB0aGlzIG92ZXJcbiAgICBzc2Rpbi5jYWxsYmFjay51Z2VuTmFtZSA9IHNzZGluLnVnZW5OYW1lXG4gIH1cblxuICBzc2Rpbi50eXBlID0gJ2FuYWx5c2lzJ1xuICBHaWJiZXJpc2guYW5hbHl6ZXJzLnB1c2goIHNzZGluIClcblxuICByZXR1cm4gc3NkaW5cbn1cblxuU1NELmRlZmF1bHRzID0ge1xuICBpbnB1dDowLFxuICBpc1N0ZXJlbzpmYWxzZVxufVxuXG5yZXR1cm4geyBJbiwgT3V0LCBTU0QgfVxuXG59XG4iLCJjb25zdCB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICksXG4gICAgICBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgQUQgPSBmdW5jdGlvbiggYXJndW1lbnRQcm9wcyApIHtcbiAgICBjb25zdCBhZCA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSxcbiAgICAgICAgICBhdHRhY2sgID0gZy5pbiggJ2F0dGFjaycgKSxcbiAgICAgICAgICBkZWNheSAgID0gZy5pbiggJ2RlY2F5JyApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBBRC5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBjb25zdCBncmFwaCA9IGcuYWQoIGF0dGFjaywgZGVjYXksIHsgc2hhcGU6cHJvcHMuc2hhcGUsIGFscGhhOnByb3BzLmFscGhhIH0pXG5cbiAgICBhZC50cmlnZ2VyID0gZ3JhcGgudHJpZ2dlclxuICAgIFxuICAgIGNvbnN0IF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIGFkLCBncmFwaCwgWydlbnZlbG9wZXMnLCdBRCddLCBwcm9wcyApXG5cbiAgICByZXR1cm4gX19vdXRcbiAgfVxuXG4gIEFELmRlZmF1bHRzID0geyBhdHRhY2s6NDQxMDAsIGRlY2F5OjQ0MTAwLCBzaGFwZTonZXhwb25lbnRpYWwnLCBhbHBoYTo1IH0gXG5cbiAgcmV0dXJuIEFEXG5cbn1cbiIsImNvbnN0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSxcbiAgICAgIGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBBRFNSID0gZnVuY3Rpb24oIGFyZ3VtZW50UHJvcHMgKSB7XG4gICAgY29uc3QgYWRzciAgPSBPYmplY3QuY3JlYXRlKCB1Z2VuICksXG4gICAgICAgICAgYXR0YWNrICA9IGcuaW4oICdhdHRhY2snICksXG4gICAgICAgICAgZGVjYXkgICA9IGcuaW4oICdkZWNheScgKSxcbiAgICAgICAgICBzdXN0YWluID0gZy5pbiggJ3N1c3RhaW4nICksXG4gICAgICAgICAgcmVsZWFzZSA9IGcuaW4oICdyZWxlYXNlJyApLFxuICAgICAgICAgIHN1c3RhaW5MZXZlbCA9IGcuaW4oICdzdXN0YWluTGV2ZWwnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIEFEU1IuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgT2JqZWN0LmFzc2lnbiggYWRzciwgcHJvcHMgKVxuXG4gICAgY29uc3QgZ3JhcGggPSBnLmFkc3IoIFxuICAgICAgYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgc3VzdGFpbkxldmVsLCByZWxlYXNlLCBcbiAgICAgIHsgdHJpZ2dlclJlbGVhc2U6IHByb3BzLnRyaWdnZXJSZWxlYXNlLCBzaGFwZTpwcm9wcy5zaGFwZSwgYWxwaGE6cHJvcHMuYWxwaGEgfSBcbiAgICApXG5cbiAgICBhZHNyLnRyaWdnZXIgPSBncmFwaC50cmlnZ2VyXG4gICAgYWRzci5hZHZhbmNlID0gZ3JhcGgucmVsZWFzZVxuXG4gICAgY29uc3QgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggYWRzciwgZ3JhcGgsIFsnZW52ZWxvcGVzJywnQURTUiddLCBwcm9wcyApXG5cbiAgICByZXR1cm4gX19vdXQgXG4gIH1cblxuICBBRFNSLmRlZmF1bHRzID0geyBcbiAgICBhdHRhY2s6MjIwNTAsIFxuICAgIGRlY2F5OjIyMDUwLCBcbiAgICBzdXN0YWluOjQ0MTAwLCBcbiAgICBzdXN0YWluTGV2ZWw6LjYsIFxuICAgIHJlbGVhc2U6IDQ0MTAwLCBcbiAgICB0cmlnZ2VyUmVsZWFzZTpmYWxzZSxcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnLFxuICAgIGFscGhhOjUgXG4gIH0gXG5cbiAgcmV0dXJuIEFEU1Jcbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBFbnZlbG9wZXMgPSB7XG4gICAgQUQgICAgIDogcmVxdWlyZSggJy4vYWQuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIEFEU1IgICA6IHJlcXVpcmUoICcuL2Fkc3IuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIFJhbXAgICA6IHJlcXVpcmUoICcuL3JhbXAuanMnICkoIEdpYmJlcmlzaCApLFxuXG4gICAgZXhwb3J0IDogdGFyZ2V0ID0+IHtcbiAgICAgIGZvciggbGV0IGtleSBpbiBFbnZlbG9wZXMgKSB7XG4gICAgICAgIGlmKCBrZXkgIT09ICdleHBvcnQnICYmIGtleSAhPT0gJ2ZhY3RvcnknICkge1xuICAgICAgICAgIHRhcmdldFsga2V5IF0gPSBFbnZlbG9wZXNbIGtleSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmFjdG9yeSggdXNlQURTUiwgc2hhcGUsIGF0dGFjaywgZGVjYXksIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgcmVsZWFzZSwgdHJpZ2dlclJlbGVhc2U9ZmFsc2UgKSB7XG4gICAgICBsZXQgZW52XG5cbiAgICAgIC8vIGRlbGliZXJhdGUgdXNlIG9mIHNpbmdsZSA9IHRvIGFjY29tb2RhdGUgYm90aCAxIGFuZCB0cnVlXG4gICAgICBpZiggdXNlQURTUiAhPSB0cnVlICkge1xuICAgICAgICBlbnYgPSBnLmFkKCBhdHRhY2ssIGRlY2F5LCB7IHNoYXBlIH0pIFxuICAgICAgfWVsc2Uge1xuICAgICAgICBlbnYgPSBnLmFkc3IoIGF0dGFjaywgZGVjYXksIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgcmVsZWFzZSwgeyBzaGFwZSwgdHJpZ2dlclJlbGVhc2UgfSlcbiAgICAgICAgZW52LmFkdmFuY2UgPSBlbnYucmVsZWFzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW52XG4gICAgfVxuICB9IFxuXG4gIHJldHVybiBFbnZlbG9wZXNcbn1cbiIsImNvbnN0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSxcbiAgICAgIGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBSYW1wID0gZnVuY3Rpb24oIGFyZ3VtZW50UHJvcHMgKSB7XG4gICAgY29uc3QgcmFtcCAgID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApLFxuICAgICAgICAgIGxlbmd0aCA9IGcuaW4oICdsZW5ndGgnICksXG4gICAgICAgICAgZnJvbSAgID0gZy5pbiggJ2Zyb20nICksXG4gICAgICAgICAgdG8gICAgID0gZy5pbiggJ3RvJyApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIFJhbXAuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgY29uc3QgcmVzZXQgPSBnLmJhbmcoKVxuXG4gICAgY29uc3QgcGhhc2UgPSBnLmFjY3VtKCBnLmRpdiggMSwgbGVuZ3RoICksIHJlc2V0LCB7IHNob3VsZFdyYXA6cHJvcHMuc2hvdWxkTG9vcCwgc2hvdWxkQ2xhbXA6dHJ1ZSB9KSxcbiAgICAgICAgICBkaWZmID0gZy5zdWIoIHRvLCBmcm9tICksXG4gICAgICAgICAgZ3JhcGggPSBnLmFkZCggZnJvbSwgZy5tdWwoIHBoYXNlLCBkaWZmICkgKVxuICAgICAgICBcbiAgICByYW1wLnRyaWdnZXIgPSByZXNldC50cmlnZ2VyXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggcmFtcCwgZ3JhcGgsIFsnZW52ZWxvcGVzJywncmFtcCddLCBwcm9wcyApXG5cblxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIFJhbXAuZGVmYXVsdHMgPSB7IGZyb206MCwgdG86MSwgbGVuZ3RoOmcuZ2VuLnNhbXBsZXJhdGUsIHNob3VsZExvb3A6ZmFsc2UgfVxuXG4gIHJldHVybiBSYW1wXG5cbn1cbiIsIi8qXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW50aW1hdHRlcjE1L2hlYXBxdWV1ZS5qcy9ibG9iL21hc3Rlci9oZWFwcXVldWUuanNcbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHZlcnkgbG9vc2VseSBiYXNlZCBvZmYganMtcHJpb3JpdHktcXVldWVcbiAqIGJ5IEFkYW0gSG9vcGVyIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FkYW1ob29wZXIvanMtcHJpb3JpdHktcXVldWVcbiAqXG4gKiBUaGUganMtcHJpb3JpdHktcXVldWUgaW1wbGVtZW50YXRpb24gc2VlbWVkIGEgdGVlbnN5IGJpdCBibG9hdGVkXG4gKiB3aXRoIGl0cyByZXF1aXJlLmpzIGRlcGVuZGVuY3kgYW5kIG11bHRpcGxlIHN0b3JhZ2Ugc3RyYXRlZ2llc1xuICogd2hlbiBhbGwgYnV0IG9uZSB3ZXJlIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBTbyBoZXJlIGlzIGEga2luZCBvZlxuICogY29uZGVuc2VkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uYWxpdHkgd2l0aCBvbmx5IHRoZSBmZWF0dXJlcyB0aGF0XG4gKiBJIHBhcnRpY3VsYXJseSBuZWVkZWQuXG4gKlxuICogVXNpbmcgaXQgaXMgcHJldHR5IHNpbXBsZSwgeW91IGp1c3QgY3JlYXRlIGFuIGluc3RhbmNlIG9mIEhlYXBRdWV1ZVxuICogd2hpbGUgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGEgY29tcGFyYXRvciBhcyB0aGUgYXJndW1lbnQ6XG4gKlxuICogdmFyIGhlYXBxID0gbmV3IEhlYXBRdWV1ZSgpO1xuICpcbiAqIC8vSUYgTkVHQVRJVkUsIFJFVFVSTiBBXG4gKlxuICogdmFyIGN1c3RvbXEgPSBuZXcgSGVhcFF1ZXVlKGZ1bmN0aW9uKGEsIGIpe1xuICogICAvLyBpZiBiID4gYSwgcmV0dXJuIG5lZ2F0aXZlXG4gKiAgIC8vIG1lYW5zIHRoYXQgaXQgc3BpdHMgb3V0IHRoZSBzbWFsbGVzdCBpdGVtIGZpcnN0XG4gKiAgIHJldHVybiBhIC0gYjtcbiAqIH0pO1xuICpcbiAqIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UsIHRoZSBkZWZhdWx0IGNvbXBhcmF0b3IgaXMgaWRlbnRpY2FsIHRvXG4gKiB0aGUgY29tcGFyYXRvciB3aGljaCBpcyB1c2VkIGV4cGxpY2l0bHkgaW4gdGhlIHNlY29uZCBxdWV1ZS5cbiAqXG4gKiBPbmNlIHlvdSd2ZSBpbml0aWFsaXplZCB0aGUgaGVhcHF1ZXVlLCB5b3UgY2FuIHBsb3Agc29tZSBuZXdcbiAqIGVsZW1lbnRzIGludG8gdGhlIHF1ZXVlIHdpdGggdGhlIHB1c2ggbWV0aG9kICh2YWd1ZWx5IHJlbWluaXNjZW50XG4gKiBvZiB0eXBpY2FsIGphdmFzY3JpcHQgYXJheXMpXG4gKlxuICogaGVhcHEucHVzaCg0Mik7XG4gKiBoZWFwcS5wdXNoKFwia2l0dGVuXCIpO1xuICpcbiAqIFRoZSBwdXNoIG1ldGhvZCByZXR1cm5zIHRoZSBuZXcgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSBxdWV1ZS5cbiAqXG4gKiBZb3UgY2FuIHB1c2ggYW55dGhpbmcgeW91J2QgbGlrZSBvbnRvIHRoZSBxdWV1ZSwgc28gbG9uZyBhcyB5b3VyXG4gKiBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIGNhcGFibGUgb2YgaGFuZGxpbmcgaXQuIFRoZSBkZWZhdWx0XG4gKiBjb21wYXJhdG9yIGlzIHJlYWxseSBzdHVwaWQgc28gaXQgd29uJ3QgYmUgYWJsZSB0byBoYW5kbGUgYW55dGhpbmdcbiAqIG90aGVyIHRoYW4gYW4gbnVtYmVyIGJ5IGRlZmF1bHQuXG4gKlxuICogWW91IGNhbiBwcmV2aWV3IHRoZSBzbWFsbGVzdCBpdGVtIGJ5IHVzaW5nIHBlZWsuXG4gKlxuICogaGVhcHEucHVzaCgtOTk5OSk7XG4gKiBoZWFwcS5wZWVrKCk7IC8vID09PiAtOTk5OVxuICpcbiAqIFRoZSB1c2VmdWwgY29tcGxlbWVudCB0byB0byB0aGUgcHVzaCBtZXRob2QgaXMgdGhlIHBvcCBtZXRob2QsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBzbWFsbGVzdCBpdGVtIGFuZCB0aGVuIHJlbW92ZXMgaXQgZnJvbSB0aGVcbiAqIHF1ZXVlLlxuICpcbiAqIGhlYXBxLnB1c2goMSk7XG4gKiBoZWFwcS5wdXNoKDIpO1xuICogaGVhcHEucHVzaCgzKTtcbiAqIGhlYXBxLnBvcCgpOyAvLyA9PT4gMVxuICogaGVhcHEucG9wKCk7IC8vID09PiAyXG4gKiBoZWFwcS5wb3AoKTsgLy8gPT0+IDNcbiAqL1xuY29uc3QgSGVhcFF1ZXVlID0gZnVuY3Rpb24oY21wKXtcbiAgdGhpcy5jbXAgPSAoY21wIHx8IGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYSAtIGI7IH0pO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMuZGF0YSA9IFtdO1xufVxuSGVhcFF1ZXVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbn07XG5IZWFwUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcblxuICB2YXIgcG9zID0gdGhpcy5kYXRhLmxlbmd0aCAtIDEsXG4gIHBhcmVudCwgeDtcblxuICB3aGlsZShwb3MgPiAwKXtcbiAgICBwYXJlbnQgPSAocG9zIC0gMSkgPj4+IDE7XG4gICAgaWYodGhpcy5jbXAodGhpcy5kYXRhW3Bvc10sIHRoaXMuZGF0YVtwYXJlbnRdKSA8IDApe1xuICAgICAgeCA9IHRoaXMuZGF0YVtwYXJlbnRdO1xuICAgICAgdGhpcy5kYXRhW3BhcmVudF0gPSB0aGlzLmRhdGFbcG9zXTtcbiAgICAgIHRoaXMuZGF0YVtwb3NdID0geDtcbiAgICAgIHBvcyA9IHBhcmVudDtcbiAgICB9ZWxzZSBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGgrKztcbn07XG5IZWFwUXVldWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBsYXN0X3ZhbCA9IHRoaXMuZGF0YS5wb3AoKSxcbiAgcmV0ID0gdGhpcy5kYXRhWzBdO1xuICBpZih0aGlzLmRhdGEubGVuZ3RoID4gMCl7XG4gICAgdGhpcy5kYXRhWzBdID0gbGFzdF92YWw7XG4gICAgdmFyIHBvcyA9IDAsXG4gICAgbGFzdCA9IHRoaXMuZGF0YS5sZW5ndGggLSAxLFxuICAgIGxlZnQsIHJpZ2h0LCBtaW5JbmRleCwgeDtcbiAgICB3aGlsZSgxKXtcbiAgICAgIGxlZnQgPSAocG9zIDw8IDEpICsgMTtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICBtaW5JbmRleCA9IHBvcztcbiAgICAgIGlmKGxlZnQgPD0gbGFzdCAmJiB0aGlzLmNtcCh0aGlzLmRhdGFbbGVmdF0sIHRoaXMuZGF0YVttaW5JbmRleF0pIDwgMCkgbWluSW5kZXggPSBsZWZ0O1xuICAgICAgaWYocmlnaHQgPD0gbGFzdCAmJiB0aGlzLmNtcCh0aGlzLmRhdGFbcmlnaHRdLCB0aGlzLmRhdGFbbWluSW5kZXhdKSA8IDApIG1pbkluZGV4ID0gcmlnaHQ7XG4gICAgICBpZihtaW5JbmRleCAhPT0gcG9zKXtcbiAgICAgICAgeCA9IHRoaXMuZGF0YVttaW5JbmRleF07XG4gICAgICAgIHRoaXMuZGF0YVttaW5JbmRleF0gPSB0aGlzLmRhdGFbcG9zXTtcbiAgICAgICAgdGhpcy5kYXRhW3Bvc10gPSB4O1xuICAgICAgICBwb3MgPSBtaW5JbmRleDtcbiAgICAgIH1lbHNlIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSBsYXN0X3ZhbDtcbiAgfVxuICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFwUXVldWVcbiIsIlxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mXG4gKiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVRcbiAqIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZVxuICogTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXJcbiAqIHRoZSBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVhbG0gKHNjb3BlLCBwYXJlbnRFbGVtZW50KSB7XG4gIGNvbnN0IGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGZyYW1lLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDotOTk5cHg7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChmcmFtZSk7XG4gIGNvbnN0IHdpbiA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgbGV0IHZhcnMgPSAndmFyIHdpbmRvdywkaG9vayc7XG4gIGZvciAoY29uc3QgaSBpbiB3aW4pIHtcbiAgICBpZiAoIShpIGluIHNjb3BlKSAmJiBpICE9PSAnZXZhbCcpIHtcbiAgICAgIHZhcnMgKz0gJywnO1xuICAgICAgdmFycyArPSBpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gc2NvcGUpIHtcbiAgICB2YXJzICs9ICcsJztcbiAgICB2YXJzICs9IGk7XG4gICAgdmFycyArPSAnPXNlbGYuJztcbiAgICB2YXJzICs9IGk7XG4gIH1cbiAgY29uc3Qgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKFxuICAgIGBmdW5jdGlvbiAkaG9vayhzZWxmLGNvbnNvbGUpIHtcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgJHt2YXJzfTtyZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIGV2YWwoYXJndW1lbnRzWzBdKX19YFxuICApKTtcbiAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgdGhpcy5leGVjID0gd2luLiRob29rLmNhbGwoc2NvcGUsIHNjb3BlLCBjb25zb2xlKTtcbn1cbiIsImNvbnN0IF9fcHJveHkgPSByZXF1aXJlKCAnLi93b3JrbGV0UHJveHkuanMnIClcbmNvbnN0IGVmZmVjdFByb3RvID0gcmVxdWlyZSggJy4vZngvZWZmZWN0LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgcHJveHkgPSBfX3Byb3h5KCBHaWJiZXJpc2ggKVxuICBcbiAgY29uc3QgZmFjdG9yeSA9IGZ1bmN0aW9uKCB1Z2VuLCBncmFwaCwgX19uYW1lLCB2YWx1ZXMsIGNiPW51bGwsIHNob3VsZFByb3h5ID0gdHJ1ZSApIHtcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InIClcbiAgICAgIHVnZW4uY2FsbGJhY2sgPSBjYiA9PT0gbnVsbCA/IEdpYmJlcmlzaC5nZW5pc2guZ2VuLmNyZWF0ZUNhbGxiYWNrKCBncmFwaCwgR2liYmVyaXNoLm1lbW9yeSwgZmFsc2UsIHRydWUgKSA6IGNiXG4gICAgZWxzZVxuICAgICAgdWdlbi5jYWxsYmFjayA9IHsgb3V0OltdIH1cblxuICAgIGxldCBuYW1lID0gQXJyYXkuaXNBcnJheSggX19uYW1lICkgPyBfX25hbWVbIF9fbmFtZS5sZW5ndGggLSAxIF0gOiBfX25hbWVcblxuICAgIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICAgIC8vdHlwZTogJ3VnZW4nLFxuICAgICAgaWQ6IHZhbHVlcy5pZCB8fCBHaWJiZXJpc2gudXRpbGl0aWVzLmdldFVJRCgpLCBcbiAgICAgIHVnZW5OYW1lOiBuYW1lICsgJ18nLFxuICAgICAgZ3JhcGg6IGdyYXBoLFxuICAgICAgaW5wdXROYW1lczogdWdlbi5pbnB1dE5hbWVzIHx8IG5ldyBTZXQoIEdpYmJlcmlzaC5nZW5pc2guZ2VuLnBhcmFtZXRlcnMgKSxcbiAgICAgIGlzU3RlcmVvOiBBcnJheS5pc0FycmF5KCBncmFwaCApLFxuICAgICAgZGlydHk6IHRydWUsXG4gICAgICBfX3Byb3BlcnRpZXNfXzp2YWx1ZXMsXG4gICAgICBfX2FkZHJlc3Nlc19fOnt9XG4gICAgfSlcblxuICAgIHVnZW4udWdlbk5hbWUgKz0gdWdlbi5pZFxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICB1Z2VuLmNhbGxiYWNrLnVnZW5OYW1lID0gdWdlbi51Z2VuTmFtZSAvLyBYWFggaGFja3lcbiAgICAgIHVnZW4uY2FsbGJhY2suaWQgPSB1Z2VuLmlkXG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyggJ3VnZW4gbmFtZS9pZDonLCB1Z2VuLnVnZW5OYW1lLCB1Z2VuLmlkIClcbiAgICAvL2NvbnNvbGUubG9nKCAnY2FsbGJhY2sgbmFtZS9pZDonLCB1Z2VuLmNhbGxiYWNrLnVnZW5OYW1lLCB1Z2VuLmNhbGxiYWNrLmlkIClcblxuICAgIGZvciggbGV0IHBhcmFtIG9mIHVnZW4uaW5wdXROYW1lcyApIHtcbiAgICAgIGlmKCBwYXJhbSA9PT0gJ21lbW9yeScgKSBjb250aW51ZVxuXG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbIHBhcmFtIF0sXG4gICAgICAgICAgaXNOdW1iZXIgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IGlzTmFOKCB2YWx1ZSApID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgIGlkeFxuXG4gICAgICBpZiggaXNOdW1iZXIgKSB7IFxuICAgICAgICBpZHggPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKCAxIClcbiAgICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXSA9IHZhbHVlXG4gICAgICAgIHVnZW4uX19hZGRyZXNzZXNfX1sgcGFyYW0gXSA9IGlkeFxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBhIHNldHRlcj9cbiAgICAgIGxldCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdWdlbiwgcGFyYW0gKSxcbiAgICAgICAgICBzZXR0ZXJcblxuICAgICAgaWYoIGRlc2MgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgc2V0dGVyID0gZGVzYy5zZXRcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCBwYXJhbSwge1xuICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgZ2V0KCkgeyBcbiAgICAgICAgICBpZiggaXNOdW1iZXIgKSB7XG4gICAgICAgICAgICByZXR1cm4gR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgIC8vaWYoIHBhcmFtID09PSAnaW5wdXQnICkgY29uc29sZS5sb2coICdJTlBVVDonLCB2LCBpc051bWJlciApXG4gICAgICAgICAgaWYoIHZhbHVlICE9PSB2ICkge1xuICAgICAgICAgICAgaWYoIHNldHRlciAhPT0gdW5kZWZpbmVkICkgc2V0dGVyKCB2IClcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgIEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgaWR4IF0gPSB2YWx1ZSA9IHZcbiAgICAgICAgICAgICAgaWYoIGlzTnVtYmVyID09PSBmYWxzZSApIEdpYmJlcmlzaC5kaXJ0eSggdWdlbiApXG4gICAgICAgICAgICAgIGlzTnVtYmVyID0gdHJ1ZVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICAgICAgICAvKmlmKCBpc051bWJlciA9PT0gdHJ1ZSApKi8gR2liYmVyaXNoLmRpcnR5KCB1Z2VuIClcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3N3aXRjaGluZyBmcm9tIG51bWJlcjonLCBwYXJhbSwgdmFsdWUgKVxuICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGFkZCBieXBhc3MgXG4gICAgaWYoIGVmZmVjdFByb3RvLmlzUHJvdG90eXBlT2YoIHVnZW4gKSApIHtcbiAgICAgIGxldCB2YWx1ZSA9IHVnZW4uYnlwYXNzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sICdieXBhc3MnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICBnZXQoKSB7IHJldHVybiB2YWx1ZSB9LFxuICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgaWYoIHZhbHVlICE9PSB2ICkge1xuICAgICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCB1Z2VuIClcbiAgICAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIH1cblxuICAgIGlmKCB1Z2VuLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICB1Z2VuLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uLmZvckVhY2goIHByb3AgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbIHByb3AgXVxuICAgICAgICBsZXQgaXNOdW1iZXIgPSAhaXNOYU4oIHZhbHVlIClcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sIHByb3AsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICBnZXQoKSB7IFxuICAgICAgICAgICAgaWYoIGlzTnVtYmVyICkge1xuICAgICAgICAgICAgICBsZXQgaWR4ID0gdWdlbi5fX2FkZHJlc3Nlc19fWyBwcm9wIF1cbiAgICAgICAgICAgICAgcmV0dXJuIEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgaWR4IF1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAncmV0dXJuaW5nOicsIHByb3AsIHZhbHVlLCBHaWJiZXJpc2gubW9kZSApXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICAgIGlmKCB2YWx1ZSAhPT0gdiApIHtcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdWdlbi5fX2FkZHJlc3Nlc19fWyBwcm9wIF1cbiAgICAgICAgICAgICAgICBpZiggaWR4ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgICAgIGlkeCA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoIDEgKVxuICAgICAgICAgICAgICAgICAgdWdlbi5fX2FkZHJlc3Nlc19fWyBwcm9wIF0gPSBpZHhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbIHByb3AgXSA9IEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgaWR4IF0gPSB2XG4gICAgICAgICAgICAgICAgaXNOdW1iZXIgPSB0cnVlXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzWyBwcm9wIF0gPSB2XG4gICAgICAgICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdzZXR0aW5nIHVnZW4nLCB2YWx1ZSwgR2liYmVyaXNoLm1vZGUgKVxuICAgICAgICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdWdlbiApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAnU0VUVElORyBSRURPIEdSQVBIJywgcHJvcCwgR2liYmVyaXNoLm1vZGUgKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gbmVlZGVkIGZvciBmaWx0ZXJUeXBlIGF0IHRoZSB2ZXJ5IGxlYXN0LCBiZWNhdWFlIHRoZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBhcmUgcmV1c2VkIHdoZW4gcmUtY3JlYXRpbmcgdGhlIGdyYXBoLiBUaGlzIHNlZW1zIGxpa2UgYSBjaGVhcGVyXG4gICAgICAgICAgICAgIC8vIHdheSB0byBzb2x2ZSB0aGlzIHByb2JsZW0uXG4gICAgICAgICAgICAgIC8vdmFsdWVzWyBwcm9wIF0gPSB2XG5cbiAgICAgICAgICAgICAgdGhpcy5fX3JlZG9HcmFwaCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIG9ubHkgY3JlYXRlIHByb3h5IGlmIHdvcmtsZXRzIGFyZSBiZWluZyB1c2VkXG4gICAgLy8gb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIHVuYWx0ZXJlZCB1Z2VuXG5cbiAgICBpZiggdmFsdWVzLnNob3VsZEFkZFRvVWdlbiA9PT0gdHJ1ZSApIE9iamVjdC5hc3NpZ24oIHVnZW4sIHZhbHVlcyApXG5cbiAgICByZXR1cm4gc2hvdWxkUHJveHkgPyBwcm94eSggX19uYW1lLCB2YWx1ZXMsIHVnZW4gKSA6IHVnZW5cbiAgfVxuXG4gIGZhY3RvcnkuZ2V0VUlEID0gKCkgPT4geyByZXR1cm4gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKSB9XG5cbiAgcmV0dXJuIGZhY3Rvcnlcbn1cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuIFxuLy8gY29uc3RydWN0b3IgZm9yIHNjaHJvZWRlciBhbGxwYXNzIGZpbHRlcnNcbmxldCBhbGxQYXNzID0gZnVuY3Rpb24oIF9pbnB1dCwgbGVuZ3RoPTUwMCwgZmVlZGJhY2s9LjUgKSB7XG4gIGxldCBpbmRleCAgPSBnLmNvdW50ZXIoIDEsMCxsZW5ndGggKSxcbiAgICAgIGJ1ZmZlciA9IGcuZGF0YSggbGVuZ3RoICksXG4gICAgICBidWZmZXJTYW1wbGUgPSBnLnBlZWsoIGJ1ZmZlciwgaW5kZXgsIHsgaW50ZXJwOidub25lJywgbW9kZTonc2FtcGxlcycgfSksXG4gICAgICBvdXQgPSBnLm1lbW8oIGcuYWRkKCBnLm11bCggLTEsIF9pbnB1dCksIGJ1ZmZlclNhbXBsZSApIClcbiAgICAgICAgICAgICAgICBcbiAgZy5wb2tlKCBidWZmZXIsIGcuYWRkKCBfaW5wdXQsIGcubXVsKCBidWZmZXJTYW1wbGUsIGZlZWRiYWNrICkgKSwgaW5kZXggKVxuIFxuICByZXR1cm4gb3V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWxsUGFzc1xuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGZpbHRlciA9IHJlcXVpcmUoICcuL2ZpbHRlci5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgZ2VuaXNoID0gZ1xuICBHaWJiZXJpc2guZ2VuaXNoLmJpcXVhZCA9ICggaW5wdXQsIF9fY3V0b2ZmLCBfX1EsIG1vZGUsIGlzU3RlcmVvICkgPT4ge1xuICAgICd1c2UganNkc3AnXG4gICAgbGV0IGluMWEwLHgwYTEseDFhMix5MGIwLHkxYjEsXG4gICAgICAgIGluMWEwX3IseDBhMV9yLHgxYTJfcix5MGIwX3IseTFiMV9yLFxuICAgICAgICBjXG5cbiAgICBsZXQgcmV0dXJuVmFsdWVcbiAgICBcbiAgICBjb25zdCB4ID0gZ2VuaXNoLmRhdGEoWyAwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSlcbiAgICBjb25zdCB5ID0gZ2VuaXNoLmRhdGEoWyAwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSlcbiAgICBjb25zdCBhID0gZ2VuaXNoLmRhdGEoWyAwLDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgIGNvbnN0IGIgPSBnZW5pc2guZGF0YShbIDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgIFxuICAgIGNvbnN0IFEgPSBnLm1pbiggLjUgKyBfX1EgKiAyMiwgMjIuNSApIFxuICAgIGNvbnN0IGN1dG9mZiA9IGcubWF4KCAuMDA1LCBnLm1pbiggX19jdXRvZmYsLjk5NSApICkgKiBnLmdlbi5zYW1wbGVyYXRlIC8gNCBcbiAgICAvL2xldCB3MCA9IGcubWVtbyggZy5tdWwoIDIgKiBNYXRoLlBJLCBnLmRpdiggZy5tYXgoLjAwNSwgZy5taW4oY3V0b2ZmLC45OTUpKSwgIGcuZ2VuLnNhbXBsZXJhdGUgKSApICksXG4gICAgbGV0IHcwID0gICgyICogTWF0aC5QSSkgKiAoY3V0b2ZmIC8gZy5nZW4uc2FtcGxlcmF0ZSksXG4gICAgICAgIHNpbncwID0gZy5zaW4oIHcwICksXG4gICAgICAgIGNvc3cwID0gZy5jb3MoIHcwICksXG4gICAgICAgIGFscGhhID0gc2ludzAgLyAoIDIgKiBRIClcblxuICAgIC8vbGV0IHcwID0gZy5tZW1vKCBnLm11bCggMiAqIE1hdGguUEksIGcuZGl2KCBjdXRvZmYsICBnLmdlbi5zYW1wbGVyYXRlICkgKSApLFxuICAgICAgXG4gICAgbGV0IG9uZU1pbnVzQ29zVyA9IDEgLSBjb3N3MFxuXG4gICAgLyoqKioqKioqIHByb2Nlc3MgY29lZmZpY2llbnRzICoqKioqKioqL1xuICAgIHN3aXRjaCggbW9kZSApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYVswXSA9ICgxICsgY29zdzApIC8gMlxuICAgICAgICBhWzFdID0gKDEgKyBjb3N3MCkgKiAtMVxuICAgICAgICBhWzJdID0gYVswXVxuICAgICAgICBjICAgID0gMSArIGFscGhhXG4gICAgICAgIGJbMF0gPSAtMiAqIGNvc3cwXG4gICAgICAgIGJbMV0gPSAxIC0gYWxwaGFcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFbMF0gPSBRICogYWxwaGFcbiAgICAgICAgYVsxXSA9IDBcbiAgICAgICAgYVsyXSA9IGFbMF0gKiAtMVxuICAgICAgICBjICAgID0gMSArIGFscGhhXG4gICAgICAgIGJbMF0gPSAtMiAqIGNvc3cwXG4gICAgICAgIGJbMV0gPSAxIC0gYWxwaGFcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBMUFxuICAgICAgICBhWzBdID0gb25lTWludXNDb3NXIC8gMlxuICAgICAgICBhWzFdID0gb25lTWludXNDb3NXXG4gICAgICAgIGFbMl0gPSBhWzBdXG4gICAgICAgIGMgICAgPSAxICsgYWxwaGFcbiAgICAgICAgYlswXSA9IC0yICogY29zdzBcbiAgICAgICAgYlsxXSA9IDEgLSBhbHBoYVxuICAgIH1cblxuICAgIGFbMF0gPSBhWzBdIC8gYzsgYVsxXSA9IGFbMV0gLyBjOyBhWzJdID0gYVsyXSAvIGNcbiAgICBiWzBdID0gYlswXSAvIGM7IGJbMV0gPSBiWzFdIC8gY1xuXG4gICAgLyoqKioqKioqIGVuZCBjb2VmZmljaWVudHMgKioqKioqKiovXG5cbiAgICAvKioqKioqIGxlZnQgLyBtb25vIG91dHB1dCAqKioqKioqKi9cblxuICAgIGxldCBsID0gaXNTdGVyZW8gPT09IHRydWUgPyBpbnB1dFswXSA6IGlucHV0XG4gICAgaW4xYTAgPSBsICogYVswXVxuICAgIHgwYTEgID0geFswXSAqIGFbMV1cbiAgICB4MWEyICA9IHhbMV0gKiBhWzJdXG5cbiAgICB4WzFdID0geFswXSBcbiAgICB4WzBdID0gbFxuXG4gICAgbGV0IHN1bUxlZnQgPSBpbjFhMCArIHgwYTEgKyB4MWEyXG5cbiAgICB5MGIwID0geVswXSAqIGJbMF1cbiAgICB5MWIxID0geVsxXSAqIGJbMV1cbiAgICB5WzFdID0geVswXSBcblxuICAgIGxldCBzdW1SaWdodCA9IHkwYjAgKyB5MWIxXG5cbiAgICBsZXQgZGlmZiA9IHN1bUxlZnQgLSBzdW1SaWdodFxuXG4gICAgeVswXSA9IGRpZmZcbiAgICBcbiAgICAvKioqKioqKiogZW5kIGxlZnQvbW9ubyAqKioqKioqKioqL1xuXG4gICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgY29uc3QgeHIgPSBnZW5pc2guZGF0YShbIDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgICAgY29uc3QgeXIgPSBnZW5pc2guZGF0YShbIDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgICAgLy9sZXQgeDFfMSA9IGcuaGlzdG9yeSgpLCB4Ml8xID0gZy5oaXN0b3J5KCksIHkxXzEgPSBnLmhpc3RvcnkoKSwgeTJfMSA9IGcuaGlzdG9yeSgpXG5cbiAgICAgIGNvbnN0IHIgPSBpbnB1dFsxXSBcbiAgICAgIGluMWEwX3IgPSByICogYVswXSAvL2cubXVsKCB4MV8xLmluKCBpbnB1dFsxXSApLCBhMCApXG4gICAgICB4MGExX3IgID0geHJbMF0gKiBhWzFdLy9nLm11bCggeDJfMS5pbiggeDFfMS5vdXQgKSwgYTEgKVxuICAgICAgeDFhMl9yICA9IHhyWzFdICogYVsyXS8vZy5tdWwoIHgyXzEub3V0LCAgICAgICAgICAgIGEyIClcblxuICAgICAgeHJbMV0gICA9IHhyWzBdXG4gICAgICB4clswXSA9IHJcblxuICAgICAgY29uc3Qgc3VtTGVmdF9yID0gaW4xYTBfciArIHgwYTFfciArIHgxYTJfclxuXG4gICAgICB5MGIwX3IgPSB5clswXSAqIGJbMF0vL2cubXVsKCB5Ml8xLmluKCB5MV8xLm91dCApLCBiMSApXG4gICAgICB5MWIxX3IgPSB5clsxXSAqIGJbMV0vL2cubXVsKCB5Ml8xLm91dCwgYjIgKVxuICAgICAgeXJbMV0gPSB5clswXVxuXG4gICAgICBjb25zdCBzdW1SaWdodF9yID0geTBiMF9yICsgeTFiMV9yXG5cbiAgICAgIGNvbnN0IGRpZmZfciA9IHN1bUxlZnRfciAtIHN1bVJpZ2h0X3JcblxuICAgICAgeXJbMF0gPSBkaWZmX3JcbiAgICAgIFxuICAgICAgcmV0dXJuVmFsdWUgPSBbIGRpZmYsIGRpZmZfciBdXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm5WYWx1ZSA9IGRpZmZcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfVxuXG4gIGxldCBCaXF1YWQgPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBiaXF1YWQgPSBPYmplY3QuY3JlYXRlKCBmaWx0ZXIgKVxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIEJpcXVhZC5kZWZhdWx0cywgaW5wdXRQcm9wcyApIFxuICAgIGxldCBfX291dFxuXG4gICAgT2JqZWN0LmFzc2lnbiggYmlxdWFkLCBwcm9wcyApXG5cbiAgICBiaXF1YWQuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICAgIGlmKCBfX291dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBpc1N0ZXJlbyA9IHByb3BzLmlucHV0ICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09IHVuZGVmaW5lZCA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaXNTdGVyZW8gPSBfX291dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgICBfX291dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgICB9XG4gICAgICBiaXF1YWQuZ3JhcGggPSBHaWJiZXJpc2guZ2VuaXNoLmJpcXVhZCggZy5pbignaW5wdXQnKSwgZy5pbignY3V0b2ZmJyksICBnLmluKCdRJyksIGJpcXVhZC5tb2RlLCBpc1N0ZXJlbyApXG4gICAgfVxuXG4gICAgYmlxdWFkLl9fY3JlYXRlR3JhcGgoKVxuICAgIGJpcXVhZC5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ21vZGUnLCAnaW5wdXQnIF1cblxuICAgIF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoXG4gICAgICBiaXF1YWQsXG4gICAgICBiaXF1YWQuZ3JhcGgsXG4gICAgICBbJ2ZpbHRlcnMnLCdGaWx0ZXIxMkJpcXVhZCddLCBcbiAgICAgIHByb3BzXG4gICAgKVxuXG4gICAgcmV0dXJuIF9fb3V0XG4gIH1cblxuICBCaXF1YWQuZGVmYXVsdHMgPSB7XG4gICAgaW5wdXQ6MCxcbiAgICBROiAuMTUsXG4gICAgY3V0b2ZmOi4wNSxcbiAgICBtb2RlOjBcbiAgfVxuXG4gIHJldHVybiBCaXF1YWRcblxufVxuXG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcblxubGV0IGNvbWJGaWx0ZXIgPSBmdW5jdGlvbiggX2lucHV0LCBjb21iTGVuZ3RoLCBkYW1waW5nPS41Ki40LCBmZWVkYmFja0NvZWZmPS44NCApIHtcbiAgbGV0IGxhc3RTYW1wbGUgICA9IGcuaGlzdG9yeSgpLFxuICBcdCAgcmVhZFdyaXRlSWR4ID0gZy5jb3VudGVyKCAxLDAsY29tYkxlbmd0aCApLFxuICAgICAgY29tYkJ1ZmZlciAgID0gZy5kYXRhKCBjb21iTGVuZ3RoICksXG5cdCAgICBvdXQgICAgICAgICAgPSBnLnBlZWsoIGNvbWJCdWZmZXIsIHJlYWRXcml0ZUlkeCwgeyBpbnRlcnA6J25vbmUnLCBtb2RlOidzYW1wbGVzJyB9KSxcbiAgICAgIHN0b3JlSW5wdXQgICA9IGcubWVtbyggZy5hZGQoIGcubXVsKCBvdXQsIGcuc3ViKCAxLCBkYW1waW5nKSksIGcubXVsKCBsYXN0U2FtcGxlLm91dCwgZGFtcGluZyApICkgKVxuICAgICAgXG4gIGxhc3RTYW1wbGUuaW4oIHN0b3JlSW5wdXQgKVxuIFxuICBnLnBva2UoIGNvbWJCdWZmZXIsIGcuYWRkKCBfaW5wdXQsIGcubXVsKCBzdG9yZUlucHV0LCBmZWVkYmFja0NvZWZmICkgKSwgcmVhZFdyaXRlSWR4IClcbiBcbiAgcmV0dXJuIG91dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbWJGaWx0ZXJcbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZmlsdGVyID0gcmVxdWlyZSggJy4vZmlsdGVyLmpzJyApXG5cbmNvbnN0IGdlbmlzaCA9IGdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgR2liYmVyaXNoLmdlbmlzaC5kaW9kZVpERiA9ICggaW5wdXQsIF9fUSwgX19mcmVxLCBzYXR1cmF0aW9uLCBpc1N0ZXJlbz1mYWxzZSApID0+IHtcbiAgICBjb25zdCBpVCA9IDEgLyBnLmdlbi5zYW1wbGVyYXRlLFxuICAgICAgICAgIGt6MSA9IGcuaGlzdG9yeSgwKSxcbiAgICAgICAgICBrejIgPSBnLmhpc3RvcnkoMCksXG4gICAgICAgICAga3ozID0gZy5oaXN0b3J5KDApLFxuICAgICAgICAgIGt6NCA9IGcuaGlzdG9yeSgwKVxuXG4gICAgbGV0ICAga2ExID0gMS4wLFxuICAgICAgICAgIGthMiA9IDAuNSxcbiAgICAgICAgICBrYTMgPSAwLjUsXG4gICAgICAgICAga2E0ID0gMC41LFxuICAgICAgICAgIGtpbmR4ID0gMCAgIFxuXG4gICAgY29uc3QgZnJlcSA9IGcubXVsKCBnLm1heCguMDA1LCBnLm1pbiggX19mcmVxLCAuOTk1KSksICBnZW5pc2guZ2VuLnNhbXBsZXJhdGUgLyAyIClcbiAgICAvL2NvbnN0IGZyZXEgPSBnLm1heCguMDA1LCBnLm1pbiggX19mcmVxLCAuOTk1KSlcblxuICAgIC8vIFhYWCB0aGlzIGlzIHdoZXJlIHRoZSBtYWdpYyBudW1iZXIgaGFwZW5zIGZvciBRLi4uXG4gICAgY29uc3QgUSA9IGcubWVtbyggZy5hZGQoIC41LCBnLm11bCggX19RLCBnLmFkZCggNSwgZy5zdWIoIDUsIGcubXVsKCBnLmRpdiggZnJlcSwgMjAwMDAgICksIDUgKSApICkgKSApIClcbiAgICAvLyBrd2QgPSAyICogJE1fUEkgKiBhY2Zba2luZHhdXG4gICAgY29uc3Qga3dkID0gZy5tZW1vKCBnLm11bCggTWF0aC5QSSAqIDIsIGZyZXEgKSApXG5cbiAgICAvLyBrd2EgPSAoMi9pVCkgKiB0YW4oa3dkICogaVQvMikgXG4gICAgY29uc3Qga3dhID1nLm1lbW8oIGcubXVsKCAyL2lULCBnLnRhbiggZy5tdWwoIGt3ZCwgaVQvMiApICkgKSApXG5cbiAgICAvLyBrRyAgPSBrd2EgKiBpVC8yIFxuICAgIGNvbnN0IGtnID0gZy5tZW1vKCBnLm11bCgga3dhLCBpVC8yICkgKVxuICAgIFxuICAgIGNvbnN0IGtHNCA9IGcubWVtbyggZy5tdWwoIC41LCBnLmRpdigga2csIGcuYWRkKCAxLCBrZyApICkgKSApXG4gICAgY29uc3Qga0czID0gZy5tZW1vKCBnLm11bCggLjUsIGcuZGl2KCBrZywgZy5zdWIoIGcuYWRkKCAxLCBrZyApLCBnLm11bCggZy5tdWwoIC41LCBrZyApLCBrRzQgKSApICkgKSApXG4gICAgY29uc3Qga0cyID0gZy5tZW1vKCBnLm11bCggLjUsIGcuZGl2KCBrZywgZy5zdWIoIGcuYWRkKCAxLCBrZyApLCBnLm11bCggZy5tdWwoIC41LCBrZyApLCBrRzMgKSApICkgKSApXG4gICAgY29uc3Qga0cxID0gZy5tZW1vKCBnLmRpdigga2csIGcuc3ViKCBnLmFkZCggMSwga2cgKSwgZy5tdWwoIGtnLCBrRzIgKSApICkgKVxuXG4gICAgY29uc3Qga0dBTU1BID0gZy5tZW1vKCBnLm11bCggZy5tdWwoIGtHNCwga0czICkgLCBnLm11bCgga0cyLCBrRzEgKSApIClcblxuICAgIGNvbnN0IGtTRzEgPSBnLm1lbW8oIGcubXVsKCBnLm11bCgga0c0LCBrRzMgKSwga0cyICkgKSBcblxuICAgIGNvbnN0IGtTRzIgPSBnLm1lbW8oIGcubXVsKCBrRzQsIGtHMykgKSAgXG4gICAgY29uc3Qga1NHMyA9IGtHNCBcbiAgICBsZXQga1NHNCA9IDEuMCBcbiAgICAvLyBrayA9IDQuMCooa1EgLSAwLjUpLygyNS4wIC0gMC41KVxuICAgIGNvbnN0IGthbHBoYSA9IGcubWVtbyggZy5kaXYoIGtnLCBnLmFkZCgxLjAsIGtnKSApIClcblxuICAgIGNvbnN0IGtiZXRhMSA9IGcubWVtbyggZy5kaXYoIDEuMCwgZy5zdWIoIGcuYWRkKCAxLCBrZyApLCBnLm11bCgga2csIGtHMiApICkgKSApXG4gICAgY29uc3Qga2JldGEyID0gZy5tZW1vKCBnLmRpdiggMS4wLCBnLnN1YiggZy5hZGQoIDEsIGtnICksIGcubXVsKCBnLm11bCggLjUsIGtnICksIGtHMyApICkgKSApXG4gICAgY29uc3Qga2JldGEzID0gZy5tZW1vKCBnLmRpdiggMS4wLCBnLnN1YiggZy5hZGQoIDEsIGtnICksIGcubXVsKCBnLm11bCggLjUsIGtnICksIGtHNCApICkgKSApXG4gICAgY29uc3Qga2JldGE0ID0gZy5tZW1vKCBnLmRpdiggMS4wLCBnLmFkZCggMSwga2cgKSApICkgXG5cbiAgICBjb25zdCBrZ2FtbWExID0gZy5tZW1vKCBnLmFkZCggMSwgZy5tdWwoIGtHMSwga0cyICkgKSApXG4gICAgY29uc3Qga2dhbW1hMiA9IGcubWVtbyggZy5hZGQoIDEsIGcubXVsKCBrRzIsIGtHMyApICkgKVxuICAgIGNvbnN0IGtnYW1tYTMgPSBnLm1lbW8oIGcuYWRkKCAxLCBnLm11bCgga0czLCBrRzQgKSApIClcblxuICAgIGNvbnN0IGtkZWx0YTEgPSBrZ1xuICAgIGNvbnN0IGtkZWx0YTIgPSBnLm1lbW8oIGcubXVsKCAwLjUsIGtnICkgKVxuICAgIGNvbnN0IGtkZWx0YTMgPSBnLm1lbW8oIGcubXVsKCAwLjUsIGtnICkgKVxuXG4gICAgY29uc3Qga2Vwc2lsb24xID0ga0cyXG4gICAgY29uc3Qga2Vwc2lsb24yID0ga0czXG4gICAgY29uc3Qga2Vwc2lsb24zID0ga0c0XG5cbiAgICBjb25zdCBrbGFzdGN1dCA9IGZyZXFcblxuICAgIC8vOzsgZmVlZGJhY2sgaW5wdXRzIFxuICAgIGNvbnN0IGtmYjQgPSBnLm1lbW8oIGcubXVsKCBrYmV0YTQgLCBrejQub3V0ICkgKSBcbiAgICBjb25zdCBrZmIzID0gZy5tZW1vKCBnLm11bCgga2JldGEzLCBnLmFkZCgga3ozLm91dCwgZy5tdWwoIGtmYjQsIGtkZWx0YTMgKSApICkgKVxuICAgIGNvbnN0IGtmYjIgPSBnLm1lbW8oIGcubXVsKCBrYmV0YTIsIGcuYWRkKCBrejIub3V0LCBnLm11bCgga2ZiMywga2RlbHRhMiApICkgKSApXG5cbiAgICAvLzs7IGZlZWRiYWNrIHByb2Nlc3NcblxuICAgIGNvbnN0IGtmYm8xID0gZy5tZW1vKCBnLm11bCgga2JldGExLCBnLmFkZCgga3oxLm91dCwgZy5tdWwoIGtmYjIsIGtkZWx0YTEgKSApICkgKSBcbiAgICBjb25zdCBrZmJvMiA9IGcubWVtbyggZy5tdWwoIGtiZXRhMiwgZy5hZGQoIGt6Mi5vdXQsIGcubXVsKCBrZmIzLCBrZGVsdGEyICkgKSApICkgXG4gICAgY29uc3Qga2ZibzMgPSBnLm1lbW8oIGcubXVsKCBrYmV0YTMsIGcuYWRkKCBrejMub3V0LCBnLm11bCgga2ZiNCwga2RlbHRhMyApICkgKSApIFxuICAgIGNvbnN0IGtmYm80ID0ga2ZiNFxuXG4gICAgY29uc3Qga1NJR01BID0gZy5tZW1vKCBcbiAgICAgIGcuYWRkKCBcbiAgICAgICAgZy5hZGQoIFxuICAgICAgICAgIGcubXVsKCBrU0cxLCBrZmJvMSApLCBcbiAgICAgICAgICBnLm11bCgga1NHMiwga2ZibzIgKVxuICAgICAgICApLCBcbiAgICAgICAgZy5hZGQoXG4gICAgICAgICAgZy5tdWwoIGtTRzMsIGtmYm8zICksIFxuICAgICAgICAgIGcubXVsKCBrU0c0LCBrZmJvNCApXG4gICAgICAgICkgXG4gICAgICApIFxuICAgIClcblxuICAgIC8vY29uc3Qga1NJR01BID0gMVxuICAgIC8vOzsgbm9uLWxpbmVhciBwcm9jZXNzaW5nXG4gICAgLy9pZiAoa25scCA9PSAxKSB0aGVuXG4gICAgLy8gIGtpbiA9ICgxLjAgLyB0YW5oKGtzYXR1cmF0aW9uKSkgKiB0YW5oKGtzYXR1cmF0aW9uICoga2luKVxuICAgIC8vZWxzZWlmIChrbmxwID09IDIpIHRoZW5cbiAgICAvLyAga2luID0gdGFuaChrc2F0dXJhdGlvbiAqIGtpbikgXG4gICAgLy9lbmRpZlxuICAgIC8vXG4gICAgLy9jb25zdCBraW4gPSBpbnB1dCBcbiAgICBsZXQga2luID0gaXNTdGVyZW8gPT09IHRydWUgPyBnLmFkZCggaW5wdXRbMF0sIGlucHV0WzFdICkgOiBpbnB1dC8vZy5tZW1vKCBnLm11bCggZy5kaXYoIDEsIGcudGFuaCggc2F0dXJhdGlvbiApICksIGcudGFuaCggZy5tdWwoIHNhdHVyYXRpb24sIGlucHV0ICkgKSApIClcbiAgICBraW4gPSBnLnRhbmgoIGcubXVsKCBzYXR1cmF0aW9uLCBraW4gKSApXG5cbiAgICBjb25zdCBrdW4gPSBnLmRpdiggZy5zdWIoIGtpbiwgZy5tdWwoIFEsIGtTSUdNQSApICksIGcuYWRkKCAxLCBnLm11bCggUSwga0dBTU1BICkgKSApXG4gICAgLy9jb25zdCBrdW4gPSBnLmRpdiggMSwgZy5hZGQoIDEsIGcubXVsKCBRLCBrR0FNTUEgKSApIClcbiAgICAgICAgLy8oa2luIC0ga2sgKiBrU0lHTUEpIC8gKDEuMCArIGtrICoga0dBTU1BKVxuXG4gICAgLy87OyAxc3Qgc3RhZ2VcbiAgICBsZXQga3hpbiA9IGcubWVtbyggZy5hZGQoIGcuYWRkKCBnLm11bCgga3VuLCBrZ2FtbWExICksIGtmYjIpLCBnLm11bCgga2Vwc2lsb24xLCBrZmJvMSApICkgKVxuICAgIC8vIChrdW4gKiBrZ2FtbWExICsga2ZiMiArIGtlcHNpbG9uMSAqIGtmYm8xKVxuICAgIGxldCBrdiA9IGcubWVtbyggZy5tdWwoIGcuc3ViKCBnLm11bCgga2ExLCBreGluICksIGt6MS5vdXQgKSwga2FscGhhICkgKVxuICAgIC8va3YgPSAoa2ExICoga3hpbiAtIGt6MSkgKiBrYWxwaGEgXG4gICAgbGV0IGtscCA9IGcuYWRkKCBrdiwga3oxLm91dCApXG4gICAgLy9rbHAgPSBrdiArIGt6MVxuICAgIGt6MS5pbiggZy5hZGQoIGtscCwga3YgKSApIFxuICAgIC8va3oxID0ga2xwICsga3ZcblxuICAgICAgICAvLzs7IDJuZCBzdGFnZVxuICAgIC8va3hpbiA9IChrbHAgKiBrZ2FtbWEyICsga2ZiMyArIGtlcHNpbG9uMiAqIGtmYm8yKVxuICAgIC8va3YgPSAoa2EyICoga3hpbiAtIGt6MikgKiBrYWxwaGEgXG4gICAgLy9rbHAgPSBrdiArIGt6MlxuICAgIC8va3oyID0ga2xwICsga3ZcblxuICAgIGt4aW4gPSBnLm1lbW8oIGcuYWRkKCBnLmFkZCggZy5tdWwoIGtscCwga2dhbW1hMiApLCBrZmIzKSwgZy5tdWwoIGtlcHNpbG9uMiwga2ZibzIgKSApIClcbiAgICAvLyAoa3VuICoga2dhbW1hMSArIGtmYjIgKyBrZXBzaWxvbjEgKiBrZmJvMSlcbiAgICBrdiA9IGcubWVtbyggZy5tdWwoIGcuc3ViKCBnLm11bCgga2EyLCBreGluICksIGt6Mi5vdXQgKSwga2FscGhhICkgKVxuICAgIC8va3YgPSAoa2ExICoga3hpbiAtIGt6MSkgKiBrYWxwaGEgXG4gICAga2xwID0gZy5hZGQoIGt2LCBrejIub3V0ICkgXG4gICAgLy9rbHAgPSBrdiArIGt6MVxuICAgIGt6Mi5pbiggZy5hZGQoIGtscCwga3YgKSApIFxuICAgIC8va3oxID0ga2xwICsga3ZcblxuICAgIC8vOzsgM3JkIHN0YWdlXG4gICAgLy9reGluID0gKGtscCAqIGtnYW1tYTMgKyBrZmI0ICsga2Vwc2lsb24zICoga2ZibzMpXG4gICAgLy9rdiA9IChrYTMgKiBreGluIC0ga3ozKSAqIGthbHBoYSBcbiAgICAvL2tscCA9IGt2ICsga3ozXG4gICAgLy9rejMgPSBrbHAgKyBrdlxuXG4gICAga3hpbiA9IGcubWVtbyggZy5hZGQoIGcuYWRkKCBnLm11bCgga2xwLCBrZ2FtbWEzICksIGtmYjQpLCBnLm11bCgga2Vwc2lsb24zLCBrZmJvMyApICkgKVxuICAgIC8vIChrdW4gKiBrZ2FtbWExICsga2ZiMiArIGtlcHNpbG9uMSAqIGtmYm8xKVxuICAgIGt2ID0gZy5tZW1vKCBnLm11bCggZy5zdWIoIGcubXVsKCBrYTMsIGt4aW4gKSwga3ozLm91dCApLCBrYWxwaGEgKSApXG4gICAgLy9rdiA9IChrYTEgKiBreGluIC0ga3oxKSAqIGthbHBoYSBcbiAgICBrbHAgPSBnLmFkZCgga3YsIGt6My5vdXQgKVxuICAgIC8va2xwID0ga3YgKyBrejFcbiAgICBrejMuaW4oIGcuYWRkKCBrbHAsIGt2ICkgKVxuICAgIC8va3oxID0ga2xwICsga3ZcblxuICAgIC8vOzsgNHRoIHN0YWdlXG4gICAgLy9rdiA9IChrYTQgKiBrbHAgLSBrejQpICoga2FscGhhIFxuICAgIC8va2xwID0ga3YgKyBrejRcbiAgICAvL2t6NCA9IGtscCArIGt2XG5cbiAgICAvLyAoa3VuICoga2dhbW1hMSArIGtmYjIgKyBrZXBzaWxvbjEgKiBrZmJvMSlcbiAgICBrdiA9IGcubWVtbyggZy5tdWwoIGcuc3ViKCBnLm11bCgga2E0LCBreGluICksIGt6NC5vdXQgKSwga2FscGhhICkgKVxuICAgIC8va3YgPSAoa2ExICoga3hpbiAtIGt6MSkgKiBrYWxwaGEgXG4gICAga2xwID0gZy5hZGQoIGt2LCBrejQub3V0IClcbiAgICAvL2tscCA9IGt2ICsga3oxXG4gICAga3o0LmluKCBnLmFkZCgga2xwLCBrdiApIClcblxuICAgIC8va3oxID0ga2xwICsga3ZcbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICAvL2xldCBwb2xlc1IgPSBnLmRhdGEoWyAwLDAsMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgLy8gICAgcmV6elIgPSBnLmNsYW1wKCBnLm11bCggcG9sZXNSWzNdLCByZXogKSApLFxuICAgICAgLy8gICAgb3V0cHV0UiA9IGcuc3ViKCBpbnB1dFsxXSwgcmV6elIgKSAgICAgICAgIFxuXG4gICAgICAvL3BvbGVzUlswXSA9IGcuYWRkKCBwb2xlc1JbMF0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlswXSApLCBvdXRwdXRSICAgKSwgY3V0b2ZmICkpXG4gICAgICAvL3BvbGVzUlsxXSA9IGcuYWRkKCBwb2xlc1JbMV0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlsxXSApLCBwb2xlc1JbMF0gKSwgY3V0b2ZmICkpXG4gICAgICAvL3BvbGVzUlsyXSA9IGcuYWRkKCBwb2xlc1JbMl0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlsyXSApLCBwb2xlc1JbMV0gKSwgY3V0b2ZmICkpXG4gICAgICAvL3BvbGVzUlszXSA9IGcuYWRkKCBwb2xlc1JbM10sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlszXSApLCBwb2xlc1JbMl0gKSwgY3V0b2ZmICkpXG5cbiAgICAgIC8vbGV0IHJpZ2h0ID0gZy5zd2l0Y2goIGlzTG93UGFzcywgcG9sZXNSWzNdLCBnLnN1Yiggb3V0cHV0UiwgcG9sZXNSWzNdICkgKVxuXG4gICAgICAvL3JldHVyblZhbHVlID0gW2xlZnQsIHJpZ2h0XVxuICAgIH1lbHNle1xuICAgICAvLyByZXR1cm5WYWx1ZSA9IGtscFxuICAgIH1cbiAgICAvL3JldHVyblZhbHVlID0ga2xwXG4gICAgXG4gICAgcmV0dXJuIGtscFxuIH1cblxuICBjb25zdCBEaW9kZVpERiA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHpkZiAgICAgID0gT2JqZWN0LmNyZWF0ZSggZmlsdGVyIClcbiAgICBjb25zdCBwcm9wcyAgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBEaW9kZVpERi5kZWZhdWx0cywgZmlsdGVyLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBjb25zdCBpc1N0ZXJlbyA9IHByb3BzLmlucHV0LmlzU3RlcmVvIFxuXG4gICAgT2JqZWN0LmFzc2lnbiggemRmLCBwcm9wcyApXG5cbiAgICBjb25zdCBfX291dCA9IEdpYmJlcmlzaC5mYWN0b3J5KFxuICAgICAgemRmLCBcbiAgICAgIEdpYmJlcmlzaC5nZW5pc2guZGlvZGVaREYoIGcuaW4oJ2lucHV0JyksIGcuaW4oJ1EnKSwgZy5pbignY3V0b2ZmJyksIGcuaW4oJ3NhdHVyYXRpb24nKSwgaXNTdGVyZW8gKSwgXG4gICAgICBbJ2ZpbHRlcnMnLCdGaWx0ZXIyNFRCMzAzJ10sXG4gICAgICBwcm9wc1xuICAgIClcblxuICAgIHJldHVybiBfX291dCBcbiAgfVxuXG4gIERpb2RlWkRGLmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgUTogLjY1LFxuICAgIHNhdHVyYXRpb246IDEsXG4gICAgY3V0b2ZmOi41IFxuICB9XG5cbiAgcmV0dXJuIERpb2RlWkRGXG5cbn1cbiIsImxldCB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKVxuXG5sZXQgZmlsdGVyID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbk9iamVjdC5hc3NpZ24oIGZpbHRlciwge1xuICBkZWZhdWx0czogeyBieXBhc3M6ZmFsc2UgfSBcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyXG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgZmlsdGVyID0gcmVxdWlyZSggJy4vZmlsdGVyLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBHaWJiZXJpc2guZ2VuaXNoLmZpbHRlcjI0ID0gKCBpbnB1dCwgX3JleiwgX2N1dG9mZiwgaXNMb3dQYXNzLCBpc1N0ZXJlbz1mYWxzZSApID0+IHtcbiAgICBsZXQgcmV0dXJuVmFsdWUsXG4gICAgICAgIHBvbGVzTCA9IGcuZGF0YShbIDAsMCwwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIHBlZWtQcm9wcyA9IHsgaW50ZXJwOidub25lJywgbW9kZTonc2ltcGxlJyB9LFxuICAgICAgICByZXogPSBnLm1lbW8oIGcubXVsKCBfcmV6LCA1ICkgKSxcbiAgICAgICAgY3V0b2ZmID0gZy5tZW1vKCBnLmRpdiggX2N1dG9mZiwgMTEwMjUgKSApLFxuICAgICAgICByZXp6TCA9IGcuY2xhbXAoIGcubXVsKCBwb2xlc0xbM10sIHJleiApICksXG4gICAgICAgIG91dHB1dEwgPSBnLnN1YiggaXNTdGVyZW8gPyBpbnB1dFswXSA6IGlucHV0LCByZXp6TCApIFxuXG4gICAgcG9sZXNMWzBdID0gZy5hZGQoIHBvbGVzTFswXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNMWzBdICksIG91dHB1dEwgICApLCBjdXRvZmYgKSlcbiAgICBwb2xlc0xbMV0gPSBnLmFkZCggcG9sZXNMWzFdLCBnLm11bCggZy5hZGQoIGcubXVsKC0xLCBwb2xlc0xbMV0gKSwgcG9sZXNMWzBdICksIGN1dG9mZiApKVxuICAgIHBvbGVzTFsyXSA9IGcuYWRkKCBwb2xlc0xbMl0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzTFsyXSApLCBwb2xlc0xbMV0gKSwgY3V0b2ZmICkpXG4gICAgcG9sZXNMWzNdID0gZy5hZGQoIHBvbGVzTFszXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNMWzNdICksIHBvbGVzTFsyXSApLCBjdXRvZmYgKSlcbiAgICBcbiAgICBsZXQgbGVmdCA9IGcuc3dpdGNoKCBpc0xvd1Bhc3MsIHBvbGVzTFszXSwgZy5zdWIoIG91dHB1dEwsIHBvbGVzTFszXSApIClcblxuICAgIGlmKCBpc1N0ZXJlbyApIHtcbiAgICAgIGxldCBwb2xlc1IgPSBnLmRhdGEoWyAwLDAsMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICAgIHJlenpSID0gZy5jbGFtcCggZy5tdWwoIHBvbGVzUlszXSwgcmV6ICkgKSxcbiAgICAgICAgICBvdXRwdXRSID0gZy5zdWIoIGlucHV0WzFdLCByZXp6UiApICAgICAgICAgXG5cbiAgICAgIHBvbGVzUlswXSA9IGcuYWRkKCBwb2xlc1JbMF0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlswXSApLCBvdXRwdXRSICAgKSwgY3V0b2ZmICkpXG4gICAgICBwb2xlc1JbMV0gPSBnLmFkZCggcG9sZXNSWzFdLCBnLm11bCggZy5hZGQoIGcubXVsKC0xLCBwb2xlc1JbMV0gKSwgcG9sZXNSWzBdICksIGN1dG9mZiApKVxuICAgICAgcG9sZXNSWzJdID0gZy5hZGQoIHBvbGVzUlsyXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzJdICksIHBvbGVzUlsxXSApLCBjdXRvZmYgKSlcbiAgICAgIHBvbGVzUlszXSA9IGcuYWRkKCBwb2xlc1JbM10sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlszXSApLCBwb2xlc1JbMl0gKSwgY3V0b2ZmICkpXG5cbiAgICAgIGxldCByaWdodCA9IGcuc3dpdGNoKCBpc0xvd1Bhc3MsIHBvbGVzUlszXSwgZy5zdWIoIG91dHB1dFIsIHBvbGVzUlszXSApIClcblxuICAgICAgcmV0dXJuVmFsdWUgPSBbbGVmdCwgcmlnaHRdXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm5WYWx1ZSA9IGxlZnRcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfVxuXG4gIGxldCBGaWx0ZXIyNCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGxldCBmaWx0ZXIyNCAgID0gT2JqZWN0LmNyZWF0ZSggZmlsdGVyIClcbiAgICBsZXQgcHJvcHMgICAgPSBPYmplY3QuYXNzaWduKCB7fSwgRmlsdGVyMjQuZGVmYXVsdHMsIGZpbHRlci5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgbGV0IGlzU3RlcmVvID0gcHJvcHMuaW5wdXQuaXNTdGVyZW8gXG5cbiAgICBjb25zdCBfX291dCA9IEdpYmJlcmlzaC5mYWN0b3J5KFxuICAgICAgZmlsdGVyMjQsIFxuICAgICAgR2liYmVyaXNoLmdlbmlzaC5maWx0ZXIyNCggZy5pbignaW5wdXQnKSwgZy5pbignUScpLCBnLmluKCdjdXRvZmYnKSwgZy5pbignaXNMb3dQYXNzJyksIGlzU3RlcmVvICksIFxuICAgICAgWydmaWx0ZXJzJywnRmlsdGVyMjRDbGFzc2ljJ10sXG4gICAgICBwcm9wc1xuICAgIClcblxuICAgIHJldHVybiBfX291dFxuICB9XG5cblxuICBGaWx0ZXIyNC5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIFE6IC4yNSxcbiAgICBjdXRvZmY6IDg4MCxcbiAgICBpc0xvd1Bhc3M6MVxuICB9XG5cbiAgcmV0dXJuIEZpbHRlcjI0XG5cbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IGcgPSBHaWJiZXJpc2guZ2VuaXNoXG5cbiAgY29uc3QgZmlsdGVycyA9IHtcbiAgICBGaWx0ZXIyNENsYXNzaWMgOiByZXF1aXJlKCAnLi9maWx0ZXIyNC5qcycgICkoIEdpYmJlcmlzaCApLFxuICAgIEZpbHRlcjI0TW9vZyAgICA6IHJlcXVpcmUoICcuL2xhZGRlci5kc3AuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIEZpbHRlcjI0VEIzMDMgICA6IHJlcXVpcmUoICcuL2Rpb2RlRmlsdGVyWkRGLmpzJyApKCBHaWJiZXJpc2ggKSxcbiAgICBGaWx0ZXIxMkJpcXVhZCAgOiByZXF1aXJlKCAnLi9iaXF1YWQuZHNwLmpzJyAgICApKCBHaWJiZXJpc2ggKSxcbiAgICBGaWx0ZXIxMlNWRiAgICAgOiByZXF1aXJlKCAnLi9zdmYuanMnICAgICAgICkoIEdpYmJlcmlzaCApLFxuICAgIFxuICAgIC8vIG5vdCBmb3IgdXNlIGJ5IGVuZC11c2Vyc1xuICAgIGdlbmlzaDoge1xuICAgICAgQ29tYiAgICAgICAgOiByZXF1aXJlKCAnLi9jb21iZmlsdGVyLmpzJyApLFxuICAgICAgQWxsUGFzcyAgICAgOiByZXF1aXJlKCAnLi9hbGxwYXNzLmpzJyApXG4gICAgfSxcblxuICAgIGZhY3RvcnkoIGlucHV0LCBjdXRvZmYsIHNhdHVyYXRpb24sIF9wcm9wcywgaXNTdGVyZW8gPSBmYWxzZSApIHtcbiAgICAgIGxldCBmaWx0ZXJlZE9zYyBcblxuICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVycy5kZWZhdWx0cywgX3Byb3BzIClcblxuICAgICAgc3dpdGNoKCBwcm9wcy5maWx0ZXJNb2RlbCApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZpbHRlcmVkT3NjID0gZy56ZDI0KCBpbnB1dCwgZy5taW4oIGcuaW4oJ1EnKSwgLjk5OTkgKSwgY3V0b2ZmLCAwICkgLy8gZy5tYXgoLjAwNSwgZy5taW4oIGN1dG9mZiwgMSApICkgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBnLmRpb2RlWkRGKCBpbnB1dCwgZy5taW4oIGcuaW4oJ1EnKSwgLjk5OTkgKSwgY3V0b2ZmLCBzYXR1cmF0aW9uLCBpc1N0ZXJlbyApIFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBnLnN2ZiggaW5wdXQsIGN1dG9mZiwgZy5zdWIoIDEsIGcuaW4oJ1EnKSksIHByb3BzLmZpbHRlck1vZGUsIGlzU3RlcmVvLCB0cnVlICkgXG4gICAgICAgICAgYnJlYWs7IFxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBnLmJpcXVhZCggaW5wdXQsIGN1dG9mZiwgIGcuaW4oJ1EnKSwgcHJvcHMuZmlsdGVyTW9kZSwgaXNTdGVyZW8gKSBcbiAgICAgICAgICBicmVhazsgXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAvL2lzTG93UGFzcyA9IGcucGFyYW0oICdsb3dQYXNzJywgMSApLFxuICAgICAgICAgIGZpbHRlcmVkT3NjID0gZy5maWx0ZXIyNCggaW5wdXQsIGcuaW4oJ1EnKSwgY3V0b2ZmLCBwcm9wcy5maWx0ZXJNb2RlLCBpc1N0ZXJlbyApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gcmV0dXJuIHVuZmlsdGVyZWQgc2lnbmFsXG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBpbnB1dCAvL2cuZmlsdGVyMjQoIG9zY1dpdGhHYWluLCBnLmluKCdyZXNvbmFuY2UnKSwgY3V0b2ZmLCBpc0xvd1Bhc3MgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsdGVyZWRPc2NcbiAgICB9LFxuXG4gICAgZGVmYXVsdHM6IHsgZmlsdGVyTW9kZTogMCwgZmlsdGVyTW9kZWw6MCB9XG4gIH1cblxuICBmaWx0ZXJzLmV4cG9ydCA9IHRhcmdldCA9PiB7XG4gICAgZm9yKCBsZXQga2V5IGluIGZpbHRlcnMgKSB7XG4gICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyAmJiBrZXkgIT09ICdnZW5pc2gnICkge1xuICAgICAgICB0YXJnZXRbIGtleSBdID0gZmlsdGVyc1sga2V5IF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxucmV0dXJuIGZpbHRlcnNcblxufVxuIiwiY29uc3QgZ2VuaXNoID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGZpbHRlclByb3RvID0gcmVxdWlyZSggJy4vZmlsdGVyLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBtYWtlQ2hhbm5lbCA9IGZ1bmN0aW9uKCBpbnB1dCwgX1EsIF9mcmVxICkge1xuICAgICd1c2UganNkc3AnXG4gICAgY29uc3QgaVQgPSAxIC8gZ2VuaXNoLmdlbi5zYW1wbGVyYXRlLFxuICAgICAgICAgIHogID0gZ2VuaXNoLmRhdGEoWyAwLDAsMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pXG5cbiAgICBjb25zdCBmcmVxID0gZ2VuaXNoLm1heCguMDA1LCBnZW5pc2gubWluKCBfZnJlcSwgMSApICkgXG4gICAgY29uc3QgUSA9IC41ICsgX1EgKiAyM1xuICAgIC8vIGt3ZCA9IDIgKiAkTV9QSSAqIGFjZltraW5keF1cbiAgICBjb25zdCBrd2QgPSAoIE1hdGguUEkgKiAyICkgKiBmcmVxICogZ2VuaXNoLmdlbi5zYW1wbGVyYXRlIC8gMlxuXG4gICAgLy8ga3dhID0gKDIvaVQpICogdGFuKGt3ZCAqIGlULzIpIFxuICAgIGNvbnN0IGt3YSA9IDIvaVQgKiBnZW5pc2gudGFuKCBrd2QgKiBpVC8yIClcblxuICAgIC8vIGtHICA9IGt3YSAqIGlULzIgXG4gICAgY29uc3Qga2cgPSBrd2EgKiBpVC8yXG5cbiAgICAvLyBrayA9IDQuMCooa1EgLSAwLjUpLygyNS4wIC0gMC41KVxuICAgIGNvbnN0IGtrID0gNCAqIChRIC0gLjUpIC8gMjQuNVxuXG4gICAgLy8ga2dfcGx1c18xID0gKDEuMCArIGtnKVxuICAgIGNvbnN0IGtnX3BsdXNfMSA9IDEgKyBrZ1xuXG4gICAgLy8ga0cgPSBrZyAvIGtnX3BsdXNfMSBcbiAgICBjb25zdCBrRyAgICAgPSBrZyAvIGtnX3BsdXNfMSxcbiAgICAgICAgICBrR18yICAgPSBrRyAqIGtHLFxuICAgICAgICAgIGtHXzMgICA9IGtHXzIgKiBrRyxcbiAgICAgICAgICBrR0FNTUEgPSBrR18yICoga0dfMlxuXG4gICAgY29uc3Qga1MxID0gelswXSAvIGtnX3BsdXNfMSxcbiAgICAgICAgICBrUzIgPSB6WzFdIC8ga2dfcGx1c18xLFxuICAgICAgICAgIGtTMyA9IHpbMl0gLyBrZ19wbHVzXzEsXG4gICAgICAgICAga1M0ID0gelszXSAvIGtnX3BsdXNfMVxuXG4gICAgLy9rUyA9IGtHXzMgKiBrUzEgICsga0dfMiAqIGtTMiArIGtHICoga1MzICsga1M0IFxuICAgIGNvbnN0IGtTID0ga0dfMyAqIGtTMSArIGtHXzIgKiBrUzIgKyBrRyAqIGtTMyArIGtTNFxuXG4gICAgLy9rdSA9IChraW4gLSBrayAqICBrUykgLyAoMSArIGtrICoga0dBTU1BKVxuICAgIGNvbnN0IGt1ICA9IChpbnB1dCAtIGtrICoga1MpIC8gKDEgKyBrayAqIGtHQU1NQSlcblxuICAgIGxldCBrdiA9ICAoIGt1IC0gelswXSApICoga0dcbiAgICBsZXQga2xwID0ga3YgKyB6WzBdXG4gICAgelswXSA9IGtscCArIGt2XG5cbiAgICBrdiAgPSAoIGtscCAtIHpbMV0gKSAqIGtHXG4gICAga2xwID0ga3YgKyB6WzFdXG4gICAgelsxXSA9IGtscCArIGt2XG5cbiAgICBrdiAgPSAoa2xwIC0gelsyXSApICoga0dcbiAgICBrbHAgPSBrdiArIHpbMl1cbiAgICB6WzJdID0ga2xwICsga3ZcblxuICAgIGt2ICA9IChrbHAgLSB6WzNdICkgKiBrR1xuICAgIGtscCA9IGt2ICsgelszXVxuICAgIHpbM10gPSBrbHAgKyBrdlxuXG4gICAgcmV0dXJuIGtscFxuICB9XG5cbiAgR2liYmVyaXNoLmdlbmlzaC56ZDI0ID0gKCBpbnB1dCwgX1EsIGZyZXEsIGlzU3RlcmVvPWZhbHNlICkgPT4ge1xuICAgIGNvbnN0IGxlZnRJbnB1dCA9IGlzU3RlcmVvID09PSB0cnVlID8gaW5wdXRbMF0gOiBpbnB1dFxuICAgIGNvbnN0IGxlZnQgPSBtYWtlQ2hhbm5lbCggbGVmdElucHV0LCBfUSwgZnJlcSApXG5cbiAgICBsZXQgb3V0XG4gICAgaWYoIGlzU3RlcmVvID09PSB0cnVlICkge1xuICAgICAgY29uc3QgcmlnaHQgPSBtYWtlQ2hhbm5lbCggaW5wdXRbMV0sIF9RLCBmcmVxIClcbiAgICAgIG91dCA9IFsgbGVmdCwgcmlnaHQgXVxuICAgIH1lbHNle1xuICAgICAgb3V0ID0gbGVmdFxuICAgIH1cblxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGNvbnN0IFpkMjQgPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBmaWx0ZXIgICA9IE9iamVjdC5jcmVhdGUoIGZpbHRlclByb3RvIClcbiAgICBjb25zdCBwcm9wcyAgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBaZDI0LmRlZmF1bHRzLCBmaWx0ZXIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIGxldCBvdXRcblxuICAgIGZpbHRlci5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG4gICAgZmlsdGVyLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlzU3RlcmVvID0gcHJvcHMuaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gdW5kZWZpbmVkID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICAgIH1lbHNle1xuICAgICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgICAgfVxuXG4gICAgICBmaWx0ZXIuZ3JhcGggPSBHaWJiZXJpc2guZ2VuaXNoLnpkMjQoIGdlbmlzaC5pbignaW5wdXQnKSwgZ2VuaXNoLmluKCdRJyksIGdlbmlzaC5pbignY3V0b2ZmJyksIGlzU3RlcmVvICkgXG4gICAgfSBcblxuICAgIGZpbHRlci5fX2NyZWF0ZUdyYXBoKClcblxuICAgIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KFxuICAgICAgZmlsdGVyLCBcbiAgICAgIGZpbHRlci5ncmFwaCwgXG4gICAgICBbJ2ZpbHRlcnMnLCdGaWx0ZXIyNE1vb2cnXSxcbiAgICAgIHByb3BzXG4gICAgKVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgWmQyNC5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIFE6IC43NSxcbiAgICBjdXRvZmY6IC4yNSxcbiAgfVxuXG4gIHJldHVybiBaZDI0XG5cbn1cblxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBmaWx0ZXIgPSByZXF1aXJlKCAnLi9maWx0ZXIuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBHaWJiZXJpc2guZ2VuaXNoLnN2ZiA9ICggaW5wdXQsIGN1dG9mZiwgUSwgbW9kZSwgaXNTdGVyZW89ZmFsc2UsIHNob3VsZENvbnZlcnRGcmVxUT1mYWxzZSApID0+IHtcbiAgICBsZXQgZDEgPSBnLmRhdGEoWzAsMF0sIDEsIHsgbWV0YTp0cnVlIH0pLCBkMiA9IGcuZGF0YShbMCwwXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIHBlZWtQcm9wcyA9IHsgbW9kZTonc2ltcGxlJywgaW50ZXJwOidub25lJyB9XG5cbiAgICBpZiggc2hvdWxkQ29udmVydEZyZXFRID09PSB0cnVlICkge1xuICAgICAgLy9RID0gZy5taW4oIGcuYWRkKC4wMSAsIF9fUSksIDEgKSBcbiAgICAgIGN1dG9mZiA9IGcubXVsKCBnLm1heCggLjAwNSwgZy5taW4oIGN1dG9mZiwuOTk1ICkgKSwgZy5kaXYoIGcuZ2VuLnNhbXBsZXJhdGUsIDQgKSApXG4gICAgfVxuXG4gICAgbGV0IGYxID0gZy5tZW1vKCBnLm11bCggMiAqIE1hdGguUEksIGcuZGl2KCBjdXRvZmYsIGcuZ2VuLnNhbXBsZXJhdGUgKSApIClcbiAgICBsZXQgb25lT3ZlclEgPSBnLm1lbW8oIGcuZGl2KCAxLCBRICkgKVxuICAgIGxldCBsID0gZy5tZW1vKCBnLmFkZCggZDJbMF0sIGcubXVsKCBmMSwgZDFbMF0gKSApICksXG4gICAgICAgIGggPSBnLm1lbW8oIGcuc3ViKCBnLnN1YiggaXNTdGVyZW8gPyBpbnB1dFswXSA6IGlucHV0LCBsICksIGcubXVsKCBRLCBkMVswXSApICkgKSxcbiAgICAgICAgYiA9IGcubWVtbyggZy5hZGQoIGcubXVsKCBmMSwgaCApLCBkMVswXSApICksXG4gICAgICAgIG4gPSBnLm1lbW8oIGcuYWRkKCBoLCBsICkgKVxuXG4gICAgZDFbMF0gPSBiXG4gICAgZDJbMF0gPSBsXG5cbiAgICBsZXQgb3V0ID0gZy5zZWxlY3RvciggbW9kZSwgbCwgaCwgYiwgbiApXG5cbiAgICBsZXQgcmV0dXJuVmFsdWVcbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICBsZXQgZDEyID0gZy5kYXRhKFswLDBdLCAxLCB7IG1ldGE6dHJ1ZSB9KSwgZDIyID0gZy5kYXRhKFswLDBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgICAgbGV0IGwyID0gZy5tZW1vKCBnLmFkZCggZDIyWzBdLCBnLm11bCggZjEsIGQxMlswXSApICkgKSxcbiAgICAgICAgICBoMiA9IGcubWVtbyggZy5zdWIoIGcuc3ViKCBpbnB1dFsxXSwgbDIgKSwgZy5tdWwoIFEsIGQxMlswXSApICkgKSxcbiAgICAgICAgICBiMiA9IGcubWVtbyggZy5hZGQoIGcubXVsKCBmMSwgaDIgKSwgZDEyWzBdICkgKSxcbiAgICAgICAgICBuMiA9IGcubWVtbyggZy5hZGQoIGgyLCBsMiApIClcblxuICAgICAgZDEyWzBdID0gYjJcbiAgICAgIGQyMlswXSA9IGwyXG5cbiAgICAgIGxldCBvdXQyID0gZy5zZWxlY3RvciggbW9kZSwgbDIsIGgyLCBiMiwgbjIgKVxuXG4gICAgICByZXR1cm5WYWx1ZSA9IFsgb3V0LCBvdXQyIF1cbiAgICB9ZWxzZXtcbiAgICAgIHJldHVyblZhbHVlID0gb3V0XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlXG4gIH1cblxuICBsZXQgU1ZGID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgY29uc3Qgc3ZmID0gT2JqZWN0LmNyZWF0ZSggZmlsdGVyIClcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBTVkYuZGVmYXVsdHMsIGZpbHRlci5kZWZhdWx0cywgaW5wdXRQcm9wcyApIFxuXG4gICAgY29uc3QgaXNTdGVyZW8gPSBwcm9wcy5pbnB1dC5pc1N0ZXJlb1xuICAgIFxuICAgIC8vIFhYWCBORUVEUyBSRUZBQ1RPUklOR1xuICAgIGNvbnN0IF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgICAgc3ZmLFxuICAgICAgLy9HaWJiZXJpc2guZ2VuaXNoLnN2ZiggZy5pbignaW5wdXQnKSwgZy5tdWwoIGcuaW4oJ2N1dG9mZicpLCBnLmdlbi5zYW1wbGVyYXRlIC8gNSApLCBnLnN1YiggMSwgZy5pbignUScpICksIGcuaW4oJ21vZGUnKSwgaXNTdGVyZW8gKSwgXG4gICAgICBHaWJiZXJpc2guZ2VuaXNoLnN2ZiggZy5pbignaW5wdXQnKSwgZy5tdWwoIGcuaW4oJ2N1dG9mZicpLCBnLmdlbi5zYW1wbGVyYXRlIC8gNSApLCBnLnN1YiggMSwgZy5pbignUScpICksIGcuaW4oJ21vZGUnKSwgaXNTdGVyZW8sIHRydWUgKSwgXG4gICAgICBbJ2ZpbHRlcnMnLCdGaWx0ZXIxMlNWRiddLCBcbiAgICAgIHByb3BzXG4gICAgKVxuXG4gICAgcmV0dXJuIF9fb3V0XG4gIH1cblxuXG4gIFNWRi5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIFE6IC42NSxcbiAgICBjdXRvZmY6LjI1LFxuICAgIG1vZGU6MFxuICB9XG5cbiAgcmV0dXJuIFNWRlxuXG59XG5cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxubGV0IEJpdENydXNoZXIgPSBpbnB1dFByb3BzID0+IHtcbiAgY29uc3QgIHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBiaXRDcnVzaGVyTGVuZ3RoOiA0NDEwMCB9LCBCaXRDcnVzaGVyLmRlZmF1bHRzLCBlZmZlY3QuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgIGJpdENydXNoZXIgPSBPYmplY3QuY3JlYXRlKCBlZmZlY3QgKVxuXG4gIGxldCBvdXRcblxuICBiaXRDcnVzaGVyLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICB9XG5cbiAgICBsZXQgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgIGJpdERlcHRoID0gZy5pbiggJ2JpdERlcHRoJyApLFxuICAgICAgICBzYW1wbGVSYXRlID0gZy5pbiggJ3NhbXBsZVJhdGUnICksXG4gICAgICAgIGxlZnRJbnB1dCA9IGlzU3RlcmVvID8gaW5wdXRbIDAgXSA6IGlucHV0LFxuICAgICAgICByaWdodElucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFsgMSBdIDogbnVsbFxuICAgIFxuICAgIGxldCBzdG9yZUwgPSBnLmhpc3RvcnkoMClcbiAgICBsZXQgc2FtcGxlUmVkdXhDb3VudGVyID0gZy5jb3VudGVyKCBzYW1wbGVSYXRlLCAwLCAxIClcblxuICAgIGxldCBiaXRNdWx0ID0gZy5wb3coIGcubXVsKCBiaXREZXB0aCwgMTYgKSwgMiApXG4gICAgbGV0IGNydXNoZWRMID0gZy5kaXYoIGcuZmxvb3IoIGcubXVsKCBnLm11bCggbGVmdElucHV0LCBpbnB1dEdhaW4gKSwgYml0TXVsdCApICksIGJpdE11bHQgKVxuXG4gICAgbGV0IG91dEwgPSBnLnN3aXRjaChcbiAgICAgIHNhbXBsZVJlZHV4Q291bnRlci53cmFwLFxuICAgICAgY3J1c2hlZEwsXG4gICAgICBzdG9yZUwub3V0XG4gICAgKVxuXG4gICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgbGV0IHN0b3JlUiA9IGcuaGlzdG9yeSgwKVxuICAgICAgbGV0IGNydXNoZWRSID0gZy5kaXYoIGcuZmxvb3IoIGcubXVsKCBnLm11bCggcmlnaHRJbnB1dCwgaW5wdXRHYWluICksIGJpdE11bHQgKSApLCBiaXRNdWx0IClcblxuICAgICAgbGV0IG91dFIgPSBnLnN3aXRjaCggXG4gICAgICAgIHNhbXBsZVJlZHV4Q291bnRlci53cmFwLFxuICAgICAgICBjcnVzaGVkUixcbiAgICAgICAgc3RvcmVMLm91dFxuICAgICAgKVxuXG4gICAgICBiaXRDcnVzaGVyLmdyYXBoID0gWyBvdXRMLCBvdXRSIF1cbiAgICB9ZWxzZXtcbiAgICAgIGJpdENydXNoZXIuZ3JhcGggPSBvdXRMXG4gICAgfVxuICB9XG5cbiAgYml0Q3J1c2hlci5fX2NyZWF0ZUdyYXBoKClcbiAgYml0Q3J1c2hlci5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgIGJpdENydXNoZXIsXG4gICAgYml0Q3J1c2hlci5ncmFwaCxcbiAgICBbJ2Z4JywnYml0Q3J1c2hlciddLCBcbiAgICBwcm9wcyBcbiAgKVxuICByZXR1cm4gb3V0IFxufVxuXG5CaXRDcnVzaGVyLmRlZmF1bHRzID0ge1xuICBpbnB1dDowLFxuICBiaXREZXB0aDouNSxcbiAgc2FtcGxlUmF0ZTogLjVcbn1cblxucmV0dXJuIEJpdENydXNoZXJcblxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIGxldCBwcm90byA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApXG5cbiAgbGV0IFNodWZmbGVyID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgbGV0IGJ1ZmZlclNodWZmbGVyID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgICAgYnVmZmVyU2l6ZSA9IDg4MjAwXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBTaHVmZmxlci5kZWZhdWx0cywgZWZmZWN0LmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBcbiAgICBsZXQgb3V0XG4gICAgYnVmZmVyU2h1ZmZsZXIuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiB0cnVlIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICAgIC8vb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICAgIH0gICAgICBcbiAgICAgIFxuICAgICAgY29uc3QgcGhhc2UgPSBnLmFjY3VtKCAxLDAseyBzaG91bGRXcmFwOiBmYWxzZSB9KVxuXG4gICAgICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgICAgICBfX2xlZnRJbnB1dCA9IGlzU3RlcmVvID8gaW5wdXRbIDAgXSA6IGlucHV0LFxuICAgICAgICAgICAgX19yaWdodElucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFsgMSBdIDogbnVsbCxcbiAgICAgICAgICAgIGxlZnRJbnB1dCA9IGcubXVsKCBfX2xlZnRJbnB1dCwgaW5wdXRHYWluICksXG4gICAgICAgICAgICByaWdodElucHV0ID0gZy5tdWwoIF9fcmlnaHRJbnB1dCwgaW5wdXRHYWluICksXG4gICAgICAgICAgICByYXRlT2ZTaHVmZmxpbmcgPSBnLmluKCAncmF0ZScgKSxcbiAgICAgICAgICAgIGNoYW5jZU9mU2h1ZmZsaW5nID0gZy5pbiggJ2NoYW5jZScgKSxcbiAgICAgICAgICAgIHJldmVyc2VDaGFuY2UgPSBnLmluKCAncmV2ZXJzZUNoYW5jZScgKSxcbiAgICAgICAgICAgIHJlcGl0Y2hDaGFuY2UgPSBnLmluKCAncmVwaXRjaENoYW5jZScgKSxcbiAgICAgICAgICAgIHJlcGl0Y2hNaW4gPSBnLmluKCAncmVwaXRjaE1pbicgKSxcbiAgICAgICAgICAgIHJlcGl0Y2hNYXggPSBnLmluKCAncmVwaXRjaE1heCcgKVxuXG4gICAgICBsZXQgcGl0Y2hNZW1vcnkgPSBnLmhpc3RvcnkoMSlcblxuICAgICAgbGV0IHNob3VsZFNodWZmbGVDaGVjayA9IGcuZXEoIGcubW9kKCBwaGFzZSwgcmF0ZU9mU2h1ZmZsaW5nICksIDAgKVxuICAgICAgbGV0IGlzU2h1ZmZsaW5nID0gZy5tZW1vKCBnLnNhaCggZy5sdCggZy5ub2lzZSgpLCBjaGFuY2VPZlNodWZmbGluZyApLCBzaG91bGRTaHVmZmxlQ2hlY2ssIDAgKSApIFxuXG4gICAgICAvLyBpZiB3ZSBhcmUgc2h1ZmZsaW5nIGFuZCBvbiBhIHJlcGVhdCBib3VuZGFyeS4uLlxuICAgICAgbGV0IHNodWZmbGVDaGFuZ2VkID0gZy5tZW1vKCBnLmFuZCggc2hvdWxkU2h1ZmZsZUNoZWNrLCBpc1NodWZmbGluZyApIClcbiAgICAgIGxldCBzaG91bGRSZXZlcnNlID0gZy5sdCggZy5ub2lzZSgpLCByZXZlcnNlQ2hhbmNlICksXG4gICAgICAgICAgcmV2ZXJzZU1vZCA9IGcuc3dpdGNoKCBzaG91bGRSZXZlcnNlLCAtMSwgMSApXG5cbiAgICAgIGxldCBwaXRjaCA9IGcuaWZlbHNlKCBcbiAgICAgICAgZy5hbmQoIHNodWZmbGVDaGFuZ2VkLCBnLmx0KCBnLm5vaXNlKCksIHJlcGl0Y2hDaGFuY2UgKSApLFxuICAgICAgICBnLm1lbW8oIGcubXVsKCBnLmFkZCggcmVwaXRjaE1pbiwgZy5tdWwoIGcuc3ViKCByZXBpdGNoTWF4LCByZXBpdGNoTWluICksIGcubm9pc2UoKSApICksIHJldmVyc2VNb2QgKSApLFxuICAgICAgICByZXZlcnNlTW9kXG4gICAgICApXG4gICAgICBcbiAgICAgIC8vIG9ubHkgc3dpdGNoIHBpdGNoZXMgb24gcmVwZWF0IGJvdW5kYXJpZXNcbiAgICAgIHBpdGNoTWVtb3J5LmluKCBnLnN3aXRjaCggc2h1ZmZsZUNoYW5nZWQsIHBpdGNoLCBwaXRjaE1lbW9yeS5vdXQgKSApXG5cbiAgICAgIGxldCBmYWRlTGVuZ3RoID0gZy5tZW1vKCBnLmRpdiggcmF0ZU9mU2h1ZmZsaW5nLCAxMDAgKSApLFxuICAgICAgICAgIGZhZGVJbmNyID0gZy5tZW1vKCBnLmRpdiggMSwgZmFkZUxlbmd0aCApIClcblxuICAgICAgY29uc3QgYnVmZmVyTCA9IGcuZGF0YSggYnVmZmVyU2l6ZSApXG4gICAgICBjb25zdCBidWZmZXJSID0gaXNTdGVyZW8gPyBnLmRhdGEoIGJ1ZmZlclNpemUgKSA6IG51bGxcbiAgICAgIGxldCByZWFkUGhhc2UgPSBnLmFjY3VtKCBwaXRjaE1lbW9yeS5vdXQsIDAsIHsgc2hvdWxkV3JhcDpmYWxzZSB9KSBcbiAgICAgIGxldCBzdHV0dGVyID0gZy53cmFwKCBnLnN1YiggZy5tb2QoIHJlYWRQaGFzZSwgYnVmZmVyU2l6ZSApLCAyMjA1MCApLCAwLCBidWZmZXJTaXplIClcblxuICAgICAgbGV0IG5vcm1hbFNhbXBsZSA9IGcucGVlayggYnVmZmVyTCwgZy5hY2N1bSggMSwgMCwgeyBtYXg6ODgyMDAgfSksIHsgbW9kZTonc2ltcGxlJyB9KVxuXG4gICAgICBsZXQgc3R1dHRlclNhbXBsZVBoYXNlID0gZy5zd2l0Y2goIGlzU2h1ZmZsaW5nLCBzdHV0dGVyLCBnLm1vZCggcmVhZFBoYXNlLCBidWZmZXJTaXplICkgKVxuICAgICAgbGV0IHN0dXR0ZXJTYW1wbGUgPSBnLm1lbW8oIGcucGVlayggXG4gICAgICAgIGJ1ZmZlckwsIFxuICAgICAgICBzdHV0dGVyU2FtcGxlUGhhc2UsXG4gICAgICAgIHsgbW9kZTonc2FtcGxlcycgfVxuICAgICAgKSApXG4gICAgICBcbiAgICAgIGxldCBzdHV0dGVyU2hvdWxkRmFkZUluID0gZy5hbmQoIHNodWZmbGVDaGFuZ2VkLCBpc1NodWZmbGluZyApXG4gICAgICBsZXQgc3R1dHRlclBoYXNlID0gZy5hY2N1bSggMSwgc2h1ZmZsZUNoYW5nZWQsIHsgc2hvdWxkV3JhcDogZmFsc2UgfSlcblxuICAgICAgbGV0IGZhZGVJbkFtb3VudCA9IGcubWVtbyggZy5kaXYoIHN0dXR0ZXJQaGFzZSwgZmFkZUxlbmd0aCApIClcbiAgICAgIGxldCBmYWRlT3V0QW1vdW50ID0gZy5kaXYoIGcuc3ViKCByYXRlT2ZTaHVmZmxpbmcsIHN0dXR0ZXJQaGFzZSApLCBnLnN1YiggcmF0ZU9mU2h1ZmZsaW5nLCBmYWRlTGVuZ3RoICkgKVxuICAgICAgXG4gICAgICBsZXQgZmFkZWRTdHV0dGVyID0gZy5pZmVsc2UoXG4gICAgICAgIGcubHQoIHN0dXR0ZXJQaGFzZSwgZmFkZUxlbmd0aCApLFxuICAgICAgICBnLm1lbW8oIGcubXVsKCBnLnN3aXRjaCggZy5sdCggZmFkZUluQW1vdW50LCAxICksIGZhZGVJbkFtb3VudCwgMSApLCBzdHV0dGVyU2FtcGxlICkgKSxcbiAgICAgICAgZy5ndCggc3R1dHRlclBoYXNlLCBnLnN1YiggcmF0ZU9mU2h1ZmZsaW5nLCBmYWRlTGVuZ3RoICkgKSxcbiAgICAgICAgZy5tZW1vKCBnLm11bCggZy5ndHAoIGZhZGVPdXRBbW91bnQsIDAgKSwgc3R1dHRlclNhbXBsZSApICksXG4gICAgICAgIHN0dXR0ZXJTYW1wbGVcbiAgICAgIClcbiAgICAgIFxuICAgICAgbGV0IG91dHB1dEwgPSBnLm1peCggbm9ybWFsU2FtcGxlLCBmYWRlZFN0dXR0ZXIsIGlzU2h1ZmZsaW5nICkgXG5cbiAgICAgIGxldCBwb2tlTCA9IGcucG9rZSggYnVmZmVyTCwgbGVmdElucHV0LCBnLm1vZCggZy5hZGQoIHBoYXNlLCA0NDEwMCApLCA4ODIwMCApIClcblxuICAgICAgbGV0IHBhbm5lciA9IGcucGFuKCBvdXRwdXRMLCBvdXRwdXRMLCBnLmluKCAncGFuJyApIClcbiAgICAgIFxuICAgICAgYnVmZmVyU2h1ZmZsZXIuZ3JhcGggPSBbIHBhbm5lci5sZWZ0LCBwYW5uZXIucmlnaHQgXVxuICAgIH1cblxuICAgIGJ1ZmZlclNodWZmbGVyLl9fY3JlYXRlR3JhcGgoKVxuICAgIGJ1ZmZlclNodWZmbGVyLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cbiAgICBcbiAgICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBidWZmZXJTaHVmZmxlcixcbiAgICAgIGJ1ZmZlclNodWZmbGVyLmdyYXBoLFxuICAgICAgWydmeCcsJ3NodWZmbGVyJ10sIFxuICAgICAgcHJvcHMgXG4gICAgKVxuXG4gICAgcmV0dXJuIG91dCBcbiAgfVxuICBcbiAgU2h1ZmZsZXIuZGVmYXVsdHMgPSB7XG4gICAgaW5wdXQ6MCxcbiAgICByYXRlOjIyMDUwLFxuICAgIGNoYW5jZTouMjUsXG4gICAgcmV2ZXJzZUNoYW5jZTouNSxcbiAgICByZXBpdGNoQ2hhbmNlOi41LFxuICAgIHJlcGl0Y2hNaW46LjUsXG4gICAgcmVwaXRjaE1heDoyLFxuICAgIHBhbjouNSxcbiAgICBtaXg6LjVcbiAgfVxuXG4gIHJldHVybiBTaHVmZmxlciBcbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG4gIFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxubGV0IF9fQ2hvcnVzID0gaW5wdXRQcm9wcyA9PiB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgX19DaG9ydXMuZGVmYXVsdHMsIGVmZmVjdC5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gIGxldCBvdXRcbiAgXG4gIGNvbnN0IGNob3J1cyA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApXG5cbiAgY2hvcnVzLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBpbnB1dCA9IGcuaW4oJ2lucHV0JyksXG4gICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICBmcmVxMSA9IGcuaW4oJ3Nsb3dGcmVxdWVuY3knKSxcbiAgICAgICAgICBmcmVxMiA9IGcuaW4oJ2Zhc3RGcmVxdWVuY3knKSxcbiAgICAgICAgICBhbXAxICA9IGcuaW4oJ3Nsb3dHYWluJyksXG4gICAgICAgICAgYW1wMiAgPSBnLmluKCdmYXN0R2FpbicpXG5cbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICB9XG5cbiAgICBjb25zdCBsZWZ0SW5wdXQgPSBpc1N0ZXJlbyA/IGcubXVsKCBpbnB1dFswXSwgaW5wdXRHYWluICkgOiBnLm11bCggaW5wdXQsIGlucHV0R2FpbiApXG5cbiAgICBjb25zdCB3aW4wICAgPSBnLmVudiggJ2ludmVyc2V3ZWxjaCcsIDEwMjQgKSxcbiAgICAgICAgICB3aW4xMjAgPSBnLmVudiggJ2ludmVyc2V3ZWxjaCcsIDEwMjQsIDAsIC4zMzMgKSxcbiAgICAgICAgICB3aW4yNDAgPSBnLmVudiggJ2ludmVyc2V3ZWxjaCcsIDEwMjQsIDAsIC42NjYgKVxuICAgIFxuICAgIGNvbnN0IHNsb3dQaGFzb3IgPSBnLnBoYXNvciggZnJlcTEsIDAsIHsgbWluOjAgfSksXG4gICAgICAgICAgc2xvd1BlZWsxICA9IGcubXVsKCBnLnBlZWsoIHdpbjAsICAgc2xvd1BoYXNvciApLCBhbXAxICksXG4gICAgICAgICAgc2xvd1BlZWsyICA9IGcubXVsKCBnLnBlZWsoIHdpbjEyMCwgc2xvd1BoYXNvciApLCBhbXAxICksXG4gICAgICAgICAgc2xvd1BlZWszICA9IGcubXVsKCBnLnBlZWsoIHdpbjI0MCwgc2xvd1BoYXNvciApLCBhbXAxIClcbiAgICBcbiAgICBjb25zdCBmYXN0UGhhc29yID0gZy5waGFzb3IoIGZyZXEyLCAwLCB7IG1pbjowIH0pLFxuICAgICAgICAgIGZhc3RQZWVrMSAgPSBnLm11bCggZy5wZWVrKCB3aW4wLCAgIGZhc3RQaGFzb3IgKSwgYW1wMiApLFxuICAgICAgICAgIGZhc3RQZWVrMiAgPSBnLm11bCggZy5wZWVrKCB3aW4xMjAsIGZhc3RQaGFzb3IgKSwgYW1wMiApLFxuICAgICAgICAgIGZhc3RQZWVrMyAgPSBnLm11bCggZy5wZWVrKCB3aW4yNDAsIGZhc3RQaGFzb3IgKSwgYW1wMiApXG5cblxuICAgIGxldCBzYW1wbGVSYXRlID0gR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlXG4gICAgIFxuICAgIGNvbnN0IG1zID0gc2FtcGxlUmF0ZSAvIDEwMDAgXG4gICAgY29uc3QgbWF4RGVsYXlUaW1lID0gMTAwMCAqIG1zXG5cbiAgICAvL2NvbnNvbGUubG9nKCAnc3I6Jywgc2FtcGxlUmF0ZSwgJ21zOicsIG1zLCAnbWF4RGVsYXlUaW1lOicsIG1heERlbGF5VGltZSApXG5cbiAgICBjb25zdCB0aW1lMSA9ICBnLm11bCggZy5hZGQoIHNsb3dQZWVrMSwgZmFzdFBlZWsxLCA1ICksIG1zICksXG4gICAgICAgICAgdGltZTIgPSAgZy5tdWwoIGcuYWRkKCBzbG93UGVlazIsIGZhc3RQZWVrMiwgNSApLCBtcyApLFxuICAgICAgICAgIHRpbWUzID0gIGcubXVsKCBnLmFkZCggc2xvd1BlZWszLCBmYXN0UGVlazMsIDUgKSwgbXMgKVxuXG4gICAgY29uc3QgZGVsYXkxTCA9IGcuZGVsYXkoIGxlZnRJbnB1dCwgdGltZTEsIHsgc2l6ZTptYXhEZWxheVRpbWUgfSksXG4gICAgICAgICAgZGVsYXkyTCA9IGcuZGVsYXkoIGxlZnRJbnB1dCwgdGltZTIsIHsgc2l6ZTptYXhEZWxheVRpbWUgfSksXG4gICAgICAgICAgZGVsYXkzTCA9IGcuZGVsYXkoIGxlZnRJbnB1dCwgdGltZTMsIHsgc2l6ZTptYXhEZWxheVRpbWUgfSlcblxuICAgIFxuICAgIGNvbnN0IGxlZnRPdXRwdXQgPSBnLmFkZCggZGVsYXkxTCwgZGVsYXkyTCwgZGVsYXkzTCApXG4gICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgY29uc3QgcmlnaHRJbnB1dCA9IGcubXVsKCBpbnB1dFsxXSwgaW5wdXRHYWluIClcbiAgICAgIGNvbnN0IGRlbGF5MVIgPSBnLmRlbGF5KHJpZ2h0SW5wdXQsIHRpbWUxLCB7IHNpemU6bWF4RGVsYXlUaW1lIH0pLFxuICAgICAgICAgICAgZGVsYXkyUiA9IGcuZGVsYXkocmlnaHRJbnB1dCwgdGltZTIsIHsgc2l6ZTptYXhEZWxheVRpbWUgfSksXG4gICAgICAgICAgICBkZWxheTNSID0gZy5kZWxheShyaWdodElucHV0LCB0aW1lMywgeyBzaXplOm1heERlbGF5VGltZSB9KVxuXG4gICAgICAvLyBmbGlwIGEgY291cGxlIGRlbGF5IGxpbmVzIGZvciBzdGVyZW8gZWZmZWN0P1xuICAgICAgY29uc3QgcmlnaHRPdXRwdXQgPSBnLmFkZCggZGVsYXkxUiwgZGVsYXkyTCwgZGVsYXkzUiApXG4gICAgICBjaG9ydXMuZ3JhcGggPSBbIGcuYWRkKCBkZWxheTFMLCBkZWxheTJSLCBkZWxheTNMKSwgcmlnaHRPdXRwdXQgXVxuICAgIH1lbHNle1xuICAgICAgY2hvcnVzLmdyYXBoID0gbGVmdE91dHB1dFxuICAgIH1cbiAgfVxuXG4gIGNob3J1cy5fX2NyZWF0ZUdyYXBoKClcbiAgY2hvcnVzLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggY2hvcnVzLCBjaG9ydXMuZ3JhcGgsIFsnZngnLCdjaG9ydXMnXSwgcHJvcHMgKVxuXG4gIHJldHVybiBvdXQgXG59XG5cbl9fQ2hvcnVzLmRlZmF1bHRzID0ge1xuICBpbnB1dDowLFxuICBzbG93RnJlcXVlbmN5OiAuMTgsXG4gIHNsb3dHYWluOjMsXG4gIGZhc3RGcmVxdWVuY3k6NixcbiAgZmFzdEdhaW46MSxcbiAgaW5wdXRHYWluOjFcbn1cblxucmV0dXJuIF9fQ2hvcnVzXG5cbn1cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxubGV0IERlbGF5ID0gaW5wdXRQcm9wcyA9PiB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHsgZGVsYXlMZW5ndGg6IDg4MjAwIH0sIGVmZmVjdC5kZWZhdWx0cywgRGVsYXkuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgIGRlbGF5ID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0IClcblxuICBsZXQgb3V0XG4gIGRlbGF5Ll9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICB9ICAgIFxuXG4gICAgY29uc3QgaW5wdXQgICAgICA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICBpbnB1dEdhaW4gID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICBkZWxheVRpbWUgID0gZy5pbiggJ3RpbWUnICksXG4gICAgICAgICAgd2V0ZHJ5ICAgICA9IGcuaW4oICd3ZXRkcnknICksXG4gICAgICAgICAgbGVmdElucHV0ICA9IGlzU3RlcmVvID8gZy5tdWwoIGlucHV0WyAwIF0sIGlucHV0R2FpbiApIDogZy5tdWwoIGlucHV0LCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICByaWdodElucHV0ID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbIDEgXSwgaW5wdXRHYWluICkgOiBudWxsXG4gICAgICBcbiAgICBjb25zdCBmZWVkYmFjayA9IGcuaW4oICdmZWVkYmFjaycgKVxuXG4gICAgLy8gbGVmdCBjaGFubmVsXG4gICAgY29uc3QgZmVlZGJhY2tIaXN0b3J5TCA9IGcuaGlzdG9yeSgpXG4gICAgY29uc3QgZWNob0wgPSBnLmRlbGF5KCBnLmFkZCggbGVmdElucHV0LCBnLm11bCggZmVlZGJhY2tIaXN0b3J5TC5vdXQsIGZlZWRiYWNrICkgKSwgZGVsYXlUaW1lLCB7IHNpemU6cHJvcHMuZGVsYXlMZW5ndGggfSlcbiAgICBmZWVkYmFja0hpc3RvcnlMLmluKCBlY2hvTCApXG4gICAgY29uc3QgbGVmdCA9IGcubWl4KCBsZWZ0SW5wdXQsIGVjaG9MLCB3ZXRkcnkgKVxuXG4gICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgLy8gcmlnaHQgY2hhbm5lbFxuICAgICAgY29uc3QgZmVlZGJhY2tIaXN0b3J5UiA9IGcuaGlzdG9yeSgpXG4gICAgICBjb25zdCBlY2hvUiA9IGcuZGVsYXkoIGcuYWRkKCByaWdodElucHV0LCBnLm11bCggZmVlZGJhY2tIaXN0b3J5Ui5vdXQsIGZlZWRiYWNrICkgKSwgZGVsYXlUaW1lLCB7IHNpemU6cHJvcHMuZGVsYXlMZW5ndGggfSlcbiAgICAgIGZlZWRiYWNrSGlzdG9yeVIuaW4oIGVjaG9SIClcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZy5taXgoIHJpZ2h0SW5wdXQsIGVjaG9SLCB3ZXRkcnkgKVxuXG4gICAgICBkZWxheS5ncmFwaCA9IFsgbGVmdCwgcmlnaHQgXVxuICAgIH1lbHNle1xuICAgICAgZGVsYXkuZ3JhcGggPSBsZWZ0IFxuICAgIH1cbiAgfVxuXG4gIGRlbGF5Ll9fY3JlYXRlR3JhcGgoKVxuICBkZWxheS5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG4gIFxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgZGVsYXksXG4gICAgZGVsYXkuZ3JhcGgsIFxuICAgIFsnZngnLCdkZWxheSddLCBcbiAgICBwcm9wcyBcbiAgKVxuXG4gIHJldHVybiBvdXRcbn1cblxuRGVsYXkuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGZlZWRiYWNrOi41LFxuICB0aW1lOiAxMTAyNSxcbiAgd2V0ZHJ5OiAuNVxufVxuXG5yZXR1cm4gRGVsYXlcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG4vLyB0YWtlbiBmcm9tIGNzb3VuZDogaHR0cDovL21hbnVhbC5mcmVlc2hlbGwub3JnL2Nzb3VuZDUvZGlzdG9ydDEuaHRtbFxuLypcblxuICAgICAgICAgZXhwKGFzaWcgKiAoc2hhcGUxICsgcHJlZ2FpbikpIC0gZXhwKGFzaWcgKiAoc2hhcGUyIC0gcHJlZ2FpbikpXG4gIGFvdXQgPSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIGV4cChhc2lnICogcHJlZ2FpbikgICAgICAgICAgICArIGV4cCgtYXNpZyAqIHByZWdhaW4pXG5cbiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBsZXQgRGlzdG9ydGlvbiA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBlZmZlY3QuZGVmYXVsdHMsIERpc3RvcnRpb24uZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgZGlzdG9ydGlvbj0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0ICksXG4gICAgICAgIG91dFxuXG4gICAgZGlzdG9ydGlvbi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICAgIHNoYXBlMSA9IGcuaW4oICdzaGFwZTEnICksXG4gICAgICAgICAgICBzaGFwZTIgPSBnLmluKCAnc2hhcGUyJyApLFxuICAgICAgICAgICAgcHJlZ2FpbiA9IGcuaW4oICdwcmVnYWluJyApLFxuICAgICAgICAgICAgcG9zdGdhaW4gPSBnLmluKCAncG9zdGdhaW4nIClcblxuICAgICAgbGV0IGxvdXRcbiAgICAgIHtcbiAgICAgICAgJ3VzZSBqc2RzcCdcbiAgICAgICAgY29uc3QgbGlucHV0ID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbMF0sIGlucHV0R2FpbiApIDogZy5tdWwoIGlucHV0LCBpbnB1dEdhaW4gKVxuICAgICAgICBjb25zdCBsdG9wID0gZy5leHAoIGxpbnB1dCAqIChzaGFwZTEgKyBwcmVnYWluKSApIC0gZy5leHAoIGxpbnB1dCAqIChzaGFwZTIgLSBwcmVnYWluKSApXG4gICAgICAgIGNvbnN0IGxib3R0b20gPSBnLmV4cCggbGlucHV0ICogcHJlZ2FpbiApICsgZy5leHAoIC0xICogbGlucHV0ICogcHJlZ2FpbiApXG4gICAgICAgIGxvdXQgPSAoIGx0b3AgLyBsYm90dG9tICkgKiBwb3N0Z2FpblxuICAgICAgfVxuXG4gICAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICAgIGxldCByb3V0XG4gICAgICAgIHtcbiAgICAgICAgICAndXNlIGpzZHNwJ1xuICAgICAgICAgIGNvbnN0IHJpbnB1dCA9IGlzU3RlcmVvID8gZy5tdWwoIGlucHV0WzFdLCBpbnB1dEdhaW4gKSA6IGcubXVsKCBpbnB1dCwgaW5wdXRHYWluIClcbiAgICAgICAgICBjb25zdCBydG9wID0gZy5leHAoIHJpbnB1dCAqIChzaGFwZTEgKyBwcmVnYWluKSApIC0gZy5leHAoIHJpbnB1dCAqIChzaGFwZTIgLSBwcmVnYWluKSApXG4gICAgICAgICAgY29uc3QgcmJvdHRvbSA9IGcuZXhwKCByaW5wdXQgKiBwcmVnYWluICkgKyBnLmV4cCggLTEgKiByaW5wdXQgKiBwcmVnYWluIClcbiAgICAgICAgICByb3V0ID0gKCBydG9wIC8gcmJvdHRvbSApICogcG9zdGdhaW5cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RvcnRpb24uZ3JhcGggPSBbIGxvdXQsIHJvdXQgXVxuICAgICAgfWVsc2V7XG4gICAgICAgIGRpc3RvcnRpb24uZ3JhcGggPSBsb3V0IFxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3RvcnRpb24uX19jcmVhdGVHcmFwaCgpXG4gICAgZGlzdG9ydGlvbi5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBkaXN0b3J0aW9uLFxuICAgICAgZGlzdG9ydGlvbi5ncmFwaCwgXG4gICAgICBbICdmeCcsJ2Rpc3RvcnRpb24nIF0sIFxuICAgICAgcHJvcHMgXG4gICAgKVxuICAgIHJldHVybiBvdXQgXG4gIH1cblxuICBEaXN0b3J0aW9uLmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgc2hhcGUxOi4xLFxuICAgIHNoYXBlMjouMSxcbiAgICBwcmVnYWluOjUsXG4gICAgcG9zdGdhaW46LjUsXG4gIH1cblxuICByZXR1cm4gRGlzdG9ydGlvblxuXG59XG4iLCJsZXQgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKClcblxubGV0IGVmZmVjdCA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuXG5PYmplY3QuYXNzaWduKCBlZmZlY3QsIHtcbiAgZGVmYXVsdHM6IHsgYnlwYXNzOmZhbHNlLCBpbnB1dEdhaW46MSB9LFxuICB0eXBlOidlZmZlY3QnXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVmZmVjdFxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IGVmZmVjdHMgPSB7XG4gICAgRnJlZXZlcmIgICAgOiByZXF1aXJlKCAnLi9mcmVldmVyYi5qcycgICkoIEdpYmJlcmlzaCApLFxuICAgIC8vUGxhdGUgICAgICAgOiByZXF1aXJlKCAnLi9kYXR0b3Jyby5kc3AuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIEZsYW5nZXIgICAgIDogcmVxdWlyZSggJy4vZmxhbmdlci5qcycgICApKCBHaWJiZXJpc2ggKSxcbiAgICBWaWJyYXRvICAgICA6IHJlcXVpcmUoICcuL3ZpYnJhdG8uanMnICAgKSggR2liYmVyaXNoICksXG4gICAgRGVsYXkgICAgICAgOiByZXF1aXJlKCAnLi9kZWxheS5qcycgICAgICkoIEdpYmJlcmlzaCApLFxuICAgIEJpdENydXNoZXIgIDogcmVxdWlyZSggJy4vYml0Q3J1c2hlci5qcycpKCBHaWJiZXJpc2ggKSxcbiAgICBEaXN0b3J0aW9uICA6IHJlcXVpcmUoICcuL2Rpc3RvcnRpb24uZHNwLmpzJykoIEdpYmJlcmlzaCApLFxuICAgIFJpbmdNb2QgICAgIDogcmVxdWlyZSggJy4vcmluZ01vZC5qcycgICApKCBHaWJiZXJpc2ggKSxcbiAgICBUcmVtb2xvICAgICA6IHJlcXVpcmUoICcuL3RyZW1vbG8uanMnICAgKSggR2liYmVyaXNoICksXG4gICAgQ2hvcnVzICAgICAgOiByZXF1aXJlKCAnLi9jaG9ydXMuanMnICAgICkoIEdpYmJlcmlzaCApLFxuICAgIFdhdmVmb2xkZXIgIDogcmVxdWlyZSggJy4vd2F2ZWZvbGRlci5kc3AuanMnKSggR2liYmVyaXNoIClbMF0sXG4gICAgU2h1ZmZsZXIgICAgOiByZXF1aXJlKCAnLi9idWZmZXJTaHVmZmxlci5qcycgICkoIEdpYmJlcmlzaCApLFxuICAgIC8vR2F0ZSAgICAgICAgOiByZXF1aXJlKCAnLi9nYXRlLmpzJyAgICAgICkoIEdpYmJlcmlzaCApLFxuICB9XG5cbiAgZWZmZWN0cy5leHBvcnQgPSB0YXJnZXQgPT4ge1xuICAgIGZvciggbGV0IGtleSBpbiBlZmZlY3RzICkge1xuICAgICAgaWYoIGtleSAhPT0gJ2V4cG9ydCcgKSB7XG4gICAgICAgIHRhcmdldFsga2V5IF0gPSBlZmZlY3RzWyBrZXkgXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5yZXR1cm4gZWZmZWN0c1xuXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgcHJvdG8gPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxubGV0IEZsYW5nZXIgPSBpbnB1dFByb3BzID0+IHtcbiAgbGV0IHByb3BzICAgPSBPYmplY3QuYXNzaWduKCB7IGRlbGF5TGVuZ3RoOjQ0MTAwIH0sIEZsYW5nZXIuZGVmYXVsdHMsIHByb3RvLmRlZmF1bHRzLCBpbnB1dFByb3BzICksXG4gICAgICBmbGFuZ2VyID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIG91dFxuXG4gIGZsYW5nZXIuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgICAgZGVsYXlMZW5ndGggPSBwcm9wcy5kZWxheUxlbmd0aCxcbiAgICAgICAgICBmZWVkYmFja0NvZWZmID0gZy5pbiggJ2ZlZWRiYWNrJyApLFxuICAgICAgICAgIG1vZEFtb3VudCA9IGcuaW4oICdvZmZzZXQnICksXG4gICAgICAgICAgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBkZWxheUJ1ZmZlckwgPSBnLmRhdGEoIGRlbGF5TGVuZ3RoIClcblxuICAgIGNvbnN0IHdyaXRlSWR4ID0gZy5hY2N1bSggMSwwLCB7IG1pbjowLCBtYXg6ZGVsYXlMZW5ndGgsIGludGVycDonbm9uZScsIG1vZGU6J3NhbXBsZXMnIH0pXG4gICAgXG4gICAgY29uc3Qgb2Zmc2V0ID0gZy5tdWwoIG1vZEFtb3VudCwgNTAwIClcblxuICAgIGNvbnN0IG1vZCA9IHByb3BzLm1vZCA9PT0gdW5kZWZpbmVkID8gZy5jeWNsZSggZnJlcXVlbmN5ICkgOiBwcm9wcy5tb2RcbiAgICBcbiAgICBjb25zdCByZWFkSWR4ID0gZy53cmFwKCBcbiAgICAgIGcuYWRkKCBcbiAgICAgICAgZy5zdWIoIHdyaXRlSWR4LCBvZmZzZXQgKSwgXG4gICAgICAgIG1vZC8vZy5tdWwoIG1vZCwgZy5zdWIoIG9mZnNldCwgMSApICkgXG4gICAgICApLCBcbiAgICAgIDAsIFxuICAgICAgZGVsYXlMZW5ndGhcbiAgICApXG5cbiAgICBjb25zdCBsZWZ0SW5wdXQgPSBpc1N0ZXJlbyA/IGlucHV0WzBdIDogaW5wdXRcblxuICAgIGNvbnN0IGRlbGF5ZWRPdXRMID0gZy5wZWVrKCBkZWxheUJ1ZmZlckwsIHJlYWRJZHgsIHsgaW50ZXJwOidsaW5lYXInLCBtb2RlOidzYW1wbGVzJyB9KVxuICAgIFxuICAgIGcucG9rZSggZGVsYXlCdWZmZXJMLCBnLmFkZCggbGVmdElucHV0LCBnLm11bCggZGVsYXllZE91dEwsIGZlZWRiYWNrQ29lZmYgKSApLCB3cml0ZUlkeCApXG5cbiAgICBjb25zdCBsZWZ0ID0gZy5hZGQoIGxlZnRJbnB1dCwgZGVsYXllZE91dEwgKVxuXG4gICAgaWYoIGlzU3RlcmVvID09PSB0cnVlICkge1xuICAgICAgY29uc3QgcmlnaHRJbnB1dCA9IGlucHV0WzFdXG4gICAgICBjb25zdCBkZWxheUJ1ZmZlclIgPSBnLmRhdGEoIGRlbGF5TGVuZ3RoIClcbiAgICAgIFxuICAgICAgbGV0IGRlbGF5ZWRPdXRSID0gZy5wZWVrKCBkZWxheUJ1ZmZlclIsIHJlYWRJZHgsIHsgaW50ZXJwOidsaW5lYXInLCBtb2RlOidzYW1wbGVzJyB9KVxuXG4gICAgICBnLnBva2UoIGRlbGF5QnVmZmVyUiwgZy5hZGQoIHJpZ2h0SW5wdXQsIGcubXVsKCBkZWxheWVkT3V0UiwgZmVlZGJhY2tDb2VmZiApICksIHdyaXRlSWR4IClcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZy5hZGQoIHJpZ2h0SW5wdXQsIGRlbGF5ZWRPdXRSIClcblxuICAgICAgZmxhbmdlci5ncmFwaCA9IFsgbGVmdCwgcmlnaHQgXVxuXG4gICAgfWVsc2V7XG4gICAgICBmbGFuZ2VyLmdyYXBoID0gbGVmdFxuICAgIH1cbiAgfVxuXG4gIGZsYW5nZXIuX19jcmVhdGVHcmFwaCgpXG4gIGZsYW5nZXIuX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuXG4gIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICBmbGFuZ2VyLFxuICAgIGZsYW5nZXIuZ3JhcGgsIFxuICAgIFsnZngnLCdmbGFuZ2VyJ10sIFxuICAgIHByb3BzIFxuICApIFxuXG4gIHJldHVybiBvdXQgXG59XG5cbkZsYW5nZXIuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGZlZWRiYWNrOi44MSxcbiAgb2Zmc2V0Oi4xMjUsXG4gIGZyZXF1ZW5jeToxXG59XG5cbnJldHVybiBGbGFuZ2VyXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgXG5jb25zdCBhbGxQYXNzID0gR2liYmVyaXNoLmZpbHRlcnMuZ2VuaXNoLkFsbFBhc3NcbmNvbnN0IGNvbWJGaWx0ZXIgPSBHaWJiZXJpc2guZmlsdGVycy5nZW5pc2guQ29tYlxuXG5jb25zdCB0dW5pbmcgPSB7XG4gIGNvbWJDb3VudDpcdCAgXHQ4LFxuICBjb21iVHVuaW5nOiBcdFx0WyAxMTE2LCAxMTg4LCAxMjc3LCAxMzU2LCAxNDIyLCAxNDkxLCAxNTU3LCAxNjE3IF0sICAgICAgICAgICAgICAgICAgICBcbiAgYWxsUGFzc0NvdW50OiBcdDQsXG4gIGFsbFBhc3NUdW5pbmc6XHRbIDIyNSwgNTU2LCA0NDEsIDM0MSBdLFxuICBhbGxQYXNzRmVlZGJhY2s6MC41LFxuICBmaXhlZEdhaW46IFx0XHQgIDAuMDE1LFxuICBzY2FsZURhbXBpbmc6IFx0MC40LFxuICBzY2FsZVJvb206IFx0XHQgIDAuMjgsXG4gIG9mZnNldFJvb206IFx0ICAwLjcsXG4gIHN0ZXJlb1NwcmVhZDogICAyM1xufVxuXG5jb25zdCBGcmVldmVyYiA9IGlucHV0UHJvcHMgPT4ge1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBlZmZlY3QuZGVmYXVsdHMsIEZyZWV2ZXJiLmRlZmF1bHRzLCBpbnB1dFByb3BzICksXG4gICAgICAgIHJldmVyYiA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApIFxuXG4gIGxldCBvdXQgXG4gIHJldmVyYi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgIH1lbHNle1xuICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICB9ICAgIFxuXG4gICAgY29uc3QgY29tYnNMID0gW10sIGNvbWJzUiA9IFtdXG5cbiAgICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICBpbnB1dEdhaW4gPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgIHdldDEgPSBnLmluKCAnd2V0MScpLFxuICAgICAgICAgIHdldDIgPSBnLmluKCAnd2V0MicgKSwgIFxuICAgICAgICAgIGRyeSA9IGcuaW4oICdkcnknICksIFxuICAgICAgICAgIHJvb21TaXplID0gZy5pbiggJ3Jvb21TaXplJyApLCBcbiAgICAgICAgICBkYW1waW5nID0gZy5pbiggJ2RhbXBpbmcnIClcbiAgICBcbiAgICBjb25zdCBfX3N1bW1lZElucHV0ID0gaXNTdGVyZW8gPT09IHRydWUgPyBnLmFkZCggaW5wdXRbMF0sIGlucHV0WzFdICkgOiBpbnB1dCxcbiAgICAgICAgICBzdW1tZWRJbnB1dCA9IGcubXVsKCBfX3N1bW1lZElucHV0LCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICBhdHRlbnVhdGVkSW5wdXQgPSBnLm1lbW8oIGcubXVsKCBzdW1tZWRJbnB1dCwgdHVuaW5nLmZpeGVkR2FpbiApIClcbiAgICBcbiAgICAvLyBjcmVhdGUgY29tYiBmaWx0ZXJzIGluIHBhcmFsbGVsLi4uXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCA4OyBpKysgKSB7IFxuICAgICAgY29tYnNMLnB1c2goIFxuICAgICAgICBjb21iRmlsdGVyKCBcbiAgICAgICAgICBhdHRlbnVhdGVkSW5wdXQsIFxuICAgICAgICAgIHR1bmluZy5jb21iVHVuaW5nW2ldLCBcbiAgICAgICAgICBnLm11bChkYW1waW5nLC40KSxcbiAgICAgICAgICBnLm11bCggdHVuaW5nLnNjYWxlUm9vbSArIHR1bmluZy5vZmZzZXRSb29tLCByb29tU2l6ZSApIFxuICAgICAgICApIFxuICAgICAgKVxuICAgICAgY29tYnNSLnB1c2goIFxuICAgICAgICBjb21iRmlsdGVyKCBcbiAgICAgICAgICBhdHRlbnVhdGVkSW5wdXQsIFxuICAgICAgICAgIHR1bmluZy5jb21iVHVuaW5nW2ldICsgdHVuaW5nLnN0ZXJlb1NwcmVhZCwgXG4gICAgICAgICAgZy5tdWwoZGFtcGluZywuNCksIFxuICAgICAgICAgIGcubXVsKCB0dW5pbmcuc2NhbGVSb29tICsgdHVuaW5nLm9mZnNldFJvb20sIHJvb21TaXplICkgXG4gICAgICAgICkgXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIC8vIC4uLiBhbmQgc3VtIHRoZW0gd2l0aCBhdHRlbnVhdGVkIGlucHV0LCB1c2Ugb2YgbGV0IGlzIGRlbGliZXJhdGUgaGVyZVxuICAgIGxldCBvdXRMID0gZy5hZGQoIGF0dGVudWF0ZWRJbnB1dCwgLi4uY29tYnNMIClcbiAgICBsZXQgb3V0UiA9IGcuYWRkKCBhdHRlbnVhdGVkSW5wdXQsIC4uLmNvbWJzUiApXG4gICAgXG4gICAgLy8gcnVuIHRocm91Z2ggYWxscGFzcyBmaWx0ZXJzIGluIHNlcmllc1xuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgNDsgaSsrICkgeyBcbiAgICAgIG91dEwgPSBhbGxQYXNzKCBvdXRMLCB0dW5pbmcuYWxsUGFzc1R1bmluZ1sgaSBdICsgdHVuaW5nLnN0ZXJlb1NwcmVhZCApXG4gICAgICBvdXRSID0gYWxsUGFzcyggb3V0UiwgdHVuaW5nLmFsbFBhc3NUdW5pbmdbIGkgXSArIHR1bmluZy5zdGVyZW9TcHJlYWQgKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBvdXRwdXRMID0gZy5hZGQoIGcubXVsKCBvdXRMLCB3ZXQxICksIGcubXVsKCBvdXRSLCB3ZXQyICksIGcubXVsKCBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGlucHV0WzBdIDogaW5wdXQsIGRyeSApICksXG4gICAgICAgICAgb3V0cHV0UiA9IGcuYWRkKCBnLm11bCggb3V0Uiwgd2V0MSApLCBnLm11bCggb3V0TCwgd2V0MiApLCBnLm11bCggaXNTdGVyZW8gPT09IHRydWUgPyBpbnB1dFsxXSA6IGlucHV0LCBkcnkgKSApXG5cbiAgICByZXZlcmIuZ3JhcGggPSBbIG91dHB1dEwsIG91dHB1dFIgXVxuICB9XG5cbiAgcmV2ZXJiLl9fY3JlYXRlR3JhcGgoKVxuICByZXZlcmIuX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuXG4gIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCByZXZlcmIsIHJldmVyYi5ncmFwaCwgWydmeCcsJ2ZyZWV2ZXJiJ10sIHByb3BzIClcblxuICByZXR1cm4gb3V0XG59XG5cblxuRnJlZXZlcmIuZGVmYXVsdHMgPSB7XG4gIGlucHV0OiAwLFxuICB3ZXQxOiAxLFxuICB3ZXQyOiAwLFxuICBkcnk6IC41LFxuICByb29tU2l6ZTogLjkyNSxcbiAgZGFtcGluZzogIC41LFxufVxuXG5yZXR1cm4gRnJlZXZlcmIgXG5cbn1cblxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgUmluZ01vZCA9IGlucHV0UHJvcHMgPT4ge1xuICBsZXQgcHJvcHMgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBSaW5nTW9kLmRlZmF1bHRzLCBlZmZlY3QuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgIHJpbmdNb2QgPSBPYmplY3QuY3JlYXRlKCBlZmZlY3QgKSxcbiAgICAgIG91dFxuXG4gIHJpbmdNb2QuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH0gICAgXG5cbiAgICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICBpbnB1dEdhaW4gPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgIGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgZ2FpbiA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICAgIG1peCA9IGcuaW4oICdtaXgnIClcbiAgICBcbiAgICBjb25zdCBsZWZ0SW5wdXQgPSBpc1N0ZXJlbyA/IGcubXVsKCBpbnB1dFswXSwgaW5wdXRHYWluICkgOiBnLm11bCggaW5wdXQsIGlucHV0R2FpbiApLFxuICAgICAgICAgIHNpbmUgPSBnLm11bCggZy5jeWNsZSggZnJlcXVlbmN5ICksIGdhaW4gKVxuICAgXG4gICAgY29uc3QgbGVmdCA9IGcuYWRkKCBnLm11bCggbGVmdElucHV0LCBnLnN1YiggMSwgbWl4ICkpLCBnLm11bCggZy5tdWwoIGxlZnRJbnB1dCwgc2luZSApLCBtaXggKSApIFxuICAgICAgICBcbiAgICBpZiggaXNTdGVyZW8gPT09IHRydWUgKSB7XG4gICAgICBjb25zdCByaWdodElucHV0ID0gZy5tdWwoIGlucHV0WzFdLCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICAgIHJpZ2h0ID0gZy5hZGQoIGcubXVsKCByaWdodElucHV0LCBnLnN1YiggMSwgbWl4ICkpLCBnLm11bCggZy5tdWwoIHJpZ2h0SW5wdXQsIHNpbmUgKSwgbWl4ICkgKSBcbiAgICAgIFxuICAgICAgcmluZ01vZC5ncmFwaCA9IFsgbGVmdCwgcmlnaHQgXVxuICAgIH1lbHNle1xuICAgICAgcmluZ01vZC5ncmFwaCA9IGxlZnRcbiAgICB9XG4gIH1cblxuICByaW5nTW9kLl9fY3JlYXRlR3JhcGgoKSBcbiAgcmluZ01vZC5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgIHJpbmdNb2QsXG4gICAgcmluZ01vZC5ncmFwaCwgXG4gICAgWyAnZngnLCdyaW5nTW9kJ10sIFxuICAgIHByb3BzIFxuICApXG4gIFxuICByZXR1cm4gb3V0IFxufVxuXG5SaW5nTW9kLmRlZmF1bHRzID0ge1xuICBpbnB1dDowLFxuICBmcmVxdWVuY3k6MjIwLFxuICBnYWluOiAxLCBcbiAgbWl4OjFcbn1cblxucmV0dXJuIFJpbmdNb2RcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxuY29uc3QgVHJlbW9sbyA9IGlucHV0UHJvcHMgPT4ge1xuICBjb25zdCBwcm9wcyAgID0gT2JqZWN0LmFzc2lnbigge30sIFRyZW1vbG8uZGVmYXVsdHMsIGVmZmVjdC5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICB0cmVtb2xvID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0IClcbiAgXG4gIGxldCBvdXRcbiAgdHJlbW9sby5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgIH1lbHNle1xuICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgfSAgICBcblxuICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgICAgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBhbW91bnQgPSBnLmluKCAnYW1vdW50JyApXG4gICAgXG4gICAgY29uc3QgbGVmdElucHV0ID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbMF0sIGlucHV0R2FpbiApIDogZy5tdWwoIGlucHV0LCBpbnB1dEdhaW4gKVxuXG4gICAgbGV0IG9zY1xuICAgIGlmKCBwcm9wcy5zaGFwZSA9PT0gJ3NxdWFyZScgKSB7XG4gICAgICBvc2MgPSBnLmd0KCBnLnBoYXNvciggZnJlcXVlbmN5ICksIDAgKVxuICAgIH1lbHNlIGlmKCBwcm9wcy5zaGFwZSA9PT0gJ3NhdycgKSB7XG4gICAgICBvc2MgPSBnLmd0cCggZy5waGFzb3IoIGZyZXF1ZW5jeSApLCAwIClcbiAgICB9ZWxzZXtcbiAgICAgIG9zYyA9IGcuY3ljbGUoIGZyZXF1ZW5jeSApXG4gICAgfVxuXG4gICAgY29uc3QgbW9kID0gZy5tdWwoIG9zYywgYW1vdW50IClcbiAgIFxuICAgIGNvbnN0IGxlZnQgPSBnLnN1YiggbGVmdElucHV0LCBnLm11bCggbGVmdElucHV0LCBtb2QgKSApXG5cbiAgICBpZiggaXNTdGVyZW8gPT09IHRydWUgKSB7XG4gICAgICBjb25zdCByaWdodElucHV0ID0gZy5tdWwoIGlucHV0WzFdLCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICAgIHJpZ2h0ID0gZy5tdWwoIHJpZ2h0SW5wdXQsIG1vZCApXG5cbiAgICAgIHRyZW1vbG8uZ3JhcGggPSBbIGxlZnQsIHJpZ2h0IF1cbiAgICB9ZWxzZXtcbiAgICAgIHRyZW1vbG8uZ3JhcGggPSBsZWZ0XG4gICAgfVxuICB9XG4gIFxuICB0cmVtb2xvLl9fY3JlYXRlR3JhcGgoKVxuICB0cmVtb2xvLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgdHJlbW9sbyxcbiAgICB0cmVtb2xvLmdyYXBoLFxuICAgIFsnZngnLCd0cmVtb2xvJ10sIFxuICAgIHByb3BzIFxuICApIFxuICByZXR1cm4gb3V0IFxufVxuXG5UcmVtb2xvLmRlZmF1bHRzID0ge1xuICBpbnB1dDowLFxuICBmcmVxdWVuY3k6MixcbiAgYW1vdW50OiAxLCBcbiAgc2hhcGU6J3NpbmUnXG59XG5cbnJldHVybiBUcmVtb2xvXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiBcbmNvbnN0IFZpYnJhdG8gPSBpbnB1dFByb3BzID0+IHtcbiAgY29uc3QgcHJvcHMgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBWaWJyYXRvLmRlZmF1bHRzLCBlZmZlY3QuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgdmlicmF0byA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApXG5cbiAgbGV0IG91dFxuICB2aWJyYXRvLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICB9ICAgIFxuXG4gICAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICBkZWxheUxlbmd0aCA9IDQ0MTAwLFxuICAgICAgICAgIGZlZWRiYWNrQ29lZmYgPSBnLmluKCAnZmVlZGJhY2snICksXG4gICAgICAgICAgbW9kQW1vdW50ID0gZy5pbiggJ2Ftb3VudCcgKSxcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGRlbGF5QnVmZmVyTCA9IGcuZGF0YSggZGVsYXlMZW5ndGggKVxuXG4gICAgY29uc3Qgd3JpdGVJZHggPSBnLmFjY3VtKCAxLDAsIHsgbWluOjAsIG1heDpkZWxheUxlbmd0aCwgaW50ZXJwOidub25lJywgbW9kZTonc2FtcGxlcycgfSlcbiAgICBcbiAgICBjb25zdCBvZmZzZXQgPSBnLm11bCggbW9kQW1vdW50LCA1MDAgKVxuICAgIFxuICAgIGNvbnN0IHJlYWRJZHggPSBnLndyYXAoIFxuICAgICAgZy5hZGQoIFxuICAgICAgICBnLnN1Yiggd3JpdGVJZHgsIG9mZnNldCApLCBcbiAgICAgICAgZy5tdWwoIGcuY3ljbGUoIGZyZXF1ZW5jeSApLCBnLnN1Yiggb2Zmc2V0LCAxICkgKSBcbiAgICAgICksIFxuICAgICAgMCwgXG4gICAgICBkZWxheUxlbmd0aFxuICAgIClcblxuICAgIGNvbnN0IGxlZnRJbnB1dCA9IGlzU3RlcmVvID8gZy5tdWwoIGlucHV0WzBdLCBpbnB1dEdhaW4gKSA6IGcubXVsKCBpbnB1dCwgaW5wdXRHYWluIClcblxuICAgIGNvbnN0IGRlbGF5ZWRPdXRMID0gZy5wZWVrKCBkZWxheUJ1ZmZlckwsIHJlYWRJZHgsIHsgaW50ZXJwOidsaW5lYXInLCBtb2RlOidzYW1wbGVzJyB9KVxuICAgIFxuICAgIGcucG9rZSggZGVsYXlCdWZmZXJMLCBnLmFkZCggbGVmdElucHV0LCBnLm11bCggZGVsYXllZE91dEwsIGZlZWRiYWNrQ29lZmYgKSApLCB3cml0ZUlkeCApXG5cbiAgICBjb25zdCBsZWZ0ID0gZGVsYXllZE91dExcblxuICAgIGlmKCBpc1N0ZXJlbyA9PT0gdHJ1ZSApIHtcbiAgICAgIGNvbnN0IHJpZ2h0SW5wdXQgPSBnLm11bCggaW5wdXRbMV0sIGlucHV0R2FpbiApXG4gICAgICBjb25zdCBkZWxheUJ1ZmZlclIgPSBnLmRhdGEoIGRlbGF5TGVuZ3RoIClcbiAgICAgIFxuICAgICAgY29uc3QgZGVsYXllZE91dFIgPSBnLnBlZWsoIGRlbGF5QnVmZmVyUiwgcmVhZElkeCwgeyBpbnRlcnA6J2xpbmVhcicsIG1vZGU6J3NhbXBsZXMnIH0pXG5cbiAgICAgIGcucG9rZSggZGVsYXlCdWZmZXJSLCBnLmFkZCggcmlnaHRJbnB1dCwgbXVsKCBkZWxheWVkT3V0UiwgZmVlZGJhY2tDb2VmZiApICksIHdyaXRlSWR4IClcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZGVsYXllZE91dFJcblxuICAgICAgdmlicmF0by5ncmFwaCA9IFsgbGVmdCwgcmlnaHQgXVxuICAgIH1lbHNle1xuICAgICAgdmlicmF0by5ncmFwaCA9IGxlZnQgXG4gICAgfVxuICB9XG5cbiAgdmlicmF0by5fX2NyZWF0ZUdyYXBoKClcbiAgdmlicmF0by5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgIHZpYnJhdG8sXG4gICAgdmlicmF0by5ncmFwaCwgICAgXG4gICAgWyAnZngnLCAndmlicmF0bycgXSwgXG4gICAgcHJvcHMgXG4gICkgXG4gIHJldHVybiBvdXQgXG59XG5cblZpYnJhdG8uZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGZlZWRiYWNrOi4wMSxcbiAgYW1vdW50Oi41LFxuICBmcmVxdWVuY3k6NFxufVxuXG5yZXR1cm4gVmlicmF0b1xuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbmNvbnN0IFJMID0gNy41ZTMsXG4gICAgICAgUiA9IDE1ZTMsIFxuICAgICAgVlQgPSAyNmUtMyxcbiAgICAgIElzID0gMTBlLTE2LFxuICAgICAgIGEgPSAyKlJML1IsXG4gICAgICAgYiA9IChSKzIqUkwpLyhWVCpSKSxcbiAgICAgICBkID0gKFJMKklzKS9WVFxuXG4vLyBBbnRpYWxpYXNpbmcgZXJyb3IgdGhyZXNob2xkXG5jb25zdCB0aHJlc2ggPSAxMGUtMTA7XG5cbmNvbnN0IHdhdmVzdGFnZSA9IGluMSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBgICBjb25zdCB0aHJlc2ggPSAxMGUtMTA7XG5cbiAgbGV0IHcgPSBMbjE7XG4gIGxldCBleHB3LCBwLCByLCBzO1xuXG4gIGNvbnN0IGUgPSBNYXRoLkVcbiAgY29uc3QgcG93ID0gTWF0aC5wb3dcbiAgY29uc3QgYWJzID0gTWF0aC5hYnNcbiAgZm9yKGxldCBpPTA7IGk8MTAwMDsgaSsrKSB7XG4gICAgZXhwdyA9IHBvdyhlLHcpO1xuXG4gICAgcCA9IHcqZXhwdyAtIHg7XG4gICAgciA9ICh3KzEpKmV4cHc7XG4gICAgcyA9ICh3KzIpLygyKih3KzEpKTsgICAgICAgIFxuICAgIGVyciA9IChwLyhyLShwKnMpKSk7XG5cbiAgICBpZiAoYWJzKGVycik8dGhyZXNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB3ID0gdyAtIGVycjtcbiAgfVxuXG4gIHJldHVybiB3O2BcblxuICBjb25zdCBMYW1iZXJ0X1cgPSBnLnByb2Nlc3MoICd4JywnTG4xJywgYm9keSApXG5cbiAgY29uc3QgTG4xID0gZy5oaXN0b3J5KDApLFxuICAgICAgICBGbjEgPSBnLmhpc3RvcnkoMCksXG4gICAgICAgIHhuMSA9IGcuaGlzdG9yeSgwKVxuXG4gIHtcbiAgICAndXNlIGpzZHNwJ1xuICAgIC8vIENvbXB1dGUgQW50aWRlcml2YXRpdmVcbiAgICBjb25zdCBsID0gZy5zaWduKGluMSk7IFxuICAgIGxldCB1ID0gZCAqIGcucG93KCBNYXRoLkUsIGwgKiBiICogaW4xIClcbiAgICBsZXQgTG4gPSBMYW1iZXJ0X1cuY2FsbCh1LExuMS5vdXQpXG4gICAgY29uc3QgRm4gPSAoMC41ICogVlQvYiApICogKExuICogKExuICsgMikpIC0gMC41KmEqaW4xKmluMVxuXG4gICAgbGV0IHhuID0gMC41ICogKCBpbjEgKyB4bjEub3V0IClcbiAgICB1ID0gZCAqIGcucG93KCBNYXRoLkUsIGwgKiBiICogeG4gKVxuICAgIExuID0gTGFtYmVydF9XLmNhbGwoIHUsIExuMS5vdXQgKVxuXG4gICAgLy9vdXQxID0gO1xuICAgIC8vIENoZWNrIGZvciBpbGwtY29uZGl0aW9uaW5nXG4gICAgY29uc3Qgb3V0MSA9IGcuaWZlbHNlKFxuICAgICAgZy5sdCggZy5hYnMoIGluMSAtIHhuMS5vdXQgKSwgdGhyZXNoKSwgXG4gICAgICAobCAqIFZUICogTG4pIC0gKCBhICogeG4gKSxcbiAgICAgIChGbiAtIEZuMS5vdXQpIC8gKGluMSAtIHhuMS5vdXQpXG4gICAgKVxuXG4gICAgLy8gVXBkYXRlIFN0YXRlc1xuICAgIExuMS5pbiggTG4gKVxuICAgIEZuMS5pbiggRm4gKVxuICAgIHhuMS5pbiggaW4xIClcblxuICAgIHJldHVybiBvdXQxXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IFdhdmVmb2xkZXIgPSBpbnB1dFByb3BzID0+IHtcblxuICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBlZmZlY3QuZGVmYXVsdHMsIFdhdmVmb2xkZXIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgd2F2ZWZvbGRlciA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApLFxuICAgICAgICBvdXRcblxuICAgIHdhdmVmb2xkZXIuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICAgIH1lbHNle1xuICAgICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICAgIGdhaW4gID0gZy5pbiggJ2dhaW4nICksXG4gICAgICAgICAgICBwb3N0Z2FpbiA9IGcuaW4oICdwb3N0Z2FpbicgKVxuXG4gICAgICBsZXQgbG91dFxuICAgICAge1xuICAgICAgICAndXNlIGpzZHNwJ1xuXG4gICAgICAgIGNvbnN0IGxpbnB1dCA9IGlzU3RlcmVvID8gaW5wdXRbMF0gKiBnYWluIDogaW5wdXQgKiBnYWluXG4gICAgICAgIGxvdXQgPSBsaW5wdXQgKiAuMzMzXG4gICAgICAgIGxvdXQgPSB3YXZlc3RhZ2UoIHdhdmVzdGFnZSggd2F2ZXN0YWdlKCB3YXZlc3RhZ2UoIGxvdXQgKSApICkgKVxuICAgICAgICBsb3V0ID0gbG91dCAqIC42XG4gICAgICAgIGxvdXQgPSBnLnRhbmgoIGxvdXQgKSAqIHBvc3RnYWluXG4gICAgICB9XG5cbiAgICAgIHdhdmVmb2xkZXIuZ3JhcGggPSBsb3V0XG5cbiAgICAgIGlmKCBpc1N0ZXJlbyApIHtcbiAgICAgICAgbGV0IHJvdXRcbiAgICAgICAge1xuICAgICAgICAgICd1c2UganNkc3AnXG4gICAgICAgICAgY29uc3QgcmlucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFsxXSAqIGdhaW4gOiBpbnB1dCAqIGdhaW5cbiAgICAgICAgICByb3V0ID0gcmlucHV0ICogLjMzM1xuICAgICAgICAgIHJvdXQgPSB3YXZlc3RhZ2UoIHdhdmVzdGFnZSggd2F2ZXN0YWdlKCB3YXZlc3RhZ2UoIHJvdXQgKSApICkgKVxuICAgICAgICAgIHJvdXQgPSByb3V0ICogLjZcbiAgICAgICAgICByb3V0ID0gZy50YW5oKCByb3V0ICkgKiBwb3N0Z2FpblxuICAgICAgICB9XG5cbiAgICAgICAgd2F2ZWZvbGRlci5ncmFwaCA9IFsgbG91dCwgcm91dCBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2F2ZWZvbGRlci5fX2NyZWF0ZUdyYXBoKClcbiAgICB3YXZlZm9sZGVyLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICAgIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICAgIHdhdmVmb2xkZXIsXG4gICAgICB3YXZlZm9sZGVyLmdyYXBoLCBcbiAgICAgIFsgJ2Z4Jywnd2F2ZWZvbGRlcicgXSwgXG4gICAgICBwcm9wcyBcbiAgICApXG5cbiAgICByZXR1cm4gb3V0IFxuICB9XG5cbiAgV2F2ZWZvbGRlci5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIGdhaW46MixcbiAgICBwb3N0Z2FpbjoxXG4gIH1cblxuICByZXR1cm4gWyBXYXZlZm9sZGVyLCB3YXZlc3RhZ2UgXVxuXG59XG4iLCJsZXQgTWVtb3J5SGVscGVyID0gcmVxdWlyZSggJ21lbW9yeS1oZWxwZXInICksXG4gICAgZ2VuaXNoICAgICAgID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuICAgIFxubGV0IEdpYmJlcmlzaCA9IHtcbiAgYmxvY2tDYWxsYmFja3M6IFtdLCAvLyBjYWxsZWQgZXZlcnkgYmxvY2tcbiAgZGlydHlVZ2VuczogW10sXG4gIGNhbGxiYWNrVWdlbnM6IFtdLFxuICBjYWxsYmFja05hbWVzOiBbXSxcbiAgYW5hbHl6ZXJzOiBbXSxcbiAgZ3JhcGhJc0RpcnR5OiBmYWxzZSxcbiAgdWdlbnM6IHt9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIGlkOiAtMSxcbiAgcHJldmVudFByb3h5OmZhbHNlLFxuICBwcm94eUVuYWJsZWQ6IHRydWUsXG5cbiAgb3V0cHV0OiBudWxsLFxuXG4gIG1lbW9yeSA6IG51bGwsIC8vIDIwIG1pbnV0ZXMgYnkgZGVmYXVsdD9cbiAgZmFjdG9yeTogbnVsbCwgXG4gIGdlbmlzaCxcbiAgc2NoZWR1bGVyOiByZXF1aXJlKCAnLi9zY2hlZHVsaW5nL3NjaGVkdWxlci5qcycgKSxcbiAgLy93b3JrbGV0UHJvY2Vzc29yTG9hZGVyOiByZXF1aXJlKCAnLi93b3JrbGV0UHJvY2Vzc29yLmpzJyApLFxuICB3b3JrbGV0UHJvY2Vzc29yOiBudWxsLFxuXG4gIG1lbW9lZDoge30sXG4gIG1vZGU6J3NjcmlwdFByb2Nlc3NvcicsXG5cbiAgcHJvdG90eXBlczoge1xuICAgIHVnZW46IG51bGwsLy9yZXF1aXJlKCcuL3VnZW4uanMnKSxcbiAgICBpbnN0cnVtZW50OiByZXF1aXJlKCAnLi9pbnN0cnVtZW50cy9pbnN0cnVtZW50LmpzJyApLFxuICAgIGVmZmVjdDogcmVxdWlyZSggJy4vZngvZWZmZWN0LmpzJyApLFxuICAgIGFuYWx5emVyOiByZXF1aXJlKCAnLi9hbmFseXNpcy9hbmFseXplci5qcycgKVxuICB9LFxuXG4gIG1peGluczoge1xuICAgIHBvbHlpbnN0cnVtZW50OiByZXF1aXJlKCAnLi9pbnN0cnVtZW50cy9wb2x5TWl4aW4uanMnIClcbiAgfSxcblxuICB3b3JrbGV0UGF0aDogJy4vZ2liYmVyaXNoX3dvcmtsZXQuanMnLFxuXG4gIGluaXQoIG1lbUFtb3VudCwgY3R4LCBtb2RlPSd3b3JrbGV0JyApIHtcbiAgICBsZXQgbnVtQnl0ZXMgPSBpc05hTiggbWVtQW1vdW50ICkgPyAyMCAqIDYwICogNDQxMDAgOiBtZW1BbW91bnRcblxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgZ2liYmVyaXNoIGlzIHVzaW5nIHdvcmtsZXRzLFxuICAgIC8vIHdlIHN0aWxsIHdhbnQgZ2VuaXNoIHRvIG91dHB1dCB2YW5pbGxhIGpzIGZ1bmN0aW9ucyBpbnN0ZWFkXG4gICAgLy8gb2YgYXVkaW8gd29ya2xldCBjbGFzc2VzOyB0aGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWRcbiAgICAvLyBmcm9tIHdpdGhpbiB0aGUgZ2liYmVyaXNoIGF1ZGlvd29ya2xldCBwcm9jZXNzb3Igbm9kZS5cbiAgICB0aGlzLmdlbmlzaC5nZW4ubW9kZSA9ICdzY3JpcHRQcm9jZXNzb3InXG5cbiAgICB0aGlzLm1lbW9yeSA9IE1lbW9yeUhlbHBlci5jcmVhdGUoIG51bUJ5dGVzLCBGbG9hdDY0QXJyYXkgKVxuXG4gICAgdGhpcy5tb2RlID0gbW9kZVxuXG4gICAgY29uc3Qgc3RhcnR1cCA9IHRoaXMudXRpbGl0aWVzLmNyZWF0ZVdvcmtsZXRcblxuICAgIHRoaXMuc2NoZWR1bGVyLmluaXQoIHRoaXMgKVxuICAgIFxuICAgIHRoaXMuYW5hbHl6ZXJzLmRpcnR5ID0gZmFsc2VcblxuICAgIGlmKCB0aGlzLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcblxuICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBwID0gbmV3IFByb21pc2UoIChfX3Jlc29sdmUsIF9fcmVqZWN0ICkgPT4ge1xuICAgICAgICAgIHRoaXMudXRpbGl0aWVzLmNyZWF0ZUNvbnRleHQoIGN0eCwgc3RhcnR1cC5iaW5kKCB0aGlzLnV0aWxpdGllcyApLCBfX3Jlc29sdmUgKVxuICAgICAgICB9KS50aGVuKCAoKT0+IHtcbiAgICAgICAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gdHJ1ZVxuICAgICAgICAgIEdpYmJlcmlzaC5sb2FkKClcbiAgICAgICAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gZmFsc2VcbiAgICAgICAgICBHaWJiZXJpc2gub3V0cHV0ID0gdGhpcy5CdXMyKClcblxuICAgICAgICAgIC8vIEdpYmJlcmlzaC5vdXRwdXQgbmVlZHMgdG8gYmUgYXNzaWduIHNvIHRoYXQgdWdlbnMgY2FuXG4gICAgICAgICAgLy8gY29ubmVjdCB0byBpdCBieSBkZWZhdWx0LiBUaGVyZSdzIG5vIG90aGVyIHdheSB0byBhc3NpZ24gaXRcbiAgICAgICAgICAvLyBvdXRzaWRlIG9mIGV2YWxpbmcgY29kZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgIGFkZHJlc3M6J2V2YWwnLCBcbiAgICAgICAgICAgIGNvZGU6YEdpYmJlcmlzaC5vdXRwdXQgPSB0aGlzLnVnZW5zLmdldCgke0dpYmJlcmlzaC5vdXRwdXQuaWR9KTtgIFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcblxuICAgICAgfSlcbiAgICAgIFxuICAgICAgcmV0dXJuIHBcblxuICAgIH1lbHNlIGlmKCB0aGlzLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgR2liYmVyaXNoLmxvYWQoKVxuICAgIH1cbiAgfSxcblxuICBsb2FkKCkge1xuICAgIHRoaXMuZmFjdG9yeSAgICAgID0gcmVxdWlyZSggJy4vZmFjdG9yeS5qcycgKSggdGhpcyApXG4gICAgXG4gICAgdGhpcy5QYW5uZXIgICAgICAgPSByZXF1aXJlKCAnLi9taXNjL3Bhbm5lci5qcycgKSggdGhpcyApXG4gICAgdGhpcy5Qb2x5VGVtcGxhdGUgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50cy9wb2x5dGVtcGxhdGUuanMnICkoIHRoaXMgKVxuICAgIHRoaXMub3NjaWxsYXRvcnMgID0gcmVxdWlyZSggJy4vb3NjaWxsYXRvcnMvb3NjaWxsYXRvcnMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuZmlsdGVycyAgICAgID0gcmVxdWlyZSggJy4vZmlsdGVycy9maWx0ZXJzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLmJpbm9wcyAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvYmlub3BzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLm1vbm9wcyAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvbW9ub3BzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLkJ1cyAgICAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvYnVzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLkJ1czIgICAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvYnVzMi5qcycgKSggdGhpcyApXG4gICAgdGhpcy5pbnN0cnVtZW50cyAgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50cy9pbnN0cnVtZW50cy5qcycgKSggdGhpcyApXG4gICAgdGhpcy5meCAgICAgICAgICAgPSByZXF1aXJlKCAnLi9meC9lZmZlY3RzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLlNlcXVlbmNlciAgICA9IHJlcXVpcmUoICcuL3NjaGVkdWxpbmcvc2VxdWVuY2VyLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLlNlcXVlbmNlcjIgICA9IHJlcXVpcmUoICcuL3NjaGVkdWxpbmcvc2VxMi5qcycgKSggdGhpcyApXG4gICAgdGhpcy5UaWRhbCAgICAgICAgPSByZXF1aXJlKCAnLi9zY2hlZHVsaW5nL3RpZGFsLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLmVudmVsb3BlcyAgICA9IHJlcXVpcmUoICcuL2VudmVsb3Blcy9lbnZlbG9wZXMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuYW5hbHlzaXMgICAgID0gcmVxdWlyZSggJy4vYW5hbHlzaXMvYW5hbHl6ZXJzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLnRpbWUgICAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvdGltZS5qcycgKSggdGhpcyApXG4gICAgdGhpcy5Qcm94eSAgICAgICAgPSByZXF1aXJlKCAnLi93b3JrbGV0UHJveHkuanMnICkoIHRoaXMgKVxuICB9LFxuXG4gIGV4cG9ydCggdGFyZ2V0LCBzaG91bGRFeHBvcnRHZW5pc2g9ZmFsc2UgKSB7XG4gICAgaWYoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkgdGhyb3cgRXJyb3IoJ1lvdSBtdXN0IGRlZmluZSBhIHRhcmdldCBvYmplY3QgZm9yIEdpYmJlcmlzaCB0byBleHBvcnQgdmFyaWFibGVzIHRvLicpXG5cbiAgICBpZiggc2hvdWxkRXhwb3J0R2VuaXNoICkgdGhpcy5nZW5pc2guZXhwb3J0KCB0YXJnZXQgKVxuXG4gICAgdGhpcy5pbnN0cnVtZW50cy5leHBvcnQoIHRhcmdldCApXG4gICAgdGhpcy5meC5leHBvcnQoIHRhcmdldCApXG4gICAgdGhpcy5maWx0ZXJzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLm9zY2lsbGF0b3JzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLmJpbm9wcy5leHBvcnQoIHRhcmdldCApXG4gICAgdGhpcy5tb25vcHMuZXhwb3J0KCB0YXJnZXQgKVxuICAgIHRoaXMuZW52ZWxvcGVzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLmFuYWx5c2lzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0YXJnZXQuU2VxdWVuY2VyID0gdGhpcy5TZXF1ZW5jZXJcbiAgICB0YXJnZXQuU2VxdWVuY2VyMiA9IHRoaXMuU2VxdWVuY2VyMlxuICAgIHRhcmdldC5CdXMgPSB0aGlzLkJ1c1xuICAgIHRhcmdldC5CdXMyID0gdGhpcy5CdXMyXG4gICAgdGFyZ2V0LlNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyXG4gICAgdGFyZ2V0LlRpZGFsID0gdGhpcy5UaWRhbFxuICAgIHRoaXMudGltZS5leHBvcnQoIHRhcmdldCApXG4gICAgdGhpcy51dGlsaXRpZXMuZXhwb3J0KCB0YXJnZXQgKVxuICB9LFxuXG4gIHByaW50Y2IoKSB7IFxuICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBhZGRyZXNzOidjYWxsYmFjaycgfSkgXG4gIH0sXG4gIHByaW50b2JqKCBvYmogKSB7XG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IGFkZHJlc3M6J3ByaW50Jywgb2JqZWN0Om9iai5pZCB9KSBcbiAgfSxcbiAgc2VuZCggbXNnICl7XG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSggbXNnIClcbiAgfSxcblxuICBkaXJ0eSggdWdlbiApIHtcbiAgICBpZiggdWdlbiA9PT0gdGhpcy5hbmFseXplcnMgKSB7XG4gICAgICB0aGlzLmdyYXBoSXNEaXJ0eSA9IHRydWVcbiAgICAgIHRoaXMuYW5hbHl6ZXJzLmRpcnR5ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpcnR5VWdlbnMucHVzaCggdWdlbiApXG4gICAgICB0aGlzLmdyYXBoSXNEaXJ0eSA9IHRydWVcbiAgICAgIGlmKCB0aGlzLm1lbW9lZFsgdWdlbi51Z2VuTmFtZSBdICkge1xuICAgICAgICBkZWxldGUgdGhpcy5tZW1vZWRbIHVnZW4udWdlbk5hbWUgXVxuICAgICAgfVxuICAgIH0gXG4gIH0sXG5cbiAgY2xlYXIoKSB7XG4gICAgLy8gZG8gbm90IGRlbGV0ZSB0aGUgZ2FpbiBhbmQgdGhlIHBhbiBvZiB0aGUgbWFzdGVyIGJ1cyBcbiAgICB0aGlzLm91dHB1dC5pbnB1dHMuc3BsaWNlKCAwLCB0aGlzLm91dHB1dC5pbnB1dHMubGVuZ3RoIC0gMiApXG4gICAgLy90aGlzLm91dHB1dC5pbnB1dE5hbWVzLmxlbmd0aCA9IDBcbiAgICB0aGlzLmFuYWx5emVycy5sZW5ndGggPSAwXG4gICAgdGhpcy5zY2hlZHVsZXIuY2xlYXIoKVxuICAgIHRoaXMuZGlydHkoIHRoaXMub3V0cHV0IClcbiAgICBpZiggdGhpcy5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICB0aGlzLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgICBhZGRyZXNzOidtZXRob2QnLCBcbiAgICAgICAgb2JqZWN0OnRoaXMuaWQsXG4gICAgICAgIG5hbWU6J2NsZWFyJyxcbiAgICAgICAgYXJnczpbXVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gY2xlYXIgbWVtb3J5Li4uIFhYWCBzaG91bGQgdGhpcyBiZSBhIE1lbW9yeUhlbHBlciBmdW5jdGlvbj9cbiAgICAvL3RoaXMubWVtb3J5LmhlYXAuZmlsbCgwKVxuICAgIC8vdGhpcy5tZW1vcnkubGlzdCA9IHt9XG5cbiAgICBHaWJiZXJpc2guZ2VuaXNoLmdlbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lbW9yeSBpbml0JylcbiAgICBHaWJiZXJpc2guZ2VuaXNoLmdlbi5oaXN0b3JpZXMuY2xlYXIoKVxuXG4gICAgLy9HaWJiZXJpc2gub3V0cHV0ID0gdGhpcy5CdXMyKClcbiAgICBcbiAgfSxcblxuICAvLyB1c2VkIHRvIHNvcnQgYW5hbHlzaXMgdWdlbnMgYnkgcHJpb3JpdHkuXG4gIC8vIGhpZ2hlciBwcmlvcml0aWVzIG1lYW4gbG93ZXIgb3JkZXJpbmcgaW4gdGhlIGFycmF5LFxuICAvLyB3aGljaCBtZWFucyB0aGV5IHdpbGwgcnVuIGZpcnN0IGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgLy8gYnkgZGVmdWx0LCBhbmFseXNpcyB1Z2VucyBhcmUgYXNzaWduZWQgYSBwcmlvcml0eSBvZiAwIGluIHRoZVxuICAvLyBhbmFseXNpcyBwcm90b3R5cGUuXG4gIGFuYWx5c2lzQ29tcGFyZSggYSxiICkge1xuICAgIHJldHVybiAoaXNOYU4oYi5wcmlvcml0eSkgPyAwIDogYi5wcmlvcml0eSkgLSAoaXNOYU4oYS5wcmlvcml0eSkgPyAwOiBhLnByaW9yaXR5IClcbiAgfSxcblxuICBnZW5lcmF0ZUNhbGxiYWNrKCkge1xuICAgIGlmKCB0aGlzLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIEdpYmJlcmlzaC5jYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9XG4gICAgICBHaWJiZXJpc2guY2FsbGJhY2sub3V0ID0gW11cbiAgICAgIHJldHVybiBHaWJiZXJpc2guY2FsbGJhY2tcbiAgICB9XG4gICAgbGV0IHVpZCA9IDAsXG4gICAgICAgIGNhbGxiYWNrQm9keSwgbGFzdExpbmUsIGFuYWx5c2lzPScnXG5cbiAgICB0aGlzLm1lbW9lZCA9IHt9XG5cbiAgICBjYWxsYmFja0JvZHkgPSB0aGlzLnByb2Nlc3NHcmFwaCggdGhpcy5vdXRwdXQgKVxuICAgIGxhc3RMaW5lID0gY2FsbGJhY2tCb2R5WyBjYWxsYmFja0JvZHkubGVuZ3RoIC0gMV1cbiAgICBjYWxsYmFja0JvZHkudW5zaGlmdCggXCJcXHQndXNlIHN0cmljdCdcIiApXG5cbiAgICB0aGlzLmFuYWx5emVyc1xuICAgICAgLnNvcnQoIHRoaXMuYW5hbHlzaXNDb21wYXJlIClcbiAgICAgIC5mb3JFYWNoKCB2PT4ge1xuICAgICAgICBjb25zdCBhbmFseXNpc0Jsb2NrID0gR2liYmVyaXNoLnByb2Nlc3NVZ2VuKCB2IClcbiAgICAgICAgLy9pZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coICdhbmFseXNpczonLCBhbmFseXNpc0Jsb2NrLCB2ICApXG4gICAgICAgIC8vfVxuICAgICAgICBsZXQgYW5hbHlzaXNMaW5lXG5cbiAgICAgICAgaWYoIHR5cGVvZiBhbmFseXNpc0Jsb2NrID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICBhbmFseXNpc0xpbmUgPSBhbmFseXNpc0Jsb2NrLnBvcCgpXG5cbiAgICAgICAgICBhbmFseXNpc0Jsb2NrLmZvckVhY2goIHYgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tCb2R5LnNwbGljZSggY2FsbGJhY2tCb2R5Lmxlbmd0aCAtIDEsIDAsIHYgKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGFuYWx5c2lzTGluZSA9IGFuYWx5c2lzQmxvY2tcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrQm9keS5wdXNoKCBhbmFseXNpc0xpbmUgKVxuICAgICAgfSlcblxuICAgIHRoaXMuYW5hbHl6ZXJzLmZvckVhY2goIHYgPT4ge1xuICAgICAgaWYoIHRoaXMuY2FsbGJhY2tVZ2Vucy5pbmRleE9mKCB2LmNhbGxiYWNrICkgPT09IC0xIClcbiAgICAgICAgdGhpcy5jYWxsYmFja1VnZW5zLnB1c2goIHYuY2FsbGJhY2sgKVxuICAgIH0pXG5cbiAgICB0aGlzLmNhbGxiYWNrTmFtZXMgPSB0aGlzLmNhbGxiYWNrVWdlbnMubWFwKCB2ID0+IHYudWdlbk5hbWUgKVxuXG4gICAgY2FsbGJhY2tCb2R5LnB1c2goICdcXG5cXHRyZXR1cm4gJyArIGxhc3RMaW5lLnNwbGl0KCAnPScgKVswXS5zcGxpdCggJyAnIClbMV0gKVxuXG4gICAgaWYoIHRoaXMuZGVidWcgPT09IHRydWUgKSBjb25zb2xlLmxvZyggJ2NhbGxiYWNrOlxcbicsIGNhbGxiYWNrQm9keS5qb2luKCdcXG4nKSApXG4gICAgXG4gICAgdGhpcy5jYWxsYmFja05hbWVzLnB1c2goICdtZW0nIClcbiAgICB0aGlzLmNhbGxiYWNrVWdlbnMucHVzaCggdGhpcy5tZW1vcnkuaGVhcCApXG4gICAgdGhpcy5jYWxsYmFjayA9IEZ1bmN0aW9uKCAuLi50aGlzLmNhbGxiYWNrTmFtZXMsIGNhbGxiYWNrQm9keS5qb2luKCAnXFxuJyApICkvLy5iaW5kKCBudWxsLCAuLi50aGlzLmNhbGxiYWNrVWdlbnMgKVxuICAgIHRoaXMuY2FsbGJhY2sub3V0ID0gW11cblxuICAgIGlmKCB0aGlzLm9uY2FsbGJhY2sgKSB0aGlzLm9uY2FsbGJhY2soIHRoaXMuY2FsbGJhY2sgKVxuXG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2sgXG4gIH0sXG5cbiAgcHJvY2Vzc0dyYXBoKCBvdXRwdXQgKSB7XG4gICAgdGhpcy5jYWxsYmFja1VnZW5zLmxlbmd0aCA9IDBcbiAgICB0aGlzLmNhbGxiYWNrTmFtZXMubGVuZ3RoID0gMFxuXG4gICAgdGhpcy5jYWxsYmFja1VnZW5zLnB1c2goIG91dHB1dC5jYWxsYmFjayApXG5cbiAgICBsZXQgYm9keSA9IHRoaXMucHJvY2Vzc1VnZW4oIG91dHB1dCApXG4gICAgXG5cbiAgICB0aGlzLmRpcnR5VWdlbnMubGVuZ3RoID0gMFxuICAgIHRoaXMuZ3JhcGhJc0RpcnR5ID0gZmFsc2VcblxuICAgIHJldHVybiBib2R5XG4gIH0sXG4gIHByb3h5UmVwbGFjZSggb2JqICkge1xuICAgIGlmKCB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgKSB7XG4gICAgICBpZiggb2JqLmlkICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNvbnN0IF9fb2JqID0gR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQoIG9iai5pZCApXG4gICAgICAgIC8vY29uc29sZS5sb2coICdyZXRyaWV2ZWQ6JywgX19vYmoubmFtZSApXG5cbiAgICAgICAgLy9pZiggb2JqLnByb3AgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUubG9nKCAnZ290IGEgc3NkLm91dCcsIG9iaiApXG4gICAgICAgIHJldHVybiBvYmoucHJvcCAhPT0gdW5kZWZpbmVkID8gX19vYmpbIG9iai5wcm9wIF0gOiBfX29ialxuICAgICAgfWVsc2UgaWYoIG9iai5pc0Z1bmMgPT09IHRydWUgKSB7XG4gICAgICAgIGxldCBmdW5jID0gIGV2YWwoICcoJyArIG9iai52YWx1ZSArICcpJyApXG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyggJ3JlcGxhY2luZyBmdW5jdGlvbjonLCBmdW5jIClcblxuICAgICAgICByZXR1cm4gZnVuY1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmpcbiAgfSxcblxuICBwcm9jZXNzVWdlbiggdWdlbiwgYmxvY2sgKSB7XG4gICAgaWYoIGJsb2NrID09PSB1bmRlZmluZWQgKSBibG9jayA9IFtdXG4gICAgaWYoIHVnZW4gPT09IHVuZGVmaW5lZCApIHJldHVybiBibG9ja1xuXG5cbiAgICBsZXQgZGlydHlJZHggPSBHaWJiZXJpc2guZGlydHlVZ2Vucy5pbmRleE9mKCB1Z2VuIClcblxuICAgIGxldCBtZW1vID0gR2liYmVyaXNoLm1lbW9lZFsgdWdlbi51Z2VuTmFtZSBdXG5cbiAgICBpZiggbWVtbyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgcmV0dXJuIG1lbW9cbiAgICB9IGVsc2UgaWYoIHVnZW4gPT09IHRydWUgfHwgdWdlbiA9PT0gZmFsc2UgKSB7XG4gICAgICB0aHJvdyBcIldoeSBpcyB1Z2VuIGEgYm9vbGVhbj8gW3RydWVdIG9yIFtmYWxzZV1cIjtcbiAgICB9IGVsc2UgaWYoIHVnZW4uYmxvY2sgPT09IHVuZGVmaW5lZCB8fCBkaXJ0eUluZGV4ICE9PSAtMSApIHtcbiAgICAgIC8vIHdlaXJkIGVkZ2UgY2FzZSB3aXRoIGFuYWx5c2lzIChmb2xsb3cpIHVnZW5cbiAgICAgIGlmKCB1Z2VuLmlkID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHVnZW4uaWQgPSB1Z2VuLl9fcHJvcGVydGllc19fLm92ZXJyaWRlaWRcbiAgICAgIH1cblxuICAgICAgbGV0IGxpbmUgPSBgXFx0Y29uc3Qgdl8ke3VnZW4uaWR9ID0gYCBcbiAgICAgIGlmKCAhdWdlbi5pc29wICkgbGluZSArPSBgJHt1Z2VuLnVnZW5OYW1lfSggYFxuXG4gICAgICAvLyBtdXN0IGdldCBhcnJheSBzbyB3ZSBjYW4ga2VlcCB0cmFjayBvZiBsZW5ndGggZm9yIGNvbW1hIGluc2VydGlvblxuICAgICAgY29uc3Qga2V5cyA9IHVnZW4uaXNvcCA9PT0gdHJ1ZSB8fCB1Z2VuLnR5cGUgPT09ICdidXMnICBcbiAgICAgICAgPyBPYmplY3Qua2V5cyggdWdlbi5pbnB1dHMgKSBcbiAgICAgICAgOiBbLi4udWdlbi5pbnB1dE5hbWVzIF0gXG5cbiAgICAgIGxpbmUgPSB1Z2VuLmlzb3AgPT09IHRydWUgXG4gICAgICAgID8gR2liYmVyaXNoLl9fcHJvY2Vzc0Jpbm9wKCB1Z2VuLCBsaW5lLCBibG9jaywga2V5cyApIFxuICAgICAgICA6IEdpYmJlcmlzaC5fX3Byb2Nlc3NOb25CaW5vcCggdWdlbiwgbGluZSwgYmxvY2ssIGtleXMgKVxuXG4gICAgICBsaW5lID0gR2liYmVyaXNoLl9fYWRkTGluZUVuZGluZyggbGluZSwgdWdlbiwga2V5cyApXG5cbiAgICAgIGJsb2NrLnB1c2goIGxpbmUgKVxuICAgICAgXG4gICAgICBHaWJiZXJpc2gubWVtb2VkWyB1Z2VuLnVnZW5OYW1lIF0gPSBgdl8ke3VnZW4uaWR9YFxuXG4gICAgICBpZiggZGlydHlJZHggIT09IC0xICkge1xuICAgICAgICBHaWJiZXJpc2guZGlydHlVZ2Vucy5zcGxpY2UoIGRpcnR5SWR4LCAxIClcbiAgICAgIH1cblxuICAgIH1lbHNlIGlmKCB1Z2VuLmJsb2NrICkge1xuICAgICAgcmV0dXJuIHVnZW4uYmxvY2tcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tcbiAgfSwgXG5cbiAgX19wcm9jZXNzQmlub3AoIHVnZW4sIGxpbmUsIGJsb2NrLCBrZXlzICkge1xuICAgIC8vX19nZXRJbnB1dFN0cmluZyggbGluZSwgaW5wdXQsIGJsb2NrLCBrZXksIHVnZW4gKSB7XG4gICAgY29uc3QgaXNMZWZ0U3RlcmVvID0gR2liYmVyaXNoLl9faXNTdGVyZW8oIHVnZW4uaW5wdXRzWzBdICksIFxuICAgICAgICAgIGlzUmlnaHRTdGVyZW8gPSBHaWJiZXJpc2guX19pc1N0ZXJlbyggdWdlbi5pbnB1dHNbMV0gKSxcbiAgICAgICAgICBsZWZ0ID0gR2liYmVyaXNoLl9fZ2V0SW5wdXRTdHJpbmcoIGxpbmUsIHVnZW4uaW5wdXRzWzBdLCBibG9jaywgJzAnLCBrZXlzICksXG4gICAgICAgICAgcmlnaHQ9IEdpYmJlcmlzaC5fX2dldElucHV0U3RyaW5nKCBsaW5lLCB1Z2VuLmlucHV0c1sxXSwgYmxvY2ssICcxJywga2V5cyApLFxuICAgICAgICAgIG9wID0gdWdlbi5vcFxuICAgICAgICBcbiAgICBsZXQgZ3JhcGgsIG91dFxuXG4gICAgaWYoIGlzTGVmdFN0ZXJlbyA9PT0gdHJ1ZSAmJiBpc1JpZ2h0U3RlcmVvID09PSBmYWxzZSApIHtcbiAgICAgIGxpbmUgKz0gYFsgJHtsZWZ0fVswXSAke29wfSAke3JpZ2h0fSwgJHtsZWZ0fVsxXSAke29wfSAke3JpZ2h0fSBdYFxuICAgICAgLy9ncmFwaCA9IFsgZy5hZGQoIGFyZ3NbMF0uZ3JhcGhbMF0sIGFyZ3NbMV0gKSwgZy5hZGQoIGFyZ3NbMF0uZ3JhcGhbMV0sIGFyZ3NbMV0gKV1cbiAgICB9ZWxzZSBpZiggaXNMZWZ0U3RlcmVvID09PSBmYWxzZSAmJiBpc1JpZ2h0U3RlcmVvID09PSB0cnVlICkge1xuICAgICAgLy9ncmFwaCA9IFsgZy5hZGQoIGFyZ3NbMF0sIGFyZ3NbMV0uZ3JhcGhbMF0gKSwgZy5hZGQoIGFyZ3NbMF0sIGFyZ3NbMV0uZ3JhcGhbMV0gKV1cbiAgICAgIGxpbmUgKz0gYFsgJHtsZWZ0fSAke29wfSAke3JpZ2h0fVswXSwgJHtsZWZ0fSAke29wfSAke3JpZ2h0fVsxXSBdYFxuICAgIH1lbHNlIGlmKCBpc0xlZnRTdGVyZW8gPT09IHRydWUgJiYgaXNSaWdodFN0ZXJlbyA9PT0gdHJ1ZSApIHtcbiAgICAgIC8vZ3JhcGggPSBbIGcuYWRkKCBhcmdzWzBdLmdyYXBoWzBdLCBhcmdzWzFdLmdyYXBoWzBdICksIGcuYWRkKCBhcmdzWzBdLmdyYXBoWzFdLCBhcmdzWzFdLmdyYXBoWzFdICldXG4gICAgICBsaW5lICs9IGBbICR7bGVmdH1bMF0gJHtvcH0gJHtyaWdodH1bMF0sICR7bGVmdH1bMV0gJHtvcH0gJHtyaWdodH1bMV0gXWBcbiAgICB9ZWxzZXtcbiAgICAgIC8vIFhYWCBpbXBvcnRhbnQsIG11c3QgcmUtYXNzaWduIHdoZW4gY2FsbGluZyBwcm9jZXNzTm9uQmlub3BcbiAgICAgIGxpbmUgPSBHaWJiZXJpc2guX19wcm9jZXNzTm9uQmlub3AoIHVnZW4sIGxpbmUsIGJsb2NrLCBrZXlzIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGxpbmVcbiAgfSxcblxuICBfX3Byb2Nlc3NOb25CaW5vcCggdWdlbiwgbGluZSwgYmxvY2ssIGtleXMgKSB7XG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrICkge1xuICAgICAgbGV0IGtleSA9IGtleXNbIGkgXVxuICAgICAgLy8gYmlub3AuaW5wdXRzIGlzIGFjdHVhbCB2YWx1ZXMsIG5vdCBqdXN0IHByb3BlcnR5IG5hbWVzXG4gICAgICBsZXQgaW5wdXQgXG4gICAgICBpZiggdWdlbi5pc29wIHx8IHVnZW4udHlwZSA9PT0nYnVzJyApIHtcbiAgICAgICAgaW5wdXQgPSB1Z2VuLmlucHV0c1sga2V5IF1cbiAgICAgIH1lbHNle1xuICAgICAgICBpbnB1dCA9IHVnZW5bIGtleSBdIFxuICAgICAgfVxuXG4gICAgICBpZiggaW5wdXQgIT09IHVuZGVmaW5lZCApIHsgXG4gICAgICAgIGlucHV0ID0gR2liYmVyaXNoLl9fZ2V0QnlwYXNzZWRJbnB1dCggaW5wdXQgKVxuICAgICAgICBsaW5lICs9IEdpYmJlcmlzaC5fX2dldElucHV0U3RyaW5nKCBsaW5lLCBpbnB1dCwgYmxvY2ssIGtleSwgdWdlbiApXG4gICAgICAgIGxpbmUgID0gR2liYmVyaXNoLl9fYWRkU2VwYXJhdG9yKCBsaW5lLCBpbnB1dCwgdWdlbiwgaSA8IGtleXMubGVuZ3RoIC0gMSApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVcbiAgfSxcblxuICAvLyBkZXRlcm1pbmUgaWYgYSB1Z2VuIGlzIHN0ZXJlb1xuICBfX2lzU3RlcmVvKCB1Z2VuICkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG5cbiAgICBpZiggdWdlbiA9PT0gdW5kZWZpbmVkIHx8IHVnZW4gPT09IG51bGwgKSByZXR1cm4gZmFsc2VcblxuICAgIGlmKCB1Z2VuLmlzU3RlcmVvID09PSB0cnVlICkgcmV0dXJuIHRydWVcblxuICAgIGlmKCB1Z2VuLmlzb3AgPT09IHRydWUgKSB7XG4gICAgICByZXR1cm4gR2liYmVyaXNoLl9faXNTdGVyZW8oIHVnZW4uaW5wdXRzWzBdICkgfHwgR2liYmVyaXNoLl9faXNTdGVyZW8oIHVnZW4uaW5wdXRzWzFdIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGlzU3RlcmVvXG4gIH0sXG5cbiAgLy8gaWYgYW4gZWZmZWN0IGlzIGJ5cGFzc2VkLCBnZXQgbmV4dCBvbmUgaW4gY2hhaW4gKG9yIG91dHB1dCBkZXN0aW5hdGlvbilcbiAgX19nZXRCeXBhc3NlZElucHV0KCBpbnB1dCApIHtcbiAgICBpZiggaW5wdXQuYnlwYXNzID09PSB0cnVlICkge1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIGlucHV0cyBvZiBjaGFpbiB1bnRpbCBvbmUgaXMgZm91bmRcbiAgICAgIC8vIHRoYXQgaXMgbm90IGJlaW5nIGJ5cGFzc2VkXG5cbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlXG5cbiAgICAgIHdoaWxlKCBpbnB1dC5pbnB1dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZm91bmQgPT09IGZhbHNlICkge1xuICAgICAgICBpZiggdHlwZW9mIGlucHV0LmlucHV0LmJ5cGFzcyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5pbnB1dFxuICAgICAgICAgIGlmKCBpbnB1dC5ieXBhc3MgPT09IGZhbHNlICkgZm91bmQgPSB0cnVlXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuaW5wdXRcbiAgICAgICAgICBmb3VuZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnB1dFxuICB9LFxuXG4gIC8vIGdldCBhIHN0cmluZyByZXByZXNlbnRpbmcgYSB1Z2VuIGZvciBpbnNlcnRpb24gaW50byBjYWxsYmFjay5cbiAgLy8gaWYgYSB1Z2VuIGNvbnRhaW5zIG90aGVyIHVnZW5zLCB0cmlnZ2VyIGNvZGVnZW4gZm9yIHRob3NlIHVnZW5zIGFzIHdlbGwuXG4gIF9fZ2V0SW5wdXRTdHJpbmcoIGxpbmUsIGlucHV0LCBibG9jaywga2V5LCB1Z2VuICkge1xuICAgIGxldCB2YWx1ZSA9ICcnXG4gICAgaWYoIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgKSB7XG4gICAgICBpZiggaXNOYU4oa2V5KSApIHtcbiAgICAgICAgdmFsdWUgKz0gYG1lbVske3VnZW4uX19hZGRyZXNzZXNfX1sga2V5IF19XWAvL2lucHV0XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdmFsdWUgKz0gaW5wdXRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgdmFsdWUgKz0gJycgKyBpbnB1dFxuICAgIH1lbHNle1xuICAgICAgLy9jb25zb2xlLmxvZyggJ2tleTonLCBrZXksICdpbnB1dDonLCB1Z2VuLmlucHV0cywgdWdlbi5pbnB1dHNbIGtleSBdICkgXG4gICAgICAvLyBYWFggbm90IHN1cmUgd2h5IHRoaXMgaGFzIHRvIGJlIGhlcmUsIGJ1dCBzb21laG93IG5vbi1wcm9jZXNzZWQgb2JqZWN0c1xuICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gaWQgbnVtYmVycyBhcmUgYmVpbmcgcGFzc2VkIGhlcmUuLi5cblxuICAgICAgaWYoIGlucHV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgaWYoIGlucHV0LnVnZW5OYW1lID09PSB1bmRlZmluZWQgJiYgaW5wdXQuaWQgIT09IHVuZGVmaW5lZCAgKSB7XG4gICAgICAgICAgICBpZiggdWdlbiA9PT0gdW5kZWZpbmVkICApIHtcbiAgICAgICAgICAgICAgaW5wdXQgPSBHaWJiZXJpc2gucHJvY2Vzc29yLnVnZW5zLmdldCggaW5wdXQuaWQgKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGlmKCB1Z2VuLnR5cGUgIT09ICdzZXEnICkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQoIGlucHV0LmlkIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzVWdlbiggaW5wdXQsIGJsb2NrIClcblxuICAgICAgICBpZiggIWlucHV0Lmlzb3AgKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaXMgbmVlZGVkIHNvIHRoYXQgZ3JhcGhzIHdpdGggc3NkcyB0aGF0IHJlZmVyIHRvIHRoZW1zZWx2ZXNcbiAgICAgICAgICAvLyBkb24ndCBhZGQgdGhlIHNzZCBpbiBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2guY2FsbGJhY2tVZ2Vucy5pbmRleE9mKCBpbnB1dC5jYWxsYmFjayApID09PSAtMSApIHtcbiAgICAgICAgICAgIEdpYmJlcmlzaC5jYWxsYmFja1VnZW5zLnB1c2goIGlucHV0LmNhbGxiYWNrIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSArPSBgdl8ke2lucHV0LmlkfWBcbiAgICAgICAgaW5wdXQuX192YXJuYW1lID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfSxcblxuICAvLyBhZGQgc2VwYXJhdG9ycyBmb3IgZnVuY3Rpb24gY2FsbHMgYW5kIGhhbmRsZSBiaW5vcHMgKG1vbm8gb25seSlcbiAgX19hZGRTZXBhcmF0b3IoIGxpbmUsIGlucHV0LCB1Z2VuLCBpc05vdEVuZE9mTGluZSApIHtcbiAgICBpZiggaXNOb3RFbmRPZkxpbmUgPT09IHRydWUgKSB7XG4gICAgICBpZiggdWdlbi5pc29wID09PSB0cnVlICkge1xuICAgICAgICBpZiggdWdlbi5vcCA9PT0gJyonIHx8IHVnZW4ub3AgPT09ICcvJyApIHtcbiAgICAgICAgICBpZiggaW5wdXQgIT09IDEgKSB7XG4gICAgICAgICAgICBsaW5lICs9ICcgJyArIHVnZW4ub3AgKyAnICdcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKCAwLCAtMSAqICgnJytpbnB1dCkubGVuZ3RoIClcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxpbmUgKz0gJyAnICsgdWdlbi5vcCArICcgJ1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbGluZSArPSAnLCAnXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVcbiAgfSxcblxuICAvLyBhZGQgbWVtb3J5IHRvIGVuZCBvZiBmdW5jdGlvbiBjYWxscyBhbmQgY2xvc2UgcGFyZW50aGVzaXMgXG4gIF9fYWRkTGluZUVuZGluZyggbGluZSwgdWdlbiwga2V5cyApIHtcbiAgICBpZiggKHVnZW4udHlwZSA9PT0gJ2J1cycgJiYga2V5cy5sZW5ndGggPiAwKSApIGxpbmUgKz0gJywgJ1xuICAgIGlmKCAhdWdlbi5pc29wICYmIHVnZW4udHlwZSAhPT0gJ3NlcScgKSBsaW5lICs9ICdtZW0nXG4gICAgbGluZSArPSB1Z2VuLmlzb3AgPyAnJyA6ICcgKSdcblxuICAgIHJldHVybiBsaW5lXG4gIH0sXG5cbn1cblxuR2liYmVyaXNoLnByb3RvdHlwZXMuVWdlbiA9IEdpYmJlcmlzaC5wcm90b3R5cGVzLnVnZW4gPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApKCBHaWJiZXJpc2ggKVxuR2liYmVyaXNoLnV0aWxpdGllcyA9IHJlcXVpcmUoICcuL3V0aWxpdGllcy5qcycgKSggR2liYmVyaXNoIClcblxubW9kdWxlLmV4cG9ydHMgPSBHaWJiZXJpc2hcbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuICBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBDbGFwID0gYXJndW1lbnRQcm9wcyA9PiB7XG4gICAgJ3VzZSBqc2RzcCcgXG5cbiAgICBjb25zdCBjbGFwID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApLFxuICAgICAgICAgIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLCAvLyAwLTEgaW5wdXQgdmFsdWVcbiAgICAgICAgICBzY2FsZWREZWNheSA9IGRlY2F5ICogKGcuZ2VuLnNhbXBsZXJhdGUgKiAyICksXG4gICAgICAgICAgZ2FpbiAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBzcGFjaW5nID0gZy5pbiggJ3NwYWNpbmcnICksIC8vIHNwYWNpbmcgYmV0d2VlbiBjbGFwLCBpbiBIenNcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgY3V0b2ZmID0gZy5pbignY3V0b2ZmJyksXG4gICAgICAgICAgUSAgICAgID0gZy5pbignUScpXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBDbGFwLmRlZmF1bHRzLCBhcmd1bWVudFByb3BzIClcblxuICAgIGNvbnN0IGVnID0gZy5kZWNheSggc2NhbGVkRGVjYXksIHsgaW5pdFZhbHVlOjAgfSApLCBcbiAgICAgICAgICBjaGVjayA9IGcuZ3QoIGVnLCAuMDAwNSApLFxuICAgICAgICAgIG5vaXNlID0gLTEgKyBnLm5vaXNlKCkgKiAyLFxuICAgICAgICAgIHJuZCA9IG5vaXNlLC8vZy5ndHAoIG5vaXNlLCAwICksLy8gKiBlZyxcbiAgICAgICAgICBiICAgPSBnLmJhbmcoKSxcbiAgICAgICAgICBzYXcgPSBnLnBoYXNvciggc3BhY2luZywgYiwgeyBtaW46MCB9KSxcbiAgICAgICAgICByc2F3ID0gMSAtIHNhdyxcbiAgICAgICAgICBzYXdfZW52ID0gZy5hZCggMCwgLjAzNSAqIGcuZ2VuLnNhbXBsZXJhdGUsIHsgc2hhcGU6J2xpbmVhcicgfSksIFxuICAgICAgICAgIGIyID0gZy5iYW5nKCksXG4gICAgICAgICAgY291bnQgPSBnLmFjY3VtKCAxLGIyLHsgbWF4OkluZmluaXR5LCBtaW46MCwgaW5pdGlhbFZhbHVlOjAgfSksXG4gICAgICAgICAgZGVsYXllZE5vaXNlID0gZy5zd2l0Y2goIGcuZ3RlKCBjb3VudCwgZy5nZW4uc2FtcGxlcmF0ZSAqIC4wMzUgKSwgcm5kLCAwICksXG4gICAgICAgICAgYnBmMSA9IGcuc3ZmKCBkZWxheWVkTm9pc2UsIDEwMDAsIC41LCAyLCBmYWxzZSApLFxuXG4gICAgICAgICAgc2NhbGVkT3V0ID0gKCBicGYxICogZWcgKyAoIHJuZCAqIHJzYXcgKiBzYXdfZW52ICkgKSAqIGdhaW4gKiBsb3VkbmVzcyAqIHRyaWdnZXJMb3VkbmVzcyxcbiAgICAgICAgICBvdXQgPSBnLnN2Ziggc2NhbGVkT3V0LCBjdXRvZmYsIFEsIDEsIGZhbHNlIClcbiAgICBcbiAgICAvLyBYWFggVE9ETyA6IG1ha2UgdGhpcyB3b3JrIHdpdGggaWZlbHNlLiB0aGUgcHJvYmxlbSBpcyB0aGF0IHBva2UgdWdlbnMgcHV0IHRoZWlyXG4gICAgLy8gY29kZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgaW5zdGVhZCBvZiBhdCB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIGFzc29jaWF0ZWQgaWYvZWxzZSBibG9jay5cbiAgICBjb25zdCBpZmUgPSBnLnN3aXRjaCggY2hlY2ssIG91dCwgMCApXG4gICAgXG4gICAgY2xhcC5lbnYgPSB7XG4gICAgICB0cmlnZ2VyKCB2b2wgKSB7XG4gICAgICAgIGIudHJpZ2dlcigpXG4gICAgICAgIGVnLnRyaWdnZXIoIHZvbCApXG4gICAgICAgIGIyLnRyaWdnZXIoKVxuICAgICAgICBzYXdfZW52LnRyaWdnZXIoKVxuICAgICAgfVxuICAgIH0gXG4gICAgXG4gICAgcmV0dXJuIEdpYmJlcmlzaC5mYWN0b3J5KCBjbGFwLCBpZmUsIFsnaW5zdHJ1bWVudHMnLCdjbGFwJ10sIHByb3BzICApXG4gIH1cbiAgXG4gIENsYXAuZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBzcGFjaW5nOjEwMCxcbiAgICBkZWNheTouMixcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjEsXG4gICAgY3V0b2ZmOjkwMCxcbiAgICBROi44NVxuICB9XG5cbiAgcmV0dXJuIENsYXBcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKSxcbiAgICAgIF9fd2F2ZWZvbGQgICA9IHJlcXVpcmUoICcuLi9meC93YXZlZm9sZGVyLmRzcC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3Qgd2F2ZWZvbGQgPSBfX3dhdmVmb2xkKCBHaWJiZXJpc2ggKVsxXVxuXG4gIGNvbnN0IENvbXBsZXggPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBzeW4gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcblxuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgbG91ZG5lc3MgID0gZy5pbiggJ2xvdWRuZXNzJyApLCBcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgZ2xpZGUgICA9IGcubWF4KCAxLCBnLmluKCAnZ2xpZGUnICkgKSxcbiAgICAgICAgICBzbGlkaW5nRnJlcSA9IGcuc2xpZGUoIGZyZXF1ZW5jeSwgZ2xpZGUsIGdsaWRlICksXG4gICAgICAgICAgYXR0YWNrICA9IGcuaW4oICdhdHRhY2snICksIFxuICAgICAgICAgIGRlY2F5ICAgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgc3VzdGFpbiA9IGcuaW4oICdzdXN0YWluJyApLCBcbiAgICAgICAgICBzdXN0YWluTGV2ZWwgPSBnLmluKCAnc3VzdGFpbkxldmVsJyApLFxuICAgICAgICAgIHJlbGVhc2UgPSBnLmluKCAncmVsZWFzZScgKSxcbiAgICAgICAgICBwcmVnYWluID0gZy5pbiggJ3ByZWdhaW4nICksXG4gICAgICAgICAgcG9zdGdhaW49IGcuaW4oICdwb3N0Z2FpbicgKSxcbiAgICAgICAgICBiaWFzICAgID0gZy5pbiggJ2JpYXMnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIENvbXBsZXguZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwgcHJvcHMgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG9zYyA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCBzeW4ud2F2ZWZvcm0sIHNsaWRpbmdGcmVxLCBzeW4uYW50aWFsaWFzIClcblxuICAgICAgY29uc3QgZW52ID0gR2liYmVyaXNoLmVudmVsb3Blcy5mYWN0b3J5KCBcbiAgICAgICAgcHJvcHMudXNlQURTUiwgXG4gICAgICAgIHByb3BzLnNoYXBlLCBcbiAgICAgICAgYXR0YWNrLCBkZWNheSwgXG4gICAgICAgIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgXG4gICAgICAgIHJlbGVhc2UsIFxuICAgICAgICBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgICAgKVxuXG4gICAgICBjb25zdCBzYXR1cmF0aW9uID0gZy5pbignc2F0dXJhdGlvbicpXG5cbiAgICAgIC8vIGJlbG93IGRvZXNuJ3Qgd29yayBhcyBpdCBhdHRlbXB0cyB0byBhc3NpZ24gdG8gcmVsZWFzZSBwcm9wZXJ0eSB0cmlnZ2VyaW5nIGNvZGVnZW4uLi5cbiAgICAgIC8vIHN5bi5yZWxlYXNlID0gKCk9PiB7IHN5bi5lbnYucmVsZWFzZSgpIH1cblxuICAgICAge1xuICAgICAgICAndXNlIGpzZHNwJ1xuICAgICAgICBsZXQgb3NjV2l0aEVudiA9IG9zYyAqIGVudiAqIGxvdWRuZXNzICogdHJpZ2dlckxvdWRuZXNzLFxuICAgICAgICAgICAgcGFubmVyXG5cbiAgICAgICAgbGV0IGZvbGRlZE9zYyA9IHdhdmVmb2xkKCB3YXZlZm9sZCggd2F2ZWZvbGQoIHdhdmVmb2xkKCBiaWFzICsgb3NjV2l0aEVudiAqIChwcmVnYWluICogZW52KSAqIC4zMzMgKSApICkgKVxuICAgICAgICBmb2xkZWRPc2MgPSBnLnRhbmgoIGZvbGRlZE9zYyAqIC42ICkgKiBwb3N0Z2FpblxuIFxuICAgICAgICAvLyAxNiBpcyBhbiB1bmZvcnR1bmF0ZSBlbXBpcmljYWxseSBkZXJpdmVkIG1hZ2ljIG51bWJlci4uLlxuICAgICAgICBjb25zdCBiYXNlQ3V0b2ZmRnJlcSA9IGcuaW4oJ2N1dG9mZicpICogKCBmcmVxdWVuY3kgLyAgKCBnLmdlbi5zYW1wbGVyYXRlIC8gMTYgKSApIFxuICAgICAgICBjb25zdCBjdXRvZmYgPSBnLm1pbiggYmFzZUN1dG9mZkZyZXEgKiBnLnBvdyggMiwgZy5pbignZmlsdGVyTXVsdCcpICogbG91ZG5lc3MgKiB0cmlnZ2VyTG91ZG5lc3MgKSAqIGVudiwgLjk5NSApIFxuICAgICAgICBjb25zdCBmaWx0ZXJlZE9zYyA9IEdpYmJlcmlzaC5maWx0ZXJzLmZhY3RvcnkoIGZvbGRlZE9zYywgY3V0b2ZmLCBzYXR1cmF0aW9uLCBwcm9wcyApXG5cbiAgICAgICAgbGV0IGNvbXBsZXhXaXRoR2FpbiA9IGZpbHRlcmVkT3NjICogZy5pbiggJ2dhaW4nIClcbiAgICAgICAgLy8gWFhYIHVnbHksIHVnbHkgaGFja1xuICAgICAgICBpZiggIHByb3BzLmZpbHRlck1vZGVsICE9PSAyICkgY29tcGxleFdpdGhHYWluID0gY29tcGxleFdpdGhHYWluICogc2F0dXJhdGlvblxuICAgIFxuICAgICAgICBpZiggc3luLnBhblZvaWNlcyA9PT0gdHJ1ZSApIHsgXG4gICAgICAgICAgcGFubmVyID0gZy5wYW4oIGNvbXBsZXhXaXRoR2FpbiwgY29tcGxleFdpdGhHYWluLCBnLmluKCAncGFuJyApICkgXG4gICAgICAgICAgc3luLmdyYXBoID0gWyBwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgc3luLmdyYXBoID0gY29tcGxleFdpdGhHYWluXG4gICAgICAgIH1cblxuICAgICAgICBzeW4uZW52ID0gZW52XG4gICAgICAgIHN5bi5vc2MgPSBvc2NcbiAgICAgICAgc3luLmZpbHRlciA9IGZpbHRlcmVkT3NjXG4gICAgICB9XG5cbiAgICB9XG4gICAgXG4gICAgc3luLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnd2F2ZWZvcm0nLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywnZmlsdGVyTW9kZScsICd1c2VBRFNSJywgJ3NoYXBlJyBdXG4gICAgc3luLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHN5biwgc3luLmdyYXBoLCBbJ2luc3RydW1lbnRzJywgJ2NvbXBsZXgnXSwgcHJvcHMgIClcblxuICAgIHJldHVybiBvdXRcbiAgfVxuICBcbiAgQ29tcGxleC5kZWZhdWx0cyA9IHtcbiAgICB3YXZlZm9ybTondHJpYW5nbGUnLFxuICAgIGF0dGFjazogNDQsXG4gICAgZGVjYXk6IDIyMDUwLFxuICAgIHN1c3RhaW46NDQxMDAsXG4gICAgc3VzdGFpbkxldmVsOi42LFxuICAgIHJlbGVhc2U6MjIwNTAsXG4gICAgdXNlQURTUjpmYWxzZSxcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnLFxuICAgIHRyaWdnZXJSZWxlYXNlOmZhbHNlLFxuICAgIGdhaW46IC41LFxuICAgIHB1bHNld2lkdGg6LjI1LFxuICAgIGZyZXF1ZW5jeToyMjAsXG4gICAgcGFuOiAuNSxcbiAgICBhbnRpYWxpYXM6dHJ1ZSxcbiAgICBwYW5Wb2ljZXM6ZmFsc2UsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxLFxuICAgIGdsaWRlOjEsXG4gICAgc2F0dXJhdGlvbjoxLFxuICAgIGZpbHRlck11bHQ6MixcbiAgICBROi4yNSxcbiAgICBjdXRvZmY6LjUsXG4gICAgLy9maWx0ZXJUeXBlOjEsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNb2RlOjAsXG4gICAgaXNTdGVyZW86ZmFsc2UsXG4gICAgcHJlZ2Fpbjo0LFxuICAgIHBvc3RnYWluOjEsXG4gICAgYmlhczowXG4gIH1cblxuICAvLyBkbyBub3QgaW5jbHVkZSB2ZWxvY2l0eSwgd2hpY2ggc2hvdWRsIGFsd2F5cyBiZSBwZXIgdm9pY2VcbiAgbGV0IFBvbHlDb21wbGV4ID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggQ29tcGxleCwgWydmcmVxdWVuY3knLCdhdHRhY2snLCdkZWNheScsJ3B1bHNld2lkdGgnLCdwYW4nLCdnYWluJywnZ2xpZGUnLCAnc2F0dXJhdGlvbicsICdmaWx0ZXJNdWx0JywgJ1EnLCAnY3V0b2ZmJywgJ3Jlc29uYW5jZScsICdhbnRpYWxpYXMnLCAnZmlsdGVyTW9kZWwnLCAnd2F2ZWZvcm0nLCAnZmlsdGVyTW9kZScsICdfX3RyaWdnZXJMb3VkbmVzcycsICdsb3VkbmVzcycsICdwcmVnYWluJywgJ3Bvc3RnYWluJywgJ2JpYXMnXSApIFxuICBQb2x5Q29tcGxleC5kZWZhdWx0cyA9IENvbXBsZXguZGVmYXVsdHNcblxuICByZXR1cm4gWyBDb21wbGV4LCBQb2x5Q29tcGxleCBdXG5cbn1cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgQ29uZ2EgPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBjb25zdCBjb25nYSA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKSxcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIGdhaW4gID0gZy5pbiggJ2dhaW4nICksXG4gICAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBDb25nYS5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBjb25zdCB0cmlnZ2VyID0gZy5iYW5nKCksXG4gICAgICAgICAgaW1wdWxzZSA9IGcubXVsKCB0cmlnZ2VyLCA2MCApLFxuICAgICAgICAgIF9kZWNheSA9ICBnLnN1YiggLjEwMSwgZy5kaXYoIGRlY2F5LCAxMCApICksIC8vIGNyZWF0ZSByYW5nZSBvZiAuMDAxIC0gLjA5OVxuICAgICAgICAgIGJwZiA9IGcuc3ZmKCBpbXB1bHNlLCBmcmVxdWVuY3ksIF9kZWNheSwgMiwgZmFsc2UgKSxcbiAgICAgICAgICBvdXQgPSBnLm11bCggYnBmLCBnLm11bCggZy5tdWwoIHRyaWdnZXJMb3VkbmVzcyxsb3VkbmVzcyApLCBnYWluICkgKVxuICAgIFxuICAgIGNvbmdhLmlzU3RlcmVvID0gZmFsc2VcbiAgICBjb25nYS5lbnYgPSB0cmlnZ2VyXG4gICAgcmV0dXJuIEdpYmJlcmlzaC5mYWN0b3J5KCBjb25nYSwgb3V0LCBbJ2luc3RydW1lbnRzJywnY29uZ2EnXSwgcHJvcHMgIClcbiAgfVxuICBcbiAgQ29uZ2EuZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogLjEyNSxcbiAgICBmcmVxdWVuY3k6MTkwLFxuICAgIGRlY2F5OiAuODUsXG4gICAgbG91ZG5lc3M6IDEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgY29uc3QgUG9seUNvbmdhID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggQ29uZ2EsIFsnZ2FpbicsJ2ZyZXF1ZW5jeScsJ2RlY2F5JywnbG91ZG5lc3MnLCdfX3RyaWdnZXJMb3VkbmVzcycgXSApIFxuICBQb2x5Q29uZ2EuZGVmYXVsdHMgPSBDb25nYS5kZWZhdWx0c1xuXG4gIHJldHVybiBbIENvbmdhLCBQb2x5Q29uZ2EgXVxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBDb3diZWxsID0gYXJndW1lbnRQcm9wcyA9PiB7XG4gICAgbGV0IGNvd2JlbGwgPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcbiAgICBcbiAgICBjb25zdCBkZWNheSAgID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIGdhaW4gICAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIENvd2JlbGwuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgY29uc3QgYnBmQ3V0b2ZmID0gZy5wYXJhbSggJ2JwZmMnLCAxMDAwICksXG4gICAgICAgICAgczEgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIDU2MCApLFxuICAgICAgICAgIHMyID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCA4NDUgKSxcbiAgICAgICAgICBlZyA9IGcuZGVjYXkoIGcubXVsKCBkZWNheSwgZy5nZW4uc2FtcGxlcmF0ZSAqIDIgKSwgeyBpbml0VmFsdWU6MCB9KSwgXG4gICAgICAgICAgYnBmID0gZy5zdmYoIGcuYWRkKCBzMSxzMiApLCBicGZDdXRvZmYsIDMsIDIsIGZhbHNlICksXG4gICAgICAgICAgZW52QnBmID0gZy5tdWwoIGJwZiwgZWcgKSxcbiAgICAgICAgICBvdXQgPSBnLm11bCggZW52QnBmLCBnLm11bCggZ2FpbiwgbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApIClcblxuICAgIGNvd2JlbGwuZW52ID0gZWcgXG5cbiAgICBjb3diZWxsLmlzU3RlcmVvID0gZmFsc2VcblxuICAgIGNvd2JlbGwgPSBHaWJiZXJpc2guZmFjdG9yeSggY293YmVsbCwgb3V0LCBbJ2luc3RydW1lbnRzJywgJ2Nvd2JlbGwnXSwgcHJvcHMgIClcbiAgICBcbiAgICByZXR1cm4gY293YmVsbFxuICB9XG4gIFxuICBDb3diZWxsLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgZGVjYXk6LjUsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICByZXR1cm4gQ293YmVsbFxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbmNvbnN0IGdlbmlzaCA9IGdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IEZNID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgbGV0IHN5biA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuXG4gICAgbGV0IGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgIGdsaWRlID0gZy5tYXgoIDEsIGcuaW4oICdnbGlkZScgKSApLFxuICAgICAgICBzbGlkaW5nRnJlcSA9IGcuc2xpZGUoIGZyZXF1ZW5jeSwgZ2xpZGUsIGdsaWRlICksXG4gICAgICAgIGNtUmF0aW8gPSBnLmluKCAnY21SYXRpbycgKSxcbiAgICAgICAgaW5kZXggPSBnLmluKCAnaW5kZXgnICksXG4gICAgICAgIGZlZWRiYWNrID0gZy5pbiggJ2ZlZWRiYWNrJyApLFxuICAgICAgICBhdHRhY2sgPSBnLmluKCAnYXR0YWNrJyApLCBkZWNheSA9IGcuaW4oICdkZWNheScgKSxcbiAgICAgICAgc3VzdGFpbiA9IGcuaW4oICdzdXN0YWluJyApLCBzdXN0YWluTGV2ZWwgPSBnLmluKCAnc3VzdGFpbkxldmVsJyApLFxuICAgICAgICByZWxlYXNlID0gZy5pbiggJ3JlbGVhc2UnICksXG4gICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgIHNhdHVyYXRpb24gPSBnLmluKCAnc2F0dXJhdGlvbicgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgRk0uZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwgcHJvcHMgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGVudiA9IEdpYmJlcmlzaC5lbnZlbG9wZXMuZmFjdG9yeSggXG4gICAgICAgIHByb3BzLnVzZUFEU1IsIFxuICAgICAgICBwcm9wcy5zaGFwZSwgXG4gICAgICAgIGF0dGFjaywgZGVjYXksIFxuICAgICAgICBzdXN0YWluLCBzdXN0YWluTGV2ZWwsIFxuICAgICAgICByZWxlYXNlLCBcbiAgICAgICAgcHJvcHMudHJpZ2dlclJlbGVhc2VcbiAgICAgIClcblxuICAgICAgc3luLmFkdmFuY2UgPSAoKT0+IHsgZW52LnJlbGVhc2UoKSB9XG5cbiAgICAgIGNvbnN0IGZlZWRiYWNrc3NkID0gZy5oaXN0b3J5KCAwIClcblxuICAgICAgY29uc3QgbW9kT3NjID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoIFxuICAgICAgICBzeW4ubW9kdWxhdG9yV2F2ZWZvcm0sIFxuICAgICAgICBnLmFkZCggZy5tdWwoIHNsaWRpbmdGcmVxLCBjbVJhdGlvICksIGcubXVsKCBmZWVkYmFja3NzZC5vdXQsIGZlZWRiYWNrLCBpbmRleCApICksIFxuICAgICAgICBzeW4uYW50aWFsaWFzIFxuICAgICAgKVxuXG4gICAgICB7XG4gICAgICAgICd1c2UganNkc3AnXG4gICAgICAgIGNvbnN0IExvdWRuZXNzID0gbG91ZG5lc3MgKiB0cmlnZ2VyTG91ZG5lc3NcbiAgICAgICAgY29uc3QgbW9kT3NjV2l0aEluZGV4ID0gbW9kT3NjICogc2xpZGluZ0ZyZXEgKiBpbmRleCAqIExvdWRuZXNzXG4gICAgICAgIGNvbnN0IG1vZE9zY1dpdGhFbnYgICA9IG1vZE9zY1dpdGhJbmRleCAqIGVudlxuICAgICAgICBcbiAgICAgICAgY29uc3QgbW9kT3NjV2l0aEVudkF2ZyA9ICAuNSAqICggbW9kT3NjV2l0aEVudiArIGZlZWRiYWNrc3NkLm91dCApXG5cbiAgICAgICAgZmVlZGJhY2tzc2QuaW4oIG1vZE9zY1dpdGhFbnZBdmcgKVxuXG4gICAgICAgIGNvbnN0IGNhcnJpZXJPc2MgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggc3luLmNhcnJpZXJXYXZlZm9ybSwgZy5hZGQoIHNsaWRpbmdGcmVxLCBtb2RPc2NXaXRoRW52QXZnICksIHN5bi5hbnRpYWxpYXMgKVxuXG4gICAgICAgIC8vIFhYWCBob3JyaWJsZSBoYWNrIGJlbG93IHRvIFwidXNlXCIgc2F0dXJhdGlvbiBldmVuIHdoZW4gbm90IHVzaW5nIGEgZGlvZGUgZmlsdGVyIFxuICAgICAgICBjb25zdCBjYXJyaWVyT3NjV2l0aEVudiA9IHByb3BzLmZpbHRlck1vZGVsID09PSAyID8gY2Fycmllck9zYyAqIGVudiA6IGcubXVsKGNhcnJpZXJPc2MsIGcubXVsKGVudixzYXR1cmF0aW9uKSApXG5cbiAgICAgICAgY29uc3QgYmFzZUN1dG9mZkZyZXEgPSBnLmluKCAnY3V0b2ZmJyApICogKCBmcmVxdWVuY3kgLyAgKCBnLmdlbi5zYW1wbGVyYXRlIC8gMTYgKSApIFxuICAgICAgICBjb25zdCBjdXRvZmYgPSBnLm1pbiggYmFzZUN1dG9mZkZyZXEgKiBnLnBvdyggMiwgZy5pbignZmlsdGVyTXVsdCcpICogTG91ZG5lc3MgKSAqIGVudiwgLjk5NSApIFxuICAgICAgICBjb25zdCBmaWx0ZXJlZE9zYyA9IEdpYmJlcmlzaC5maWx0ZXJzLmZhY3RvcnkoIGNhcnJpZXJPc2NXaXRoRW52LCBjdXRvZmYsIHNhdHVyYXRpb24sIHN5biApXG4gICAgICAgIGNvbnN0IHN5bnRoV2l0aEdhaW4gPSBmaWx0ZXJlZE9zYyAqIGcuaW4oICdnYWluJyApICogTG91ZG5lc3NcbiAgICAgICAgXG4gICAgICAgIGxldCBwYW5uZXJcbiAgICAgICAgaWYoIHByb3BzLnBhblZvaWNlcyA9PT0gdHJ1ZSApIHsgXG4gICAgICAgICAgcGFubmVyID0gZy5wYW4oIHN5bnRoV2l0aEdhaW4sIHN5bnRoV2l0aEdhaW4sIGcuaW4oICdwYW4nICkgKSBcbiAgICAgICAgICBzeW4uZ3JhcGggPSBbcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgICAgICAgc3luLmlzU3RlcmVvID0gdHJ1ZVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzeW4uZ3JhcGggPSBzeW50aFdpdGhHYWluXG4gICAgICAgICAgc3luLmlzU3RlcmVvID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzeW4uZW52ID0gZW52XG5cbiAgICAgIHJldHVybiBlbnZcbiAgICB9XG4gICAgXG4gICAgc3luLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnY2FycmllcldhdmVmb3JtJywgJ21vZHVsYXRvcldhdmVmb3JtJywgJ2FudGlhbGlhcycsICdmaWx0ZXJNb2RlbCcsICdmaWx0ZXJNb2RlJyBdXG4gICAgY29uc3QgZW52ID0gc3luLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHN5biwgc3luLmdyYXBoICwgWydpbnN0cnVtZW50cycsJ0ZNJ10sIHByb3BzIClcblxuICAgIG91dC5lbnYuYWR2YW5jZSA9IG91dC5hZHZhbmNlIFxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIEZNLmRlZmF1bHRzID0ge1xuICAgIGNhcnJpZXJXYXZlZm9ybTonc2luZScsXG4gICAgbW9kdWxhdG9yV2F2ZWZvcm06J3NpbmUnLFxuICAgIGF0dGFjazogNDQsXG4gICAgZmVlZGJhY2s6IDAsXG4gICAgZGVjYXk6IDIyMDUwLFxuICAgIHN1c3RhaW46NDQxMDAsXG4gICAgc3VzdGFpbkxldmVsOi42LFxuICAgIHJlbGVhc2U6MjIwNTAsXG4gICAgdXNlQURTUjpmYWxzZSxcbiAgICBzaGFwZTonbGluZWFyJyxcbiAgICB0cmlnZ2VyUmVsZWFzZTpmYWxzZSxcbiAgICBnYWluOiAuMjUsXG4gICAgY21SYXRpbzoyLFxuICAgIGluZGV4OjUsXG4gICAgcHVsc2V3aWR0aDouMjUsXG4gICAgZnJlcXVlbmN5OjIyMCxcbiAgICBwYW46IC41LFxuICAgIGFudGlhbGlhczpmYWxzZSxcbiAgICBwYW5Wb2ljZXM6ZmFsc2UsXG4gICAgZ2xpZGU6MSxcbiAgICBzYXR1cmF0aW9uOjEsXG4gICAgZmlsdGVyTXVsdDoxLjUsXG4gICAgUTouMjUsXG4gICAgY3V0b2ZmOi4zNSxcbiAgICBmaWx0ZXJNb2RlbDowLFxuICAgIGZpbHRlck1vZGU6MCxcbiAgICBsb3VkbmVzczogMSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG5cbiAgfVxuXG4gIGNvbnN0IFBvbHlGTSA9IEdpYmJlcmlzaC5Qb2x5VGVtcGxhdGUoIEZNLCBbJ2dsaWRlJywnZnJlcXVlbmN5JywnYXR0YWNrJywnZGVjYXknLCdwdWxzZXdpZHRoJywncGFuJywnZ2FpbicsJ2NtUmF0aW8nLCdpbmRleCcsICdzYXR1cmF0aW9uJywgJ2ZpbHRlck11bHQnLCAnUScsICdjdXRvZmYnLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywgJ2NhcnJpZXJXYXZlZm9ybScsICdtb2R1bGF0b3JXYXZlZm9ybScsJ2ZpbHRlck1vZGUnLCAnZmVlZGJhY2snLCAndXNlQURTUicsICdzdXN0YWluJywgJ3JlbGVhc2UnLCAnc3VzdGFpbkxldmVsJywgJ19fdHJpZ2dlckxvdWRuZXNzJywnbG91ZG5lc3MnIF0gKSBcbiAgUG9seUZNLmRlZmF1bHRzID0gRk0uZGVmYXVsdHNcblxuICByZXR1cm4gWyBGTSwgUG9seUZNIF1cblxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBsZXQgSGF0ID0gYXJndW1lbnRQcm9wcyA9PiB7XG4gICAgbGV0IGhhdCA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKSxcbiAgICAgICAgdHVuZSAgPSBnLmluKCAndHVuZScgKSxcbiAgICAgICAgc2NhbGVkVHVuZSA9IGcubWVtbyggZy5hZGQoIC40LCB0dW5lICkgKSxcbiAgICAgICAgZGVjYXkgID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICBnYWluICA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApXG5cbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgSGF0LmRlZmF1bHRzLCBhcmd1bWVudFByb3BzIClcblxuICAgIGxldCBiYXNlRnJlcSA9IGcubXVsKCAzMjUsIHNjYWxlZFR1bmUgKSwgLy8gcmFuZ2Ugb2YgMTYyLjUgLSA0ODcuNVxuICAgICAgICBicGZDdXRvZmYgPSBnLm11bCggZy5wYXJhbSggJ2JwZmMnLCA3MDAwICksIHNjYWxlZFR1bmUgKSxcbiAgICAgICAgaHBmQ3V0b2ZmID0gZy5tdWwoIGcucGFyYW0oICdocGZjJywgMTEwMDAgKSwgc2NhbGVkVHVuZSApLCAgXG4gICAgICAgIHMxID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCBiYXNlRnJlcSwgZmFsc2UgKSxcbiAgICAgICAgczIgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIGcubXVsKCBiYXNlRnJlcSwxLjQ0NzEgKSApLFxuICAgICAgICBzMyA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCAnc3F1YXJlJywgZy5tdWwoIGJhc2VGcmVxLDEuNjE3MCApICksXG4gICAgICAgIHM0ID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCBnLm11bCggYmFzZUZyZXEsMS45MjY1ICkgKSxcbiAgICAgICAgczUgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIGcubXVsKCBiYXNlRnJlcSwyLjUwMjggKSApLFxuICAgICAgICBzNiA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCAnc3F1YXJlJywgZy5tdWwoIGJhc2VGcmVxLDIuNjYzNyApICksXG4gICAgICAgIHN1bSA9IGcuYWRkKCBzMSxzMixzMyxzNCxzNSxzNiApLFxuICAgICAgICBlZyA9IGcuZGVjYXkoIGcubXVsKCBkZWNheSwgZy5nZW4uc2FtcGxlcmF0ZSAqIDIgKSwgeyBpbml0VmFsdWU6MCB9KSwgXG4gICAgICAgIGJwZiA9IGcuc3ZmKCBzdW0sIGJwZkN1dG9mZiwgLjUsIDIsIGZhbHNlICksXG4gICAgICAgIGVudkJwZiA9IGcubXVsKCBicGYsIGVnICksXG4gICAgICAgIGhwZiA9IGcuZmlsdGVyMjQoIGVudkJwZiwgMCwgaHBmQ3V0b2ZmLCAwICksXG4gICAgICAgIG91dCA9IGcubXVsKCBocGYsIGcubXVsKCBnYWluLCBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApICkgKVxuXG4gICAgaGF0LmVudiA9IGVnIFxuICAgIGhhdC5pc1N0ZXJlbyA9IGZhbHNlXG5cbiAgICBjb25zdCBfX2hhdCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBoYXQsIG91dCwgWydpbnN0cnVtZW50cycsJ2hhdCddLCBwcm9wcyAgKVxuICAgIFxuXG4gICAgcmV0dXJuIF9faGF0XG4gIH1cbiAgXG4gIEhhdC5kZWZhdWx0cyA9IHtcbiAgICBnYWluOiAgLjUsXG4gICAgdHVuZTogLjYsXG4gICAgZGVjYXk6LjEsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICByZXR1cm4gSGF0XG5cbn1cbiIsImNvbnN0IHVnZW4gPSByZXF1aXJlKCcuLi91Z2VuLmpzJykoKTtcblxuY29uc3QgaW5zdHJ1bWVudCA9IE9iamVjdC5jcmVhdGUodWdlbik7XG5cbk9iamVjdC5hc3NpZ24oaW5zdHJ1bWVudCwge1xuICB0eXBlOiAnaW5zdHJ1bWVudCcsXG5cbiAgbm90ZShmcmVxLCBsb3VkbmVzcyA9IG51bGwpIHtcbiAgICAvLyBpZiBiaW5vcCBpcyBzaG91bGQgYmUgdXNlZC4uLlxuICAgIGlmIChpc05hTih0aGlzLmZyZXF1ZW5jeSkpIHtcbiAgICAgIC8vIGFuZCBpZiB3ZSBhcmUgYXNzaWduaW5nIGJpbm9wIGZvciB0aGUgZmlyc3QgdGltZS4uLlxuICAgICAgbGV0IG9iaiA9IEdpYmJlcmlzaC5wcm9jZXNzb3IudWdlbnMuZ2V0KHRoaXMuZnJlcXVlbmN5LmlkKTtcbiAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgSW5jb3JyZWN0IG5vdGUgJHt0aGlzLmZyZXF1ZW5jeX0gYXNzaWduZWQgdG8gJHt0aGlzLnVnZW5OYW1lfTsgdGhpcyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouaXNvcCAhPT0gdHJ1ZSkge1xuICAgICAgICBvYmouaW5wdXRzWzBdID0gZnJlcTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5pbnB1dHNbMV0gPSBmcmVxO1xuICAgICAgICBHaWJiZXJpc2guZGlydHkodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyZXF1ZW5jeSA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmVxdWVuY3kgPSBmcmVxO1xuICAgIH1cblxuICAgIGlmIChsb3VkbmVzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fX3RyaWdnZXJMb3VkbmVzcyA9IGxvdWRuZXNzO1xuICAgIH1cblxuICAgIHRoaXMuZW52LnRyaWdnZXIoKTtcbiAgfSxcblxuICB0cmlnZ2VyKGxvdWRuZXNzID0gMSkge1xuICAgIGlmIChpc05hTihsb3VkbmVzcykpIHtcbiAgICAgIHRocm93IEVycm9yKGBBIG5vbi1udW1iZXIgd2FzIHBhc3NlZCB0byB0cmlnZ2VyKCkgb24gJHt0aGlzLnVnZW5OYW1lfTsgdGhpcyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBlbnZlbG9wZSB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX190cmlnZ2VyTG91ZG5lc3MgPSBsb3VkbmVzcztcbiAgICAgIHRoaXMuZW52LnRyaWdnZXIoKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdHJ1bWVudFxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG5jb25zdCBpbnN0cnVtZW50cyA9IHtcbiAgS2ljayAgICAgICAgOiByZXF1aXJlKCAnLi9raWNrLmpzJyApKCBHaWJiZXJpc2ggKSxcbiAgQ2xhdmUgICAgICAgOiByZXF1aXJlKCAnLi9jb25nYS5qcycgKSggR2liYmVyaXNoIClbMF0sIC8vIGNsYXZlIGlzIHNhbWUgYXMgY29uZ2Egd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHMsIHNlZSBiZWxvd1xuICBIYXQgICAgICAgICA6IHJlcXVpcmUoICcuL2hhdC5qcycgKSggR2liYmVyaXNoICksXG4gIFNuYXJlICAgICAgIDogcmVxdWlyZSggJy4vc25hcmUuanMnICkoIEdpYmJlcmlzaCApLFxuICBDb3diZWxsICAgICA6IHJlcXVpcmUoICcuL2Nvd2JlbGwuanMnICkoIEdpYmJlcmlzaCApLFxuICBUb20gICAgICAgICA6IHJlcXVpcmUoICcuL3RvbS5qcycgKSggR2liYmVyaXNoICksXG4gIENsYXAgICAgICAgIDogcmVxdWlyZSggJy4vY2xhcC5kc3AuanMnICkoIEdpYmJlcmlzaCApLFxuICBNdWx0aXNhbXBsZXI6IHJlcXVpcmUoICcuL211bHRpc2FtcGxlci5kc3AuanMnICkoIEdpYmJlcmlzaCApLFxuICBTb3VuZGZvbnQgICA6IHJlcXVpcmUoICcuL3NvdW5kZm9udC5qcycgKSggR2liYmVyaXNoIClcbn1cblxuaW5zdHJ1bWVudHMuQ2xhdmUuZGVmYXVsdHMuZnJlcXVlbmN5ID0gMjUwMFxuaW5zdHJ1bWVudHMuQ2xhdmUuZGVmYXVsdHMuZGVjYXkgPSAuNTtcblxuWyBpbnN0cnVtZW50cy5TeW50aCwgaW5zdHJ1bWVudHMuUG9seVN5bnRoIF0gICAgID0gcmVxdWlyZSggJy4vc3ludGguZHNwLmpzJyApKCBHaWJiZXJpc2ggKTtcblsgaW5zdHJ1bWVudHMuQ29tcGxleCwgaW5zdHJ1bWVudHMuUG9seUNvbXBsZXhdICA9IHJlcXVpcmUoICcuL2NvbXBsZXguZHNwLmpzJyApKCBHaWJiZXJpc2ggKTtcblsgaW5zdHJ1bWVudHMuTW9ub3N5bnRoLCBpbnN0cnVtZW50cy5Qb2x5TW9ubyBdICA9IHJlcXVpcmUoICcuL21vbm9zeW50aC5kc3AuanMnICkoIEdpYmJlcmlzaCApO1xuWyBpbnN0cnVtZW50cy5GTSwgaW5zdHJ1bWVudHMuUG9seUZNIF0gICAgICAgICAgID0gcmVxdWlyZSggJy4vZm0uZHNwLmpzJyApKCBHaWJiZXJpc2ggKTtcblsgaW5zdHJ1bWVudHMuU2FtcGxlciwgaW5zdHJ1bWVudHMuUG9seVNhbXBsZXIgXSA9IHJlcXVpcmUoICcuL3NhbXBsZXIuanMnICkoIEdpYmJlcmlzaCApO1xuWyBpbnN0cnVtZW50cy5LYXJwbHVzLCBpbnN0cnVtZW50cy5Qb2x5S2FycGx1cyBdID0gcmVxdWlyZSggJy4va2FycGx1c3N0cm9uZy5qcycgKSggR2liYmVyaXNoICk7XG5bIGluc3RydW1lbnRzLkNvbmdhLCBpbnN0cnVtZW50cy5Qb2x5Q29uZ2EgXSAgICAgPSByZXF1aXJlKCAnLi9jb25nYS5qcycgKSggR2liYmVyaXNoIClcblxuaW5zdHJ1bWVudHMuZXhwb3J0ID0gdGFyZ2V0ID0+IHtcbiAgZm9yKCBsZXQga2V5IGluIGluc3RydW1lbnRzICkge1xuICAgIGlmKCBrZXkgIT09ICdleHBvcnQnICkge1xuICAgICAgdGFyZ2V0WyBrZXkgXSA9IGluc3RydW1lbnRzWyBrZXkgXVxuICAgIH1cbiAgfVxufVxuXG5yZXR1cm4gaW5zdHJ1bWVudHNcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgS2FycGx1cyA9IGlucHV0UHJvcHMgPT4ge1xuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgS2FycGx1cy5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgbGV0IHN5biA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuICAgIFxuICAgIGxldCBzYW1wbGVSYXRlID0gR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIFxuXG4gICAgY29uc3QgdHJpZ2dlciA9IGcuYmFuZygpLFxuICAgICAgICAgIC8vIGhpZ2ggaW5pdGlhbFZhbHVlIHN0b3BzIHRyaWdnZXJpbmcgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICBwaGFzZSA9IGcuYWNjdW0oIDEsIHRyaWdnZXIsIHsgc2hvdWxkV3JhcE1heDpmYWxzZSwgaW5pdGlhbFZhbHVlOjEwMDAwMDAgfSApLFxuICAgICAgICAgIGVudiA9IGcuZ3RwKCBnLnN1YiggMSwgZy5kaXYoIHBoYXNlLCAyMDAgKSApLCAwICksXG4gICAgICAgICAgaW1wdWxzZSA9IGcubXVsKCBnLm5vaXNlKCksIGVudiApLFxuICAgICAgICAgIGZlZWRiYWNrID0gZy5oaXN0b3J5KCksXG4gICAgICAgICAgZnJlcXVlbmN5ID0gZy5pbignZnJlcXVlbmN5JyksXG4gICAgICAgICAgZ2xpZGUgPSBnLm1heCggMSwgZy5pbiggJ2dsaWRlJyApICksXG4gICAgICAgICAgc2xpZGluZ0ZyZXF1ZW5jeSA9IGcuc2xpZGUoIGZyZXF1ZW5jeSwgZ2xpZGUsIGdsaWRlICksXG4gICAgICAgICAgZGVsYXkgPSBnLmRlbGF5KCBnLmFkZCggaW1wdWxzZSwgZmVlZGJhY2sub3V0ICksIGcuZGl2KCBzYW1wbGVSYXRlLCBzbGlkaW5nRnJlcXVlbmN5ICkpLFxuICAgICAgICAgIGRlY2F5ZWQgPSBnLm11bCggZGVsYXksIGcudDYwKCBnLm11bCggZy5pbignZGVjYXknKSwgc2xpZGluZ0ZyZXF1ZW5jeSApICkgKSxcbiAgICAgICAgICBkYW1wZWQgPSAgZy5taXgoIGRlY2F5ZWQsIGZlZWRiYWNrLm91dCwgZy5pbignZGFtcGluZycpICksXG4gICAgICAgICAgbiA9IGcubm9pc2UoKSxcbiAgICAgICAgICBibGVuZFZhbHVlID0gZy5zd2l0Y2goIGcuZ3QoIG4sIGcuaW4oJ2JsZW5kJykgKSwgLTEsIDEgKSwgXG4gICAgICAgICAgd2l0aEdhaW4gPSBnLm11bCggZy5tdWwoIGJsZW5kVmFsdWUsIGRhbXBlZCApLCBnLm11bCggZy5tdWwoIGcuaW4oJ2xvdWRuZXNzJyksIGcuaW4oJ19fdHJpZ2dlckxvdWRuZXNzJykgKSwgZyAuaW4oJ2dhaW4nKSApIClcblxuICAgIGZlZWRiYWNrLmluKCBkYW1wZWQgKVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBLYXJwbHVzLmRlZmF1bHRzLCBwcm9wcyApXG5cbiAgICBPYmplY3QuYXNzaWduKCBzeW4sIHtcbiAgICAgIHByb3BlcnRpZXMgOiBwcm9wcyxcblxuICAgICAgZW52IDogdHJpZ2dlcixcbiAgICAgIHBoYXNlLFxuXG4gICAgICBnZXRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgcGhhc2UubWVtb3J5LnZhbHVlLmlkeCBdXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpZiggcHJvcGVydGllcy5wYW5Wb2ljZXMgKSB7ICBcbiAgICAgIGNvbnN0IHBhbm5lciA9IGcucGFuKCB3aXRoR2Fpbiwgd2l0aEdhaW4sIGcuaW4oICdwYW4nICkgKVxuICAgICAgc3luID0gR2liYmVyaXNoLmZhY3RvcnkoIHN5biwgW3Bhbm5lci5sZWZ0LCBwYW5uZXIucmlnaHRdLCBbJ2luc3RydW1lbnRzJywna2FycGx1cyddLCBwcm9wcyAgKVxuICAgICAgc3luLmlzU3RlcmVvID0gdHJ1ZVxuICAgIH1lbHNle1xuICAgICAgc3luID0gR2liYmVyaXNoLmZhY3RvcnkoIHN5biwgd2l0aEdhaW4sIFsnaW5zdHJ1bWVudHMnLCdrYXJwbHVzJ10sIHByb3BzIClcbiAgICAgIHN5bi5pc1N0ZXJlbyA9IGZhbHNlIFxuICAgIH1cblxuICAgIHJldHVybiBzeW5cbiAgfVxuICBcbiAgS2FycGx1cy5kZWZhdWx0cyA9IHtcbiAgICBkZWNheTogLjk3LFxuICAgIGRhbXBpbmc6LjIsXG4gICAgZ2FpbjogLjE1LFxuICAgIGZyZXF1ZW5jeToyMjAsXG4gICAgcGFuOiAuNSxcbiAgICBnbGlkZToxLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjEsXG4gICAgYmxlbmQ6MVxuICB9XG5cbiAgbGV0IGVudkNoZWNrRmFjdG9yeSA9ICggc3luLHN5bnRoICkgPT4ge1xuICAgIGxldCBlbnZDaGVjayA9ICgpPT4ge1xuICAgICAgbGV0IHBoYXNlID0gc3luLmdldFBoYXNlKCksXG4gICAgICAgICAgZW5kVGltZSA9IHN5bnRoLmRlY2F5ICogc2FtcGxlUmF0ZVxuXG4gICAgICBpZiggcGhhc2UgPiBlbmRUaW1lICkge1xuICAgICAgICBzeW50aC5kaXNjb25uZWN0VWdlbiggc3luIClcbiAgICAgICAgc3luLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBzeW4ucGhhc2UubWVtb3J5LnZhbHVlLmlkeCBdID0gMCAvLyB0cmlnZ2VyIGRvZXNuJ3Qgc2VlbSB0byByZXNldCBmb3Igc29tZSByZWFzb25cbiAgICAgIH1lbHNle1xuICAgICAgICBHaWJiZXJpc2guYmxvY2tDYWxsYmFja3MucHVzaCggZW52Q2hlY2sgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52Q2hlY2tcbiAgfVxuXG4gIGNvbnN0IFBvbHlLYXJwbHVzID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggS2FycGx1cywgWydmcmVxdWVuY3knLCdkZWNheScsJ2RhbXBpbmcnLCdwYW4nLCdnYWluJywgJ2dsaWRlJywnbG91ZG5lc3MnLCAnX190cmlnZ2VyTG91ZG5lc3MnXSwgZW52Q2hlY2tGYWN0b3J5ICkgXG4gIFBvbHlLYXJwbHVzLmRlZmF1bHRzID0gS2FycGx1cy5kZWZhdWx0c1xuXG4gIHJldHVybiBbIEthcnBsdXMsIFBvbHlLYXJwbHVzIF1cblxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBLaWNrID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgLy8gZXN0YWJsaXNoIHByb3RvdHlwZSBjaGFpblxuICAgIGNvbnN0IGtpY2sgPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcblxuICAgIC8vIGRlZmluZSBpbnB1dHNcbiAgICBjb25zdCBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIHRvbmUgID0gZy5pbiggJ3RvbmUnICksXG4gICAgICAgICAgZ2FpbiAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgTG91ZG5lc3MgPSBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApXG4gICAgXG4gICAgLy8gY3JlYXRlIGluaXRpYWwgcHJvcGVydHkgc2V0XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgS2ljay5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgT2JqZWN0LmFzc2lnbigga2ljaywgcHJvcHMgKVxuXG4gICAgLy8gY3JlYXRlIERTUCBncmFwaFxuICAgIGNvbnN0IHRyaWdnZXIgPSBnLmJhbmcoKSxcbiAgICAgICAgICBpbXB1bHNlID0gZy5tdWwoIHRyaWdnZXIsIDYwICksXG4gICAgICAgICAgc2NhbGVkRGVjYXkgPSBnLnN1YiggMS4wMDUsIGRlY2F5ICksIC8vIC0+IHJhbmdlIHsgLjAwNSwgMS4wMDUgfVxuICAgICAgICAgIHNjYWxlZFRvbmUgPSBnLmFkZCggNTAsIGcubXVsKCB0b25lLCBnLm11bCg0MDAwLCBMb3VkbmVzcyApICkgKSwgLy8gLT4gcmFuZ2UgeyA1MCwgNDA1MCB9XG4gICAgICAgICAgYnBmID0gZy5zdmYoIGltcHVsc2UsIGZyZXF1ZW5jeSwgc2NhbGVkRGVjYXksIDIsIGZhbHNlICksXG4gICAgICAgICAgbHBmID0gZy5zdmYoIGJwZiwgc2NhbGVkVG9uZSwgLjUsIDAsIGZhbHNlICksXG4gICAgICAgICAgZ3JhcGggPSBnLm11bCggbHBmLCBnLm11bCggZ2FpbiwgTG91ZG5lc3MgKSApXG4gICAgXG4gICAga2ljay5lbnYgPSB0cmlnZ2VyXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIGtpY2ssIGdyYXBoLCBbJ2luc3RydW1lbnRzJywna2ljayddLCBwcm9wcyAgKVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIFxuICBLaWNrLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgZnJlcXVlbmN5Ojg1LFxuICAgIHRvbmU6IC4yNSxcbiAgICBkZWNheTouOSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcbiAgfVxuXG4gIHJldHVybiBLaWNrXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnICksXG4gICAgICBmZWVkYmFja09zYyA9IHJlcXVpcmUoICcuLi9vc2NpbGxhdG9ycy9mbWZlZWRiYWNrb3NjLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBNb25vID0gYXJndW1lbnRQcm9wcyA9PiB7XG4gICAgY29uc3Qgc3luID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApLFxuICAgICAgICAgIG9zY3MgPSBbXSwgXG4gICAgICAgICAgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBnbGlkZSA9IGcubWF4KCAxLCBnLmluKCAnZ2xpZGUnICkgKSxcbiAgICAgICAgICBzbGlkaW5nRnJlcSA9IGcubWVtbyggZy5zbGlkZSggZnJlcXVlbmN5LCBnbGlkZSwgZ2xpZGUgKSApLFxuICAgICAgICAgIGF0dGFjayA9IGcuaW4oICdhdHRhY2snICksIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIHN1c3RhaW4gPSBnLmluKCAnc3VzdGFpbicgKSwgc3VzdGFpbkxldmVsID0gZy5pbiggJ3N1c3RhaW5MZXZlbCcgKSxcbiAgICAgICAgICByZWxlYXNlID0gZy5pbiggJ3JlbGVhc2UnICksXG4gICAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApLFxuICAgICAgICAgIExvdWRuZXNzID0gZy5tdWwoIGxvdWRuZXNzLCB0cmlnZ2VyTG91ZG5lc3MgKSxcbiAgICAgICAgICBzYXR1cmF0aW9uID0gZy5pbiggJ3NhdHVyYXRpb24nIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIE1vbm8uZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwgcHJvcHMgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGVudiA9IEdpYmJlcmlzaC5lbnZlbG9wZXMuZmFjdG9yeSggXG4gICAgICAgIHByb3BzLnVzZUFEU1IsIFxuICAgICAgICBwcm9wcy5zaGFwZSwgXG4gICAgICAgIGF0dGFjaywgZGVjYXksIFxuICAgICAgICBzdXN0YWluLCBzdXN0YWluTGV2ZWwsIFxuICAgICAgICByZWxlYXNlLCBcbiAgICAgICAgcHJvcHMudHJpZ2dlclJlbGVhc2VcbiAgICAgIClcblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCAzOyBpKysgKSB7XG4gICAgICAgIGxldCBvc2MsIGZyZXFcblxuICAgICAgICBzd2l0Y2goIGkgKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZnJlcSA9IGcuYWRkKCBzbGlkaW5nRnJlcSwgZy5tdWwoIHNsaWRpbmdGcmVxLCBnLmluKCdkZXR1bmUyJykgKSApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBmcmVxID0gZy5hZGQoIHNsaWRpbmdGcmVxLCBnLm11bCggc2xpZGluZ0ZyZXEsIGcuaW4oJ2RldHVuZTMnKSApIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBmcmVxID0gc2xpZGluZ0ZyZXFcbiAgICAgICAgfVxuXG4gICAgICAgIG9zYyA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCBzeW4ud2F2ZWZvcm0sIGZyZXEsIHN5bi5hbnRpYWxpYXMgKVxuICAgICAgICBcbiAgICAgICAgb3Njc1sgaSBdID0gb3NjXG4gICAgICB9XG5cblxuICAgICAgLy9jb25zdCBiYXNlQ3V0b2ZmRnJlcSA9IGcuaW4oJ2N1dG9mZicpICogKGZyZXF1ZW5jeSAvICAoZy5nZW4uc2FtcGxlcmF0ZSAvIDE2ICkpXG4gICAgICAvL2NvbnN0IGN1dG9mZiA9IGJhc2VDdXRvZmZGcmVxICogZy5wb3coIDIsIGcuaW4oJ2ZpbHRlck11bHQnKSAqIGxvdWRuZXNzICkgKiBlbnYgXG4gICAgICBjb25zdCBvc2NTdW0gPSBnLmFkZCggLi4ub3NjcyApLFxuICAgICAgICAgICAgLy8gWFhYIGhvcnJpYmxlIGhhY2sgYmVsb3cgdG8gXCJ1c2VcIiBzYXR1cmF0aW9uIGV2ZW4gd2hlbiBub3QgdXNpbmcgYSBkaW9kZSBmaWx0ZXIgXG4gICAgICAgICAgICBvc2NXaXRoRW52ID0gcHJvcHMuZmlsdGVyTW9kZWw9PT0gMiA/IGcubXVsKCBvc2NTdW0sIGVudiApIDogZy5zdWIoIGcuYWRkKCBnLm11bCggb3NjU3VtLCBlbnYpLCBzYXR1cmF0aW9uICksIHNhdHVyYXRpb24gKSxcbiAgICAgICAgICAgIGJhc2VDdXRvZmZGcmVxID0gZy5tdWwoIGcuaW4oJ2N1dG9mZicpLCBnLmRpdiggZnJlcXVlbmN5LCBnLmdlbi5zYW1wbGVyYXRlIC8gMTYgKSApLFxuICAgICAgICAgICAgY3V0b2ZmID0gZy5tdWwoIGcubXVsKCBiYXNlQ3V0b2ZmRnJlcSwgZy5wb3coIDIsIGcubXVsKCBnLmluKCdmaWx0ZXJNdWx0JyksIExvdWRuZXNzICkgKSksIGVudiApLFxuICAgICAgICAgICAgZmlsdGVyZWRPc2MgPSBHaWJiZXJpc2guZmlsdGVycy5mYWN0b3J5KCBvc2NXaXRoRW52LCBjdXRvZmYsIGcuaW4oJ3NhdHVyYXRpb24nKSwgc3luIClcbiAgICAgICAgXG4gICAgICBpZiggcHJvcHMucGFuVm9pY2VzICkgeyAgXG4gICAgICAgIGNvbnN0IHBhbm5lciA9IGcucGFuKCBmaWx0ZXJlZE9zYyxmaWx0ZXJlZE9zYywgZy5pbiggJ3BhbicgKSApXG4gICAgICAgIHN5bi5ncmFwaCA9IFsgZy5tdWwoIHBhbm5lci5sZWZ0LCBnLmluKCdnYWluJyksIExvdWRuZXNzICksIGcubXVsKCBwYW5uZXIucmlnaHQsIGcuaW4oJ2dhaW4nKSwgTG91ZG5lc3MgKSBdXG4gICAgICAgIHN5bi5pc1N0ZXJlbyA9IHRydWVcbiAgICAgIH1lbHNle1xuICAgICAgICBzeW4uZ3JhcGggPSBnLm11bCggZmlsdGVyZWRPc2MsIGcuaW4oJ2dhaW4nKSwgTG91ZG5lc3MgKVxuICAgICAgICBzeW4uaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBzeW4uZW52ID0gZW52XG4gICAgfVxuXG4gICAgc3luLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnd2F2ZWZvcm0nLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywgJ2ZpbHRlck1vZGUnIF1cbiAgICBzeW4uX19jcmVhdGVHcmFwaCgpXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggc3luLCBzeW4uZ3JhcGgsIFsnaW5zdHJ1bWVudHMnLCdNb25vc3ludGgnXSwgcHJvcHMgKVxuXG4gICAgcmV0dXJuIG91dFxuICB9IFxuICBcbiAgTW9uby5kZWZhdWx0cyA9IHtcbiAgICB3YXZlZm9ybTogJ3NhdycsXG4gICAgYXR0YWNrOiA0NCxcbiAgICBkZWNheTogMjIwNTAsXG4gICAgc3VzdGFpbjo0NDEwMCxcbiAgICBzdXN0YWluTGV2ZWw6LjYsXG4gICAgcmVsZWFzZToyMjA1MCxcbiAgICB1c2VBRFNSOmZhbHNlLFxuICAgIHNoYXBlOidsaW5lYXInLFxuICAgIHRyaWdnZXJSZWxlYXNlOmZhbHNlLFxuICAgIGdhaW46IC4yNSxcbiAgICBwdWxzZXdpZHRoOi4yNSxcbiAgICBmcmVxdWVuY3k6MjIwLFxuICAgIHBhbjogLjUsXG4gICAgZGV0dW5lMjouMDA1LFxuICAgIGRldHVuZTM6LS4wMDUsXG4gICAgY3V0b2ZmOiAuNSxcbiAgICBROiAuMjUsXG4gICAgcGFuVm9pY2VzOmZhbHNlLFxuICAgIGdsaWRlOiAxLFxuICAgIGFudGlhbGlhczpmYWxzZSxcbiAgICAvL2ZpbHRlclR5cGU6IDEsXG4gICAgZmlsdGVyTW9kZWw6IDEsXG4gICAgZmlsdGVyTW9kZTogMCwgLy8gMCA9IExQLCAxID0gSFAsIDIgPSBCUCwgMyA9IE5vdGNoXG4gICAgc2F0dXJhdGlvbjouNSxcbiAgICBmaWx0ZXJNdWx0OiAyLFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgbGV0IFBvbHlNb25vID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggTW9ubywgXG4gICAgWyAnZnJlcXVlbmN5JywnYXR0YWNrJywnZGVjYXknLCdjdXRvZmYnLCdRJyxcbiAgICAgICdkZXR1bmUyJywnZGV0dW5lMycsJ3B1bHNld2lkdGgnLCdwYW4nLCdnYWluJywgXG4gICAgICAnZ2xpZGUnLCAnc2F0dXJhdGlvbicsICdmaWx0ZXJNdWx0JywgICdhbnRpYWxpYXMnLCBcbiAgICAgICdmaWx0ZXJNb2RlbCcsICd3YXZlZm9ybScsICdmaWx0ZXJNb2RlJywgJ2xvdWRuZXNzJywgJ19fdHJpZ2dlckxvdWRuZXNzJyBdXG4gICkgXG4gIFBvbHlNb25vLmRlZmF1bHRzID0gTW9uby5kZWZhdWx0c1xuXG4gIHJldHVybiBbIE1vbm8sIFBvbHlNb25vIF1cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApXG4gIGNvbnN0IG1lbW8gPSB7fVxuICBcbiAgT2JqZWN0LmFzc2lnbiggcHJvdG8sIHtcbiAgICBwaWNrRmlsZSggc2FtcGxlICkge1xuICAgICAgdGhpcy5jdXJyZW50U2FtcGxlID0gc2FtcGxlXG4gICAgfSxcbiAgICBwaWNrKCBfX2lkeCApIHtcbiAgICAgIGNvbnN0IGlkeCA9IE1hdGguZmxvb3IoIF9faWR4IClcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggdGhpcy5zYW1wbGVycyApXG4gICAgICBjb25zdCBrZXkgPSBrZXlzWyBpZHggXVxuICAgICAgdGhpcy5jdXJyZW50U2FtcGxlID0ga2V5XG4gICAgfSxcbiAgICBwaWNrcGxheSggX19pZHggKSB7XG4gICAgICBjb25zdCBpZHggPSBNYXRoLmZsb29yKCBfX2lkeCApXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuc2FtcGxlcnMgKVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1sgaWR4IF1cbiAgICAgIHRoaXMuY3VycmVudFNhbXBsZSA9IGtleVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcigpXG4gICAgfSxcbiAgICBub3RlKCByYXRlICkge1xuICAgICAgLy90aGlzLnJhdGUgPSByYXRlXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCBudWxsLCByYXRlIClcbiAgICB9LFxuICAgIHNldHBhbiggbnVtPTAsIHZhbHVlPS41ICkge1xuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgY29uc3Qgdm9pY2UgPSB0aGlzLnZvaWNlc1sgbnVtIF1cbiAgICAgICAgLy8gc2V0IHZvaWNlIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgLy9nLmdlbi5tZW1vcnkuaGVhcC5zZXQoIFsgdmFsdWUgXSwgdm9pY2UucGFuLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgICAgdm9pY2UucGFuID0gdmFsdWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHJhdGUoIG51bT0wLCB2YWx1ZT0xICkge1xuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgY29uc3Qgdm9pY2UgPSB0aGlzLnZvaWNlc1sgbnVtIF1cbiAgICAgICAgLy8gc2V0IHZvaWNlIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgLy9nLmdlbi5tZW1vcnkuaGVhcC5zZXQoIFsgdmFsdWUgXSwgdm9pY2UucmF0ZS5tZW1vcnkudmFsdWVzLmlkeCApXG4gICAgICAgIHZvaWNlLnJhdGUgPSB2YWx1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlciggdm9sdW1lPW51bGwsIHJhdGU9bnVsbCApIHtcbiAgICAgICdubyBqc2RzcCdcbiAgICAgIGlmKCB2b2x1bWUgIT09IG51bGwgKSB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzID0gdm9sdW1lXG5cbiAgICAgIGxldCB2b2ljZSA9IG51bGxcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSB0aGlzLnNhbXBsZXJzWyB0aGlzLmN1cnJlbnRTYW1wbGUgXVxuXG4gICAgICAgIC8vIGlmIHNhbXBsZSBpc24ndCBsb2FkZWQuLi5cbiAgICAgICAgaWYoIHNhbXBsZXIgPT09IHVuZGVmaW5lZCApIHJldHVyblxuXG4gICAgICAgIHZvaWNlID0gdGhpcy5fX2dldFZvaWNlX18oKVxuXG4gICAgICAgIC8vIHNldCB2b2ljZSBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5idWZmZXJMZW5ndGgubWVtb3J5LnZhbHVlcy5pZHggXSA9IHNhbXBsZXIuZGF0YUxlbmd0aFxuXG4gICAgICAgIC8vIHNldCB2b2ljZSBkYXRhIGluZGV4XG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5idWZmZXJMb2MubWVtb3J5LnZhbHVlcy5pZHggXSA9IHNhbXBsZXIuZGF0YUlkeFxuXG4gICAgICAgIC8vaWYoIHJhdGUgIT09IG51bGwgKSBnLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UucmF0ZS5tZW1vcnkudmFsdWVzLmlkeCBdID0gcmF0ZVxuICAgICAgICBpZiggcmF0ZSAhPT0gbnVsbCApIHZvaWNlLnJhdGUgPSByYXRlXG4gICAgICAgIGlmKCByYXRlID4gMCApIHtcbiAgICAgICAgICB2b2ljZS50cmlnZ2VyKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3JldmVyc2U/JywgcmF0ZSApXG4gICAgICAgICAgdm9pY2UuYmFuZy50cmlnZ2VyKClcbiAgICAgICAgICAvL3ZvaWNlLnBoYXNlLnZhbHVlID0gMFxuICAgICAgICAgIHZvaWNlLnBoYXNlLnZhbHVlID0gc2FtcGxlci5kYXRhTGVuZ3RoIC0gMVxuICAgICAgICAgIC8vY29uc29sZS5sb2coICdwaGFzZScsIHZvaWNlLnBoYXNlLnZhbHVlIClcbiAgICAgICAgfVxuICAgICAgICAvL2lmKCByYXRlIDwgMCApIHtcbiAgICAgICAgLy8gIGNvbnN0IHBoYXNlID0gc2FtcGxlci5kYXRhSWR4ICsgTWF0aC5yb3VuZCgoc2FtcGxlci5kYXRhTGVuZ3RoLzIpKSAtIDFcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKCAncGhhc2U6JywgcGhhc2UsICdsZW5ndGg6Jywgc2FtcGxlci5kYXRhTGVuZ3RoLCAnc3RhcnQ6Jywgc2FtcGxlci5kYXRhSWR4IClcbiAgICAgICAgLy8gIC8vdm9pY2UucGhhc2UudmFsdWUgPSBwaGFzZVxuICAgICAgICAvLyAgLy9nLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UucGhhc2UubWVtb3J5LnZhbHVlLmlkeCBdID0gcGhhc2VcbiAgICAgICAgLy99ZWxzZXtcbiAgICAgICAgLy8gIC8vIHdpbGwgcmVzZXQgcGhhc2UgdG8gMFxuICAgICAgICAvLyAgdm9pY2UudHJpZ2dlcigpXG4gICAgICAgIC8vfVxuICAgICAgICBcbiAgICAgICAgLy92b2ljZS50cmlnZ2VyKClcbiAgICAgICAgLy9nLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UucmF0ZS5tZW1vcnkudmFsdWVzLmlkeCBdID0gcmF0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdm9pY2VcbiAgICB9LFxuICAgIF9fZ2V0Vm9pY2VfXygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZvaWNlc1sgdGhpcy52b2ljZUNvdW50KysgJSB0aGlzLnZvaWNlcy5sZW5ndGggXVxuICAgIH0sXG4gIH0pXG5cbiAgY29uc3QgU2FtcGxlciA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHN5biA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBvbmxvYWQ6bnVsbCwgdm9pY2VDb3VudDowLCBmaWxlczpbXSB9LCBTYW1wbGVyLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcblxuICAgIHN5bi5pc1N0ZXJlbyA9IHByb3BzLmlzU3RlcmVvICE9PSB1bmRlZmluZWQgPyBwcm9wcy5pc1N0ZXJlbyA6IGZhbHNlXG5cbiAgICBjb25zdCBzdGFydCA9IGcuaW4oICdzdGFydCcgKSwgZW5kID0gZy5pbiggJ2VuZCcgKSwgXG4gICAgICAgICAgcmF0ZSA9IGcuaW4oICdyYXRlJyApLCBzaG91bGRMb29wID0gZy5pbiggJ2xvb3BzJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICAvLyByYXRlIHN0b3JhZ2UgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSdyZSBwbGF5aW5nXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBmb3J3YXJkIG9yIGluIHJldmVyc2UsIGZvciB1c2UgaW4gdGhlICd0cmlnZ2VyJyBtZXRob2QuXG4gICAgICAgICAgcmF0ZVN0b3JhZ2UgPSBnLmRhdGEoWzBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIHN5bi5fX21ldGFfXyA9IHtcbiAgICAgICAgYWRkcmVzczonYWRkJyxcbiAgICAgICAgbmFtZTogWydpbnN0cnVtZW50cycsICdNdWx0aXNhbXBsZXInXSxcbiAgICAgICAgcHJvcGVydGllczogSlNPTi5zdHJpbmdpZnkocHJvcHMpLCBcbiAgICAgICAgaWQ6IHN5bi5pZFxuICAgICAgfVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5zZXQoIHN5bi5pZCwgc3luIClcblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSggc3luLl9fbWV0YV9fIClcbiAgICB9XG5cbiAgICBjb25zdCB2b2ljZXMgPSBbXVxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgc3luLm1heFZvaWNlczsgaSsrICkge1xuICAgICAgJ3VzZSBqc2RzcCdcblxuICAgICAgY29uc3Qgdm9pY2UgPSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aDogZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBidWZmZXJMb2M6ICAgIGcuZGF0YSggWzFdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgYmFuZzogZy5iYW5nKCksXG4gICAgICAgIC8vIFhYWCBob3cgZG8gSSBjaGFuZ2UgdGhpcyBmcm9tIG1haW4gdGhyZWFkP1xuICAgICAgICBfX3BhbjogZy5kYXRhKCBbLjVdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgX19yYXRlOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fc2hvdWxkTG9vcDogZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX2xvdWRuZXNzOiAgZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBnZXQgbG91ZG5lc3MoKSB7IFxuICAgICAgICAgIHJldHVybiBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX2xvdWRuZXNzLm1lbW9yeS52YWx1ZXMuaWR4ICAgXVxuICAgICAgICB9LFxuICAgICAgICBzZXQgbG91ZG5lc3MoIHYgKSB7XG4gICAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHRoaXMuX19sb3VkbmVzcy5tZW1vcnkudmFsdWVzLmlkeCBdID0gdlxuICAgICAgICB9LFxuICAgICAgICBzZXQgcGFuKHYpIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX3Bhbi5tZW1vcnkudmFsdWVzLmlkeCBdID0gdlxuICAgICAgICB9LFxuICAgICAgICBzZXQgcmF0ZSh2KSB7XG4gICAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHRoaXMuX19yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHZvaWNlLnBoYXNlID0gZy5jb3VudGVyKCBcbiAgICAgICAgcmF0ZSAqIHZvaWNlLl9fcmF0ZVswXSwgXG4gICAgICAgIHN0YXJ0ICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdLFxuICAgICAgICBlbmQgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0sIFxuICAgICAgICB2b2ljZS5iYW5nLFxuICAgICAgICBzaG91bGRMb29wLCBcbiAgICAgICAgeyBzaG91bGRXcmFwOmZhbHNlLCBpbml0aWFsVmFsdWU6OTk5OTk5OSB9XG4gICAgICApXG5cbiAgICAgIHZvaWNlLnRyaWdnZXIgPSB2b2ljZS5iYW5nLnRyaWdnZXJcblxuICAgICAgdm9pY2UuZ3JhcGggPSBnLmlmZWxzZShcbiAgICAgICAgLy8gaWYgcGhhc2UgaXMgZ3JlYXRlciB0aGFuIHN0YXJ0IGFuZCBsZXNzIHRoYW4gZW5kLi4uIFxuICAgICAgICBnLmFuZCggXG4gICAgICAgICAgZy5ndGUoIHZvaWNlLnBoYXNlLCBzdGFydCAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSApLCBcbiAgICAgICAgICBnLmx0KCAgdm9pY2UucGhhc2UsIGVuZCAgICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdICkgXG4gICAgICAgICksXG4gICAgICAgIC8vIC4uLnJlYWQgZGF0YVxuICAgICAgICB2b2ljZS5wZWVrID0gZy5wZWVrRHluKCBcbiAgICAgICAgICB2b2ljZS5idWZmZXJMb2NbMF0sIFxuICAgICAgICAgIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSxcbiAgICAgICAgICB2b2ljZS5waGFzZSxcbiAgICAgICAgICB7IG1vZGU6J3NhbXBsZXMnIH1cbiAgICAgICAgKSxcbiAgICAgICAgLy8gLi4uZWxzZSByZXR1cm4gMFxuICAgICAgICAwXG4gICAgICApIFxuICAgICAgKiBsb3VkbmVzcyBcbiAgICAgICogdm9pY2UuX19sb3VkbmVzc1swXSBcblxuICAgICAgY29uc3QgcGFuID0gZy5wYW4oIHZvaWNlLmdyYXBoLCB2b2ljZS5ncmFwaCwgdm9pY2UuX19wYW5bMF0gKVxuICAgICAgdm9pY2UuZ3JhcGggPSBbIHBhbi5sZWZ0LCBwYW4ucmlnaHQgXVxuXG4gICAgICB2b2ljZXMucHVzaCggdm9pY2UgKVxuICAgIH1cblxuICAgIC8vIGxvYWQgaW4gc2FtcGxlIGRhdGFcbiAgICBjb25zdCBzYW1wbGVycyA9IHt9XG5cbiAgICAvLyBib3VuZCB0byBpbmRpdmlkdWFsIHNhbXBsZXIgb2JqZWN0cyBpbiBsb2FkU2FtcGxlIGZ1bmN0aW9uXG4gICAgc3luLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiggYnVmZmVyLCBvbmxvYWQgKSB7XG4gICAgICAvLyBtYWluIHRocmVhZDogd2hlbiBzYW1wbGUgaXMgbG9hZGVkLCBjb3B5IGl0IG92ZXIgbWVzc2FnZSBwb3J0XG4gICAgICAvLyBwcm9jZXNzb3IgdGhyZWFkOiBvbmxvYWQgaXMgY2FsbGVkIHZpYSBtZXNzYWdlcG9ydCBoYW5kbGVyLCBhbmRcbiAgICAgIC8vIHBhc3NlZCBpbiB0aGUgbmV3IGJ1ZmZlciB0byBiZSBjb3BpZWQuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgY29uc3QgbWVtSWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggdGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGgsIHRydWUgKVxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFkZHJlc3M6J2NvcHlfbXVsdGknLFxuICAgICAgICAgIGlkOiAgICAgc3luLmlkLFxuICAgICAgICAgIGJ1ZmZlcjogdGhpcy5kYXRhLmJ1ZmZlcixcbiAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmKCB0eXBlb2Ygb25sb2FkID09PSAnZnVuY3Rpb24nICkgb25sb2FkKCB0aGlzLCBidWZmZXIgKVxuXG4gICAgICB9ZWxzZSBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICB0aGlzLmRhdGEuYnVmZmVyID0gYnVmZmVyIFxuXG4gICAgICAgIC8vIHNldCBkYXRhIG1lbW9yeSBzcGVjIGJlZm9yZSBpc3N1aW5nIG1lbW9yeSByZXF1ZXN0XG4gICAgICAgIHRoaXMuZGF0YUxlbmd0aCA9IHRoaXMuZGF0YS5tZW1vcnkudmFsdWVzLmxlbmd0aCA9IHRoaXMuZGF0YS5kaW0gPSB0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aFxuXG4gICAgICAgIC8vIHJlcXVlc3QgbWVtb3J5IHRvIGNvcHkgdGhlIGJ1ZmVyIG92ZXJcbiAgICAgICAgZy5nZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5kYXRhLm1lbW9yeSwgZmFsc2UgKVxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcC5zZXQoIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5tZW1vcnkudmFsdWVzLmlkeCApXG5cbiAgICAgICAgLy8gc2V0IGxvY2F0aW9uIG9mIGJ1ZmZlciAoZG9lcyBub3Qgd29yaylcbiAgICAgICAgdGhpcy5kYXRhSWR4ID0gdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMuaWR4XG5cbiAgICAgICAgc3luLmN1cnJlbnRTYW1wbGUgPSB0aGlzLmZpbGVuYW1lXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luLmxvYWRTYW1wbGUgPSBmdW5jdGlvbiggZmlsZW5hbWUsIF9fb25sb2FkLCBidWZmZXI9bnVsbCApIHtcbiAgICAgICd1c2UganNkc3AnXG5cbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1sgZmlsZW5hbWUgXSA9IHtcbiAgICAgICAgZGF0YUxlbmd0aDogbnVsbCxcbiAgICAgICAgZGF0YUlkeDogbnVsbCxcbiAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICBmaWxlbmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbmxvYWQgPSBzeW4ubG9hZEJ1ZmZlci5iaW5kKCBzYW1wbGVyICkgXG4gICAgICAvLyBwYXNzaW5nIGEgZmlsZW5hbWUgdG8gZGF0YSB3aWxsIGNhdXNlIGl0IHRvIGJlIGxvYWRlZCBpbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAgIC8vIG9ubG9hZCB3aWxsIHRoZW4gYmUgY2FsbGVkIHRvIHBhc3MgdGhlIGJ1ZmZlciBvdmVyIHRoZSBtZXNzYWdlcG9ydC4gSW4gdGhlXG4gICAgICAvLyBwcm9jZXNzb3IgdGhyZWFkLCBtYWtlIGEgcGxhY2Vob2xkZXIgdW50aWwgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgc2FtcGxlci5kYXRhID0gZy5kYXRhKCBidWZmZXIgIT09IG51bGwgPyBidWZmZXIgOiBmaWxlbmFtZSwgMSwgeyBvbmxvYWQgfSlcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkOyBhIHZhbGlkXG4gICAgICAgIC8vIGRhdGEgb2JqZWN0IGlzIG9ubHkgcmV0dXJuIGlmIHRoZSBmaWxlIGhhcyBiZWVuXG4gICAgICAgIC8vIHByZXZpb3VzbHkgbG9hZGVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBidWZmZXIgaGFzXG4gICAgICAgIC8vIGJlZW4gY2FjaGVkLlxuICAgICAgICBpZiggc2FtcGxlci5kYXRhIGluc3RhbmNlb2YgUHJvbWlzZSApIHtcbiAgICAgICAgICBzYW1wbGVyLmRhdGEudGhlbiggZCA9PiB7XG4gICAgICAgICAgICBzYW1wbGVyLmRhdGEgPSBkXG4gICAgICAgICAgICBtZW1vWyBmaWxlbmFtZSBdID0gc2FtcGxlci5kYXRhIFxuICAgICAgICAgICAgb25sb2FkKCBzYW1wbGVyLCBfX29ubG9hZCApXG4gICAgICAgICAgfSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gdXNpbmcgYSBjYWNoZWQgZGF0YSBidWZmZXIsIG5vIG5lZWRcbiAgICAgICAgICAvLyBmb3IgYXN5bmNocm9ub3VzIGxvYWRpbmcuXG4gICAgICAgICAgbWVtb1sgZmlsZW5hbWUgXSA9IHNhbXBsZXJcbiAgICAgICAgICBvbmxvYWQoIHNhbXBsZXIsIF9fb25sb2FkIClcbiAgICAgICAgfSAgICAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgc2FtcGxlci5kYXRhID0gZy5kYXRhKCBuZXcgRmxvYXQzMkFycmF5KCksIDEsIHsgb25sb2FkLCBmaWxlbmFtZSB9KVxuICAgICAgICBzYW1wbGVyLmRhdGEub25sb2FkID0gb25sb2FkXG4gICAgICB9IFxuICAgIH1cblxuICAgIHByb3BzLmZpbGVzLmZvckVhY2goIGZpbGVuYW1lID0+IHN5bi5sb2FkU2FtcGxlKCBmaWxlbmFtZSApIClcblxuICAgIHN5bi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICAndXNlIGpzZHNwJ1xuICAgICAgXG4gICAgICBjb25zdCBncmFwaHMgPSB2b2ljZXMubWFwKCB2b2ljZSA9PiB2b2ljZS5ncmFwaCApXG4gICAgICBjb25zdCBsZWZ0ID0gZy5hZGQoIC4uLnZvaWNlcy5tYXAoIHZvaWNlID0+IHZvaWNlLmdyYXBoWzBdICkgKVxuICAgICAgY29uc3QgcmlnaHQgPSBnLmFkZCggLi4udm9pY2VzLm1hcCggdm9pY2UgPT4gdm9pY2UuZ3JhcGhbMV0gKSApXG4gICAgICBjb25zdCBnYWluID0gZy5pbiggJ2dhaW4nIClcbiAgICAgIHN5bi5ncmFwaCA9IFsgbGVmdCAqIGdhaW4sIHJpZ2h0ICogZ2FpbiBdXG5cbiAgICAgIGlmKCBzeW4ucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgY29uc3QgcGFubmVyID0gZy5wYW4oIHN5bi5ncmFwaFswXSwgc3luLmdyYXBoWzFdLCBnLmluKCAncGFuJyApICkgXG4gICAgICAgIHN5bi5ncmFwaCA9IFsgcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgICAgc3luLFxuICAgICAgc3luLmdyYXBoLFxuICAgICAgWydpbnN0cnVtZW50cycsJ211bHRpc2FtcGxlciddLCBcbiAgICAgIHByb3BzIFxuICAgICkgXG5cbiAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gdHJ1ZVxuICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSBmYWxzZVxuXG4gICAgb3V0LnZvaWNlcyA9IHZvaWNlc1xuICAgIG91dC5zYW1wbGVycyA9IHNhbXBsZXJzXG5cbiAgICBHaWJiZXJpc2gucHJveHlFbmFibGVkID0gdHJ1ZVxuICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSBmYWxzZVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgU2FtcGxlci5kZWZhdWx0cyA9IHtcbiAgICBnYWluOiAxLFxuICAgIHBhbjogLjUsXG4gICAgcmF0ZTogMSxcbiAgICBwYW5Wb2ljZXM6ZmFsc2UsXG4gICAgc2hvdWxkTG9vcDpmYWxzZSxcbiAgICBsb29wczogMCxcbiAgICBzdGFydDowLFxuICAgIGVuZDoxLFxuICAgIGJ1ZmZlckxlbmd0aDotOTk5OTk5OTk5LFxuICAgIGxvdWRuZXNzOjEsXG4gICAgbWF4Vm9pY2VzOjUsIFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcbiAgfVxuXG4gIHJldHVybiBTYW1wbGVyXG59XG4iLCIvLyBYWFggVE9PIE1BTlkgR0xPQkFMIEdJQkJFUklTSCBWQUxVRVNcblxuY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJy4uL2luZGV4LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBub3RlKCBmcmVxICkge1xuICAgIC8vIHdpbGwgYmUgc2VudCB0byBwcm9jZXNzb3Igbm9kZSB2aWEgcHJveHkgbWV0aG9kLi4uXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlICE9PSAnd29ya2xldCcgKSB7XG4gICAgICBsZXQgdm9pY2UgPSB0aGlzLl9fZ2V0Vm9pY2VfXygpXG4gICAgICAvL09iamVjdC5hc3NpZ24oIHZvaWNlLCB0aGlzLnByb3BlcnRpZXMgKVxuICAgICAgLy9pZiggZ2FpbiA9PT0gdW5kZWZpbmVkICkgZ2FpbiA9IHRoaXMuZ2FpblxuICAgICAgLy92b2ljZS5nYWluID0gZ2FpblxuICAgICAgdm9pY2UuX190cmlnZ2VyTG91ZG5lc3MgPSB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzXG4gICAgICB2b2ljZS5ub3RlKCBmcmVxLCB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzIClcbiAgICAgIHRoaXMuX19ydW5Wb2ljZV9fKCB2b2ljZSwgdGhpcyApXG4gICAgICB0aGlzLnRyaWdnZXJOb3RlID0gZnJlcVxuICAgIH1cbiAgfSxcblxuICAvLyBYWFggdGhpcyBpcyBub3QgcGFydGljdWxhcmx5IHNhdGlzZnlpbmcuLi5cbiAgLy8gbXVzdCBjaGVjayBmb3IgYm90aCBub3RlcyBhbmQgY2hvcmRzXG4gIHRyaWdnZXIoIGxvdWRuZXNzICkge1xuICAgIGlmKCB0aGlzLnRyaWdnZXJDaG9yZCAhPT0gbnVsbCApIHtcbiAgICAgIHRoaXMudHJpZ2dlckNob3JkLmZvckVhY2goIHYgPT4ge1xuICAgICAgICBsZXQgdm9pY2UgPSB0aGlzLl9fZ2V0Vm9pY2VfXygpXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIHZvaWNlLCB0aGlzLnByb3BlcnRpZXMgKVxuICAgICAgICB2b2ljZS5ub3RlKCB2LCBsb3VkbmVzcyApXG4gICAgICAgIHRoaXMuX19ydW5Wb2ljZV9fKCB2b2ljZSwgdGhpcyApXG4gICAgICB9KVxuICAgIH1lbHNlIGlmKCB0aGlzLnRyaWdnZXJOb3RlICE9PSBudWxsICkge1xuICAgICAgbGV0IHZvaWNlID0gdGhpcy5fX2dldFZvaWNlX18oKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdm9pY2UsIHRoaXMucHJvcGVydGllcyApXG4gICAgICB2b2ljZS5ub3RlKCB0aGlzLnRyaWdnZXJOb3RlLCBsb3VkbmVzcyApXG4gICAgICB0aGlzLl9fcnVuVm9pY2VfXyggdm9pY2UsIHRoaXMgKVxuICAgIH1lbHNle1xuICAgICAgbGV0IHZvaWNlID0gdGhpcy5fX2dldFZvaWNlX18oKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdm9pY2UsIHRoaXMucHJvcGVydGllcyApXG4gICAgICB2b2ljZS50cmlnZ2VyKCBsb3VkbmVzcyApXG4gICAgICB0aGlzLl9fcnVuVm9pY2VfXyggdm9pY2UsIHRoaXMgKVxuICAgIH1cbiAgfSxcblxuICBfX3J1blZvaWNlX18oIHZvaWNlLCBfcG9seSApIHtcbiAgICBpZiggIXZvaWNlLmlzQ29ubmVjdGVkICkge1xuICAgICAgdm9pY2UuY29ubmVjdCggX3BvbHkgKVxuICAgICAgdm9pY2UuaXNDb25uZWN0ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLy9sZXQgZW52Q2hlY2tcbiAgICAvL2lmKCBfcG9seS5lbnZDaGVjayA9PT0gdW5kZWZpbmVkICkge1xuICAgIC8vICBlbnZDaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgIGlmKCB2b2ljZS5lbnYuaXNDb21wbGV0ZSgpICkge1xuICAgIC8vICAgICAgX3BvbHkuZGlzY29ubmVjdFVnZW4oIHZvaWNlIClcbiAgICAvLyAgICAgIHZvaWNlLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAvLyAgICB9ZWxzZXtcbiAgICAvLyAgICAgIEdpYmJlcmlzaC5ibG9ja0NhbGxiYWNrcy5wdXNoKCBlbnZDaGVjayApXG4gICAgLy8gICAgfVxuICAgIC8vICB9XG4gICAgLy99ZWxzZXtcbiAgICAvLyAgZW52Q2hlY2sgPSBfcG9seS5lbnZDaGVjayggdm9pY2UsIF9wb2x5IClcbiAgICAvL31cblxuICAgIC8vIFhYWCB1bmNvbW1lbnQgdGhpcyBsaW5lIHRvIHR1cm4gb24gZHluYW1pY2FsbHkgY29ubmVjdGluZ1xuICAgIC8vIGRpc2Nvbm5lY3RpbmcgaW5kaXZpZHVhbCB2b2ljZXMgZnJvbSBncmFwaFxuICAgIC8vR2liYmVyaXNoLmJsb2NrQ2FsbGJhY2tzLnB1c2goIGVudkNoZWNrIClcbiAgfSxcblxuICBfX2dldFZvaWNlX18oKSB7XG4gICAgcmV0dXJuIHRoaXMudm9pY2VzWyB0aGlzLnZvaWNlQ291bnQrKyAlIHRoaXMudm9pY2VzLmxlbmd0aCBdXG4gIH0sXG5cbiAgY2hvcmQoIGZyZXF1ZW5jaWVzICkge1xuICAgIC8vIHdpbGwgYmUgc2VudCB0byBwcm9jZXNzb3Igbm9kZSB2aWEgcHJveHkgbWV0aG9kLi4uXG4gICAgaWYoIEdpYmJlcmlzaCAhPT0gdW5kZWZpbmVkICYmIEdpYmJlcmlzaC5tb2RlICE9PSAnd29ya2xldCcgKSB7XG4gICAgICBmcmVxdWVuY2llcy5mb3JFYWNoKCB2ID0+IHRoaXMubm90ZSggdiApIClcbiAgICAgIHRoaXMudHJpZ2dlckNob3JkID0gZnJlcXVlbmNpZXNcbiAgICB9XG4gIH0sXG5cbiAgZnJlZSgpIHtcbiAgICBmb3IoIGxldCBjaGlsZCBvZiB0aGlzLnZvaWNlcyApIGNoaWxkLmZyZWUoKVxuICB9LFxuXG4gIHRyaWdnZXJDaG9yZDpudWxsLFxuICB0cmlnZ2VyTm90ZTpudWxsXG59XG4iLCIvKlxuICogVGhpcyBmaWxlcyBjcmVhdGVzIGEgZmFjdG9yeSBnZW5lcmF0aW5nIHBvbHlzeW50aCBjb25zdHJ1Y3RvcnMuXG4gKi9cblxuY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcbmNvbnN0IF9fcHJveHkgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgcHJveHkgPSBfX3Byb3h5KCBHaWJiZXJpc2ggKVxuXG4gIGNvbnN0IFRlbXBsYXRlRmFjdG9yeSA9ICggdWdlbiwgcHJvcGVydHlMaXN0LCBfZW52Q2hlY2sgKSA9PiB7XG5cbiAgICBjb25zdCBUZW1wbGF0ZSA9IHByb3BzID0+IHtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgeyBpc1N0ZXJlbzp0cnVlLCBtYXhWb2ljZXM6NCB9LCBwcm9wcyApXG5cbiAgICAgIC8vY29uc3Qgc3ludGggPSBwcm9wZXJ0aWVzLmlzU3RlcmVvID09PSB0cnVlID8gT2JqZWN0LmNyZWF0ZSggc3RlcmVvUHJvdG8gKSA6IE9iamVjdC5jcmVhdGUoIG1vbm9Qcm90byApXG4gICAgICBjb25zdCBzeW50aCA9IHByb3BlcnRpZXMuaXNTdGVyZW8gPT09IHRydWUgPyBHaWJiZXJpc2guQnVzMih7IF9fdXNlUHJveHlfXzpmYWxzZSB9KSA6IEdpYmJlcmlzaC5CdXMoeyBfX3VzZVByb3h5X186ZmFsc2UgfSkgXG5cbiAgICAgIE9iamVjdC5hc3NpZ24oIFxuICAgICAgICBzeW50aCwgXG5cbiAgICAgICAge1xuICAgICAgICAgIG1heFZvaWNlczogcHJvcGVydGllcy5tYXhWb2ljZXMsIFxuICAgICAgICAgIHZvaWNlQ291bnQ6IDAsXG4gICAgICAgICAgZW52Q2hlY2s6IF9lbnZDaGVjayxcbiAgICAgICAgICBkaXJ0eTogdHJ1ZSxcbiAgICAgICAgICB1Z2VuTmFtZTogJ3BvbHknICsgdWdlbi5uYW1lICsgJ18nICsgc3ludGguaWQgKyAnXycgKyAoIHByb3BlcnRpZXMuaXNTdGVyZW8gPyAyIDogMSApLFxuICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgfSxcblxuICAgICAgICBHaWJiZXJpc2gubWl4aW5zLnBvbHlpbnN0cnVtZW50XG4gICAgICApXG5cbiAgICAgIHByb3BlcnRpZXMucGFuVm9pY2VzID0gdHJ1ZS8vZmFsc2UvL3Byb3BlcnRpZXMuaXNTdGVyZW9cbiAgICAgIHN5bnRoLmNhbGxiYWNrLnVnZW5OYW1lID0gc3ludGgudWdlbk5hbWVcblxuICAgICAgY29uc3Qgc3RvcmVkSWQgPSBwcm9wZXJ0aWVzLmlkXG4gICAgICBpZiggcHJvcGVydGllcy5pZCAhPT0gdW5kZWZpbmVkICkgZGVsZXRlIHByb3BlcnRpZXMuaWQgXG5cbiAgICAgIGNvbnN0IHZvaWNlcyA9IFtdXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHN5bnRoLm1heFZvaWNlczsgaSsrICkge1xuICAgICAgICBwcm9wZXJ0aWVzLmlkID0gc3ludGguaWQgKydfJytpXG4gICAgICAgIHZvaWNlc1tpXSA9IHVnZW4oIHByb3BlcnRpZXMgKVxuICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InIClcbiAgICAgICAgICB2b2ljZXNbaV0uY2FsbGJhY2sudWdlbk5hbWUgPSB2b2ljZXNbaV0udWdlbk5hbWVcblxuICAgICAgICB2b2ljZXNbaV0uaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICAvL3N5bnRoLl9fdm9pY2VzW2ldID0gcHJveHkoIFsnaW5zdHJ1bWVudHMnLCB1Z2VuLm5hbWVdLCBwcm9wZXJ0aWVzLCBzeW50aC52b2ljZXNbaV0gKVxuICAgICAgfVxuXG4gICAgICBsZXQgX3Byb3BlcnR5TGlzdCBcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmlzU3RlcmVvID09PSBmYWxzZSApIHtcbiAgICAgICAgX3Byb3BlcnR5TGlzdCA9IHByb3BlcnR5TGlzdC5zbGljZSggMCApXG4gICAgICAgIGNvbnN0IGlkeCA9ICBfcHJvcGVydHlMaXN0LmluZGV4T2YoICdwYW4nIClcbiAgICAgICAgaWYoIGlkeCAgPiAtMSApIF9wcm9wZXJ0eUxpc3Quc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgfVxuXG4gICAgICBwcm9wZXJ0aWVzLmlkID0gc3RvcmVkSWRcblxuICAgICAgVGVtcGxhdGVGYWN0b3J5LnNldHVwUHJvcGVydGllcyggc3ludGgsIHVnZW4sIHByb3BlcnRpZXMuaXNTdGVyZW8gPyBwcm9wZXJ0eUxpc3QgOiBfcHJvcGVydHlMaXN0IClcbiAgICAgIFxuICAgICAgY29uc3QgcCA9IHByb3h5KCBbJ2luc3RydW1lbnRzJywgJ1BvbHknK3VnZW4ubmFtZV0sIHByb3BlcnRpZXMsIHN5bnRoICkgXG5cbiAgICAgIC8vIHByb3h5IHdvcmthcm91bmQgbmlnaHRtYXJlLi4uIGlmIHdlIGluY2x1ZGUgdGhlIHZvaWNlcyB3aGVuIHdlIGNyZWF0ZVxuICAgICAgLy8gdGhlIHByb3h5LCB0aGV5IHdpbmQgdXAgYmVpbmcgc3RyYW5nZWx5IHVuYWRkcmVzc2FibGUuIHBlcmhhcHMgdGhleVxuICAgICAgLy8gYXJlIGJlaW5nIG92ZXJ3cml0dGluZyBpbiB0aGUgUHJvY2Vzc29yLnVnZW5zIG1hcCBvYmplY3Q/XG4gICAgICAvLyBtYW51YWxseSBhZGRpbmcgZWFjaCBvbmUgc2VlbXMgdG8gd29yayBhcm91bmQgdGhlIHByb2JsZW1cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBwLnZvaWNlcyA9IFtdXG4gICAgICAgIGxldCBjb3VudCA9IDBcbiAgICAgICAgZm9yKCBsZXQgdiBvZiB2b2ljZXMgKSB7XG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOiAnYWRkT2JqZWN0VG9Qcm9wZXJ0eScsXG4gICAgICAgICAgICBvYmplY3Q6IHN5bnRoLmlkLFxuICAgICAgICAgICAgbmFtZTondm9pY2VzJyxcbiAgICAgICAgICAgIGtleTpjb3VudCxcbiAgICAgICAgICAgIHZhbHVlOnYuaWRcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcC52b2ljZXNbIGNvdW50IF0gPSB2XG4gICAgICAgICAgY291bnQrK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwIFxuICAgIH1cblxuICAgIHJldHVybiBUZW1wbGF0ZVxuICB9XG5cbiAgVGVtcGxhdGVGYWN0b3J5LnNldHVwUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBzeW50aCwgdWdlbiwgcHJvcHMgKSB7XG4gICAgZm9yKCBsZXQgcHJvcGVydHkgb2YgcHJvcHMgKSB7XG4gICAgICBpZiggcHJvcGVydHkgPT09ICdwYW4nIHx8IHByb3BlcnR5ID09PSAnaWQnICkgY29udGludWVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggc3ludGgsIHByb3BlcnR5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHN5bnRoLnByb3BlcnRpZXNbIHByb3BlcnR5IF0gfHwgdWdlbi5kZWZhdWx0c1sgcHJvcGVydHkgXVxuICAgICAgICB9LFxuICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgc3ludGgucHJvcGVydGllc1sgcHJvcGVydHkgXSA9IHZcbiAgICAgICAgICBmb3IoIGxldCBjaGlsZCBvZiBzeW50aC52b2ljZXMgKSB7XG4gICAgICAgICAgICBjaGlsZFsgcHJvcGVydHkgXSA9IHZcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFRlbXBsYXRlRmFjdG9yeVxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcbiAgY29uc3QgbWVtbyA9IHt9XG5cbiAgT2JqZWN0LmFzc2lnbiggcHJvdG8sIHtcbiAgICBub3RlKCByYXRlICkge1xuICAgICAgdGhpcy5yYXRlID0gcmF0ZVxuICAgICAgaWYoIHJhdGUgPiAwICkge1xuICAgICAgICB0aGlzLl9fdHJpZ2dlcigpXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fX3BoYXNlX18udmFsdWUgPSB0aGlzLmVuZCAqICh0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDEpXG4gICAgICB9XG4gICAgfSxcbiAgICB0cmlnZ2VyKCB2b2x1bWUgKSB7XG4gICAgICBpZiggdm9sdW1lICE9PSB1bmRlZmluZWQgKSB0aGlzLmdhaW4gPSB2b2x1bWVcblxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgLy8gaWYgd2UncmUgcGxheWluZyB0aGUgc2FtcGxlIGZvcndhcmRzLi4uXG4gICAgICAgIGlmKCBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIHRoaXMuX19yYXRlU3RvcmFnZV9fLm1lbW9yeS52YWx1ZXMuaWR4IF0gPiAwICkge1xuICAgICAgICAgIHRoaXMuX190cmlnZ2VyKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3BoYXNlX18udmFsdWUgPSB0aGlzLmVuZCAqICh0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KVxuXG4gIGNvbnN0IFNhbXBsZXIgPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBzeW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHsgb25sb2FkOm51bGwgfSwgU2FtcGxlci5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG5cbiAgICBzeW4uaXNTdGVyZW8gPSBwcm9wcy5pc1N0ZXJlbyAhPT0gdW5kZWZpbmVkID8gcHJvcHMuaXNTdGVyZW8gOiBmYWxzZVxuXG4gICAgY29uc3Qgc3RhcnQgPSBnLmluKCAnc3RhcnQnICksIGVuZCA9IGcuaW4oICdlbmQnICksIFxuICAgICAgICAgIGJ1ZmZlckxlbmd0aCA9IGcuaW4oICdidWZmZXJMZW5ndGgnICksIFxuICAgICAgICAgIHJhdGUgPSBnLmluKCAncmF0ZScgKSwgc2hvdWxkTG9vcCA9IGcuaW4oICdsb29wcycgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgLy8gcmF0ZSBzdG9yYWdlIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UncmUgcGxheWluZ1xuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgZm9yd2FyZCBvciBpbiByZXZlcnNlLCBmb3IgdXNlIGluIHRoZSAndHJpZ2dlcicgbWV0aG9kLlxuICAgICAgICAgIHJhdGVTdG9yYWdlID0gZy5kYXRhKFswXSwgMSwgeyBtZXRhOnRydWUgfSlcblxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwgcHJvcHMgKVxuXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICBzeW4uX19tZXRhX18gPSB7XG4gICAgICAgIGFkZHJlc3M6J2FkZCcsXG4gICAgICAgIG5hbWU6IFsnaW5zdHJ1bWVudHMnLCAnU2FtcGxlciddLFxuICAgICAgICBwcm9wZXJ0aWVzOiBKU09OLnN0cmluZ2lmeShwcm9wcyksIFxuICAgICAgICBpZDogc3luLmlkXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggc3luLmlkLCBzeW4gKVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBzeW4uX19tZXRhX18gKVxuICAgIH1cblxuICAgIHN5bi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBzeW4uX19iYW5nX18gPSBnLmJhbmcoKVxuICAgICAgc3luLl9fdHJpZ2dlciA9IHN5bi5fX2JhbmdfXy50cmlnZ2VyXG5cbiAgICAgIHN5bi5fX3BoYXNlX18gPSBnLmNvdW50ZXIoIFxuICAgICAgICByYXRlLCBcbiAgICAgICAgZy5tdWwoc3RhcnQsYnVmZmVyTGVuZ3RoKSwgXG4gICAgICAgIGcubXVsKCBlbmQsIGJ1ZmZlckxlbmd0aCApLCBcbiAgICAgICAgc3luLl9fYmFuZ19fLCBcbiAgICAgICAgc2hvdWxkTG9vcCwgXG4gICAgICAgIHsgc2hvdWxkV3JhcDpmYWxzZSwgaW5pdGlhbFZhbHVlOjk5OTk5OTkgfVxuICAgICAgKVxuICAgICAgXG4gICAgICBzeW4uX19yYXRlU3RvcmFnZV9fID0gcmF0ZVN0b3JhZ2VcbiAgICAgIHJhdGVTdG9yYWdlWzBdID0gcmF0ZVxuXG4gICAgICAvLyBYWFggd2UgYWRkZWQgb3VyIHJlY29yZGVkICdyYXRlJyBwYXJhbSBhbmQgdGhlbiBlZmZlY3RpdmVseSBzdWJ0cmFjdCBpdCxcbiAgICAgIC8vIHNvIHRoYXQgaXRzIHByZXNlbmNlIGluIHRoZSBncmFwaCB3aWxsIGZvcmNlIGdlbmlzaCB0byBhY3R1YWxseSByZWNvcmQgdGhlIFxuICAgICAgLy8gcmF0ZSBhcyB0aGUgaW5wdXQuIHRoaXMgaXMgZXh0cmVtZWx5IGhhY2t5Li4uIHRoZXJlIHNob3VsZCBiZSBhIHdheSB0byByZWNvcmRcbiAgICAgIC8vIHZhbHVlIHdpdGhvdXQgaGF2aW5nIHRvIGluY2x1ZGUgaXQgaW4gdGhlIGdyYXBoIVxuICAgICAgc3luLmdyYXBoID0gZy5hZGQoIGcubXVsKCBcbiAgICAgICAgZy5pZmVsc2UoIFxuICAgICAgICAgIGcuYW5kKCBnLmd0ZSggc3luLl9fcGhhc2VfXywgZy5tdWwoc3RhcnQsYnVmZmVyTGVuZ3RoKSApLCBnLmx0KCBzeW4uX19waGFzZV9fLCBnLm11bChlbmQsYnVmZmVyTGVuZ3RoKSApICksXG4gICAgICAgICAgZy5wZWVrKCBcbiAgICAgICAgICAgIHN5bi5kYXRhLCBcbiAgICAgICAgICAgIHN5bi5fX3BoYXNlX18sXG4gICAgICAgICAgICB7IG1vZGU6J3NhbXBsZXMnIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIDBcbiAgICAgICAgKSwgXG4gICAgICAgIGcubXVsKCBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApLCBnLmluKCdnYWluJykgKVxuICAgICAgKSwgcmF0ZVN0b3JhZ2VbMF0sIGcubXVsKCByYXRlU3RvcmFnZVswXSwgLTEgKSApXG4gICAgICBcbiAgICAgIGlmKCBzeW4ucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgY29uc3QgcGFubmVyID0gZy5wYW4oIHN5bi5ncmFwaCwgc3luLmdyYXBoLCBnLmluKCAncGFuJyApICkgXG4gICAgICAgIHN5bi5ncmFwaCA9IFsgcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25sb2FkID0gKGJ1ZmZlcixmaWxlbmFtZSkgPT4ge1xuICAgICAgaWYoIGJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmV0dXJuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgLy9jb25zdCBtZW1JZHggPSBtZW1vWyBmaWxlbmFtZSBdLmlkeCAhPT0gdW5kZWZpbmVkID8gbWVtb1sgZmlsZW5hbWUgXS5pZHggOiBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKCBzeW4uZGF0YS5tZW1vcnkudmFsdWVzLmxlbmd0aCwgdHJ1ZSApXG5cbiAgICAgICAgY29uc3QgbWVtSWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggYnVmZmVyLmxlbmd0aCwgdHJ1ZSApXG4gICAgICAgIC8vbWVtb1sgZmlsZW5hbWUgXS5pZHggPSBtZW1JZHhcblxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBhZGRyZXNzOidjb3B5JyxcbiAgICAgICAgICBpZDogICAgIHN5bi5pZCxcbiAgICAgICAgICBpZHg6ICAgIG1lbUlkeCxcbiAgICAgICAgICBidWZmZXJcbiAgICAgICAgfSlcblxuICAgICAgfWVsc2UgaWYgKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIHN5bi5kYXRhLmJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgICBzeW4uZGF0YS5tZW1vcnkudmFsdWVzLmxlbmd0aCA9IHN5bi5kYXRhLmRpbSA9IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgc3luLl9fcmVkb0dyYXBoKCkgXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2Ygc3luLm9ubG9hZCA9PT0gJ2Z1bmN0aW9uJyApeyAgXG4gICAgICAgIHN5bi5vbmxvYWQoIGJ1ZmZlciB8fCBzeW4uZGF0YS5idWZmZXIgKVxuICAgICAgfVxuICAgICAgaWYoIHN5bi5idWZmZXJMZW5ndGggPT09IC05OTk5OTk5OTkgJiYgc3luLmRhdGEuYnVmZmVyICE9PSB1bmRlZmluZWQgKSBzeW4uYnVmZmVyTGVuZ3RoID0gc3luLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDFcbiAgICB9XG5cbiAgICAvL2lmKCBwcm9wcy5maWxlbmFtZSApIHtcbiAgICBzeW4ubG9hZEZpbGUgPSBmdW5jdGlvbiggZmlsZW5hbWUgKSB7XG4gICAgICAvL2lmKCBtZW1vWyBmaWxlbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSAhPT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgc3luLmRhdGEgPSBnLmRhdGEoIGZpbGVuYW1lLCAxLCB7IG9ubG9hZCB9KVxuXG5cbiAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkOyBhIHZhbGlkXG4gICAgICAgICAgLy8gZGF0YSBvYmplY3QgaXMgb25seSByZXR1cm4gaWYgdGhlIGZpbGUgaGFzIGJlZW5cbiAgICAgICAgICAvLyBwcmV2aW91c2x5IGxvYWRlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgYnVmZmVyIGhhc1xuICAgICAgICAgIC8vIGJlZW4gY2FjaGVkLlxuICAgICAgICAgIGlmKCBzeW4uZGF0YSBpbnN0YW5jZW9mIFByb21pc2UgKSB7XG4gICAgICAgICAgICBzeW4uZGF0YS50aGVuKCBkID0+IHtcbiAgICAgICAgICAgICAgc3luLmRhdGEgPSBkXG4gICAgICAgICAgICAgIG1lbW9bIGZpbGVuYW1lIF0gPSBzeW4uZGF0YVxuICAgICAgICAgICAgICBvbmxvYWQoIGQuYnVmZmVyLCBmaWxlbmFtZSApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy8gdXNpbmcgYSBjYWNoZWQgZGF0YSBidWZmZXIsIG5vIG5lZWRcbiAgICAgICAgICAgIC8vIGZvciBhc3luY2hyb25vdXMgbG9hZGluZy5cbiAgICAgICAgICAgIG1lbW9bIGZpbGVuYW1lIF0gPSBzeW4uZGF0YVxuICAgICAgICAgICAgb25sb2FkKCBzeW4uZGF0YS5idWZmZXIsIGZpbGVuYW1lIClcbiAgICAgICAgICB9ICAgICBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgc3luLmRhdGEgPSBnLmRhdGEoIG5ldyBGbG9hdDMyQXJyYXkoKSwgMSwgeyBvbmxvYWQsIGZpbGVuYW1lIH0pXG4gICAgICAgICAgLy9tZW1vWyBmaWxlbmFtZSBdID0gc3luLmRhdGFcbiAgICAgICAgfVxuICAgICAgLy99ZWxzZXtcbiAgICAgIC8vICBzeW4uZGF0YSA9IG1lbW9bIGZpbGVuYW1lIF1cbiAgICAgIC8vICBjb25zb2xlLmxvZyggJ21lbW8gZGF0YTonLCBzeW4uZGF0YSApXG4gICAgICAvLyAgb25sb2FkKCBzeW4uZGF0YS5idWZmZXIsIGZpbGVuYW1lIClcbiAgICAgIC8vfVxuICAgIH1cblxuICAgIHN5bi5sb2FkQnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlciApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIHN5bi5kYXRhLmJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgICBzeW4uZGF0YS5tZW1vcnkudmFsdWVzLmxlbmd0aCA9IHN5bi5kYXRhLmRpbSA9IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgc3luLl9fcmVkb0dyYXBoKCkgXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHByb3BzLmZpbGVuYW1lICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBzeW4ubG9hZEZpbGUoIHByb3BzLmZpbGVuYW1lIClcbiAgICB9ZWxzZXtcbiAgICAgIHN5bi5kYXRhID0gZy5kYXRhKCBuZXcgRmxvYXQzMkFycmF5KCkgKVxuICAgIH1cblxuICAgIGlmKCBzeW4uZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgc3luLmRhdGEub25sb2FkID0gb25sb2FkXG5cbiAgICAgIHN5bi5fX2NyZWF0ZUdyYXBoKClcbiAgICB9XG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBzeW4sXG4gICAgICBzeW4uZ3JhcGgsXG4gICAgICBbJ2luc3RydW1lbnRzJywnc2FtcGxlciddLCBcbiAgICAgIHByb3BzIFxuICAgICkgXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBTYW1wbGVyLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgcGFuOiAuNSxcbiAgICByYXRlOiAxLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBsb29wczogMCxcbiAgICBzdGFydDowLFxuICAgIGVuZDoxLFxuICAgIGJ1ZmZlckxlbmd0aDotOTk5OTk5OTk5LFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgY29uc3QgZW52Q2hlY2tGYWN0b3J5ID0gZnVuY3Rpb24oIHZvaWNlLCBfcG9seSApIHtcbiAgICBjb25zdCBlbnZDaGVjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlID0gR2liYmVyaXNoLm1lbW9yeS5oZWFwWyB2b2ljZS5fX3BoYXNlX18ubWVtb3J5LnZhbHVlLmlkeCBdXG4gICAgICBpZiggKCB2b2ljZS5yYXRlID4gMCAmJiBwaGFzZSA+IHZvaWNlLmVuZCApIHx8ICggdm9pY2UucmF0ZSA8IDAgJiYgcGhhc2UgPCAwICkgKSB7XG4gICAgICAgIF9wb2x5LmRpc2Nvbm5lY3RVZ2VuLmNhbGwoIF9wb2x5LCB2b2ljZSApXG4gICAgICAgIHZvaWNlLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAgIH1lbHNle1xuICAgICAgICBHaWJiZXJpc2guYmxvY2tDYWxsYmFja3MucHVzaCggZW52Q2hlY2sgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnZDaGVja1xuICB9XG5cbiAgY29uc3QgUG9seVNhbXBsZXIgPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBTYW1wbGVyLCBbJ3JhdGUnLCdwYW4nLCdnYWluJywnc3RhcnQnLCdlbmQnLCdsb29wcycsJ2J1ZmZlckxlbmd0aCcsJ19fdHJpZ2dlckxvdWRuZXNzJywnbG91ZG5lc3MnXSwgZW52Q2hlY2tGYWN0b3J5ICkgXG5cbiAgcmV0dXJuIFsgU2FtcGxlciwgUG9seVNhbXBsZXIgXVxufVxuXG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG4gIFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IFNuYXJlID0gYXJndW1lbnRQcm9wcyA9PiB7XG4gICAgY29uc3Qgc25hcmUgPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50ICksXG4gICAgICAgICAgZGVjYXkgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgc2NhbGVkRGVjYXkgPSBnLm11bCggZGVjYXksIGcuZ2VuLnNhbXBsZXJhdGUgKiAyICksXG4gICAgICAgICAgc25hcHB5PSBnLmluKCAnc25hcHB5JyApLFxuICAgICAgICAgIHR1bmUgID0gZy5pbiggJ3R1bmUnICksXG4gICAgICAgICAgZ2FpbiAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCdfX3RyaWdnZXJMb3VkbmVzcycpLFxuICAgICAgICAgIExvdWRuZXNzID0gZy5tdWwoIGxvdWRuZXNzLCB0cmlnZ2VyTG91ZG5lc3MgKSxcbiAgICAgICAgICBlZyA9IGcuZGVjYXkoIHNjYWxlZERlY2F5LCB7IGluaXRWYWx1ZTowIH0gKSwgXG4gICAgICAgICAgY2hlY2sgPSBnLm1lbW8oIGcuZ3QoIGVnLCAuMDAwNSApICksXG4gICAgICAgICAgcm5kID0gZy5tdWwoIGcubm9pc2UoKSwgZWcgKSxcbiAgICAgICAgICBocGYgPSBnLnN2Ziggcm5kLCBnLmFkZCggMTAwMCwgZy5tdWwoIGcuYWRkKCAxLCB0dW5lKSwgMTAwMCApICksIC41LCAxLCBmYWxzZSApLFxuICAgICAgICAgIHNuYXAgPSBnLm11bCggZy5ndHAoIGcubXVsKCBocGYsIHNuYXBweSApLCAwICksIExvdWRuZXNzICksIC8vIHJlY3RpZnlcbiAgICAgICAgICBicGYxID0gZy5zdmYoIGVnLCBnLm11bCggMTgwLCBnLmFkZCggdHVuZSwgMSApICksIC4wNSwgMiwgZmFsc2UgKSxcbiAgICAgICAgICBicGYyID0gZy5zdmYoIGVnLCBnLm11bCggMzMwLCBnLmFkZCggdHVuZSwgMSApICksIC4wNSwgMiwgZmFsc2UgKSxcbiAgICAgICAgICBvdXQgID0gZy5tZW1vKCBnLmFkZCggc25hcCwgYnBmMSwgZy5tdWwoIGJwZjIsIC44ICkgKSApLCAvL1hYWCB3aHkgaXMgbWVtbyBuZWVkZWQ/XG4gICAgICAgICAgc2NhbGVkT3V0ID0gZy5tdWwoIG91dCwgZy5tdWwoIGdhaW4sIExvdWRuZXNzICkgKSxcbiAgICAgICAgICBpZmUgPSBnLnN3aXRjaCggY2hlY2ssIHNjYWxlZE91dCwgMCApLFxuICAgICAgICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIFNuYXJlLmRlZmF1bHRzLCBhcmd1bWVudFByb3BzIClcblxuICAgIC8vIFhYWCBUT0RPIDogbWFrZSBhYm92ZSBzd2l0Y2ggd29yayB3aXRoIGlmZWxzZS4gdGhlIHByb2JsZW0gaXMgdGhhdCBwb2tlIHVnZW5zIHB1dCB0aGVpclxuICAgIC8vIGNvZGUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIGluc3RlYWQgb2YgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAvLyBhc3NvY2lhdGVkIGlmL2Vsc2UgYmxvY2suXG4gICAgXG4gICAgc25hcmUuZW52ID0gZWcgXG4gICAgY29uc3QgX19zbmFyZSA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzbmFyZSwgaWZlLCBbJ2luc3RydW1lbnRzJywnc25hcmUnXSwgcHJvcHMgIClcbiAgICBcbiAgICByZXR1cm4gX19zbmFyZVxuICB9XG4gIFxuICBTbmFyZS5kZWZhdWx0cyA9IHtcbiAgICBnYWluOiAuNSxcbiAgICB0dW5lOjAsXG4gICAgc25hcHB5OiAxLFxuICAgIGRlY2F5Oi4xLFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgcmV0dXJuIFNuYXJlXG5cbn1cbiIsIi8qZmV0Y2goICcwMDAwX0FzcGlyaW5fc2YyX2ZpbGUuanNvbicgKVxuLnRoZW4oIHJlcyA9PiByZXMuanNvbigpIClcbi50aGVuKCBqc29uID0+IHtcbiAgd2luZG93LnpvbmVzID0ganNvbi56b25lc1xuICBjb25zb2xlLmxvZyggd2luZG93LnpvbmVzIClcbn0pXG5cbmFiID0gR2liYmVyaXNoLnV0aWxpdGllcy4uZGVjb2RlQXJyYXlCdWZmZXIoIHpvbmVzWzBdLmZpbGUgKVxuZ2VuaXNoLnV0aWxpdGllcy5jdHguZGVjb2RlQXVkaW9EYXRhKCBhYiwgYnVmZmVyID0+IHtcbiAgX19hYiA9IGJ1ZmZlclxuICBjb25zb2xlLmxvZyggJ2J1ZmZlciBtYWRlJyApXG59KVxuXG5cbl9kID0gZGF0YSggX19hYiApXG5wbGF5KCBwZWVrKCBfZCwgcGhhc29yKDEsMCx7bWluOjB9KSApIClcbiovXG5cbmNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG5jb25zdCBzb3VuZGZvbnRzID0ge31cblxuY29uc3QgYmFua3MgPSBbXG4gICdBc3BpcmluJyxcbiAgJ0NoYW9zJyxcbiAgJ0ZsdWlkUjMnLFxuICAnR2VuZXJhbFVzZXJHUycsXG4gICdKQ0xpdmUnXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcbiAgY29uc3QgbWVtbyA9IHt9XG4gIFxuICBPYmplY3QuYXNzaWduKCBwcm90bywge1xuICAgIHBpY2tGaWxlKCBzYW1wbGUgKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTYW1wbGUgPSBzYW1wbGVcbiAgICB9LFxuICAgIHBpY2soIF9faWR4ICkge1xuICAgICAgY29uc3QgaWR4ID0gTWF0aC5mbG9vciggX19pZHggKVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLnNhbXBsZXJzIClcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbIGlkeCBdXG4gICAgICB0aGlzLmN1cnJlbnRTYW1wbGUgPSBrZXlcbiAgICB9LFxuICAgIHBpY2twbGF5KCBfX2lkeCApIHtcbiAgICAgIGNvbnN0IGlkeCA9IE1hdGguZmxvb3IoIF9faWR4IClcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggdGhpcy5zYW1wbGVycyApXG4gICAgICBjb25zdCBrZXkgPSBrZXlzWyBpZHggXVxuICAgICAgdGhpcy5jdXJyZW50U2FtcGxlID0ga2V5XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKClcbiAgICB9LFxuICAgIF9fbm90ZSggcmF0ZSwgbG91ZG5lc3M9bnVsbCApIHtcbiAgICAgIC8vIHNvdW5kZm9udCBtZWFzdXJlcyBwaXRjaCBpbiBjZW50c1xuICAgICAgLy8gb3JpZ2luYWxQaXRjaCA9IGZpbmRNaWRpRm9ySHooIGh6ICkgKiAxMDAgLy8gKDEwMCBjZW50cyBwZXIgbWlkaSBpbmRleClcbiAgICAgIC8vIHJhdGUgPSBNYXRoLnBvdygyLCAoMTAwLjAgKiBwaXRjaCAtIG9yaWdpbmFsUGl0Y2gpIC8gMTIwMC4wKSAvLyAxMjAwIGNlbnRzIHBlciBvY3RhdmVcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoIGxvdWRuZXNzLCByYXRlIClcbiAgICB9LFxuICAgIG5vdGUoIGZyZXEsIGxvdWRuZXNzPW51bGwgKSB7XG4gICAgICAnbm8ganNkc3AnXG4gICAgICBjb25zdCBtaWRpbm90ZSA9IDY5ICsgMTIgKiBNYXRoLmxvZzIoIGZyZXEvNDQwIClcbiAgICAgIHRoaXMubWlkaW5vdGUoIG1pZGlub3RlLCBsb3VkbmVzcyApXG4gICAgfSxcbiAgICBtaWRpcGljayggbWlkaW5vdGUsIGxvdWRuZXNzICkge1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIHpvbmVzIHRvIGZpbmQgY29ycmVjdCBzYW1wbGUgI1xuICAgICAgbGV0IGlkeCA9IDAsIHBpdGNoID0gMFxuICAgICAgZm9yKCBsZXQgem9uZSBvZiB0aGlzLnpvbmVzICkge1xuICAgICAgICBpZiggbWlkaW5vdGUgPj0gem9uZS5rZXlSYW5nZUxvdyAmJiBtaWRpbm90ZSA8PSB6b25lLmtleVJhbmdlSGlnaCApIHtcbiAgICAgICAgICBwaXRjaCA9IHpvbmUub3JpZ2luYWxQaXRjaFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlkeCsrXG4gICAgICB9XG4gICAgICB0aGlzLnBpY2soIGlkeCApXG4gICAgICByZXR1cm4gcGl0Y2hcbiAgICB9LFxuICAgIG1pZGlub3RlKCBtaWRpbm90ZSwgbG91ZG5lc3M9bnVsbCApIHtcbiAgICAgICdubyBqc2RzcCdcbiAgICAgIGNvbnN0IHNhbXBsZVBpdGNoID0gdGhpcy5taWRpcGljayggbWlkaW5vdGUgKVxuICAgICAgY29uc3QgcGl0Y2ggPSBNYXRoLnBvdyggMiwgKDEwMCAqIG1pZGlub3RlIC0gc2FtcGxlUGl0Y2ggKSAvIDEyMDAgKSBcbiAgICAgIC8vY29uc3QgcGl0Y2ggPSAxLy9NYXRoLnBvdyggMiwgKHNhbXBsZVBpdGNoICkgKSBcbiAgICAgIHRoaXMuX19ub3RlKCBwaXRjaCwgbG91ZG5lc3MgKVxuICAgIH0sIFxuICAgIG1pZGljaG9yZCggZnJlcXVlbmNpZXMgKSB7XG4gICAgICBpZiggR2liYmVyaXNoICE9PSB1bmRlZmluZWQgJiYgR2liYmVyaXNoLm1vZGUgIT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgZnJlcXVlbmNpZXMuZm9yRWFjaCggdiA9PiB0aGlzLm1pZGlub3RlKCB2ICkgKVxuICAgICAgICB0aGlzLnRyaWdnZXJDaG9yZCA9IGZyZXF1ZW5jaWVzXG4gICAgICB9XG4gICAgfSxcbiAgICBjaG9yZCggZnJlcXVlbmNpZXMgKSB7XG4gICAgICBpZiggR2liYmVyaXNoICE9PSB1bmRlZmluZWQgJiYgR2liYmVyaXNoLm1vZGUgIT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgZnJlcXVlbmNpZXMuZm9yRWFjaCggdiA9PiB0aGlzLm5vdGUoIHYgKSApXG4gICAgICAgIHRoaXMudHJpZ2dlckNob3JkID0gZnJlcXVlbmNpZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0cGFuKCBudW09MCwgdmFsdWU9LjUgKSB7XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBjb25zdCB2b2ljZSA9IHRoaXMudm9pY2VzWyBudW0gXVxuICAgICAgICAvLyBzZXQgdm9pY2UgYnVmZmVyIGxlbmd0aFxuICAgICAgICAvL2cuZ2VuLm1lbW9yeS5oZWFwLnNldCggWyB2YWx1ZSBdLCB2b2ljZS5wYW4ubWVtb3J5LnZhbHVlcy5pZHggKVxuICAgICAgICB2b2ljZS5wYW4gPSB2YWx1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0cmF0ZSggbnVtPTAsIHZhbHVlPTEgKSB7XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBjb25zdCB2b2ljZSA9IHRoaXMudm9pY2VzWyBudW0gXVxuICAgICAgICAvLyBzZXQgdm9pY2UgYnVmZmVyIGxlbmd0aFxuICAgICAgICAvL2cuZ2VuLm1lbW9yeS5oZWFwLnNldCggWyB2YWx1ZSBdLCB2b2ljZS5yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgICAgdm9pY2UucmF0ZSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSxcbiAgICB0cmlnZ2VyKCB2b2x1bWU9bnVsbCwgcmF0ZT1udWxsICkge1xuICAgICAgJ25vIGpzZHNwJ1xuICAgICAgLy9pZiggdm9sdW1lICE9PSBudWxsICkgdGhpcy5fX3RyaWdnZXJMb3VkbmVzcyA9IHZvbHVtZVxuXG4gICAgICBsZXQgdm9pY2UgPSBudWxsXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBjb25zdCBzYW1wbGVyID0gdGhpcy5zYW1wbGVyc1sgdGhpcy5jdXJyZW50U2FtcGxlIF1cblxuICAgICAgICAvLyBpZiBzYW1wbGUgaXNuJ3QgbG9hZGVkLi4uXG4gICAgICAgIGlmKCBzYW1wbGVyID09PSB1bmRlZmluZWQgKSByZXR1cm5cblxuICAgICAgICB2b2ljZSA9IHRoaXMuX19nZXRWb2ljZV9fKClcblxuICAgICAgICAvLyBzZXQgdm9pY2UgYnVmZmVyIGxlbmd0aFxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UuYnVmZmVyTGVuZ3RoLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSBzYW1wbGVyLmRhdGFMZW5ndGhcblxuICAgICAgICAvLyBzZXQgdm9pY2UgZGF0YSBpbmRleFxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UuYnVmZmVyTG9jLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSBzYW1wbGVyLmRhdGFJZHhcblxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UuX19sb29wU3RhcnQubWVtb3J5LnZhbHVlcy5pZHggXSA9IHNhbXBsZXIuem9uZS5sb29wU3RhcnRcbiAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHZvaWNlLl9fbG9vcEVuZC5tZW1vcnkudmFsdWVzLmlkeCAgIF0gPSBzYW1wbGVyLnpvbmUubG9vcEVuZFxuXG4gICAgICAgIGlmKCB2b2x1bWUgIT09IG51bGwgKVxuICAgICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5sb3VkbmVzcy5tZW1vcnkudmFsdWVzLmlkeCAgIF0gPSB2b2x1bWVcblxuICAgICAgICBpZiggcmF0ZSAhPT0gbnVsbCApIHZvaWNlLnJhdGUgPSByYXRlIFxuICAgICAgICBcbiAgICAgICAgdm9pY2UudHJpZ2dlcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2b2ljZVxuICAgIH0sXG4gICAgX19nZXRWb2ljZV9fKCkge1xuICAgICAgcmV0dXJuIHRoaXMudm9pY2VzWyB0aGlzLnZvaWNlQ291bnQrKyAlIHRoaXMudm9pY2VzLmxlbmd0aCBdXG4gICAgfSxcbiAgfSlcblxuICBjb25zdCBTb3VuZGZvbnQgPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBzeW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHsgb25sb2FkOm51bGwsIHZvaWNlQ291bnQ6MCwgZmlsZXM6W10gfSwgU291bmRmb250LmRlZmF1bHRzLCBpbnB1dFByb3BzIClcblxuICAgIHN5bi5pc1N0ZXJlbyA9IHByb3BzLmlzU3RlcmVvICE9PSB1bmRlZmluZWQgPyBwcm9wcy5pc1N0ZXJlbyA6IGZhbHNlXG5cbiAgICBjb25zdCBzdGFydCA9IGcuaW4oICdzdGFydCcgKSwgZW5kID0gZy5pbiggJ2VuZCcgKSwgXG4gICAgICAgICAgcmF0ZSA9IGcuaW4oICdyYXRlJyApLCBzaG91bGRMb29wID0gZy5pbiggJ2xvb3BzJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICAvLyByYXRlIHN0b3JhZ2UgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSdyZSBwbGF5aW5nXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBmb3J3YXJkIG9yIGluIHJldmVyc2UsIGZvciB1c2UgaW4gdGhlICd0cmlnZ2VyJyBtZXRob2QuXG4gICAgICAgICAgcmF0ZVN0b3JhZ2UgPSBnLmRhdGEoWzBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIHN5bi5fX21ldGFfXyA9IHtcbiAgICAgICAgYWRkcmVzczonYWRkJyxcbiAgICAgICAgbmFtZTogWydpbnN0cnVtZW50cycsICdTb3VuZGZvbnQnXSxcbiAgICAgICAgcHJvcGVydGllczogSlNPTi5zdHJpbmdpZnkocHJvcHMpLCBcbiAgICAgICAgaWQ6IHN5bi5pZFxuICAgICAgfVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5zZXQoIHN5bi5pZCwgc3luIClcblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSggc3luLl9fbWV0YV9fIClcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYWxsIG91ciB2b2NlY3NcbiAgICBjb25zdCB2b2ljZXMgPSBbXVxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgc3luLm1heFZvaWNlczsgaSsrICkge1xuICAgICAgJ3VzZSBqc2RzcCdcblxuICAgICAgY29uc3Qgdm9pY2UgPSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aDogZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBidWZmZXJMb2M6ICAgIGcuZGF0YSggWzFdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgYmFuZzogZy5iYW5nKCksXG4gICAgICAgIC8vIFhYWCBob3cgZG8gSSBjaGFuZ2UgdGhpcyBmcm9tIG1haW4gdGhyZWFkP1xuICAgICAgICBfX3BhbjogZy5kYXRhKCBbLjVdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgX19yYXRlOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fc2hvdWxkTG9vcDogZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX2xvb3BTdGFydDogZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX2xvb3BFbmQ6ICAgZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX2xvdWRuZXNzOiAgZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBnZXQgbG91ZG5lc3MoKSB7IFxuICAgICAgICAgIHJldHVybiBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX2xvdWRuZXNzLm1lbW9yeS52YWx1ZXMuaWR4ICAgXVxuICAgICAgICB9LFxuICAgICAgICBzZXQgbG91ZG5lc3MoIHYgKSB7XG4gICAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHRoaXMuX19sb3VkbmVzcy5tZW1vcnkudmFsdWVzLmlkeCBdID0gdlxuICAgICAgICB9LFxuICAgICAgICBzZXQgcGFuKHYpIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX3Bhbi5tZW1vcnkudmFsdWVzLmlkeCBdID0gdlxuICAgICAgICB9LFxuICAgICAgICBzZXQgcmF0ZSh2KSB7XG4gICAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHRoaXMuX19yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHZvaWNlLnBoYXNlID0gZy5jb3VudGVyKCBcbiAgICAgICAgcmF0ZSAqIHZvaWNlLl9fcmF0ZVswXSwgXG4gICAgICAgIHN0YXJ0ICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdLFxuICAgICAgICBlbmQgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0sIFxuICAgICAgICB2b2ljZS5iYW5nLFxuICAgICAgICBzaG91bGRMb29wLCBcbiAgICAgICAgeyBzaG91bGRXcmFwOmZhbHNlLCBpbml0aWFsVmFsdWU6OTk5OTk5OSB9XG4gICAgICApXG5cbiAgICAgIHZvaWNlLnRyaWdnZXIgPSB2b2ljZS5iYW5nLnRyaWdnZXJcblxuICAgICAgdm9pY2UuZ3JhcGggPSBnLmlmZWxzZShcbiAgICAgICAgLy8gaWYgcGhhc2UgaXMgZ3JlYXRlciB0aGFuIHN0YXJ0IGFuZCBsZXNzIHRoYW4gZW5kLi4uIFxuICAgICAgICBnLmFuZCggXG4gICAgICAgICAgZy5ndGUoIHZvaWNlLnBoYXNlLCBzdGFydCAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSApLCBcbiAgICAgICAgICBnLmx0KCAgdm9pY2UucGhhc2UsIGVuZCAgICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdICkgXG4gICAgICAgICksXG4gICAgICAgIC8vIC4uLnJlYWQgZGF0YVxuICAgICAgICB2b2ljZS5wZWVrID0gZy5wZWVrRHluKCBcbiAgICAgICAgICB2b2ljZS5idWZmZXJMb2NbMF0sIFxuICAgICAgICAgIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSxcbiAgICAgICAgICB2b2ljZS5waGFzZSxcbiAgICAgICAgICB7IG1vZGU6J3NhbXBsZXMnIH1cbiAgICAgICAgKSxcbiAgICAgICAgLy8gLi4uZWxzZSByZXR1cm4gMFxuICAgICAgICAwXG4gICAgICApIFxuICAgICAgKiBsb3VkbmVzcyBcbiAgICAgICogdm9pY2UuX19sb3VkbmVzc1swXSBcblxuICAgICAgLy8gc3RhcnQgb2YgYXR0ZW1wdCB0byBsb29wIHN1c3RhaW4uLi5cbiAgICAgIC8vdm9pY2UuZ3JhcGggPSBnLmlmZWxzZShcbiAgICAgIC8vICAvLyBpZiBwaGFzZSBpcyBncmVhdGVyIHRoYW4gc3RhcnQgYW5kIGxlc3MgdGhhbiBlbmQuLi4gXG4gICAgICAvLyAgZy5hbmQoIFxuICAgICAgLy8gICAgZy5ndGUoIHZvaWNlLnBoYXNlLCBzdGFydCAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSApLCBcbiAgICAgIC8vICAgIGcubHQoICB2b2ljZS5waGFzZSwgZW5kICAgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0gKSBcbiAgICAgIC8vICApLFxuICAgICAgLy8gIC8vIC4uLnJlYWQgZGF0YVxuICAgICAgLy8gIHZvaWNlLnBlZWsgPSBnLnBlZWtEeW4oIFxuICAgICAgLy8gICAgdm9pY2UuYnVmZmVyTG9jWzBdLCBcbiAgICAgIC8vICAgIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSxcbiAgICAgIC8vICAgIHZvaWNlLnBoYXNlLFxuICAgICAgLy8gICAgeyBtb2RlOidzYW1wbGVzJyB9XG4gICAgICAvLyAgKSxcbiAgICAgIC8vICAvLyAuLi5lbHNlIHJldHVybiAwXG4gICAgICAvLyAgZy5pZmVsc2UoXG4gICAgICAvLyAgICBnLmFuZChcbiAgICAgIC8vICAgICAgdm9pY2UuX19zaG91bGRMb29wWzBdLFxuICAgICAgLy8gICAgICBnLmd0KCB2b2ljZS5waGFzZSwgdm9pY2UuX19sb29wRW5kWzBdIClcbiAgICAgIC8vICAgICksXG4gICAgICAvLyAgICBnLnBlZWtEeW4oIFxuICAgICAgLy8gICAgICB2b2ljZS5idWZmZXJMb2NbMF0sIFxuICAgICAgLy8gICAgICB2b2ljZS5idWZmZXJMZW5ndGhbMF0sXG4gICAgICAvLyAgICAgIGcuYWRkKCBcbiAgICAgIC8vICAgICAgICB2b2ljZS5fX2xvb3BTdGFydFswXSxcbiAgICAgIC8vICAgICAgICBnLm1vZChcbiAgICAgIC8vICAgICAgICAgIHZvaWNlLnBoYXNlLFxuICAgICAgLy8gICAgICAgICAgLy9nLnN1Yiggdm9pY2UucGhhc2UsIHZvaWNlLl9fbG9vcFN0YXJ0WzBdICksXG4gICAgICAvLyAgICAgICAgICBnLnN1Yiggdm9pY2UuX19sb29wRW5kWzBdLCB2b2ljZS5fX2xvb3BTdGFydFswXSApXG4gICAgICAvLyAgICAgICAgKVxuICAgICAgLy8gICAgICApLFxuICAgICAgLy8gICAgICB7IG1vZGU6J3NhbXBsZXMnIH1cbiAgICAgIC8vICAgICksXG4gICAgICAvLyAgICAwXG4gICAgICAvLyAgKVxuICAgICAgLy8pIFxuICAgICAgLy8qIGxvdWRuZXNzIFxuICAgICAgLy8qIHRyaWdnZXJMb3VkbmVzcyBcbiAgICAgIFxuICAgICAgY29uc3QgcGFuID0gZy5wYW4oIHZvaWNlLmdyYXBoLCB2b2ljZS5ncmFwaCwgdm9pY2UuX19wYW5bMF0gKVxuICAgICAgdm9pY2UuZ3JhcGggPSBbIHBhbi5sZWZ0LCBwYW4ucmlnaHQgXVxuXG4gICAgICB2b2ljZXMucHVzaCggdm9pY2UgKVxuICAgIH1cblxuICAgIC8vIGxvYWQgaW4gc2FtcGxlIGRhdGFcbiAgICBjb25zdCBzYW1wbGVycyA9IHt9XG5cbiAgICAvLyBib3VuZCB0byBpbmRpdmlkdWFsIHNhbXBsZXIgb2JqZWN0cyBpbiBsb2FkU2FtcGxlIGZ1bmN0aW9uXG4gICAgc3luLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiggYnVmZmVyLCBvbmxvYWQgKSB7XG4gICAgICAvLyBtYWluIHRocmVhZDogd2hlbiBzYW1wbGUgaXMgbG9hZGVkLCBjb3B5IGl0IG92ZXIgbWVzc2FnZSBwb3J0XG4gICAgICAvLyBwcm9jZXNzb3IgdGhyZWFkOiBvbmxvYWQgaXMgY2FsbGVkIHZpYSBtZXNzYWdlcG9ydCBoYW5kbGVyLCBhbmRcbiAgICAgIC8vIHBhc3NlZCBpbiB0aGUgbmV3IGJ1ZmZlciB0byBiZSBjb3BpZWQuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgY29uc3QgbWVtSWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggdGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGgsIHRydWUgKVxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFkZHJlc3M6J2NvcHlfbXVsdGknLFxuICAgICAgICAgIGlkOiAgICAgc3luLmlkLFxuICAgICAgICAgIGJ1ZmZlcjogdGhpcy5kYXRhLmJ1ZmZlcixcbiAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmKCB0eXBlb2Ygb25sb2FkID09PSAnZnVuY3Rpb24nICkgb25sb2FkKCB0aGlzLCBidWZmZXIgKVxuXG4gICAgICB9ZWxzZSBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICB0aGlzLmRhdGEuYnVmZmVyID0gYnVmZmVyIFxuXG4gICAgICAgIC8vIHNldCBkYXRhIG1lbW9yeSBzcGVjIGJlZm9yZSBpc3N1aW5nIG1lbW9yeSByZXF1ZXN0XG4gICAgICAgIHRoaXMuZGF0YUxlbmd0aCA9IHRoaXMuZGF0YS5tZW1vcnkudmFsdWVzLmxlbmd0aCA9IHRoaXMuZGF0YS5kaW0gPSB0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aFxuICAgICAgICB0aGlzLnpvbmUgPSBzeW4uem9uZXNbIHRoaXMuZmlsZW5hbWUgXVxuXG4gICAgICAgIC8vIHJlcXVlc3QgbWVtb3J5IHRvIGNvcHkgdGhlIGJ1ZmVyIG92ZXJcbiAgICAgICAgZy5nZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5kYXRhLm1lbW9yeSwgZmFsc2UgKVxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcC5zZXQoIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5tZW1vcnkudmFsdWVzLmlkeCApXG5cbiAgICAgICAgLy8gc2V0IGxvY2F0aW9uIG9mIGJ1ZmZlciAoZG9lcyBub3Qgd29yaylcbiAgICAgICAgdGhpcy5kYXRhSWR4ID0gdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMuaWR4XG5cbiAgICAgICAgc3luLmN1cnJlbnRTYW1wbGUgPSB0aGlzLmZpbGVuYW1lXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luLmxvYWRTYW1wbGUgPSBmdW5jdGlvbiggZmlsZW5hbWUsIF9fb25sb2FkLCBidWZmZXI9bnVsbCApIHtcbiAgICAgICd1c2UganNkc3AnXG5cbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1sgZmlsZW5hbWUgXSA9IHtcbiAgICAgICAgZGF0YUxlbmd0aDogbnVsbCxcbiAgICAgICAgZGF0YUlkeDogbnVsbCxcbiAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICBmaWxlbmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbmxvYWQgPSBzeW4ubG9hZEJ1ZmZlci5iaW5kKCBzYW1wbGVyICkgXG4gICAgICAvLyBwYXNzaW5nIGEgZmlsZW5hbWUgdG8gZGF0YSB3aWxsIGNhdXNlIGl0IHRvIGJlIGxvYWRlZCBpbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAgIC8vIG9ubG9hZCB3aWxsIHRoZW4gYmUgY2FsbGVkIHRvIHBhc3MgdGhlIGJ1ZmZlciBvdmVyIHRoZSBtZXNzYWdlcG9ydC4gSW4gdGhlXG4gICAgICAvLyBwcm9jZXNzb3IgdGhyZWFkLCBtYWtlIGEgcGxhY2Vob2xkZXIgdW50aWwgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgc2FtcGxlci5kYXRhID0gZy5kYXRhKCBidWZmZXIgIT09IG51bGwgPyBidWZmZXIgOiBmaWxlbmFtZSwgMSwgeyBvbmxvYWQgfSlcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkOyBhIHZhbGlkXG4gICAgICAgIC8vIGRhdGEgb2JqZWN0IGlzIG9ubHkgcmV0dXJuIGlmIHRoZSBmaWxlIGhhcyBiZWVuXG4gICAgICAgIC8vIHByZXZpb3VzbHkgbG9hZGVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBidWZmZXIgaGFzXG4gICAgICAgIC8vIGJlZW4gY2FjaGVkLlxuICAgICAgICBpZiggc2FtcGxlci5kYXRhIGluc3RhbmNlb2YgUHJvbWlzZSApIHtcbiAgICAgICAgICBzYW1wbGVyLmRhdGEudGhlbiggZCA9PiB7XG4gICAgICAgICAgICBzYW1wbGVyLmRhdGEgPSBkXG4gICAgICAgICAgICBtZW1vWyBmaWxlbmFtZSBdID0gc2FtcGxlci5kYXRhIFxuICAgICAgICAgICAgb25sb2FkKCBzYW1wbGVyLCBfX29ubG9hZCApXG4gICAgICAgICAgfSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gdXNpbmcgYSBjYWNoZWQgZGF0YSBidWZmZXIsIG5vIG5lZWRcbiAgICAgICAgICAvLyBmb3IgYXN5bmNocm9ub3VzIGxvYWRpbmcuXG4gICAgICAgICAgbWVtb1sgZmlsZW5hbWUgXSA9IHNhbXBsZXJcbiAgICAgICAgICBzYW1wbGVyLmRhdGFMZW5ndGggPSBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgb25sb2FkKCBzYW1wbGVyLCBfX29ubG9hZCApXG4gICAgICAgIH0gICAgIFxuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIG5vdCBzdXJlIGlmIGZpcnN0IGNhc2Ugd2lsbCBoYXBwZW4gd2l0aCBzb3VuZGZvbnRzIChpdCBkb2VzIHdpdGggcmVndWxhciBtdWx0aXNhbXBsZXIpXG4gICAgICAgIGlmKCBidWZmZXIgPT09IG51bGwgKSB7XG4gICAgICAgICAgc2FtcGxlci5kYXRhID0gZy5kYXRhKCBuZXcgRmxvYXQzMkFycmF5KCksIDEsIHsgb25sb2FkLCBmaWxlbmFtZSB9KVxuICAgICAgICAgIHNhbXBsZXIuZGF0YS5vbmxvYWQgPSBvbmxvYWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgc2FtcGxlci5kYXRhID0gZy5kYXRhKCBidWZmZXIsIDEsIHsgb25sb2FkLCBmaWxlbmFtZSB9KVxuICAgICAgICAgIC8vc2FtcGxlci5kYXRhLm9ubG9hZCA9IG9ubG9hZFxuICAgICAgICAgIG9ubG9hZCggYnVmZmVyLCBfX29ubG9hZCApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhbXBsZXJcbiAgICB9XG5cbiAgICBzeW4ubG9hZCA9IGZ1bmN0aW9uKCBzb3VuZE51bWJlcj0wLCBiYW5rSW5kZXg9MCApIHtcbiAgICAgICdubyBqc2RzcCdcblxuICAgICAgLy8gbmVlZCB0byBtZW1vaXplLi4uIGFscmVhZHkgc3RvcmluZyBpbiBzb3VuZGZvbnRzXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkgcmV0dXJuXG5cbiAgICAgIC8vIGluIGNhc2UgdXNlcnMgcGFzcyBuYW1lIG9mIHNvdW5kZm9udCBpbnN0ZWFkIG9mIG51bWJlclxuICAgICAgaWYoIHR5cGVvZiBzb3VuZE51bWJlciA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIGxldCBfX3NvdW5kTnVtYmVyID0gU291bmRmb250Lm5hbWVzLmluZGV4T2YoIHNvdW5kTnVtYmVyIClcbiAgICAgICAgaWYoIF9fc291bmROdW1iZXIgPT09IC0xICkge1xuICAgICAgICAgIF9fc291bmROdW1iZXIgPSAwXG4gICAgICAgICAgY29uc29sZS53YXJuKCBgVGhlICR7c291bmROdW1iZXJ9IFNvdW5kZm9udCBjYW4ndCBiZSBmb3VuZC4gVXNpbmcgUGlhbm8gaW5zdGVhZC5gIClcbiAgICAgICAgfVxuICAgICAgICBzb3VuZE51bWJlciA9IF9fc291bmROdW1iZXJcbiAgICAgIH1cblxuICAgICAgbGV0IG51bSA9IChzb3VuZE51bWJlcikgKyAnMCdcbiAgICAgIGlmKCBzb3VuZE51bWJlciA8IDEwMCApIG51bSA9ICcwJytudW1cbiAgICAgIGlmKCBzb3VuZE51bWJlciA8IDEwICkgIG51bSA9ICcwJytudW1cblxuICAgICAgZmV0Y2goIGAke1NvdW5kZm9udC5yZXNvdXJjZVBhdGh9JHtudW19XyR7YmFua3NbYmFua0luZGV4XX0uc2YyLmpzb25gIClcbiAgICAgICAgLnRoZW4oIHJlcyA9PiByZXMuanNvbigpIClcbiAgICAgICAgLnRoZW4oIGpzb24gPT4ge1xuICAgICAgICAgIGNvbnN0IHpvbmVzID0gc291bmRmb250c1sgc291bmROdW1iZXIgXSA9IGpzb24uem9uZXNcbiAgICAgICAgICB0aGlzLnpvbmVzID0gem9uZXNcbiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHpvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB6b25lID0gem9uZXNbaV1cbiAgICAgICAgICAgIGNvbnN0IGFiID0gR2liYmVyaXNoLnV0aWxpdGllcy5iYXNlNjQuZGVjb2RlQXJyYXlCdWZmZXIoIHpvbmUuZmlsZSApXG4gICAgICAgICAgICBnLnV0aWxpdGllcy5jdHguZGVjb2RlQXVkaW9EYXRhKCBhYiwgYnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgem9uZS5zYW1wbGVyID0gc3luLmxvYWRTYW1wbGUoIGksIG51bGwsIGJ1ZmZlciApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvL3Byb3BzLmZpbGVzLmZvckVhY2goIGZpbGVuYW1lID0+IHN5bi5sb2FkU2FtcGxlKCBmaWxlbmFtZSApIClcblxuICAgIHN5bi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICAndXNlIGpzZHNwJ1xuICAgICAgXG4gICAgICBjb25zdCBncmFwaHMgPSB2b2ljZXMubWFwKCB2b2ljZSA9PiB2b2ljZS5ncmFwaCApXG4gICAgICBjb25zdCBsZWZ0ID0gZy5hZGQoIC4uLnZvaWNlcy5tYXAoIHZvaWNlID0+IHZvaWNlLmdyYXBoWzBdICkgKVxuICAgICAgY29uc3QgcmlnaHQgPSBnLmFkZCggLi4udm9pY2VzLm1hcCggdm9pY2UgPT4gdm9pY2UuZ3JhcGhbMV0gKSApXG4gICAgICBjb25zdCBnYWluID0gZy5pbiggJ2dhaW4nIClcbiAgICAgIHN5bi5ncmFwaCA9IFsgbGVmdCAqIGdhaW4sIHJpZ2h0ICogZ2FpbiBdXG5cbiAgICAgIGlmKCBzeW4ucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgY29uc3QgcGFubmVyID0gZy5wYW4oIHN5bi5ncmFwaFswXSwgc3luLmdyYXBoWzFdLCBnLmluKCAncGFuJyApICkgXG4gICAgICAgIHN5bi5ncmFwaCA9IFsgcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgICAgc3luLFxuICAgICAgc3luLmdyYXBoLFxuICAgICAgWydpbnN0cnVtZW50cycsJ3NvdW5kZm9udCddLCBcbiAgICAgIHByb3BzIFxuICAgICkgXG5cbiAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gdHJ1ZVxuICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSBmYWxzZVxuXG4gICAgb3V0LnZvaWNlcyA9IHZvaWNlc1xuICAgIG91dC5zYW1wbGVycyA9IHNhbXBsZXJzXG5cbiAgICBHaWJiZXJpc2gucHJveHlFbmFibGVkID0gdHJ1ZVxuICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSBmYWxzZVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgU291bmRmb250LmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgcGFuOiAuNSxcbiAgICByYXRlOiAxLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBzaG91bGRMb29wOmZhbHNlLFxuICAgIGxvb3BzOiAwLFxuICAgIHN0YXJ0OjAsXG4gICAgZW5kOjEsXG4gICAgYnVmZmVyTGVuZ3RoOi05OTk5OTk5OTksXG4gICAgbG91ZG5lc3M6MSxcbiAgICBtYXhWb2ljZXM6NSwgXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgU291bmRmb250LnJlc291cmNlUGF0aCA9ICdyZXNvdXJjZXMvc291bmRmb250cy8nXG4gIFNvdW5kZm9udC5uYW1lcyA9IFtcbiAgICBcIkFjb3VzdGljIEdyYW5kIFBpYW5vXCIsXG4gICAgXCJCcmlnaHQgQWNvdXN0aWMgUGlhbm9cIixcbiAgICBcIkVsZWN0cmljIEdyYW5kIFBpYW5vXCIsXG4gICAgXCJIb25reS10b25rIFBpYW5vXCIsXG4gICAgXCJFbGVjdHJpYyBQaWFubyAxXCIsXG4gICAgXCJFbGVjdHJpYyBQaWFubyAyXCIsXG4gICAgXCJIYXJwc2ljaG9yZFwiLFxuICAgIFwiQ2xhdmlcIixcbiAgICBcIkNlbGVzdGFcIixcbiAgICBcIkdsb2NrZW5zcGllbFwiLFxuICAgIFwiTXVzaWMgQm94XCIsXG4gICAgXCJWaWJyYXBob25lXCIsXG4gICAgXCJNYXJpbWJhXCIsXG4gICAgXCJYeWxvcGhvbmVcIixcbiAgICBcIlR1YnVsYXIgQmVsbHNcIixcbiAgICBcIkR1bGNpbWVyXCIsXG4gICAgXCJEcmF3YmFyIE9yZ2FuXCIsXG4gICAgXCJQZXJjdXNzaXZlIE9yZ2FuXCIsXG4gICAgXCJSb2NrIE9yZ2FuXCIsXG4gICAgXCJDaHVyY2ggT3JnYW5cIixcbiAgICBcIlJlZWQgT3JnYW5cIixcbiAgICBcIkFjY29yZGlvblwiLFxuICAgIFwiSGFybW9uaWNhXCIsXG4gICAgXCJUYW5nbyBBY2NvcmRpb25cIixcbiAgICBcIkFjb3VzdGljIEd1aXRhciAobnlsb24pXCIsXG4gICAgXCJBY291c3RpYyBHdWl0YXIgKHN0ZWVsKVwiLFxuICAgIFwiRWxlY3RyaWMgR3VpdGFyIChqYXp6KVwiLFxuICAgIFwiRWxlY3RyaWMgR3VpdGFyIChjbGVhbilcIixcbiAgICBcIkVsZWN0cmljIEd1aXRhciAobXV0ZWQpXCIsXG4gICAgXCJPdmVyZHJpdmVuIEd1aXRhclwiLFxuICAgIFwiRGlzdG9ydGlvbiBHdWl0YXJcIixcbiAgICBcIkd1aXRhciBoYXJtb25pY3NcIixcbiAgICBcIkFjb3VzdGljIEJhc3NcIixcbiAgICBcIkVsZWN0cmljIEJhc3MgKGZpbmdlcilcIixcbiAgICBcIkVsZWN0cmljIEJhc3MgKHBpY2spXCIsXG4gICAgXCJGcmV0bGVzcyBCYXNzXCIsXG4gICAgXCJTbGFwIEJhc3MgMVwiLFxuICAgIFwiU2xhcCBCYXNzIDJcIixcbiAgICBcIlN5bnRoIEJhc3MgMVwiLFxuICAgIFwiU3ludGggQmFzcyAyXCIsXG4gICAgXCJWaW9saW5cIixcbiAgICBcIlZpb2xhXCIsXG4gICAgXCJDZWxsb1wiLFxuICAgIFwiQ29udHJhYmFzc1wiLFxuICAgIFwiVHJlbW9sbyBTdHJpbmdzXCIsXG4gICAgXCJQaXp6aWNhdG8gU3RyaW5nc1wiLFxuICAgIFwiT3JjaGVzdHJhbCBIYXJwXCIsXG4gICAgXCJUaW1wYW5pXCIsXG4gICAgXCJTdHJpbmcgRW5zZW1ibGUgMVwiLFxuICAgIFwiU3RyaW5nIEVuc2VtYmxlIDJcIixcbiAgICBcIlN5bnRoU3RyaW5ncyAxXCIsXG4gICAgXCJTeW50aFN0cmluZ3MgMlwiLFxuICAgIFwiQ2hvaXIgQWFoc1wiLFxuICAgIFwiVm9pY2UgT29oc1wiLFxuICAgIFwiU3ludGggVm9pY2VcIixcbiAgICBcIk9yY2hlc3RyYSBIaXRcIixcbiAgICBcIlRydW1wZXRcIixcbiAgICBcIlRyb21ib25lXCIsXG4gICAgXCJUdWJhXCIsXG4gICAgXCJNdXRlZCBUcnVtcGV0XCIsXG4gICAgXCJGcmVuY2ggSG9yblwiLFxuICAgIFwiQnJhc3MgU2VjdGlvblwiLFxuICAgIFwiU3ludGhCcmFzcyAxXCIsXG4gICAgXCJTeW50aEJyYXNzIDJcIixcbiAgICBcIlNvcHJhbm8gU2F4XCIsXG4gICAgXCJBbHRvIFNheFwiLFxuICAgIFwiVGVub3IgU2F4XCIsXG4gICAgXCJCYXJpdG9uZSBTYXhcIixcbiAgICBcIk9ib2VcIixcbiAgICBcIkVuZ2xpc2ggSG9yblwiLFxuICAgIFwiQmFzc29vblwiLFxuICAgIFwiQ2xhcmluZXRcIixcbiAgICBcIlBpY2NvbG9cIixcbiAgICBcIkZsdXRlXCIsXG4gICAgXCJSZWNvcmRlclwiLFxuICAgIFwiUGFuIEZsdXRlXCIsXG4gICAgXCJCbG93biBCb3R0bGVcIixcbiAgICBcIlNoYWt1aGFjaGlcIixcbiAgICBcIldoaXN0bGVcIixcbiAgICBcIk9jYXJpbmFcIixcbiAgICBcIkxlYWQgMSAoc3F1YXJlKVwiLFxuICAgIFwiTGVhZCAyIChzYXd0b290aClcIixcbiAgICBcIkxlYWQgMyAoY2FsbGlvcGUpXCIsXG4gICAgXCJMZWFkIDQgKGNoaWZmKVwiLFxuICAgIFwiTGVhZCA1IChjaGFyYW5nKVwiLFxuICAgIFwiTGVhZCA2ICh2b2ljZSlcIixcbiAgICBcIkxlYWQgNyAoZmlmdGhzKVwiLFxuICAgIFwiTGVhZCA4IChiYXNzICsgbGVhZClcIixcbiAgICBcIlBhZCAxIChuZXcgYWdlKVwiLFxuICAgIFwiUGFkIDIgKHdhcm0pXCIsXG4gICAgXCJQYWQgMyAocG9seXN5bnRoKVwiLFxuICAgIFwiUGFkIDQgKGNob2lyKVwiLFxuICAgIFwiUGFkIDUgKGJvd2VkKVwiLFxuICAgIFwiUGFkIDYgKG1ldGFsbGljKVwiLFxuICAgIFwiUGFkIDcgKGhhbG8pXCIsXG4gICAgXCJQYWQgOCAoc3dlZXApXCIsXG4gICAgXCJGWCAxIChyYWluKVwiLFxuICAgIFwiRlggMiAoc291bmR0cmFjaylcIixcbiAgICBcIkZYIDMgKGNyeXN0YWwpXCIsXG4gICAgXCJGWCA0IChhdG1vc3BoZXJlKVwiLFxuICAgIFwiRlggNSAoYnJpZ2h0bmVzcylcIixcbiAgICBcIkZYIDYgKGdvYmxpbnMpXCIsXG4gICAgXCJGWCA3IChlY2hvZXMpXCIsXG4gICAgXCJGWCA4IChzY2ktZmkpXCIsXG4gICAgXCJTaXRhclwiLFxuICAgIFwiQmFuam9cIixcbiAgICBcIlNoYW1pc2VuXCIsXG4gICAgXCJLb3RvXCIsXG4gICAgXCJLYWxpbWJhXCIsXG4gICAgXCJCYWcgcGlwZVwiLFxuICAgIFwiRmlkZGxlXCIsXG4gICAgXCJTaGFuYWlcIixcbiAgICBcIlRpbmtsZSBCZWxsXCIsXG4gICAgXCJBZ29nb1wiLFxuICAgIFwiU3RlZWwgRHJ1bXNcIixcbiAgICBcIldvb2RibG9ja1wiLFxuICAgIFwiVGFpa28gRHJ1bVwiLFxuICAgIFwiTWVsb2RpYyBUb21cIixcbiAgICBcIlN5bnRoIERydW1cIixcbiAgICBcIlJldmVyc2UgQ3ltYmFsXCIsXG4gICAgXCJHdWl0YXIgRnJldCBOb2lzZVwiLFxuICAgIFwiQnJlYXRoIE5vaXNlXCIsXG4gICAgXCJTZWFzaG9yZVwiLFxuICAgIFwiQmlyZCBUd2VldFwiLFxuICAgIFwiVGVsZXBob25lIFJpbmdcIixcbiAgICBcIkhlbGljb3B0ZXJcIixcbiAgICBcIkFwcGxhdXNlXCIsXG4gICAgXCJHdW5zaG90XCJcbiAgXVxuXG4gIFNvdW5kZm9udC5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS50YWJsZSggU291bmRmb250Lm5hbWVzIClcbiAgfVxuXG4gIHJldHVybiBTb3VuZGZvbnRcbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgU3ludGggPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBzeW4gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcblxuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgbG91ZG5lc3MgID0gZy5pbiggJ2xvdWRuZXNzJyApLCBcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgZ2xpZGUgPSBnLm1heCggMSwgZy5pbiggJ2dsaWRlJyApICksXG4gICAgICAgICAgc2xpZGluZ0ZyZXEgPSBnLnNsaWRlKCBmcmVxdWVuY3ksIGdsaWRlLCBnbGlkZSApLFxuICAgICAgICAgIGF0dGFjayA9IGcuaW4oICdhdHRhY2snICksIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIHN1c3RhaW4gPSBnLmluKCAnc3VzdGFpbicgKSwgc3VzdGFpbkxldmVsID0gZy5pbiggJ3N1c3RhaW5MZXZlbCcgKSxcbiAgICAgICAgICByZWxlYXNlID0gZy5pbiggJ3JlbGVhc2UnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIFN5bnRoLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBPYmplY3QuYXNzaWduKCBzeW4sIHByb3BzIClcblxuICAgIHN5bi5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBvc2MgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggc3luLndhdmVmb3JtLCBzbGlkaW5nRnJlcSwgc3luLmFudGlhbGlhcyApXG5cbiAgICAgIGNvbnN0IGVudiA9IEdpYmJlcmlzaC5lbnZlbG9wZXMuZmFjdG9yeSggXG4gICAgICAgIHByb3BzLnVzZUFEU1IsIFxuICAgICAgICBwcm9wcy5zaGFwZSwgXG4gICAgICAgIGF0dGFjaywgZGVjYXksIFxuICAgICAgICBzdXN0YWluLCBzdXN0YWluTGV2ZWwsIFxuICAgICAgICByZWxlYXNlLCBcbiAgICAgICAgcHJvcHMudHJpZ2dlclJlbGVhc2VcbiAgICAgIClcblxuXG4gICAgICAvLyBzeW4uZW52ID0gZW52XG4gICAgICAvLyBiZWxvdyBkb2Vzbid0IHdvcmsgYXMgaXQgYXR0ZW1wdHMgdG8gYXNzaWduIHRvIHJlbGVhc2UgcHJvcGVydHkgdHJpZ2dlcmluZyBjb2RlZ2VuLi4uXG4gICAgICBzeW4uYWR2YW5jZSA9ICgpPT4geyBlbnYucmVsZWFzZSgpIH1cblxuICAgICAge1xuICAgICAgICAndXNlIGpzZHNwJ1xuICAgICAgICBsZXQgb3NjV2l0aEVudiA9IG9zYyAqIGVudiAqIGxvdWRuZXNzICogdHJpZ2dlckxvdWRuZXNzLFxuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IGcuaW4oJ3NhdHVyYXRpb24nKSxcbiAgICAgICAgICAgIHBhbm5lclxuXG4gICAgICAgIC8vIDE2IGlzIGFuIHVuZm9ydHVuYXRlIGVtcGlyaWNhbGx5IGRlcml2ZWQgbWFnaWMgbnVtYmVyLi4uXG4gICAgICAgIGNvbnN0IGJhc2VDdXRvZmZGcmVxID0gZy5pbignY3V0b2ZmJykgKiAoIGZyZXF1ZW5jeSAvICAoIGcuZ2VuLnNhbXBsZXJhdGUgLyAxNiApICkgXG4gICAgICAgIGNvbnN0IGN1dG9mZiA9IGcubWluKCBiYXNlQ3V0b2ZmRnJlcSAqIGcucG93KCAyLCBnLmluKCdmaWx0ZXJNdWx0JykgKiBsb3VkbmVzcyAqIHRyaWdnZXJMb3VkbmVzcyApICogZW52LCAuOTk1ICkgXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkT3NjID0gR2liYmVyaXNoLmZpbHRlcnMuZmFjdG9yeSggb3NjV2l0aEVudiwgY3V0b2ZmLCBzYXR1cmF0aW9uLCBwcm9wcyApXG5cbiAgICAgICAgbGV0IHN5bnRoV2l0aEdhaW4gPSBmaWx0ZXJlZE9zYyAqIGcuaW4oICdnYWluJyApXG4gICAgICAgIFxuICAgICAgICAvLyBYWFggVGhpcyBsaW5lIGhhcyB0byBiZSBoZXJlIGZvciBjb3JyZWN0IGNvZGUgZ2VuZXJhdGlvbiB0byB3b3JrIHdoZW5cbiAgICAgICAgLy8gc2F0dXJhdGlvbiBpcyBub3QgYmVpbmcgdXNlZC4uLiBvYnZpb3VzbHkgdGhpcyBzaG91bGQgY2FuY2VsIG91dC4gXG4gICAgICAgIGlmKCBzeW4uZmlsdGVyTW9kZWwgIT09IDIgKSBzeW50aFdpdGhHYWluID0gc3ludGhXaXRoR2FpbiArIHNhdHVyYXRpb24gLSBzYXR1cmF0aW9uXG4gICAgXG4gICAgICAgIGlmKCBzeW4ucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgICBwYW5uZXIgPSBnLnBhbiggc3ludGhXaXRoR2Fpbiwgc3ludGhXaXRoR2FpbiwgZy5pbiggJ3BhbicgKSApIFxuICAgICAgICAgIHN5bi5ncmFwaCA9IFsgcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgICAgICAgc3luLmlzU3RlcmVvID0gdHJ1ZVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzeW4uZ3JhcGggPSBzeW50aFdpdGhHYWluXG4gICAgICAgICAgc3luLmlzU3RlcmVvID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bi5lbnYgPSBlbnZcbiAgICAgICAgc3luLm9zYyA9IG9zY1xuICAgICAgICBzeW4uZmlsdGVyID0gZmlsdGVyZWRPc2NcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudlxuXG4gICAgfVxuICAgIFxuICAgIHN5bi5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ3dhdmVmb3JtJywgJ2FudGlhbGlhcycsICdmaWx0ZXJNb2RlbCcsJ2ZpbHRlck1vZGUnLCAndXNlQURTUicsICdzaGFwZScgXVxuICAgIGNvbnN0IGVudiA9IHN5bi5fX2NyZWF0ZUdyYXBoKClcblxuICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzeW4sIHN5bi5ncmFwaCwgWydpbnN0cnVtZW50cycsICdzeW50aCddLCBwcm9wcywgbnVsbCwgdHJ1ZSwgWydzYXR1cmF0aW9uJ10gIClcblxuICAgIG91dC5lbnYuYWR2YW5jZSA9IG91dC5hZHZhbmNlIFxuXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIFxuICBTeW50aC5kZWZhdWx0cyA9IHtcbiAgICB3YXZlZm9ybTonc2F3JyxcbiAgICBhdHRhY2s6IDQ0LFxuICAgIGRlY2F5OiAyMjA1MCxcbiAgICBzdXN0YWluOjQ0MTAwLFxuICAgIHN1c3RhaW5MZXZlbDouNixcbiAgICByZWxlYXNlOjIyMDUwLFxuICAgIHVzZUFEU1I6ZmFsc2UsXG4gICAgc2hhcGU6J2xpbmVhcicsXG4gICAgdHJpZ2dlclJlbGVhc2U6ZmFsc2UsXG4gICAgZ2FpbjogLjUsXG4gICAgcHVsc2V3aWR0aDouMjUsXG4gICAgZnJlcXVlbmN5OjIyMCxcbiAgICBwYW46IC41LFxuICAgIGFudGlhbGlhczpmYWxzZSxcbiAgICBwYW5Wb2ljZXM6ZmFsc2UsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxLFxuICAgIGdsaWRlOjEsXG4gICAgc2F0dXJhdGlvbjoxLFxuICAgIGZpbHRlck11bHQ6MixcbiAgICBROi4yNSxcbiAgICBjdXRvZmY6LjUsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNb2RlOjBcbiAgfVxuXG4gIC8vIGRvIG5vdCBpbmNsdWRlIHZlbG9jaXR5LCB3aGljaCBzaG91ZGwgYWx3YXlzIGJlIHBlciB2b2ljZVxuICBsZXQgUG9seVN5bnRoID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggU3ludGgsIFsnZnJlcXVlbmN5JywnYXR0YWNrJywnZGVjYXknLCdwdWxzZXdpZHRoJywncGFuJywnZ2FpbicsJ2dsaWRlJywgJ3NhdHVyYXRpb24nLCAnZmlsdGVyTXVsdCcsICdRJywgJ2N1dG9mZicsICdyZXNvbmFuY2UnLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywgJ3dhdmVmb3JtJywgJ2ZpbHRlck1vZGUnLCAnX190cmlnZ2VyTG91ZG5lc3MnLCAnbG91ZG5lc3MnXSApIFxuICBQb2x5U3ludGguZGVmYXVsdHMgPSBTeW50aC5kZWZhdWx0c1xuXG4gIHJldHVybiBbIFN5bnRoLCBQb2x5U3ludGggXVxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBUb20gPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBsZXQgdG9tID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApXG4gICAgXG4gICAgY29uc3QgZGVjYXkgICA9IGcuaW4oICdkZWNheScgKSxcbiAgICAgICAgICBwaXRjaCAgID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBnYWluICAgID0gZy5pbiggJ2dhaW4nICksXG4gICAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBUb20uZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgY29uc3QgdHJpZ2dlciA9IGcuYmFuZygpLFxuICAgICAgICAgIGltcHVsc2UgPSBnLm11bCggdHJpZ2dlciwgMSApLFxuICAgICAgICAgIGVnID0gZy5kZWNheSggZy5tdWwoIGRlY2F5LCBnLmdlbi5zYW1wbGVyYXRlICogMiApLCB7IGluaXRWYWx1ZTowIH0gKSwgXG4gICAgICAgICAgYnBmID0gZy5tdWwoIGcuc3ZmKCBpbXB1bHNlLCBwaXRjaCwgLjAxNzUsIDIsIGZhbHNlICksIDEwICksXG4gICAgICAgICAgbm9pc2UgPSBnLmd0cCggZy5ub2lzZSgpLCAwICksIC8vIHJlY3RpZnkgbm9pc2VcbiAgICAgICAgICBlbnZlbG9wZWROb2lzZSA9IGcubXVsKCBub2lzZSwgZWcgKSxcbiAgICAgICAgICBscGYgPSBnLm11bCggZy5zdmYoIGVudmVsb3BlZE5vaXNlLCAxMjAsIC41LCAwLCBmYWxzZSApLCAyLjUgKSxcbiAgICAgICAgICBvdXQgPSBnLm11bCggZy5hZGQoIGJwZiwgbHBmICksIGcubXVsKCBnYWluLCBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApICkgKVxuXG4gICAgdG9tLmVudiA9IHtcbiAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBlZy50cmlnZ2VyKClcbiAgICAgICAgdHJpZ2dlci50cmlnZ2VyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b20uaXNTdGVyZW8gPSBmYWxzZVxuXG4gICAgdG9tID0gR2liYmVyaXNoLmZhY3RvcnkoIHRvbSwgb3V0LCBbJ2luc3RydW1lbnRzJywgJ3RvbSddLCBwcm9wcyAgKVxuICAgIFxuICAgIHJldHVybiB0b21cbiAgfVxuICBcbiAgVG9tLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgZGVjYXk6LjcsXG4gICAgZnJlcXVlbmN5OjEyMCxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcbiAgfVxuXG4gIHJldHVybiBUb21cbn1cbiIsImNvbnN0IHVnZW5wcm90byA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKCksXG4gICAgIF9fcHJveHkgICAgID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKSxcbiAgICAgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG5cbiAgY29uc3QgY3JlYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwLCBpZCApIHtcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IDI7IGkrKyApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggcCwgaSwge1xuICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gcC5pbnB1dHNbIGkgXSB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIHAuaW5wdXRzWyBpIF0gPSB2XG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgICAgICAgYWRkcmVzczonYWRkVG9Qcm9wZXJ0eScsIFxuICAgICAgICAgICAgICAgIG9iamVjdDppZCxcbiAgICAgICAgICAgICAgICBuYW1lOidpbnB1dHMnLFxuICAgICAgICAgICAgICAgIGtleTppLFxuICAgICAgICAgICAgICAgIHZhbHVlOnZcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgICAgICAgYWRkcmVzczonYWRkT2JqZWN0VG9Qcm9wZXJ0eScsIFxuICAgICAgICAgICAgICAgIG9iamVjdDppZCxcbiAgICAgICAgICAgICAgICBuYW1lOidpbnB1dHMnLFxuICAgICAgICAgICAgICAgIGtleTppLFxuICAgICAgICAgICAgICAgIHZhbHVlOnYuaWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBhZGRyZXNzOidkaXJ0eScsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBCaW5vcHMgPSB7XG4gICAgZXhwb3J0KCBvYmogKSB7XG4gICAgICBmb3IoIGxldCBrZXkgaW4gQmlub3BzICkge1xuICAgICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyApIHtcbiAgICAgICAgICBvYmpbIGtleSBdID0gQmlub3BzWyBrZXkgXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBBZGQoIC4uLmFyZ3MgKSB7XG4gICAgICBjb25zdCBpZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG4gICAgICBjb25zdCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggdWdlbnByb3RvIClcbiAgICAgIGNvbnN0IGlzU3RlcmVvID0gR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMF0gKSB8fCBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1sxXSApXG4gICAgICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IGlzb3A6dHJ1ZSwgb3A6JysnLCBpbnB1dHM6YXJncywgdWdlbk5hbWU6J2FkZCcgKyBpZCwgaWQsIGlzU3RlcmVvIH0gKVxuICAgICAgXG4gICAgICBjb25zdCBwID0gcHJveHkoIFsnYmlub3BzJywnQWRkJ10sIHsgaXNvcDp0cnVlLCBpbnB1dHM6YXJncyB9LCB1Z2VuIClcbiAgICAgIGNyZWF0ZVByb3BlcnRpZXMoIHAsIGlkIClcblxuICAgICAgcmV0dXJuIHBcbiAgICB9LFxuXG4gICAgU3ViKCAuLi5hcmdzICkge1xuICAgICAgY29uc3QgaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuICAgICAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHVnZW5wcm90byApXG4gICAgICBjb25zdCBpc1N0ZXJlbyA9IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzBdICkgfHwgR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMV0gKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBpc29wOnRydWUsIG9wOictJywgaW5wdXRzOmFyZ3MsIHVnZW5OYW1lOidzdWInICsgaWQsIGlkLCBpc1N0ZXJlbyB9IClcblxuICAgICAgcmV0dXJuIHByb3h5KCBbJ2Jpbm9wcycsJ1N1YiddLCB7IGlzb3A6dHJ1ZSwgaW5wdXRzOmFyZ3MgfSwgdWdlbiApXG4gICAgfSxcblxuICAgIE11bCggLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IGlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcbiAgICAgIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCB1Z2VucHJvdG8gKVxuICAgICAgY29uc3QgaXNTdGVyZW8gPSBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1swXSApIHx8IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzFdIClcbiAgICAgIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgaXNvcDp0cnVlLCBvcDonKicsIGlucHV0czphcmdzLCB1Z2VuTmFtZTonbXVsJyArIGlkLCBpZCwgaXNTdGVyZW8gfSApXG5cbiAgICAgIGNvbnN0IHAgPSBwcm94eSggWydiaW5vcHMnLCdNdWwnXSwgeyBpc29wOnRydWUsIGlucHV0czphcmdzIH0sIHVnZW4gKVxuICAgICAgY3JlYXRlUHJvcGVydGllcyggcCwgaWQgKVxuICAgICAgcmV0dXJuIHBcbiAgICB9LFxuXG4gICAgRGl2KCAuLi5hcmdzICkge1xuICAgICAgY29uc3QgaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuICAgICAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHVnZW5wcm90byApXG4gICAgICBjb25zdCBpc1N0ZXJlbyA9IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzBdICkgfHwgR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMV0gKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBpc29wOnRydWUsIG9wOicvJywgaW5wdXRzOmFyZ3MsIHVnZW5OYW1lOidkaXYnICsgaWQsIGlkLCBpc1N0ZXJlb30gKVxuICAgIFxuICAgICAgY29uc3QgcCA9IHByb3h5KCBbJ2Jpbm9wcycsJ0RpdiddLCB7IGlzb3A6dHJ1ZSwgaW5wdXRzOmFyZ3MgfSwgdWdlbiApXG4gICAgICBjcmVhdGVQcm9wZXJ0aWVzKCBwLCBpZCApXG5cbiAgICAgIHJldHVybiBwXG4gICAgfSxcblxuICAgIE1vZCggLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IGlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcbiAgICAgIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCB1Z2VucHJvdG8gKVxuICAgICAgY29uc3QgaXNTdGVyZW8gPSBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1swXSApIHx8IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzFdIClcbiAgICAgIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgaXNvcDp0cnVlLCBvcDonJScsIGlucHV0czphcmdzLCB1Z2VuTmFtZTonbW9kJyArIGlkLCBpZCwgaXNTdGVyZW99IClcblxuICAgICAgY29uc3QgcCA9IHByb3h5KCBbJ2Jpbm9wcycsJ01vZCddLCB7IGlzb3A6dHJ1ZSwgaW5wdXRzOmFyZ3MgfSwgdWdlbiApXG4gICAgICBjcmVhdGVQcm9wZXJ0aWVzKCBwLCBpZCApXG5cbiAgICAgIHJldHVybiBwXG4gICAgfSwgICBcbiAgfVxuXG4gIGZvciggbGV0IGtleSBpbiBCaW5vcHMgKSB7XG4gICAgQmlub3BzWyBrZXkgXS5kZWZhdWx0cyA9IHsgMDowLCAxOjAgfVxuICB9XG5cbiAgcmV0dXJuIEJpbm9wc1xufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpLFxuICAgIF9fcHJveHk9IHJlcXVpcmUoICcuLi93b3JrbGV0UHJveHkuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG4gIGNvbnN0IEJ1cyA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuXG4gIE9iamVjdC5hc3NpZ24oIEJ1cywge1xuICAgIGdhaW46IHtcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgdGhpcy5tdWwuaW5wdXRzWyAxIF0gPSB2XG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGhpcyApXG4gICAgICB9LFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWxbIDEgXVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfX2FkZElucHV0KCBpbnB1dCApIHtcbiAgICAgIHRoaXMuc3VtLmlucHV0cy5wdXNoKCBpbnB1dCApXG4gICAgICBHaWJiZXJpc2guZGlydHkoIHRoaXMgKVxuICAgIH0sXG5cbiAgICBjcmVhdGUoIF9wcm9wcyApIHtcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgQnVzLmRlZmF1bHRzLCB7IGlucHV0czpbMF0gfSwgX3Byb3BzIClcblxuICAgICAgLy8gTVVTVCBQUkVWRU5UIFBST1hZXG4gICAgICAvLyBPdGhoZXJ3aXNlIHRoZXNlIGJpbm9wcyBhcmUgY3JlYXRlZCBpbiB0aGUgd29ya2xldCBhbmQgc2VudFxuICAgICAgLy8gYWNyb3NzIHRoZSB0aHJlYWQgdG8gYmUgaW5zdGFudGlhdGVkLCBhbmQgdGhlbiBpbnN0YW50aWF0ZWQgYWdhaW5cbiAgICAgIC8vIHdoZW4gdGhlIGJ1cyBpcyBjcmVhdGVkIGluIHRoZSBwcm9jZXNzb3IgdGhyZWFkLCBtZXNzaW5nIHVwIHRoZSB2YXJpb3VzXG4gICAgICAvLyB1aWRzIGludm9sdmVkLiBCeSBwcmV2ZW50aW5nIHByb3h5aW5nIHRoZSBiaW5vcHMgYXJlIG9ubHkgY3JlYXRlZFxuICAgICAgLy8gYSBzaW5nbGUgdGltZSB3aGVuIHRoZSBidXMgaXMgc2VudCBhY3Jvc3MgdGhlIHRocmVhZC5cbiAgICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSB0cnVlXG4gICAgICBjb25zdCBzdW0gPSBHaWJiZXJpc2guYmlub3BzLkFkZCggLi4ucHJvcHMuaW5wdXRzIClcbiAgICAgIGNvbnN0IG11bCA9IEdpYmJlcmlzaC5iaW5vcHMuTXVsKCBzdW0sIHByb3BzLmdhaW4gKVxuICAgICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IGZhbHNlXG5cbiAgICAgIGNvbnN0IGdyYXBoID0gR2liYmVyaXNoLlBhbm5lcih7IGlucHV0Om11bCwgcGFuOiBwcm9wcy5wYW4gfSlcblxuICAgICAgZ3JhcGguc3VtID0gc3VtXG4gICAgICBncmFwaC5tdWwgPSBtdWxcbiAgICAgIGdyYXBoLmRpc2Nvbm5lY3RVZ2VuID0gQnVzLmRpc2Nvbm5lY3RVZ2VuXG5cbiAgICAgIGdyYXBoLl9fcHJvcGVydGllc19fID0gcHJvcHNcblxuICAgICAgY29uc3Qgb3V0ID0gcHJvcHMuX191c2VQcm94eV9fID09PSB0cnVlID8gcHJveHkoIFsnQnVzJ10sIHByb3BzLCBncmFwaCApIDogZ3JhcGhcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvdXQsICdnYWluJywgQnVzLmdhaW4gKVxuXG4gICAgICBpZiggZmFsc2UgJiYgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9PT0gZmFsc2UgJiYgR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICBhZGRyZXNzOidhZGQnLFxuICAgICAgICAgIG5hbWU6WydCdXMnXSxcbiAgICAgICAgICBwcm9wcywgXG4gICAgICAgICAgaWQ6Z3JhcGguaWRcbiAgICAgICAgfVxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBtZXRhIClcbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgICAgIGFkZHJlc3M6J21ldGhvZCcsIFxuICAgICAgICAgIG9iamVjdDpncmFwaC5pZCxcbiAgICAgICAgICBuYW1lOidjb25uZWN0JyxcbiAgICAgICAgICBhcmdzOltdXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQgXG4gICAgfSxcblxuICAgIGRpc2Nvbm5lY3RVZ2VuKCB1Z2VuICkge1xuICAgICAgbGV0IHJlbW92ZUlkeCA9IHRoaXMuc3VtLmlucHV0cy5pbmRleE9mKCB1Z2VuIClcblxuICAgICAgaWYoIHJlbW92ZUlkeCAhPT0gLTEgKSB7XG4gICAgICAgIHRoaXMuc3VtLmlucHV0cy5zcGxpY2UoIHJlbW92ZUlkeCwgMSApXG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGhpcyApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGNhbid0IGluY2x1ZGUgaW5wdXRzIGhlcmUgYXMgaXQgd2lsbCBiZSBzdWNrZWQgdXAgYnkgR2liYmVyLFxuICAgIC8vIGluc3RlYWQgcGFzcyBkdXJpbmcgT2JqZWN0LmFzc2lnbigpIGFmdGVyIGRlZmF1bHRzLlxuICAgIGRlZmF1bHRzOiB7IGdhaW46MSwgcGFuOi41LCBfX3VzZVByb3h5X186dHJ1ZSB9XG4gIH0pXG5cbiAgY29uc3QgY29uc3RydWN0b3IgPSBCdXMuY3JlYXRlLmJpbmQoIEJ1cyApXG4gIGNvbnN0cnVjdG9yLmRlZmF1bHRzID0gQnVzLmRlZmF1bHRzXG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yXG59XG5cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKCksXG4gICAgICBfX3Byb3h5ID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgQnVzMiA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG5cbiAgbGV0IGJ1ZmZlckwsIGJ1ZmZlclJcbiAgXG4gIE9iamVjdC5hc3NpZ24oIEJ1czIsIHsgXG4gICAgY3JlYXRlKCBfX3Byb3BzICkge1xuXG4gICAgICBpZiggYnVmZmVyTCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBjb25zdCBwID0gZy5wYW4oKVxuICAgICAgICBcbiAgICAgICAgLy8gY29weSBtZW1vcnkuLi4gb3RoZXJ3aXNlIHRoZSB3YXZldGFibGVzIGRvbid0IGhhdmUgbWVtb3J5IGluZGljZXMuXG4gICAgICAgIGJ1ZmZlckwgPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKDEwMjQpXG4gICAgICAgIEdpYmJlcmlzaC5tZW1vcnkuaGVhcC5zZXQoIEdpYmJlcmlzaC5nZW5pc2guZ2VuLmdsb2JhbHMucGFuTC5idWZmZXIsIGJ1ZmZlckwgKVxuXG4gICAgICAgIGJ1ZmZlclIgPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKDEwMjQpXG4gICAgICAgIEdpYmJlcmlzaC5tZW1vcnkuaGVhcC5zZXQoIEdpYmJlcmlzaC5nZW5pc2guZ2VuLmdsb2JhbHMucGFuUi5idWZmZXIsIGJ1ZmZlclIgKVxuICAgICAgfVxuXG4gICAgICAvLyBYWFggbXVzdCBiZSBzYW1lIHR5cGUgYXMgd2hhdCBpcyByZXR1cm5lZCBieSBnZW5pc2ggZm9yIHR5cGUgY2hlY2tzIHRvIHdvcmsgY29ycmVjdGx5XG4gICAgICBjb25zdCBvdXRwdXQgPSBuZXcgRmxvYXQ2NEFycmF5KCAyICkgXG5cbiAgICAgIGNvbnN0IGJ1cyA9IE9iamVjdC5jcmVhdGUoIEJ1czIgKVxuXG4gICAgICBsZXQgaW5pdCA9IGZhbHNlXG5cbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgQnVzMi5kZWZhdWx0cywgX19wcm9wcyApXG5cbiAgICAgIE9iamVjdC5hc3NpZ24oIFxuICAgICAgICBidXMsXG5cbiAgICAgICAge1xuICAgICAgICAgIGNhbGxiYWNrKCkge1xuICAgICAgICAgICAgb3V0cHV0WyAwIF0gPSBvdXRwdXRbIDEgXSA9IDBcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJZHggPSBhcmd1bWVudHMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgY29uc3QgbWVtb3J5ICA9IGFyZ3VtZW50c1sgbGFzdElkeCBdXG4gICAgICAgICAgICBsZXQgcGFuICA9IGFyZ3VtZW50c1sgbGFzdElkeCAtIDEgXVxuICAgICAgICAgICAgY29uc3QgZ2FpbiA9IGFyZ3VtZW50c1sgbGFzdElkeCAtIDIgXVxuXG4gICAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGxhc3RJZHggLSAyOyBpKz0gMyApIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBhcmd1bWVudHNbIGkgXSxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBhcmd1bWVudHNbIGkgKyAxIF0sXG4gICAgICAgICAgICAgICAgICAgIGlzU3RlcmVvID0gYXJndW1lbnRzWyBpICsgMiBdXG5cbiAgICAgICAgICAgICAgb3V0cHV0WyAwIF0gKz0gaXNTdGVyZW8gPT09IHRydWUgPyBpbnB1dFsgMCBdICogbGV2ZWwgOiBpbnB1dCAqIGxldmVsXG5cbiAgICAgICAgICAgICAgb3V0cHV0WyAxIF0gKz0gaXNTdGVyZW8gPT09IHRydWUgPyBpbnB1dFsgMSBdICogbGV2ZWwgOiBpbnB1dCAqIGxldmVsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBwYW4gPCAwICkge1xuICAgICAgICAgICAgICBwYW4gPSAwXG4gICAgICAgICAgICB9ZWxzZSBpZiggcGFuID4gMSApe1xuICAgICAgICAgICAgICBwYW4gPSAxXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhblJhd0luZGV4ICA9IHBhbiAqIDEwMjMsXG4gICAgICAgICAgICAgICAgICBwYW5CYXNlSW5kZXggPSBwYW5SYXdJbmRleCB8IDAsXG4gICAgICAgICAgICAgICAgICBwYW5OZXh0SW5kZXggPSAocGFuQmFzZUluZGV4ICsgMSkgJiAxMDIzLFxuICAgICAgICAgICAgICAgICAgaW50ZXJwQW1vdW50ID0gcGFuUmF3SW5kZXggLSBwYW5CYXNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBwYW5MID0gbWVtb3J5WyBidWZmZXJMICsgcGFuQmFzZUluZGV4IF0gXG4gICAgICAgICAgICAgICAgICAgICsgKCBpbnRlcnBBbW91bnQgKiAoIG1lbW9yeVsgYnVmZmVyTCArIHBhbk5leHRJbmRleCBdIC0gbWVtb3J5WyBidWZmZXJMICsgcGFuQmFzZUluZGV4IF0gKSApLFxuICAgICAgICAgICAgICAgICAgcGFuUiA9IG1lbW9yeVsgYnVmZmVyUiArIHBhbkJhc2VJbmRleCBdIFxuICAgICAgICAgICAgICAgICAgICArICggaW50ZXJwQW1vdW50ICogKCBtZW1vcnlbIGJ1ZmZlclIgKyBwYW5OZXh0SW5kZXggXSAtIG1lbW9yeVsgYnVmZmVyUiArIHBhbkJhc2VJbmRleCBdICkgKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBvdXRwdXRbMF0gKj0gZ2FpbiAqIHBhbkxcbiAgICAgICAgICAgIG91dHB1dFsxXSAqPSBnYWluICogcGFuUlxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCA6IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpLFxuICAgICAgICAgIGRpcnR5IDogZmFsc2UsXG4gICAgICAgICAgdHlwZSA6ICdidXMnLFxuICAgICAgICAgIGlucHV0czpbIDEsIC41IF0sXG4gICAgICAgICAgaXNTdGVyZW86IHRydWUsXG4gICAgICAgICAgX19wcm9wZXJ0aWVzX186cHJvcHNcbiAgICAgICAgfSxcblxuICAgICAgICBCdXMyLmRlZmF1bHRzLFxuXG4gICAgICAgIHByb3BzXG4gICAgICApXG5cbiAgICAgIGJ1cy51Z2VuTmFtZSA9IGJ1cy5jYWxsYmFjay51Z2VuTmFtZSA9ICdidXMyXycgKyBidXMuaWRcblxuICAgICAgY29uc3Qgb3V0ID0gYnVzLl9fdXNlUHJveHlfXyA9PT0gdHJ1ZSA/IHByb3h5KCBbJ0J1czInXSwgcHJvcHMsIGJ1cyApIDogYnVzXG5cblxuICAgICAgLy8gd2UgaGF2ZSB0byBpbmNsdWRlIGN1c3RvbSBwcm9wZXJ0aWVzIGZvciB0aGVzZSBhcyB0aGUgYXJndW1lbnQgbGlzdCBmb3JcbiAgICAgIC8vIHRoZSBjb21waWxlZCBvdXRwdXQgZnVuY3Rpb24gaXMgdmFyaWFibGVcbiAgICAgIC8vIHNvIGNvZGVnZW4gY2FuJ3Qga25vdyB0aGUgY29ycmVjdCBhcmd1bWVudCBvcmRlciBmb3IgdGhlIGZ1bmN0aW9uXG4gICAgICBsZXQgcGFuID0gLjVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3V0LCAncGFuJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBwYW4gfSxcbiAgICAgICAgc2V0KHYpeyBcbiAgICAgICAgICBwYW4gPSB2XG4gICAgICAgICAgb3V0LmlucHV0c1sgb3V0LmlucHV0cy5sZW5ndGggLSAxIF0gPSBwYW5cbiAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIG91dCApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGxldCBnYWluID0gMVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvdXQsICdnYWluJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBnYWluIH0sXG4gICAgICAgIHNldCh2KXsgXG4gICAgICAgICAgZ2FpbiA9IHZcbiAgICAgICAgICBvdXQuaW5wdXRzWyBvdXQuaW5wdXRzLmxlbmd0aCAtIDIgXSA9IGdhaW5cbiAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIG91dCApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuICAgIFxuICAgIGRpc2Nvbm5lY3RVZ2VuKCB1Z2VuICkge1xuICAgICAgbGV0IHJlbW92ZUlkeCA9IHRoaXMuaW5wdXRzLmluZGV4T2YoIHVnZW4gKVxuXG4gICAgICBpZiggcmVtb3ZlSWR4ICE9PSAtMSApIHtcbiAgICAgICAgdGhpcy5pbnB1dHMuc3BsaWNlKCByZW1vdmVJZHgsIDMgKVxuICAgICAgICBHaWJiZXJpc2guZGlydHkoIHRoaXMgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWZhdWx0czogeyBnYWluOjEsIHBhbjouNSwgX191c2VQcm94eV9fOnRydWUgfVxuICB9KVxuXG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gQnVzMi5jcmVhdGUuYmluZCggQnVzMiApXG4gIGNvbnN0cnVjdG9yLmRlZmF1bHRzID0gQnVzMi5kZWZhdWx0c1xuXG4gIHJldHVybiBjb25zdHJ1Y3RvclxuXG59XG4iLCJjb25zdCAgZyAgICA9IHJlcXVpcmUoICdnZW5pc2guanMnICApLFxuICAgICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBNb25vcHMgPSB7XG4gICAgZXhwb3J0KCBvYmogKSB7XG4gICAgICBmb3IoIGxldCBrZXkgaW4gTW9ub3BzICkge1xuICAgICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyApIHtcbiAgICAgICAgICBvYmpbIGtleSBdID0gTW9ub3BzWyBrZXkgXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBBYnMoIGlucHV0ICkge1xuICAgICAgY29uc3QgYWJzID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gICAgICBjb25zdCBncmFwaCA9IGcuYWJzKCBnLmluKCdpbnB1dCcpIClcbiAgICAgIFxuICAgICAgY29uc3QgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggYWJzLCBncmFwaCwgWydtb25vcHMnLCdhYnMnXSwgT2JqZWN0LmFzc2lnbih7fSwgTW9ub3BzLmRlZmF1bHRzLCB7IGlucHV0czpbaW5wdXRdLCBpc29wOnRydWUgfSkgKVxuXG4gICAgICByZXR1cm4gX19vdXRcbiAgICB9LFxuXG4gICAgUG93KCBpbnB1dCwgZXhwb25lbnQgKSB7XG4gICAgICBjb25zdCBwb3cgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IGdyYXBoID0gZy5wb3coIGcuaW4oJ2lucHV0JyksIGcuaW4oJ2V4cG9uZW50JykgKVxuICAgICAgXG4gICAgICBHaWJiZXJpc2guZmFjdG9yeSggcG93LCBncmFwaCwgWydtb25vcHMnLCdwb3cnXSwgT2JqZWN0LmFzc2lnbih7fSwgTW9ub3BzLmRlZmF1bHRzLCB7IGlucHV0czpbaW5wdXRdLCBleHBvbmVudCwgaXNvcDp0cnVlIH0pIClcblxuICAgICAgcmV0dXJuIHBvd1xuICAgIH0sXG4gICAgQ2xhbXAoIGlucHV0LCBtaW4sIG1heCApIHtcbiAgICAgIGNvbnN0IGNsYW1wID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gICAgICBjb25zdCBncmFwaCA9IGcuY2xhbXAoIGcuaW4oJ2lucHV0JyksIGcuaW4oJ21pbicpLCBnLmluKCdtYXgnKSApXG4gICAgICBcbiAgICAgIGNvbnN0IF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIGNsYW1wLCBncmFwaCwgWydtb25vcHMnLCdjbGFtcCddLCBPYmplY3QuYXNzaWduKHt9LCBNb25vcHMuZGVmYXVsdHMsIHsgaW5wdXRzOltpbnB1dF0sIGlzb3A6dHJ1ZSwgbWluLCBtYXggfSkgKVxuXG4gICAgICByZXR1cm4gX19vdXRcbiAgICB9LFxuXG4gICAgTWVyZ2UoIGlucHV0ICkge1xuICAgICAgY29uc3QgbWVyZ2VyID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gICAgICBjb25zdCBjYiA9IGZ1bmN0aW9uKCBfaW5wdXQgKSB7XG4gICAgICAgIHJldHVybiBfaW5wdXRbMF0gKyBfaW5wdXRbMV1cbiAgICAgIH1cblxuICAgICAgR2liYmVyaXNoLmZhY3RvcnkoIG1lcmdlciwgZy5pbiggJ2lucHV0JyApLCBbJ21vbm9wcycsJ21lcmdlJ10sIHsgaW5wdXRzOltpbnB1dF0sIGlzb3A6dHJ1ZSB9LCBjYiApXG4gICAgICBtZXJnZXIudHlwZSA9ICdhbmFseXNpcydcbiAgICAgIG1lcmdlci5pbnB1dE5hbWVzID0gWyAnaW5wdXQnIF1cbiAgICAgIG1lcmdlci5pbnB1dHMgPSBbIGlucHV0IF1cbiAgICAgIG1lcmdlci5pbnB1dCA9IGlucHV0XG4gICAgICBcbiAgICAgIHJldHVybiBtZXJnZXJcbiAgICB9LFxuICB9XG5cbiAgTW9ub3BzLmRlZmF1bHRzID0geyBpbnB1dDowIH1cblxuICByZXR1cm4gTW9ub3BzXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuXG5jb25zdCB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgUGFubmVyID0gaW5wdXRQcm9wcyA9PiB7XG4gIGNvbnN0IHByb3BzICA9IE9iamVjdC5hc3NpZ24oIHt9LCBQYW5uZXIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgcGFubmVyID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbiAgY29uc3QgaXNTdGVyZW8gPSBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gdW5kZWZpbmVkID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBBcnJheS5pc0FycmF5KCBwcm9wcy5pbnB1dCApIFxuICBcbiAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgIHBhbiAgID0gZy5pbiggJ3BhbicgKVxuXG4gIGxldCBncmFwaCBcbiAgaWYoIGlzU3RlcmVvICkge1xuICAgIGdyYXBoID0gZy5wYW4oIGlucHV0WzBdLCBpbnB1dFsxXSwgcGFuICkgIFxuICB9ZWxzZXtcbiAgICBncmFwaCA9IGcucGFuKCBpbnB1dCwgaW5wdXQsIHBhbiApXG4gIH1cblxuICBHaWJiZXJpc2guZmFjdG9yeSggcGFubmVyLCBbIGdyYXBoLmxlZnQsIGdyYXBoLnJpZ2h0XSwgWydwYW5uZXInXSwgcHJvcHMgKVxuICBcbiAgcmV0dXJuIHBhbm5lclxufVxuXG5QYW5uZXIuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIHBhbjouNVxufVxuXG5yZXR1cm4gUGFubmVyIFxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgVGltZSA9IHtcbiAgICBicG06IDEyMCxcblxuICAgIGV4cG9ydDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBPYmplY3QuYXNzaWduKCB0YXJnZXQsIFRpbWUgKVxuICAgIH0sXG5cbiAgICBtcyA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAqIEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZSAvIDEwMDA7XG4gICAgfSxcblxuICAgIHNlY29uZHMgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgKiBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGU7XG4gICAgfSxcblxuICAgIGJlYXRzIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IFxuICAgICAgICB2YXIgc2FtcGxlc1BlckJlYXQgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyAoIEdpYmJlcmlzaC5UaW1lLmJwbSAvIDYwICkgO1xuICAgICAgICByZXR1cm4gc2FtcGxlc1BlckJlYXQgKiB2YWwgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUaW1lXG59XG4iLCJjb25zdCBnZW5pc2ggPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgc3NkID0gZ2VuaXNoLmhpc3RvcnksXG4gICAgICBub2lzZSA9IGdlbmlzaC5ub2lzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBqc2RzcFwiXG5cbiAgY29uc3QgbGFzdCA9IHNzZCggMCApXG5cbiAgY29uc3Qgd2hpdGUgPSAoIG5vaXNlKCkgKiAyICkgLSAxXG5cbiAgbGV0IG91dCA9IChsYXN0Lm91dCArICguMDIgKiB3aGl0ZSkpIC8gMS4wMlxuXG4gIGxhc3QuaW4oIG91dCApXG5cbiAgb3V0ICo9IDMuNVxuICAgXG4gIHJldHVybiBvdXRcbn1cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuXG5sZXQgZmVlZGJhY2tPc2MgPSBmdW5jdGlvbiggZnJlcXVlbmN5LCBmaWx0ZXIsIHB1bHNld2lkdGg9LjUsIGFyZ3VtZW50UHJvcHMgKSB7XG4gIGlmKCBhcmd1bWVudFByb3BzID09PSB1bmRlZmluZWQgKSBhcmd1bWVudFByb3BzID0geyB0eXBlOiAwIH1cblxuICBsZXQgbGFzdFNhbXBsZSA9IGcuaGlzdG9yeSgpLFxuICAgICAgLy8gZGV0ZXJtaW5lIHBoYXNlIGluY3JlbWVudCBhbmQgbWVtb2l6ZSByZXN1bHRcbiAgICAgIHcgPSBnLm1lbW8oIGcuZGl2KCBmcmVxdWVuY3ksIGcuZ2VuLnNhbXBsZXJhdGUgKSApLFxuICAgICAgLy8gY3JlYXRlIHNjYWxpbmcgZmFjdG9yXG4gICAgICBuID0gZy5zdWIoIC0uNSwgdyApLFxuICAgICAgc2NhbGluZyA9IGcubXVsKCBnLm11bCggMTMsIGZpbHRlciApLCBnLnBvdyggbiwgNSApICksXG4gICAgICAvLyBjYWxjdWxhdGUgZGMgb2Zmc2V0IGFuZCBub3JtYWxpemF0aW9uIGZhY3RvcnNcbiAgICAgIERDID0gZy5zdWIoIC4zNzYsIGcubXVsKCB3LCAuNzUyICkgKSxcbiAgICAgIG5vcm0gPSBnLnN1YiggMSwgZy5tdWwoIDIsIHcgKSApLFxuICAgICAgLy8gZGV0ZXJtaW5lIHBoYXNlXG4gICAgICBvc2MxUGhhc2UgPSBnLmFjY3VtKCB3LCAwLCB7IG1pbjotMSB9KSxcbiAgICAgIG9zYzEsIG91dFxuXG4gIC8vIGNyZWF0ZSBjdXJyZW50IHNhbXBsZS4uLiBmcm9tIHRoZSBwYXBlcjpcbiAgLy8gb3NjID0gKG9zYyArIHNpbigyKnBpKihwaGFzZSArIG9zYypzY2FsaW5nKSkpKjAuNWY7XG4gIG9zYzEgPSBnLm1lbW8oIFxuICAgIGcubXVsKFxuICAgICAgZy5hZGQoXG4gICAgICAgIGxhc3RTYW1wbGUub3V0LFxuICAgICAgICBnLnNpbihcbiAgICAgICAgICBnLm11bChcbiAgICAgICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICAgICAgZy5tZW1vKCBnLmFkZCggb3NjMVBoYXNlLCBnLm11bCggbGFzdFNhbXBsZS5vdXQsIHNjYWxpbmcgKSApIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICAuNVxuICAgIClcbiAgKVxuXG4gIC8vIHN0b3JlIHNhbXBsZSB0byB1c2UgYXMgbW9kdWxhdGlvblxuICBsYXN0U2FtcGxlLmluKCBvc2MxIClcblxuICAvLyBpZiBwd20gLyBzcXVhcmUgd2F2ZWZvcm0gaW5zdGVhZCBvZiBzYXd0b290aC4uLlxuICBpZiggYXJndW1lbnRQcm9wcy50eXBlID09PSAxICkgeyBcbiAgICBjb25zdCBsYXN0U2FtcGxlMiA9IGcuaGlzdG9yeSgpIC8vIGZvciBvc2MgMlxuICAgIGNvbnN0IGxhc3RTYW1wbGVNYXN0ZXIgPSBnLmhpc3RvcnkoKSAvLyBmb3Igc3VtIG9mIG9zYzEsb3NjMlxuXG4gICAgY29uc3Qgb3NjMiA9IGcubXVsKFxuICAgICAgZy5hZGQoXG4gICAgICAgIGxhc3RTYW1wbGUyLm91dCxcbiAgICAgICAgZy5zaW4oXG4gICAgICAgICAgZy5tdWwoXG4gICAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICAgIGcubWVtbyggZy5hZGQoIG9zYzFQaGFzZSwgZy5tdWwoIGxhc3RTYW1wbGUyLm91dCwgc2NhbGluZyApLCBwdWxzZXdpZHRoICkgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIC41XG4gICAgKVxuXG4gICAgbGFzdFNhbXBsZTIuaW4oIG9zYzIgKVxuICAgIG91dCA9IGcubWVtbyggZy5zdWIoIGxhc3RTYW1wbGUub3V0LCBsYXN0U2FtcGxlMi5vdXQgKSApXG4gICAgb3V0ID0gZy5tZW1vKCBnLmFkZCggZy5tdWwoIDIuNSwgb3V0ICksIGcubXVsKCAtMS41LCBsYXN0U2FtcGxlTWFzdGVyLm91dCApICkgKVxuICAgIFxuICAgIGxhc3RTYW1wbGVNYXN0ZXIuaW4oIGcuc3ViKCBvc2MxLCBvc2MyICkgKVxuXG4gIH1lbHNle1xuICAgICAvLyBvZmZzZXQgYW5kIG5vcm1hbGl6ZVxuICAgIG9zYzEgPSBnLmFkZCggZy5tdWwoIDIuNSwgb3NjMSApLCBnLm11bCggLTEuNSwgbGFzdFNhbXBsZS5vdXQgKSApXG4gICAgb3NjMSA9IGcuYWRkKCBvc2MxLCBEQyApXG4gXG4gICAgb3V0ID0gb3NjMVxuICB9XG5cbiAgcmV0dXJuIGcubXVsKCBvdXQsIG5vcm0gKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZlZWRiYWNrT3NjXG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpLFxuICAgICAgZmVlZGJhY2tPc2MgPSByZXF1aXJlKCAnLi9mbWZlZWRiYWNrb3NjLmpzJyApLFxuICAgICAgcG9seUJsZXAgPSByZXF1aXJlKCAnLi9wb2x5YmxlcC5kc3AuanMnIClcblxuLy8gIF9fbWFrZU9zY2lsbGF0b3JfXyggdHlwZSwgZnJlcXVlbmN5LCBhbnRpYWxpYXMgKSB7XG4gICAgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIGxldCBPc2NpbGxhdG9ycyA9IHtcbiAgICBleHBvcnQoIG9iaiApIHtcbiAgICAgIGZvciggbGV0IGtleSBpbiBPc2NpbGxhdG9ycyApIHtcbiAgICAgICAgaWYoIGtleSAhPT0gJ2V4cG9ydCcgKSB7XG4gICAgICAgICAgb2JqWyBrZXkgXSA9IE9zY2lsbGF0b3JzWyBrZXkgXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdlbmlzaDoge1xuICAgICAgQnJvd246IHJlcXVpcmUoICcuL2Jyb3dubm9pc2UuZHNwLmpzJyApLFxuICAgICAgUGluazogIHJlcXVpcmUoICcuL3Bpbmtub2lzZS5kc3AuanMnICApXG4gICAgfSxcblxuICAgIFdhdmV0YWJsZTogcmVxdWlyZSggJy4vd2F2ZXRhYmxlLmpzJyApKCBHaWJiZXJpc2ggKSxcbiAgICBcbiAgICBTcXVhcmUoIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCBzcXIgICA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSBcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGFudGlhbGlhczpmYWxzZSB9LCBPc2NpbGxhdG9ycy5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgICBjb25zdCBvc2MgICA9IE9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCBnLmluKCAnZnJlcXVlbmN5JyApLCBwcm9wcy5hbnRpYWxpYXMgKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLm11bCggb3NjLCBnLmluKCdnYWluJyApIClcblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHNxciwgZ3JhcGgsIFsnb3NjaWxsYXRvcnMnLCdzcXVhcmUnXSwgcHJvcHMgKVxuXG4gICAgICByZXR1cm4gb3V0XG4gICAgfSxcblxuICAgIFRyaWFuZ2xlKCBpbnB1dFByb3BzICkge1xuICAgICAgY29uc3QgdHJpPSBPYmplY3QuY3JlYXRlKCB1Z2VuICkgXG4gICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBhbnRpYWxpYXM6ZmFsc2UgfSwgT3NjaWxsYXRvcnMuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgICAgY29uc3Qgb3NjICAgPSBPc2NpbGxhdG9ycy5mYWN0b3J5KCAndHJpYW5nbGUnLCBnLmluKCAnZnJlcXVlbmN5JyApLCBwcm9wcy5hbnRpYWxpYXMgKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLm11bCggb3NjLCBnLmluKCdnYWluJyApIClcblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHRyaSwgZ3JhcGgsIFsnb3NjaWxsYXRvcnMnLCd0cmlhbmdsZSddLCBwcm9wcyApXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgUFdNKCBpbnB1dFByb3BzICkge1xuICAgICAgY29uc3QgcHdtICAgPSBPYmplY3QuY3JlYXRlKCB1Z2VuICkgXG4gICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBhbnRpYWxpYXM6ZmFsc2UsIHB1bHNld2lkdGg6LjI1IH0sIE9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICAgIGNvbnN0IG9zYyAgID0gT3NjaWxsYXRvcnMuZmFjdG9yeSggJ3B3bScsIGcuaW4oICdmcmVxdWVuY3knICksIHByb3BzLmFudGlhbGlhcyApXG4gICAgICBjb25zdCBncmFwaCA9IGcubXVsKCBvc2MsIGcuaW4oJ2dhaW4nICkgKVxuXG4gICAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggcHdtLCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ1BXTSddLCBwcm9wcyApXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgU2luZSggaW5wdXRQcm9wcyApIHtcbiAgICAgIGNvbnN0IHNpbmUgID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIE9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICAgIGNvbnN0IGdyYXBoID0gZy5tdWwoIGcuY3ljbGUoIGcuaW4oJ2ZyZXF1ZW5jeScpICksIGcuaW4oJ2dhaW4nKSApXG5cbiAgICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzaW5lLCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ3NpbmUnXSwgcHJvcHMgKVxuICAgICAgXG4gICAgICByZXR1cm4gb3V0XG4gICAgfSxcblxuICAgIE5vaXNlKCBpbnB1dFByb3BzICkge1xuICAgICAgY29uc3Qgbm9pc2UgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIHsgZ2FpbjogMSwgY29sb3I6J3doaXRlJyB9LCBpbnB1dFByb3BzIClcbiAgICAgIGxldCBncmFwaCBcblxuICAgICAgc3dpdGNoKCBwcm9wcy5jb2xvciApIHtcbiAgICAgICAgY2FzZSAnYnJvd24nOlxuICAgICAgICAgIGdyYXBoID0gZy5tdWwoIE9zY2lsbGF0b3JzLmdlbmlzaC5Ccm93bigpLCBnLmluKCdnYWluJykgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwaW5rJzpcbiAgICAgICAgICBncmFwaCA9IGcubXVsKCBPc2NpbGxhdG9ycy5nZW5pc2guUGluaygpLCBnLmluKCdnYWluJykgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGdyYXBoID0gZy5tdWwoIGcubm9pc2UoKSwgZy5pbignZ2FpbicpIClcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIG5vaXNlLCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ25vaXNlJ10sIHByb3BzIClcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH0sXG5cbiAgICBTYXcoIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCBzYXcgICA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSBcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGFudGlhbGlhczpmYWxzZSB9LCBPc2NpbGxhdG9ycy5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgICBjb25zdCBvc2MgICA9IE9zY2lsbGF0b3JzLmZhY3RvcnkoICdzYXcnLCBnLmluKCAnZnJlcXVlbmN5JyApLCBwcm9wcy5hbnRpYWxpYXMgKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLm11bCggb3NjLCBnLmluKCdnYWluJyApIClcblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHNhdywgZ3JhcGgsIFsnb3NjaWxsYXRvcnMnLCdzYXcnXSwgcHJvcHMgKVxuXG4gICAgICByZXR1cm4gb3V0XG4gICAgfSxcblxuICAgIFJldmVyc2VTYXcoIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCBzYXcgICA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSBcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGFudGlhbGlhczpmYWxzZSB9LCBPc2NpbGxhdG9ycy5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgICBjb25zdCBvc2MgICA9IGcuc3ViKCAxLCBPc2NpbGxhdG9ycy5mYWN0b3J5KCAnc2F3JywgZy5pbiggJ2ZyZXF1ZW5jeScgKSwgcHJvcHMuYW50aWFsaWFzICkgKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLm11bCggb3NjLCBnLmluKCAnZ2FpbicgKSApXG5cbiAgICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzYXcsIGdyYXBoLCBbJ29zY2lsbGF0b3JzJywnUmV2ZXJzZVNhdyddLCBwcm9wcyApXG4gICAgICBcbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgZmFjdG9yeSggdHlwZSwgZnJlcXVlbmN5LCBhbnRpYWxpYXM9ZmFsc2UgKSB7XG4gICAgICBsZXQgb3NjXG5cbiAgICAgIHN3aXRjaCggdHlwZSApIHtcbiAgICAgICAgY2FzZSAncHdtJzpcbiAgICAgICAgICBsZXQgcHVsc2V3aWR0aCA9IGcuaW4oJ3B1bHNld2lkdGgnKVxuICAgICAgICAgIGlmKCBhbnRpYWxpYXMgPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIG9zYyA9IGZlZWRiYWNrT3NjKCBmcmVxdWVuY3ksIDEsIHB1bHNld2lkdGgsIHsgdHlwZToxIH0pXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBsZXQgcGhhc2UgPSBnLnBoYXNvciggZnJlcXVlbmN5LCAwLCB7IG1pbjowIH0gKVxuICAgICAgICAgICAgb3NjID0gZy5sdCggcGhhc2UsIHB1bHNld2lkdGggKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2F3JzpcbiAgICAgICAgICBpZiggYW50aWFsaWFzID09IGZhbHNlICkge1xuICAgICAgICAgICAgb3NjID0gZy5waGFzb3IoIGZyZXF1ZW5jeSApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvc2MgPSBwb2x5QmxlcCggZnJlcXVlbmN5LCB7IHR5cGUgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpbmUnOlxuICAgICAgICAgIG9zYyA9IGcuY3ljbGUoIGZyZXF1ZW5jeSApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgaWYoIGFudGlhbGlhcyA9PSB0cnVlICkge1xuICAgICAgICAgICAgLy9vc2MgPSBmZWVkYmFja09zYyggZnJlcXVlbmN5LCAxLCAuNSwgeyB0eXBlOjEgfSlcbiAgICAgICAgICAgIG9zYyA9IHBvbHlCbGVwKCBmcmVxdWVuY3ksIHsgdHlwZSB9KVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgb3NjID0gZy53YXZldGFibGUoIGZyZXF1ZW5jeSwgeyBidWZmZXI6T3NjaWxsYXRvcnMuU3F1YXJlLmJ1ZmZlciwgbmFtZTonc3F1YXJlJyB9IClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgICBpZiggYW50aWFsaWFzID09IHRydWUgKSB7XG4gICAgICAgICAgICBvc2MgPSBwb2x5QmxlcCggZnJlcXVlbmN5LCB7IHR5cGUgfSlcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG9zYyA9IGcud2F2ZXRhYmxlKCBmcmVxdWVuY3ksIHsgYnVmZmVyOk9zY2lsbGF0b3JzLlRyaWFuZ2xlLmJ1ZmZlciwgbmFtZTondHJpYW5nbGUnIH0gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbm9pc2UnOlxuICAgICAgICAgIG9zYyA9IGcubm9pc2UoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3NjXG4gICAgfVxuICB9XG5cbiAgT3NjaWxsYXRvcnMuU3F1YXJlLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIDEwMjQgKVxuXG4gIGZvciggbGV0IGkgPSAxMDIzOyBpID49IDA7IGktLSApIHsgXG4gICAgT3NjaWxsYXRvcnMuU3F1YXJlLmJ1ZmZlciBbIGkgXSA9IGkgLyAxMDI0ID4gLjUgPyAxIDogLTFcbiAgfVxuXG4gIE9zY2lsbGF0b3JzLlRyaWFuZ2xlLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIDEwMjQgKVxuXG4gIFxuICBmb3IoIGxldCBpID0gMTAyNDsgaS0tOyBpID0gaSApIHsgT3NjaWxsYXRvcnMuVHJpYW5nbGUuYnVmZmVyW2ldID0gMSAtIDQgKiBNYXRoLmFicygoIChpIC8gMTAyNCkgKyAwLjI1KSAlIDEgLSAwLjUpOyB9XG5cbiAgT3NjaWxsYXRvcnMuZGVmYXVsdHMgPSB7XG4gICAgZnJlcXVlbmN5OiA0NDAsXG4gICAgZ2FpbjogMVxuICB9XG5cbiAgcmV0dXJuIE9zY2lsbGF0b3JzXG5cbn1cbiIsImNvbnN0IGdlbmlzaCA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBzc2QgPSBnZW5pc2guaGlzdG9yeSxcbiAgICAgIGRhdGEgPSBnZW5pc2guZGF0YSxcbiAgICAgIG5vaXNlID0gZ2VuaXNoLm5vaXNlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIGpzZHNwXCJcblxuICBjb25zdCBiID0gZGF0YSggOCwgMSwgeyBtZXRhOiB0cnVlIH0pXG4gIGNvbnN0IHdoaXRlID0gbm9pc2UoKSAqIDIgLSAxXG5cbiAgYlswXSA9ICggLjk5ODg2ICogYlswXSApICsgKCB3aGl0ZSAqIC4wNTU1MTc5IClcbiAgYlsxXSA9ICggLjk5MzMyICogYlsxXSApICsgKCB3aGl0ZSAqIC4wNzUwNTc5IClcbiAgYlsyXSA9ICggLjk2OTAwICogYlsyXSApICsgKCB3aGl0ZSAqIC4xNTM4NTIwIClcbiAgYlszXSA9ICggLjg4NjUwICogYlszXSApICsgKCB3aGl0ZSAqIC4zMTA0ODU2IClcbiAgYls0XSA9ICggLjU1MDAwICogYls0XSApICsgKCB3aGl0ZSAqIC41MzI5NTIyIClcbiAgYls1XSA9ICggLS43NjE2ICogYls1XSApIC0gKCB3aGl0ZSAqIC4wMTY4OTgwIClcbiBcbiAgY29uc3Qgb3V0ID0gKCBiWzBdICsgYlsxXSArIGJbMl0gKyBiWzNdICsgYls0XSArIGJbNV0gKyBiWzZdICsgd2hpdGUgKiAuNTM2MiApICogLjExXG5cbiAgYls2XSA9IHdoaXRlICogLjExNTkyNlxuXG4gIHJldHVybiBvdXRcblxufVxuIiwiY29uc3QgZ2VuaXNoID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuY29uc3QgZyA9IGdlbmlzaFxuXG4vLyBiYXNlZCBvbiBodHRwOi8vd3d3Lm1hcnRpbi1maW5rZS5kZS9ibG9nL2FydGljbGVzL2F1ZGlvLXBsdWdpbnMtMDE4LXBvbHlibGVwLW9zY2lsbGF0b3IvXG5jb25zdCBwb2x5QmxlcCA9IGZ1bmN0aW9uKCBfX2ZyZXF1ZW5jeSwgYXJndW1lbnRQcm9wcyApIHtcbiAgJ3VzZSBqc2RzcCdcbiAgaWYoIGFyZ3VtZW50UHJvcHMgPT09IHVuZGVmaW5lZCApIGFyZ3VtZW50UHJvcHMgPSB7IHR5cGU6ICdzYXcnIH1cbiAgXG4gIGNvbnN0IG1lbSA9IGcuaGlzdG9yeSgwKVxuICBjb25zdCB0eXBlID0gYXJndW1lbnRQcm9wcy50eXBlXG4gIGNvbnN0IGZyZXF1ZW5jeSA9IF9fZnJlcXVlbmN5ID09PSB1bmRlZmluZWQgPyAyMjAgOiBfX2ZyZXF1ZW5jeVxuICBjb25zdCBkdCA9IGZyZXF1ZW5jeSAvIGcuZ2VuLnNhbXBsZXJhdGVcbiAgXG4gIGNvbnN0IHQgPSBnLmFjY3VtKCBkdCwgMCwgeyBtaW46MCB9KVxuICBsZXQgb3NjXG5cbiAgLy8gdHJpYW5nbGUgd2F2ZXMgYXJlIGludGVncmF0ZWQgc3F1YXJlIHdhdmVzLCBzbyB0aGUgYmVsb3cgY2FzZSBhY2NvbW9kYXRlcyBib3RoIHR5cGVzXG4gIGlmKCB0eXBlID09PSAndHJpYW5nbGUnIHx8IHR5cGUgPT09ICdzcXVhcmUnICkge1xuICAgIC8vIGx0IE5PVCBndCB0byBnZXQgY29ycmVjdCBwaGFzZVxuICAgIG9zYyA9ICgyICogZy5sdCh0LC41KSApIC0gMVxuICB9ZWxzZXtcbiAgICBvc2MgPSAyICogdCAtIDFcbiAgfVxuICBjb25zdCBjYXNlMSA9IGcubHQodCxkdClcbiAgY29uc3QgY2FzZTIgPSBnLmd0KHQsMS1kdClcbiAgY29uc3QgYWRqdXN0ZWRUID0gZy5zd2l0Y2goIGNhc2UxLCB0L2R0LCBnLnN3aXRjaCggY2FzZTIsICh0LTEpL2R0LCB0ICkgKVxuICBcbiAgLy8gaWYvZWxzZWlmL2Vsc2Ugd2l0aCBuZXN0ZWQgdGVybmFyeSBvcGVyYXRvcnNcbiAgY29uc3QgYmxlcCA9IGcuc3dpdGNoKFxuICAgIGNhc2UxLFxuICAgIGFkanVzdGVkVCArIGFkanVzdGVkVCAtIGFkanVzdGVkVCAqIGFkanVzdGVkVCAtIDEsXG4gICAgZy5zd2l0Y2goXG4gICAgICBjYXNlMixcbiAgICAgIGFkanVzdGVkVCAqIGFkanVzdGVkVCArIGFkanVzdGVkVCArIGFkanVzdGVkVCArIDEsXG4gICAgICAvLyBmaW5hbCBlbHNlIGNhc2UgaXMgMFxuICAgICAgMFxuICAgIClcbiAgKVxuICBcbiAgLy8gdHJpYW5nbGUgd2F2ZXMgYXJlIGludGVncmF0ZWQgc3F1YXJlIHdhdmVzLCBzbyB0aGUgYmVsb3cgY2FzZSBhY2NvbW9kYXRlcyBib3RoIHR5cGVzXG4gIGlmKCB0eXBlICE9PSAnc2F3JyApIHtcbiAgICBvc2MgPSBvc2MgKyBibGVwXG4gICAgY29uc3QgdF8yID0gZy5tZW1vKCBnLm1vZCggdCArIC41LCAxICkgKVxuICAgIGNvbnN0IGNhc2UxXzIgPSBnLmx0KHRfMixkdClcbiAgICBjb25zdCBjYXNlMl8yID0gZy5ndCh0XzIsMS1kdClcbiAgICBjb25zdCBhZGp1c3RlZFRfMiA9IGcuc3dpdGNoKCBjYXNlMV8yLCB0XzIvZHQsIGcuc3dpdGNoKCBjYXNlMl8yLCAodF8yLTEpL2R0LCB0XzIgKSApXG4gXG4gICAgY29uc3QgYmxlcDIgPSBnLnN3aXRjaChcbiAgICAgIGNhc2UxXzIsXG4gICAgICBhZGp1c3RlZFRfMiArIGFkanVzdGVkVF8yIC0gYWRqdXN0ZWRUXzIgKiBhZGp1c3RlZFRfMiAtIDEsXG4gICAgICBnLnN3aXRjaChcbiAgICAgICAgY2FzZTJfMixcbiAgICAgICAgYWRqdXN0ZWRUXzIgKiBhZGp1c3RlZFRfMiArIGFkanVzdGVkVF8yICsgYWRqdXN0ZWRUXzIgKyAxLFxuICAgICAgICAwXG4gICAgICApXG4gICAgKVxuICAgIG9zYyA9IG9zYyAtIGJsZXAyXG4gICAgXG4gICAgLy8gbGVha3kgaW50ZWdyYXRvciB0byBjcmVhdGUgdHJpYW5nbGUgZnJvbSBzcXVhcmUgd2F2ZVxuICAgIGlmKCB0eXBlID09PSAndHJpYW5nbGUnICkge1xuICAgICAgb3NjID0gZHQgKiBvc2MgKyAoMSAtIGR0ICkgKiBtZW0ub3V0XG4gICAgICBtZW0uaW4oIG9zYyApXG4gICAgfVxuICB9ZWxzZXtcbiAgICBvc2MgPSBvc2MgLSBibGVwXG4gIH1cbiAgXG4gIHJldHVybiBvc2Ncbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5QmxlcCBcbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgV2F2ZXRhYmxlID0gZnVuY3Rpb24oIGlucHV0UHJvcHMgKSB7XG4gICAgY29uc3Qgd2F2ZXRhYmxlID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gICAgY29uc3QgcHJvcHMgID0gT2JqZWN0LmFzc2lnbih7fSwgR2liYmVyaXNoLm9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBjb25zdCBvc2MgPSBnLndhdmV0YWJsZSggZy5pbignZnJlcXVlbmN5JyksIHByb3BzIClcbiAgICBjb25zdCBncmFwaCA9IGcubXVsKCBcbiAgICAgIG9zYywgXG4gICAgICBnLmluKCAnZ2FpbicgKVxuICAgIClcblxuICAgIEdpYmJlcmlzaC5mYWN0b3J5KCB3YXZldGFibGUsIGdyYXBoLCAnd2F2ZXRhYmxlJywgcHJvcHMgKVxuXG4gICAgcmV0dXJuIHdhdmV0YWJsZVxuICB9XG5cbiAgZy53YXZldGFibGUgPSBmdW5jdGlvbiggZnJlcXVlbmN5LCBwcm9wcyApIHtcbiAgICBsZXQgZGF0YVByb3BzID0geyBpbW11dGFibGU6dHJ1ZSB9XG5cbiAgICAvLyB1c2UgZ2xvYmFsIHJlZmVyZW5jZXMgaWYgYXBwbGljYWJsZVxuICAgIGlmKCBwcm9wcy5uYW1lICE9PSB1bmRlZmluZWQgKSBkYXRhUHJvcHMuZ2xvYmFsID0gcHJvcHMubmFtZVxuXG4gICAgY29uc3QgYnVmZmVyID0gZy5kYXRhKCBwcm9wcy5idWZmZXIsIDEsIGRhdGFQcm9wcyApXG5cbiAgICByZXR1cm4gZy5wZWVrKCBidWZmZXIsIGcucGhhc29yKCBmcmVxdWVuY3ksIDAsIHsgbWluOjAgfSApIClcbiAgfVxuXG4gIHJldHVybiBXYXZldGFibGVcbn1cbiIsImNvbnN0IFF1ZXVlID0gcmVxdWlyZSggJy4uL2V4dGVybmFsL3ByaW9yaXR5cXVldWUuanMnIClcblxubGV0IEdpYmJlcmlzaCA9IG51bGxcblxuY29uc3QgU2NoZWR1bGVyID0ge1xuICBwaGFzZTogMCxcblxuICBxdWV1ZTogbmV3IFF1ZXVlKCAoIGEsIGIgKSA9PiB7XG4gICAgaWYoIGEudGltZSA9PT0gYi50aW1lICkgeyBcbiAgICAgIHJldHVybiBhLnByaW9yaXR5IDwgYi5wcmlvcml0eSA/IC0xIDogYS5wcmlvcml0eSA+IGIucHJpb3JpdHkgPyAxIDogMDtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWUgLy9hLnRpbWUubWludXMoIGIudGltZSApXG4gICAgfVxuICB9KSxcblxuICBpbml0KCBfX0dpYmJlcmlzaCApIHtcbiAgICBHaWJiZXJpc2ggPSBfX0dpYmJlcmlzaFxuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUuZGF0YS5sZW5ndGggPSAwXG4gICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwXG4gICAgdGhpcy5waGFzZSA9IDBcbiAgfSxcblxuICBhZGQoIHRpbWUsIGZ1bmMsIHByaW9yaXR5ID0gMCApIHtcbiAgICB0aW1lICs9IHRoaXMucGhhc2VcblxuICAgIHRoaXMucXVldWUucHVzaCh7IHRpbWUsIGZ1bmMsIHByaW9yaXR5IH0pXG5cbiAgICByZXR1cm4gdGhpcy5waGFzZVxuICB9LFxuXG4gIHRpY2soIHVzaW5nU3luYyA9IGZhbHNlICkge1xuICAgIGlmKCB0aGlzLnNob3VsZFN5bmMgPT09IHVzaW5nU3luYyApIHtcbiAgICAgIGlmKCB0aGlzLnF1ZXVlLmxlbmd0aCApIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnF1ZXVlLnBlZWsoKVxuXG4gICAgICAgIGlmKCBpc05hTiggbmV4dC50aW1lICkgKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZS5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB3aGlsZSggdGhpcy5waGFzZSA+PSBuZXh0LnRpbWUgKSB7XG4gICAgICAgICAgbmV4dC5mdW5jKCBuZXh0LnByaW9yaXR5IClcbiAgICAgICAgICB0aGlzLnF1ZXVlLnBvcCgpXG4gICAgICAgICAgbmV4dCA9IHRoaXMucXVldWUucGVlaygpXG5cbiAgICAgICAgICAvLyBYWFggdGhpcyBoYXBwZW5zIHdoZW4gY2FsbGluZyBzZXF1ZW5jZXIuc3RvcCgpLi4uIHdoeT9cbiAgICAgICAgICBpZiggbmV4dCA9PT0gdW5kZWZpbmVkICkgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBoYXNlKytcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5waGFzZVxuICB9LFxuXG4gIGFkdmFuY2UoIGFtdCApIHtcbiAgICB0aGlzLnBoYXNlICs9IGFtdFxuICAgIHRoaXMudGljayggdHJ1ZSApXG4gIH1cbn1cblxubGV0IHNob3VsZFN5bmMgPSBmYWxzZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBTY2hlZHVsZXIsICdzaG91bGRTeW5jJywge1xuICBnZXQoKSB7IHJldHVybiBzaG91bGRTeW5jIH0sXG4gIHNldCh2KXsgXG4gICAgc2hvdWxkU3luYyA9IHZcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOidldmFsJyxcbiAgICAgICAgY29kZTonR2liYmVyaXNoLnNjaGVkdWxlci5zaG91bGRTeW5jID0gJyArIHZcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVkdWxlclxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBfX3Byb3h5ID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKSxcbiAgICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbiAgY29uc3QgcHJveHkgPSBfX3Byb3h5KCBHaWJiZXJpc2ggKVxuXG4gIE9iamVjdC5hc3NpZ24oIF9fcHJvdG9fXywge1xuICAgIHN0YXJ0KCBkZWxheT0wICkge1xuICAgICAgaWYoIGRlbGF5ICE9PSAwICkge1xuICAgICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggZGVsYXksICgpPT4ge1xuICAgICAgICAgIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggdGhpcyApXG4gICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnB1c2goIHRoaXMgKVxuICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIHN0b3AoIGRlbGF5PTAgKSB7XG4gICAgICBjb25zdCBpZHggPSBHaWJiZXJpc2guYW5hbHl6ZXJzLmluZGV4T2YoIHRoaXMgKVxuICAgICAgaWYoIGRlbGF5ID09PSAwICkge1xuICAgICAgICBpZiggaWR4ID4gLTEgKSB7XG4gICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBoYXNlID0gMFxuICAgICAgICB0aGlzLm5leHRUaW1lID0gMFxuICAgICAgfWVsc2V7XG4gICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBkZWxheSwgKCk9PiB7XG4gICAgICAgICAgaWYoIGlkeCA+IC0xICkge1xuICAgICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBoYXNlID0gMFxuICAgICAgICAgIHRoaXMubmV4dFRpbWUgPSAwXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBmaXJlKCl7XG4gICAgICBsZXQgdmFsdWUgID0gdHlwZW9mIHRoaXMudmFsdWVzICA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudmFsdWVzICA6IHRoaXMudmFsdWVzWyB0aGlzLl9fdmFsdWVzUGhhc2UrKyAgJSB0aGlzLnZhbHVlcy5sZW5ndGggIF1cbiAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdGhpcy50YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdmFsdWUoKVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiB0aGlzLnRhcmdldFsgdGhpcy5rZXkgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgfVxuICAgICAgICBpZiggdmFsdWUgIT09IHRoaXMuRE5SICkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0WyB0aGlzLmtleSBdKCB2YWx1ZSApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgIGlmKCB2YWx1ZSAhPT0gdGhpcy5ETlIgKVxuICAgICAgICAgIHRoaXMudGFyZ2V0WyB0aGlzLmtleSBdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLy8gWFhYIHdlIG5lZWQgdG8gaW1wbGVtZW50IHByaW9yaXR5LCB3aGljaCB3aWxsIGluIHR1cm4gZGV0ZXJtaW5lIHRoZSBvcmRlclxuICAvLyB0aGF0IHRoZSBzZXF1ZW5jZXJzIGFyZSBhZGRlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gIGNvbnN0IFNlcTIgPSB7IFxuICAgIGNyZWF0ZSggaW5wdXRQcm9wcyApIHtcbiAgICAgIGNvbnN0IHNlcSA9IE9iamVjdC5jcmVhdGUoIF9fcHJvdG9fXyApLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIFNlcTIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuXG4gICAgICBzZXEucGhhc2UgPSAwXG4gICAgICBzZXEuaW5wdXROYW1lcyA9IFsgJ3JhdGUnLCAnZGVuc2l0eScgXVxuICAgICAgc2VxLmlucHV0cyA9IFsgMSwgMSBdXG4gICAgICBzZXEubmV4dFRpbWUgPSAwXG4gICAgICBzZXEuX192YWx1ZXNQaGFzZSA9IDBcbiAgICAgIHNlcS5fX3RpbWluZ3NQaGFzZSA9IDBcbiAgICAgIHNlcS5pZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG4gICAgICBzZXEuZGlydHkgPSB0cnVlXG4gICAgICBzZXEudHlwZSA9ICdzZXEnXG4gICAgICBzZXEuX19hZGRyZXNzZXNfXyA9IHt9XG4gICAgICBzZXEuRE5SID0gLTk4NzY1NDMyMVxuXG4gICAgICBwcm9wZXJ0aWVzLmlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcblxuICAgICAgT2JqZWN0LmFzc2lnbiggc2VxLCBwcm9wZXJ0aWVzICkgXG4gICAgICBzZXEuX19wcm9wZXJ0aWVzX18gPSBwcm9wZXJ0aWVzXG5cbiAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcXVlbmNlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgdmlhIG90aGVyIG1lYW5zLFxuICAgICAgLy8gaW4gR2liYmVyIHRoaXMgaXMgd2hlbiB5b3UgcHJvdmlkZSB0aW1pbmcgdG8gb25lIHNlcXVlbmNlXG4gICAgICAvLyBvbiBhbiBvYmplY3QgYW5kIHdhbnQgdG8gdXNlIHRoYXQgb25lIHBhdHRlcm4gdG8gdHJpZ2dlclxuICAgICAgLy8gbXVsdGlwbGUgc2VxdWVuY2VzLlxuICAgICAgaWYoIHNlcS50aW1pbmdzID09PSBudWxsICkgeyBzZXEubmV4dFRpbWUgPSBJbmZpbml0eSB9IFxuXG4gICAgICAvLyBYWFggdGhpcyBuZWVkcyB0byBiZSBvcHRpbWl6ZWQgYXMgbXVjaCBhcyBodW1hbmx5IHBvc3NpYmxlLCBzaW5jZSBpdCdzIHJ1bm5pbmcgYXQgYXVkaW8gcmF0ZS4uLlxuICAgICAgc2VxLmNhbGxiYWNrID0gZnVuY3Rpb24oIHJhdGUsIGRlbnNpdHkgKSB7XG4gICAgICAgIHdoaWxlKCBzZXEucGhhc2UgPj0gc2VxLm5leHRUaW1lICkge1xuICAgICAgICAgIGxldCB2YWx1ZSAgPSB0eXBlb2Ygc2VxLnZhbHVlcyAgPT09ICdmdW5jdGlvbicgPyBzZXEudmFsdWVzICA6IHNlcS52YWx1ZXNbIHNlcS5fX3ZhbHVlc1BoYXNlKysgICUgc2VxLnZhbHVlcy5sZW5ndGggIF0sXG4gICAgICAgICAgICAgIHNob3VsZFJ1biA9IHRydWVcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgdGltaW5nID0gbnVsbFxuICAgICAgICAgIGlmKCBzZXEudGltaW5ncyAhPT0gbnVsbCAmJiBzZXEudGltaW5ncyAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgICAgIHRpbWluZyA9IHR5cGVvZiBzZXEudGltaW5ncyA9PT0gJ2Z1bmN0aW9uJyA/IHNlcS50aW1pbmdzIDogc2VxLnRpbWluZ3NbIHNlcS5fX3RpbWluZ3NQaGFzZSsrICUgc2VxLnRpbWluZ3MubGVuZ3RoIF1cbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdGltaW5nID09PSAnZnVuY3Rpb24nICkgdGltaW5nID0gdGltaW5nKClcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHNob3VsZEluY3JlYXNlU3BlZWQgPSBkZW5zaXR5IDw9IDEgPyBmYWxzZSA6IHRydWVcblxuICAgICAgICAgIC8vIFhYWCB0aGlzIHN1cHBvcnRzIGFuIGVkZ2UgY2FzZSBpbiBHaWJiZXIsIHdoZXJlIHBhdHRlcm5zIGxpa2UgRXVjbGlkIC8gSGV4IHJldHVyblxuICAgICAgICAgIC8vIG9iamVjdHMgaW5kaWNhdGluZyBib3RoIHdoZXRoZXIgb3Igbm90IHRoZXkgc2hvdWxkIHNob3VsZCB0cmlnZ2VyIHZhbHVlcyBhcyB3ZWxsXG4gICAgICAgICAgLy8gYXMgdGhlIG5leHQgdGltZSB0aGV5IHNob3VsZCBydW4uIHBlcmhhcHMgdGhpcyBjb3VsZCBiZSBtYWRlIG1vcmUgZ2VuZXJhbGl6YWJsZT9cbiAgICAgICAgICBpZiggdGltaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aW1pbmcgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgaWYoIHRpbWluZy5zaG91bGRFeGVjdXRlID09PSAxICkge1xuICAgICAgICAgICAgICBzaG91bGRSdW4gPSB0cnVlXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgc2hvdWxkUnVuID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWluZyA9IHRpbWluZy50aW1lIFxuICAgICAgICAgIH1lbHNlIGlmKCB0aW1pbmcgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBpZiggTWF0aC5yYW5kb20oKSA+PSBkZW5zaXR5ICkgc2hvdWxkUnVuID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggc2hvdWxkUnVuICkge1xuICAgICAgICAgICAgaWYoIHNlcS5tYWludGhyZWFkb25seSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggc2VxLm1haW50aHJlYWRvbmx5LCBzZXEua2V5LCB2YWx1ZSApXG4gICAgICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcS50YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgdmFsdWUoKVxuICAgICAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBzZXEudGFyZ2V0WyBzZXEua2V5IF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoIHZhbHVlICE9PSBzZXEuRE5SICkge1xuICAgICAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSggdmFsdWUgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgICAgICBpZiggdmFsdWUgIT09IHNlcS5ETlIgKVxuICAgICAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHRpbWluZyA9PT0gbnVsbCApIHJldHVyblxuXG4gICAgICAgICAgc2VxLnBoYXNlIC09IHNlcS5uZXh0VGltZVxuXG4gICAgICAgICAgaWYoIHNob3VsZEluY3JlYXNlU3BlZWQgKSB7XG4gICAgICAgICAgICB0aW1pbmcgPSBNYXRoLnJhbmRvbSgpID4gKDIgLSBkZW5zaXR5KSA/IHRpbWluZyAvIDIgOiB0aW1pbmdcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VxLm5leHRUaW1lID0gdGltaW5nXG4gICAgICAgIH1cblxuICAgICAgICBzZXEucGhhc2UgKz0gcmF0ZVxuXG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG5cbiAgICAgIHNlcS51Z2VuTmFtZSA9IHNlcS5jYWxsYmFjay51Z2VuTmFtZSA9ICdzZXFfJyArIHNlcS5pZFxuXG4gICAgICAvLyBzaW5jZSB3ZSdyZSBub3QgcGFzc2luZyBvdXIgc2VxdWVuY2VyIHRocm91Z2ggdGhlIHVnZW4gdGVtcGxhdGUsIHdlIG5lZWRcbiAgICAgIC8vIHRvIGdyYWIgYSBtZW1vcnkgYWRkcmVzcyBmb3IgaXRzIHJhdGUgc28gaXQgY2FuIGJlIHNlcXVlbmNlZCBhbmQgZGVmaW5lXG4gICAgICAvLyBhIHByb3BlcnR5IHRoYXQgbWFuaXB1bGF0ZXMgdGhhdCBtZW1vcnkgYWRkcmVzcy5cbiAgICAgIGNvbnN0IGlkeCA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoIDEgKVxuICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXSA9IHNlcS5yYXRlXG4gICAgICBzZXEuX19hZGRyZXNzZXNfXy5yYXRlID0gaWR4XG5cbiAgICAgIGxldCB2YWx1ZSA9IHNlcS5yYXRlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHNlcSwgJ3JhdGUnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHZhbHVlIH0sXG4gICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICBpZiggdmFsdWUgIT09IHYgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdudW1iZXInICkgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXSA9IHZcblxuICAgICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGlkeCA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoIDEgKVxuICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBkaWR4IF0gPSBzZXEuZGVuc2l0eVxuICAgICAgc2VxLl9fYWRkcmVzc2VzX18uZGVuc2l0eSA9IGRpZHhcblxuICAgICAgbGV0IGR2YWx1ZSA9IHNlcS5kZW5zaXR5XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHNlcSwgJ2RlbnNpdHknLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIGR2YWx1ZSB9LFxuICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgaWYoIGR2YWx1ZSAhPT0gdiApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ251bWJlcicgKSBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGRpZHggXSA9IHZcblxuICAgICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgICAgIGR2YWx1ZSA9IHZcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBHaWJiZXJpc2gudXRpbGl0aWVzLmNyZWF0ZVB1YlN1Yiggc2VxIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3h5KCBbJ1NlcXVlbmNlcjInXSwgcHJvcGVydGllcywgc2VxICkgXG4gICAgfVxuICB9XG5cbiAgU2VxMi5kZWZhdWx0cyA9IHsgcmF0ZTogMSwgZGVuc2l0eToxLCBwcmlvcml0eTowLCBwaGFzZTowIH1cbiAgU2VxMi5jcmVhdGUuRE9fTk9UX09VVFBVVCA9IC05ODc2NTQzMjFcblxuICByZXR1cm4gU2VxMi5jcmVhdGVcblxufVxuXG4iLCJjb25zdCBfX3Byb3h5ID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbmNvbnN0IHJlbmRlckZuYyA9IGZ1bmN0aW9uKCBwYXR0ZXJuICkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIHBhdHRlcm4uZGljdCApXG4gIGNvbnN0IG9ianMgPSBPYmplY3QudmFsdWVzKCBwYXR0ZXJuLmRpY3QgKVxuICAgIC5tYXAoIHYgPT4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KCB2IClcbiAgICA/IEdpYmJlcmlzaC5wcm9jZXNzb3IudWdlbnMuZ2V0KHYuaWQpIFxuICAgIDogdiBcbiAgICApXG5cbiAgLy8gd2UgY3JlYXRlIGEgbmV3IGlubmVyIGZ1bmN0aW9uIHVzaW5nIHRoZSBmdW5jdGlvbiBjb25zdHJ1Y3RvcixcbiAgLy8gd2hlcmUgZXZlcnkgYXJndW1lbnQgaXMgY29kZWdlbidkIGFzIGFuIHVwdmFsdWUgdG8gdGhlXG4gIC8vIHJldHVybmVkIGZ1bmN0aW9uLiBhZnRlciBjb2RlZ2VuIHdlIGNhbGwgdGhlIGZ1bmN0b25cbiAgLy8gdG8gZ2V0IHRoZSBpbm5lciBmdW5jdGlvbiB3aXRoIHRoZSB1cHZhbHVlcyBhbmRkXG4gIC8vIHJldHVybiB0aGF0LiBTdG9yZSByZWZlcmVuY2VzIHRvIGdsb2JhbHMgYXMgdXB2YWx1ZXMgYXMgd2VsbC5cbiAgbGV0IGNvZGUgPSAnbGV0IEdpYmJlcmlzaCA9IF9fR2liYmVyaXNoLCBnbG9iYWwgPSBfX2dsb2JhbDtcXG4nXG4gIGtleXMuZm9yRWFjaCggayA9PiB7XG4gICAgbGV0IGxpbmUgPSBgbGV0ICR7a30gPSBgXG4gICAgY29uc3QgdmFsdWUgPSBwYXR0ZXJuLmRpY3RbIGsgXVxuICAgIGNvbnN0IGdldHRlciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgXG4gICAgICA/IEFycmF5LmlzQXJyYXkoIHZhbHVlIClcbiAgICAgID8gYFske3ZhbHVlLnRvU3RyaW5nKCl9XWBcbiAgICAgIDogYEdpYmJlcmlzaC5wcm9jZXNzb3IudWdlbnMuZ2V0KCR7IHZhbHVlLmlkIH0pYFxuICAgICAgOiB2YWx1ZVxuICAgIGxpbmUgKz0gZ2V0dGVyIFxuICAgIGNvZGUgKz0gbGluZSArICdcXG4nXG5cbiAgfSkgIFxuICBjb2RlICs9YHJldHVybiBmdW5jdGlvbigpIHsgJHsgcGF0dGVybi5mbmNzdHIgfSB9YCBcblxuICAvLyBwYXNzIGluIGdsb2JhbHMgdG8gYmUgdXNlZCBhcyB1cHZhbHVlcyBpbiBmaW5hbCBmdW5jdGlvblxuICBjb25zdCBmbmMgPSBuZXcgRnVuY3Rpb24oICdfX0dpYmJlcmlzaCcsICdfX2dsb2JhbCcsIGNvZGUgKSggR2liYmVyaXNoLCBnbG9iYWwgKVxuXG4gIHJldHVybiBmbmMgXG59XG5cbmNvbnN0IHByb3h5ID0gX19wcm94eSggR2liYmVyaXNoIClcblxuY29uc3QgU2VxdWVuY2VyID0gcHJvcHMgPT4ge1xuICBsZXQgX19zZXFcbiAgbGV0IGZsb2F0RXJyb3IgPSAwXG5cbiAgY29uc3Qgc2VxID0ge1xuICAgIHR5cGU6J3NlcScsXG4gICAgX19pc1J1bm5pbmc6ZmFsc2UsXG4gICAgX192YWx1ZXNQaGFzZTogIDAsXG4gICAgX190aW1pbmdzUGhhc2U6IDAsXG4gICAgX19vbmx5UnVuc09uY2U6IGZhbHNlLFxuICAgIF9fcmVwZWF0Q291bnQ6IG51bGwsXG4gICAgRE5SIDogLTk4NzY1NDMyMSxcblxuICAgIHRpY2soIHByaW9yaXR5ICkge1xuICAgICAgbGV0IHZhbHVlICA9IHR5cGVvZiBzZXEudmFsdWVzICA9PT0gJ2Z1bmN0aW9uJyBcbiAgICAgICAgICA/IHNlcS52YWx1ZXMgIFxuICAgICAgICAgIDogc2VxLnZhbHVlc1sgIHNlcS5fX3ZhbHVlc1BoYXNlKysgICUgc2VxLnZhbHVlcy5sZW5ndGggIF0sXG5cbiAgICAgICAgdGltaW5nID0gdHlwZW9mIHNlcS50aW1pbmdzID09PSAnZnVuY3Rpb24nIFxuICAgICAgICAgID8gc2VxLnRpbWluZ3MgXG4gICAgICAgICAgOiBzZXEudGltaW5ncyAhPT0gbnVsbFxuICAgICAgICAgICAgPyBzZXEudGltaW5nc1sgc2VxLl9fdGltaW5nc1BoYXNlKysgJSBzZXEudGltaW5ncy5sZW5ndGggXVxuICAgICAgICAgICAgOiBudWxsLFxuXG4gICAgICAgIHNob3VsZFJ1biA9IHRydWVcbiAgICAgIFxuICAgICAgaWYoIHNlcS5fX29ubHlSdW5zT25jZSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgaWYoIHNlcS5fX3ZhbHVlc1BoYXNlID09PSBzZXEudmFsdWVzLmxlbmd0aCApIHtcbiAgICAgICAgICBzZXEuc3RvcCgpXG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmKCBzZXEuX19yZXBlYXRDb3VudCAhPT0gbnVsbCApIHtcbiAgICAgICAgaWYoIHNlcS5fX3ZhbHVlc1BoYXNlICUgc2VxLnZhbHVlcy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgc2VxLl9fcmVwZWF0Q291bnQtLVxuICAgICAgICAgIGlmKCBzZXEuX19yZXBlYXRDb3VudCA9PT0gMCApIHtcbiAgICAgICAgICAgIHNlcS5zdG9wKClcbiAgICAgICAgICAgIHNlcS5fX3JlcGVhdENvdW50ID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggdHlwZW9mIHRpbWluZyA9PT0gJ2Z1bmN0aW9uJyApIHRpbWluZyA9IHRpbWluZygpXG5cbiAgICAgIC8vIFhYWCB0aGlzIHN1cHBvcnRzIGFuIGVkZ2UgY2FzZSBpbiBHaWJiZXIsIHdoZXJlIHBhdHRlcm5zIGxpa2UgRXVjbGlkIC8gSGV4IHJldHVyblxuICAgICAgLy8gb2JqZWN0cyBpbmRpY2F0aW5nIGJvdGggd2hldGhlciBvciBub3QgdGhleSBzaG91bGQgc2hvdWxkIHRyaWdnZXIgdmFsdWVzIGFzIHdlbGxcbiAgICAgIC8vIGFzIHRoZSBuZXh0IHRpbWUgdGhleSBzaG91bGQgcnVuLiBwZXJoYXBzIHRoaXMgY291bGQgYmUgbWFkZSBtb3JlIGdlbmVyYWxpemFibGU/XG4gICAgICBpZiggdGltaW5nICE9PSBudWxsICkge1xuICAgICAgICBpZiggdHlwZW9mIHRpbWluZyA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgaWYoIHRpbWluZy5zaG91bGRFeGVjdXRlID09PSAxICkge1xuICAgICAgICAgICAgc2hvdWxkUnVuID0gdHJ1ZVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc2hvdWxkUnVuID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltaW5nID0gdGltaW5nLnRpbWUgXG4gICAgICAgIH1cblxuICAgICAgICB0aW1pbmcgKj0gc2VxLnJhdGVcbiAgICAgIH1lbHNle1xuICAgICAgICBzaG91bGRSdW4gPSBmYWxzZSBcbiAgICAgIH1cblxuICAgICAgaWYoIHZhbHVlID09PSBTZXF1ZW5jZXIuRE9fTk9UX09VVFBVVCApIHNob3VsZFJ1biA9IGZhbHNlXG5cbiAgICAgIGlmKCBzaG91bGRSdW4gKSB7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBpZiggc2VxLm1haW50aHJlYWRvbmx5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdtYWluIHRocmVhZCBvbmx5JyApXG4gICAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLm1lc3NhZ2VzLnB1c2goIHNlcS5tYWludGhyZWFkb25seSwgc2VxLmtleSwgdmFsdWUgKVxuICAgICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VxLnRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgdmFsdWUoKVxuICAgICAgICAgIH1lbHNlIGlmKCB0eXBlb2Ygc2VxLnRhcmdldFsgc2VxLmtleSBdID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggc2VxLmtleSwgc2VxLnRhcmdldCApXG4gICAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgICAgICBpZiggdmFsdWUgIT09IHNlcS5ETlIgKVxuICAgICAgICAgICAgICBzZXEudGFyZ2V0WyBzZXEua2V5IF0oIHZhbHVlIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgICAgIGlmKCB2YWx1ZSAhPT0gc2VxLkROUiApXG4gICAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9IHZhbHVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHNlcS5yZXBvcnRPdXRwdXQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBhZGRyZXNzOidfX3NlcXVlbmNlcicsXG4gICAgICAgICAgICAgIGlkOiBzZXEuaWQsXG4gICAgICAgICAgICAgIG5hbWU6J291dHB1dCcsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBwaGFzZTogc2VxLl9fdmFsdWVzUGhhc2UsXG4gICAgICAgICAgICAgIGxlbmd0aDogc2VxLnZhbHVlcy5sZW5ndGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCBgQSBzZXF1ZW5jZSB0YXJnZXRpbmcgJHtzZXEudGFyZ2V0LnVnZW5OYW1lfS4ke3NlcS5rZXl9IGNvbnRhaW5zIGFuIGltcHJvcGVyIHZhbHVlIGFuZCB3aWxsIGJlIHN0b3BwZWQuYCApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgaWYoIHNlcS5fX2lzUnVubmluZyA9PT0gdHJ1ZSAmJiAhaXNOYU4oIHRpbWluZyApICYmIHNlcS5hdXRvdHJpZyA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgdGltaW5nICs9IGZsb2F0RXJyb3JcbiAgICAgICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggdGltaW5nLCBzZXEudGljaywgc2VxLnByaW9yaXR5IClcbiAgICAgICAgICBmbG9hdEVycm9yID0gdGltaW5nIC0gTWF0aC5mbG9vciggdGltaW5nIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmlyZSgpe1xuICAgICAgbGV0IHZhbHVlICA9IHR5cGVvZiB0aGlzLnZhbHVlcyAgPT09ICdmdW5jdGlvbicgPyB0aGlzLnZhbHVlcyAgOiB0aGlzLnZhbHVlc1sgdGhpcy5fX3ZhbHVlc1BoYXNlKysgICUgdGhpcy52YWx1ZXMubGVuZ3RoICBdXG4gICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRoaXMudGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHZhbHVlKClcbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdGhpcy50YXJnZXRbIHRoaXMua2V5IF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHZhbHVlICE9PSB0aGlzLkROUiApIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFsgdGhpcy5rZXkgXSggdmFsdWUgKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICBpZiggdmFsdWUgIT09IHRoaXMuRE5SIClcbiAgICAgICAgICB0aGlzLnRhcmdldFsgdGhpcy5rZXkgXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXJ0KCBkZWxheSA9IDAgKSB7XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICYmIHNlcS5fX2lzUnVubmluZyA9PT0gZmFsc2UgKSB7XG4gICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBcbiAgICAgICAgICBkZWxheSwgXG4gICAgICAgICAgcHJpb3JpdHkgPT4ge1xuICAgICAgICAgICAgc2VxLnRpY2soIHByaW9yaXR5IClcbiAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGFkZHJlc3M6J19fc2VxdWVuY2VyJyxcbiAgICAgICAgICAgICAgaWQ6IHNlcS5pZCxcbiAgICAgICAgICAgICAgbmFtZTonc3RhcnQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIFxuICAgICAgICAgIHNlcS5wcmlvcml0eSBcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgc2VxLl9faXNSdW5uaW5nID0gdHJ1ZVxuICAgICAgc2VxLl9fZGVsYXkgPSBkZWxheVxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfSxcblxuICAgIHN0b3AoIGRlbGF5ID0gbnVsbCApIHtcbiAgICAgIGlmKCBkZWxheSA9PT0gbnVsbCApIHtcbiAgICAgICAgc2VxLl9faXNSdW5uaW5nID0gZmFsc2VcblxuICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidfX3NlcXVlbmNlcicsXG4gICAgICAgICAgICBpZDogc2VxLmlkLFxuICAgICAgICAgICAgbmFtZTonc3RvcCdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBcbiAgICAgIH1lbHNle1xuICAgICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggZGVsYXksIHNlcS5zdG9wIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3NlcVxuICAgIH0sXG5cbiAgICBvbmNlKCkge1xuICAgICAgc2VxLl9fb25seVJ1bnNPbmNlID0gdHJ1ZVxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfSxcblxuICAgIHJlcGVhdCggcmVwZWF0Q291bnQgPSAyICkge1xuICAgICAgc2VxLl9fcmVwZWF0Q291bnQgPSByZXBlYXRDb3VudFxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfVxuICB9XG5cbiAgcHJvcHMuaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuXG4gIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgIEdpYmJlcmlzaC51dGlsaXRpZXMuY3JlYXRlUHViU3ViKCBzZXEgKVxuICB9ZWxzZXtcbiAgICAvLyBuZWVkIGEgc2VwYXJhdGUgcmVmZXJlbmNlIHRvIHRoZSBwcm9wZXJ0aWVzIGZvciB3b3JrbGV0IG1ldGEtcHJvZ3JhbW1pbmdcbiAgICBpZiggdHlwZW9mIHByb3BzLnZhbHVlcyA9PT0gJ29iamVjdCcgJiYgcHJvcHMudmFsdWVzLnJlcXVpcmVzUmVuZGVyID09PSB0cnVlICkge1xuICAgICAgcHJvcHMudmFsdWVzID0gcmVuZGVyRm5jKCBwcm9wcy52YWx1ZXMgKVxuICAgIH1cbiAgICBpZiggcHJvcHMudGltaW5ncyAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMudGltaW5ncyA9PT0gJ29iamVjdCcgJiYgcHJvcHMudGltaW5ncy5yZXF1aXJlc1JlbmRlciA9PT0gdHJ1ZSApIHtcbiAgICAgIHByb3BzLnRpbWluZ3MgPSByZW5kZXJGbmMoIHByb3BzLnRpbWluZ3MgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgU2VxdWVuY2VyLmRlZmF1bHRzLCBwcm9wcyApXG4gIE9iamVjdC5hc3NpZ24oIHNlcSwgcHJvcGVydGllcyApIFxuICBzZXEuX19wcm9wZXJ0aWVzX18gPSBwcm9wZXJ0aWVzXG5cbiAgX19zZXEgPSAgcHJveHkoIFsnU2VxdWVuY2VyJ10sIHByb3BlcnRpZXMsIHNlcSApXG5cbiAgcmV0dXJuIF9fc2VxXG59XG5cblNlcXVlbmNlci5kZWZhdWx0cyA9IHsgcHJpb3JpdHk6MTAwLCByYXRlOjEsIHJlcG9ydE91dHB1dDpmYWxzZSwgYXV0b3RyaWc6ZmFsc2UgfVxuXG5TZXF1ZW5jZXIubWFrZSA9IGZ1bmN0aW9uKCB2YWx1ZXMsIHRpbWluZ3MsIHRhcmdldCwga2V5LCBwcmlvcml0eSwgcmVwb3J0T3V0cHV0ICkge1xuICByZXR1cm4gU2VxdWVuY2VyKHsgdmFsdWVzLCB0aW1pbmdzLCB0YXJnZXQsIGtleSwgcHJpb3JpdHksIHJlcG9ydE91dHB1dCB9KVxufVxuXG5TZXF1ZW5jZXIuRE9fTk9UX09VVFBVVCA9IC05ODc2NTQzMjFcblxucmV0dXJuIFNlcXVlbmNlclxuXG59XG4iLCJjb25zdCBfX3Byb3h5ID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKVxuY29uc3QgUGF0dGVybiA9IHJlcXVpcmUoICd0aWRhbC5wZWdqcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbmNvbnN0IHByb3h5ID0gX19wcm94eSggR2liYmVyaXNoIClcblxuY29uc3QgU2VxdWVuY2VyID0gcHJvcHMgPT4ge1xuICBsZXQgX19zZXFcbiAgY29uc3Qgc2VxID0ge1xuICAgIF9faXNSdW5uaW5nOmZhbHNlLFxuXG4gICAgX19waGFzZTogIDAsXG4gICAgX190eXBlOidzZXEnLFxuICAgIF9fcGF0dGVybjogUGF0dGVybiggcHJvcHMucGF0dGVybiwgeyBhZGRMb2NhdGlvbnM6dHJ1ZSwgYWRkVUlEOnRydWUsIGVuY2xvc2U6dHJ1ZSB9KSxcbiAgICBfX2V2ZW50czogbnVsbCxcblxuICAgIHRpY2soIHByaW9yaXR5ICkge1xuICAgICAgLy8gcnVubmluZyBmb3IgZmlyc3QgdGltZSwgcGVyZm9ybSBhIHF1ZXJ5XG4gICAgICBpZiggc2VxLl9fZXZlbnRzID09PSBudWxsIHx8IHNlcS5fX2V2ZW50cy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgIHNlcS5fX2V2ZW50cyA9IHNlcS5fX3BhdHRlcm4ucXVlcnkoIHNlcS5fX3BoYXNlKyssIDEgKVxuICAgICAgfVxuXG4gICAgICAvLyB1c2VkIHdoZW4gc2NoZWR1bGluZyBldmVudHMgdGhhdCBhcmUgdmVyeSBmYXIgYXBhcnRcbiAgICAgIGlmKCBzZXEuX19ldmVudHMubGVuZ3RoIDw9IDAgKSB7XG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgaWYoIHNlcS5fX2lzUnVubmluZyA9PT0gdHJ1ZSAgKSB7XG4gICAgICAgICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gU2VxdWVuY2VyLmNsb2NrLmNwcywgc2VxLnRpY2ssIHNlcS5wcmlvcml0eSApXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VxLl9fZXZlbnRzWyAwIF0uYXJjLnN0YXJ0XG5cbiAgICAgIGlmKCBzZXEua2V5ICE9PSAnY2hvcmQnICkge1xuICAgICAgICB3aGlsZSggc2VxLl9fZXZlbnRzLmxlbmd0aCA+IDAgJiYgc3RhcnRUaW1lLnZhbHVlT2YoKSA9PT0gc2VxLl9fZXZlbnRzWzBdLmFyYy5zdGFydC52YWx1ZU9mKCkgKSB7XG4gICAgICAgICAgbGV0IGV2ZW50ICA9IHNlcS5fX2V2ZW50cy5zaGlmdCgpLFxuICAgICAgICAgICAgICB2YWx1ZSAgPSBldmVudC52YWx1ZSxcbiAgICAgICAgICAgICAgdWlkICAgID0gZXZlbnQudWlkXG5cbiAgICAgICAgICAvLyBmb3IgYmpvcmtsdW5kIGV0Yy5cbiAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyApIHZhbHVlID0gdmFsdWUudmFsdWVcblxuICAgICAgICAgIGlmKCBzZXEuZmlsdGVycyAhPT0gbnVsbCApIHZhbHVlID0gc2VxLmZpbHRlcnMucmVkdWNlKCAoY3VycmVudFZhbHVlLCBmaWx0ZXIpID0+IGZpbHRlciggY3VycmVudFZhbHVlLCBzZXEsIHVpZCApLCB2YWx1ZSApICBcbiAgICAgICAgICBpZiggc2VxLm1haW50aHJlYWRvbmx5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggc2VxLm1haW50aHJlYWRvbmx5LCBzZXEua2V5LCB2YWx1ZSApXG4gICAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBzZXEudGFyZ2V0WyBzZXEua2V5IF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICBzZXEudGFyZ2V0WyBzZXEua2V5IF0oIHZhbHVlIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbGV0IHZhbHVlID0gc2VxLl9fZXZlbnRzLmZpbHRlciggZXZ0ID0+IHN0YXJ0VGltZS52YWx1ZU9mKCkgPT09IGV2dC5hcmMuc3RhcnQudmFsdWVPZigpICkubWFwKCBldnQgPT4gZXZ0LnZhbHVlIClcbiAgICAgICAgbGV0IHVpZCA9IHNlcS5fX2V2ZW50c1swXS51aWRcblxuICAgICAgICBjb25zdCBldmVudHMgPSBzZXEuX19ldmVudHMuc3BsaWNlKCAwLCB2YWx1ZS5sZW5ndGggKVxuXG4gICAgICAgIGlmKCBzZXEuZmlsdGVycyAhPT0gbnVsbCApIHtcbiAgICAgICAgICBpZiggdmFsdWUubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgdmFsdWUgPSBzZXEuZmlsdGVycy5yZWR1Y2UoIChjdXJyZW50VmFsdWUsIGZpbHRlcikgPT4gZmlsdGVyKCBjdXJyZW50VmFsdWUsIHNlcSwgdWlkICksIHZhbHVlICkgIFxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCggKHYsaSkgPT4gc2VxLmZpbHRlcnMucmVkdWNlKCAoY3VycmVudFZhbHVlLCBmaWx0ZXIpID0+IGZpbHRlciggY3VycmVudFZhbHVlLCBzZXEsIGV2ZW50c1sgaSBdLnVpZCApLCB2ICkgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0eXBlb2Ygc2VxLnRhcmdldFsgc2VxLmtleSBdID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSggdmFsdWUgKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzZXEudGFyZ2V0WyBzZXEua2V5IF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIGxldCB0aW1pbmdcbiAgICAgICAgaWYoIHNlcS5fX2V2ZW50cy5sZW5ndGggPD0gMCApIHtcbiAgICAgICAgICBsZXQgdGltZSA9IDBcbiAgICAgICAgICB3aGlsZSggc2VxLl9fZXZlbnRzLmxlbmd0aCA8PSAwICkge1xuICAgICAgICAgICAgc2VxLl9fZXZlbnRzID0gc2VxLl9fcGF0dGVybi5xdWVyeSggc2VxLl9fcGhhc2UrKywgMSApXG4gICAgICAgICAgICB0aW1lKytcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9zZXEuX19ldmVudHMuZm9yRWFjaCggZXZ0ID0+IHtcbiAgICAgICAgICAvLyAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuYWRkKCAxICkuc3ViKCBzdGFydFRpbWUgKSBcbiAgICAgICAgICAvLyAgZXZ0LmFyYy5lbmQgICA9IGV2dC5hcmMuZW5kLmFkZCggMSApLnN1Yiggc3RhcnRUaW1lIClcbiAgICAgICAgICAvL30pXG5cbiAgICAgICAgICB0aW1pbmcgPSB0aW1lIC0gc3RhcnRUaW1lLnZhbHVlT2YoKSBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGltaW5nID0gc2VxLl9fZXZlbnRzWzBdLmFyYy5zdGFydC5zdWIoIHN0YXJ0VGltZSApLnZhbHVlT2YoKSBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGltaW5nICo9IE1hdGguY2VpbCggR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gU2VxdWVuY2VyLmNsb2NrLmNwcyApICsgMSBcblxuICAgICAgICBpZiggc2VxLl9faXNSdW5uaW5nID09PSB0cnVlICYmICFpc05hTiggdGltaW5nICkgJiYgdGltaW5nID4gMCApIHtcbiAgICAgICAgICAvLyBYWFggdGhpcyBzdXBwb3J0cyBhbiBlZGdlIGNhc2UgaW4gR2liYmVyLCB3aGVyZSBwYXR0ZXJucyBsaWtlIEV1Y2xpZCAvIEhleCByZXR1cm5cbiAgICAgICAgICAvLyBvYmplY3RzIGluZGljYXRpbmcgYm90aCB3aGV0aGVyIG9yIG5vdCB0aGV5IHNob3VsZCBzaG91bGQgdHJpZ2dlciB2YWx1ZXMgYXMgd2VsbFxuICAgICAgICAgIC8vIGFzIHRoZSBuZXh0IHRpbWUgdGhleSBzaG91bGQgcnVuLiBwZXJoYXBzIHRoaXMgY291bGQgYmUgbWFkZSBtb3JlIGdlbmVyYWxpemFibGU/XG4gICAgICAgICAgXG4gICAgICAgICAgLy9pZiggdHlwZW9mIHRpbWluZyA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgLy8gIGlmKCB0aW1pbmcuc2hvdWxkRXhlY3V0ZSA9PT0gMSApIHtcbiAgICAgICAgICAvLyAgICBzaG91bGRSdW4gPSB0cnVlXG4gICAgICAgICAgLy8gIH1lbHNle1xuICAgICAgICAgIC8vICAgIHNob3VsZFJ1biA9IGZhbHNlXG4gICAgICAgICAgLy8gIH1cbiAgICAgICAgICAvLyAgdGltaW5nID0gdGltaW5nLnRpbWUgXG4gICAgICAgICAgLy99XG5cbiAgICAgICAgICAvL3RpbWluZyAqPSBzZXEucmF0ZVxuXG4gICAgICAgICAgR2liYmVyaXNoLnNjaGVkdWxlci5hZGQoIHRpbWluZywgc2VxLnRpY2ssIHNlcS5wcmlvcml0eSApXG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgfSxcblxuICAgIHJvdGF0ZSggYW10ICkge1xuICAgICAgc2VxLl9fcGhhc2UgKz0gYW10XG4gICAgICByZXR1cm4gX19zZXEgXG4gICAgfSxcblxuICAgIHN0YXJ0KCBkZWxheSA9IDAgKSB7XG4gICAgICBzZXEuX19pc1J1bm5pbmcgPSB0cnVlXG4gICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggZGVsYXksIHNlcS50aWNrLCBzZXEucHJpb3JpdHkgKVxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfSxcblxuICAgIHN0b3AoKSB7XG4gICAgICBzZXEuX19pc1J1bm5pbmcgPSBmYWxzZVxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfSxcblxuICAgIHNldCggcGF0dGVyblN0cmluZyApIHtcbiAgICAgIHNlcS5fX3BhdHRlcm4gPSBQYXR0ZXJuKCBwYXR0ZXJuU3RyaW5nLCB7IGFkZExvY2F0aW9uczp0cnVlLCBhZGRVSUQ6dHJ1ZSwgZW5jbG9zZTp0cnVlIH0pXG5cbiAgICB9XG4gIH1cblxuICBwcm9wcy5pZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG5cbiAgLy8gbmVlZCBhIHNlcGFyYXRlIHJlZmVyZW5jZSB0byB0aGUgcHJvcGVydGllcyBmb3Igd29ya2xldCBtZXRhLXByb2dyYW1taW5nXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgU2VxdWVuY2VyLmRlZmF1bHRzLCBwcm9wcyApXG4gIE9iamVjdC5hc3NpZ24oIHNlcSwgcHJvcGVydGllcyApIFxuICBzZXEuX19wcm9wZXJ0aWVzX18gPSBwcm9wZXJ0aWVzXG5cbiAgX19zZXEgPSAgcHJveHkoIFsnVGlkYWwnXSwgcHJvcGVydGllcywgc2VxIClcblxuICByZXR1cm4gX19zZXFcbn1cblxuU2VxdWVuY2VyLmRlZmF1bHRzID0geyBwcmlvcml0eToxMDAwMDAsIHBhdHRlcm46JycsIHJhdGU6MSwgZmlsdGVyczpudWxsIH1cblxuU2VxdWVuY2VyLm1ha2UgPSBmdW5jdGlvbiggdmFsdWVzLCB0aW1pbmdzLCB0YXJnZXQsIGtleSwgcHJpb3JpdHkgKSB7XG4gIHJldHVybiBTZXF1ZW5jZXIoeyB2YWx1ZXMsIHRpbWluZ3MsIHRhcmdldCwga2V5LCBwcmlvcml0eSB9KVxufVxuXG5sZXQgX191aWQgPSAwXG5TZXF1ZW5jZXIuZ2V0VUlEID0gKCk9PiB7XG4gIHJldHVybiBfX3VpZCsrXG59XG5cblNlcXVlbmNlci5QYXR0ZXJuID0gUGF0dGVyblxuXG5TZXF1ZW5jZXIuY2xvY2sgPSB7IGNwczogMSB9XG5cblNlcXVlbmNlci5pZCA9IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKClcblxuaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgIGFkZHJlc3M6J2V2YWwnLFxuICAgIGNvZGU6YEdpYmJlcmlzaC5UaWRhbC5jbG9jay5pZCA9ICR7U2VxdWVuY2VyLmlkfTsgR2liYmVyaXNoLnVnZW5zLnNldCggJHtTZXF1ZW5jZXIuaWR9LCBHaWJiZXJpc2guVGlkYWwuY2xvY2sgKWBcbiAgfSlcbiAgXG4gIGxldCBjcHMgPSAxXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggU2VxdWVuY2VyLCAnY3BzJywge1xuICAgIGdldCgpIHsgcmV0dXJuIGNwcyB9LFxuICAgIHNldCh2KXsgXG4gICAgICBjcHMgPSB2XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWRkcmVzczonc2V0JyxcbiAgICAgICAgICBvYmplY3Q6U2VxdWVuY2VyLmlkLFxuICAgICAgICAgIG5hbWU6J2NwcycsXG4gICAgICAgICAgdmFsdWU6Y3BzIFxuICAgICAgICB9KSBcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbnJldHVybiBTZXF1ZW5jZXJcblxufVxuIiwibGV0IEdpYmJlcmlzaCA9IG51bGxcblxuY29uc3QgX191Z2VuID0gZnVuY3Rpb24oIF9fR2liYmVyaXNoICkge1xuICBpZiggX19HaWJiZXJpc2ggIT09IHVuZGVmaW5lZCAmJiBHaWJiZXJpc2ggPT0gbnVsbCApIEdpYmJlcmlzaCA9IF9fR2liYmVyaXNoXG4gXG4gIGNvbnN0IHJlcGxhY2UgPSBvYmogPT4ge1xuICAgIGlmKCB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyApIHtcbiAgICAgIGlmKCBvYmouaWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Nvci51Z2Vucy5nZXQoIG9iai5pZCApXG4gICAgICB9IFxuICAgIH1cblxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGNvbnN0IHVnZW4gPSB7XG4gICAgX19HaWJiZXJpc2g6R2liYmVyaXNoLFxuXG4gICAgZnJlZTpmdW5jdGlvbigpIHtcbiAgICAgIEdpYmJlcmlzaC5nZW5pc2guZ2VuLmZyZWUoIHRoaXMuZ3JhcGggKVxuICAgIH0sXG5cbiAgICBwcmludDpmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKCB0aGlzLmNhbGxiYWNrLnRvU3RyaW5nKCkgKVxuICAgIH0sXG5cbiAgICBjb25uZWN0OmZ1bmN0aW9uKCB0YXJnZXQsIGxldmVsPTEgKSB7XG4gICAgICBpZiggdGhpcy5jb25uZWN0ZWQgPT09IHVuZGVmaW5lZCApIHRoaXMuY29ubmVjdGVkID0gW11cblxuICAgICAgLy9sZXQgaW5wdXQgPSBsZXZlbCA9PT0gMSA/IHRoaXMgOiBHaWJiZXJpc2guYmlub3BzLk11bCggdGhpcywgbGV2ZWwgKVxuICAgICAgbGV0IGlucHV0ID0gdGhpc1xuXG4gICAgICBpZiggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkgdGFyZ2V0ID0gR2liYmVyaXNoLm91dHB1dCBcblxuXG4gICAgICAvLyBYWFggSSBmb3Jnb3QsIHdoZXJlIGlzIF9fYWRkSW5wdXQgZm91bmQ/IENhbiB3ZSBjb250cm9sIHRoZVxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIGlucHV0P1xuICAgICAgaWYoIHR5cGVvZiB0YXJnZXQuX19hZGRJbnB1dCA9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICB0YXJnZXQuX19hZGRJbnB1dCggaW5wdXQgKVxuICAgICAgfSBlbHNlIGlmKCB0YXJnZXQuc3VtICYmIHRhcmdldC5zdW0uaW5wdXRzICkge1xuICAgICAgICB0YXJnZXQuc3VtLmlucHV0cy5wdXNoKCBpbnB1dCApXG4gICAgICB9IGVsc2UgaWYoIHRhcmdldC5pbnB1dHMgKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldC5pbnB1dHMuaW5kZXhPZiggaW5wdXQgKVxuXG4gICAgICAgIC8vIGlmIG5vIGNvbm5lY3Rpb24gZXhpc3RzLi4uXG4gICAgICAgIGlmKCBpZHggPT09IC0xICkge1xuICAgICAgICAgIHRhcmdldC5pbnB1dHMudW5zaGlmdCggaW5wdXQsIGxldmVsLCBpbnB1dC5pc1N0ZXJlbyApXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UgdXBkYXRlIHRoZSBjb25uZWN0aW9uJ3MgbGV2ZWwsIHdoaWNoIGlzIHN0b3JlZFxuICAgICAgICAgIC8vIG9uZSBpbmRleCBoaWdoZXIgaW4gdGhlIGlucHV0IGxpc3QuXG4gICAgICAgICAgdGFyZ2V0LmlucHV0c1sgaWR4ICsgMSBdID0gbGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LmlucHV0ID0gaW5wdXRcbiAgICAgICAgdGFyZ2V0LmlucHV0R2FpbiA9IGxldmVsXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGFyZ2V0IClcblxuICAgICAgdGhpcy5jb25uZWN0ZWQucHVzaChbIHRhcmdldCwgaW5wdXQsIGxldmVsIF0pXG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGRpc2Nvbm5lY3Q6ZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICAgIGlmKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdGhpcy5jb25uZWN0ZWQgKSApIHtcbiAgICAgICAgICBmb3IoIGxldCBjb25uZWN0aW9uIG9mIHRoaXMuY29ubmVjdGVkICkge1xuICAgICAgICAgICAgaWYoIGNvbm5lY3Rpb25bMF0uZGlzY29ubmVjdFVnZW4gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvblswXS5kaXNjb25uZWN0VWdlbiggY29ubmVjdGlvblsxXSApXG4gICAgICAgICAgICB9ZWxzZSBpZiggY29ubmVjdGlvblswXS5pbnB1dCA9PT0gdGhpcyApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvblswXS5pbnB1dCA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWQubGVuZ3RoID0gMFxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGVkLmZpbmQoIHYgPT4gdlswXSA9PT0gdGFyZ2V0IClcbiAgICAgICAgLy8gaWYgdGFyZ2V0IGlzIGEgYnVzLi4uXG4gICAgICAgIGlmKCB0YXJnZXQuZGlzY29ubmVjdFVnZW4gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBpZiggY29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgdGFyZ2V0LmRpc2Nvbm5lY3RVZ2VuKCBjb25uZWN0aW9uWzFdIClcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIG11c3QgYmUgYW4gZWZmZWN0LCBzZXQgaW5wdXQgdG8gMFxuICAgICAgICAgIHRhcmdldC5pbnB1dCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldElkeCA9IHRoaXMuY29ubmVjdGVkLmluZGV4T2YoIGNvbm5lY3Rpb24gKVxuXG4gICAgICAgIGlmKCB0YXJnZXRJZHggIT09IC0xICkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdGVkLnNwbGljZSggdGFyZ2V0SWR4LCAxIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFpbjpmdW5jdGlvbiggdGFyZ2V0LCBsZXZlbD0xICkge1xuICAgICAgdGhpcy5jb25uZWN0KCB0YXJnZXQsbGV2ZWwgKVxuXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIF9fcmVkb0dyYXBoOmZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGlzU3RlcmVvID0gdGhpcy5pc1N0ZXJlb1xuICAgICAgdGhpcy5fX2NyZWF0ZUdyYXBoKClcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBHaWJiZXJpc2guZ2VuaXNoLmdlbi5jcmVhdGVDYWxsYmFjayggdGhpcy5ncmFwaCwgR2liYmVyaXNoLm1lbW9yeSwgZmFsc2UsIHRydWUgKVxuICAgICAgdGhpcy5pbnB1dE5hbWVzID0gbmV3IFNldCggR2liYmVyaXNoLmdlbmlzaC5nZW4ucGFyYW1ldGVycyApIFxuICAgICAgdGhpcy5jYWxsYmFjay51Z2VuTmFtZSA9IHRoaXMudWdlbk5hbWVcbiAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGhpcyApXG5cbiAgICAgIC8vIGlmIGNoYW5uZWwgY291bnQgaGFzIGNoYW5nZWQgYWZ0ZXIgcmVjb21waWxpbmcgZ3JhcGguLi5cbiAgICAgIGlmKCBpc1N0ZXJlbyAhPT0gdGhpcy5pc1N0ZXJlbyApIHtcblxuICAgICAgICAvLyBjaGVjayBmb3IgYW55IGNvbm5lY3Rpb25zIGJlZm9yZSBpdGVyYXRpbmcuLi5cbiAgICAgICAgaWYoIHRoaXMuY29ubmVjdGVkID09PSB1bmRlZmluZWQgKSByZXR1cm5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidXNzZXMgdGhlIHVnZW4gaXMgY29ubmVjdGVkIHRvXG4gICAgICAgIGZvciggbGV0IGNvbm5lY3Rpb24gb2YgdGhpcy5jb25uZWN0ZWQgKSB7XG4gICAgICAgICAgLy8gc2V0IHRoZSBkaXJ0eSBmbGFnIG9mIHRoZSBidXNcbiAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIGNvbm5lY3Rpb25bIDAgXSApXG5cbiAgICAgICAgICAvLyBjaGVjayBmb3IgaW5wdXRzIGFycmF5LCB3aGljaCBpbmRpY2F0ZXMgY29ubmVjdGlvbiBpcyB0byBhIGJ1c1xuICAgICAgICAgIGlmKCBjb25uZWN0aW9uWzBdLmlucHV0cyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgaW5wdXQgaW4gdGhlIGJ1c3NlcyAnaW5wdXRzJyBhcnJheVxuICAgICAgICAgICAgY29uc3QgaW5wdXRJZHggPSBjb25uZWN0aW9uWyAwIF0uaW5wdXRzLmluZGV4T2YoIGNvbm5lY3Rpb25bIDEgXSApXG5cbiAgICAgICAgICAgIC8vIGFzc3VtaWluZyBpdCBpcyBmb3VuZC4uLlxuICAgICAgICAgICAgaWYoIGlucHV0SWR4ICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgLy8gY2hhbmdlIHN0ZXJlbyBmaWVsZFxuICAgICAgICAgICAgICBjb25uZWN0aW9uWyAwIF0uaW5wdXRzWyBpbnB1dElkeCArIDIgXSA9IHRoaXMuaXNTdGVyZW9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSBpZiggY29ubmVjdGlvblswXS5pbnB1dCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgaWYoIGNvbm5lY3Rpb25bMF0uX19yZWRvR3JhcGggIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvblswXS5fX3JlZG9HcmFwaCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIHJldHVybiB1Z2VuXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfX3VnZW5cbiIsImNvbnN0IGdlbmlzaCA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBBV1BGID0gcmVxdWlyZSggJy4vZXh0ZXJuYWwvYXVkaW93b3JrbGV0LXBvbHlmaWxsLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxubGV0IHVpZCA9IDBcbmNvbnN0IHV0aWxpdGllcyA9IHtcbiAgTWFrZTogZnVuY3Rpb24oIHByb3BzICl7XG4gICAgY29uc3QgbmFtZSA9IHByb3BzLm5hbWUgfHwgJ1VnZW4nICsgKE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkqMTAwMDAgKSApXG4gICAgY29uc3QgdHlwZSA9IHByb3BzLnR5cGUgfHwgJ1VnZW4nXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByb3BzLnByb3BlcnRpZXMgfHwge31cbiAgICBjb25zdCBibG9jayA9IGBcbiAgICBjb25zdCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggR2liYmVyaXNoLnByb3RvdHlwZXNbICcke3R5cGV9JyBdIClcbiAgICBjb25zdCBncmFwaGZuYyA9ICR7cHJvcHMuY29uc3RydWN0b3IudG9TdHJpbmcoKX1cblxuICAgIGNvbnN0IHByb3h5ID0gR2liYmVyaXNoLmZhY3RvcnkoIHVnZW4sIGdyYXBoZm5jKCksICcke25hbWV9JywgJHtKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKX0gKVxuICAgIGlmKCB0eXBlb2YgcHJvcHMgPT09ICdvYmplY3QnICkgT2JqZWN0LmFzc2lnbiggcHJveHksIHByb3BzIClcblxuICAgIHJldHVybiBwcm94eWBcblxuICAgIEdpYmJlcmlzaFsgbmFtZSBdID0gbmV3IEZ1bmN0aW9uKCAncHJvcHMnLCBibG9jayApXG5cbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIG5hbWUsXG4gICAgICBhZGRyZXNzOidhZGRDb25zdHJ1Y3RvcicsXG4gICAgICBjb25zdHJ1Y3RvclN0cmluZzpgZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgICAgIGNvbnN0IGZuYyA9ICR7R2liYmVyaXNoWyBuYW1lIF0udG9TdHJpbmcoKX1cblxuICAgICAgcmV0dXJuIGZuY1xuICAgIH1gXG4gICAgfSlcblxuICAgIHJldHVybiBHaWJiZXJpc2hbIG5hbWUgXVxuICB9LFxuXG4gIGNyZWF0ZUNvbnRleHQoIGN0eCwgY2IsIHJlc29sdmUsIGJ1ZmZlclNpemU9MjA0OCApIHtcbiAgICBsZXQgQUMgPSB0eXBlb2YgQXVkaW9Db250ZXh0ID09PSAndW5kZWZpbmVkJyA/IHdlYmtpdEF1ZGlvQ29udGV4dCA6IEF1ZGlvQ29udGV4dFxuXG4gICAgQVdQRiggd2luZG93LCBidWZmZXJTaXplIClcblxuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYoIHR5cGVvZiBBQyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gR2liYmVyaXNoLmN0eCA9IGN0eCA9PT0gdW5kZWZpbmVkID8gbmV3IEFDKHsgbGF0ZW5jeUhpbnQ6LjAyNSB9KSA6IGN0eFxuXG4gICAgICAgIGdlbmlzaC5nZW4uc2FtcGxlcmF0ZSA9IHRoaXMuY3R4LnNhbXBsZVJhdGVcbiAgICAgICAgZ2VuaXNoLnV0aWxpdGllcy5jdHggPSB0aGlzLmN0eFxuXG4gICAgICAgIGlmKCBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHN0YXJ0IClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBzdGFydCApXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgc3RhcnQgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbXlTb3VyY2UgPSB1dGlsaXRpZXMuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gICAgICAgIG15U291cmNlLmNvbm5lY3QoIHV0aWxpdGllcy5jdHguZGVzdGluYXRpb24gKVxuICAgICAgICBteVNvdXJjZS5zdGFydCgpXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgKSBjYiggcmVzb2x2ZSApXG4gICAgfVxuXG4gICAgaWYoIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBzdGFydCApXG4gICAgfWVsc2V7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIHN0YXJ0IClcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHN0YXJ0IClcbiAgICB9XG5cbiAgICByZXR1cm4gR2liYmVyaXNoLmN0eFxuICB9LFxuICBcbiAgY3JlYXRlV29ya2xldCggcmVzb2x2ZSApIHtcbiAgICBHaWJiZXJpc2guY3R4LmF1ZGlvV29ya2xldC5hZGRNb2R1bGUoIEdpYmJlcmlzaC53b3JrbGV0UGF0aCApLnRoZW4oICgpID0+IHtcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0ID0gbmV3IEF1ZGlvV29ya2xldE5vZGUoIEdpYmJlcmlzaC5jdHgsICdnaWJiZXJpc2gnLCB7IG91dHB1dENoYW5uZWxDb3VudDpbMl0gfSApXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LmNvbm5lY3QoIEdpYmJlcmlzaC5jdHguZGVzdGluYXRpb24gKVxuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gR2liYmVyaXNoLnV0aWxpdGllcy53b3JrbGV0SGFuZGxlcnNbIGV2ZW50LmRhdGEuYWRkcmVzcyBdXG4gICAgICAgIGlmKCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSBjYWxsYmFjayggZXZlbnQgKSAgICAgXG4gICAgICB9XG4gICAgICBHaWJiZXJpc2gud29ya2xldC51Z2VucyA9IG5ldyBNYXAoKVxuXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9LFxuXG4gIGZ1dHVyZSggZm5jLCB0aW1lLCBkaWN0ICkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggZGljdCApXG4gICAgY29uc3QgY29kZSA9IGBcbiAgICAgIGNvbnN0IGZuYyA9ICR7Zm5jLnRvU3RyaW5nKCl9XG4gICAgICBjb25zdCBhcmdzID0gWyR7a2V5cy5tYXAoIGtleSA9PiB0eXBlb2YgZGljdFtrZXldID09PSAnb2JqZWN0JyA/IGRpY3RbIGtleSBdLmlkIDogYCcke2RpY3RbIGtleV19J2AgKS5qb2luKCcsJyl9XVxuICAgICAgY29uc3Qgb2JqcyA9IGFyZ3MubWFwKCB2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IEdpYmJlcmlzaC5wcm9jZXNzb3IudWdlbnMuZ2V0KHYpIDogdiApXG4gICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggJHt0aW1lfSwgKCk9PiBmbmMoIC4uLm9ianMgKSwgMSApXG4gICAgYCBcbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICBhZGRyZXNzOidldmFsJywgXG4gICAgICBjb2RlXG4gICAgfSlcbiAgfSxcblxuICB3b3JrbGV0SGFuZGxlcnM6IHtcbiAgICBwaGFzZSggZXZlbnQgKSB7XG4gICAgICBHaWJiZXJpc2gucGhhc2UgPSBldmVudC5kYXRhLnZhbHVlXG4gICAgICBpZiggdHlwZW9mIEdpYmJlcmlzaC5vbnBoYXNldXBkYXRlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBHaWJiZXJpc2gub25waGFzZXVwZGF0ZSggR2liYmVyaXNoLnBoYXNlIClcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fc2VxdWVuY2VyKCBldmVudCApIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhXG4gICAgICBjb25zdCBpZCA9IG1lc3NhZ2UuaWRcbiAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG1lc3NhZ2UubmFtZVxuICAgICAgY29uc3Qgb2JqID0gR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCBpZCApXG4gICAgICBpZiggb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqLnB1Ymxpc2ggIT09IHVuZGVmaW5lZCApXG4gICAgICAgIG9iai5wdWJsaXNoKCBldmVudE5hbWUsIG1lc3NhZ2UgKVxuICAgIH0sXG4gICAgY2FsbGJhY2soIGV2ZW50ICkge1xuICAgICAgaWYoIHR5cGVvZiBHaWJiZXJpc2gub25jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgR2liYmVyaXNoLm9uY2FsbGJhY2soIGV2ZW50LmRhdGEuY29kZSApXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQoIGV2ZW50ICkge1xuICAgICAgbGV0IG5hbWUgPSBldmVudC5kYXRhLm5hbWVcbiAgICAgIGxldCB2YWx1ZVxuICAgICAgaWYoIG5hbWVbMF0gPT09ICdHaWJiZXJpc2gnICkge1xuICAgICAgICB2YWx1ZSA9IEdpYmJlcmlzaFxuICAgICAgICBuYW1lLnNoaWZ0KClcbiAgICAgIH1cbiAgICAgIGZvciggbGV0IHNlZ21lbnQgb2YgbmFtZSApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVsgc2VnbWVudCBdXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOidzZXQnLFxuICAgICAgICBuYW1lOidHaWJiZXJpc2guJyArIG5hbWUuam9pbignLicpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSlcbiAgICB9LFxuICAgIHN0YXRlKCBldmVudCApe1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBldmVudC5kYXRhLm1lc3NhZ2VzXG4gICAgICBpZiggbWVzc2FnZXMubGVuZ3RoID09PSAwICkgcmV0dXJuXG5cbiAgICAgIC8vIFhYWCBpcyBwcmV2ZW50UHJveHkgYWN0dWFsbHkgdXNlZD9cbiAgICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSB0cnVlXG4gICAgICBHaWJiZXJpc2gucHJveHlFbmFibGVkID0gZmFsc2VcblxuICAgICAgbGV0IGkgPSAwXG4gICAgICB3aGlsZSggaSA8IG1lc3NhZ2VzLmxlbmd0aCApIHtcbiAgICAgICAgY29uc3QgaWQgPSBtZXNzYWdlc1sgaSBdIFxuICAgICAgICBjb25zdCBwcm9wTmFtZSA9IG1lc3NhZ2VzWyBpICsgMSBdXG4gICAgICAgIGNvbnN0IHZhbHVlTCA9IG1lc3NhZ2VzWyBpICsgMiBdXG4gICAgICAgIGNvbnN0IHZhbHVlUiA9IG1lc3NhZ2VzWyBpICsgMyBdXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVMXG4gICAgICAgIGNvbnN0IG9iaiA9IEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLmdldCggaWQgKVxuXG4gICAgICAgIGlmKCBHaWJiZXJpc2gud29ya2xldC5kZWJ1ZyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICBpZiggcHJvcE5hbWUgIT09ICdvdXRwdXQnICkgY29uc29sZS5sb2coIHByb3BOYW1lLCB2YWx1ZSwgaWQgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHR5cGVvZiBwcm9wTmFtZSAhPT0gJ3N0cmluZycgKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgaWYoIG9iaiAhPT0gdW5kZWZpbmVkICYmIHByb3BOYW1lLmluZGV4T2YoJy4nKSA9PT0gLTEgJiYgcHJvcE5hbWUgIT09ICdpZCcgKSB7IFxuICAgICAgICAgIGlmKCBvYmpbIHByb3BOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2Ygb2JqWyBwcm9wTmFtZSBdICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICBpZiggcHJvcE5hbWUgPT09ICdvdXRwdXQnICkge1xuICAgICAgICAgICAgICAgIG9ialsgcHJvcE5hbWUgXSA9IFsgdmFsdWVMLCB2YWx1ZVIgXVxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBvYmpbIHByb3BOYW1lIF0gPSB2YWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgb2JqWyBwcm9wTmFtZSBdKCB2YWx1ZSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvYmpbIHByb3BOYW1lIF0gPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2UgaWYoIG9iaiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIGNvbnN0IHByb3BTcGxpdCA9IHByb3BOYW1lLnNwbGl0KCcuJylcbiAgICAgICAgICBpZiggb2JqWyBwcm9wU3BsaXRbIDAgXSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBpZiggcHJvcFNwbGl0WzFdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2Ygb2JqWyBwcm9wU3BsaXRbIDAgXSBdWyBwcm9wU3BsaXRbIDEgXSBdICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgIG9ialsgcHJvcFNwbGl0WyAwIF0gXVsgcHJvcFNwbGl0WyAxIF0gXSA9IHZhbHVlXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG9ialsgcHJvcFNwbGl0WyAwIF0gXVsgcHJvcFNwbGl0WyAxIF0gXSggdmFsdWUgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAndW5kZWZpbmVkIHNwbGl0IHByb3BlcnR5IScsIGlkLCBwcm9wU3BsaXRbMF0sIHByb3BTcGxpdFsxXSwgdmFsdWUsIG9iaiApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBkb3VibGUgY2hlY2sgYW5kIG1ha2Ugc3VyZSB0aGlzIGlzbid0IGdldHRpbmcgc2VudCBiYWNrIHRvIHByb2Nlc3Nvcm5vZGUuLi5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIHByb3BOYW1lLCB2YWx1ZSwgb2JqIClcbiAgICAgICAgaSArPSBwcm9wTmFtZSA9PT0gJ291dHB1dCcgPyA0IDogM1xuICAgICAgfVxuICAgICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IGZhbHNlXG4gICAgICBHaWJiZXJpc2gucHJveHlFbmFibGVkID0gdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVQdWJTdWIoIG9iaiApIHtcbiAgICBjb25zdCBldmVudHMgPSB7fVxuICAgIG9iai5vbiA9IGZ1bmN0aW9uKCBrZXksIGZjbiApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGV2ZW50c1sga2V5IF0gPSBbXVxuICAgICAgfVxuICAgICAgZXZlbnRzWyBrZXkgXS5wdXNoKCBmY24gKVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIG9iai5vZmYgPSBmdW5jdGlvbigga2V5LCBmY24gKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBjb25zdCBhcnIgPSBldmVudHNbIGtleSBdXG5cbiAgICAgICAgYXJyLnNwbGljZSggYXJyLmluZGV4T2YoIGZjbiApLCAxIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICBvYmoucHVibGlzaCA9IGZ1bmN0aW9uKCBrZXksIGRhdGEgKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBjb25zdCBhcnIgPSBldmVudHNbIGtleSBdXG5cbiAgICAgICAgYXJyLmZvckVhY2goIHYgPT4gdiggZGF0YSApIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gIH0sXG5cbiAgd3JhcCggZnVuYywgLi4uYXJncyApIHtcbiAgICBjb25zdCBvdXQgPSB7XG4gICAgICBhY3Rpb246J3dyYXAnLFxuICAgICAgdmFsdWU6ZnVuYyxcbiAgICAgIC8vIG11c3QgcmV0dXJuIG9iamVjdHMgY29udGFpbmluZyBvbmx5IHRoZSBpZCBudW1iZXIgdG8gYXZvaWRcbiAgICAgIC8vIGNyZWF0aW5nIGNpcmN1bGFyIEpTT04gcmVmZXJlbmNlcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIHBhc3NpbmcgYWN0dWFsIHVnZW5zXG4gICAgICBhcmdzOiBhcmdzLm1hcCggdiA9PiB7IHJldHVybiB7IGlkOnYuaWQgfSB9KVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cbiAgLy8gZm9yIHdyYXBwaW5nIHVwdmFsdWVzIGluIGEgZGljdGlvbmFyeSBhbmQgcGFzc2luZyBmdW5jdGlvbiBhY3Jvc3MgdGhyZWFkXG4gIC8vIHRvIGJlIHJlY29uc3RydWN0ZWQuXG4gIC8vIGV4OyB3cmFwcGVkID0gZm4oICgpPT4geyByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHRlc3QgfSwgeyB0ZXN0OjIwIH0pXG4gIC8vIHN5bi5ub3RlLnNlcSggd3JhcHBlZCwgMS80IClcbiAgZm4oIGZuYywgZGljdD17fSkge1xuICAgIGNvbnN0IGZuY3N0ciA9IGZuYy50b1N0cmluZygpXG4gICAgY29uc3QgZmlyc3RCcmFja2V0SWR4ID0gZm5jc3RyLmluZGV4T2YoJ3snKVxuICAgIGNvbnN0IGNvZGUgPSBmbmNzdHIuc2xpY2UoZmlyc3RCcmFja2V0SWR4KzEsIC0xIClcbiAgICBjb25zdCBzID0geyByZXF1aXJlc1JlbmRlcjp0cnVlLCBmaWx0ZXJzOltdLCBmbmNzdHI6Y29kZSwgYXJnczpbXSwgZGljdCwgYWRkRmlsdGVyKCBmICkgeyB0aGlzLmZpbHRlcnMucHVzaChmKSB9IH0gIFxuICAgIHJldHVybiBzXG4gIH0sXG5cbiAgcnVuKCBmbmMgKSB7IFxuICAgIGNvbnN0IHN0ciA9IGZuYy50b3N0cmluZygpXG4gICAgY29uc3QgaWR4ID0gc3RyLmluZGV4b2YoJz0+JykgKyAyXG4gICAgY29uc3QgY29kZSA9IHN0ci5zbGljZSggaWR4ICkudHJpbSgpXG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgYWRkcmVzczonZXZhbCcsXG4gICAgICBjb2RlXG4gICAgfSlcbiAgfSxcblxuICBleHBvcnQoIG9iaiApIHtcbiAgICBvYmoud3JhcCA9IHRoaXMud3JhcFxuICAgIG9iai5mdXR1cmUgPSB0aGlzLmZ1dHVyZVxuICAgIG9iai5NYWtlID0gdGhpcy5NYWtlXG4gIH0sXG5cbiAgZ2V0VUlEKCkgeyByZXR1cm4gdWlkKysgfSxcblxuICBiYXNlNjQgOiB7XG4gICAgX2tleVN0ciA6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIixcbiAgICAvLyB3aWxsIHJldHVybiBhICBVaW50OEFycmF5IHR5cGVcbiAgICBkZWNvZGVBcnJheUJ1ZmZlcjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gKGlucHV0Lmxlbmd0aC80KSAqIDM7XG4gICAgICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcyk7XG4gICAgICAgIHRoaXMuZGVjb2RlKGlucHV0LCBhYik7XG5cbiAgICAgICAgcmV0dXJuIGFiO1xuICAgIH0sXG4gICAgZGVjb2RlOiBmdW5jdGlvbihpbnB1dCwgYXJyYXlCdWZmZXIpIHtcbiAgICAgIC8vZ2V0IGxhc3QgY2hhcnMgdG8gc2VlIGlmIGFyZSB2YWxpZFxuICAgICAgdmFyIGxrZXkxID0gdGhpcy5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aC0xKSk7XHRcdCBcbiAgICAgIHZhciBsa2V5MiA9IHRoaXMuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGgtMikpO1x0XHQgXG4gICAgICB2YXIgYnl0ZXMgPSAoaW5wdXQubGVuZ3RoLzQpICogMztcbiAgICAgIGlmIChsa2V5MSA9PSA2NCkgYnl0ZXMtLTsgLy9wYWRkaW5nIGNoYXJzLCBzbyBza2lwXG4gICAgICBpZiAobGtleTIgPT0gNjQpIGJ5dGVzLS07IC8vcGFkZGluZyBjaGFycywgc28gc2tpcFxuICAgICAgdmFyIHVhcnJheTtcbiAgICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICBpZiAoYXJyYXlCdWZmZXIpXG4gICAgICAgICAgdWFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgZWxzZVxuICAgICAgICAgIHVhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csIFwiXCIpO1xuICAgICAgZm9yIChpPTA7IGk8Ynl0ZXM7IGkrPTMpIHtcdFxuICAgICAgICAgIC8vZ2V0IHRoZSAzIG9jdGVjdHMgaW4gNCBhc2NpaSBjaGFyc1xuICAgICAgICAgIGVuYzEgPSB0aGlzLl9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaisrKSk7XG4gICAgICAgICAgZW5jMiA9IHRoaXMuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChqKyspKTtcbiAgICAgICAgICBlbmMzID0gdGhpcy5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGorKykpO1xuICAgICAgICAgIGVuYzQgPSB0aGlzLl9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaisrKSk7XG5cbiAgICAgICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICAgIHVhcnJheVtpXSA9IGNocjE7XHRcdFx0XG4gICAgICAgICAgaWYgKGVuYzMgIT0gNjQpIHVhcnJheVtpKzFdID0gY2hyMjtcbiAgICAgICAgICBpZiAoZW5jNCAhPSA2NCkgdWFycmF5W2krMl0gPSBjaHIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVhcnJheTtcdFxuICAgIH1cbiAgfVxufVxuXG5yZXR1cm4gdXRpbGl0aWVzXG5cbn1cbiIsImNvbnN0IHNlcmlhbGl6ZSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1qYXZhc2NyaXB0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG5jb25zdCByZXBsYWNlT2JqID0gZnVuY3Rpb24oIG9iaiwgc2hvdWxkU2VyaWFsaXplRnVuY3Rpb25zID0gdHJ1ZSApIHtcbiAgaWYoIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBvYmouaWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICBpZiggb2JqLl9fdHlwZSAhPT0gJ3NlcScgKSB7IC8vIFhYWCB3aHk/XG4gICAgICByZXR1cm4geyBpZDpvYmouaWQsIHByb3A6b2JqLnByb3AgfVxuICAgIH1lbHNle1xuICAgICAgLy8gc2hvdWxkbid0IEkgYmUgc2VyaWFsaXppbmcgbW9zdCBvYmplY3RzLCBub3QganVzdCBzZXFzP1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZSggb2JqIClcbiAgICB9XG4gIH1lbHNlIGlmKCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIHNob3VsZFNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gdHJ1ZSApIHtcbiAgICByZXR1cm4geyBpc0Z1bmM6dHJ1ZSwgdmFsdWU6c2VyaWFsaXplKCBvYmogKSB9XG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG5jb25zdCBtYWtlQW5kU2VuZE9iamVjdCA9IGZ1bmN0aW9uKCBfX25hbWUsIHZhbHVlcywgb2JqICkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge31cblxuICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRocm91Z2ggbWVzc2FnZXBvcnQuLi5cblxuICBmb3IoIGxldCBrZXkgaW4gdmFsdWVzICkge1xuICAgIGNvbnN0IGFscmVhZHlQcm9jZXNzZWQgPSAodHlwZW9mIHZhbHVlc1sga2V5IF0gPT09ICdvYmplY3QnICYmIHZhbHVlc1sga2V5IF0gIT09IG51bGwgJiYgdmFsdWVzWyBrZXkgXS5fX21ldGFfXyAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgKHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZXNbIGtleSBdLl9fbWV0YV9fICE9PSB1bmRlZmluZWQgKVxuXG4gICAgaWYoIGFscmVhZHlQcm9jZXNzZWQgKSB7IFxuICAgICAgcHJvcGVydGllc1sga2V5IF0gPSB7IGlkOnZhbHVlc1sga2V5IF0uX19tZXRhX18uaWQgfVxuICAgIH1lbHNlIGlmKCBBcnJheS5pc0FycmF5KCB2YWx1ZXNbIGtleSBdICkgKSB7XG4gICAgICBjb25zdCBhcnIgPSBbXVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB2YWx1ZXNbIGtleSBdLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBhcnJbIGkgXSA9IHJlcGxhY2VPYmooIHZhbHVlc1sga2V5IF1baV0sIGZhbHNlICApXG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzWyBrZXkgXSA9IGFyclxuICAgIH1lbHNlIGlmKCB0eXBlb2YgdmFsdWVzW2tleV0gPT09ICdvYmplY3QnICYmIHZhbHVlc1trZXldICE9PSBudWxsICl7XG4gICAgICBwcm9wZXJ0aWVzWyBrZXkgXSA9IHJlcGxhY2VPYmooIHZhbHVlc1sga2V5IF0sIGZhbHNlIClcbiAgICB9ZWxzZXtcbiAgICAgIHByb3BlcnRpZXNbIGtleSBdID0gdmFsdWVzWyBrZXkgXVxuICAgIH1cbiAgfVxuXG4gIGxldCBzZXJpYWxpemVkUHJvcGVydGllcyA9IHNlcmlhbGl6ZSggcHJvcGVydGllcyApXG5cbiAgaWYoIEFycmF5LmlzQXJyYXkoIF9fbmFtZSApICkge1xuICAgIGNvbnN0IG9sZE5hbWUgPSBfX25hbWVbIF9fbmFtZS5sZW5ndGggLSAxIF1cbiAgICBfX25hbWVbIF9fbmFtZS5sZW5ndGggLSAxIF0gPSBvbGROYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBvbGROYW1lLnN1YnN0cmluZygxKVxuICB9ZWxzZXtcbiAgICBfX25hbWUgPSBbIF9fbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgX19uYW1lLnN1YnN0cmluZygxKSBdXG4gIH1cblxuICBvYmouX19tZXRhX18gPSB7XG4gICAgYWRkcmVzczonYWRkJyxcbiAgICBuYW1lOl9fbmFtZSxcbiAgICBwcm9wZXJ0aWVzOnNlcmlhbGl6ZWRQcm9wZXJ0aWVzLCBcbiAgICBpZDpvYmouaWRcbiAgfVxuXG4gIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggb2JqLmlkLCBvYmogKVxuXG4gIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoIG9iai5fX21ldGFfXyApXG59XG5cbmNvbnN0IGRvTm90UHJveHkgPSBbICdjb25uZWN0ZWQnLCAnaW5wdXQnLCAnd3JhcCcsICdjYWxsYmFjaycsICdpbnB1dE5hbWVzJywgJ29uJywgJ29mZicsJ3B1Ymxpc2gnIF1cbiAgIFxuY29uc3QgX19wcm94eSA9IGZ1bmN0aW9uKCBfX25hbWUsIHZhbHVlcywgb2JqICkge1xuXG4gIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICYmIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPT09IGZhbHNlICkge1xuICAgIG1ha2VBbmRTZW5kT2JqZWN0KCBfX25hbWUsIHZhbHVlcywgb2JqIClcblxuICAgIC8vIHByb3h5IGZvciBhbGwgbWV0aG9kIGNhbGxzIHRvIHNlbmQgdG8gd29ya2xldFxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KCBvYmosIHtcbiAgICAgIGdldCggdGFyZ2V0LCBwcm9wLCByZWNlaXZlciApIHtcbiAgICAgICAgaWYoIHR5cGVvZiB0YXJnZXRbIHByb3AgXSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wLmluZGV4T2YoJ19fJykgPT09IC0xICYmIGRvTm90UHJveHkuaW5kZXhPZiggcHJvcCApID09PSAtMSApIHtcbiAgICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSggdGFyZ2V0WyBwcm9wIF0sIHtcbiAgICAgICAgICAgIGFwcGx5KCBfX3RhcmdldCwgdGhpc0FyZywgYXJncyApIHtcblxuICAgICAgICAgICAgICBpZiggR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfX2FyZ3MgPSBhcmdzLm1hcCggX192YWx1ZSA9PiByZXBsYWNlT2JqKCBfX3ZhbHVlLCB0cnVlICkgKVxuXG4gICAgICAgICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgICAgICAgICAgICAgYWRkcmVzczonbWV0aG9kJywgXG4gICAgICAgICAgICAgICAgICBvYmplY3Q6b2JqLmlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTpwcm9wLFxuICAgICAgICAgICAgICAgICAgYXJnczpfX2FyZ3NcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IEdpYmJlcmlzaC5wcm94eUVuYWJsZWRcbiAgICAgICAgICAgICAgR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IGZhbHNlXG4gICAgICAgICAgICAgIGNvbnN0IG91dCA9ICBfX3RhcmdldC5hcHBseSggdGhpc0FyZywgYXJncyApXG4gICAgICAgICAgICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0ZW1wXG4gICAgICAgICAgICAgIHJldHVybiBvdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBwcm94eVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFsgcHJvcCBdXG4gICAgICB9LFxuICAgICAgc2V0KCB0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlciApIHtcbiAgICAgICAgaWYoIGRvTm90UHJveHkuaW5kZXhPZiggcHJvcCApID09PSAtMSApIHsgXG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBjb25zdCBfX3ZhbHVlID0gcmVwbGFjZU9iaiggdmFsdWUgKVxuXG4gICAgICAgICAgICBpZiggX192YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgICAgICAgYWRkcmVzczonc2V0JywgXG4gICAgICAgICAgICAgICAgb2JqZWN0Om9iai5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOnByb3AsXG4gICAgICAgICAgICAgICAgdmFsdWU6X192YWx1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFsgcHJvcCBdID0gdmFsdWVcblxuICAgICAgICAvLyBtdXN0IHJldHVybiB0cnVlIGZvciBhbnkgRVM2IHByb3h5IHNldHRlclxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBYWFggWFhYIFhYWCBYWFggWFhYIFhYWFxuICAgIC8vIFJFTUVNQkVSIFRIQVQgWU9VIE1VU1QgQVNTSUdOIFRIRSBSRVRVUk5FRCBWQUxVRSBUTyBZT1VSIFVHRU4sXG4gICAgLy8gWU9VIENBTk5PVCBVU0UgVEhJUyBGVU5DVElPTiBUTyBNT0RJRlkgQSBVR0VOIElOIFBMQUNFLlxuICAgIC8vIFhYWCBYWFggWFhYIFhYWCBYWFggWFhYXG5cbiAgICByZXR1cm4gcHJveHlcbiAgfWVsc2UgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyAmJiBHaWJiZXJpc2gucHJldmVudFByb3h5ID09PSBmYWxzZSApIHtcblxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KCBvYmosIHtcbiAgICAgIC8vZ2V0KCB0YXJnZXQsIHByb3AsIHJlY2VpdmVyICkgeyByZXR1cm4gdGFyZ2V0WyBwcm9wIF0gfSxcbiAgICAgIHNldCggdGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIgKSB7XG4gICAgICAgIGxldCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgICAgICAgaWYoIHByb3AuaW5kZXhPZignX18nKSA9PT0gLTEgJiYgdmFsdWVUeXBlICE9PSAnZnVuY3Rpb24nICYmIHZhbHVlVHlwZSAhPT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5wcm9jZXNzb3IgIT09IHVuZGVmaW5lZCApIHsgXG4gICAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLm1lc3NhZ2VzLnB1c2goIG9iai5pZCwgcHJvcCwgdmFsdWUgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbIHByb3AgXSA9IHZhbHVlXG5cbiAgICAgICAgLy8gbXVzdCByZXR1cm4gdHJ1ZSBmb3IgYW55IEVTNiBwcm94eSBzZXR0ZXJcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb3h5XG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbnJldHVybiBfX3Byb3h5XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgTWVtb3J5SGVscGVyID0ge1xuICBjcmVhdGUoIHNpemVPckJ1ZmZlcj00MDk2LCBtZW10eXBlPUZsb2F0MzJBcnJheSApIHtcbiAgICBsZXQgaGVscGVyID0gT2JqZWN0LmNyZWF0ZSggdGhpcyApXG5cbiAgICAvLyBjb252ZW5pZW50bHksIGJ1ZmZlciBjb25zdHJ1Y3RvcnMgYWNjZXB0IGVpdGhlciBhIHNpemUgb3IgYW4gYXJyYXkgYnVmZmVyIHRvIHVzZS4uLlxuICAgIC8vIHNvLCBubyBtYXR0ZXIgd2hpY2ggaXMgcGFzc2VkIHRvIHNpemVPckJ1ZmZlciBpdCBzaG91bGQgd29yay5cbiAgICBPYmplY3QuYXNzaWduKCBoZWxwZXIsIHtcbiAgICAgIGhlYXA6IG5ldyBtZW10eXBlKCBzaXplT3JCdWZmZXIgKSxcbiAgICAgIGxpc3Q6IHt9LFxuICAgICAgZnJlZUxpc3Q6IHt9XG4gICAgfSlcblxuICAgIHJldHVybiBoZWxwZXJcbiAgfSxcblxuICBhbGxvYyggc2l6ZSwgaW1tdXRhYmxlICkge1xuICAgIGxldCBpZHggPSAtMVxuXG4gICAgaWYoIHNpemUgPiB0aGlzLmhlYXAubGVuZ3RoICkge1xuICAgICAgdGhyb3cgRXJyb3IoICdBbGxvY2F0aW9uIHJlcXVlc3QgaXMgbGFyZ2VyIHRoYW4gaGVhcCBzaXplIG9mICcgKyB0aGlzLmhlYXAubGVuZ3RoIClcbiAgICB9XG5cbiAgICBmb3IoIGxldCBrZXkgaW4gdGhpcy5mcmVlTGlzdCApIHtcbiAgICAgIGxldCBjYW5kaWRhdGUgPSB0aGlzLmZyZWVMaXN0WyBrZXkgXVxuXG4gICAgICBpZiggY2FuZGlkYXRlLnNpemUgPj0gc2l6ZSApIHtcbiAgICAgICAgaWR4ID0ga2V5XG5cbiAgICAgICAgdGhpcy5saXN0WyBpZHggXSA9IHsgc2l6ZSwgaW1tdXRhYmxlLCByZWZlcmVuY2VzOjEgfVxuXG4gICAgICAgIGlmKCBjYW5kaWRhdGUuc2l6ZSAhPT0gc2l6ZSApIHtcbiAgICAgICAgICBsZXQgbmV3SW5kZXggPSBpZHggKyBzaXplLFxuICAgICAgICAgICAgICBuZXdGcmVlU2l6ZVxuXG4gICAgICAgICAgZm9yKCBsZXQga2V5IGluIHRoaXMubGlzdCApIHtcbiAgICAgICAgICAgIGlmKCBrZXkgPiBuZXdJbmRleCApIHtcbiAgICAgICAgICAgICAgbmV3RnJlZVNpemUgPSBrZXkgLSBuZXdJbmRleFxuICAgICAgICAgICAgICB0aGlzLmZyZWVMaXN0WyBuZXdJbmRleCBdID0gbmV3RnJlZVNpemVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBpZHggIT09IC0xICkgZGVsZXRlIHRoaXMuZnJlZUxpc3RbIGlkeCBdXG5cbiAgICBpZiggaWR4ID09PSAtMSApIHtcbiAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoIHRoaXMubGlzdCApLFxuICAgICAgICAgIGxhc3RJbmRleFxuXG4gICAgICBpZigga2V5cy5sZW5ndGggKSB7IC8vIGlmIG5vdCBmaXJzdCBhbGxvY2F0aW9uLi4uXG4gICAgICAgIGxhc3RJbmRleCA9IHBhcnNlSW50KCBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXSApXG5cbiAgICAgICAgaWR4ID0gbGFzdEluZGV4ICsgdGhpcy5saXN0WyBsYXN0SW5kZXggXS5zaXplXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWR4ID0gMFxuICAgICAgfVxuXG4gICAgICB0aGlzLmxpc3RbIGlkeCBdID0geyBzaXplLCBpbW11dGFibGUsIHJlZmVyZW5jZXM6MSB9XG4gICAgfVxuXG4gICAgaWYoIGlkeCArIHNpemUgPj0gdGhpcy5oZWFwLmxlbmd0aCApIHtcbiAgICAgIHRocm93IEVycm9yKCAnTm8gYXZhaWxhYmxlIGJsb2NrcyByZW1haW4gc3VmZmljaWVudCBmb3IgYWxsb2NhdGlvbiByZXF1ZXN0LicgKVxuICAgIH1cbiAgICByZXR1cm4gaWR4XG4gIH0sXG5cbiAgYWRkUmVmZXJlbmNlKCBpbmRleCApIHtcbiAgICBpZiggdGhpcy5saXN0WyBpbmRleCBdICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgdGhpcy5saXN0WyBpbmRleCBdLnJlZmVyZW5jZXMrK1xuICAgIH1cbiAgfSxcblxuICBmcmVlKCBpbmRleCApIHtcbiAgICBpZiggdGhpcy5saXN0WyBpbmRleCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICB0aHJvdyBFcnJvciggJ0NhbGxpbmcgZnJlZSgpIG9uIG5vbi1leGlzdGluZyBibG9jay4nIClcbiAgICB9XG5cbiAgICBsZXQgc2xvdCA9IHRoaXMubGlzdFsgaW5kZXggXVxuICAgIGlmKCBzbG90ID09PSAwICkgcmV0dXJuXG4gICAgc2xvdC5yZWZlcmVuY2VzLS1cblxuICAgIGlmKCBzbG90LnJlZmVyZW5jZXMgPT09IDAgJiYgc2xvdC5pbW11dGFibGUgIT09IHRydWUgKSB7ICAgIFxuICAgICAgdGhpcy5saXN0WyBpbmRleCBdID0gMFxuXG4gICAgICBsZXQgZnJlZUJsb2NrU2l6ZSA9IDBcbiAgICAgIGZvciggbGV0IGtleSBpbiB0aGlzLmxpc3QgKSB7XG4gICAgICAgIGlmKCBrZXkgPiBpbmRleCApIHtcbiAgICAgICAgICBmcmVlQmxvY2tTaXplID0ga2V5IC0gaW5kZXhcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJlZUxpc3RbIGluZGV4IF0gPSBmcmVlQmxvY2tTaXplXG4gICAgfVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbW9yeUhlbHBlclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIEEgbGlicmFyeSBvZiBzZWVkYWJsZSBSTkdzIGltcGxlbWVudGVkIGluIEphdmFzY3JpcHQuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG4vLyB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbSgxKTsgLy8gb3IgYW55IHNlZWQuXG4vLyB2YXIgeCA9IHJhbmRvbSgpOyAgICAgICAvLyAwIDw9IHggPCAxLiAgRXZlcnkgYml0IGlzIHJhbmRvbS5cbi8vIHZhciB4ID0gcmFuZG9tLnF1aWNrKCk7IC8vIDAgPD0geCA8IDEuICAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXG5cbi8vIGFsZWEsIGEgNTMtYml0IG11bHRpcGx5LXdpdGgtY2FycnkgZ2VuZXJhdG9yIGJ5IEpvaGFubmVzIEJhYWfDuGUuXG4vLyBQZXJpb2Q6IH4yXjExNlxuLy8gUmVwb3J0ZWQgdG8gcGFzcyBhbGwgQmlnQ3J1c2ggdGVzdHMuXG52YXIgYWxlYSA9IHJlcXVpcmUoJy4vbGliL2FsZWEnKTtcblxuLy8geG9yMTI4LCBhIHB1cmUgeG9yLXNoaWZ0IGdlbmVyYXRvciBieSBHZW9yZ2UgTWFyc2FnbGlhLlxuLy8gUGVyaW9kOiAyXjEyOC0xLlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogTWF0cml4UmFuayBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3IxMjggPSByZXF1aXJlKCcuL2xpYi94b3IxMjgnKTtcblxuLy8geG9yd293LCBHZW9yZ2UgTWFyc2FnbGlhJ3MgMTYwLWJpdCB4b3Itc2hpZnQgY29tYmluZWQgcGx1cyB3ZXlsLlxuLy8gUGVyaW9kOiAyXjE5Mi0yXjMyXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBDb2xsaXNpb25PdmVyLCBTaW1wUG9rZXIsIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcndvdyA9IHJlcXVpcmUoJy4vbGliL3hvcndvdycpO1xuXG4vLyB4b3JzaGlmdDcsIGJ5IEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyLCB0YWtlc1xuLy8gYSBkaWZmZXJlbnQgYXBwcm9hY2g6IGl0IGFkZHMgcm9idXN0bmVzcyBieSBhbGxvd2luZyBtb3JlIHNoaWZ0c1xuLy8gdGhhbiBNYXJzYWdsaWEncyBvcmlnaW5hbCB0aHJlZS4gIEl0IGlzIGEgNy1zaGlmdCBnZW5lcmF0b3Jcbi8vIHdpdGggMjU2IGJpdHMsIHRoYXQgcGFzc2VzIEJpZ0NydXNoIHdpdGggbm8gc3lzdG1hdGljIGZhaWx1cmVzLlxuLy8gUGVyaW9kIDJeMjU2LTEuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcnNoaWZ0NyA9IHJlcXVpcmUoJy4vbGliL3hvcnNoaWZ0NycpO1xuXG4vLyB4b3I0MDk2LCBieSBSaWNoYXJkIEJyZW50LCBpcyBhIDQwOTYtYml0IHhvci1zaGlmdCB3aXRoIGFcbi8vIHZlcnkgbG9uZyBwZXJpb2QgdGhhdCBhbHNvIGFkZHMgYSBXZXlsIGdlbmVyYXRvci4gSXQgYWxzbyBwYXNzZXNcbi8vIEJpZ0NydXNoIHdpdGggbm8gc3lzdGVtYXRpYyBmYWlsdXJlcy4gIEl0cyBsb25nIHBlcmlvZCBtYXlcbi8vIGJlIHVzZWZ1bCBpZiB5b3UgaGF2ZSBtYW55IGdlbmVyYXRvcnMgYW5kIG5lZWQgdG8gYXZvaWRcbi8vIGNvbGxpc2lvbnMuXG4vLyBQZXJpb2Q6IDJeNDEyOC0yXjMyLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3I0MDk2ID0gcmVxdWlyZSgnLi9saWIveG9yNDA5NicpO1xuXG4vLyBUeWNoZS1pLCBieSBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8sIGlzIGEgYml0LXNoaWZ0aW5nIHJhbmRvbVxuLy8gbnVtYmVyIGdlbmVyYXRvciBkZXJpdmVkIGZyb20gQ2hhQ2hhLCBhIG1vZGVybiBzdHJlYW0gY2lwaGVyLlxuLy8gaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcbi8vIFBlcmlvZDogfjJeMTI3XG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHR5Y2hlaSA9IHJlcXVpcmUoJy4vbGliL3R5Y2hlaScpO1xuXG4vLyBUaGUgb3JpZ2luYWwgQVJDNC1iYXNlZCBwcm5nIGluY2x1ZGVkIGluIHRoaXMgbGlicmFyeS5cbi8vIFBlcmlvZDogfjJeMTYwMFxudmFyIHNyID0gcmVxdWlyZSgnLi9zZWVkcmFuZG9tJyk7XG5cbnNyLmFsZWEgPSBhbGVhO1xuc3IueG9yMTI4ID0geG9yMTI4O1xuc3IueG9yd293ID0geG9yd293O1xuc3IueG9yc2hpZnQ3ID0geG9yc2hpZnQ3O1xuc3IueG9yNDA5NiA9IHhvcjQwOTY7XG5zci50eWNoZWkgPSB0eWNoZWk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3I7XG4iLCIvLyBBIHBvcnQgb2YgYW4gYWxnb3JpdGhtIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuLy8gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25xdWlubGFuL2JldHRlci1yYW5kb20tbnVtYmVycy1mb3ItamF2YXNjcmlwdC1taXJyb3Jcbi8vIE9yaWdpbmFsIHdvcmsgaXMgdW5kZXIgTUlUIGxpY2Vuc2UgLVxuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxOSBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBwb29sLCBtYXRoKSB7XG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cblxudmFyIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcbiAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5mdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgb3B0aW9ucyA9IChvcHRpb25zID09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICBvcHRpb25zLmVudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcbiAgICAoc2VlZCA9PSBudWxsKSA/IGF1dG9zZWVkKCkgOiBzZWVkLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cbiAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLCAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH1cbiAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH1cbiAgcHJuZy5kb3VibGUgPSBwcm5nO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcblxuICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cbiAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykgeyBjb3B5KHN0YXRlLCBhcmM0KTsgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKFxuICBwcm5nLFxuICBzaG9ydHNlZWQsXG4gICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxuICBvcHRpb25zLnN0YXRlKTtcbn1cblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufSBlbHNlIHtcbiAgLy8gV2hlbiBpbmNsdWRlZCBhcyBhIHBsYWluIHNjcmlwdCwgc2V0IHVwIE1hdGguc2VlZHJhbmRvbSBnbG9iYWwuXG4gIG1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xufVxuXG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufSkoXG4gIC8vIGdsb2JhbDogYHNlbGZgIGluIGJyb3dzZXJzIChpbmNsdWRpbmcgc3RyaWN0IG1vZGUgYW5kIHdlYiB3b3JrZXJzKSxcbiAgLy8gb3RoZXJ3aXNlIGB0aGlzYCBpbiBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHNcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogdGhpcyxcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuXG5TZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZSBhbiBpbnRlcm5hbCBVSUQgdG8gbWFrZSB0aGUgcmVnZXhwIHBhdHRlcm4gaGFyZGVyIHRvIGd1ZXNzLlxudmFyIFVJRCAgICAgICAgICAgICAgICAgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDAwKS50b1N0cmluZygxNik7XG52YXIgUExBQ0VfSE9MREVSX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ1wiQF9fKEZ8UnxEfE18UyktJyArIFVJRCArICctKFxcXFxkKylfX0BcIicsICdnJyk7XG5cbnZhciBJU19OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXFx7XFxzKlxcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfS9nO1xudmFyIElTX1BVUkVfRlVOQ1RJT04gPSAvZnVuY3Rpb24uKj9cXCgvO1xudmFyIElTX0FSUk9XX0ZVTkNUSU9OID0gLy4qPz0+Lio/LztcbnZhciBVTlNBRkVfQ0hBUlNfUkVHRVhQICAgPSAvWzw+XFwvXFx1MjAyOFxcdTIwMjldL2c7XG5cbnZhciBSRVNFUlZFRF9TWU1CT0xTID0gWycqJywgJ2FzeW5jJ107XG5cbi8vIE1hcHBpbmcgb2YgdW5zYWZlIEhUTUwgYW5kIGludmFsaWQgSmF2YVNjcmlwdCBsaW5lIHRlcm1pbmF0b3IgY2hhcnMgdG8gdGhlaXJcbi8vIFVuaWNvZGUgY2hhciBjb3VudGVycGFydHMgd2hpY2ggYXJlIHNhZmUgdG8gdXNlIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbnZhciBFU0NBUEVEX0NIQVJTID0ge1xuICAgICc8JyAgICAgOiAnXFxcXHUwMDNDJyxcbiAgICAnPicgICAgIDogJ1xcXFx1MDAzRScsXG4gICAgJy8nICAgICA6ICdcXFxcdTAwMkYnLFxuICAgICdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAnXFxcXHUyMDI5J1xufTtcblxuZnVuY3Rpb24gZXNjYXBlVW5zYWZlQ2hhcnModW5zYWZlQ2hhcikge1xuICAgIHJldHVybiBFU0NBUEVEX0NIQVJTW3Vuc2FmZUNoYXJdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShvYmosIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIGBzcGFjZWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0ge3NwYWNlOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICB2YXIgZnVuY3Rpb25zID0gW107XG4gICAgdmFyIHJlZ2V4cHMgICA9IFtdO1xuICAgIHZhciBkYXRlcyAgICAgPSBbXTtcbiAgICB2YXIgbWFwcyAgICAgID0gW107XG4gICAgdmFyIHNldHMgICAgICA9IFtdO1xuXG4gICAgLy8gUmV0dXJucyBwbGFjZWhvbGRlcnMgZm9yIGZ1bmN0aW9ucyBhbmQgcmVnZXhwcyAoaWRlbnRpZmllZCBieSBpbmRleClcbiAgICAvLyB3aGljaCBhcmUgbGF0ZXIgcmVwbGFjZWQgYnkgdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCB3LyBhIHRvSlNPTiBtZXRob2QsIHRvSlNPTiBpcyBjYWxsZWQgYmVmb3JlXG4gICAgICAgIC8vIHRoZSByZXBsYWNlciBydW5zLCBzbyB3ZSB1c2UgdGhpc1trZXldIHRvIGdldCB0aGUgbm9uLXRvSlNPTmVkIHZhbHVlLlxuICAgICAgICB2YXIgb3JpZ1ZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcmlnVmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZihvcmlnVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0BfX1ItJyArIFVJRCArICctJyArIChyZWdleHBzLnB1c2gob3JpZ1ZhbHVlKSAtIDEpICsgJ19fQCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9yaWdWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0BfX0QtJyArIFVJRCArICctJyArIChkYXRlcy5wdXNoKG9yaWdWYWx1ZSkgLSAxKSArICdfX0AnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihvcmlnVmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0BfX00tJyArIFVJRCArICctJyArIChtYXBzLnB1c2gob3JpZ1ZhbHVlKSAtIDEpICsgJ19fQCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9yaWdWYWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQF9fUy0nICsgVUlEICsgJy0nICsgKHNldHMucHVzaChvcmlnVmFsdWUpIC0gMSkgKyAnX19AJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BfX0YtJyArIFVJRCArICctJyArIChmdW5jdGlvbnMucHVzaChvcmlnVmFsdWUpIC0gMSkgKyAnX19AJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVGdW5jKGZuKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZEZuID0gZm4udG9TdHJpbmcoKTtcbiAgICAgIGlmIChJU19OQVRJVkVfQ09ERV9SRUdFWFAudGVzdChzZXJpYWxpemVkRm4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VyaWFsaXppbmcgbmF0aXZlIGZ1bmN0aW9uOiAnICsgZm4ubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1cmUgZnVuY3Rpb25zLCBleGFtcGxlOiB7a2V5OiBmdW5jdGlvbigpIHt9fVxuICAgICAgaWYoSVNfUFVSRV9GVU5DVElPTi50ZXN0KHNlcmlhbGl6ZWRGbikpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZEZuO1xuICAgICAgfVxuXG4gICAgICAvLyBhcnJvdyBmdW5jdGlvbnMsIGV4YW1wbGU6IGFyZzEgPT4gYXJnMSs1XG4gICAgICBpZihJU19BUlJPV19GVU5DVElPTi50ZXN0KHNlcmlhbGl6ZWRGbikpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZEZuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnc1N0YXJ0c0F0ID0gc2VyaWFsaXplZEZuLmluZGV4T2YoJygnKTtcbiAgICAgIHZhciBkZWYgPSBzZXJpYWxpemVkRm4uc3Vic3RyKDAsIGFyZ3NTdGFydHNBdClcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsLmxlbmd0aCA+IDAgfSk7XG5cbiAgICAgIHZhciBub25SZXNlcnZlZFN5bWJvbHMgPSBkZWYuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gUkVTRVJWRURfU1lNQk9MUy5pbmRleE9mKHZhbCkgPT09IC0xXG4gICAgICB9KTtcblxuICAgICAgLy8gZW5oYW5jZWQgbGl0ZXJhbCBvYmplY3RzLCBleGFtcGxlOiB7a2V5KCkge319XG4gICAgICBpZihub25SZXNlcnZlZFN5bWJvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiAoZGVmLmluZGV4T2YoJ2FzeW5jJykgPiAtMSA/ICdhc3luYyAnIDogJycpICsgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKyAoZGVmLmpvaW4oJycpLmluZGV4T2YoJyonKSA+IC0xID8gJyonIDogJycpXG4gICAgICAgICAgICArIHNlcmlhbGl6ZWRGbi5zdWJzdHIoYXJnc1N0YXJ0c0F0KTtcbiAgICAgIH1cblxuICAgICAgLy8gYXJyb3cgZnVuY3Rpb25zXG4gICAgICByZXR1cm4gc2VyaWFsaXplZEZuO1xuICAgIH1cblxuICAgIHZhciBzdHI7XG5cbiAgICAvLyBDcmVhdGVzIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLlxuICAgIC8vIE5PVEU6IE5vZGUgMC4xMiBnb2VzIGludG8gc2xvdyBtb2RlIHdpdGggZXh0cmEgSlNPTi5zdHJpbmdpZnkoKSBhcmdzLlxuICAgIGlmIChvcHRpb25zLmlzSlNPTiAmJiAhb3B0aW9ucy5zcGFjZSkge1xuICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgb3B0aW9ucy5pc0pTT04gPyBudWxsIDogcmVwbGFjZXIsIG9wdGlvbnMuc3BhY2UpO1xuICAgIH1cblxuICAgIC8vIFByb3RlY3RzIGFnYWluc3QgYEpTT04uc3RyaW5naWZ5KClgIHJldHVybmluZyBgdW5kZWZpbmVkYCwgYnkgc2VyaWFsaXppbmdcbiAgICAvLyB0byB0aGUgbGl0ZXJhbCBzdHJpbmc6IFwidW5kZWZpbmVkXCIuXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc3RyKTtcbiAgICB9XG5cbiAgICAvLyBSZXBsYWNlIHVuc2FmZSBIVE1MIGFuZCBpbnZhbGlkIEphdmFTY3JpcHQgbGluZSB0ZXJtaW5hdG9yIGNoYXJzIHdpdGhcbiAgICAvLyB0aGVpciBzYWZlIFVuaWNvZGUgY2hhciBjb3VudGVycGFydC4gVGhpcyBfbXVzdF8gaGFwcGVuIGJlZm9yZSB0aGVcbiAgICAvLyByZWdleHBzIGFuZCBmdW5jdGlvbnMgYXJlIHNlcmlhbGl6ZWQgYW5kIGFkZGVkIGJhY2sgdG8gdGhlIHN0cmluZy5cbiAgICBpZiAob3B0aW9ucy51bnNhZmUgIT09IHRydWUpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoVU5TQUZFX0NIQVJTX1JFR0VYUCwgZXNjYXBlVW5zYWZlQ2hhcnMpO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvbnMubGVuZ3RoID09PSAwICYmIHJlZ2V4cHMubGVuZ3RoID09PSAwICYmIGRhdGVzLmxlbmd0aCA9PT0gMCAmJiBtYXBzLmxlbmd0aCA9PT0gMCAmJiBzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiBmdW5jdGlvbiwgcmVnZXhwLCBkYXRlLCBtYXAgYW5kIHNldCBwbGFjZWhvbGRlcnMgaW4gdGhlXG4gICAgLy8gSlNPTiBzdHJpbmcgd2l0aCB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25zLiBJZiB0aGUgb3JpZ2luYWwgdmFsdWUgY2FuXG4gICAgLy8gbm90IGJlIGZvdW5kLCB0aGVuIGB1bmRlZmluZWRgIGlzIHVzZWQuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFBMQUNFX0hPTERFUl9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCwgdHlwZSwgdmFsdWVJbmRleCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0QnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJuZXcgRGF0ZShcXFwiXCIgKyBkYXRlc1t2YWx1ZUluZGV4XS50b0lTT1N0cmluZygpICsgXCJcXFwiKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdSJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cHNbdmFsdWVJbmRleF0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm5ldyBNYXAoXCIgKyBzZXJpYWxpemUoQXJyYXkuZnJvbShtYXBzW3ZhbHVlSW5kZXhdLmVudHJpZXMoKSksIG9wdGlvbnMpICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJuZXcgU2V0KFwiICsgc2VyaWFsaXplKEFycmF5LmZyb20oc2V0c1t2YWx1ZUluZGV4XS52YWx1ZXMoKSksIG9wdGlvbnMpICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbnNbdmFsdWVJbmRleF07XG5cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUZ1bmMoZm4pO1xuICAgIH0pO1xufVxuIiwiLypcbiAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC4xMC4wLlxuICpcbiAqIGh0dHA6Ly9wZWdqcy5vcmcvXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG59XG5cbmZ1bmN0aW9uIHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuXG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHBlZyRTeW50YXhFcnJvcik7XG4gIH1cbn1cblxucGVnJHN1YmNsYXNzKHBlZyRTeW50YXhFcnJvciwgRXJyb3IpO1xuXG5wZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kKSB7XG4gIHZhciBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlMgPSB7XG4gICAgICAgIGxpdGVyYWw6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArIFwiXFxcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiY2xhc3NcIjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICB2YXIgZXNjYXBlZFBhcnRzID0gXCJcIixcbiAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RhdGlvbi5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXNjYXBlZFBhcnRzICs9IGV4cGVjdGF0aW9uLnBhcnRzW2ldIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgPyBjbGFzc0VzY2FwZShleHBlY3RhdGlvbi5wYXJ0c1tpXVswXSkgKyBcIi1cIiArIGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzFdKVxuICAgICAgICAgICAgICA6IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzICsgXCJdXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW55OiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3RoZXI6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIGhleChjaCkge1xuICAgIHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGl0ZXJhbEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAucmVwbGFjZSgvXCIvZywgICdcXFxcXCInKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc0VzY2FwZShzKSB7XG4gICAgcmV0dXJuIHNcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAucmVwbGFjZSgvXFxdL2csICdcXFxcXScpXG4gICAgICAucmVwbGFjZSgvXFxeL2csICdcXFxcXicpXG4gICAgICAucmVwbGFjZSgvLS9nLCAgJ1xcXFwtJylcbiAgICAgIC5yZXBsYWNlKC9cXDAvZywgJ1xcXFwwJylcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JylcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlNbZXhwZWN0YXRpb24udHlwZV0oZXhwZWN0YXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkge1xuICAgIHZhciBkZXNjcmlwdGlvbnMgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgaSwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRpb25zW2ldID0gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RlZFtpXSk7XG4gICAgfVxuXG4gICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcblxuICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgKyBcIiwgb3IgXCJcbiAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZCkge1xuICAgIHJldHVybiBmb3VuZCA/IFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbn07XG5cbmZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHBhdHRlcm46IHBlZyRwYXJzZXBhdHRlcm4gfSxcbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSBwZWckcGFyc2VwYXR0ZXJuLFxuXG4gICAgICBwZWckYzAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gdmFsdWVcbiAgICAgICAgaWYoIG9wdGlvbnMuZW5jbG9zZSA9PT0gdHJ1ZSAmJiB2YWx1ZS50eXBlICE9PSAnZ3JvdXAnICkge1xuICAgICAgICAgIG91dCA9IHsgdHlwZTonZ3JvdXAnLCB2YWx1ZXM6WyB2YWx1ZSBdIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG91dFxuICAgICAgfSxcbiAgICAgIHBlZyRjMSA9IGZ1bmN0aW9uKF92YWx1ZXNzdGFydCwgX3ZhbHVlc2VuZCkge1xuICAgICAgICBfdmFsdWVzZW5kLnVuc2hpZnQoIF92YWx1ZXNzdGFydCApXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IF92YWx1ZXNlbmRcblxuICAgICAgICBsZXQgb3V0XG4gICAgICAgIFxuICAgICAgICBpZiggdmFsdWVzLnR5cGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAvLyBnZXR0aW5nIG5lc3RlZCBhcnJheXMgd2l0aCBmZWV0Li4uXG4gICAgICAgICAgb3V0ID0ge1xuICAgICAgICAgICAgdmFsdWVzOkFycmF5LmlzQXJyYXkoIHZhbHVlc1swXSApID8gdmFsdWVzWzBdIDogdmFsdWVzLFxuICAgICAgICAgICAgdHlwZTonZ3JvdXAnIFxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgb3V0ID0gdmFsdWVzXG4gICAgICAgICAgb3V0LnR5cGUgPSAnZ3JvdXAnXG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgYWRkTG9jKCBvdXQsIGxvY2F0aW9uKCkgKVxuXG4gICAgICAgIHJldHVybiBvdXRcbiAgICAgIH0sXG4gICAgICBwZWckYzIgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImdyb3VwXCIpLFxuICAgICAgcGVnJGMzID0gXCJbXCIsXG4gICAgICBwZWckYzQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiW1wiLCBmYWxzZSksXG4gICAgICBwZWckYzUgPSBcIl1cIixcbiAgICAgIHBlZyRjNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJdXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICBjb25zdCBvdXQgPSB7XG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHR5cGU6J2dyb3VwJyBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGFkZExvYyggb3V0LCBsb2NhdGlvbigpICkgXG4gICAgICB9LFxuICAgICAgcGVnJGM4ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0ZXJtXCIpLFxuICAgICAgcGVnJGM5ID0gZnVuY3Rpb24oYm9keSkge3JldHVybiBib2R5fSxcbiAgICAgIHBlZyRjMTAgPSBcIihcIixcbiAgICAgIHBlZyRjMTEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSksXG4gICAgICBwZWckYzEyID0gXCIsXCIsXG4gICAgICBwZWckYzEzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIixcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxNCA9IFwiKVwiLFxuICAgICAgcGVnJGMxNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIpXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTYgPSBmdW5jdGlvbih2YWx1ZSwgcHVsc2VzLCBzbG90cywgcm90YXRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHR5cGU6J2Jqb3JrbHVuZCcsXG4gICAgICAgICAgcHVsc2VzLCBcbiAgICAgICAgICBzbG90cywgXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgJ3JvdGF0aW9uJzogcm90YXRpb24ubGVuZ3RoID4gMCA/IHJvdGF0aW9uWyAwIF0gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgY29uc3Qgd2l0aExvYyA9IGFkZExvYyggcmVzdWx0LCBsb2NhdGlvbigpICkgXG4gICAgICAgIC8vd2l0aExvYy52YWx1ZS51aWQgPSB3aXRoTG9jLnVpZFxuICAgICAgICByZXR1cm4gd2l0aExvY1xuICAgICAgfSxcbiAgICAgIHBlZyRjMTcgPSBmdW5jdGlvbihib2R5KSB7IHJldHVybiBib2R5IH0sXG4gICAgICBwZWckYzE4ID0gXCI/XCIsXG4gICAgICBwZWckYzE5ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj9cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMyMCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHsgdHlwZTonZGVncmFkZScsIHZhbHVlIH1cbiAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICAvL3JldHVybiBhZGRMb2MoIG91dCwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGMyMSA9IFwiKlwiLFxuICAgICAgcGVnJGMyMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjMgPSBmdW5jdGlvbih2YWx1ZSwgcmF0ZSkge1xuICAgICAgICBjb25zdCByID0gIHsgdHlwZTonc3BlZWQnLCByYXRlLCB2YWx1ZSB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuYWRkTG9jYXRpb25zID09PSB0cnVlICkge1xuICAgICAgICAgIHIubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydDp2YWx1ZS5sb2NhdGlvbi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcmF0ZS5sb2NhdGlvbi5lbmRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByIFxuICAgICAgfSxcbiAgICAgIHBlZyRjMjQgPSBcIi9cIixcbiAgICAgIHBlZyRjMjUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSksXG4gICAgICBwZWckYzI2ID0gZnVuY3Rpb24odmFsdWUsIHJhdGUpIHtcbiAgICAgICAgLypjb25zdCByID0gIHsgdHlwZTonc2xvdycsIHJhdGUsIHZhbHVlIH0qL1xuXG4gICAgICAgIC8vaWYoIG9wdGlvbnMuYWRkTG9jYXRpb25zID09PSB0cnVlICkge1xuICAgICAgICAvLyAgci5sb2NhdGlvbiA9IHtcbiAgICAgICAgLy8gICAgc3RhcnQ6dmFsdWUubG9jYXRpb24uc3RhcnQsXG4gICAgICAgIC8vICAgIGVuZDogcmF0ZS5sb2NhdGlvbi5lbmRcbiAgICAgICAgLy8gIH1cbiAgICAgICAgLy99XG4gICAgICAgIC8vY29uc3QgZ3JvdXAgPSB2YWx1ZS50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgIC8vICA/IHZhbHVlXG4gICAgICAgIGNvbnN0IGdyb3VwID0geyB0eXBlOidncm91cCcsIHZhbHVlczpbIHZhbHVlIF0gfVxuXG4gICAgICAgIGNvbnN0IG9uZXN0ZXAgPSB7XG4gICAgICAgICAgdHlwZTonb25lc3RlcCcsXG4gICAgICAgICAgdmFsdWVzOlsgZ3JvdXAgXVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCByYXRlLnZhbHVlIC0gMTsgaSsrICkge1xuICAgICAgICAgIGdyb3VwLnZhbHVlcy5wdXNoKHsgdHlwZToncmVzdCcgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZExvYyggb25lc3RlcCwgbG9jYXRpb24oKSApXG4gICAgICAgIHJldHVybiBvbmVzdGVwXG4gICAgICAgIC8qcmV0dXJuIHIgKi9cbiAgICAgIH0sXG4gICAgICBwZWckYzI3ID0gXCJ7XCIsXG4gICAgICBwZWckYzI4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMyOSA9IFwifVwiLFxuICAgICAgcGVnJGMzMCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMzEgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IFxuICAgICAgICAgICdsZWZ0Jzp7XG4gICAgICAgICAgICB0eXBlOidncm91cCcsXG4gICAgICAgICAgICB2YWx1ZXM6bGVmdFxuICAgICAgICAgIH0sIFxuICAgICAgICAgICdyaWdodCc6e1xuICAgICAgICAgICAgdHlwZTonZ3JvdXAnLFxuICAgICAgICAgICAgdmFsdWVzOnJpZ2h0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogJ3BvbHltZXRlcicgXG4gICAgICAgIH1cblxuICAgICAgICBhZGRMb2MoIHJlc3VsdC5sZWZ0LCBsb2NhdGlvbigpIClcbiAgICAgICAgYWRkTG9jKCByZXN1bHQucmlnaHQsIGxvY2F0aW9uKCkgKVxuICAgICAgICBhZGRMb2MoIHJlc3VsdCwgbG9jYXRpb24oKSApXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSxcbiAgICAgIHBlZyRjMzIgPSBcIn5cIixcbiAgICAgIHBlZyRjMzMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiflwiLCBmYWxzZSksXG4gICAgICBwZWckYzM0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgcmV0dXJuIHsgdHlwZToncmVzdCcgfVxuICAgICAgfSxcbiAgICAgIHBlZyRjMzUgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgICB0eXBlOidncm91cCcsXG4gICAgICAgICAgdmFsdWVzOiBzdGFydC5tYXAoIGdycCA9PiBncnBbMF0gKVxuICAgICAgICB9XG4gICAgICAgIG91dC52YWx1ZXMucHVzaCggZW5kIClcblxuICAgICAgICByZXR1cm4gYWRkTG9jKCBvdXQsIGxvY2F0aW9uKCkgKVxuICAgICAgfSxcbiAgICAgIHBlZyRjMzYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH0sXG4gICAgICBwZWckYzM3ID0gZnVuY3Rpb24oYm9keSwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGJvZHkubWFwKCB2YWwgPT4gdmFsWzBdIClcblxuICAgICAgICB2YWx1ZXMucHVzaCggZW5kIClcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdHlwZTogJ2xheWVycycsXG4gICAgICAgICAgdmFsdWVzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkTG9jKCByZXN1bHQsIGxvY2F0aW9uKCkgKVxuICAgICAgfSxcbiAgICAgIHBlZyRjMzggPSBcIjxcIixcbiAgICAgIHBlZyRjMzkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiPFwiLCBmYWxzZSksXG4gICAgICBwZWckYzQwID0gXCI+XCIsXG4gICAgICBwZWckYzQxID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj5cIiwgZmFsc2UpLFxuICAgICAgcGVnJGM0MiA9IGZ1bmN0aW9uKGJvZHksIGVuZCkge1xuICAgICAgICBjb25zdCBvbmVzdGVwID0ge1xuICAgICAgICAgIHR5cGU6J29uZXN0ZXAnLFxuICAgICAgICAgIHZhbHVlczpbYm9keV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBlbmQgIT09IG51bGwgKSB7XG4gICAgICAgICAgb25lc3RlcC52YWx1ZXMucHVzaCggZW5kIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRMb2MoIG9uZXN0ZXAsIGxvY2F0aW9uKCkgKVxuICAgICAgfSxcbiAgICAgIHBlZyRjNDMgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIndvcmRcIiksXG4gICAgICBwZWckYzQ0ID0gL15bbGV0dGVyIG51bWJlcl0vLFxuICAgICAgcGVnJGM0NSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcImxcIiwgXCJlXCIsIFwidFwiLCBcInRcIiwgXCJlXCIsIFwiclwiLCBcIiBcIiwgXCJuXCIsIFwidVwiLCBcIm1cIiwgXCJiXCIsIFwiZVwiLCBcInJcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzQ2ID0gZnVuY3Rpb24odmFsdWUpIHsgXG4gICAgICAgIHJldHVybiBhZGRMb2MoIHsgdHlwZTp0eXBlb2YgdmFsdWUsIHZhbHVlLCB9LCBsb2NhdGlvbigpIClcbiAgICAgIH0sXG4gICAgICBwZWckYzQ3ID0gZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jKCB7IHR5cGU6J3N0cmluZycsIHZhbHVlOnRleHQoKS50cmltKCkgfSwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGM0OCA9IC9eW14gW1xcXSB7fSAoKSBcXHRcXG5cXHIgJyonICdcXC8nICcuJyAnficgJz8nICcsJyAnPicgJzwnIF0vLFxuICAgICAgcGVnJGM0OSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIiBcIiwgXCJbXCIsIFwiXVwiLCBcIiBcIiwgXCJ7XCIsIFwifVwiLCBcIiBcIiwgXCIoXCIsIFwiKVwiLCBcIiBcIiwgXCJcXHRcIiwgXCJcXG5cIiwgXCJcXHJcIiwgXCIgXCIsIFwiJ1wiLCBcIipcIiwgXCInXCIsIFwiIFwiLCBcIidcIiwgXCIvXCIsIFwiJ1wiLCBcIiBcIiwgXCInXCIsIFwiLlwiLCBcIidcIiwgXCIgXCIsIFwiJ1wiLCBcIn5cIiwgXCInXCIsIFwiIFwiLCBcIidcIiwgXCI/XCIsIFwiJ1wiLCBcIiBcIiwgXCInXCIsIFwiLFwiLCBcIidcIiwgXCIgXCIsIFwiJ1wiLCBcIj5cIiwgXCInXCIsIFwiIFwiLCBcIidcIiwgXCI8XCIsIFwiJ1wiLCBcIiBcIl0sIHRydWUsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkTG9jKCB7dHlwZTonc3RyaW5nJywgdmFsdWUgfSwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGM1MSA9IFwiLlwiLFxuICAgICAgcGVnJGM1MiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIuXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTMgPSBcIi1cIixcbiAgICAgIHBlZyRjNTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLVwiLCBmYWxzZSksXG4gICAgICBwZWckYzU1ID0gL15bMC05XS8sXG4gICAgICBwZWckYzU2ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFkZExvYyggeyB0eXBlOidudW1iZXInLCB2YWx1ZTordGV4dCgpLnRyaW0oKSB9LCBsb2NhdGlvbigpIClcbiAgICAgIH0sXG4gICAgICBwZWckYzU4ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ3aGl0ZXNwYWNlXCIpLFxuICAgICAgcGVnJGM1OSA9IC9eWyBcXHRcXG5cXHIgXS8sXG4gICAgICBwZWckYzYwID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcclwiLCBcIiBcIl0sIGZhbHNlLCBmYWxzZSksXG5cbiAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgIHBlZyRzYXZlZFBvcyAgICAgICAgID0gMCxcbiAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGUgID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dLFxuICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgcGVnJHJlc3VsdHNDYWNoZSA9IHt9LFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLFxuICAgICAgaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYW55RXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSwgcDtcblxuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgcC0tO1xuICAgICAgfVxuXG4gICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIGxpbmU6ICAgZGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHArKztcbiAgICAgIH1cblxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpLFxuICAgICAgICBlbmRQb3NEZXRhaWxzICAgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLFxuICAgICAgICBsaW5lOiAgIHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICAgIGxpbmU6ICAgZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXBhdHRlcm4oKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMCxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWZlZXQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlbGlzdCgpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzAoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbGlzdCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMSxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMShzMiwgczQpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWdyb3VwKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDIsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICAgIHMyID0gcGVnJGMzO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBbXTtcbiAgICAgICAgICBzNSA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckYzU7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM3KHM0KTtcbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGVybSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMyxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWV1Y2xpZCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VzcGVlZCgpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlc2xvdygpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWRlZ3JhZGUoKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGF5ZXIoKTtcbiAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcG9seW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vncm91cCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VvbmVzdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM5KHMxKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VldWNsaWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTAsIHMxMSwgczEyLCBzMTMsIHMxNCwgczE1O1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyA0LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2Vub3RldWNsaWQoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgczMgPSBwZWckYzEwO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRjMTI7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEzKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRjMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE1KTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxNCA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoczE0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMucHVzaChzMTQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczE0ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczE0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTUgPSBwZWckYzE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczE1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTUpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxNSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxNihzMiwgczUsIHM4LCBzMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vub3RldWNsaWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDUsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2Vncm91cCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VudW1iZXIoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZXdvcmQoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXJzKCk7XG4gICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcmVzdCgpO1xuICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW9uZXN0ZXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTcoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWRlZ3JhZGUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDYsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2Vub3RkZWdyYWRlKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYzKSB7XG4gICAgICAgIHMyID0gcGVnJGMxODtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE5KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMjAoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdGRlZ3JhZGUoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyA3LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VzcGVlZCgpO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlc2xvdygpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZWV1Y2xpZCgpO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckcGFyc2Vncm91cCgpO1xuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlb25lc3RlcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3BlZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyA4LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlbm90c3BlZWQoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDIpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMjE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2Vub3RzcGVlZCgpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjMoczEsIHM1KTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbm90c3BlZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDksXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VldWNsaWQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlcG9seW1ldGVyKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2VudW1iZXIoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VsYXllcigpO1xuICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXJzKCk7XG4gICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vncm91cCgpO1xuICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VvbmVzdGVwKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNyhzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc2xvdygpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDEwLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlbm90c2xvdygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgIHMzID0gcGVnJGMyNDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW5vdHNsb3coKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzI2KHMxLCBzNSk7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdHNsb3coKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDExLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZXBvbHltZXRlcigpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGF5ZXIoKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVycygpO1xuICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlZ3JvdXAoKTtcbiAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcmVzdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlb25lc3RlcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTcoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXBvbHltZXRlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMDtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTIsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICBzMiA9IHBlZyRjMjc7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBbXTtcbiAgICAgICAgICBzNSA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJGMxMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IFtdO1xuICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHM3LnB1c2goczgpO1xuICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckYzI5O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMzEoczQsIHM3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcmVzdCgpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxMyxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNikge1xuICAgICAgczEgPSBwZWckYzMyO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMzKTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzM0KCk7XG4gICAgfVxuICAgIHMwID0gczE7XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmZWV0KCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxNCxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlZm9vdCgpO1xuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWZvb3QoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlbm90Zm9vdCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMzUoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vmb290KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTUsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IHBlZyRwYXJzZW5vdGZvb3QoKTtcbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBwZWckcGFyc2Vub3Rmb290KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZWRvdCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMzYoczEpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vub3Rmb290KCkge1xuICAgIHZhciBzMDtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTYsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJHBhcnNlbGlzdCgpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VkZWdyYWRlKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2Vwb2x5bWV0ZXIoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZXNwZWVkKCk7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VzbG93KCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbGV0dGVycygpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2V3b3JkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VvbmVzdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbGF5ZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5O1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxNyxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgICAgczIgPSBwZWckYzM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczYgPSBwZWckcGFyc2Vub3RsYXllcigpO1xuICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgIHM4ID0gcGVnJGMxMjtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM4ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNiA9IFtzNiwgczcsIHM4LCBzOV07XG4gICAgICAgICAgICAgICAgICBzNSA9IHM2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgczUgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2Vub3RsYXllcigpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICAgICAgczggPSBwZWckYzEyO1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHM2ID0gW3M2LCBzNywgczgsIHM5XTtcbiAgICAgICAgICAgICAgICAgICAgICBzNSA9IHM2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW5vdGxheWVyKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJGM1O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzNyhzNCwgczUpO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdGxheWVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxOCxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXNwZWVkKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZXNsb3coKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZWxpc3QoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VudW1iZXIoKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVycygpO1xuICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcG9seW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW9uZXN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE3KHMxKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VvbmVzdGVwKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDE5LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjApIHtcbiAgICAgIHMxID0gcGVnJGMzODtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOSk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZW5vdG9uZXN0ZXAoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgczQgPSBwZWckYzEyO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEzKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW5vdG9uZXN0ZXAoKTtcbiAgICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjIpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJGM0MDtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0MSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM0MihzMywgczUpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vub3RvbmVzdGVwKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAyMCxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWxpc3QoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2Vwb2x5bWV0ZXIoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2V3b3JkKCk7XG4gICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VudW1iZXIoKTtcbiAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcmVzdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE3KHMxKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V3b3JkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDIxLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBpZiAocGVnJGM0NC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ1KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIGlmIChwZWckYzQ0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0NSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBzMztcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzQ2KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQzKTsgfVxuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWxldHRlcnMoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAyMixcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzQ3KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbGV0dGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAyMyxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChwZWckYzQ4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OSk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IGlucHV0LnN1YnN0cmluZyhzMSwgcGVnJGN1cnJQb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHMyO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzUwKHMxKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWRvdCgpIHtcbiAgICB2YXIgczA7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDI0LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICBzMCA9IHBlZyRjNTE7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTIpOyB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcXVlc3Rpb24oKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAyNSxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mykge1xuICAgICAgczAgPSBwZWckYzE4O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE5KTsgfVxuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW51bWJlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDI2LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgIHMxID0gcGVnJGM1MztcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1NCk7IH1cbiAgICB9XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBpZiAocGVnJGM1NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICAgICAgczQgPSBwZWckYzUxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNSA9IFtdO1xuICAgICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBbczMsIHM0LCBzNV07XG4gICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjNTE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IFtzMywgczRdO1xuICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzU3KCk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlXygpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAyNyxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBbXTtcbiAgICBpZiAocGVnJGM1OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBpZiAocGVnJGM1OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYwKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuXG4gICAgY29uc3QgYWRkTG9jYXRpb25zID0gb3B0aW9ucy5hZGRMb2NhdGlvbnNcbiAgIFxuICAgIGxldCB1aWQgPSAwXG4gICAgY29uc3QgYWRkTG9jID0gZnVuY3Rpb24oIHZhbHVlLCBsb2NhdGlvbiApIHtcbiAgICAgIGlmKCBhZGRMb2NhdGlvbnMgPT09IHRydWUgKSB7XG4gICAgICAgIHZhbHVlLmxvY2F0aW9uID0gbG9jYXRpb25cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIG9wdGlvbnMuYWRkVUlEID09PSB0cnVlICkge1xuICAgICAgICB2YWx1ZS51aWQgPSB1aWQrK1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBwZWckcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBwZWckZmFpbChwZWckZW5kRXhwZWN0YXRpb24oKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBlZyRtYXhGYWlsUG9zKSA6IG51bGwsXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aFxuICAgICAgICA/IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zICsgMSlcbiAgICAgICAgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcylcbiAgICApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTeW50YXhFcnJvcjogcGVnJFN5bnRheEVycm9yLFxuICBwYXJzZTogICAgICAgcGVnJHBhcnNlXG59O1xuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuLi9kaXN0L3RpZGFsLmpzJykucGFyc2VcbmNvbnN0IHF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeUFyYy5qcycgKS5xdWVyeUFyY1xuY29uc3QgRnJhY3Rpb24gPSByZXF1aXJlKCAnZnJhY3Rpb24uanMnIClcblxuLyogVGhlIFBhdHRlcm4gb2JqZWN0IGlzIHVzZWQgdG8gcGFyc2UgYSBwYXR0ZXJuXG4gKiBhIHNpbmdsZSB0aW1lIGFuZCB0aGVuIHF1ZXJ5IGl0IHJlcGVhdGVkbHksIGFzc3VtaW5nXG4gKiBkaWZmZXJlbnQgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgZWFjaCBxdWVyeS4gQSBwcmlvcml0eVxuICogcXVldWUgaXMgdXNlZCB0byBzb3J0IHRoZSBldmVudHMuLi4gXG4qL1xuY29uc3QgUGF0dGVybiA9ICggcGF0dGVyblN0cmluZywgb3B0cyApID0+IHtcbiAgaWYoIHR5cGVvZiBwYXR0ZXJuU3RyaW5nICE9PSAnc3RyaW5nJyApXG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYSBzdHJpbmcgdG8gZ2VuZXJhdGUgdGhlIHBhdHRlcm4gZnJvbSdcblxuICBsZXQgX19kYXRhXG4gIHRyeXtcbiAgICBfX2RhdGEgPSBwYXJzZSggcGF0dGVyblN0cmluZywgb3B0cyApXG4gIH1jYXRjaCggZSApIHtcbiAgICB0aHJvdyBgV2Ugd2VyZSB1bmFibGUgdG8gcGFyc2UgdGhlIHBhdHRlcm4gJHtwYXR0ZXJuU3RyaW5nfS4gJHtlLnRvU3RyaW5nKCl9YFxuICB9XG5cbiAgY29uc3QgcHRybiA9IHtcbiAgICBfX3Jhd1N0cmluZzogcGF0dGVyblN0cmluZyxcbiAgICBfX2RhdGEsXG5cbiAgICBldmVudHM6IG51bGwsXG5cbiAgICBfX3NvcnQoIGEsYiApIHsgcmV0dXJuIGEuYXJjLnN0YXJ0LmNvbXBhcmUoIGIuYXJjLnN0YXJ0ICkgfSxcbiAgICBxdWVyeSggc3RhcnQsIGR1cmF0aW9uICkge1xuICAgICAgaWYoIHR5cGVvZiBzdGFydCAhPT0gJ29iamVjdCcgKSBzdGFydCA9IEZyYWN0aW9uKCBzdGFydCApXG4gICAgICBpZiggdHlwZW9mIGR1cmF0aW9uICE9PSAnb2JqZWN0JyApIGR1cmF0aW9uID0gRnJhY3Rpb24oIGR1cmF0aW9uIClcblxuICAgICAgcHRybi5ldmVudHMgPSBxdWVyeSggXG4gICAgICAgIHB0cm4uX19kYXRhLCBcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGR1cmF0aW9uIFxuICAgICAgKVxuICAgICAgLnNvcnQoIHB0cm4uX19zb3J0IClcblxuICAgICAgcmV0dXJuIHB0cm4uZXZlbnRzXG4gICAgfSxcblxuICAgIHByaW50KCkge1xuICAgICAgaWYoIHB0cm4uZXZlbnRzICE9PSBudWxsICkge1xuICAgICAgICBwdHJuLmV2ZW50cy5mb3JFYWNoKCB2ID0+IFxuICAgICAgICAgIGNvbnNvbGUubG9nKCBcbiAgICAgICAgICAgIGAke3YuYXJjLnN0YXJ0LnRvRnJhY3Rpb24oKX0gLSAke3YuYXJjLmVuZC50b0ZyYWN0aW9uKCl9OiBbICR7di52YWx1ZS50b1N0cmluZygpfSBdYCBcbiAgICAgICAgICApIFxuICAgICAgICApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc29sZS5sb2coICdObyBldmVudHMgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXR0ZXJuOyBoYXZlIHlvdSBxdWVyaWVkIGl0IHlldD8nIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHRyblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhdHRlcm5cbiIsImNvbnN0IEZyYWN0aW9uID0gcmVxdWlyZSggJ2ZyYWN0aW9uLmpzJyApXG5jb25zdCB1dGlsICAgICA9IHJlcXVpcmUoICd1dGlsJyApXG5jb25zdCBiam9yayAgICA9IHJlcXVpcmUoICdiam9yaycgKSBcbmNvbnN0IGxvZyAgICAgID0gdXRpbC5pbnNwZWN0XG5jb25zdCBzcmFuZCAgICA9IHJlcXVpcmUoICdzZWVkcmFuZG9tJyApXG5cbmNvbnN0IHJuZCA9IGZ1bmN0aW9uKCBwaGFzZSApIHtcbiAgLy9jb25zb2xlLmxvZyggJ3BoYXNlJywgcGhhc2UudG9GcmFjdGlvbigpIClcbiAgcmV0dXJuIG5ldyBzcmFuZCggcGhhc2UudG9GcmFjdGlvbigpICkoKVxufVxuXG4vKiBxdWVyeUFyY1xuICpcbiAqIEdlbmVyYXRlcyBldmVudHMgZm9yIHByb3ZpZGVkIHBhdHRlcm4sIHN0YXJ0aW5nIGF0XG4gKiBhbiBpbml0aWFsIHBoYXNlLCBzdWJkaXZpZGVzIHF1ZXJpZXMgaW4gaW5kaXZpZHVhbCBcbiAqIGN5Y2xlcyBpZiBkdXJhdGlvbiBvZiBxdWVyeSBpcyBncmVhdGVyIHRoYW4gMSBjeWNsZS5cbiAqIEZpbHRlcnMgZXZlbnRzIG91dHNpZGUgb2YgdGhlIHRoZSBpbnRlbmRlZCByYW5nZS4gXG4gKiBSZW1hcHMgZXZlbnRzIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBpbml0aWFsIHBoYXNlLlxuICovXG5jb25zdCBxdWVyeUFyYyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gIGNvbnN0IHN0YXJ0ICAgICAgICAgPSBwaGFzZS5jbG9uZSgpLFxuICAgICAgICBlbmQgICAgICAgICAgID0gc3RhcnQuYWRkKCBkdXJhdGlvbiApLFxuICAgICAgICAvLyBnZXQgcGhhc2Ugb2Zmc2V0IGlmIHNjaGVkdWxpbmcgYmVnaW5zIGluIG1pZGRsZSBvZiBldmVudCBhcmNcbiAgICAgICAgYWRqdXN0ZWRQaGFzZSA9IGFkanVzdFBoYXNlKCBwaGFzZSwgZ2V0UGhhc2VJbmNyKCBwYXR0ZXJuICksIGVuZCApXG5cbiAgbGV0IGV2ZW50TGlzdFxuXG4gIC8vIGlmIHdlJ3JlIHF1ZXJ5aW5nIGFuIGFyYyB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBvbmUgY3ljbGUgaW4gbGVuZ3RoLi5cbiAgaWYoIGR1cmF0aW9uLnZhbHVlT2YoKSA8PSAxICkge1xuICAgIGV2ZW50TGlzdCA9IHByb2Nlc3NQYXR0ZXJuKCBcbiAgICAgIHBhdHRlcm4sIFxuICAgICAgZHVyYXRpb24sIFxuICAgICAgYWRqdXN0ZWRQaGFzZSwgXG4gICAgICBudWxsLCBcbiAgICAgIG51bGwsIFxuICAgICAgZmFsc2UvL3Nob3VsZFJlbWFwKCBwYXR0ZXJuICkgXG4gICAgKVxuICB9ZWxzZXtcbiAgICAvLyBmb3IgbG9uZ2VyIGFyY3Mgd2UgbmVlZCB0byBxdWVyeSBvbmUgY3ljbGUgYXQgYSB0aW1lXG4gICAgZXZlbnRMaXN0ID0gW11cbiAgICBsZXQgY291bnQgPSAwXG4gICAgZm9yKCBsZXQgaSA9IGFkanVzdGVkUGhhc2UudmFsdWVPZigpOyBpIDwgYWRqdXN0ZWRQaGFzZS5hZGQoIGR1cmF0aW9uICkudmFsdWVPZigpOyBpKysgKSB7XG4gICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KCBcbiAgICAgICAgcHJvY2Vzc1BhdHRlcm4oIFxuICAgICAgICAgIHBhdHRlcm4sIFxuICAgICAgICAgIEZyYWN0aW9uKDEpLFxuICAgICAgICAgIGFkanVzdGVkUGhhc2UuYWRkKCBjb3VudCsrICksIFxuICAgICAgICAgIG51bGwsIFxuICAgICAgICAgIG51bGwsIFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBwcnVuZSBhbnkgZXZlbnRzIHRoYXQgZmFsbCBiZWZvcmUgb3VyIHN0YXJ0IHBoYXNlIG9yIGFmdGVyIG91ciBlbmQgcGhhc2VcbiAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmZpbHRlciggZXZ0ID0+IHtcbiAgICByZXR1cm4gKGV2dC5hcmMuc3RhcnQudmFsdWVPZigpID49IHN0YXJ0LnZhbHVlT2YoKSBcbiAgICAgICAgJiYgZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgIDwgIGVuZC52YWx1ZU9mKCkgKSBcbiAgfSlcbiAgLy8gcmVtYXAgZXZlbnRzIHRvIG1ha2UgdGhlaXIgYXJjcyByZWxhdGl2ZSB0byBpbml0aWFsIHBoYXNlIGFyZ3VtZW50XG4gIC5tYXAoIGV2dCA9PiB7XG4gICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuc3ViKCBzdGFydCApXG4gICAgZXZ0LmFyYy5lbmQgICA9IGV2dC5hcmMuZW5kLnN1Yiggc3RhcnQgKVxuICAgIHJldHVybiBldnRcbiAgfSlcbiBcbiAgLy9jb25zb2xlLmxvZyggJ2V2ZW50TGlzdDonLCBsb2coZXZlbnRMaXN0LHtkZXB0aDo0fSkgKVxuICByZXR1cm4gZXZlbnRMaXN0XG59XG5cbi8vIGlmIGFuIGV2ZW50IGlzIGZvdW5kIHRoYXQgcmVwcmVzZW50cyBhIHBhdHRlcm4gKGFzIG9wcG9zZWQgdG8gYSBjb25zdGFudCkgdGhpcyBmdW5jdGlvblxuLy8gaXMgY2FsbGVkIHRvIHF1ZXJ5IHRoZSBwYXR0ZXJuIGFuZCBtYXAgYW55IGdlbmVyYXRlZCBldmVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIHRpbWVzcGFuXG5jb25zdCBwcm9jZXNzUGF0dGVybiA9ICggcGF0dGVybiwgZHVyYXRpb24sIHBoYXNlLCBwaGFzZUluY3I9bnVsbCwgb3ZlcnJpZGUgPSBudWxsLCBzaG91bGRSZW1hcEFyY3M9ZmFsc2UgKSA9PiB7XG4gIC8vaWYoIHBoYXNlSW5jciAhPT0gbnVsbCApIGRlYnVnZ2VyXG4gIGNvbnN0IHN0YXRlID0gW11cbiAgc3RhdGUucGhhc2UgPSBwaGFzZVxuICBsZXQgZXZlbnRzID0gaGFuZGxlcnNbIHBhdHRlcm4udHlwZSBdKCBcbiAgICBzdGF0ZSwgXG4gICAgcGF0dGVybiwgXG4gICAgLypzaG91bGRSZXNldCggcGF0dGVybiApID09PSB0cnVlID8gRnJhY3Rpb24oMCkgOiovIHBoYXNlLmNsb25lKCksIFxuICAgIC8vIFhYWCB0aGlzIGlzIGNvbmZ1c2luZy4gd2UgYXJlIGdldHRpbmcgYXJvdW5kIGEgcHJvYmxlbVxuICAgIC8vIHdpdGggcG9seW1ldGVycyB3aGVyZSBkdXBsaWNhdGUgZXZlbnRzIGFyZSBnZW5lcmF0ZWQgYnlcbiAgICAvLyBub3QgcGFzc2luZyBhIHBoYXNlSW5jci4uLiBpdCdzIG5vdCBuZWVkZWQgc2luY2UgdGhlcmUncyBhblxuICAgIC8vIG92ZXJyaWRlLiBCdXQgdGhpcyBkb2Vzbid0IHNlZW0gbGlrZSBjb3JyZWN0IHdheSB0byBzb2x2ZVxuICAgIC8vIHRoaXMgcHJvYmxlbSBhbmQgd2lsbCBwcm9iYWJseSBjYXVzZSBmdXR1cmUgcHJvYmxlbXMuLi5cbiAgICBwaGFzZUluY3IgIT09IG51bGwgPyBkdXJhdGlvbi5kaXYoIHBoYXNlSW5jciApIDogZHVyYXRpb24sIFxuICAgIG92ZXJyaWRlIFxuICApXG5cbiAgLy8gaWYgbmVlZGVkLCByZW1hcCBhcmNzIGZvciBldmVudHNcbiAgaWYoIHNob3VsZFJlbWFwQXJjcyA9PT0gdHJ1ZSApIHtcbiAgICBpZiggcGhhc2VJbmNyID09PSBudWxsICkgcGhhc2VJbmNyID0gZ2V0UGhhc2VJbmNyKCBwYXR0ZXJuIClcbiAgICBldmVudHMgPSBldmVudHMubWFwKCB2ID0+ICh7XG4gICAgICB2YWx1ZTogdi52YWx1ZSxcbiAgICAgIGFyYzogZ2V0TWFwcGVkQXJjKCB2LmFyYywgcGhhc2UuY2xvbmUoKSwgcGhhc2VJbmNyIClcbiAgICB9KSApXG4gIH1cbiBcbiAgcmV0dXJuIGV2ZW50cyBcbn1cbi8vIHBsYWNlaG9sZGVyIGZvciBwb3RlbnRpYWxseSBhZGRpbmcgbW9yZSBnb29kaWVzIChwYXJlbnQgYXJjIGV0Yy4pIGxhdGVyXG5jb25zdCBBcmMgPSAoIHN0YXJ0LCBlbmQgKSA9PiAoeyBzdGFydCwgZW5kIH0pXG5cbmNvbnN0IHNob3VsZE5vdFJlbWFwID0gWydwb2x5bWV0ZXInLCAnb25lc3RlcCddXG5jb25zdCBzaG91bGRSZW1hcCA9IHBhdHRlcm4gPT4gc2hvdWxkTm90UmVtYXAuaW5kZXhPZiggcGF0dGVybi50eXBlICkgPT09IC0xXG5cbi8vIFhYWCBzZWVtcyBsaWtlIGdldE1hcHBlZEFyYyBzaG91bGQgYmUgY2hhbmdlZCB0byB3aGF0IG9uZXN0ZXAgYW5kIGdyb3VwIGFyZSBub3cgdXNpbmc/XG4vLyB3b3VsZCB0aGF0IGNoYW5nZSB3b3JrIHdpdGggaG93IGdldE1hcHBlZEFyYyBpcyB1c2VkIGluIHByb2Nlc3NQYXR0ZXJuP1xuXG4vLyBtYXAgYXJjIHRpbWUgdmFsdWVzIHRvIGFwcHJvcHJpYXRlIGR1cmF0aW9uc1xuY29uc3QgZ2V0TWFwcGVkQXJjID0gKCBhcmMsIHBoYXNlLCBwaGFzZUluY3IgKSA9PiB7XG4gIGxldCBtYXBwZWRBcmNcbiAgXG4gIGlmKCBwaGFzZS5tb2QoIHBoYXNlSW5jciApLnZhbHVlT2YoKSAhPT0gMCApIHtcbiAgICBtYXBwZWRBcmMgPSBBcmMoIFxuICAgICAgYXJjLnN0YXJ0Lm11bCggcGhhc2VJbmNyICkuYWRkKCBwaGFzZSApLCBcbiAgICAgIGFyYy5lbmQubXVsKCBwaGFzZUluY3IgKS5hZGQoIHBoYXNlSW5jci5tb2QoIHBoYXNlICkgKSBcbiAgICApXG4gIH1lbHNle1xuICAgIG1hcHBlZEFyYyA9IEFyYyggXG4gICAgICBhcmMuc3RhcnQubXVsKCBwaGFzZUluY3IgKS5hZGQoIHBoYXNlICksIFxuICAgICAgYXJjLmVuZC5tdWwoIHBoYXNlSW5jciApLmFkZCggcGhhc2UgKSBcbiAgICApXG4gIH1cbiAgXG4gIHJldHVybiBtYXBwZWRBcmNcbn1cblxuLy8gaWYgaW5pdGlhbCBwaGFzZSBpcyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFyYywgYWR2YW5jZSB0byB0aGUgZW5kIGJ5IGNhbGN1bGF0aW5nIHRoZSBkaWZmZXJlbmNlXG4vLyBiZXR3ZWVuIHRoZSBjdXJyZW50IHBoYXNlIGFuZCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgYXJjLCBhbmQgaW5jcmVhc2luZyBwaGFzZSBhY2NvcmRpbmdseS5cbmNvbnN0IGFkanVzdFBoYXNlID0gKCBwaGFzZSwgcGhhc2VJbmNyLCBlbmQgKSA9PiBwaGFzZS52YWx1ZU9mKCkgPT09IDAgXG4gID8gRnJhY3Rpb24oMCkgXG4gIDogcGhhc2Uuc3ViKCBwaGFzZS5tb2QoIHBoYXNlSW5jciApIClcblxuLy8gY2hlY2sgdG8gc2VlIGlmIHBoYXNlIHNob3VsZCBhZHZhbmNlIHRvIG5leHQgZXZlbnQsIG9yLCBpZiBuZXh0IGV2ZW50IGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZSwgdG8gdGhlXG4vLyBlbmQgb2YgdGhlIGN1cnJlbnQgZHVyYXRpb24gYmVpbmcgcmVxdWVzdGVkLlxuY29uc3QgYWR2YW5jZVBoYXNlID0gKCBwaGFzZSwgcGhhc2VJbmNyLCBlbmQgKSA9PiBwaGFzZSArIHBoYXNlSW5jciA8PSBlbmQgPyBwaGFzZS5hZGQoIHBoYXNlSW5jciApIDogZW5kIFxuXG4vLyBjYWxjdWxhdGUgdGhlIGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50IGJlaW5nIHByb2Nlc3NlZC5cbmNvbnN0IGNhbGN1bGF0ZUR1cmF0aW9uID0gKCBwaGFzZSwgcGhhc2VJbmNyLCBlbmQgKSA9PiBwaGFzZSArIHBoYXNlSW5jciA8PSBlbmQgPyBwaGFzZUluY3IgOiBlbmQuc3ViKCBwaGFzZSApXG5cbi8vIGdldCBhbiBpbmRleCBudW1iZXIgZm9yIGEgcGF0dGVybiBmb3IgYSBwYXJ0aWN1bGFyIHBoYXNlXG5jb25zdCBnZXRJbmRleCA9ICggcGF0dGVybiwgcGhhc2UgKSA9PiB7XG4gIGxldCBpZHggPSAwXG4gIGlmKCBwYXR0ZXJuLm9wdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcbiAgICBpZiggcGF0dGVybi5vcHRpb25zLm92ZXJyaWRlSW5jciA9PT0gdHJ1ZSApIHtcbiAgICAgIGlkeCA9IHBoYXNlLmRpdiggcGF0dGVybi5vcHRpb25zLmluY3IgKS5tb2QoIHBhdHRlcm4udmFsdWVzLmxlbmd0aCApLmZsb29yKClcbiAgICB9XG4gIH1lbHNle1xuICAgIC8vIGRlZmF1bHQgbGlzdCBiZWhhdmlvclxuICAgIGlkeCA9IHBoYXNlLm11bCggRnJhY3Rpb24oIHBhdHRlcm4udmFsdWVzLmxlbmd0aCApICkubW9kKCBwYXR0ZXJuLnZhbHVlcy5sZW5ndGggKS5mbG9vcigpXG4gIH1cblxuICByZXR1cm4gaWR4LnZhbHVlT2YoKVxufVxuXG4vLyBpbiBhZGRpdGlvbiB0byAnZmFzdCcsIHBoYXNlIHJlc2V0cyBhcmUgYWxzbyBuZWNlc3Nhcnkgd2hlbiBpbmRleGluZyBzdWJwYXR0ZXJucyxcbi8vIHdoaWNoIGFyZSBjdXJyZW50bHkgYXJyYXlzIHdpdGggbm8gZGVmaW5lZCAudHlwZSBwcm9wZXJ0eSwgaGVuY2UgdGhlIGluY2x1c2lvbiBvZlxuLy8gdW5kZWZpbmVkIGluIHRoZSBhcnJheSBiZWxvd1xuY29uc3Qgc2hvdWxkUmVzZXRQaGFzZSA9IFsgJ3JlcGVhdCcsIHVuZGVmaW5lZCwgJ2dyb3VwJywgJ2xheWVycycgXSBcblxuLy8gWFhYIGRvZXMgdGhlc2UgbmVlZCB0byBsb29rIGF0IGFsbCBwYXJlbnRzIHJlY3Vyc2l2ZWx5PyBSaWdodCBub3cgd2UncmUgb25seSB1c2luZyBvbmUgZ2VuZXJhdGlvbi4uLlxuY29uc3Qgc2hvdWxkUmVzZXQgPSBwYXR0ZXJuID0+IHtcbiAgY29uc3QgcmVzZXQgPSBzaG91bGRSZXNldFBoYXNlLmluZGV4T2YoIHBhdHRlcm4udHlwZSApID4gLTEgXG4gIGNvbnN0IHBhcmVudCA9IHBhdHRlcm4ucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgc2hvdWxkUmVzZXRQaGFzZS5pbmRleE9mKCBwYXR0ZXJuLnBhcmVudC50eXBlICkgPiAtMVxuXG4gIHJldHVybiByZXNldCAmJiBwYXJlbnRcbn1cblxuLy8gSSBhc3N1bWUgdGhpcyB3aWxsIG5lZWQgdG8gYmUgYSBzd2l0Y2ggb24gcGF0dGVybi50eXBlIGluIHRoZSBmdXR1cmUuLi5cbmNvbnN0IGdldFBoYXNlSW5jciA9IHBhdHRlcm4gPT4ge1xuICBsZXQgaW5jclxuXG4gIHN3aXRjaCggcGF0dGVybi50eXBlICkge1xuICAgIGNhc2UgJ3BvbHltZXRlcic6IGluY3IgPSBGcmFjdGlvbiggMSwgcGF0dGVybi5sZWZ0LnZhbHVlcy5sZW5ndGggKTsgYnJlYWs7XG4gICAgY2FzZSAnbnVtYmVyJzogY2FzZSAnc3RyaW5nJzogaW5jciA9IEZyYWN0aW9uKCAxICk7IGJyZWFrO1xuICAgIGNhc2UgJ29uZXN0ZXAnOiBpbmNyID0gbnVsbDsgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmKCBwYXR0ZXJuLnZhbHVlcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGluY3IgPSBGcmFjdGlvbigxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jciA9IEZyYWN0aW9uKCAxLCBwYXR0ZXJuLnZhbHVlcy5sZW5ndGggKVxuICAgICAgICAvL2xldCBsZW4gPSAwXG4gICAgICAgIC8vcGF0dGVybi52YWx1ZXMuZm9yRWFjaCggdiA9PiBsZW4gKz0gdi50eXBlID09PSAnc2xvdycgPyB2LnJhdGUudmFsdWUgOiAxIClcbiAgICAgICAgLy9pbmNyID0gRnJhY3Rpb24oIDEsIGxlbiApIFxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgfVxuXG4gIHJldHVybiBpbmNyXG59XG5cbmNvbnN0IGhhbmRsZXJzID0ge1xuICByZXN0KCBzdGF0ZSApIHsgcmV0dXJuIHN0YXRlIH0sXG5cbiAgLy8gc3RhbmRhcmQgbGlzdHMgZS5nLiAnMCAxIDIgMycgb3IgJ1swIDEgMl0nXG4gIGdyb3VwKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uLCBvdmVycmlkZUluY3I9bnVsbCApIHtcbiAgICBjb25zdCBzdGFydCAgICAgPSBwaGFzZS5jbG9uZSgpLFxuICAgICAgICAgIGVuZCAgICAgICA9IHN0YXJ0LmFkZCggZHVyYXRpb24gKSxcbiAgICAgICAgICBwaGFzZUluY3IgPSBvdmVycmlkZUluY3IgPT09IG51bGwgXG4gICAgICAgICAgICA/IGdldFBoYXNlSW5jciggcGF0dGVybiApIFxuICAgICAgICAgICAgOiBvdmVycmlkZUluY3JcbiAgICAgICAgICBcbiAgICBsZXQgZXZlbnRMaXN0ID0gW11cblxuICAgIC8vY29uc29sZS5sb2coIFxuICAgIC8vICAndHlwZTonLCAgcGF0dGVybi50eXBlLCBcbiAgICAvLyAgJ3BoYXNlOicsIHBoYXNlLnRvRnJhY3Rpb24oKSxcbiAgICAvLyAgJ2luY3I6JywgIHBoYXNlSW5jci50b0ZyYWN0aW9uKCksXG4gICAgLy8gICdkdXI6JywgICBkdXJhdGlvbi50b0ZyYWN0aW9uKClcbiAgICAvLylcbiAgICBcbiAgICB3aGlsZSggcGhhc2UuY29tcGFyZSggZW5kICkgPCAwICkge1xuICAgICAgLy8gaWYgcGF0dGVybiBpcyBhIGxpc3QsIHJlYWQgdXNpbmcgY3VycmVudCBwaGFzZSwgZWxzZSByZWFkIGRpcmVjdGx5XG4gICAgICBjb25zdCBtZW1iZXIgPSBBcnJheS5pc0FycmF5KCBwYXR0ZXJuLnZhbHVlcyApID09PSB0cnVlIFxuICAgICAgICA/IHBhdHRlcm4udmFsdWVzWyBnZXRJbmRleCggcGF0dGVybiwgcGhhc2UgKSBdIFxuICAgICAgICA6IHBhdHRlcm4udmFsdWVcblxuICAgICAgLy8gZ2V0IGR1cmF0aW9uIG9mIGN1cnJlbnQgZXZlbnQgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICBjb25zdCBkdXIgPSBjYWxjdWxhdGVEdXJhdGlvbiggcGhhc2UsIHBoYXNlSW5jciwgZW5kIClcblxuICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGEgbnVtZXJpYyBvciBzdHJpbmcgY29uc3RhbnQgKGlmIGl0J3MgYSBwYXR0ZXJuKS4uLlxuICAgICAgaWYoIG1lbWJlciA9PT0gdW5kZWZpbmVkIHx8IChpc05hTiggbWVtYmVyLnZhbHVlICkgJiYgdHlwZW9mIG1lbWJlci52YWx1ZSAhPT0gJ3N0cmluZycpICkge1xuICAgICAgICAvLyBxdWVyeSB0aGUgcGF0dGVybiBhbmQgcmVtYXAgdGltZSB2YWx1ZXMgYXBwcm9wcmlhdGVseSBcbiAgICAgICAgaWYoIG1lbWJlciAhPT0gdW5kZWZpbmVkICkgbWVtYmVyLnBhcmVudCA9IHBhdHRlcm5cbiAgICAgICAgLy9jb25zb2xlLmxvZyggJ3Byb2Nlc3NpbmcgJywgcGF0dGVybi50eXBlLCBtZW1iZXIudHlwZSwgZHVyLnRvRnJhY3Rpb24oKSwgIHBoYXNlSW5jci50b0ZyYWN0aW9uKCkgKVxuICAgICAgICBjb25zdCBldmVudHMgPSBwcm9jZXNzUGF0dGVybiggXG4gICAgICAgICAgbWVtYmVyLCBcbiAgICAgICAgICBGcmFjdGlvbigxKSwgXG4gICAgICAgICAgLy9tZW1iZXIudHlwZSAhPT0gJ3Nsb3cnID8gRnJhY3Rpb24oMCkgOiBwaGFzZS5jbG9uZSgpLCBcbiAgICAgICAgICBGcmFjdGlvbigwKSxcbiAgICAgICAgICBudWxsLCAvL2dldFBoYXNlSW5jcihtZW1iZXIpLFxuICAgICAgICAgIG51bGwsIFxuICAgICAgICAgIGZhbHNlLy9zaG91bGRSZW1hcCggbWVtYmVyIClcbiAgICAgICAgKVxuICAgICAgICAubWFwKCBldnQgPT4ge1xuICAgICAgICAgIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0Lm11bCggZHVyICkuYWRkKCBwaGFzZSApXG4gICAgICAgICAgZXZ0LmFyYy5lbmQgICA9IGV2dC5hcmMuZW5kLm11bCggZHVyICkuYWRkKCBwaGFzZSApXG4gICAgICAgICAgcmV0dXJuIGV2dFxuICAgICAgICB9KVxuXG4gICAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQoIGV2ZW50cyApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gWFhYIHNob3VsZG4ndCB3ZSBqdXN0IHByb2Nlc3MgYWxsIHBhdHRlcm5zPz8/XG4gICAgICAgIC8vIG1lbWJlciBkb2VzIG5vdCBuZWVkIGZ1cnRoZXIgcHJvY2Vzc2luZywgc28gYWRkIHRvIGV2ZW50IGxpc3RcbiAgICAgICAgY29uc3QgZXZ0ID0geyBcbiAgICAgICAgICB2YWx1ZTptZW1iZXIudmFsdWUsIFxuICAgICAgICAgIGFyYzpBcmMoIHBoYXNlLCBwaGFzZS5hZGQoIGR1ciApICksXG4gICAgICAgIH1cbiAgICAgICAgaWYoIG1lbWJlci51aWQgIT09IHVuZGVmaW5lZCApIGV2dC51aWQgPSBtZW1iZXIudWlkIFxuXG4gICAgICAgIGV2ZW50TGlzdC5wdXNoKCBldnQgKVxuICAgICAgfVxuXG4gICAgICAvLyBhc3N1bWluZyB3ZSBhcmUgc3RhcnRpbmcgLyBlbmRpbmcgYXQgYSByZWd1bGFyIHBoYXNlIGluY3JlbWVudCB2YWx1ZS4uLlxuICAgICAgXG4gICAgICBpZiggcGhhc2UubW9kKCBwaGFzZUluY3IgKS52YWx1ZU9mKCkgPT09IDAgKSB7XG4gICAgICAgIHBoYXNlID0gYWR2YW5jZVBoYXNlKCBwaGFzZSwgcGhhc2VJbmNyLCBlbmQgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIGFkdmFuY2UgcGhhc2UgdG8gbmV4dCBwaGFzZSBpbmNyZW1lbnRcbiAgICAgICAgcGhhc2UgPSBwaGFzZS5hZGQoIHBoYXNlSW5jci5zdWIoIHBoYXNlLm1vZCggcGhhc2VJbmNyICkgKSApIFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBydW5lIGFueSBldmVudHMgdGhhdCBmYWxsIGJlZm9yZSBvdXIgc3RhcnQgcGhhc2Ugb3IgYWZ0ZXIgb3VyIGVuZCBwaGFzZVxuICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5maWx0ZXIoIGV2dCA9PiB7XG4gICAgICByZXR1cm4gZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgPj0gc3RhcnQudmFsdWVPZigpICYmIGV2dC5hcmMuc3RhcnQudmFsdWVPZigpIDwgZW5kLnZhbHVlT2YoKVxuICAgIH0pXG4gICBcbiAgICByZXR1cm4gc3RhdGUuY29uY2F0KCBldmVudExpc3QgKVxuICB9LFxuXG4gIGJqb3JrbHVuZCggc3RhdGUsIHBhdHRlcm4sIHBoYXNlLCBkdXJhdGlvbiApIHtcbiAgICBjb25zdCBvbmVzQW5kWmVyb3MgPSBiam9yayggcGF0dGVybi5wdWxzZXMudmFsdWUsIHBhdHRlcm4uc2xvdHMudmFsdWUgKVxuICAgIGxldCByb3RhdGlvbiA9IHBhdHRlcm4ucm90YXRpb24gIT09IG51bGwgPyBwYXR0ZXJuLnJvdGF0aW9uLnZhbHVlIDogMFxuICAgIFxuICAgIC8vIHJvdGF0ZSByaWdodFxuICAgIGlmKCByb3RhdGlvbiA+IDAgKSB7XG4gICAgICB3aGlsZSggcm90YXRpb24gPiAwICkge1xuICAgICAgICBjb25zdCByaWdodCA9IG9uZXNBbmRaZXJvcy5wb3AoKVxuICAgICAgICBvbmVzQW5kWmVyb3MudW5zaGlmdCggcmlnaHQgKVxuICAgICAgICByb3RhdGlvbi0tXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCByb3RhdGlvbiA8IDAgKSB7XG4gICAgICAvLyByb3RhdGUgbGVmdFxuICAgICAgd2hpbGUoIHJvdGF0aW9uIDwgMCApIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IG9uZXNBbmRaZXJvcy5zaGlmdCgpXG4gICAgICAgIG9uZXNBbmRaZXJvcy5wdXNoKCBsZWZ0IClcbiAgICAgICAgcm90YXRpb24rK1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzbG90RHVyYXRpb24gPSBkdXJhdGlvbi5kaXYoIHBhdHRlcm4uc2xvdHMudmFsdWUgKVxuICAgIGNvbnN0IHZhbHVlSXNWYWx1ZSA9IHBhdHRlcm4udmFsdWUudHlwZSA9PT0gJ251bWJlcicgfHwgcGF0dGVybi52YWx1ZS50eXBlID09PSAnc3RyaW5nJ1xuXG4gICAgY29uc3QgZXZlbnRzID0gb25lc0FuZFplcm9zLm1hcCggKCBzaG91bGRJbmNsdWRlLCBpLCBhcnIgKSA9PiB7XG4gICAgICBsZXQgZXZ0XG4gICAgICAvLyBkb24ndCBwcm9jZXNzIHVubGVzcyBhbiBhY3R1YWwgZXZlbnQgd2lsbCBiZSBpbmNsdWRlZC4uLlxuICAgICAgaWYoIHNob3VsZEluY2x1ZGUgPT09IDEgKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UGhhc2UgPSBwaGFzZS5hZGQoIHNsb3REdXJhdGlvbi5tdWwoIGkgKSApXG4gICAgICAgIGV2dCA9IHtcbiAgICAgICAgICBzaG91bGRJbmNsdWRlLFxuICAgICAgICAgIC8vIFhYWCBpcyB0aGVyZSBhIGNhc2Ugd2hlcmUgd2Ugc2hvdWxkIHVzZSBtb3JlIHRoYW4gXG4gICAgICAgICAgLy8gdGhlIGZpcnN0IHZhbHVlIGJ5IHF1ZXJ5aW5nIHRoZSB2YWx1ZSBwYXR0ZXJuP1xuICAgICAgICAgIHZhbHVlOnZhbHVlSXNWYWx1ZSA/IHBhdHRlcm4udmFsdWUgOiBwcm9jZXNzUGF0dGVybiggcGF0dGVybi52YWx1ZSwgc2xvdER1cmF0aW9uLCBzdGFydFBoYXNlIClbMF0udmFsdWUsXG4gICAgICAgICAgYXJjOkFyYyggc3RhcnRQaGFzZSwgc3RhcnRQaGFzZS5hZGQoIHNsb3REdXJhdGlvbiApICkgXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBldnQgPSB7IHNob3VsZEluY2x1ZGUgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZ0XG4gICAgfSlcbiAgICAuZmlsdGVyKCBldnQgPT4ge1xuICAgICAgbGV0IHNob3VsZEluY2x1ZGUgPSBldnQuc2hvdWxkSW5jbHVkZVxuXG4gICAgICAvLyBuZWVkZWQgdG8gcGFzcyB0ZXN0cyBhbmQgaXMgYWxzbyBjbGVhbmVyLi4uXG4gICAgICBkZWxldGUgZXZ0LnNob3VsZEluY2x1ZGVcbiAgICAgIHJldHVybiBzaG91bGRJbmNsdWRlID09PSAxXG4gICAgfSlcblxuICAgIGV2ZW50cy5mb3JFYWNoKCBldnQgPT4ge1xuICAgICAgZXZ0LnVpZCA9IHBhdHRlcm4udmFsdWUudWlkXG4gICAgICBzdGF0ZS5wdXNoKCBldnQgKSBcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBzdGF0ZVxuICB9LFxuXG4gIG9uZXN0ZXAoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgcGF0dGVybi52YWx1ZXMuZm9yRWFjaCggZ3JvdXAgPT4ge1xuICAgICAgLy8gaW5pdGlhbGl6ZSwgdGhlbiBpbmNyZW1lbnQuIHRoaXMgYXNzdW1lcyB0aGF0IHRoZSBwYXR0ZXJuIHdpbGwgYmUgcGFyc2VkIG9uY2UsXG4gICAgICAvLyBhbmQgdGhlbiB0aGUgcmVzdWx0aW5nIGRhdGEgc3RydWN0dXJlIHdpbGwgYmUgcXVlcmllZCByZXBlYXRlZGx5LCBlbmFibGluZyB0aGUgdXNlXG4gICAgICAvLyBvZiBzdGF0ZS5cbiAgICAgIGdyb3VwLmNvdW50ID0gZ3JvdXAuY291bnQgPT09IHVuZGVmaW5lZCA/IDAgOiBncm91cC5jb3VudCArIDFcblxuICAgICAgY29uc3Qgc3VicGF0dGVybiA9IGdyb3VwLnZhbHVlc1sgZ3JvdXAuY291bnQgJSBncm91cC52YWx1ZXMubGVuZ3RoIF1cbiAgICAgIGNvbnN0IGR1ciA9IGR1cmF0aW9uLnZhbHVlT2YoKSA8PSAxID8gRnJhY3Rpb24oMSkgOiBkdXJhdGlvbiBcbiAgICAgIGNvbnN0IGR1ckRpZmYgPSBkdXJhdGlvbi5tdWwoIGR1ciApIFxuXG4gICAgICBjb25zdCBldmVudHMgPSBwcm9jZXNzUGF0dGVybiggXG4gICAgICAgIHN1YnBhdHRlcm4sIFxuICAgICAgICBkdXIsXG4gICAgICAgIEZyYWN0aW9uKDApLCBcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxudWxsLHRydWVcbiAgICAgICkubWFwKCBldnQgPT4ge1xuICAgICAgICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5tdWwoIGR1cmF0aW9uICkuYWRkKCBwaGFzZSApXG4gICAgICAgIGV2dC5hcmMuZW5kID0gZXZ0LmFyYy5lbmQubXVsKCBkdXJhdGlvbiApLmFkZCggcGhhc2UgKVxuXG4gICAgICAgIHJldHVybiBldnRcbiAgICAgIH0pICBcblxuICAgICAgc3RhdGUucHVzaCggLi4uZXZlbnRzIClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHN0YXRlXG4gIH0sXG5cbiAgbnVtYmVyKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIC8vaWYoIHBoYXNlLnZhbHVlT2YoKSA9PT0gMCApIHtcbiAgICAgIGNvbnN0IGV2dCA9IHsgYXJjOkFyYyggcGhhc2UsIHBoYXNlLmFkZCggZHVyYXRpb24gKSApLCB2YWx1ZTpwYXR0ZXJuLnZhbHVlIH1cbiAgICAgIGlmKCBwYXR0ZXJuLnVpZCAhPT0gdW5kZWZpbmVkICkgZXZ0LnVpZCA9IHBhdHRlcm4udWlkXG4gICAgICBzdGF0ZS5wdXNoKGV2dClcbiAgICAvL31cbiAgICByZXR1cm4gc3RhdGUgXG4gIH0sXG5cbiAgc3RyaW5nKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIGNvbnN0IGV2dCA9IHsgYXJjOkFyYyggcGhhc2UsIHBoYXNlLmFkZCggZHVyYXRpb24gKSApLCB2YWx1ZTpwYXR0ZXJuLnZhbHVlIH1cbiAgICBpZiggcGF0dGVybi51aWQgIT09IHVuZGVmaW5lZCApIGV2dC51aWQgPSBwYXR0ZXJuLnVpZFxuICAgIHN0YXRlLnB1c2goZXZ0KVxuICAgIHJldHVybiBzdGF0ZSBcbiAgfSxcblxuICBkZWdyYWRlKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIC8vIGF0dGVtcHQgdG8gc2VlZCByYW5kb20uLi4gcm5kKCBzdGF0ZS5waGFzZSApXG4gICAgY29uc3Qgcm51bSA9IE1hdGgucmFuZG9tKClcbiAgICAvL2NvbnNvbGUubG9nKCAncm5kOicsIHJudW0sIHN0YXRlLnBoYXNlLnRvRnJhY3Rpb24oKSApXG4gICAgaWYoIHJudW0gPiAuNSApIHtcbiAgICAgIGNvbnN0IGV2dCA9IHsgXG4gICAgICAgIGFyYzpBcmMoIHBoYXNlLCBwaGFzZS5hZGQoIGR1cmF0aW9uICkgKSwgXG4gICAgICAgIHZhbHVlOnBhdHRlcm4udmFsdWUudmFsdWVcbiAgICAgIH1cblxuICAgICAgLy9jb25zb2xlLmxvZyggJ2FkZGluZycsIGV2dCApXG5cbiAgICAgIGlmKCBwYXR0ZXJuLnVpZCAhPT0gdW5kZWZpbmVkICkgZXZ0LnVpZCA9IHBhdHRlcm4udWlkXG5cbiAgICAgIHN0YXRlLnB1c2goIGV2dCApXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlIFxuICB9LFxuXG4gIHBvbHltZXRlciggc3RhdGUsIHBhdHRlcm4sIHBoYXNlLCBkdXJhdGlvbiApIHtcbiAgICBwYXR0ZXJuLmxlZnQucGFyZW50ID0gcGF0dGVybi5yaWdodC5wYXJlbnQgPSBwYXR0ZXJuXG5cbiAgICBjb25zdCBpbmNyICA9IEZyYWN0aW9uKCAxLCBwYXR0ZXJuLmxlZnQudmFsdWVzLmxlbmd0aCApXG4gICAgY29uc3QgbGVmdCAgPSBwcm9jZXNzUGF0dGVybiggcGF0dGVybi5sZWZ0LCBkdXJhdGlvbiwgcGhhc2UuY2xvbmUoKSwgZHVyYXRpb24sIGluY3IsIGZhbHNlIClcblxuICAgIHBhdHRlcm4ucmlnaHQub3B0aW9ucyA9IHsgb3ZlcnJpZGVJbmNyOiB0cnVlLCBpbmNyIH1cbiAgICBjb25zdCByaWdodCA9IHByb2Nlc3NQYXR0ZXJuKCBwYXR0ZXJuLnJpZ2h0LCBkdXJhdGlvbiwgcGhhc2UuY2xvbmUoKSwgZHVyYXRpb24sIGluY3IsIGZhbHNlICkgXG5cbiAgICByZXR1cm4gc3RhdGUuY29uY2F0KCBsZWZ0ICkuY29uY2F0KCByaWdodCApXG4gIH0sXG5cbiAgbGF5ZXJzKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIC8vcGF0dGVybi5sZWZ0LnBhcmVudCA9IHBhdHRlcm4ucmlnaHQucGFyZW50ID0gcGF0dGVyblxuICAgIGZvciggY29uc3QgZ3JvdXAgb2YgcGF0dGVybi52YWx1ZXMgKSB7XG4gICAgICBjb25zdCBpbmNyID0gZ2V0UGhhc2VJbmNyKCBncm91cCApXG4gICAgICBjb25zdCBldmVudHMgPSBwcm9jZXNzUGF0dGVybiggZ3JvdXAsIGR1cmF0aW9uLmNsb25lKCksIHBoYXNlLmNsb25lKCksIGR1cmF0aW9uLCBudWxsLCBmYWxzZSlcbiAgICAgIC8vIG5vdCBzdXJlIHdoeSBleGNlc3MgZXZlbnRzIGFyZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IG5lZWQgdG8gYmUgZmlsdGVyZWQuLi5cbiAgICAgIC5maWx0ZXIoIGV2dCA9PiBcbiAgICAgICAgZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgPj0gcGhhc2UudmFsdWVPZigpIFxuICAgICAgICAmJiBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSA8IHBoYXNlLmFkZCggZHVyYXRpb24gKS52YWx1ZU9mKClcbiAgICAgIClcbiAgICAgIFxuICAgICAgLy9jb25zb2xlLmxvZyggJ2dyb3VwOicsIHV0aWwuaW5zcGVjdCggZ3JvdXAsIHsgZGVwdGg6MyB9KSApXG4gICAgICAvL2NvbnNvbGUubG9nKCAnc3RhdGU6JywgdXRpbC5pbnNwZWN0KCBldmVudHMsIHsgZGVwdGg6MyB9KSlcbiAgICAgIHN0YXRlID0gc3RhdGUuY29uY2F0KCBldmVudHMgKVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZVxuICB9LFxuXG4gIHNsb3coIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgY29uc3Qgc3BlZWQgPSBwYXR0ZXJuLnJhdGUudmFsdWVcblxuICAgIGxldCBldmVudHNcbiAgICAvL2lmKCBwaGFzZS52YWx1ZU9mKCkgJSBzcGVlZCA9PT0gMCApIHtcbiAgICAgIC8vIFhYWCB3aHkgZG8gd2UgbmVlZCB0aGlzIGVkZ2UgY2FzZT9cbiAgICAgIGNvbnN0IHBoYXNlRGlmZiA9IHBoYXNlLnN1YiggcGhhc2UuZGl2KCBzcGVlZCApIClcblxuICAgICAgaWYoIHBhdHRlcm4udmFsdWUudHlwZSAhPT0gJ2xheWVycycgKSB7XG4gICAgICAgIC8vZXZlbnRzID0gcXVlcnlBcmMoXG4gICAgICAgIC8vICBwYXR0ZXJuLnZhbHVlLFxuICAgICAgICAvLyAgcGhhc2UuZGl2KCBzcGVlZCApLFxuICAgICAgICAvLyAgZHVyYXRpb24uZGl2KCBzcGVlZCApXG4gICAgICAgIC8vKVxuICAgICAgICAvL2NvbnNvbGUubG9nKCBkdXJhdGlvbiwgcGhhc2UsIHNwZWVkIClcbiAgICAgICAgLy9ldmVudHMgPSBwcm9jZXNzUGF0dGVybihcbiAgICAgICAgLy8gIHBhdHRlcm4udmFsdWUsXG4gICAgICAgIC8vICBkdXJhdGlvbi5tdWwoIHNwZWVkICksXG4gICAgICAgIC8vICBwaGFzZS5kaXYoIHNwZWVkIClcbiAgICAgICAgLy8pICAgICAgIFxuICAgICAgICBldmVudHMgPSBxdWVyeUFyYyhcbiAgICAgICAgICBwYXR0ZXJuLnZhbHVlLFxuICAgICAgICAgIEZyYWN0aW9uKDApLFxuICAgICAgICAgIGR1cmF0aW9uLmRpdiggc3BlZWQgKSBcbiAgICAgICAgKS5tYXAoIGV2dCA9PiB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IGV2dC5hcmMuZW5kLnN1YiggZXZ0LmFyYy5zdGFydCApXG4gICAgICAgICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuYWRkKCBwaGFzZSApXG4gICAgICAgICAgZXZ0LmFyYy5lbmQgICA9IGV2dC5hcmMuc3RhcnQuYWRkKCBkdXJhdGlvbi5tdWwoIHNwZWVkICkgKS5hZGQoIHBoYXNlIClcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCBkaWZmLCBkdXJhdGlvbi5tdWwoIHNwZWVkICksIGV2dC5hcmMuc3RhcnQsIGV2dC5hcmMuZW5kIClcbiAgICAgICAgICByZXR1cm4gZXZ0XG4gICAgICAgIH0pXG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzID0gaGFuZGxlcnMubGF5ZXJzKCBzdGF0ZSwgcGF0dGVybi52YWx1ZSwgcGhhc2UuZGl2KCBzcGVlZCApLCBkdXJhdGlvbi5kaXYoIHNwZWVkICkgKVxuICAgICAgfVxuXG4gICAgICAvL2NvbnNvbGUubG9nKCBsb2coIGV2ZW50cywgeyBkZXB0aDozIH0pLCBwaGFzZS5hZGQoIGR1cmF0aW9uICkudG9GcmFjdGlvbigpIClcbiAgICAgIC8vaWYoIHBhdHRlcm4udmFsdWUudHlwZSA9PT0gJ2dyb3VwJyApIHtcbiAgICAgIC8vICBldmVudHMgPSBldmVudHMubWFwKCBldnQgPT4ge1xuICAgICAgLy8gICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQubXVsKCBzcGVlZCApXG4gICAgICAvLyAgICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQubXVsKCBzcGVlZCApXG4gICAgICAvLyAgICByZXR1cm4gZXZ0XG4gICAgICAvLyAgfSlcbiAgICAgIC8vfVxuICAgICAgLy9ldmVudHMgPSBldmVudHMubWFwKCBldnQgPT4ge1xuICAgICAgLy8gIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0LmFkZCggcGhhc2VEaWZmIClcbiAgICAgIC8vICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQuYWRkKCBwaGFzZURpZmYgKVxuICAgICAgLy8gIC8vZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuYWRkKCBwaGFzZSApXG4gICAgICAvLyAgLy9ldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQuYWRkKCBwaGFzZSApXG4gICAgICAvLyAgcmV0dXJuIGV2dFxuICAgICAgLy99KVxuICAgICAgLy8uZmlsdGVyKCBldnQgPT4gZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgPCBwaGFzZS5hZGQoIGR1cmF0aW9uICkudmFsdWVPZigpIClcbiAgICAvL31cbiAgICAvL2NvbnNvbGUubG9nKCAnc2xvdzonLCBsb2coIGV2ZW50cywgeyBkZXB0aDozIH0pLCBwaGFzZS5hZGQoIGR1cmF0aW9uICkudG9GcmFjdGlvbigpIClcblxuICAgIGlmKCBldmVudHMgIT09IHVuZGVmaW5lZCApIHN0YXRlID0gc3RhdGUuY29uY2F0KCBldmVudHMgKVxuXG4gICAgcmV0dXJuIHN0YXRlXG4gIH0sXG5cbi8vY29uc3QgcHJvY2Vzc1BhdHRlcm4gPSAoIHBhdHRlcm4sIGR1cmF0aW9uLCBwaGFzZSwgcGhhc2VJbmNyPW51bGwsIG92ZXJyaWRlID0gbnVsbCwgc2hvdWxkUmVtYXBBcmNzPXRydWUgKSA9PiB7XG4gIHNwZWVkKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIC8vIHRoZSBnZW5lcmFsIHByb2Nlc3Mgb2YgaW5jcmVhc2luZyB0aGUgc3BlZWQgb2YgYSBwYXR0ZXJuIGlzIHRvIHF1ZXJ5XG4gICAgLy8gZm9yIGEgbG9uZ2VyIGR1cmF0aW9uIGFjY29yZGluZyB0byB0aGUgc3BlZWQsIGFuZCB0aGUgc2NhbGUgdGhlIHJlc3VsdGluZ1xuICAgIC8vIGV2ZW50cy5cbiAgICBcbiAgICAvLyBmb2xsb3dpbmcgZXhwbGFuYXRpb24gZnJvbSB5YXh1IGZvciBob3cgc3VicGF0dGVybnMgd29yayB3aXRoIHJhdGVzLi4uXG4gICAgLy8gaHR0cHM6Ly90YWxrLmx1cmsub3JnL2NoYW5uZWwvdGlkYWw/bXNnPXo1Y2s3M0g5RXZ4UXdNcXE2IFxuICAgIC8vIHJlOiBwYXR0ZXJuIGEqWzIgNCA4XVxuICAgIC8vIFwiQW55d2F5IHdoYXQgaGFwcGVucyBpbiB0aGlzIGtpbmQgb2Ygc2l0dWF0aW9uIGlzIHRoYXQgaXQgc3BsaXRzIHRoZSBjeWNsZSBpbiB0aHJlZSwgXG4gICAgLy8gZWFjaCBhIHdpbmRvdyBvbiB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaWYgeW91J2QgaGF2ZSBzcGVkIHRoaW5ncyB1cCBieSB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgLy8gc28gZm9yIHRoZSBmaXJzdCB0aGlyZCB5b3UnZCBnZXQgYSB0aGlyZCBvZiB0d28gYSdzXG4gICAgLy8gZm9yIHRoZSBzZWNvbmQgdGhpcmQgeW91J2QgZ2V0IHRoZSBzZWNvbmQgdGhpcmQgb2YgZm91ciBhJ3MuLi5cIlxuICAgIFxuICAgIGNvbnN0IHNwZWVkID0gcGF0dGVybi5yYXRlLnZhbHVlXG4gICAgY29uc3QgZXZlbnRzID0gcXVlcnlBcmMoXG4gICAgICBwYXR0ZXJuLnZhbHVlLFxuICAgICAgRnJhY3Rpb24oMCksXG4gICAgICBkdXJhdGlvbi5tdWwoIHNwZWVkICkgXG4gICAgKS5tYXAoIGV2dCA9PiB7XG4gICAgICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5kaXYoIHNwZWVkICkuYWRkKCBwaGFzZSApXG4gICAgICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQuZGl2KCBzcGVlZCApLmFkZCggcGhhc2UgKVxuICAgICAgcmV0dXJuIGV2dFxuICAgIH0pXG5cbiAgICAvLyBYWFggYWNjb3VudCBmb3IgaGF2aW5nIGEgc3BlZWRzIHBhdHRlcm4hISEhXG4gICAgLypcbiAgICBcbiAgICBjb25zdCBpbmNyID0gRnJhY3Rpb24oMSwgc3BlZWRzLmxlbmd0aClcbiAgICBjb25zdCBzcGVlZHMgPSBxdWVyeUFyYyggcGF0dGVybi5yYXRlLCBGcmFjdGlvbigwKSwgRnJhY3Rpb24oMSkgKVxuXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBzcGVlZHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBsZXQgc3BlZWQgPSBzcGVlZHNbIGkgXS52YWx1ZVxuXG4gICAgICBpZiggcGF0dGVybi5vcGVyYXRvciA9PT0gJyonICkge1xuICAgICAgICAvL2V2ZW50cyA9IHF1ZXJ5QXJjKCBcbiAgICAgICAgLy8gIHBhdHRlcm4udmFsdWUsXG4gICAgICAgIC8vICBwaGFzZS5jbG9uZSgpLCAvL0ZyYWN0aW9uKCAwICksIFxuICAgICAgICAvLyAgRnJhY3Rpb24oIHNwZWVkICkubXVsKCBkdXJhdGlvbiApXG4gICAgICAgIC8vKVxuICAgICAgICBldmVudHMgPSBwcm9jZXNzUGF0dGVybihcbiAgICAgICAgICBwYXR0ZXJuLnZhbHVlLFxuICAgICAgICAgIGR1cmF0aW9uLm11bCggc3BlZWQgKSxcbiAgICAgICAgICBwaGFzZS5jbG9uZSgpLy9GcmFjdGlvbiggc3BlZWQgKS5tdWwoIGR1cmF0aW9uIClcbiAgICAgICAgICAvL3BoYXNlLmNsb25lKCkgXG4gICAgICAgIClcbiAgICAgICAgICBcbiAgICAgICAgLy8gcmVtYXAgZXZlbnRzIHRvIGNvcnJlY3QgdGltZSBzcGFuc1xuICAgICAgICAubWFwKCBldnQgPT4ge1xuICAgICAgICAgIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0LmRpdiggc3BlZWQgKS8vLmFkZCggcGhhc2UgKVxuICAgICAgICAgIGV2dC5hcmMuZW5kICAgPSBldnQuYXJjLmVuZC5kaXYoIHNwZWVkICkvLy5hZGQoIHBoYXNlIClcbiAgICAgICAgICByZXR1cm4gZXZ0XG4gICAgICAgIH0pXG4gICAgICAgIC8vLmZpbHRlciggZXZ0ID0+IFxuICAgICAgICAvLyAgZXZ0LmFyYy5zdGFydC5jb21wYXJlKCBpbmNyLm11bCggaSApICkgPj0gMCBcbiAgICAgICAgLy8gICAgJiYgZXZ0LmFyYy5zdGFydC5jb21wYXJlKCBpbmNyLm11bCggaSsxICkgKSA8IDAgXG4gICAgICAgIC8vKSlcbiAgICAgICAgLy8gYWRkIHRvIHByZXZpb3VzIGV2ZW50c1xuICAgICAgICAuY29uY2F0KCBldmVudHMgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIHNwZWVkID0gMS9zcGVlZFxuICAgICAgICAvL2NvbnNvbGUubG9nKCAncGhhc2U6JywgcGhhc2UubXVsKCBzcGVlZCApIClcbiAgICAgICAgZXZlbnRzID0gcHJvY2Vzc1BhdHRlcm4oIFxuICAgICAgICAgIHBhdHRlcm4udmFsdWUsIFxuICAgICAgICAgIGR1cmF0aW9uLm11bCggRnJhY3Rpb24oIHNwZWVkICkgKSwgXG4gICAgICAgICAgcGhhc2UubXVsKCBzcGVlZCApLFxuICAgICAgICAgIGdldFBoYXNlSW5jciggcGF0dGVybiApLm11bCggc3BlZWQgKSwgbnVsbCwgZmFsc2VcbiAgICAgICAgKVxuICAgICAgICAvL2NvbnNvbGUubG9nKCAnZXZlbnRzOicsIGxvZyggZXZlbnRzLCB7IGRlcHRoOjQgfSApIClcbiAgICAgICAgLy8gcmVtYXAgZXZlbnRzIHRvIGNvcnJlY3QgdGltZSBzcGFuc1xuICAgICAgICBldmVudHMubWFwKCBldnQgPT4ge1xuICAgICAgICAgIGlmKCBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSAhPT0gMCApIHtcbiAgICAgICAgICAgIC8vIFhYWCBJIGRvbid0IGtub3cgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5IGJ1dCBpdCBnZXRzIHJpZCBvZiBhIG9mZi1ieS1vbmUgZXJyb3JcbiAgICAgICAgICAgIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0LnN1YiggcGhhc2UuZGl2KCAxL3NwZWVkICkgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFsc28sIGRvZXMgdGhlIGV2ZW50IGxlbmd0aCBuZWVkIHRvIGJlIGFkanVzdGVkPyBtaWdodCBhcyB3ZWxsLi4uXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyggJ2VuZDonLCBldnQuYXJjLmVuZC50b0ZyYWN0aW9uKCksIHBoYXNlLnRvRnJhY3Rpb24oKSwgc3BlZWQgKVxuICAgICAgICAgIGV2dC5hcmMuZW5kID0gZXZ0LmFyYy5lbmQubXVsKCAxL3NwZWVkICkvLy5tdWwoIDEvc3BlZWQgKVxuICAgICAgICAgIC8vZXZ0LmFyYy5lbmQuc3ViKCBwaGFzZS5kaXYoIDEvc3BlZWQgKSApLmFkZCggMS9zcGVlZCAtIDEpXG5cbiAgICAgICAgICByZXR1cm4gZXZ0XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHJlbW92ZSBldmVudHMgZG9uJ3QgZmFsbCBpbiB0aGUgY3VycmVudCB3aW5kb3dcbiAgICAgICAgLmZpbHRlciggZXZ0ID0+IFxuICAgICAgICAgIGV2dC5hcmMuc3RhcnQuY29tcGFyZSggaW5jci5tdWwoaSkgKSA+PSAwICYmIFxuICAgICAgICAgIGV2dC5hcmMuc3RhcnQuY29tcGFyZSggaW5jci5tdWwoaSsxKSApIDw9IDAgXG4gICAgICAgIClcbiAgICAgICAgLy8gYWRkIHRvIHByZXZpb3VzIGV2ZW50c1xuICAgICAgICAuY29uY2F0KCBldmVudHMgKVxuICAgICAgfVxuICAgIH0qL1xuXG4gICAgLy9jb25zb2xlLmxvZyggJ2V2ZW50czonLCBsb2coIGV2ZW50cywgeyBkZXB0aDo0IH0pIClcbiAgICByZXR1cm4gc3RhdGUuY29uY2F0KCBldmVudHMgKVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cy5xdWVyeUFyYyA9IHF1ZXJ5QXJjXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBnW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7IHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiY29uc3QgQXVkaW8gPSByZXF1aXJlKFwiZ2liYmVyLmF1ZGlvLmxpYlwiKSxcbiAgR2liYmVyID0gcmVxdWlyZShcImdpYmJlci5jb3JlLmxpYlwiKTtcbmNocm9tYSA9IHJlcXVpcmUoXCJjaHJvbWEtanNcIik7XG5jb25zdCBwYWxsZXR0ZSA9IGNocm9tYS5icmV3ZXIuU2V0MTtcbmNvbnN0IHNldDFTY2FsZSA9IGNocm9tYS5zY2FsZShwYWxsZXR0ZSk7XG5jb25zb2xlLmxvZyhcInBhbGxldHRlOiBcIiwgcGFsbGV0dGUpO1xuXG4vLyBjb25zb2xlLmxvZygnQ2hyb21hOiAnLCBDaHJvbWEpO1xuZm9yIChjb25zdCBrZXkgaW4gQXVkaW8pIHtcbiAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKEF1ZGlvLCBrZXkpKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IEF1ZGlvW2tleV07XG4gICAgLy8gY29uc29sZS5sb2coJ2tleTogJywga2V5LCAodHlwZW9mIGVsZW1lbnQpKTtcbiAgfVxufVxuY29uc3QgY29udGVudHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250ZW50cyk7XG5jb250ZW50cy5jbGFzc0xpc3QuYWRkKFwiY29udGVudHNcIik7XG5cbmNvbnN0IGxlZnRTaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbmNvbnRlbnRzLmFwcGVuZENoaWxkKGxlZnRTaWRlKTtcbmxlZnRTaWRlLmNsYXNzTGlzdC5hZGQoXCJsZWZ0LXNpZGVcIik7XG5jb25zdCByaWdodFNpZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuY29udGVudHMuYXBwZW5kQ2hpbGQocmlnaHRTaWRlKTtcbnJpZ2h0U2lkZS5jbGFzc0xpc3QuYWRkKFwicmlnaHQtc2lkZVwiKTtcbmNvbnN0IHJpZ2h0U2lkZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyaWdodFNpZGUyKTtcbnJpZ2h0U2lkZTIuY2xhc3NMaXN0LmFkZChcInJpZ2h0LXNpZGUyXCIpO1xuXG5jb25zb2xlLmxvZyhcIkF1ZGlvOiBcIiwgQXVkaW8pO1xuY29uc3QgaW5zdHJ1bWVudHNDYXRlZ29yaWVzID0gQXVkaW8uUHJlc2V0cy5pbnN0cnVtZW50cztcbmNvbnNvbGUubG9nKFwiaW5zdHJ1bWVudHNDYXRlZ29yaWVzOiBcIiwgaW5zdHJ1bWVudHNDYXRlZ29yaWVzKTtcbnZhciBjYXRlZ29yaWVzU2l6ZSA9IE9iamVjdC5rZXlzKGluc3RydW1lbnRzQ2F0ZWdvcmllcykubGVuZ3RoO1xubGV0IGNvdW50ZXIgPSAtMTtcbmxldCBjb3VudGVyMiA9IC0xO1xuY29uc3QgZGVzY3JpcHRpb25zRGlzcGxheXMgPSBbXTtcbmNvbnN0IGluc3RydW1lbnRQYXJhbWV0ZXJzID0ge307XG5jb25zdCBhbGxJbnN0cnVtZW50UGFyYW1ldGVycyA9IG5ldyBTZXQoKTtcbmNvbnN0IGFsbEluc3RydW1lbnRQYXJhbWV0ZXJzMiA9IHt9O1xuY29uc3QgYWxsSW5zdHJ1bWVudHMgPSB7fTtcbmNvbnN0IGFsbEluc3RydW1lbnRzMiA9IHt9O1xuY29uc3QgY29sb3JzUGVyQ2F0ZWdvcnkgPSB7fTtcblxuY29uc3QgYWxsUG9zaWJsZUluc3RydW1lbnRzRGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5hbGxQb3NpYmxlSW5zdHJ1bWVudHNEaXNwbGF5LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuYWxsUG9zaWJsZUluc3RydW1lbnRzRGlzcGxheS5zdHlsZS50b3AgPSBcIjBcIjtcbmFsbFBvc2libGVJbnN0cnVtZW50c0Rpc3BsYXkuc3R5bGUubGVmdCA9IFwiMFwiO1xuXG5sZXQgYWxsUG9zaWJsZUluc3RydW1lbnRzID0gW107XG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFsbFBvc2libGVJbnN0cnVtZW50c0Rpc3BsYXkpO1xuXG5mb3IgKGNvbnN0IGNhdGVnb3J5IGluIGluc3RydW1lbnRzQ2F0ZWdvcmllcykge1xuICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaW5zdHJ1bWVudHNDYXRlZ29yaWVzLCBjYXRlZ29yeSkpIHtcbiAgICBjb3VudGVyKys7XG4gICAgY29uc3QgaW5zdHJ1bWVudHNJbkNhdGVnb3J5ID0gaW5zdHJ1bWVudHNDYXRlZ29yaWVzW2NhdGVnb3J5XTtcbiAgICBjb25zdCBpbnN0cnVtZW50SW5DYXRlZ29yeUtleXMgPSBPYmplY3Qua2V5cyhpbnN0cnVtZW50c0luQ2F0ZWdvcnkpO1xuXG4gICAgY29uc3QgaUxlbmd0aCA9IGluc3RydW1lbnRJbkNhdGVnb3J5S2V5cy5sZW5ndGg7XG4gICAgLy8gY29uc29sZS5sb2coJ2tleTogJywga2V5KTtcbiAgICAvLyBjb25zb2xlLmxvZygnZWxlbWVudDogJywgT2JqZWN0LmtleXMoZWxlbWVudCkpO1xuICAgIGNvbnN0IGNhdGVnb3J5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjYXRlZ29yeURpdi5jbGFzc05hbWUgPSBcImluc3RydW1lbnQtY2F0ZWdvcnlcIjtcbiAgICBjb25zdCBjYXRlZ29yeVRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpO1xuICAgIGNhdGVnb3J5VGl0bGUuY2xhc3NOYW1lID0gXCJjYXRlZ29yeS1uYW1lXCI7XG4gICAgY2F0ZWdvcnlUaXRsZS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgcmlnaHRTaWRlLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBjbGFlckFsbERlc2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgY2F0ZWdvcnlUaXRsZS5pbm5lckhUTUwgPSBgJHtjb3VudGVyfS0ke2NhdGVnb3J5fS0tLSR7aUxlbmd0aH1gO1xuICAgIGNhdGVnb3J5RGl2LmFwcGVuZENoaWxkKGNhdGVnb3J5VGl0bGUpO1xuICAgIGNvbnN0IGluc3RydW1lbnREZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3QgYmdDb2xvciA9IHNldDFTY2FsZShjb3VudGVyIC8gY2F0ZWdvcmllc1NpemUpXG4gICAgICAuZGFya2VuKDIpXG4gICAgICAuaGV4KCk7XG4gICAgY29sb3JzUGVyQ2F0ZWdvcnlbY2F0ZWdvcnldID0gYmdDb2xvcjtcbiAgICBjYXRlZ29yeURpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiZ0NvbG9yO1xuICAgIGNvbnN0IHBhcmFtc1NldCA9IG5ldyBTZXQoKTtcbiAgICBpbnN0cnVtZW50UGFyYW1ldGVyc1tjYXRlZ29yeV0gPSBwYXJhbXNTZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ZXIyKys7XG4gICAgICBjb25zdCBpbnN0cnVtZW50ID0gaW5zdHJ1bWVudEluQ2F0ZWdvcnlLZXlzW2ldO1xuICAgICAgY29uc3QgaW5zdHJ1bWVudE9iamVjdCA9IGluc3RydW1lbnRzSW5DYXRlZ29yeVtpbnN0cnVtZW50XTtcbiAgICAgIGNvbnN0IHBhcmFtRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBwYXJhbURpdi5jbGFzc0xpc3QuYWRkKFwicGFyYW1cIik7XG4gICAgICBjb25zdCB1bmlxdWVJRCA9IGNhdGVnb3J5ICsgaW5zdHJ1bWVudDtcbiAgICAgIGFsbFBvc2libGVJbnN0cnVtZW50cy5wdXNoKGBzID0gJHtjYXRlZ29yeX0oJyR7aW5zdHJ1bWVudH0nKWApO1xuICAgICAgYWxsSW5zdHJ1bWVudHNbdW5pcXVlSURdID0ge1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaW5zdHJ1bWVudCxcbiAgICAgICAgYmdDb2xvcixcbiAgICAgICAgcGFyYW1EaXYsXG4gICAgICB9O1xuICAgICAgLy8gcGFyYW1EaXYuY2xhc3NMaXN0LmFkZChjYXRlZ29yeSk7XG4gICAgICAvLyBwYXJhbURpdi5jbGFzc0xpc3QuYWRkKGtleSk7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHBhcmFtTmFtZS5pbm5lckhUTUwgPSBpbnN0cnVtZW50O1xuICAgICAgYWxsSW5zdHJ1bWVudHMyW2luc3RydW1lbnRdID0gcGFyYW1EaXY7XG4gICAgICBwYXJhbURpdi5hcHBlbmRDaGlsZChwYXJhbU5hbWUpO1xuICAgICAgcGFyYW1EaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgb25QYXJhbWFDbGljayhjYXRlZ29yeSwgaW5zdHJ1bWVudCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBpbnN0cnVtZW50T2JqZWN0KSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChpbnN0cnVtZW50T2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluc3RydW1lbnRPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIHBhcmFtc1NldC5hZGQocHJvcGVydHkpO1xuICAgICAgICAgIGFsbEluc3RydW1lbnRQYXJhbWV0ZXJzLmFkZChwcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKGFsbEluc3RydW1lbnRQYXJhbWV0ZXJzMltwcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgIGFsbEluc3RydW1lbnRQYXJhbWV0ZXJzMltwcm9wZXJ0eV0udHlwZW9mLmFkZCh0eXBlb2YgdmFsdWUpO1xuICAgICAgICAgICAgYWxsSW5zdHJ1bWVudFBhcmFtZXRlcnMyW3Byb3BlcnR5XS5jYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XG4gICAgICAgICAgICBhbGxJbnN0cnVtZW50UGFyYW1ldGVyczJbcHJvcGVydHldLmtleXMuYWRkKGluc3RydW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxJbnN0cnVtZW50UGFyYW1ldGVyczJbcHJvcGVydHldID0ge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgdHlwZW9mOiBuZXcgU2V0KFt0eXBlb2YgdmFsdWVdKSxcbiAgICAgICAgICAgICAgY2F0ZWdvcmllczogbmV3IFNldChbY2F0ZWdvcnldKSxcbiAgICAgICAgICAgICAga2V5czogbmV3IFNldChbaW5zdHJ1bWVudF0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgcHJvcGVydHlEaXYuY2xhc3NOYW1lID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHByb3BlcnR5TmFtZS5pbm5lckhUTUwgPSBwcm9wZXJ0eSArIFwiLlwiO1xuICAgICAgICAgIHByb3BlcnR5RGl2LmFwcGVuZENoaWxkKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHByb3BlcnR5VmFsdWUuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgcHJvcGVydHlEaXYuYXBwZW5kQ2hpbGQocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgcGFyYW1EaXYuYXBwZW5kQ2hpbGQocHJvcGVydHlEaXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJhbURpdi5hcHBlbmRDaGlsZChwYXJhbVZhbHVlKTtcbiAgICAgIGNhdGVnb3J5RGl2LmFwcGVuZENoaWxkKHBhcmFtRGl2KTtcbiAgICB9XG4gICAgY2F0ZWdvcnlEaXYuYXBwZW5kQ2hpbGQoaW5zdHJ1bWVudERlc2NyaXB0aW9uKTtcbiAgICBkZXNjcmlwdGlvbnNEaXNwbGF5cy5wdXNoKGluc3RydW1lbnREZXNjcmlwdGlvbik7XG4gICAgbGVmdFNpZGUuYXBwZW5kQ2hpbGQoY2F0ZWdvcnlEaXYpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdpbnN0cnVtZW50RGl2OiAnLCBpbnN0cnVtZW50RGl2KTtcbiAgfVxufVxuLy8gY29uc29sZS5sb2coXCJhbGxJbnN0cnVtZW50czogXCIsIGFsbEluc3RydW1lbnRzKTtcbmFsbFBvc2libGVJbnN0cnVtZW50cyA9IGFsbFBvc2libGVJbnN0cnVtZW50cy5qb2luKFwiPGJyPlwiKTtcbmNvbnNvbGUubG9nKFwiYWxsUG9zaWJsZUluc3RydW1lbnRzOiBcIiwgYWxsUG9zaWJsZUluc3RydW1lbnRzKTtcbi8vIGFsbFBvc2libGVJbnN0cnVtZW50c0Rpc3BsYXkuaW5uZXJIVE1MID0gYWxsUG9zaWJsZUluc3RydW1lbnRzO1xuY29uc3QgY2xhZXJBbGxEZXNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gIGRlc2NyaXB0aW9uc0Rpc3BsYXlzLmZvckVhY2goKGRpc3BsYXkpID0+IHtcbiAgICBkaXNwbGF5LmlubmVySFRNTCA9IFwiXCI7XG4gIH0pO1xufTtcbmNvbnN0IG9uUGFyYW1hQ2xpY2sgPSAoY2F0ZWdvcnksIGluc3RydW1lbnQpID0+IHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5wcm9wZXJ0eVwiKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgZWxlbWVudC5vbmNsaWNrID0gbnVsbDtcbiAgfSk7XG4gIGNsYWVyQWxsRGVzY3JpcHRpb25zKCk7XG4gIGNvbnN0IGJnQ29sb3IgPSBhbGxJbnN0cnVtZW50c1tjYXRlZ29yeSArIGluc3RydW1lbnRdLmJnQ29sb3I7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBpbnN0cnVtZW50c0NhdGVnb3JpZXNbY2F0ZWdvcnldW2luc3RydW1lbnRdO1xuICBsZXQgaW5kZXNPZkFBQUEgPSBPYmplY3Qua2V5cyhpbnN0cnVtZW50c0NhdGVnb3JpZXNbY2F0ZWdvcnldKS5pbmRleE9mKFxuICAgIGluc3RydW1lbnRcbiAgKTtcbiAgbGV0IGluZGVzT2ZCQkIgPSBPYmplY3Qua2V5cyhpbnN0cnVtZW50c0NhdGVnb3JpZXMpLmluZGV4T2YoY2F0ZWdvcnkpO1xuICBsZXQgc3RyaW5nID0gYDxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiR7YmdDb2xvcn07XCI+PHNwYW4+JHtpbmRlc09mQkJCfS8ke1xuICAgIE9iamVjdC5rZXlzKGluc3RydW1lbnRzQ2F0ZWdvcmllcykubGVuZ3RoXG4gIH0tJHtjYXRlZ29yeX08L3NwYW4+LS0tLTxzcGFuPiR7aW5kZXNPZkFBQUF9LyR7XG4gICAgT2JqZWN0LmtleXMoaW5zdHJ1bWVudHNDYXRlZ29yaWVzW2NhdGVnb3J5XSkubGVuZ3RoXG4gIH0tJHtpbnN0cnVtZW50fTwvc3Bhbj48L2Rpdj5gO1xuICBhbGxJbnN0cnVtZW50UGFyYW1ldGVycy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgY29uc3QgZWxlbWVudDIgPSBhbGxJbnN0cnVtZW50UGFyYW1ldGVyczJbcHJvcGVydHldO1xuICAgIGxldCBjYXRlZ29yaWVzQ29sdW1uID0gXCJcIjtcbiAgICBPYmplY3Qua2V5cyhpbnN0cnVtZW50c0NhdGVnb3JpZXMpLmZvckVhY2goKGNhdGVnb3J5NFByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBoYXNDYXRlZ29yeTRQcm9wZXJ0eSA9IGVsZW1lbnQyLmNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5NFByb3BlcnR5KTtcbiAgICAgIGNhdGVnb3JpZXNDb2x1bW4gKz0gYDxkaXYgc3R5bGU9XCJib3JkZXI6MXB4IHNvbGlkICR7XG4gICAgICAgIGNhdGVnb3J5ID09PSBjYXRlZ29yeTRQcm9wZXJ0eSAmJiBoYXNDYXRlZ29yeTRQcm9wZXJ0eSAmJiB2YWx1ZVxuICAgICAgICAgID8gXCIjYWFhXCJcbiAgICAgICAgICA6IFwiIzU1NVwiXG4gICAgICB9O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7Y29sb3I6IzU1NTtiYWNrZ3JvdW5kLWNvbG9yOiR7XG4gICAgICAgIGhhc0NhdGVnb3J5NFByb3BlcnR5XG4gICAgICAgICAgPyBjb2xvcnNQZXJDYXRlZ29yeVtjYXRlZ29yeTRQcm9wZXJ0eV1cbiAgICAgICAgICA6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfTtcIj4mbmJzcDs8L2Rpdj5gO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbHVtblByb3BlcnR5MiA9IGA8c3BhbiBjbGFzcz1cImNvbHVtbiB0aW55XCI+JHtlbGVtZW50Mi5jYXRlZ29yaWVzLnNpemV9PC9zcGFuPmA7XG4gICAgY29uc3QgY29sdW1uUHJvcGVydHkzID0gYDxzcGFuIGNsYXNzPVwiY29sdW1uIHRpbnlcIj4ke2VsZW1lbnQyLmtleXMuc2l6ZX08L3NwYW4+YDtcbiAgICBjb25zdCBjb2x1bW5Qcm9wZXJ0eSA9IGA8c3BhbiBjbGFzcz1cImNvbHVtbiBzbWFsbCBwcm9wZXJ0eVwiIG9uY2xpY2s9XCJvbkluc3RydW1lbnRQYXJhbUNsaWNrKHRoaXMpXCI+JHtwcm9wZXJ0eX08L3NwYW4+YDtcbiAgICBjb25zdCBjb2x1bW5UeXBlT2YgPSBgPHNwYW4gY2xhc3M9XCJjb2x1bW4gc21hbGxcIj4ke1xuICAgICAgZWxlbWVudDIudHlwZW9mID8gQXJyYXkuZnJvbShlbGVtZW50Mi50eXBlb2YpLnRvU3RyaW5nKCkgOiBcIi1cIlxuICAgIH08L3NwYW4+YDtcbiAgICBjb25zdCBjb2x1bW5FbGVtZW50VmFsdWUgPSBgPHNwYW4gY2xhc3M9XCJjb2x1bW4gZWxlbWVudFwiPiR7XG4gICAgICB2YWx1ZSA/IHZhbHVlIDogXCJcIlxuICAgIH08L3NwYW4+IGA7XG4gICAgc3RyaW5nICs9IGA8ZGl2PiR7Y29sdW1uUHJvcGVydHl9ICR7Y29sdW1uVHlwZU9mfSAke2NvbHVtbkVsZW1lbnRWYWx1ZX0ke2NhdGVnb3JpZXNDb2x1bW59JHtjb2x1bW5Qcm9wZXJ0eTJ9JHtjb2x1bW5Qcm9wZXJ0eTN9PC9kaXY+YDtcbiAgfSk7XG4gIHJpZ2h0U2lkZS5pbm5lckhUTUwgPSBzdHJpbmc7XG59O1xub25QYXJhbWFDbGljayhcIkRydW1zXCIsIFwiZWFyc2hyZWRcIik7XG5cbm9uSW5zdHJ1bWVudFBhcmFtQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICBjb25zdCBwYXJhbWV0ZXIgPSBlLnRleHRDb250ZW50O1xuICBjb25zb2xlLmxvZyhcInBhcmFtZXRlcjogXCIsIHBhcmFtZXRlcik7XG4gIGNvbnN0IGFzZGFzZCA9IGFsbEluc3RydW1lbnRQYXJhbWV0ZXJzMltwYXJhbWV0ZXJdO1xuXG4gIGNvbnNvbGUubG9nKFwiYXNkYXNkOiBcIiwgYXNkYXNkKTtcbiAgcmlnaHRTaWRlMi5pbm5lckhUTUwgPSBBcnJheS5mcm9tKGFzZGFzZC5jYXRlZ29yaWVzKVxuICAgIC5tYXAoXG4gICAgICAoY2F0ZWdvcnkpID0+XG4gICAgICAgIGA8c3BhbiBzdHlsZT1cImJvcmRlcjoxcHggc29saWQgd2hpdGU7YmFja2dyb3VuZC1jb2xvcjoke2NvbG9yc1BlckNhdGVnb3J5W2NhdGVnb3J5XX1cIj4ke2NhdGVnb3J5fTwvc3Bhbj5gXG4gICAgKVxuICAgIC5qb2luKFwiXCIpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhbGxJbnN0cnVtZW50czIpIHtcbiAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYWxsSW5zdHJ1bWVudHMyLCBrZXkpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYWxsSW5zdHJ1bWVudHMyW2tleV07XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRcIik7XG4gICAgfVxuICB9XG4gIEFycmF5LmZyb20oYXNkYXNkLmtleXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwia2V5OiBcIiwga2V5KTtcbiAgICBjb25zdCBhc2Rhc2Rhc2N4eHh4ID0gYWxsSW5zdHJ1bWVudHMyW2tleV07XG4gICAgY29uc29sZS5sb2coXCJhc2Rhc2Rhc2N4eHh4OiBcIiwgYXNkYXNkYXNjeHh4eCk7XG4gICAgYXNkYXNkYXNjeHh4eC5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0XCIpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBvbmUoKSB7XG4gIGxldCBhYWFhYSA9IE9iamVjdC5rZXlzKGFsbEluc3RydW1lbnRzKTtcblxuICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgY29uc3QgcmFuZG9tSW5kZXggPSAoYWFhYWEubGVuZ3RoICogTWF0aC5yYW5kb20oKSkgfCAwO1xuICAgIGNvbnN0IHJhbmRvbUtleSA9IGFhYWFhLnNwbGljZShyYW5kb21JbmRleCwgMSk7XG4gICAgaWYgKGFhYWFhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWFhYWEgPSBPYmplY3Qua2V5cyhhbGxJbnN0cnVtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUVsZW1lbnQgPSBhbGxJbnN0cnVtZW50c1tyYW5kb21LZXldO1xuICAgIG9uUGFyYW1hQ2xpY2socmFuZG9tRWxlbWVudC5jYXRlZ29yeSwgcmFuZG9tRWxlbWVudC5pbnN0cnVtZW50KTtcbiAgfSwgMTAwKTtcbn1cblxuZnVuY3Rpb24gdHdvKCkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFsbEluc3RydW1lbnRzKTtcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHNldEludGVydmFsKCgpID0+IHtcbiAgICBpbmRleCsrO1xuICAgIGNvbnN0IG5leHRLZXkgPSBrZXlzW2luZGV4ICUgbGVuZ3RoXTtcbiAgICBjb25zdCBuZXh0RWxlbWVudCA9IGFsbEluc3RydW1lbnRzW25leHRLZXldO1xuICAgIG9uUGFyYW1hQ2xpY2sobmV4dEVsZW1lbnQuY2F0ZWdvcnksIG5leHRFbGVtZW50Lmluc3RydW1lbnQpO1xuICB9LCAxMDApO1xufVxuLy8gdHdvKCk7XG4vLyBvbmUoKTtcbmNvbnNvbGUubG9nKFwiY291bnRlcjI6IFwiLCBjb3VudGVyMik7XG5jb25zb2xlLmxvZyhPYmplY3Qua2V5cyhhbGxJbnN0cnVtZW50cykubGVuZ3RoKTtcbiJdfQ==