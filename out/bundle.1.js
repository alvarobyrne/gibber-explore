(function () {
  var socket = document.createElement('script')
  var script = document.createElement('script')
  socket.setAttribute('src', 'http://127.0.0.1:3001/socket.io/socket.io.js')
  script.type = 'text/javascript'

  socket.onload = function () {
    document.head.appendChild(script)
  }
  script.text = ['window.socket = io("http://127.0.0.1:3001");',
  'socket.on("bundle", function() {',
  'console.log("livereaload triggered")',
  'window.location.reload();});'].join('\n')
  document.head.appendChild(socket)
}());
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
function bjorklund(slots, pulses){
  var pattern = [],
      count = [],
      remainder = [pulses],
      divisor = slots - pulses,
      level = 0,
      build_pattern = function(lv){
        if( lv == -1 ){ pattern.push(0); }
        else if( lv == -2 ){ pattern.push(1); }
        else{
          for(var x=0; x<count[lv]; x++){
            build_pattern(lv-1);
          }

          if(remainder[lv]){
            build_pattern(lv-2);
          }
        }
      }
  ;

  while(remainder[level] > 1){
    count.push(Math.floor(divisor/remainder[level]));
    remainder.push(divisor%remainder[level]);
    divisor = remainder[level];
    level++;
  }
  count.push(divisor);

  build_pattern(level);

  return pattern.reverse();
}


module.exports = function(m, k){
  if(m > k) return bjorklund(m, k);
  else return bjorklund(k, m);
};

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":5,"get-intrinsic":90}],5:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":12,"get-intrinsic":90}],6:[function(require,module,exports){
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.chroma = factory());
})(this, (function () { 'use strict';

    var limit$2 = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var limit$1 = limit$2;

    var clip_rgb$3 = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit$1(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit$1(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type$p = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var type$o = type$p;

    var unpack$B = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type$o(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var type$n = type$p;

    var last$4 = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI$2 = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb$3,
    	limit: limit$2,
    	type: type$p,
    	unpack: unpack$B,
    	last: last$4,
    	PI: PI$2,
    	TWOPI: PI$2*2,
    	PITHIRD: PI$2/3,
    	DEG2RAD: PI$2 / 180,
    	RAD2DEG: 180 / PI$2
    };

    var input$h = {
    	format: {},
    	autodetect: []
    };

    var last$3 = utils.last;
    var clip_rgb$2 = utils.clip_rgb;
    var type$m = utils.type;
    var _input = input$h;

    var Color$D = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$m(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$3(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
                _input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (_input.format[mode]) {
            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$2(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color$D.prototype.toString = function toString () {
        if (type$m(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color$D;

    var chroma$k = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
    };

    chroma$k.Color = Color_1;
    chroma$k.version = '2.4.2';

    var chroma_1 = chroma$k;

    var unpack$A = utils.unpack;
    var max$2 = Math.max;

    var rgb2cmyk$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$A(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r,max$2(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk$1;

    var unpack$z = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$z(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils.unpack;
    var type$l = utils.type;

    var rgb2cmyk = rgb2cmyk_1;

    Color$C.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
    };

    chroma$j.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
    };

    input$g.format.cmyk = cmyk2rgb_1;

    input$g.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$y(args, 'cmyk');
            if (type$l(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$x = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$x(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css$1;

    var unpack$w = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$3 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$w(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl$3;

    var unpack$v = utils.unpack;
    var last$1 = utils.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$v(args, 'rgba');
        var mode = last$1(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css$1;

    var unpack$u = utils.unpack;
    var round$5 = Math.round;

    var hsl2rgb$1 = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$u(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb$1;

    var hsl2rgb = hsl2rgb_1;
    var input$f = input$h;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input$f.format.named) {
            try {
                return input$f.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb$1.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb$1;

    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils.type;

    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;

    Color$B.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma$i.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
    };

    input$e.format.css = css2rgb;

    input$e.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils.unpack;

    input$d.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$t(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma$h.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
    };

    Color$A.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$s = utils.unpack;

    var rgb2hcg$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$s(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg$1;

    var unpack$r = utils.unpack;
    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$r(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$q = utils.unpack;
    var type$j = utils.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;

    var rgb2hcg = rgb2hcg_1;

    Color$z.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
    };

    chroma$g.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
    };

    input$c.format.hcg = hcg2rgb_1;

    input$c.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$q(args, 'hcg');
            if (type$j(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$p = utils.unpack;
    var last = utils.last;
    var round$3 = Math.round;

    var rgb2hex$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$p(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex$2;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb$1;

    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils.type;
    var input$b = input$h;

    var rgb2hex$1 = rgb2hex_1;

    Color$y.prototype.hex = function(mode) {
        return rgb2hex$1(this._rgb, mode);
    };

    chroma$f.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
    };

    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
                return 'hex';
            }
        }
    });

    var unpack$o = utils.unpack;
    var TWOPI$2 = utils.TWOPI;
    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi$1;

    var unpack$n = utils.unpack;
    var limit = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$n(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit(i*r*3);
        g = limit(i*g*3);
        b = limit(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$m = utils.unpack;
    var type$h = utils.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;

    var rgb2hsi = rgb2hsi_1;

    Color$x.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
    };

    chroma$e.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
    };

    input$a.format.hsi = hsi2rgb_1;

    input$a.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'hsi');
            if (type$h(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$l = utils.unpack;
    var type$g = utils.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;

    var rgb2hsl$1 = rgb2hsl_1;

    Color$w.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
    };

    chroma$d.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
    };

    input$9.format.hsl = hsl2rgb_1;

    input$9.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$l(args, 'hsl');
            if (type$g(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$k = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$k(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv$1 = rgb2hsl;

    var unpack$j = utils.unpack;
    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$j(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$i = utils.unpack;
    var type$f = utils.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;

    var rgb2hsv = rgb2hsv$1;

    Color$v.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma$c.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
    };

    input$8.format.hsv = hsv2rgb_1;

    input$8.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$i(args, 'hsv');
            if (type$f(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils.unpack;
    var pow$a = Math.pow;

    var rgb2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$h(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$a((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab$2;

    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils.unpack;
    var pow$9 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$g(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
    };

    var lab2rgb_1 = lab2rgb$1;

    var unpack$f = utils.unpack;
    var type$e = utils.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;

    var rgb2lab$1 = rgb2lab_1;

    Color$u.prototype.lab = function() {
        return rgb2lab$1(this._rgb);
    };

    chroma$b.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
    };

    input$7.format.lab = lab2rgb_1;

    input$7.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'lab');
            if (type$e(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$e = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$e(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch$2;

    var unpack$d = utils.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;

    var rgb2lch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch$1;

    var unpack$c = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$c(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c]
    };

    var lch2lab_1 = lch2lab$2;

    var unpack$b = utils.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;

    var lch2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$b(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab$1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb$1;

    var unpack$a = utils.unpack;
    var lch2rgb = lch2rgb_1;

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$a(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$9 = utils.unpack;
    var type$d = utils.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;

    var rgb2lch = rgb2lch_1;

    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

    chroma$a.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
    };
    chroma$a.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
    };

    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$9(args, m);
            if (type$d(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11$1 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11$1;

    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils.type;

    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;

    Color$s.prototype.name = function() {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input$5.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: '+name);
    };

    input$5.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$8 = utils.unpack;

    var rgb2num$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$8(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num$1;

    var type$b = utils.type;

    var num2rgb = function (num) {
        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils.type;

    var rgb2num = rgb2num_1;

    Color$r.prototype.num = function() {
        return rgb2num(this._rgb);
    };

    chroma$9.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
    };

    input$4.format.num = num2rgb_1;

    input$4.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils.unpack;
    var type$9 = utils.type;
    var round$1 = Math.round;

    Color$q.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$1);
    };

    Color$q.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma$8.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
    };

    input$3.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$7(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input$3.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$7(args, 'rgba');
            if (type$9(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb$1;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils.unpack;
    var round = Math.round;

    var rgb2temperature$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$6(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    var rgb2temperature_1 = rgb2temperature$1;

    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;

    var rgb2temperature = rgb2temperature_1;

    Color$p.prototype.temp =
    Color$p.prototype.kelvin =
    Color$p.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
    };

    chroma$7.temp =
    chroma$7.kelvin =
    chroma$7.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
    };

    input$2.format.temp =
    input$2.format.kelvin =
    input$2.format.temperature = temperature2rgb_1;

    var unpack$5 = utils.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    var rgb2oklab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack$5(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    var rgb2oklab_1 = rgb2oklab$2;

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
    }

    var unpack$4 = utils.unpack;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$4(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    var oklab2rgb_1 = oklab2rgb$1;

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var unpack$3 = utils.unpack;
    var type$8 = utils.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;

    var rgb2oklab$1 = rgb2oklab_1;

    Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
    };

    chroma$6.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
    };

    input$1.format.oklab = oklab2rgb_1;

    input$1.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'oklab');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var unpack$2 = utils.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;

    var rgb2oklch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$2(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    var rgb2oklch_1 = rgb2oklch$1;

    var unpack$1 = utils.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$1(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var oklch2rgb_1 = oklch2rgb;

    var unpack = utils.unpack;
    var type$7 = utils.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;

    var rgb2oklch = rgb2oklch_1;

    Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma$5.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb_1;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    var Color$m = Color_1;
    var type$6 = utils.type;

    Color$m.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$6(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    var Color$l = Color_1;

    Color$l.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;

    Color$k.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
    };

    Color$k.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;

    var Color$j = Color_1;

    Color$j.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$i = Color_1;
    var type$5 = utils.type;
    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color$i.prototype.luminance = function(lum) {
        if (lum !== undefined && type$5(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
            return new Color$i(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
    };

    var interpolator$1 = {};

    var Color$h = Color_1;
    var type$4 = utils.type;
    var interpolator = interpolator$1;

    var mix$1 = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    var Color$g = Color_1;
    var mix = mix$1;

    Color$g.prototype.mix =
    Color$g.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    var Color$f = Color_1;

    Color$f.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;

    Color$e.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += LAB_CONSTANTS.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
    };

    Color$e.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var Color$d = Color_1;
    var type$3 = utils.type;

    Color$d.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type$3(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type$3(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color$d(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$c = Color_1;

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.rgb = rgb;

    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.lrgb = lrgb;

    var Color$a = Color_1;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator$1.lab = lab;

    var Color$9 = Color_1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
    };

    var interpolate_hsx$5 = _hsx;

    var lch = function (col1, col2, f) {
    	return interpolate_hsx$5(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;

    var Color$8 = Color_1;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color$8(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator$1.num = num;

    var interpolate_hsx$4 = _hsx;

    var hcg = function (col1, col2, f) {
    	return interpolate_hsx$4(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator$1.hcg = hcg;

    var interpolate_hsx$3 = _hsx;

    var hsi = function (col1, col2, f) {
    	return interpolate_hsx$3(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator$1.hsi = hsi;

    var interpolate_hsx$2 = _hsx;

    var hsl = function (col1, col2, f) {
    	return interpolate_hsx$2(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator$1.hsl = hsl;

    var interpolate_hsx$1 = _hsx;

    var hsv = function (col1, col2, f) {
    	return interpolate_hsx$1(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator$1.hsv = hsv;

    var Color$7 = Color_1;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    interpolator$1.oklab = oklab;

    var interpolate_hsx = _hsx;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    interpolator$1.oklch = oklch;

    var Color$6 = Color_1;
    var clip_rgb$1 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode, weights) {
        if ( mode === void 0 ) mode='lrgb';
        if ( weights === void 0 ) weights=null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k = l / weights.reduce(function(a, b) { return a + b; });
        weights.forEach(function (w,i) { weights[i] *= k; });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color$6(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c,ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci+1];
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci+1];
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A) * weights[ci+1];
                        dy += sin$2(A) * weights[ci+1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci+1];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0,0,0,0];
        for (var i=0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color$6(clip_rgb$1(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze

    var chroma$4 = chroma_1;
    var type$2 = utils.type;

    var pow$3 = Math.pow;

    var scale$2 = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma$4('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
                chroma$4.brewer[colors.toLowerCase()]) {
                colors = chroma$4.brewer[colors.toLowerCase()];
            }
            if (type$2(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma$4(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$3(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$2(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$2(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$2(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma$4.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma$4.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i+1]) { i++; }
                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
                            return out;
                        };
                    }

                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$2(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma$4[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma$4(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab
    var Color$5 = Color_1;

    var scale$1 = scale$2;

    // nth row of the pascal triangle
    var binom_row = function(n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color$5(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
                return new Color$5(lab, 'lab');
            };
        } else {
            throw new RangeError("No point in running bezier with only one color.")
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale$1(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */

    var chroma$3 = chroma_1;

    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$1 = utils.type;
    var clip_rgb = utils.clip_rgb;
    var TWOPI = utils.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;

    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$1(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI * (((start+120)/360) + (rotations * fract));
            var l = pow$2(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$1(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$1(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma$2.scale(f); };

        f.hue(hue);

        return f;
    };

    var Color$4 = Color_1;
    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, 'hex');
    };

    var type = type$p;
    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs$1(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var Color$3 = Color_1;


    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color$3(a);
        b = new Color$3(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var Color$2 = Color_1;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    var deltaE = function(a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl=1;
        if ( Kc === void 0 ) Kc=1;
        if ( Kh === void 0 ) Kh=1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color$2(a);
        b = new Color$2(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2)/2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2)/2;
        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
        var a1p = a1*(1+G);
        var a2p = a2*(1+G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p)/2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;    
        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045*avgCp;
        var sh = 1 + 0.015*avgCp*T;
        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
        return max(0, min(100, result));
    };

    var Color$1 = Color_1;

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color$1(a);
        b = new Color$1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var Color = Color_1;

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:
    var chroma$1 = chroma_1;

    var scale = scale$2;

    var scales = {
    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    var chroma = chroma_1;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors

















    // operators --> modify existing Colors










    // interpolators












    // generators -- > create new colors
    chroma.average = average;
    chroma.bezier = bezier_1;
    chroma.blend = blend_1;
    chroma.cubehelix = cubehelix;
    chroma.mix = chroma.interpolate = mix$1;
    chroma.random = random_1;
    chroma.scale = scale$2;

    // other utility methods
    chroma.analyze = analyze_1.analyze;
    chroma.contrast = contrast;
    chroma.deltaE = deltaE;
    chroma.distance = distance;
    chroma.limits = analyze_1.limits;
    chroma.valid = valid;

    // scale
    chroma.scales = scales;

    // colors
    chroma.colors = w3cx11_1;
    chroma.brewer = colorbrewer_1;

    var chroma_js = chroma;

    return chroma_js;

}));

},{}],7:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":90}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],9:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],10:[function(require,module,exports){
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = {
    "s": 1,
    "n": 0,
    "d": 1
  };

  function assign(n, s) {

    if (isNaN(n = parseInt(n, 10))) {
      throw Fraction['InvalidParameter'];
    }
    return n * s;
  }

  // Creates a new Fraction internally without the need of the bulky constructor
  function newFraction(n, d) {

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    var f = Object.create(Fraction.prototype);
    f["s"] = n < 0 ? -1 : 1;

    n = n < 0 ? -n : n;

    var a = gcd(n, d);

    f["n"] = n / a;
    f["d"] = d / a;
    return f;
  }

  function factorize(num) {

    var factors = {};

    var n = num;
    var i = 2;
    var s = 4;

    while (s <= n) {

      while (n % i === 0) {
        n/= i;
        factors[i] = (factors[i] || 0) + 1;
      }
      s+= 1 + 2 * i++;
    }

    if (n !== num) {
      if (n > 1)
        factors[n] = (factors[n] || 0) + 1;
    } else {
      factors[num] = (factors[num] || 0) + 1;
    }
    return factors;
  }

  var parse = function(p1, p2) {

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = p1;
      d = p2;
      s = n * d;

      if (n % 1 !== 0 || d % 1 !== 0) {
        throw Fraction['NonIntegerParameter'];
      }

    } else
      switch (typeof p1) {

        case "object":
          {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n*= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw Fraction['InvalidParameter'];
            }
            s = n * d;
            break;
          }
        case "number":
          {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }

            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1/= z;
              }

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) {
                M = (A + C) / (B + D);

                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;

                } else {

                  if (p1 > M) {
                    A+= C;
                    B+= D;
                  } else {
                    C+= A;
                    D+= B;
                  }

                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n*= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
        case "string":
          {
            B = p1.match(/\d+|./g);

            if (B === null)
              throw Fraction['InvalidParameter'];

            if (B[A] === '-') {// Check for minus sign at the beginning
              s = -1;
              A++;
            } else if (B[A] === '+') {// Check for plus sign at the beginning
              A++;
            }

            if (B.length === A + 1) { // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

              if (B[A] !== '.') { // Handle 0.5 and .5
                v = assign(B[A++], s);
              }
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A+= 3;
              }

            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A+= 3;
            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A+= 5;
            }

            if (B.length <= A) { // Check for more tokens on the stack
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
            }

            /* Fall through on error */
          }
        default:
          throw Fraction['InvalidParameter'];
      }

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
  };

  function modpow(b, e, m) {

    var r = 1;
    for (; e > 0; b = (b * b) % m, e >>= 1) {

      if (e & 1) {
        r = (r * b) % m;
      }
    }
    return r;
  }


  function cycleLen(n, d) {

    for (; d % 2 === 0;
      d/= 2) {
    }

    for (; d % 5 === 0;
      d/= 5) {
    }

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    var rem = 10 % d;
    var t = 1;

    for (; rem !== 1; t++) {
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
    }
    return t;
  }


  function cycleStart(n, d, len) {

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
    }
    return 0;
  }

  function gcd(a, b) {

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) {
      a%= b;
      if (!a)
        return b;
      b%= a;
      if (!b)
        return a;
    }
  };

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    parse(a, b);

    if (this instanceof Fraction) {
      a = gcd(P["d"], P["n"]); // Abuse variable a
      this["s"] = P["s"];
      this["n"] = P["n"] / a;
      this["d"] = P["d"] / a;
    } else {
      return newFraction(P['s'] * P['n'], P['d']);
    }
  }

  Fraction['DivisionByZero'] = new Error("Division by Zero");
  Fraction['InvalidParameter'] = new Error("Invalid argument");
  Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");

  Fraction.prototype = {

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() {

      return newFraction(this["n"], this["d"]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() {

      return newFraction(-this["s"] * this["n"], this["d"]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/
    "add": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["d"],
        this["d"] * P["n"]
      );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() {
      return newFraction(this['s'] * this['n'], this['d']);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return new Fraction(NaN);
      }

      if (a === undefined) {
        return newFraction(this["s"] * this["n"] % this["d"], 1);
      }

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) {
        throw Fraction['DivisionByZero'];
      }

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return newFraction(
        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
        P["d"] * this["d"]
      );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) {
        return newFraction(0, 1);
      }
      return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() {

      return newFraction(this["s"] * this["d"], this["n"]);
    },

    /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(a, b) {

      parse(a, b);

      // Trivial case when exp is an integer

      if (P['d'] === 1) {

        if (P['s'] < 0) {
          return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
        } else {
          return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
        }
      }

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
      if (this['s'] < 0) return null;

      // Now prime factor n and d
      var N = factorize(this['n']);
      var D = factorize(this['d']);

      // Exponentiate and take root for n and d individually
      var n = 1;
      var d = 1;
      for (var k in N) {
        if (k === '1') continue;
        if (k === '0') {
          n = 0;
          break;
        }
        N[k]*= P['n'];

        if (N[k] % P['d'] === 0) {
          N[k]/= P['d'];
        } else return null;
        n*= Math.pow(k, N[k]);
      }

      for (var k in D) {
        if (k === '1') continue;
        D[k]*= P['n'];

        if (D[k] % P['d'] === 0) {
          D[k]/= P['d'];
        } else return null;
        d*= Math.pow(k, D[k]);
      }

      if (P['s'] < 0) {
        return newFraction(d, n);
      }
      return newFraction(n, d);
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) {

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) {

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
    },

    "simplify": function(eps) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return this;
      }

      eps = eps || 0.001;

      var thisABS = this['abs']();
      var cont = thisABS['toContinued']();

      for (var i = 1; i < cont.length; i++) {

        var s = newFraction(cont[i - 1], 1);
        for (var k = i - 2; k >= 0; k--) {
          s = s['inverse']()['add'](cont[k]);
        }

        if (s['sub'](thisABS)['abs']().valueOf() < eps) {
          return s['mul'](this['s']);
        }
      }
      return this;
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) {

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() {

      return this["s"] * this["n"] / this["d"];
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/
    'toFraction': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          str+= " ";
          n%= d;
        }

        str+= n;
        str+= '/';
        str+= d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/
    'toLatex': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          n%= d;
        }

        str+= "\\frac{";
        str+= n;
        str+= '}{';
        str+= d;
        str+= '}';
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() {

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      if (isNaN(a) || isNaN(b)) {
        return res;
      }

      do {
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
      } while (a !== 1);

      return res;
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function(dec) {

      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) {
        return "NaN";
      }

      dec = dec || 15; // 15 = decimal places when no repetation

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var str = this['s'] < 0 ? "-" : "";

      str+= N / D | 0;

      N%= D;
      N*= 10;

      if (N)
        str+= ".";

      if (cycLen) {

        for (var i = cycOff; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= "(";
        for (var i = cycLen; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= ")";
      } else {
        for (var i = dec; N && i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
      }
      return str;
    }
  };

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Fraction;
    });
  } else if (typeof exports === "object") {
    Object.defineProperty(Fraction, "__esModule", { 'value': true });
    Fraction['default'] = Fraction;
    Fraction['Fraction'] = Fraction;
    module['exports'] = Fraction;
  } else {
    root['Fraction'] = Fraction;
  }

})(this);

},{}],11:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],12:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":11}],13:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'abs',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.abs' : Math.abs })

      out = `${ref}abs( ${inputs[0]} )`

    } else {
      out = Math.abs( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let abs = Object.create( proto )

  abs.inputs = [ x ]

  return abs
}

},{"./gen.js":44}],14:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'accum',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        genName = 'gen.' + this.name,
        functionBody

    gen.requestMemory( this.memory )

    gen.memory.heap[ this.memory.value.idx ] = this.initialValue

    functionBody = this.callback( genName, inputs[0], inputs[1], `memory[${this.memory.value.idx}]` )

    //gen.closures.add({ [ this.name ]: this }) 

    gen.memo[ this.name ] = this.name + '_value'
    
    return [ this.name + '_value', functionBody ]
  },

  callback( _name, _incr, _reset, valueRef ) {
    let diff = this.max - this.min,
        out = '',
        wrap = ''
    
    /* three different methods of wrapping, third is most expensive:
     *
     * 1: range {0,1}: y = x - (x | 0)
     * 2: log2(this.max) == integer: y = x & (this.max - 1)
     * 3: all others: if( x >= this.max ) y = this.max -x
     *
     */

    // must check for reset before storing value for output
    if( !(typeof this.inputs[1] === 'number' && this.inputs[1] < 1) ) { 
      if( this.resetValue !== this.min ) {

        out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.resetValue}\n\n`
        //out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.min}\n\n`
      }else{
        out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.min}\n\n`
        //out += `  if( ${_reset} >=1 ) ${valueRef} = ${this.initialValue}\n\n`
      }
    }

    out += `  var ${this.name}_value = ${valueRef}\n`
    
    if( this.shouldWrap === false && this.shouldClamp === true ) {
      out += `  if( ${valueRef} < ${this.max } ) ${valueRef} += ${_incr}\n`
    }else{
      out += `  ${valueRef} += ${_incr}\n` // store output value before accumulating  
    }

    if( this.max !== Infinity  && this.shouldWrapMax ) wrap += `  if( ${valueRef} >= ${this.max} ) ${valueRef} -= ${diff}\n`
    if( this.min !== -Infinity && this.shouldWrapMin ) wrap += `  if( ${valueRef} < ${this.min} ) ${valueRef} += ${diff}\n`

    //if( this.min === 0 && this.max === 1 ) { 
    //  wrap =  `  ${valueRef} = ${valueRef} - (${valueRef} | 0)\n\n`
    //} else if( this.min === 0 && ( Math.log2( this.max ) | 0 ) === Math.log2( this.max ) ) {
    //  wrap =  `  ${valueRef} = ${valueRef} & (${this.max} - 1)\n\n`
    //} else if( this.max !== Infinity ){
    //  wrap = `  if( ${valueRef} >= ${this.max} ) ${valueRef} -= ${diff}\n\n`
    //}

    out = out + wrap + '\n'

    return out
  },

  defaults : { min:0, max:1, resetValue:0, initialValue:0, shouldWrap:true, shouldWrapMax: true, shouldWrapMin:true, shouldClamp:false }
}

module.exports = ( incr, reset=0, properties ) => {
  const ugen = Object.create( proto )
      
  Object.assign( ugen, 
    { 
      uid:    gen.getUID(),
      inputs: [ incr, reset ],
      memory: {
        value: { length:1, idx:null }
      }
    },
    proto.defaults,
    properties 
  )

  if( properties !== undefined && properties.shouldWrapMax === undefined && properties.shouldWrapMin === undefined ) {
    if( properties.shouldWrap !== undefined ) {
      ugen.shouldWrapMin = ugen.shouldWrapMax = properties.shouldWrap
    }
  }

  if( properties !== undefined && properties.resetValue === undefined ) {
    ugen.resetValue = ugen.min
  }

  if( ugen.initialValue === undefined ) ugen.initialValue = ugen.min

  Object.defineProperty( ugen, 'value', {
    get()  { 
      //console.log( 'gen:', gen, gen.memory )
      return gen.memory.heap[ this.memory.value.idx ] 
    },
    set(v) { gen.memory.heap[ this.memory.value.idx ] = v }
  })

  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],15:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'acos',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'acos': isWorklet ? 'Math.acos' :Math.acos })

      out = `${ref}acos( ${inputs[0]} )` 

    } else {
      out = Math.acos( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let acos = Object.create( proto )

  acos.inputs = [ x ]
  acos.id = gen.getUID()
  acos.name = `${acos.basename}{acos.id}`

  return acos
}

},{"./gen.js":44}],16:[function(require,module,exports){
'use strict'

let gen      = require( './gen.js' ),
    mul      = require( './mul.js' ),
    sub      = require( './sub.js' ),
    div      = require( './div.js' ),
    data     = require( './data.js' ),
    peek     = require( './peek.js' ),
    accum    = require( './accum.js' ),
    ifelse   = require( './ifelseif.js' ),
    lt       = require( './lt.js' ),
    bang     = require( './bang.js' ),
    env      = require( './env.js' ),
    add      = require( './add.js' ),
    poke     = require( './poke.js' ),
    neq      = require( './neq.js' ),
    and      = require( './and.js' ),
    gte      = require( './gte.js' ),
    memo     = require( './memo.js' ),
    utilities= require( './utilities.js' )

module.exports = ( attackTime = 44100, decayTime = 44100, _props ) => {
  const props = Object.assign({}, { shape:'exponential', alpha:5, trigger:null }, _props )
  const _bang = props.trigger !== null ? props.trigger : bang(),
        phase = accum( 1, _bang, { min:0, max: Infinity, initialValue:-Infinity, shouldWrap:false })
      
  let bufferData, bufferDataReverse, decayData, out, buffer

  //console.log( 'shape:', props.shape, 'attack time:', attackTime, 'decay time:', decayTime )
  let completeFlag = data( [0] )
  
  // slightly more efficient to use existing phase accumulator for linear envelopes
  if( props.shape === 'linear' ) {
    out = ifelse( 
      and( gte( phase, 0), lt( phase, attackTime )),
      div( phase, attackTime ),

      and( gte( phase, 0),  lt( phase, add( attackTime, decayTime ) ) ),
      sub( 1, div( sub( phase, attackTime ), decayTime ) ),
      
      neq( phase, -Infinity),
      poke( completeFlag, 1, 0, { inline:0 }),

      0 
    )
  } else {
    bufferData = env({ length:1024, type:props.shape, alpha:props.alpha })
    bufferDataReverse = env({ length:1024, type:props.shape, alpha:props.alpha, reverse:true })

    out = ifelse( 
      and( gte( phase, 0), lt( phase, attackTime ) ), 
      peek( bufferData, div( phase, attackTime ), { boundmode:'clamp' } ), 

      and( gte(phase,0), lt( phase, add( attackTime, decayTime ) ) ), 
      peek( bufferDataReverse, div( sub( phase, attackTime ), decayTime ), { boundmode:'clamp' }),

      neq( phase, -Infinity ),
      poke( completeFlag, 1, 0, { inline:0 }),

      0
    )
  }

  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    out.node = null
    utilities.register( out )
  }

  // needed for gibberish... getting this to work right with worklets
  // via promises will probably be tricky
  out.isComplete = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      const p = new Promise( resolve => {
        out.node.getMemoryValue( completeFlag.memory.values.idx, resolve )
      })

      return p
    }else{
      return gen.memory.heap[ completeFlag.memory.values.idx ]
    }
  }

  out.trigger = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      out.node.port.postMessage({ key:'set', idx:completeFlag.memory.values.idx, value:0 })
    }else{
      gen.memory.heap[ completeFlag.memory.values.idx ] = 0
    }
    _bang.trigger()
  }

  return out 
}

},{"./accum.js":14,"./add.js":17,"./and.js":19,"./bang.js":23,"./data.js":30,"./div.js":35,"./env.js":36,"./gen.js":44,"./gte.js":46,"./ifelseif.js":49,"./lt.js":52,"./memo.js":56,"./mul.js":62,"./neq.js":63,"./peek.js":68,"./poke.js":70,"./sub.js":81,"./utilities.js":87}],17:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = { 
  basename:'add',
  gen() {
    let inputs = gen.getInputs( this ),
        out='',
        sum = 0, numCount = 0, adderAtEnd = false, alreadyFullSummed = true

    if( inputs.length === 0 ) return 0

    out = `  var ${this.name} = `

    inputs.forEach( (v,i) => {
      if( isNaN( v ) ) {
        out += v
        if( i < inputs.length -1 ) {
          adderAtEnd = true
          out += ' + '
        }
        alreadyFullSummed = false
      }else{
        sum += parseFloat( v )
        numCount++
      }
    })

    if( numCount > 0 ) {
      out += adderAtEnd || alreadyFullSummed ? sum : ' + ' + sum
    }

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = ( ...args ) => {
  const add = Object.create( proto )
  add.id = gen.getUID()
  add.name = add.basename + add.id
  add.inputs = args

  return add
}

},{"./gen.js":44}],18:[function(require,module,exports){
'use strict'

let gen      = require( './gen.js' ),
    mul      = require( './mul.js' ),
    sub      = require( './sub.js' ),
    div      = require( './div.js' ),
    data     = require( './data.js' ),
    peek     = require( './peek.js' ),
    accum    = require( './accum.js' ),
    ifelse   = require( './ifelseif.js' ),
    lt       = require( './lt.js' ),
    bang     = require( './bang.js' ),
    env      = require( './env.js' ),
    param    = require( './param.js' ),
    add      = require( './add.js' ),
    gtp      = require( './gtp.js' ),
    not      = require( './not.js' ),
    and      = require( './and.js' ),
    neq      = require( './neq.js' ),
    poke     = require( './poke.js' )

module.exports = ( attackTime=44, decayTime=22050, sustainTime=44100, sustainLevel=.6, releaseTime=44100, _props ) => {
  let envTrigger = bang(),
      phase = accum( 1, envTrigger, { max: Infinity, shouldWrap:false, initialValue:Infinity }),
      shouldSustain = param( 1 ),
      defaults = {
         shape: 'exponential',
         alpha: 5,
         triggerRelease: false,
      },
      props = Object.assign({}, defaults, _props ),
      bufferData, decayData, out, buffer, sustainCondition, releaseAccum, releaseCondition


  const completeFlag = data( [0] )

  bufferData = env({ length:1024, alpha:props.alpha, shift:0, type:props.shape })

  sustainCondition = props.triggerRelease 
    ? shouldSustain
    : lt( phase, add( attackTime, decayTime, sustainTime ) )

  releaseAccum = props.triggerRelease
    ? gtp( sub( sustainLevel, accum( div( sustainLevel, releaseTime ) , 0, { shouldWrap:false }) ), 0 )
    : sub( sustainLevel, mul( div( sub( phase, add( attackTime, decayTime, sustainTime ) ), releaseTime ), sustainLevel ) ), 

  releaseCondition = props.triggerRelease
    ? not( shouldSustain )
    : lt( phase, add( attackTime, decayTime, sustainTime, releaseTime ) )

  out = ifelse(
    // attack 
    lt( phase,  attackTime ), 
    peek( bufferData, div( phase, attackTime ), { boundmode:'clamp' } ), 

    // decay
    lt( phase, add( attackTime, decayTime ) ), 
    peek( bufferData, sub( 1, mul( div( sub( phase,  attackTime ),  decayTime ), sub( 1,  sustainLevel ) ) ), { boundmode:'clamp' }),

    // sustain
    and( sustainCondition, neq( phase, Infinity ) ),
    peek( bufferData,  sustainLevel ),

    // release
    releaseCondition, //lt( phase,  attackTime +  decayTime +  sustainTime +  releaseTime ),
    peek( 
      bufferData,
      releaseAccum, 
      //sub(  sustainLevel, mul( div( sub( phase,  attackTime +  decayTime +  sustainTime),  releaseTime ),  sustainLevel ) ), 
      { boundmode:'clamp' }
    ),

    neq( phase, Infinity ),
    poke( completeFlag, 1, 0, { inline:0 }),

    0
  )
   
  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    out.node = null
    utilities.register( out )
  }

  out.trigger = ()=> {
    shouldSustain.value = 1
    envTrigger.trigger()
  }
 
  // needed for gibberish... getting this to work right with worklets
  // via promises will probably be tricky
  out.isComplete = ()=> {
    if( usingWorklet === true && out.node !== null ) {
      const p = new Promise( resolve => {
        out.node.getMemoryValue( completeFlag.memory.values.idx, resolve )
      })

      return p
    }else{
      return gen.memory.heap[ completeFlag.memory.values.idx ]
    }
  }


  out.release = ()=> {
    shouldSustain.value = 0
    // XXX pretty nasty... grabs accum inside of gtp and resets value manually
    // unfortunately envTrigger won't work as it's back to 0 by the time the release block is triggered...
    if( usingWorklet && out.node !== null ) {
      out.node.port.postMessage({ key:'set', idx:releaseAccum.inputs[0].inputs[1].memory.value.idx, value:0 })
    }else{
      gen.memory.heap[ releaseAccum.inputs[0].inputs[1].memory.value.idx ] = 0
    }
  }

  return out 
}

},{"./accum.js":14,"./add.js":17,"./and.js":19,"./bang.js":23,"./data.js":30,"./div.js":35,"./env.js":36,"./gen.js":44,"./gtp.js":47,"./ifelseif.js":49,"./lt.js":52,"./mul.js":62,"./neq.js":63,"./not.js":65,"./param.js":67,"./peek.js":68,"./poke.js":70,"./sub.js":81}],19:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'and',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = `  var ${this.name} = (${inputs[0]} !== 0 && ${inputs[1]} !== 0) | 0\n\n`

    gen.memo[ this.name ] = `${this.name}`

    return [ `${this.name}`, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],20:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'asin',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'asin': isWorklet ? 'Math.sin' : Math.asin })

      out = `${ref}asin( ${inputs[0]} )` 

    } else {
      out = Math.asin( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let asin = Object.create( proto )

  asin.inputs = [ x ]
  asin.id = gen.getUID()
  asin.name = `${asin.basename}{asin.id}`

  return asin
}

},{"./gen.js":44}],21:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'atan',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'atan': isWorklet ? 'Math.atan' : Math.atan })

      out = `${ref}atan( ${inputs[0]} )` 

    } else {
      out = Math.atan( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let atan = Object.create( proto )

  atan.inputs = [ x ]
  atan.id = gen.getUID()
  atan.name = `${atan.basename}{atan.id}`

  return atan
}

},{"./gen.js":44}],22:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    mul     = require( './mul.js' ),
    sub     = require( './sub.js' )

module.exports = ( decayTime = 44100 ) => {
  let ssd = history ( 1 ),
      t60 = Math.exp( -6.907755278921 / decayTime )

  ssd.in( mul( ssd.out, t60 ) )

  ssd.out.trigger = ()=> {
    ssd.value = 1
  }

  return sub( 1, ssd.out )
}

},{"./gen.js":44,"./history.js":48,"./mul.js":62,"./sub.js":81}],23:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  gen() {
    gen.requestMemory( this.memory )
    
    let out = 
`  var ${this.name} = memory[${this.memory.value.idx}]
  if( ${this.name} === 1 ) memory[${this.memory.value.idx}] = 0      
      
`
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  } 
}

module.exports = ( _props ) => {
  let ugen = Object.create( proto ),
      props = Object.assign({}, { min:0, max:1 }, _props )

  ugen.name = 'bang' + gen.getUID()

  ugen.min = props.min
  ugen.max = props.max

  const usingWorklet = gen.mode === 'worklet'
  if( usingWorklet === true ) {
    ugen.node = null
    utilities.register( ugen )
  }

  ugen.trigger = () => {
    if( usingWorklet === true && ugen.node !== null ) {
      ugen.node.port.postMessage({ key:'set', idx:ugen.memory.value.idx, value:ugen.max })
    }else{
      gen.memory.heap[ ugen.memory.value.idx ] = ugen.max 
    }
  }

  ugen.memory = {
    value: { length:1, idx:null }
  }

  return ugen
}

},{"./gen.js":44}],24:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'bool',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = `${inputs[0]} === 0 ? 0 : 1`
    
    //gen.memo[ this.name ] = `gen.data.${this.name}`

    //return [ `gen.data.${this.name}`, ' ' +out ]
    return out
  }
}

module.exports = ( in1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    uid:        gen.getUID(),
    inputs:     [ in1 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}


},{"./gen.js":44}],25:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'ceil',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.ceil' : Math.ceil })

      out = `${ref}ceil( ${inputs[0]} )`

    } else {
      out = Math.ceil( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let ceil = Object.create( proto )

  ceil.inputs = [ x ]

  return ceil
}

},{"./gen.js":44}],26:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    floor= require('./floor.js'),
    sub  = require('./sub.js'),
    memo = require('./memo.js')

let proto = {
  basename:'clip',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        out

    out =

` var ${this.name} = ${inputs[0]}
  if( ${this.name} > ${inputs[2]} ) ${this.name} = ${inputs[2]}
  else if( ${this.name} < ${inputs[1]} ) ${this.name} = ${inputs[1]}
`
    out = ' ' + out
    
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  },
}

module.exports = ( in1, min=-1, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1, min, max ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./floor.js":41,"./gen.js":44,"./memo.js":56,"./sub.js":81}],27:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'cos',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'

    const ref = isWorklet ? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'cos': isWorklet ? 'Math.cos' : Math.cos })

      out = `${ref}cos( ${inputs[0]} )` 

    } else {
      out = Math.cos( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let cos = Object.create( proto )

  cos.inputs = [ x ]
  cos.id = gen.getUID()
  cos.name = `${cos.basename}{cos.id}`

  return cos
}

},{"./gen.js":44}],28:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'counter',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        genName = 'gen.' + this.name,
        functionBody
       
    if( this.memory.value.idx === null ) gen.requestMemory( this.memory )
    gen.memory.heap[ this.memory.value.idx ] = this.initialValue
    
    functionBody  = this.callback( genName, inputs[0], inputs[1], inputs[2], inputs[3], inputs[4],  `memory[${this.memory.value.idx}]`, `memory[${this.memory.wrap.idx}]`  )

    gen.memo[ this.name ] = this.name + '_value'
   
    if( gen.memo[ this.wrap.name ] === undefined ) this.wrap.gen()

    return [ this.name + '_value', functionBody ]
  },

  callback( _name, _incr, _min, _max, _reset, loops, valueRef, wrapRef ) {
    let diff = this.max - this.min,
        out = '',
        wrap = ''
    // must check for reset before storing value for output
    if( !(typeof this.inputs[3] === 'number' && this.inputs[3] < 1) ) { 
      out += `  if( ${_reset} >= 1 ) ${valueRef} = ${_min}\n`
    }

    out += `  var ${this.name}_value = ${valueRef};\n  ${valueRef} += ${_incr}\n` // store output value before accumulating  
    
    if( typeof this.max === 'number' && this.max !== Infinity && typeof this.min !== 'number' ) {
      wrap = 
`  if( ${valueRef} >= ${this.max} &&  ${loops} > 0) {
    ${valueRef} -= ${diff}
    ${wrapRef} = 1
  }else{
    ${wrapRef} = 0
  }\n`
    }else if( this.max !== Infinity && this.min !== Infinity ) {
      wrap = 
`  if( ${valueRef} >= ${_max} &&  ${loops} > 0) {
    ${valueRef} -= ${_max} - ${_min}
    ${wrapRef} = 1
  }else if( ${valueRef} < ${_min} &&  ${loops} > 0) {
    ${valueRef} += ${_max} - ${_min}
    ${wrapRef} = 1
  }else{
    ${wrapRef} = 0
  }\n`
    }else{
      out += '\n'
    }

    out = out + wrap

    return out
  }
}

module.exports = ( incr=1, min=0, max=Infinity, reset=0, loops=1,  properties ) => {
  let ugen = Object.create( proto ),
      defaults = Object.assign( { initialValue: 0, shouldWrap:true }, properties )

  Object.assign( ugen, { 
    min:    min, 
    max:    max,
    initialValue: defaults.initialValue,
    value:  defaults.initialValue,
    uid:    gen.getUID(),
    inputs: [ incr, min, max, reset, loops ],
    memory: {
      value: { length:1, idx: null },
      wrap:  { length:1, idx: null } 
    },
    wrap : {
      gen() { 
        if( ugen.memory.wrap.idx === null ) {
          gen.requestMemory( ugen.memory )
        }
        gen.getInputs( this )
        gen.memo[ this.name ] = `memory[ ${ugen.memory.wrap.idx} ]`
        return `memory[ ${ugen.memory.wrap.idx} ]` 
      }
    }
  },
  defaults )
 
  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        gen.memory.heap[ this.memory.value.idx ] = v 
      }
    }
  })
  
  ugen.wrap.inputs = [ ugen ]
  ugen.name = `${ugen.basename}${ugen.uid}`
  ugen.wrap.name = ugen.name + '_wrap'
  return ugen
} 

},{"./gen.js":44}],29:[function(require,module,exports){
'use strict'

let gen  = require( './gen.js' ),
    accum= require( './phasor.js' ),
    data = require( './data.js' ),
    peek = require( './peek.js' ),
    mul  = require( './mul.js' ),
    phasor=require( './phasor.js')

let proto = {
  basename:'cycle',

  initTable() {    
    let buffer = new Float32Array( 1024 )

    for( let i = 0, l = buffer.length; i < l; i++ ) {
      buffer[ i ] = Math.sin( ( i / l ) * ( Math.PI * 2 ) )
    }

    gen.globals.cycle = data( buffer, 1, { immutable:true } )
  }

}

module.exports = ( frequency=1, reset=0, _props ) => {
  if( typeof gen.globals.cycle === 'undefined' ) proto.initTable() 
  const props = Object.assign({}, { min:0 }, _props )

  const ugen = peek( gen.globals.cycle, phasor( frequency, reset, props ))
  ugen.name = 'cycle' + gen.getUID()

  return ugen
}

},{"./data.js":30,"./gen.js":44,"./mul.js":62,"./peek.js":68,"./phasor.js":69}],30:[function(require,module,exports){
'use strict'

const gen  = require('./gen.js'),
      utilities = require( './utilities.js' ),
      peek = require('./peek.js'),
      poke = require('./poke.js')

const proto = {
  basename:'data',
  globals: {},
  memo:{},

  gen() {
    let idx
    //console.log( 'data name:', this.name, proto.memo )
    //debugger
    if( gen.memo[ this.name ] === undefined ) {
      let ugen = this
      gen.requestMemory( this.memory, this.immutable ) 
      idx = this.memory.values.idx
      if( this.buffer !== undefined ) {
        try {
          gen.memory.heap.set( this.buffer, idx )
        }catch( e ) {
          console.log( e )
          throw Error( 'error with request. asking for ' + this.buffer.length +'. current index: ' + gen.memoryIndex + ' of ' + gen.memory.heap.length )
        }
      }
      //gen.data[ this.name ] = this
      //return 'gen.memory' + this.name + '.buffer'
      if( this.name.indexOf('data') === -1 ) {
        proto.memo[ this.name ] = idx
      }else{
        gen.memo[ this.name ] = idx
      }
    }else{
      //console.log( 'using gen data memo', proto.memo[ this.name ] )
      idx = gen.memo[ this.name ]
    }
    return idx
  },
}

module.exports = ( x, y=1, properties ) => {
  let ugen, buffer, shouldLoad = false
  
  if( properties !== undefined && properties.global !== undefined ) {
    if( gen.globals[ properties.global ] ) {
      return gen.globals[ properties.global ]
    }
  }

  if( typeof x === 'number' ) {
    if( y !== 1 ) {
      buffer = []
      for( let i = 0; i < y; i++ ) {
        buffer[ i ] = new Float32Array( x )
      }
    }else{
      buffer = new Float32Array( x )
    }
  }else if( Array.isArray( x ) ) { //! (x instanceof Float32Array ) ) {
    let size = x.length
    buffer = new Float32Array( size )
    for( let i = 0; i < x.length; i++ ) {
      buffer[ i ] = x[ i ]
    }
  }else if( typeof x === 'string' ) {
    //buffer = { length: y > 1 ? y : gen.samplerate * 60 } // XXX what???
    //if( proto.memo[ x ] === undefined ) {
      buffer = { length: y > 1 ? y : 1 } // XXX what???
      shouldLoad = true
    //}else{
      //buffer = proto.memo[ x ]
    //}
  }else if( x instanceof Float32Array ) {
    buffer = x
  }
  
  ugen = Object.create( proto ) 

  Object.assign( ugen, 
  { 
    buffer,
    name: proto.basename + gen.getUID(),
    dim:  buffer !== undefined ? buffer.length : 1, // XXX how do we dynamically allocate this?
    channels : 1,
    onload: null,
    //then( fnc ) {
    //  ugen.onload = fnc
    //  return ugen
    //},
    immutable: properties !== undefined && properties.immutable === true ? true : false,
    load( filename, __resolve ) {
      let promise = utilities.loadSample( filename, ugen )
      promise.then( _buffer => { 
        proto.memo[ x ] = _buffer
        ugen.name = filename
        ugen.memory.values.length = ugen.dim = _buffer.length

        gen.requestMemory( ugen.memory, ugen.immutable ) 
        gen.memory.heap.set( _buffer, ugen.memory.values.idx )
        if( typeof ugen.onload === 'function' ) ugen.onload( _buffer ) 
        __resolve( ugen )
      })
    },
    memory : {
      values: { length:buffer !== undefined ? buffer.length : 1, idx:null }
    }
  },
  properties
  )

  
  if( properties !== undefined ) {
    if( properties.global !== undefined ) {
      gen.globals[ properties.global ] = ugen
    }
    if( properties.meta === true ) {
      for( let i = 0, length = ugen.buffer.length; i < length; i++ ) {
        Object.defineProperty( ugen, i, {
          get () {
            return peek( ugen, i, { mode:'simple', interp:'none' } )
          },
          set( v ) {
            return poke( ugen, v, i )
          }
        })
      }
    }
  }

  let returnValue
  if( shouldLoad === true ) {
    returnValue = new Promise( (resolve,reject) => {
      //ugen.load( x, resolve )
      let promise = utilities.loadSample( x, ugen )
      promise.then( _buffer => { 
        proto.memo[ x ] = _buffer
        ugen.memory.values.length = ugen.dim = _buffer.length

        ugen.buffer = _buffer
        //gen.once( 'memory init', ()=> {
        //  console.log( "CALLED", ugen.memory )
        //  gen.requestMemory( ugen.memory, ugen.immutable ) 
        //  gen.memory.heap.set( _buffer, ugen.memory.values.idx )
        //  if( typeof ugen.onload === 'function' ) ugen.onload( _buffer ) 
        //})
        
        resolve( ugen )
      })     
    })
  }else if( proto.memo[ x ] !== undefined ) {

    gen.once( 'memory init', ()=> {
      gen.requestMemory( ugen.memory, ugen.immutable ) 
      gen.memory.heap.set( ugen.buffer, ugen.memory.values.idx )
      if( typeof ugen.onload === 'function' ) ugen.onload( ugen.buffer ) 
    })

    returnValue = ugen
  }else{
    returnValue = ugen
  }

  return returnValue 
}


},{"./gen.js":44,"./peek.js":68,"./poke.js":70,"./utilities.js":87}],31:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' )

module.exports = ( in1 ) => {
  let x1 = history(),
      y1 = history(),
      filter

  //History x1, y1; y = in1 - x1 + y1*0.9997; x1 = in1; y1 = y; out1 = y;
  filter = memo( add( sub( in1, x1.out ), mul( y1.out, .9997 ) ) )
  x1.in( in1 )
  y1.in( filter )

  return filter
}

},{"./add.js":17,"./gen.js":44,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81}],32:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    mul     = require( './mul.js' ),
    t60     = require( './t60.js' )

module.exports = ( decayTime = 44100, props ) => {
  let properties = Object.assign({}, { initValue:1 }, props ),
      ssd = history ( properties.initValue )

  ssd.in( mul( ssd.out, t60( decayTime ) ) )

  ssd.out.trigger = ()=> {
    ssd.value = 1
  }

  return ssd.out 
}

},{"./gen.js":44,"./history.js":48,"./mul.js":62,"./t60.js":83}],33:[function(require,module,exports){
'use strict'

const gen  = require( './gen.js'  ),
      data = require( './data.js' ),
      poke = require( './poke.js' ),
      peek = require( './peek.js' ),
      sub  = require( './sub.js'  ),
      wrap = require( './wrap.js' ),
      accum= require( './accum.js'),
      memo = require( './memo.js' )

const proto = {
  basename:'delay',

  gen() {
    let inputs = gen.getInputs( this )
    
    gen.memo[ this.name ] = inputs[0]
    
    return inputs[0]
  },
}

const defaults = { size: 512, interp:'none' }

module.exports = ( in1, taps, properties ) => {
  const ugen = Object.create( proto )
  let writeIdx, readIdx, delaydata

  if( Array.isArray( taps ) === false ) taps = [ taps ]
  
  const props = Object.assign( {}, defaults, properties )

  const maxTapSize = Math.max( ...taps )
  if( props.size < maxTapSize ) props.size = maxTapSize

  delaydata = data( props.size )
  
  ugen.inputs = []

  writeIdx = accum( 1, 0, { max:props.size, min:0 })
  
  for( let i = 0; i < taps.length; i++ ) {
    ugen.inputs[ i ] = peek( delaydata, wrap( sub( writeIdx, taps[i] ), 0, props.size ),{ mode:'samples', interp:props.interp })
  }
  
  ugen.outputs = ugen.inputs // XXX ugh, Ugh, UGH! but i guess it works.

  poke( delaydata, in1, writeIdx )

  ugen.name = `${ugen.basename}${gen.getUID()}`

  return ugen
}

},{"./accum.js":14,"./data.js":30,"./gen.js":44,"./memo.js":56,"./peek.js":68,"./poke.js":70,"./sub.js":81,"./wrap.js":89}],34:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' )

module.exports = ( in1 ) => {
  let n1 = history()
    
  n1.in( in1 )

  let ugen = sub( in1, n1.out )
  ugen.name = 'delta'+gen.getUID()

  return ugen
}

},{"./gen.js":44,"./history.js":48,"./sub.js":81}],35:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

const proto = {
  basename:'div',
  gen() {
    let inputs = gen.getInputs( this ),
        out=`  var ${this.name} = `,
        diff = 0, 
        numCount = 0,
        lastNumber = inputs[ 0 ],
        lastNumberIsUgen = isNaN( lastNumber ), 
        divAtEnd = false

    inputs.forEach( (v,i) => {
      if( i === 0 ) return

      let isNumberUgen = isNaN( v ),
        isFinalIdx   = i === inputs.length - 1

      if( !lastNumberIsUgen && !isNumberUgen ) {
        lastNumber = lastNumber / v
        out += lastNumber
      }else{
        out += `${lastNumber} / ${v}`
      }

      if( !isFinalIdx ) out += ' / ' 
    })

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = (...args) => {
  const div = Object.create( proto )
  
  Object.assign( div, {
    id:     gen.getUID(),
    inputs: args,
  })

  div.name = div.basename + div.id
  
  return div
}

},{"./gen.js":44}],36:[function(require,module,exports){
'use strict'

let gen     = require( './gen' ),
    windows = require( './windows' ),
    data    = require( './data' ),
    peek    = require( './peek' ),
    phasor  = require( './phasor' ),
    defaults = {
      type:'triangular', length:1024, alpha:.15, shift:0, reverse:false 
    }

module.exports = props => {
  
  let properties = Object.assign( {}, defaults, props )
  let buffer = new Float32Array( properties.length )

  let name = properties.type + '_' + properties.length + '_' + properties.shift + '_' + properties.reverse + '_' + properties.alpha
  if( typeof gen.globals.windows[ name ] === 'undefined' ) { 

    for( let i = 0; i < properties.length; i++ ) {
      buffer[ i ] = windows[ properties.type ]( properties.length, i, properties.alpha, properties.shift )
    }

    if( properties.reverse === true ) { 
      buffer.reverse()
    }
    gen.globals.windows[ name ] = data( buffer )
  }

  let ugen = gen.globals.windows[ name ] 
  ugen.name = 'env' + gen.getUID()

  return ugen
}

},{"./data":30,"./gen":44,"./peek":68,"./phasor":69,"./windows":88}],37:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'eq',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = this.inputs[0] === this.inputs[1] ? 1 : `  var ${this.name} = (${inputs[0]} === ${inputs[1]}) | 0\n\n`

    gen.memo[ this.name ] = `${this.name}`

    return [ `${this.name}`, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],38:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'exp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.exp' : Math.exp })

      out = `${ref}exp( ${inputs[0]} )`

    } else {
      out = Math.exp( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let exp = Object.create( proto )

  exp.inputs = [ x ]

  return exp
}

},{"./gen.js":44}],39:[function(require,module,exports){
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

// originally from:
// https://github.com/GoogleChromeLabs/audioworklet-polyfill
// I am modifying it to accept variable buffer sizes
// and to get rid of some strange global initialization that seems required to use it
// with browserify. Also, I added changes to fix a bug in Safari for the AudioWorkletProcessor
// property not having a prototype (see:https://github.com/GoogleChromeLabs/audioworklet-polyfill/pull/25)
// TODO: Why is there an iframe involved? (realm.js)

const Realm = require( './realm.js' )

const AWPF = function( self = window, bufferSize = 4096 ) {
  const PARAMS = []
  let nextPort

  if (typeof AudioWorkletNode !== 'function' || !("audioWorklet" in AudioContext.prototype)) {
    self.AudioWorkletNode = function AudioWorkletNode (context, name, options) {
      const processor = getProcessorsForContext(context)[name];
      const outputChannels = options && options.outputChannelCount ? options.outputChannelCount[0] : 2;
      const scriptProcessor = context.createScriptProcessor( bufferSize, 2, outputChannels);

      scriptProcessor.parameters = new Map();
      if (processor.properties) {
        for (let i = 0; i < processor.properties.length; i++) {
          const prop = processor.properties[i];
          const node = context.createGain().gain;
          node.value = prop.defaultValue;
          // @TODO there's no good way to construct the proxy AudioParam here
          scriptProcessor.parameters.set(prop.name, node);
        }
      }

      const mc = new MessageChannel();
      nextPort = mc.port2;
      const inst = new processor.Processor(options || {});
      nextPort = null;

      scriptProcessor.port = mc.port1;
      scriptProcessor.processor = processor;
      scriptProcessor.instance = inst;
      scriptProcessor.onaudioprocess = onAudioProcess;
      return scriptProcessor;
    };

    Object.defineProperty((self.AudioContext || self.webkitAudioContext).prototype, 'audioWorklet', {
      get () {
        return this.$$audioWorklet || (this.$$audioWorklet = new self.AudioWorklet(this));
      }
    });

    /* XXX - ADDED TO OVERCOME PROBLEM IN SAFARI WHERE AUDIOWORKLETPROCESSOR PROTOTYPE IS NOT AN OBJECT */
    const AudioWorkletProcessor = function() {
      this.port = nextPort
    }
    AudioWorkletProcessor.prototype = {}

    self.AudioWorklet = class AudioWorklet {
      constructor (audioContext) {
        this.$$context = audioContext;
      }

      addModule (url, options) {
        return fetch(url).then(r => {
          if (!r.ok) throw Error(r.status);
          return r.text();
        }).then( code => {
          const context = {
            sampleRate: this.$$context.sampleRate,
            currentTime: this.$$context.currentTime,
            AudioWorkletProcessor,
            registerProcessor: (name, Processor) => {
              const processors = getProcessorsForContext(this.$$context);
              processors[name] = {
                realm,
                context,
                Processor,
                properties: Processor.parameterDescriptors || []
              };
            }
          };

          context.self = context;
          const realm = new Realm(context, document.documentElement);
          realm.exec(((options && options.transpile) || String)(code));
          return null;
        });
      }
    };
  }

  function onAudioProcess (e) {
    const parameters = {};
    let index = -1;
    this.parameters.forEach((value, key) => {
      const arr = PARAMS[++index] || (PARAMS[index] = new Float32Array(this.bufferSize));
      // @TODO proper values here if possible
      arr.fill(value.value);
      parameters[key] = arr;
    });
    this.processor.realm.exec(
      'self.sampleRate=sampleRate=' + this.context.sampleRate + ';' +
      'self.currentTime=currentTime=' + this.context.currentTime
    );
    const inputs = channelToArray(e.inputBuffer);
    const outputs = channelToArray(e.outputBuffer);
    this.instance.process([inputs], [outputs], parameters);
  }

  function channelToArray (ch) {
    const out = [];
    for (let i = 0; i < ch.numberOfChannels; i++) {
      out[i] = ch.getChannelData(i);
    }
    return out;
  }

  function getProcessorsForContext (audioContext) {
    return audioContext.$$processors || (audioContext.$$processors = {});
  }
}

module.exports = AWPF

},{"./realm.js":40}],40:[function(require,module,exports){
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],41:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'floor',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( inputs[0] ) ) {
      //gen.closures.add({ [ this.name ]: Math.floor })

      out = `( ${inputs[0]} | 0 )`

    } else {
      out = inputs[0] | 0
    }
    
    return out
  }
}

module.exports = x => {
  let floor = Object.create( proto )

  floor.inputs = [ x ]

  return floor
}

},{"./gen.js":44}],42:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'fold',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        out

    out = this.createCallback( inputs[0], this.min, this.max ) 

    gen.memo[ this.name ] = this.name + '_value'

    return [ this.name + '_value', out ]
  },

  createCallback( v, lo, hi ) {
    let out =
` var ${this.name}_value = ${v},
      ${this.name}_range = ${hi} - ${lo},
      ${this.name}_numWraps = 0

  if(${this.name}_value >= ${hi}){
    ${this.name}_value -= ${this.name}_range
    if(${this.name}_value >= ${hi}){
      ${this.name}_numWraps = ((${this.name}_value - ${lo}) / ${this.name}_range) | 0
      ${this.name}_value -= ${this.name}_range * ${this.name}_numWraps
    }
    ${this.name}_numWraps++
  } else if(${this.name}_value < ${lo}){
    ${this.name}_value += ${this.name}_range
    if(${this.name}_value < ${lo}){
      ${this.name}_numWraps = ((${this.name}_value - ${lo}) / ${this.name}_range- 1) | 0
      ${this.name}_value -= ${this.name}_range * ${this.name}_numWraps
    }
    ${this.name}_numWraps--
  }
  if(${this.name}_numWraps & 1) ${this.name}_value = ${hi} + ${lo} - ${this.name}_value
`
    return ' ' + out
  }
}

module.exports = ( in1, min=0, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],43:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'gate',
  controlString:null, // insert into output codegen for determining indexing
  gen() {
    let inputs = gen.getInputs( this ), out
    
    gen.requestMemory( this.memory )
    
    let lastInputMemoryIdx = 'memory[ ' + this.memory.lastInput.idx + ' ]',
        outputMemoryStartIdx = this.memory.lastInput.idx + 1,
        inputSignal = inputs[0],
        controlSignal = inputs[1]
    
    /* 
     * we check to see if the current control inputs equals our last input
     * if so, we store the signal input in the memory associated with the currently
     * selected index. If not, we put 0 in the memory associated with the last selected index,
     * change the selected index, and then store the signal in put in the memery assoicated
     * with the newly selected index
     */
    
    out =

` if( ${controlSignal} !== ${lastInputMemoryIdx} ) {
    memory[ ${lastInputMemoryIdx} + ${outputMemoryStartIdx}  ] = 0 
    ${lastInputMemoryIdx} = ${controlSignal}
  }
  memory[ ${outputMemoryStartIdx} + ${controlSignal} ] = ${inputSignal}

`
    this.controlString = inputs[1]
    this.initialized = true

    gen.memo[ this.name ] = this.name

    this.outputs.forEach( v => v.gen() )

    return [ null, ' ' + out ]
  },

  childgen() {
    if( this.parent.initialized === false ) {
      gen.getInputs( this ) // parent gate is only input of a gate output, should only be gen'd once.
    }

    if( gen.memo[ this.name ] === undefined ) {
      gen.requestMemory( this.memory )

      gen.memo[ this.name ] = `memory[ ${this.memory.value.idx} ]`
    }
    
    return  `memory[ ${this.memory.value.idx} ]`
  }
}

module.exports = ( control, in1, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { count: 2 }

  if( typeof properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, {
    outputs: [],
    uid:     gen.getUID(),
    inputs:  [ in1, control ],
    memory: {
      lastInput: { length:1, idx:null }
    },
    initialized:false
  },
  defaults )
  
  ugen.name = `${ugen.basename}${gen.getUID()}`

  for( let i = 0; i < ugen.count; i++ ) {
    ugen.outputs.push({
      index:i,
      gen: proto.childgen,
      parent:ugen,
      inputs: [ ugen ],
      memory: {
        value: { length:1, idx:null }
      },
      initialized:false,
      name: `${ugen.name}_out${gen.getUID()}`
    })
  }

  return ugen
}

},{"./gen.js":44}],44:[function(require,module,exports){
'use strict'

/* gen.js
 *
 * low-level code generation for unit generators
 *
 */
const MemoryHelper = require( 'memory-helper' )
const EE = require( 'events' ).EventEmitter

const gen = {

  accum:0,
  getUID() { return this.accum++ },
  debug:false,
  samplerate: 44100, // change on audiocontext creation
  shouldLocalize: false,
  graph:null,
  globals:{
    windows: {},
  },
  mode:'worklet',
  
  /* closures
   *
   * Functions that are included as arguments to master callback. Examples: Math.abs, Math.random etc.
   * XXX Should probably be renamed callbackProperties or something similar... closures are no longer used.
   */

  closures: new Set(),
  params:   new Set(),
  inputs:   new Set(),

  parameters: new Set(),
  endBlock: new Set(),
  histories: new Map(),

  memo: {},

  //data: {},
  
  /* export
   *
   * place gen functions into another object for easier reference
   */

  export( obj ) {},

  addToEndBlock( v ) {
    this.endBlock.add( '  ' + v )
  },
  
  requestMemory( memorySpec, immutable=false ) {
    for( let key in memorySpec ) {
      let request = memorySpec[ key ]

      //console.log( 'requesting ' + key + ':' , JSON.stringify( request ) )

      if( request.length === undefined ) {
        console.log( 'undefined length for:', key )

        continue
      }

      request.idx = gen.memory.alloc( request.length, immutable )
    }
  },

  createMemory( amount=4096, type ) {
    const mem = MemoryHelper.create( amount, type )
    return mem
  },

  createCallback( ugen, mem, debug = false, shouldInlineMemory=false, memType = Float64Array ) {
    let isStereo = Array.isArray( ugen ) && ugen.length > 1,
        callback, 
        channel1, channel2

    if( typeof mem === 'number' || mem === undefined ) {
      this.memory = this.createMemory( mem, memType )
    }else{
      this.memory = mem
    }
    
    this.outputIdx = this.memory.alloc( 2, true )
    this.emit( 'memory init' )

    //console.log( 'cb memory:', mem )
    this.graph = ugen
    this.memo = {} 
    this.endBlock.clear()
    this.closures.clear()
    this.inputs.clear()
    this.params.clear()
    this.globals = { windows:{} }
    
    this.parameters.clear()
    
    this.functionBody = "  'use strict'\n"
    if( shouldInlineMemory===false ) {
      this.functionBody += this.mode === 'worklet' ? 
        "  var memory = this.memory\n\n" :
        "  var memory = gen.memory\n\n"
    }

    // call .gen() on the head of the graph we are generating the callback for
    //console.log( 'HEAD', ugen )
    for( let i = 0; i < 1 + isStereo; i++ ) {
      if( typeof ugen[i] === 'number' ) continue

      //let channel = isStereo ? ugen[i].gen() : ugen.gen(),
      let channel = isStereo ? this.getInput( ugen[i] ) : this.getInput( ugen ), 
          body = ''

      // if .gen() returns array, add ugen callback (graphOutput[1]) to our output functions body
      // and then return name of ugen. If .gen() only generates a number (for really simple graphs)
      // just return that number (graphOutput[0]).
      body += Array.isArray( channel ) ? channel[1] + '\n' + channel[0] : channel

      // split body to inject return keyword on last line
      body = body.split('\n')
     
      //if( debug ) console.log( 'functionBody length', body )
      
      // next line is to accommodate memo as graph head
      if( body[ body.length -1 ].trim().indexOf('let') > -1 ) { body.push( '\n' ) } 

      // get index of last line
      let lastidx = body.length - 1

      // insert return keyword
      body[ lastidx ] = '  memory[' + (this.outputIdx + i) + ']  = ' + body[ lastidx ] + '\n'

      this.functionBody += body.join('\n')
    }
    
    this.histories.forEach( value => {
      if( value !== null )
        value.gen()      
    })

    const returnStatement = isStereo ? `  return [ memory[${this.outputIdx}], memory[${this.outputIdx + 1}] ]` : `  return memory[${this.outputIdx}]`
    
    this.functionBody = this.functionBody.split('\n')

    if( this.endBlock.size ) { 
      this.functionBody = this.functionBody.concat( Array.from( this.endBlock ) )
      this.functionBody.push( returnStatement )
    }else{
      this.functionBody.push( returnStatement )
    }
    // reassemble function body
    this.functionBody = this.functionBody.join('\n')

    // we can only dynamically create a named function by dynamically creating another function
    // to construct the named function! sheesh...
    //
    if( shouldInlineMemory === true ) {
      this.parameters.add( 'memory' )
    }

    let paramString = ''
    if( this.mode === 'worklet' ) {
      for( let name of this.parameters.values() ) {
        paramString += name + ','
      }
      paramString = paramString.slice(0,-1)
    }

    const separator = this.parameters.size !== 0 && this.inputs.size > 0 ? ', ' : ''

    let inputString = ''
    if( this.mode === 'worklet' ) {
      for( let ugen of this.inputs.values() ) {
        inputString += ugen.name + ','
      }
      inputString = inputString.slice(0,-1)
    }

    let buildString = this.mode === 'worklet'
      ? `return function( ${inputString} ${separator} ${paramString} ){ \n${ this.functionBody }\n}`
      : `return function gen( ${ [...this.parameters].join(',') } ){ \n${ this.functionBody }\n}`
    
    if( this.debug || debug ) console.log( buildString ) 

    callback = new Function( buildString )()

    // assign properties to named function
    for( let dict of this.closures.values() ) {
      let name = Object.keys( dict )[0],
          value = dict[ name ]

      callback[ name ] = value
    }

    for( let dict of this.params.values() ) {
      let name = Object.keys( dict )[0],
          ugen = dict[ name ]
      
      Object.defineProperty( callback, name, {
        configurable: true,
        get() { return ugen.value },
        set(v){ ugen.value = v }
      })
      //callback[ name ] = value
    }

    callback.members = this.closures
    callback.data = this.data
    callback.params = this.params
    callback.inputs = this.inputs
    callback.parameters = this.parameters//.slice( 0 )
    callback.out = this.memory.heap.subarray( this.outputIdx, this.outputIdx + 2 )
    callback.isStereo = isStereo

    //if( MemoryHelper.isPrototypeOf( this.memory ) ) 
    callback.memory = this.memory.heap

    this.histories.clear()

    return callback
  },
  
  /* getInputs
   *
   * Called by each individual ugen when their .gen() method is called to resolve their various inputs.
   * If an input is a number, return the number. If
   * it is an ugen, call .gen() on the ugen, memoize the result and return the result. If the
   * ugen has previously been memoized return the memoized value.
   *
   */
  getInputs( ugen ) {
    return ugen.inputs.map( gen.getInput ) 
  },

  getInput( input ) {
    let isObject = typeof input === 'object',
        processedInput

    if( isObject ) { // if input is a ugen... 
      //console.log( input.name, gen.memo[ input.name ] )
      if( gen.memo[ input.name ] ) { // if it has been memoized...
        processedInput = gen.memo[ input.name ]
      }else if( Array.isArray( input ) ) {
        gen.getInput( input[0] )
        gen.getInput( input[1] )
      }else{ // if not memoized generate code  
        if( typeof input.gen !== 'function' ) {
          console.log( 'no gen found:', input, input.gen )
          input = input.graph
        }
        let code = input.gen()
        //if( code.indexOf( 'Object' ) > -1 ) console.log( 'bad input:', input, code )
        
        if( Array.isArray( code ) ) {
          if( !gen.shouldLocalize ) {
            gen.functionBody += code[1]
          }else{
            gen.codeName = code[0]
            gen.localizedCode.push( code[1] )
          }
          //console.log( 'after GEN' , this.functionBody )
          processedInput = code[0]
        }else{
          processedInput = code
        }
      }
    }else{ // it input is a number
      processedInput = input
    }

    return processedInput
  },

  startLocalize() {
    this.localizedCode = []
    this.shouldLocalize = true
  },
  endLocalize() {
    this.shouldLocalize = false

    return [ this.codeName, this.localizedCode.slice(0) ]
  },

  free( graph ) {
    if( Array.isArray( graph ) ) { // stereo ugen
      for( let channel of graph ) {
        this.free( channel )
      }
    } else {
      if( typeof graph === 'object' ) {
        if( graph.memory !== undefined ) {
          for( let memoryKey in graph.memory ) {
            this.memory.free( graph.memory[ memoryKey ].idx )
          }
        }
        if( Array.isArray( graph.inputs ) ) {
          for( let ugen of graph.inputs ) {
            this.free( ugen )
          }
        }
      }
    }
  }
}

gen.__proto__ = new EE()

module.exports = gen

},{"events":8,"memory-helper":221}],45:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'gt',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `(( ${inputs[0]} > ${inputs[1]}) | 0 )`
    } else {
      out += inputs[0] > inputs[1] ? 1 : 0 
    }
    out += '\n\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
  }
}

module.exports = (x,y) => {
  let gt = Object.create( proto )

  gt.inputs = [ x,y ]
  gt.name = gt.basename + gen.getUID()

  return gt
}

},{"./gen.js":44}],46:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  name:'gte',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `( ${inputs[0]} >= ${inputs[1]} | 0 )`
    } else {
      out += inputs[0] >= inputs[1] ? 1 : 0 
    }
    out += '\n\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
  }
}

module.exports = (x,y) => {
  let gt = Object.create( proto )

  gt.inputs = [ x,y ]
  gt.name = 'gte' + gen.getUID()

  return gt
}

},{"./gen.js":44}],47:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'gtp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out = `(${inputs[ 0 ]} * ( ( ${inputs[0]} > ${inputs[1]} ) | 0 ) )` 
    } else {
      out = inputs[0] * ( ( inputs[0] > inputs[1] ) | 0 )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let gtp = Object.create( proto )

  gtp.inputs = [ x,y ]

  return gtp
}

},{"./gen.js":44}],48:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

module.exports = ( in1=0 ) => {
  let ugen = {
    inputs: [ in1 ],
    memory: { value: { length:1, idx: null } },
    recorder: null,

    in( v ) {
      if( gen.histories.has( v ) ){
        let memoHistory = gen.histories.get( v )
        ugen.name = memoHistory.name
        return memoHistory
      }

      let obj = {
        gen() {
          let inputs = gen.getInputs( ugen )

          if( ugen.memory.value.idx === null ) {
            gen.requestMemory( ugen.memory )
            gen.memory.heap[ ugen.memory.value.idx ] = in1
          }

          let idx = ugen.memory.value.idx
          
          gen.addToEndBlock( 'memory[ ' + idx + ' ] = ' + inputs[ 0 ] )
          
          // return ugen that is being recorded instead of ssd.
          // this effectively makes a call to ssd.record() transparent to the graph.
          // recording is triggered by prior call to gen.addToEndBlock.
          gen.histories.set( v, obj )

          return inputs[ 0 ]
        },
        name: ugen.name + '_in'+gen.getUID(),
        memory: ugen.memory
      }

      this.inputs[ 0 ] = v
      
      ugen.recorder = obj

      return obj
    },
    
    out: {
            
      gen() {
        if( ugen.memory.value.idx === null ) {
          if( gen.histories.get( ugen.inputs[0] ) === undefined ) {
            gen.histories.set( ugen.inputs[0], ugen.recorder )
          }
          gen.requestMemory( ugen.memory )
          gen.memory.heap[ ugen.memory.value.idx ] = parseFloat( in1 )
        }
        let idx = ugen.memory.value.idx
         
        return 'memory[ ' + idx + ' ] '
      },
    },

    uid: gen.getUID(),
  }
  
  ugen.out.memory = ugen.memory 

  ugen.name = 'history' + ugen.uid
  ugen.out.name = ugen.name + '_out'
  ugen.in._name  = ugen.name = '_in'

  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        gen.memory.heap[ this.memory.value.idx ] = v 
      }
    }
  })

  return ugen
}

},{"./gen.js":44}],49:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'ifelse',

  gen() {
    let conditionals = this.inputs[0],
        defaultValue = gen.getInput( conditionals[ conditionals.length - 1] ),
        out = `  var ${this.name}_out = ${defaultValue}\n` 

    //console.log( 'conditionals:', this.name, conditionals )

    //console.log( 'defaultValue:', defaultValue )

    for( let i = 0; i < conditionals.length - 2; i+= 2 ) {
      let isEndBlock = i === conditionals.length - 3,
          cond  = gen.getInput( conditionals[ i ] ),
          preblock = conditionals[ i+1 ],
          block, blockName, output

      //console.log( 'pb', preblock )

      if( typeof preblock === 'number' ){
        block = preblock
        blockName = null
      }else{
        if( gen.memo[ preblock.name ] === undefined ) {
          // used to place all code dependencies in appropriate blocks
          gen.startLocalize()

          gen.getInput( preblock )

          block = gen.endLocalize()
          blockName = block[0]
          block = block[ 1 ].join('')
          block = '  ' + block.replace( /\n/gi, '\n  ' )
        }else{
          block = ''
          blockName = gen.memo[ preblock.name ]
        }
      }

      output = blockName === null ? 
        `  ${this.name}_out = ${block}` :
        `${block}  ${this.name}_out = ${blockName}`
      
      if( i===0 ) out += ' '
      out += 
` if( ${cond} === 1 ) {
${output}
  }`

      if( !isEndBlock ) {
        out += ` else`
      }else{
        out += `\n`
      }
    }

    gen.memo[ this.name ] = `${this.name}_out`

    return [ `${this.name}_out`, out ]
  }
}

module.exports = ( ...args  ) => {
  let ugen = Object.create( proto ),
      conditions = Array.isArray( args[0] ) ? args[0] : args

  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ conditions ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],50:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename:'in',

  gen() {
    const isWorklet = gen.mode === 'worklet'

    if( isWorklet ) {
      gen.inputs.add( this )
    }else{
      gen.parameters.add( this.name )
    }

    gen.memo[ this.name ] = isWorklet === true ? this.name + '[i]' : this.name

    return gen.memo[ this.name ]
  } 
}

module.exports = ( name, inputNumber=0, channelNumber=0, defaultValue=0, min=0, max=1 ) => {
  let input = Object.create( proto )

  input.id   = gen.getUID()
  input.name = name !== undefined ? name : `${input.basename}${input.id}`
  Object.assign( input, { defaultValue, min, max, inputNumber, channelNumber })

  input[0] = {
    gen() {
      if( ! gen.parameters.has( input.name ) ) gen.parameters.add( input.name )
      return input.name + '[0]'
    }
  }
  input[1] = {
    gen() {
      if( ! gen.parameters.has( input.name ) ) gen.parameters.add( input.name )
      return input.name + '[1]'
    }
  }


  return input
}

},{"./gen.js":44}],51:[function(require,module,exports){
'use strict'

const library = {
  export( destination ) {
    if( destination === window ) {
      destination.ssd = library.history    // history is window object property, so use ssd as alias
      destination.input = library.in       // in is a keyword in javascript
      destination.ternary = library.switch // switch is a keyword in javascript

      delete library.history
      delete library.in
      delete library.switch
    }

    Object.assign( destination, library )

    Object.defineProperty( library, 'samplerate', {
      get() { return library.gen.samplerate },
      set(v) {}
    })

    library.in = destination.input
    library.history = destination.ssd
    library.switch = destination.ternary

    destination.clip = library.clamp
  },

  gen:      require( './gen.js' ),
  
  abs:      require( './abs.js' ),
  round:    require( './round.js' ),
  param:    require( './param.js' ),
  add:      require( './add.js' ),
  sub:      require( './sub.js' ),
  mul:      require( './mul.js' ),
  div:      require( './div.js' ),
  accum:    require( './accum.js' ),
  counter:  require( './counter.js' ),
  sin:      require( './sin.js' ),
  cos:      require( './cos.js' ),
  tan:      require( './tan.js' ),
  tanh:     require( './tanh.js' ),
  asin:     require( './asin.js' ),
  acos:     require( './acos.js' ),
  atan:     require( './atan.js' ),  
  phasor:   require( './phasor.js' ),
  data:     require( './data.js' ),
  peek:     require( './peek.js' ),
  cycle:    require( './cycle.js' ),
  history:  require( './history.js' ),
  delta:    require( './delta.js' ),
  floor:    require( './floor.js' ),
  ceil:     require( './ceil.js' ),
  min:      require( './min.js' ),
  max:      require( './max.js' ),
  sign:     require( './sign.js' ),
  dcblock:  require( './dcblock.js' ),
  memo:     require( './memo.js' ),
  rate:     require( './rate.js' ),
  wrap:     require( './wrap.js' ),
  mix:      require( './mix.js' ),
  clamp:    require( './clamp.js' ),
  poke:     require( './poke.js' ),
  delay:    require( './delay.js' ),
  fold:     require( './fold.js' ),
  mod :     require( './mod.js' ),
  sah :     require( './sah.js' ),
  noise:    require( './noise.js' ),
  not:      require( './not.js' ),
  gt:       require( './gt.js' ),
  gte:      require( './gte.js' ),
  lt:       require( './lt.js' ), 
  lte:      require( './lte.js' ), 
  bool:     require( './bool.js' ),
  gate:     require( './gate.js' ),
  train:    require( './train.js' ),
  slide:    require( './slide.js' ),
  in:       require( './in.js' ),
  t60:      require( './t60.js'),
  mtof:     require( './mtof.js'),
  ltp:      require( './ltp.js'),        // TODO: test
  gtp:      require( './gtp.js'),        // TODO: test
  switch:   require( './switch.js' ),
  mstosamps:require( './mstosamps.js' ), // TODO: needs test,
  selector: require( './selector.js' ),
  utilities:require( './utilities.js' ),
  pow:      require( './pow.js' ),
  attack:   require( './attack.js' ),
  decay:    require( './decay.js' ),
  windows:  require( './windows.js' ),
  env:      require( './env.js' ),
  ad:       require( './ad.js'  ),
  adsr:     require( './adsr.js' ),
  ifelse:   require( './ifelseif.js' ),
  bang:     require( './bang.js' ),
  and:      require( './and.js' ),
  pan:      require( './pan.js' ),
  eq:       require( './eq.js' ),
  neq:      require( './neq.js' ),
  exp:      require( './exp.js' ),
  process:  require( './process.js' ),
  seq:      require( './seq.js' )
}

library.gen.lib = library

module.exports = library

},{"./abs.js":13,"./accum.js":14,"./acos.js":15,"./ad.js":16,"./add.js":17,"./adsr.js":18,"./and.js":19,"./asin.js":20,"./atan.js":21,"./attack.js":22,"./bang.js":23,"./bool.js":24,"./ceil.js":25,"./clamp.js":26,"./cos.js":27,"./counter.js":28,"./cycle.js":29,"./data.js":30,"./dcblock.js":31,"./decay.js":32,"./delay.js":33,"./delta.js":34,"./div.js":35,"./env.js":36,"./eq.js":37,"./exp.js":38,"./floor.js":41,"./fold.js":42,"./gate.js":43,"./gen.js":44,"./gt.js":45,"./gte.js":46,"./gtp.js":47,"./history.js":48,"./ifelseif.js":49,"./in.js":50,"./lt.js":52,"./lte.js":53,"./ltp.js":54,"./max.js":55,"./memo.js":56,"./min.js":57,"./mix.js":58,"./mod.js":59,"./mstosamps.js":60,"./mtof.js":61,"./mul.js":62,"./neq.js":63,"./noise.js":64,"./not.js":65,"./pan.js":66,"./param.js":67,"./peek.js":68,"./phasor.js":69,"./poke.js":70,"./pow.js":71,"./process.js":72,"./rate.js":73,"./round.js":74,"./sah.js":75,"./selector.js":76,"./seq.js":77,"./sign.js":78,"./sin.js":79,"./slide.js":80,"./sub.js":81,"./switch.js":82,"./t60.js":83,"./tan.js":84,"./tanh.js":85,"./train.js":86,"./utilities.js":87,"./windows.js":88,"./wrap.js":89}],52:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'lt',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `(( ${inputs[0]} < ${inputs[1]}) | 0  )`
    } else {
      out += inputs[0] < inputs[1] ? 1 : 0 
    }
    out += '\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (x,y) => {
  let lt = Object.create( proto )

  lt.inputs = [ x,y ]
  lt.name = lt.basename + gen.getUID()

  return lt
}

},{"./gen.js":44}],53:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'lte',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    out = `  var ${this.name} = `  

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out += `( ${inputs[0]} <= ${inputs[1]} | 0  )`
    } else {
      out += inputs[0] <= inputs[1] ? 1 : 0 
    }
    out += '\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (x,y) => {
  let lt = Object.create( proto )

  lt.inputs = [ x,y ]
  lt.name = 'lte' + gen.getUID()

  return lt
}

},{"./gen.js":44}],54:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'ltp',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) || isNaN( this.inputs[1] ) ) {
      out = `(${inputs[ 0 ]} * (( ${inputs[0]} < ${inputs[1]} ) | 0 ) )` 
    } else {
      out = inputs[0] * (( inputs[0] < inputs[1] ) | 0 )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let ltp = Object.create( proto )

  ltp.inputs = [ x,y ]

  return ltp
}

},{"./gen.js":44}],55:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'max',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.max' : Math.max })

      out = `${ref}max( ${inputs[0]}, ${inputs[1]} )`

    } else {
      out = Math.max( parseFloat( inputs[0] ), parseFloat( inputs[1] ) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let max = Object.create( proto )

  max.inputs = [ x,y ]

  return max
}

},{"./gen.js":44}],56:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename:'memo',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    out = `  var ${this.name} = ${inputs[0]}\n`

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  } 
}

module.exports = (in1,memoName) => {
  let memo = Object.create( proto )
  
  memo.inputs = [ in1 ]
  memo.id   = gen.getUID()
  memo.name = memoName !== undefined ? memoName + '_' + gen.getUID() : `${memo.basename}${memo.id}`

  return memo
}

},{"./gen.js":44}],57:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'min',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.min' : Math.min })

      out = `${ref}min( ${inputs[0]}, ${inputs[1]} )`

    } else {
      out = Math.min( parseFloat( inputs[0] ), parseFloat( inputs[1] ) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let min = Object.create( proto )

  min.inputs = [ x,y ]

  return min
}

},{"./gen.js":44}],58:[function(require,module,exports){
'use strict'

let gen = require('./gen.js'),
    add = require('./add.js'),
    mul = require('./mul.js'),
    sub = require('./sub.js'),
    memo= require('./memo.js')

module.exports = ( in1, in2, t=.5 ) => {
  let ugen = memo( add( mul(in1, sub(1,t ) ), mul( in2, t ) ) )
  ugen.name = 'mix' + gen.getUID()

  return ugen
}

},{"./add.js":17,"./gen.js":44,"./memo.js":56,"./mul.js":62,"./sub.js":81}],59:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

module.exports = (...args) => {
  let mod = {
    id:     gen.getUID(),
    inputs: args,

    gen() {
      let inputs = gen.getInputs( this ),
          out='(',
          diff = 0, 
          numCount = 0,
          lastNumber = inputs[ 0 ],
          lastNumberIsUgen = isNaN( lastNumber ), 
          modAtEnd = false

      inputs.forEach( (v,i) => {
        if( i === 0 ) return

        let isNumberUgen = isNaN( v ),
            isFinalIdx   = i === inputs.length - 1

        if( !lastNumberIsUgen && !isNumberUgen ) {
          lastNumber = lastNumber % v
          out += lastNumber
        }else{
          out += `${lastNumber} % ${v}`
        }

        if( !isFinalIdx ) out += ' % ' 
      })

      out += ')'

      return out
    }
  }
  
  return mod
}

},{"./gen.js":44}],60:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'mstosamps',

  gen() {
    let out,
        inputs = gen.getInputs( this ),
        returnValue

    if( isNaN( inputs[0] ) ) {
      out = `  var ${this.name } = ${gen.samplerate} / 1000 * ${inputs[0]} \n\n`
     
      gen.memo[ this.name ] = out
      
      returnValue = [ this.name, out ]
    } else {
      out = gen.samplerate / 1000 * this.inputs[0]

      returnValue = out
    }    

    return returnValue
  }
}

module.exports = x => {
  let mstosamps = Object.create( proto )

  mstosamps.inputs = [ x ]
  mstosamps.name = proto.basename + gen.getUID()

  return mstosamps
}

},{"./gen.js":44}],61:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'mtof',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: Math.exp })

      out = `( ${this.tuning} * gen.exp( .057762265 * (${inputs[0]} - 69) ) )`

    } else {
      out = this.tuning * Math.exp( .057762265 * ( inputs[0] - 69) )
    }
    
    return out
  }
}

module.exports = ( x, props ) => {
  let ugen = Object.create( proto ),
      defaults = { tuning:440 }
  
  if( props !== undefined ) Object.assign( props.defaults )

  Object.assign( ugen, defaults )
  ugen.inputs = [ x ]
  

  return ugen
}

},{"./gen.js":44}],62:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = {
  basename: 'mul',

  gen() {
    let inputs = gen.getInputs( this ),
        out = `  var ${this.name} = `,
        sum = 1, numCount = 0, mulAtEnd = false, alreadyFullSummed = true

    inputs.forEach( (v,i) => {
      if( isNaN( v ) ) {
        out += v
        if( i < inputs.length -1 ) {
          mulAtEnd = true
          out += ' * '
        }
        alreadyFullSummed = false
      }else{
        if( i === 0 ) {
          sum = v
        }else{
          sum *= parseFloat( v )
        }
        numCount++
      }
    })

    if( numCount > 0 ) {
      out += mulAtEnd || alreadyFullSummed ? sum : ' * ' + sum
    }

    out += '\n'

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = ( ...args ) => {
  const mul = Object.create( proto )
  
  Object.assign( mul, {
      id:     gen.getUID(),
      inputs: args,
  })
  
  mul.name = mul.basename + mul.id

  return mul
}

},{"./gen.js":44}],63:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'neq',

  gen() {
    let inputs = gen.getInputs( this ), out

    out = /*this.inputs[0] !== this.inputs[1] ? 1 :*/ `  var ${this.name} = (${inputs[0]} !== ${inputs[1]}) | 0\n\n`

    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  },

}

module.exports = ( in1, in2 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],64:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'noise',

  gen() {
    let out

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    gen.closures.add({ 'noise' : isWorklet ? 'Math.random' : Math.random })

    out = `  var ${this.name} = ${ref}noise()\n`
    
    gen.memo[ this.name ] = this.name

    return [ this.name, out ]
  }
}

module.exports = x => {
  let noise = Object.create( proto )
  noise.name = proto.name + gen.getUID()

  return noise
}

},{"./gen.js":44}],65:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'not',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    if( isNaN( this.inputs[0] ) ) {
      out = `( ${inputs[0]} === 0 ? 1 : 0 )`
    } else {
      out = !inputs[0] === 0 ? 1 : 0
    }
    
    return out
  }
}

module.exports = x => {
  let not = Object.create( proto )

  not.inputs = [ x ]

  return not
}

},{"./gen.js":44}],66:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' ),
    data = require( './data.js' ),
    peek = require( './peek.js' ),
    mul  = require( './mul.js' )

let proto = {
  basename:'pan', 
  initTable() {    
    let bufferL = new Float32Array( 1024 ),
        bufferR = new Float32Array( 1024 )

    const angToRad = Math.PI / 180
    for( let i = 0; i < 1024; i++ ) { 
      let pan = i * ( 90 / 1024 )
      bufferL[i] = Math.cos( pan * angToRad ) 
      bufferR[i] = Math.sin( pan * angToRad )
    }

    gen.globals.panL = data( bufferL, 1, { immutable:true })
    gen.globals.panR = data( bufferR, 1, { immutable:true })
  }

}

module.exports = ( leftInput, rightInput, pan =.5, properties ) => {
  if( gen.globals.panL === undefined ) proto.initTable()

  let ugen = Object.create( proto )

  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ leftInput, rightInput ],
    left:    mul( leftInput, peek( gen.globals.panL, pan, { boundmode:'clamp' }) ),
    right:   mul( rightInput, peek( gen.globals.panR, pan, { boundmode:'clamp' }) )
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./data.js":30,"./gen.js":44,"./mul.js":62,"./peek.js":68}],67:[function(require,module,exports){
'use strict'

let gen = require('./gen.js')

let proto = {
  basename: 'param',

  gen() {
    gen.requestMemory( this.memory )
    
    gen.params.add( this )

    const isWorklet = gen.mode === 'worklet'

    if( isWorklet ) gen.parameters.add( this.name )

    this.value = this.initialValue

    gen.memo[ this.name ] = isWorklet ? this.name : `memory[${this.memory.value.idx}]`

    return gen.memo[ this.name ]
  } 
}

module.exports = ( propName=0, value=0, min=0, max=1 ) => {
  let ugen = Object.create( proto )
  
  if( typeof propName !== 'string' ) {
    ugen.name = ugen.basename + gen.getUID()
    ugen.initialValue = propName
  }else{
    ugen.name = propName
    ugen.initialValue = value
  }

  ugen.min = min
  ugen.max = max
  ugen.defaultValue = ugen.initialValue

  // for storing worklet nodes once they're instantiated
  ugen.waapi = null

  ugen.isWorklet = gen.mode === 'worklet'

  Object.defineProperty( ugen, 'value', {
    get() {
      if( this.memory.value.idx !== null ) {
        return gen.memory.heap[ this.memory.value.idx ]
      }else{
        return this.initialValue
      }
    },
    set( v ) {
      if( this.memory.value.idx !== null ) {
        if( this.isWorklet && this.waapi !== null ) {
          this.waapi.value = v
        }else{
          gen.memory.heap[ this.memory.value.idx ] = v
        } 
      }
    }
  })

  ugen.memory = {
    value: { length:1, idx:null }
  }

  return ugen
}

},{"./gen.js":44}],68:[function(require,module,exports){

const gen  = require('./gen.js'),
      dataUgen = require('./data.js')

let proto = {
  basename:'peek',

  gen() {
    let genName = 'gen.' + this.name,
        inputs = gen.getInputs( this ),
        out, functionBody, next, lengthIsLog2, idx
    
    idx = inputs[1]
    lengthIsLog2 = (Math.log2( this.data.buffer.length ) | 0)  === Math.log2( this.data.buffer.length )

    if( this.mode !== 'simple' ) {

    functionBody = `  var ${this.name}_dataIdx  = ${idx}, 
      ${this.name}_phase = ${this.mode === 'samples' ? inputs[0] : inputs[0] + ' * ' + (this.data.buffer.length) }, 
      ${this.name}_index = ${this.name}_phase | 0,\n`

    if( this.boundmode === 'wrap' ) {
      next = lengthIsLog2 ?
      `( ${this.name}_index + 1 ) & (${this.data.buffer.length} - 1)` :
      `${this.name}_index + 1 >= ${this.data.buffer.length} ? ${this.name}_index + 1 - ${this.data.buffer.length} : ${this.name}_index + 1`
    }else if( this.boundmode === 'clamp' ) {
      next = 
        `${this.name}_index + 1 >= ${this.data.buffer.length - 1} ? ${this.data.buffer.length - 1} : ${this.name}_index + 1`
    } else if( this.boundmode === 'fold' || this.boundmode === 'mirror' ) {
      next = 
        `${this.name}_index + 1 >= ${this.data.buffer.length - 1} ? ${this.name}_index - ${this.data.buffer.length - 1} : ${this.name}_index + 1`
    }else{
       next = 
      `${this.name}_index + 1`     
    }

    if( this.interp === 'linear' ) {      
    functionBody += `      ${this.name}_frac  = ${this.name}_phase - ${this.name}_index,
      ${this.name}_base  = memory[ ${this.name}_dataIdx +  ${this.name}_index ],
      ${this.name}_next  = ${next},`
      
      if( this.boundmode === 'ignore' ) {
        functionBody += `
      ${this.name}_out   = ${this.name}_index >= ${this.data.buffer.length - 1} || ${this.name}_index < 0 ? 0 : ${this.name}_base + ${this.name}_frac * ( memory[ ${this.name}_dataIdx + ${this.name}_next ] - ${this.name}_base )\n\n`
      }else{
        functionBody += `
      ${this.name}_out   = ${this.name}_base + ${this.name}_frac * ( memory[ ${this.name}_dataIdx + ${this.name}_next ] - ${this.name}_base )\n\n`
      }
    }else{
      functionBody += `      ${this.name}_out = memory[ ${this.name}_dataIdx + ${this.name}_index ]\n\n`
    }

    } else { // mode is simple
      functionBody = `memory[ ${idx} + ${ inputs[0] } ]`
      
      return functionBody
    }

    gen.memo[ this.name ] = this.name + '_out'

    return [ this.name+'_out', functionBody ]
  },

  defaults : { channels:1, mode:'phase', interp:'linear', boundmode:'wrap' }
}

module.exports = ( input_data, index=0, properties ) => {
  let ugen = Object.create( proto )

  //console.log( dataUgen, gen.data )

  // XXX why is dataUgen not the actual function? some type of browserify nonsense...
  const finalData = typeof input_data.basename === 'undefined' ? gen.lib.data( input_data ) : input_data

  Object.assign( ugen, 
    { 
      'data':     finalData,
      dataName:   finalData.name,
      uid:        gen.getUID(),
      inputs:     [ index, finalData ],
    },
    proto.defaults,
    properties 
  )
  
  ugen.name = ugen.basename + ugen.uid

  return ugen
}


},{"./data.js":30,"./gen.js":44}],69:[function(require,module,exports){
'use strict'

let gen   = require( './gen.js' ),
    accum = require( './accum.js' ),
    mul   = require( './mul.js' ),
    proto = { basename:'phasor' },
    div   = require( './div.js' )

const defaults = { min: -1, max: 1 }

module.exports = ( frequency = 1, reset = 0, _props ) => {
  const props = Object.assign( {}, defaults, _props )

  const range = props.max - props.min

  const ugen = typeof frequency === 'number' 
    ? accum( (frequency * range) / gen.samplerate, reset, props ) 
    : accum( 
        div( 
          mul( frequency, range ),
          gen.samplerate
        ), 
        reset, props 
    )

  ugen.name = proto.basename + gen.getUID()

  return ugen
}

},{"./accum.js":14,"./div.js":35,"./gen.js":44,"./mul.js":62}],70:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    mul  = require('./mul.js'),
    wrap = require('./wrap.js')

let proto = {
  basename:'poke',

  gen() {
    let dataName = 'memory',
        inputs = gen.getInputs( this ),
        idx, out, wrapped
    
    idx = this.data.gen()

    //gen.requestMemory( this.memory )
    //wrapped = wrap( this.inputs[1], 0, this.dataLength ).gen()
    //idx = wrapped[0]
    //gen.functionBody += wrapped[1]
    let outputStr = this.inputs[1] === 0 ?
      `  ${dataName}[ ${idx} ] = ${inputs[0]}\n` :
      `  ${dataName}[ ${idx} + ${inputs[1]} ] = ${inputs[0]}\n`

    if( this.inline === undefined ) {
      gen.functionBody += outputStr
    }else{
      return [ this.inline, outputStr ]
    }
  }
}
module.exports = ( data, value, index, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { channels:1 } 

  if( properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, { 
    data,
    dataName:   data.name,
    dataLength: data.buffer.length,
    uid:        gen.getUID(),
    inputs:     [ value, index ],
  },
  defaults )


  ugen.name = ugen.basename + ugen.uid
  
  gen.histories.set( ugen.name, ugen )

  return ugen
}

},{"./gen.js":44,"./mul.js":62,"./wrap.js":89}],71:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'pow',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) || isNaN( inputs[1] ) ) {
      gen.closures.add({ 'pow': isWorklet ? 'Math.pow' : Math.pow })

      out = `${ref}pow( ${inputs[0]}, ${inputs[1]} )` 

    } else {
      if( typeof inputs[0] === 'string' && inputs[0][0] === '(' ) {
        inputs[0] = inputs[0].slice(1,-1)
      }
      if( typeof inputs[1] === 'string' && inputs[1][0] === '(' ) {
        inputs[1] = inputs[1].slice(1,-1)
      }

      out = Math.pow( parseFloat( inputs[0] ), parseFloat( inputs[1]) )
    }
    
    return out
  }
}

module.exports = (x,y) => {
  let pow = Object.create( proto )

  pow.inputs = [ x,y ]
  pow.id = gen.getUID()
  pow.name = `${pow.basename}{pow.id}`

  return pow
}

},{"./gen.js":44}],72:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')
const proto = {
  basename:'process',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    gen.closures.add({ [''+this.funcname] : this.func })

    out = `  var ${this.name} = gen['${this.funcname}'](`

    inputs.forEach( (v,i,arr ) => {
      out += arr[ i ]
      if( i < arr.length - 1 ) out += ','
    })

    out += ')\n'

    gen.memo[ this.name ] = this.name

    return [this.name, out]
    
    return out
  }
}

module.exports = (...args) => {
  const process = {}// Object.create( proto )
  const id = gen.getUID()
  process.name = 'process' + id 

  process.func = new Function( ...args )

  //gen.globals[ process.name ] = process.func

  process.call = function( ...args  ) {
    const output = Object.create( proto )
    output.funcname = process.name
    output.func = process.func
    output.name = 'process_out_' + id
    output.process = process

    output.inputs = args

    return output
  }

  return process 
}

},{"./gen.js":44}],73:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' ),
    delta   = require( './delta.js' ),
    wrap    = require( './wrap.js' )

let proto = {
  basename:'rate',

  gen() {
    let inputs = gen.getInputs( this ),
        phase  = history(),
        inMinus1 = history(),
        genName = 'gen.' + this.name,
        filter, sum, out

    gen.closures.add({ [ this.name ]: this }) 

    out = 
` var ${this.name}_diff = ${inputs[0]} - ${genName}.lastSample
  if( ${this.name}_diff < -.5 ) ${this.name}_diff += 1
  ${genName}.phase += ${this.name}_diff * ${inputs[1]}
  if( ${genName}.phase > 1 ) ${genName}.phase -= 1
  ${genName}.lastSample = ${inputs[0]}
`
    out = ' ' + out

    return [ genName + '.phase', out ]
  }
}

module.exports = ( in1, rate ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    phase:      0,
    lastSample: 0,
    uid:        gen.getUID(),
    inputs:     [ in1, rate ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./add.js":17,"./delta.js":34,"./gen.js":44,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81,"./wrap.js":89}],74:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'round',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.round' : Math.round })

      out = `${ref}round( ${inputs[0]} )`

    } else {
      out = Math.round( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let round = Object.create( proto )

  round.inputs = [ x ]

  return round
}

},{"./gen.js":44}],75:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' )

let proto = {
  basename:'sah',

  gen() {
    let inputs = gen.getInputs( this ), out

    //gen.data[ this.name ] = 0
    //gen.data[ this.name + '_control' ] = 0

    gen.requestMemory( this.memory )


    out = 
` var ${this.name}_control = memory[${this.memory.control.idx}],
      ${this.name}_trigger = ${inputs[1]} > ${inputs[2]} ? 1 : 0

  if( ${this.name}_trigger !== ${this.name}_control  ) {
    if( ${this.name}_trigger === 1 ) 
      memory[${this.memory.value.idx}] = ${inputs[0]}
    
    memory[${this.memory.control.idx}] = ${this.name}_trigger
  }
`
    
    gen.memo[ this.name ] = `memory[${this.memory.value.idx}]`//`gen.data.${this.name}`

    return [ `memory[${this.memory.value.idx}]`, ' ' +out ]
  }
}

module.exports = ( in1, control, threshold=0, properties ) => {
  let ugen = Object.create( proto ),
      defaults = { init:0 }

  if( properties !== undefined ) Object.assign( defaults, properties )

  Object.assign( ugen, { 
    lastSample: 0,
    uid:        gen.getUID(),
    inputs:     [ in1, control,threshold ],
    memory: {
      control: { idx:null, length:1 },
      value:   { idx:null, length:1 },
    }
  },
  defaults )
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],76:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'selector',

  gen() {
    let inputs = gen.getInputs( this ), out, returnValue = 0
    
    switch( inputs.length ) {
      case 2 :
        returnValue = inputs[1]
        break;
      case 3 :
        out = `  var ${this.name}_out = ${inputs[0]} === 1 ? ${inputs[1]} : ${inputs[2]}\n\n`;
        returnValue = [ this.name + '_out', out ]
        break;  
      default:
        out = 
` var ${this.name}_out = 0
  switch( ${inputs[0]} + 1 ) {\n`

        for( let i = 1; i < inputs.length; i++ ){
          out +=`    case ${i}: ${this.name}_out = ${inputs[i]}; break;\n` 
        }

        out += '  }\n\n'
        
        returnValue = [ this.name + '_out', ' ' + out ]
    }

    gen.memo[ this.name ] = this.name + '_out'

    return returnValue
  },
}

module.exports = ( ...inputs ) => {
  let ugen = Object.create( proto )
  
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],77:[function(require,module,exports){
'use strict'

let gen   = require( './gen.js' ),
    accum = require( './accum.js' ),
    counter= require( './counter.js' ),
    peek  = require( './peek.js' ),
    ssd   = require( './history.js' ),
    data  = require( './data.js' ),
    proto = { basename:'seq' }

module.exports = ( durations = 11025, values = [0,1], phaseIncrement = 1) => {
  let clock
  
  if( Array.isArray( durations ) ) {
    // we want a counter that is using our current
    // rate value, but we want the rate value to be derived from
    // the counter. must insert a single-sample dealy to avoid
    // infinite loop.
    const clock2 = counter( 0, 0, durations.length )
    const __durations = peek( data( durations ), clock2, { mode:'simple' }) 
    clock = counter( phaseIncrement, 0, __durations )
    
    // add one sample delay to avoid codegen loop
    const s = ssd()
    s.in( clock.wrap )
    clock2.inputs[0] = s.out
  }else{
    // if the rate argument is a single value we don't need to
    // do anything tricky.
    clock = counter( phaseIncrement, 0, durations )
  }
  
  const stepper = accum( clock.wrap, 0, { min:0, max:values.length })
   
  const ugen = peek( data( values ), stepper, { mode:'simple' })

  ugen.name = proto.basename + gen.getUID()
  ugen.trigger = clock.wrap

  return ugen
}

},{"./accum.js":14,"./counter.js":28,"./data.js":30,"./gen.js":44,"./history.js":48,"./peek.js":68}],78:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  name:'sign',

  gen() {
    let out,
        inputs = gen.getInputs( this )

    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ this.name ]: isWorklet ? 'Math.sign' : Math.sign })

      out = `${ref}sign( ${inputs[0]} )`

    } else {
      out = Math.sign( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let sign = Object.create( proto )

  sign.inputs = [ x ]

  return sign
}

},{"./gen.js":44}],79:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'sin',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'sin': isWorklet ? 'Math.sin' : Math.sin })

      out = `${ref}sin( ${inputs[0]} )` 

    } else {
      out = Math.sin( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let sin = Object.create( proto )

  sin.inputs = [ x ]
  sin.id = gen.getUID()
  sin.name = `${sin.basename}{sin.id}`

  return sin
}

},{"./gen.js":44}],80:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    history = require( './history.js' ),
    sub     = require( './sub.js' ),
    add     = require( './add.js' ),
    mul     = require( './mul.js' ),
    memo    = require( './memo.js' ),
    gt      = require( './gt.js' ),
    div     = require( './div.js' ),
    _switch = require( './switch.js' )

module.exports = ( in1, slideUp = 1, slideDown = 1 ) => {
  let y1 = history(0),
      filter, slideAmount

  //y (n) = y (n-1) + ((x (n) - y (n-1))/slide) 
  slideAmount = _switch( gt(in1,y1.out), slideUp, slideDown )

  filter = memo( add( y1.out, div( sub( in1, y1.out ), slideAmount ) ) )

  y1.in( filter )

  return filter
}

},{"./add.js":17,"./div.js":35,"./gen.js":44,"./gt.js":45,"./history.js":48,"./memo.js":56,"./mul.js":62,"./sub.js":81,"./switch.js":82}],81:[function(require,module,exports){
'use strict'

const gen = require('./gen.js')

const proto = {
  basename:'sub',
  gen() {
    let inputs = gen.getInputs( this ),
        out=0,
        diff = 0,
        needsParens = false, 
        numCount = 0,
        lastNumber = inputs[ 0 ],
        lastNumberIsUgen = isNaN( lastNumber ), 
        subAtEnd = false,
        hasUgens = false,
        returnValue = 0

    this.inputs.forEach( value => { if( isNaN( value ) ) hasUgens = true })

    out = '  var ' + this.name + ' = '

    inputs.forEach( (v,i) => {
      if( i === 0 ) return

      let isNumberUgen = isNaN( v ),
          isFinalIdx   = i === inputs.length - 1

      if( !lastNumberIsUgen && !isNumberUgen ) {
        lastNumber = lastNumber - v
        out += lastNumber
        return
      }else{
        needsParens = true
        out += `${lastNumber} - ${v}`
      }

      if( !isFinalIdx ) out += ' - ' 
    })

    out += '\n'

    returnValue = [ this.name, out ]

    gen.memo[ this.name ] = this.name

    return returnValue
  }

}

module.exports = ( ...args ) => {
  let sub = Object.create( proto )

  Object.assign( sub, {
    id:     gen.getUID(),
    inputs: args
  })
       
  sub.name = 'sub' + sub.id

  return sub
}

},{"./gen.js":44}],82:[function(require,module,exports){
'use strict'

let gen = require( './gen.js' )

let proto = {
  basename:'switch',

  gen() {
    let inputs = gen.getInputs( this ), out

    if( inputs[1] === inputs[2] ) return inputs[1] // if both potential outputs are the same just return one of them
    
    out = `  var ${this.name}_out = ${inputs[0]} === 1 ? ${inputs[1]} : ${inputs[2]}\n`

    gen.memo[ this.name ] = `${this.name}_out`

    return [ `${this.name}_out`, out ]
  },

}

module.exports = ( control, in1 = 1, in2 = 0 ) => {
  let ugen = Object.create( proto )
  Object.assign( ugen, {
    uid:     gen.getUID(),
    inputs:  [ control, in1, in2 ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./gen.js":44}],83:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'t60',

  gen() {
    let out,
        inputs = gen.getInputs( this ),
        returnValue

    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ [ 'exp' ]: isWorklet ? 'Math.exp' : Math.exp })

      out = `  var ${this.name} = ${ref}exp( -6.907755278921 / ${inputs[0]} )\n\n`
     
      gen.memo[ this.name ] = out
      
      returnValue = [ this.name, out ]
    } else {
      out = Math.exp( -6.907755278921 / inputs[0] )

      returnValue = out
    }    

    return returnValue
  }
}

module.exports = x => {
  let t60 = Object.create( proto )

  t60.inputs = [ x ]
  t60.name = proto.basename + gen.getUID()

  return t60
}

},{"./gen.js":44}],84:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'tan',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'tan': isWorklet ? 'Math.tan' : Math.tan })

      out = `${ref}tan( ${inputs[0]} )` 

    } else {
      out = Math.tan( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let tan = Object.create( proto )

  tan.inputs = [ x ]
  tan.id = gen.getUID()
  tan.name = `${tan.basename}{tan.id}`

  return tan
}

},{"./gen.js":44}],85:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js')

let proto = {
  basename:'tanh',

  gen() {
    let out,
        inputs = gen.getInputs( this )
    
    
    const isWorklet = gen.mode === 'worklet'
    const ref = isWorklet? '' : 'gen.'

    if( isNaN( inputs[0] ) ) {
      gen.closures.add({ 'tanh': isWorklet ? 'Math.tan' : Math.tanh })

      out = `${ref}tanh( ${inputs[0]} )` 

    } else {
      out = Math.tanh( parseFloat( inputs[0] ) )
    }
    
    return out
  }
}

module.exports = x => {
  let tanh = Object.create( proto )

  tanh.inputs = [ x ]
  tanh.id = gen.getUID()
  tanh.name = `${tanh.basename}{tanh.id}`

  return tanh
}

},{"./gen.js":44}],86:[function(require,module,exports){
'use strict'

let gen     = require( './gen.js' ),
    lt      = require( './lt.js' ),
    accum   = require( './accum.js' ),
    div     = require( './div.js' )

module.exports = ( frequency=440, pulsewidth=.5 ) => {
  let graph = lt( accum( div( frequency, 44100 ) ), pulsewidth )

  graph.name = `train${gen.getUID()}`

  return graph
}


},{"./accum.js":14,"./div.js":35,"./gen.js":44,"./lt.js":52}],87:[function(require,module,exports){
'use strict'

const AWPF = require( './external/audioworklet-polyfill.js' ),
      gen  = require( './gen.js' ),
      data = require( './data.js' )

let isStereo = false

const utilities = {
  ctx: null,
  buffers: {},
  isStereo:false,

  clear() {
    if( this.workletNode !== undefined ) {
      this.workletNode.disconnect()
    }else{
      this.callback = () => 0
    }
    this.clear.callbacks.forEach( v => v() )
    this.clear.callbacks.length = 0

    this.isStereo = false

    if( gen.graph !== null ) gen.free( gen.graph )
  },

  createContext( bufferSize = 2048 ) {
    const AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext
    
    // tell polyfill global object and buffersize
    AWPF( window, bufferSize )

    const start = () => {
      if( typeof AC !== 'undefined' ) {
        this.ctx = new AC({ latencyHint:.0125 })

        gen.samplerate = this.ctx.sampleRate

        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
          window.removeEventListener( 'touchstart', start )
        }else{
          window.removeEventListener( 'mousedown', start )
          window.removeEventListener( 'keydown', start )
        }

        const mySource = utilities.ctx.createBufferSource()
        mySource.connect( utilities.ctx.destination )
        mySource.start()
      }
    }

    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
      window.addEventListener( 'touchstart', start )
    }else{
      window.addEventListener( 'mousedown', start )
      window.addEventListener( 'keydown', start )
    }

    return this
  },

  createScriptProcessor() {
    this.node = this.ctx.createScriptProcessor( 1024, 0, 2 )
    this.clearFunction = function() { return 0 }
    if( typeof this.callback === 'undefined' ) this.callback = this.clearFunction

    this.node.onaudioprocess = function( audioProcessingEvent ) {
      var outputBuffer = audioProcessingEvent.outputBuffer;

      var left = outputBuffer.getChannelData( 0 ),
          right= outputBuffer.getChannelData( 1 ),
          isStereo = utilities.isStereo

     for( var sample = 0; sample < left.length; sample++ ) {
        var out = utilities.callback()

        if( isStereo === false ) {
          left[ sample ] = right[ sample ] = out 
        }else{
          left[ sample  ] = out[0]
          right[ sample ] = out[1]
        }
      }
    }

    this.node.connect( this.ctx.destination )

    return this
  },

  // remove starting stuff and add tabs
  prettyPrintCallback( cb ) {
    // get rid of "function gen" and start with parenthesis
    // const shortendCB = cb.toString().slice(9)
    const cbSplit = cb.toString().split('\n')
    const cbTrim = cbSplit.slice( 3, -2 )
    const cbTabbed = cbTrim.map( v => '      ' + v ) 
    
    return cbTabbed.join('\n')
  },

  createParameterDescriptors( cb ) {
    // [{name: 'amplitude', defaultValue: 0.25, minValue: 0, maxValue: 1}];
    let paramStr = ''

    //for( let ugen of cb.params.values() ) {
    //  paramStr += `{ name:'${ugen.name}', defaultValue:${ugen.value}, minValue:${ugen.min}, maxValue:${ugen.max} },\n      `
    //}
    for( let ugen of cb.params.values() ) {
      paramStr += `{ name:'${ugen.name}', automationRate:'k-rate', defaultValue:${ugen.defaultValue}, minValue:${ugen.min}, maxValue:${ugen.max} },\n      `
    }
    return paramStr
  },

  createParameterDereferences( cb ) {
    let str = cb.params.size > 0 ? '\n      ' : ''
    for( let ugen of cb.params.values() ) {
      str += `const ${ugen.name} = parameters.${ugen.name}[0]\n      `
    }

    return str
  },

  createParameterArguments( cb ) {
    let  paramList = ''
    for( let ugen of cb.params.values() ) {
      paramList += ugen.name + '[i],'
    }
    paramList = paramList.slice( 0, -1 )

    return paramList
  },

  createInputDereferences( cb ) {
    let str = cb.inputs.size > 0 ? '\n' : ''
    for( let input of  cb.inputs.values() ) {
      str += `const ${input.name} = inputs[ ${input.inputNumber} ][ ${input.channelNumber} ]\n      `
    }

    return str
  },


  createInputArguments( cb ) {
    let  paramList = ''
    for( let input of cb.inputs.values() ) {
      paramList += input.name + '[i],'
    }
    paramList = paramList.slice( 0, -1 )

    return paramList
  },
      
  createFunctionDereferences( cb ) {
    let memberString = cb.members.size > 0 ? '\n' : ''
    let memo = {}
    for( let dict of cb.members.values() ) {
      const name = Object.keys( dict )[0],
            value = dict[ name ]

      if( memo[ name ] !== undefined ) continue
      memo[ name ] = true

      memberString += `      const ${name} = ${value}\n`
    }

    return memberString
  },

  createWorkletProcessor( graph, name, debug, mem=44100*10 ) {
    //const mem = MemoryHelper.create( 4096, Float64Array )
    const cb = gen.createCallback( graph, mem, debug )
    const inputs = cb.inputs

    // get all inputs and create appropriate audioparam initializers
    const parameterDescriptors = this.createParameterDescriptors( cb )
    const parameterDereferences = this.createParameterDereferences( cb )
    const paramList = this.createParameterArguments( cb )
    const inputDereferences = this.createInputDereferences( cb )
    const inputList = this.createInputArguments( cb )   
    const memberString = this.createFunctionDereferences( cb )

    // change output based on number of channels.
    const genishOutputLine = cb.isStereo === false
      ? `left[ i ] = memory[0]`
      : `left[ i ] = memory[0];\n\t\tright[ i ] = memory[1]\n`

    const prettyCallback = this.prettyPrintCallback( cb )

    /***** begin callback code ****/
    // note that we have to check to see that memory has been passed
    // to the worker before running the callback function, otherwise
    // it can be passed too slowly and fail on occassion

    const workletCode = `
class ${name}Processor extends AudioWorkletProcessor {

  static get parameterDescriptors() {
    const params = [
      ${ parameterDescriptors }      
    ]
    return params
  }
 
  constructor( options ) {
    super( options )
    this.port.onmessage = this.handleMessage.bind( this )
    this.initialized = false
  }

  handleMessage( event ) {
    if( event.data.key === 'init' ) {
      this.memory = event.data.memory
      this.initialized = true
    }else if( event.data.key === 'set' ) {
      this.memory[ event.data.idx ] = event.data.value
    }else if( event.data.key === 'get' ) {
      this.port.postMessage({ key:'return', idx:event.data.idx, value:this.memory[event.data.idx] })     
    }
  }

  process( inputs, outputs, parameters ) {
    if( this.initialized === true ) {
      const output = outputs[0]
      const left   = output[ 0 ]
      const right  = output[ 1 ]
      const len    = left.length
      const memory = this.memory ${parameterDereferences}${inputDereferences}${memberString}

      for( let i = 0; i < len; ++i ) {
        ${prettyCallback}
        ${genishOutputLine}
      }
    }
    return true
  }
}
    
registerProcessor( '${name}', ${name}Processor)`

    
    /***** end callback code *****/


    if( debug === true ) console.log( workletCode )

    const url = window.URL.createObjectURL(
      new Blob(
        [ workletCode ], 
        { type: 'text/javascript' }
      )
    )

    return [ url, workletCode, inputs, cb.params, cb.isStereo ] 
  },

  registeredForNodeAssignment: [],
  register( ugen ) {
    if( this.registeredForNodeAssignment.indexOf( ugen ) === -1 ) {
      this.registeredForNodeAssignment.push( ugen )
    }
  },

  playWorklet( graph, name, debug=false, mem=44100 * 60 ) {
    utilities.clear()

    const [ url, codeString, inputs, params, isStereo ] = utilities.createWorkletProcessor( graph, name, debug, mem )

    const nodePromise = new Promise( (resolve,reject) => {
   
      utilities.ctx.audioWorklet.addModule( url ).then( ()=> {
        const workletNode = new AudioWorkletNode( utilities.ctx, name, { outputChannelCount:[ isStereo ? 2 : 1 ] })

        workletNode.callbacks = {}
        workletNode.onmessage = function( event ) {
          if( event.data.message === 'return' ) {
            workletNode.callbacks[ event.data.idx ]( event.data.value )
            delete workletNode.callbacks[ event.data.idx ]
          }
        }

        workletNode.getMemoryValue = function( idx, cb ) {
          this.workletCallbacks[ idx ] = cb
          this.workletNode.port.postMessage({ key:'get', idx: idx })
        }
        
        workletNode.port.postMessage({ key:'init', memory:gen.memory.heap })
        utilities.workletNode = workletNode

        utilities.registeredForNodeAssignment.forEach( ugen => ugen.node = workletNode )
        utilities.registeredForNodeAssignment.length = 0

        // assign all params as properties of node for easier reference 
        for( let dict of inputs.values() ) {
          const name = Object.keys( dict )[0]
          const param = workletNode.parameters.get( name )
      
          Object.defineProperty( workletNode, name, {
            set( v ) {
              param.value = v
            },
            get() {
              return param.value
            }
          })
        }

        for( let ugen of params.values() ) {
          const name = ugen.name
          const param = workletNode.parameters.get( name )
          ugen.waapi = param 
          // initialize?
          param.value = ugen.defaultValue

          Object.defineProperty( workletNode, name, {
            set( v ) {
              param.value = v
            },
            get() {
              return param.value
            }
          })
        }

        if( utilities.console ) utilities.console.setValue( codeString )

        workletNode.connect( utilities.ctx.destination )

        resolve( workletNode )
      })

    })

    return nodePromise
  },
  
  playGraph( graph, debug, mem=44100*10, memType=Float32Array ) {
    utilities.clear()
    if( debug === undefined ) debug = false
          
    this.isStereo = Array.isArray( graph )

    utilities.callback = gen.createCallback( graph, mem, debug, false, memType )
    
    if( utilities.console ) utilities.console.setValue( utilities.callback.toString() )

    return utilities.callback
  },

  loadSample( soundFilePath, data ) {
    const isLoaded = utilities.buffers[ soundFilePath ] !== undefined

    let req = new XMLHttpRequest()
    req.open( 'GET', soundFilePath, true )
    req.responseType = 'arraybuffer' 
    
    let promise = new Promise( (resolve,reject) => {
      if( !isLoaded ) {
        req.onload = function() {
          var audioData = req.response

          utilities.ctx.decodeAudioData( audioData, (buffer) => {
            data.buffer = buffer.getChannelData(0)
            utilities.buffers[ soundFilePath ] = data.buffer
            resolve( data.buffer )
          })
        }
      }else{
        setTimeout( ()=> resolve( utilities.buffers[ soundFilePath ] ), 0 )
      }
    })

    if( !isLoaded ) req.send()

    return promise
  }

}

utilities.clear.callbacks = []

module.exports = utilities

},{"./data.js":30,"./external/audioworklet-polyfill.js":39,"./gen.js":44}],88:[function(require,module,exports){
'use strict'

/*
 * many windows here adapted from https://github.com/corbanbrook/dsp.js/blob/master/dsp.js
 * starting at line 1427
 * taken 8/15/16
*/ 

const windows = module.exports = { 
  bartlett( length, index ) {
    return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2)) 
  },

  bartlettHann( length, index ) {
    return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos( 2 * Math.PI * index / (length - 1))
  },

  blackman( length, index, alpha ) {
    let a0 = (1 - alpha) / 2,
        a1 = 0.5,
        a2 = alpha / 2

    return a0 - a1 * Math.cos(2 * Math.PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1))
  },

  cosine( length, index ) {
    return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2)
  },

  gauss( length, index, alpha ) {
    return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2))
  },

  hamming( length, index ) {
    return 0.54 - 0.46 * Math.cos( Math.PI * 2 * index / (length - 1))
  },

  hann( length, index ) {
    return 0.5 * (1 - Math.cos( Math.PI * 2 * index / (length - 1)) )
  },

  lanczos( length, index ) {
    let x = 2 * index / (length - 1) - 1;
    return Math.sin(Math.PI * x) / (Math.PI * x)
  },

  rectangular( length, index ) {
    return 1
  },

  triangular( length, index ) {
    return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2))
  },

  // parabola
  welch( length, _index, ignore, shift=0 ) {
    //w[n] = 1 - Math.pow( ( n - ( (N-1) / 2 ) ) / (( N-1 ) / 2 ), 2 )
    const index = shift === 0 ? _index : (_index + Math.floor( shift * length )) % length
    const n_1_over2 = (length - 1) / 2 

    return 1 - Math.pow( ( index - n_1_over2 ) / n_1_over2, 2 )
  },
  inversewelch( length, _index, ignore, shift=0 ) {
    //w[n] = 1 - Math.pow( ( n - ( (N-1) / 2 ) ) / (( N-1 ) / 2 ), 2 )
    let index = shift === 0 ? _index : (_index + Math.floor( shift * length )) % length
    const n_1_over2 = (length - 1) / 2

    return Math.pow( ( index - n_1_over2 ) / n_1_over2, 2 )
  },

  parabola( length, index ) {
    if( index <= length / 2 ) {
      return windows.inversewelch( length / 2, index ) - 1
    }else{
      return 1 - windows.inversewelch( length / 2, index - length / 2 )
    }
  },

  exponential( length, index, alpha ) {
    return Math.pow( index / length, alpha )
  },

  linear( length, index ) {
    return index / length
  }
}

},{}],89:[function(require,module,exports){
'use strict'

let gen  = require('./gen.js'),
    floor= require('./floor.js'),
    sub  = require('./sub.js'),
    memo = require('./memo.js')

let proto = {
  basename:'wrap',

  gen() {
    let code,
        inputs = gen.getInputs( this ),
        signal = inputs[0], min = inputs[1], max = inputs[2],
        out, diff

    //out = `(((${inputs[0]} - ${this.min}) % ${diff}  + ${diff}) % ${diff} + ${this.min})`
    //const long numWraps = long((v-lo)/range) - (v < lo);
    //return v - range * double(numWraps);   
    
    if( this.min === 0 ) {
      diff = max
    }else if ( isNaN( max ) || isNaN( min ) ) {
      diff = `${max} - ${min}`
    }else{
      diff = max - min
    }

    out =
` var ${this.name} = ${inputs[0]}
  if( ${this.name} < ${this.min} ) ${this.name} += ${diff}
  else if( ${this.name} > ${this.max} ) ${this.name} -= ${diff}

`

    return [ this.name, ' ' + out ]
  },
}

module.exports = ( in1, min=0, max=1 ) => {
  let ugen = Object.create( proto )

  Object.assign( ugen, { 
    min, 
    max,
    uid:    gen.getUID(),
    inputs: [ in1, min, max ],
  })
  
  ugen.name = `${ugen.basename}${ugen.uid}`

  return ugen
}

},{"./floor.js":41,"./gen.js":44,"./memo.js":56,"./sub.js":81}],90:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":12,"has":216,"has-symbols":213}],91:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Analysis = {
  create( Audio ) {
    const analysis = {}

    for( let analysisName in Gibberish.analysis ) {
      const gibberishConstructor = Gibberish.analysis[ analysisName ]

      const methods = Analysis.descriptions[ analysisName ] === undefined ? null : Analysis.descriptions[ analysisName ].methods
      const description = { 
        properties: { type:'analysis' },
        name:analysisName,
        methods,
        category:'analysis'
      }

      const constructor = Ugen( gibberishConstructor, description, Audio, false, true )
      analysis[ analysisName ] = function( ...args ) {
        const ugen = constructor( ...args )
        Gibberish.worklet.ugens.set( ugen.id, ugen )
        ugen.out = ugen.__wrapped__.out
        
        if( analysisName === 'Follow' ) {
          let m = ugen.__wrapped__.multiplier || 1
          Object.defineProperty( ugen, 'multiplier', {
            configurable:true,
            get() { return m },
            set(v) { m = v; ugen.__wrapped__.multiplier = m }
          }) 
          let o = ugen.__wrapped__.offset || 0
          Object.defineProperty( ugen, 'offset', {
            configurable:true,
            get() { return o },
            set(v) { o = v; ugen.__wrapped__.offset = o }
          }) 
        }
        return ugen
      } 

    }
    return analysis
  },

  descriptions: {
    //SSD: { methods:[ 'listen' ] }
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Analysis 

},{"./ugen.js":128,"gibberish-dsp":174}],92:[function(require,module,exports){
const Gibberish   = require( 'gibberish-dsp' )
const Ugen        = require( './ugen.js' )
const Instruments = require( './instruments.js' )
const Oscillators = require( './oscillators.js' )
const Effects     = require( './effects.js' )
const Filters     = require( './filters.js' )
const Binops      = require( './binops.js' )
const Analysis    = require( './analysis.js' )
const Envelopes   = require( './envelopes.js' )
const Busses      = require( './busses.js' )
const Ensemble    = require( './ensemble.js' )
const Utility     = require( './utility.js' )
const Freesound   = require( './freesound.js' )
const Gen         = require( './gen.js' )
const WavePattern = require( './wavePattern.js' )
const WaveObjects = require( './waveObjects.js' )
//const Core        = require( 'gibber.core.lib' )
const AWPF        = require( './external/audioworklet-polyfill.js' )
//const Arp         = require( './arp.js' )

const Audio = {
  Clock: require( './clock.js' ),
  Theory: require( './theory.js' ),
  Presets: require( './presets.js' ),
  __Make: require( './make.js' ),
  initialized:false,
  autoConnect:true,
  shouldDelay:false,
  instruments:{},
  oscillators:{},
  effects:{},
  exportTarget:null,

  export( obj ) {
    if( Audio.initialized ){ 
      Object.assign( 
        obj, 
        this.instruments, 
        this.oscillators,
        this.effects,
        this.filters,
        this.busses, 
        this.envelopes, 
        this.waveObjects, 
        this.binops, 
        this.analysis 
      )
      
      Utility.export( obj )
      this.Gen.export( obj )

      obj.Gibberish = this.Gibberish

      obj.gen = this.Gen.make
      obj.lfo = this.Gen.composites.lfo
      obj.Ensemble = this.Ensemble
      obj.Drums = this.Drums
      obj.EDrums = this.EDrums
      obj.Theory = this.Theory
      obj.Freesound = this.Freesound
      obj.Clock = this.Clock
      obj.Clock.export( obj )
      obj.WavePattern = this.WavePattern
      obj.Gen = this.Gen
      obj.stop = this.stop

      obj.Out = this.Out
      obj.Make = this.Make
      obj.future = this.Gibberish.utilities.future
    }else{
      Audio.exportTarget = obj
    } 
  },

  __defaults : {
    workletPath: '../dist/gibberish_worklet.js',
    ctx:         null,
    bufferSize:  2048,
    latencyHint: .05
  },

  init( options, Gibber  ) {
    let { workletPath, ctx, bufferSize, latencyHint } = Object.assign( {}, this.__defaults, options ) 
    this.Gibber = Gibber
    this.Core = Gibber

    // XXX should probably just call Audio.Core.createProperty to avoid confusion...
    this.createProperty = Gibber.createProperty

    Gibber.Audio = this
    this.Gibberish = Gibberish

    Gibberish.workletPath = workletPath 

    this.createPubSub()

    const AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext
    window.AudioContext = AC
    AWPF( window, bufferSize ) 

    const p = new Promise( (resolve, reject) => {
      if( ctx === null ) {
        ctx = new AC({ latencyHint })
        //ctx = new AudioContext()
      }

      Gibberish.init( 44100*60*20, ctx ).then( processorNode => {
        // XXX remove once gibber.core.lib has been properly integrated 
        Audio.Core.Audio = Audio.Core.audio = Audio

        Audio.Gibberish = Gibberish

        Audio.initialized = true
        Audio.node = processorNode
        Audio.Ugen = Ugen
        Audio.Make = Audio.__Make( Audio )
        Audio.Gen = Gen( Audio )
        Audio.Gen.init()
        Audio.Gen.export( Audio.Gen.ugens )
        Audio.Theory.init( window.Gibber )
        Audio.Utilities = Utility
        Audio.WavePattern = WavePattern( Audio )
        Audio.ctx = ctx
        Audio.Out = Gibberish.output
        
        // must wait for Gen to be initialized
        Audio.Clock.init( Audio.Gen, Audio )

        Audio.createUgens()
        
        if( Audio.exportTarget !== null ) Audio.export( Audio.exportTarget )

        Gibberish.worklet.port.__postMessage = Gibberish.worklet.port.postMessage

        Gibberish.worklet.port.postMessage = function( dict ) {
          if( Audio.shouldDelay === true ) dict.delay = true

          Gibberish.worklet.port.__postMessage( dict )
        }

        Audio.export( window )

        //const drums = Audio.Drums('x*o-')
        //drums.disconnect()
        //drums.stop()

        // store last location in memory... we can clear everything else in Gibber.clear9)
        const memIdx = Object.keys( Gibberish.memory.list ).reverse()[0]
        this.__memoryEnd = parseInt( memIdx ) + Gibberish.memory.list[ memIdx ]

        // XXX this forces the gibberish scheduler to start
        // running, but it's about as hacky as it can get...
        //const __start = Audio.instruments.Synth().connect()
        //__start.disconnect()

        //Audio.Gibberish.genishi.gen.histories.clear()
        Audio.clear()

        resolve( [Audio,'Audio'] )
      })
    })
    
    return p
  },

  restart() {
    Gibber.clear()
    Gibberish.worklet.port.close()
    window.w = Gibberish.worklet
    Gibberish.worklet.disconnect()

    Gibberish.init( 44100*60*20, undefined, 'worklet', true ).then( processorNode => {
      Audio.out = Gibberish.output
      Audio.node = processorNode

      Audio.Theory.deleteProperties()
      Audio.Theory.init( window.Gibber )

      Audio.initialized = true
      Audio.node = processorNode
      Audio.Out = Gibberish.output

      Audio.Make = Audio.__Make( Audio )
      Audio.Gen = Gen( Audio )
      Audio.Gen.init()
      Audio.Gen.export( Audio.Gen.ugens )

      Audio.WavePattern = WavePattern( Audio )
      Audio.createUgens()
        
      Audio.Clock.init( Audio.Gen, Audio )

      Gibberish.worklet.port.__postMessage = Gibberish.worklet.port.postMessage
      Gibberish.worklet.port.postMessage = function( dict ) {
        if( Audio.shouldDelay === true ) dict.delay = true

        Gibberish.worklet.port.__postMessage( dict )
      }

      Audio.export( window )
      Gibber.export( window )

      const memIdx = Object.keys( Gibberish.memory.list ).reverse()[0]
      this.__memoryEnd = parseInt( memIdx ) + Gibberish.memory.list[ memIdx ]

      // XXX this forces the gibberish scheduler to start
      // running, but it's about as hacky as it can get...
      const __start = Audio.instruments.Synth().connect()
      __start.disconnect()

      //Audio.Gibberish.genishi.gen.histories.clear()

      //Audio.clear()
      console.log( 'audio engine successfully restarted.' )
      Audio.publish( 'restart' )
    })
  },

  // XXX stop clock from being cleared.
  clear() { 
    Gibberish.clear() 
    Audio.Clock.init( Audio.Gen, Audio )

    // the idea is that we only clear memory that was filled after
    // the initial Gibber initialization... this stops objects
    // like Clock and Theory from having their memory cleared and
    // from having to re-initialize them.

    // fill memory with zeros from the end initialization block onwards
    Gibberish.memory.heap.fill( 0, this.__memoryEnd )

    // get locations of all memory blocks
    const memKeys = Object.keys( Gibberish.memory.list )

    // get idx of final initialization block
    const endIdx =  memKeys.indexOf( ''+this.__memoryEnd )

    // loop through all blocks after final initialzation block
    // and delete them in the memory list... they've already
    // been zeroed out.
    for( let i = endIdx; i < memKeys.length; i++ ) {
      delete Gibberish.memory.list[ memKeys[ i ] ]
    }
    
    Audio.publish('clear')
  },

  stop() {
    Gibber.Seq.sequencers.forEach( s => s.stop() )
  },

  start() {
    Gibber.Seq.sequencers.forEach( s => s.start() )
  },
  onload() {},

  createUgens() {
    //Core.export( this, this )

    this.Freesound = Freesound( this )
    this.binops = Binops.create( this )
    this.analysis = Analysis.create( this )
    this.oscillators = Oscillators.create( this )
    this.instruments = Instruments.create( this ) 
    this.envelopes   = Envelopes.create( this )
    this.filters     = Filters.create( this )
    this.effects = Effects.create( this )
    this.busses = Busses.create( this )
    this.Ensemble = Ensemble( this )
    this.waveObjects = WaveObjects( this )

    const Pattern = this.Core.__Pattern
    Pattern.transfer( this, Pattern.toString() )

    
    const drums = require( './drums.js' )( this )
    Object.assign( this, drums )
  },

  printcb() { 
    Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'callback' }) 
  },
  printobj( obj ) {
    Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'print', object:obj.id }) 
  },
  send( msg ){
    Gibber.Audio.Gibberish.worklet.port.postMessage( msg )
  },

  createPubSub() {
    const events = this.pubevents = {}
    this.subscribe = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
    }

    this.unsubscribe = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
    }

    this.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
    }
  },

  createMapping( from, to, name, wrappedTo ) {
    if( from.__useMapping === false ) {
      to[ name ].value = from
    }else if( from.type === 'audio' ) {
      const f = to[ '__' + name ].follow = Follow({ input: from })

      let m = f.multiplier
      Object.defineProperty( to[ name ], 'multiplier', {
        get() { return m },
        set(v) { m = v; f.multiplier = m }
      })

      let o = f.offset
      Object.defineProperty( to[ name ], 'offset', {
        get() { return o },
        set(v) { o = v; f.offset = o }
      })

      wrappedTo[ name ] = f
      //to[ '__'+name].value = f

    }else if( from.type === 'gen' ) {
      // gen objects can be referred to without the graphics/audio abstraction,
      // in which case they will have no .render() function, and don't need to be rendered
      const gen = from.render !== undefined ? from.render() : from

      wrappedTo[ name ] = gen
    }
  },

  createGetter( obj, name ) { return () => obj[ '__' + name ] },

  createSetter( obj, name, post, transform=null, isPoly=false ) {
    if( typeof obj.__wrapped__ === 'object' ) {
      let desc = Object.getOwnPropertyDescriptor( obj.__wrapped__, name )

      if( desc !== undefined ) {
        Object.defineProperty( obj.__wrapped__, name,  {
          configurable:true,
          set(v) {
            obj[ '__'+name ].value = v
            if( desc.set ) {
              desc.set( v )
            }else{
              obj.__wrapped__.value = v
            }
          }
        })
      }
    }
    const setter = v => {
      let value, shouldSend = true


      if( typeof v === 'number' || typeof v === 'string' || v === null ) {
        value = transform !== null ? transform( v ) : v

        if( isPoly === true ) {
          const __wrappedObject = obj.__wrapped__
          const voice = __wrappedObject.voices[ __wrappedObject.voiceCount % __wrappedObject.voices.length ]
          voice[ name ] = value

          shouldSend = false

          Gibberish.worklet.port.postMessage({
            address:'property',
            object:voice.id,
            name,
            value
          }) 

        }else{
          obj[ '__'+name].value = v
        }
      }else if( typeof v === 'object' && v !== null && v.type === 'gen' ) {
        // gen objects can be referred to without the graphics/audio abstraction,
        // in which case they will have no .render() function, and don't need to be rendered

        v = transform !== null ? transform( v ) : v       
        const gen = v.render !== undefined ? v.render() : v 

        obj['__'+ name ].value = gen 
        value = { id: gen.id }
      }else if( typeof v === 'object' ) { //&& typeof v !== null ) {
        //if( obj.__useMapping === false || name === 'input' ) {
        //  obj[ '__'+name].value = v
        //  value = v !== null ? { id:v.id } : v
        //}else{
        //  //Audio.createMapping( v, obj, name, obj.__wrapped__ )
        //  const f = obj[ '__' + name ].follow = Follow({ input: v })

        //  let m = f.multiplier
        //  Object.defineProperty( obj[ name ], 'multiplier', {
        //    get() { return m },
        //    set(v) { m = v; f.multiplier = m }
        //  })

        //  let o = f.offset
        //  Object.defineProperty( obj[ name ], 'offset', {
        //    get() { return o },
        //    set(v) { o = v; f.offset = o }
        //  })

          //wrappedTo[ name ] = f
          //obj[ '__'+name ].value = f.__wrapped__
          //value = { id:f.id }
          obj[ '__'+name ].value = v.__wrapped__
          value = { id:v.id }
        //}
               //
        //obj[ '__'+name].value = v
        //value = v !== null ? { id:v.id } : v
      }

      if( Gibberish.mode === 'worklet' && shouldSend === true ) {
        Gibberish.worklet.port.postMessage({
          address:'property',
          object:obj.id,
          name,
          value
        }) 
      }
      if( post !== null ) {
        post.call( obj )
      }     
      if( Gibberish.mode === 'worklet' ) Audio.publish( `property.set:${obj.id}`, obj, v )
    }

    return setter
  },

  createFade( from=null, to=null, time=1, obj, name, delay=0 ) {
    if( from === null ) from = obj[ name ].value
    if( to === null ) to = obj[ name ].value

    time = Audio.Clock.time( time )

    // XXX only covers condition where ramps from fades are assigned...
    // does this need to be more generic?
    if( isNaN( from ) && from.__wrapped__.ugenName.indexOf('ramp') > -1 ) {
      from = from.to.value
    }
    if( isNaN( to ) && to.__wrapped__.ugenName.indexOf('ramp') > -1 ) {
      to = to.to.value
    }

    let ramp = Audio.envelopes.Ramp({ from, to, length:time, shouldLoop:false })
    // this is a key to not use an envelope follower for mapping
    ramp.__useMapping = false

    if( delay === 0 ) {
      obj[ name ] = ramp
    } else {
      future( (obj,name,ramp) => { 
        obj[ name ] = ramp 
      }, delay, { obj, name, ramp:ramp.__wrapped__ } )
    }

    if( ramp.__wrapped__ === undefined ) ramp.__wrapped__ = {}
    ramp.__wrapped__.values = []

    ramp.__wrapped__.output = v => {
      if( ramp.__wrapped__ !== undefined ) {
        ramp.__wrapped__.values.unshift( v )
        while( ramp.__wrapped__.values.length > 60 ) ramp.__wrapped__.values.pop()
      }
    }

    ramp.__wrapped__.finalize = () => {
      const store = ramp.__wrapped__

      // XXX I can't quite figure out why I have to wait to reset the property 
      // value here... if I don't, then the fade ugen stays assigned in the worklet processor.
      // and 0 doesn't work!
      setTimeout( ()=> obj[ name ] = store.to === 0 ? .000001 : store.to, 0 )
      store.widget.clear()
    }

    ramp.__wrapped__.from = from
    ramp.__wrapped__.to = to

    return obj
  },

  // what properties should be automatically (automagickally?)
  // filtered through Audio.Clock.time()?
  timeProps : {
    Synth:[ 'attack', 'decay', 'sustain', 'release' ],
    PolySynth:[ 'attack', 'decay', 'sustain', 'release' ],
    Complex:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyComplex:[ 'attack', 'decay', 'sustain', 'release' ],
    FM:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyFM:[ 'attack', 'decay', 'sustain', 'release' ],
    Monosynth:[ 'attack', 'decay', 'sustain', 'release' ],
    PolyMono:[ 'attack', 'decay', 'sustain', 'release' ],
    Delay:[ 'time' ], 
  }
}

module.exports = Audio

},{"./analysis.js":91,"./binops.js":93,"./busses.js":94,"./clock.js":95,"./drums.js":96,"./effects.js":97,"./ensemble.js":98,"./envelopes.js":99,"./external/audioworklet-polyfill.js":100,"./filters.js":103,"./freesound.js":104,"./gen.js":105,"./instruments.js":106,"./make.js":107,"./oscillators.js":108,"./presets.js":109,"./theory.js":127,"./ugen.js":128,"./utility.js":129,"./waveObjects.js":130,"./wavePattern.js":131,"gibberish-dsp":174}],93:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Binops = {
  create( Audio ) {
    const binops = {}

    for( let binopName in Gibberish.binops ) {
      const gibberishConstructor = Gibberish.binops[ binopName ]

      const methods = Binops.descriptions[ binopName ] === undefined ? null : Binops.descriptions[ binopName ].methods
      const description = { 
        properties:gibberishConstructor.defaults,
        methods:methods,
        name:binopName,
        category:'binops'
      }
      description.properties.type = 'binop'

      const constructor = Ugen( gibberishConstructor, description, Audio, false, true )
      binops[ binopName ] = function( ...args ) {
        const ugen = constructor( ...args )
        ugen[0] = ugen.__wrapped__[0]
        ugen[1] = ugen.__wrapped__[1]

        return ugen
      } 
    }
    return binops
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Binops

},{"./ugen.js":128,"gibberish-dsp":174}],94:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Busses = {
  create( Audio ) {
    const busses = {}

    const busDescription = { 
      properties:Gibberish.Bus.defaults,
      methods:null,
      name:'Bus',
      category:'misc'
    }

    busses.Bus = Ugen( Gibberish.Bus, busDescription, Audio )
    busses.__Bus = function( ...args ) {
      let props
      if( args.length > 1 || args.length === 1 && typeof args[0] !== 'string' ) {
        props = { inputs:args }
      }else if( args.length === 1 ) {
        props = args[0]
      }
      
      return props !== undefined ? busses.__Bus( props ) : busses.__Bus()
    }

    const bus2Description = { 
      properties:Gibberish.Bus2.defaults,
      methods:null,
      name:'Bus2',
      category:'misc'
    }

    busses.Bus2 = Ugen( Gibberish.Bus2, bus2Description, Audio )
    busses.__Bus2 = function( ...args ) {
      let props
      if( args.length > 1 || (args.length === 1 && typeof args[0] !== 'string' && args[0].type !== 'ensemble' )) {
        props = { inputs:args }
      }else if( args.length === 1 ) {
        props = args[0]
      }
      
      return props !== undefined ? busses.__Bus2( props ) : busses.__Bus2()
    }

    return busses
  }
}

module.exports = Busses

},{"./ugen.js":128,"gibberish-dsp":174}],95:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const serialize = require( 'serialize-javascript' )

// XXX must use form key:function() {} due to serialization
const Clock = {
  __beatCount:0,
  id:null,
  nogibberish:true,
  bpm:140,
  __lastBPM:140,
  seq:null,

  export:function( obj ) {
    obj.btos = Clock.btos.bind( Clock )
    obj.btoms = Clock.btoms.bind( Clock )
    obj.stob = Clock.stob.bind( Clock )
  },

  store:function() { 
    Gibberish.Clock = this
    this.beatCount = 0
    this.queue = []
    this.init()
  },

  addToQueue:function( ...args ) {
    if( Gibberish.mode === 'processor' ) {
      args = args[0]
      args.forEach( v => Gibberish.Clock.queue.push( v ) )
    }else{
      Gibberish.worklet.port.postMessage({
        address: 'method',
        object: this.id,
        name: 'addToQueue',
        args: serialize( args ),
        functions: true
      }) 
    }
  },

  init:function( Gen, Audio ) {
    // needed so that when the clock is re-initialized (for example, after clearing)
    // gibber won't try and serialized its sequencer
    this.seq = null

    const clockFunc = ()=> {
      Gibberish.worklet.port.postMessage({
        address: 'beat',
        value: this.beatCount
      }) 

      if( this.beatCount++ % 4 === 0 ) {
        Gibberish.processor.playQueue()//.forEach( f => { f() } )
      }
    }

    if( Gibberish.mode === 'worklet' ) {
      this.id = Gibberish.utilities.getUID()
      this.audioClock = null
      this.__rate = null

      Gibberish.worklet.port.postMessage({
        address:'add',
        properties:serialize( Clock ),
        id:this.id,
        post: 'store'    
      })
      
      let bpm = this.__lastBPM
      Object.defineProperty( this, 'bpm', {
        get() { return bpm },
        set(v){ 
          bpm = v
          if( Gibberish.mode === 'worklet' ) {
            this.__lastBPM = v
            if( Audio.Gibber.Tidal !== undefined ) Audio.Gibber.Tidal.cps = bpm/120/2
            Gibberish.worklet.port.postMessage({
              address:'set',
              object:this.id,
              name:'bpm',
              value:bpm 
            }) 
          }
        }
      })

      this.audioClock = Gen.make( Gen.ugens.abs(1) )
      //this.__rate = this.audioClock.__p0 

      Object.defineProperty( this, 'rate', {
        configurable:true,
        get() { return this.audioClock },
        set(v){
          this.audioClock.p0 = v
        }
      })

      //Gibberish.worklet.port.postMessage({
      //  address:'set',
      //  value: Gen.make( Gen.ugens.abs(1) ),
      //  object:this.id,
      //  name:'audioClock'
      //})

      this.bpm = this.__lastBPM
    }

    if( Gibberish.mode === 'processor' )
      this.seq = Gibberish.Sequencer.make( [ clockFunc ], [ ()=>Gibberish.Clock.time( 1/4 ) ] ).start()

  },

  connect: function() {
    if( this.audioClock !== undefined ) {
      Gibberish.analyzers.push( this.audioClock )
      Gibberish.dirty( Gibberish.analyzers )
      console.log( 'clock connected' )
    }
  },

  // time accepts an input value and converts it into samples. the input value
  // may be measured in milliseconds, beats or samples.
  time: function( inputTime = 0 ) {
    let outputTime = inputTime

    // if input is an annotated time value such as what is returned
    // by samples() or ms()...
    // console.log( 'input time:' , inputTime )
    if( isNaN( inputTime ) ) {
      if( typeof inputTime === 'object' ) { 
        if( inputTime.type === 'samples' ) {
          outputTime = inputTime.value
        }else if( inputTime.type === 'ms' ) {
          outputTime = this.mstos( inputTime.value ) 
        }
      } 
    }else{
      // XXX 4 is a magic number, needs to account for the current time signature
      outputTime = this.btos( inputTime * 4 )
    }
    
    return outputTime
  },

  // does not work... says Gibberish can't be found? I guess Gibberish isn't in the
  // global scope of the worklet?
  Time: function( inputTime ) {
    return new Function( `return Gibberish.Clock.time( ${inputTime} )` )
  },

  mstos: function( ms ) {
    return ( ms / 1000 ) * Gibberish.ctx.sampleRate
  },

  // convert beats to samples
  btos: function( beats ) {
    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
    return samplesPerBeat * beats 
  },

  // convert samples to beats (for pattern visualizations)
  stob: function( samples ) {
    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
    return (samples / samplesPerBeat) * .25 // XXX magic number should be denominator of time signature 
  },
  // convert beats to milliseconds
  btoms: function( beats ) {
    const samplesPerMs = Gibberish.ctx.sampleRate / 1000
    return beats * samplesPerMs
  },

  ms: function( value ) {
    return { type:'ms', value }
  },

  samples: function( value ) {
    return { type:'samples', value }
  }
}

module.exports = Clock

},{"gibberish-dsp":174,"serialize-javascript":231}],96:[function(require,module,exports){
const Ugen = require( './ugen.js' )
const Presets = require( './presets.js' )

let Audio = null

const addMethod = ( obj, name, __value = 1, propOverrideName ) => {
  if( propOverrideName === undefined ) propOverrideName = name

  obj[ '__' + name ] = { 
    value: __value,
    isProperty:true,
    sequencers:[],
    mods:[],
    name,

    seq( values, timings, number = 0, delay = 0 ) {
      let prevSeq = obj['__'+name].sequencers[ number ] 
      if( prevSeq !== undefined ) { 
        prevSeq.stop(); prevSeq.clear(); 
        let idx = obj.__sequencers.indexOf( prevSeq )
        obj.__sequencers.splice( idx, 1 )
      }

      // XXX you have to add a method that does all this shit on the worklet. crap.
      obj['__'+name].sequencers[ number ] = obj['__'+name][ number ] = Audio.Core.Seq({ 
        values, 
        timings, 
        target:obj.__wrapped__, 
        key:name,
        rate:Audio.Clock.audioClock
      })
      .start( Audio.Clock.time( delay ) )

      obj.__sequencers.push( obj['__'+name][ number ] )

      // return object for method chaining
      return obj
    },
  }

  Audio.Gibberish.worklet.port.postMessage({
    address:'addMethod',
    key:name,
    function:`function( ${name} ) {
        for( let input of this.inputs ) {
          if( typeof input === 'object' ) input[ '${propOverrideName}' ] = ${name}
        }
      }`,
    id:obj.id,
    delay:Audio.shouldDelay
  })

  Object.defineProperty( obj, name, {
    configurable:true,
    get() { return this[ '__' + name ] },
    set(v){ 
      this[ '__' + name ].value = v
      for( let sampler of this.samplers ) sampler[ propOverrideName ] = this[ '__' + name ].value 
    }
  })
}

module.exports = function( __Audio ) {
  Audio = __Audio

  const Drums = function( score, time, ...args ) { 
    // XXX what url prefix should I be using?

    const temp = Audio.autoConnect
    Audio.autoConnect = false
    const k  = Audio.instruments.Sampler({ filename:'./resources/audiofiles/kick.wav' })
    const s  = Audio.instruments.Sampler({ filename:'./resources/audiofiles/snare.wav' })
    const ch = Audio.instruments.Sampler({ filename:'./resources/audiofiles/hat.wav' })
    const oh = Audio.instruments.Sampler({ filename:'./resources/audiofiles/openhat.wav' })
    Audio.autoConnect = temp

    const drums = Audio.Ensemble({
      'kd': { target:k,  method:'trigger', args:[1], name:'kick' },
      [0]: { target:k,  method:'trigger', args:[1], name:'kick' },
      'sd': { target:s,  method:'trigger', args:[1], name:'snare' },
      'sn': { target:s,  method:'trigger', args:[1], name:'snare' },
      [1]: { target:s,  method:'trigger', args:[1], name:'snare' },
      'ch': { target:ch, method:'trigger', args:[1], name:'closedHat' },
      [2]: { target:ch, method:'trigger', args:[1], name:'closedHat' },
      'oh': { target:oh, method:'trigger', args:[1], name:'openHat' },
      [3]: { target:oh, method:'trigger', args:[1], name:'openHat' },
    })

    if( Audio.autoConnect === true ) drums.connect()

    drums.__sequencers = [ ]
    //if( typeof score === 'string' ) {
    //  drums.seq = Audio.Seq({
    //    target:drums,
    //    key:'play',
    //    values:score.split(''),
    //    timings:time === undefined ? 1 / score.length : time
    //  }).start()
    

    //  drums.values = drums.seq.values
    //  drums.timings = drums.seq.timings

    //  drums.__sequencers.push( drums.seq )
    //}else{
    //  Gibber.addSequencing( drums, 'play', 0 )
    //}

    drums.samplers = [ k,s,ch,oh ]

    addMethod( drums, 'pitch', 1, 'rate' )
    addMethod( drums, 'start', 0 )
    addMethod( drums, 'end', 1 )

    props = Presets.process( { name:'Drums', category:'instruments' }, args, Audio )
    if( props !== undefined && props.__presetInit__ !== undefined ) {
      Object.assign( drums, props )
      if( props.__presetInit__ !== undefined ) props.__presetInit__.call( drums, Audio )
    }

    drums.name = 'Drums'
    return drums
  }

  const EDrums = function(  ...args ) {
    const temp = Audio.autoConnect
    Audio.autoConnect = false
    
    const kd = Audio.instruments.Kick()
    const sd = Audio.instruments.Snare()
    const ch = Audio.instruments.Hat({ decay:.1, gain:.3 })
    const oh = Audio.instruments.Hat({ decay:.5, gain:.3 })
    const cp = Audio.instruments.Clap()
    const cb = Audio.instruments.Cowbell({ gain:.65 })
    
    Audio.autoConnect = temp
    
    const drums = Audio.Ensemble({
      'kd': { target:kd, method:'trigger', args:[1], name:'kick' },
      [0]: { target:kd, method:'trigger', args:[1], name:'kick' },
      [1]: { target:sd, method:'trigger', args:[1], name:'snare' },
      'sd': { target:sd, method:'trigger', args:[1], name:'snare' },
      [2]: { target:ch, method:'trigger', args:[.2], name:'closedHat' },
      'ch': { target:ch, method:'trigger', args:[.2], name:'closedHat' },
      [3]: { target:oh, method:'trigger', args:[.2], name:'openHat' },
      'oh': { target:oh, method:'trigger', args:[.2], name:'openHat' },
      [4]: { target:cp, method:'trigger', args:[.5], name:'clap' },
      'cp': { target:cp, method:'trigger', args:[.5], name:'clap' },
      [5]: { target:cb, method:'trigger', args:[.5], name:'cowbell' },
      'cb': { target:cb, method:'trigger', args:[.5], name:'cowbell' },
    })

    //if( typeof score === 'string' ) {
    //  drums.seq = Audio.Seq({
    //    target:drums,
    //    key:'play',
    //    values:score.split(''),
    //    timings:time === undefined ? 1 / score.length : time,
    //    rate:Audio.Clock.audioClock
    //  }).start()

    //  drums.values = drums.seq.values
    //  drums.timings = drums.seq.timings
    //}

    if( Audio.autoConnect === true ) drums.connect()

    props = Presets.process( { name:'EDrums', category:'instruments' }, args, Audio )
    if( props !== undefined && props.__presetInit__ !== undefined ) {
      props.__presetInit__.call( drums, Audio )
    }

    //drums.tidal = pattern => {
    //  if( drums.__tidal !== undefined ) drums.__tidal.stop()

    //  drums.__tidal = Audio.Tidal({
    //    target:drums,
    //    key:'play',
    //    pattern
    //  }).start()

    //  return drums
    //}

    drums.name = 'EDrums'
    return drums
  }

  return { Drums, EDrums }
}

},{"./presets.js":109,"./ugen.js":128}],97:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Effects = {
  create( Audio ) {
    const effects = {}
    const poolEffects = ['Freeverb', 'Plate', 'BufferShuffler']
    Gibberish.effects = Gibberish.fx

    for( let effectName in Gibberish.effects ) {
      const gibberishConstructor = Gibberish.effects[ effectName ]

      const methods = Effects.descriptions[ effectName ] === undefined ? null : Effects.descriptions[ effectName ].methods

      // XXX how do we make this more generic for any model of reverb / any type of distortion etc.
      const replaceName = effectName === 'Freeverb' ? 'Reverb' : effectName 
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:replaceName,
        category:'effects'
      }
      description.properties.type = 'fx'

      const shouldUsePool = poolEffects.indexOf( effectName ) > -1 

      effects[ effectName ] = Ugen( gibberishConstructor, description, Audio, shouldUsePool )
      
      effects[ effectName ].presets = Audio.Presets.effects[ effectName ] 
      if( effects[ effectName ].presets !== undefined ) {
        effects[ effectName ].presets.inspect = function() {
          console.table( this )
        }
      }else{
        effects[ effectName ].presets = { inspect() { console.log( `${effectName} has no presets.` ) } }
      }
    }

    effects.Reverb = function( ...args ) {
      let argprops = null
      if( args.length === 1 ) {
        if( typeof args[0] === 'object' ) argprops = args[0]
      }else if( args.length === 2 ) {
        argprops = args[1]
      }
      const props = Object.assign( {}, { model:0 }, argprops )

      let ugen = null
      switch( props.model ) {
        case 0:
        default:
          ugen = effects.Freeverb(...args )
          break;
      }

      return ugen
    }

    return effects
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Effects

},{"./ugen.js":128,"gibberish-dsp":174}],98:[function(require,module,exports){
module.exports = function( Audio ) {
  const Gibberish = Audio.Gibberish
  const Ensemble = function( props ) {
    const cp = {
      shouldAddToUgen:true
    }

    for( let key in props ) {
      const dict = props[ key ]
      const target = dict.target
      const method = dict.method
      const args = dict.args
      cp[ key ] = {
        play: function( ...args ) { 
          Gibberish.worklet.ugens.get( this.target )[ this.method ]( ...args ) 
        },
        target:target.id,
        method,
        args,
        name:dict.name
      }

      //Object.defineProperty( cp[ key ], 'loudness', {
      //  set(v) {
      //    console.log( 'loudness:', v, Gibberish.worklet.ugens.get( this.target ))
      //    Gibberish.worklet.ugens.get( this.target ).loudness = v
      //  }
      //})
      cp[ dict.name ] = target
    }

    cp.play = function( __key ) {
      const key = isNaN(__key) ? __key : parseInt( __key ) 
      if( Gibberish.mode === 'processor' ) {
        Gibberish.worklet.ugens.get( this[ key ].target )[ this[ key ].method ]( ...this[ key ].args )
      }else{
        props[ key ].target[ this[ key ].method ]( ...this[ key ].args )
      }
    }

    const ens = Audio.busses.Bus2( cp )
    ens.__isEnsemble = true

    for( let key in props ) {
      props[ key ].target.connect( ens )
    }
    
    ens.tidals = []

    ens.stop = function() {
      ens.tidals.forEach( t => t.stop() )
      ens.__sequencers.forEach( t => t.stop() )
    }
    ens.start = function() {
      ens.tidals.forEach( t => t.start() )
      ens.__sequencers.forEach( t => t.start() )
    }

    ens.tidal = (pattern,num=0) => {
      const t =  Audio.Gibber.Tidal({
        target:ens,
        key:'play',
        pattern
      })

      if( t !== null ) {
        if( ens.tidals[ num ] !== undefined ) ens.tidals[ num ].stop()

        ens.tidals[ num ] = t
        t.start()
      }

      return ens
    }
    ens.__sequencers = []

    ens.seq = (values,timings,num=0,offset=0) => {
      if( ens.__sequencers[ num ] !== undefined ) ens.__sequencers[ num ].stop()

      ens.__sequencers[ num ] = Audio.Gibber.Seq({
        target:ens,
        key:'play',
        values,timings,offset
      }).start()

      return ens
    }

    return ens
  }

  return Ensemble
}

},{}],99:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Envelopes = {
  create( Audio ) {
    const envelopes = {}

    for( let envelopeName in Gibberish.envelopes ) {
      const gibberishConstructor = Gibberish.envelopes[ envelopeName ]

      const methods = Envelopes.descriptions[ envelopeName ] === undefined ? null : Envelopes.descriptions[ envelopeName ].methods
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:envelopeName,
        category:'envelopes'
      }
      description.properties.type = 'envelope'

      envelopes[ envelopeName ] = Ugen( gibberishConstructor, description, Audio )
    }
    return envelopes
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Envelopes

},{"./ugen.js":128,"gibberish-dsp":174}],100:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./realm.js":101,"dup":39}],101:[function(require,module,exports){


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],102:[function(require,module,exports){

// See all scales at: http://abbernie.github.io/tune/scales.html


const Tune = function(){

	// the scale as ratios
	this.scale = []

	// i/o modes
	this.mode = {
		output: "frequency",
		input: "step"
	}

	// ET major, for reference
	this.etmajor= [ 261.62558,
		293.664764,
		329.627563,
		349.228241,
		391.995422,
		440,
		493.883301,
		523.25116
	]

  
  this.TuningList = null
	// Root frequency.
	this.tonic = 440

	console.log("{{{{ Tune.js v0.1 Loaded }}}}");

}

/* Set the tonic frequency */

Tune.prototype.tonicize = function(newTonic) {
	this.tonic = newTonic
}

/* Return data in the mode you are in (freq, ratio, or midi) */

Tune.prototype.note = function(input,octave){

	var newvalue;

	if (this.mode.output == "frequency") { 
		newvalue = this.frequency(input,octave)
	} else if (this.mode.output == "ratio") { 
		newvalue = this.ratio(input,octave)
	} else if (this.mode.output == "MIDI") { 
		newvalue = this.MIDI(input,octave)
	} else {
		newvalue = this.frequency(input,octave)
	}

	
	return newvalue;

}


/* Return freq data */

Tune.prototype.frequency = function(stepIn, octaveIn) {

	if (this.mode.input == "midi" || this.mode.input == "MIDI" ) {
		this.stepIn += 60
	}
	
	// what octave is our input
	var octave = Math.floor(stepIn/this.scale.length)

	if (octaveIn) { 
		octave += octaveIn
	}
	
	// which scale degree (0 - scale length) is our input
	var scaleDegree = stepIn % this.scale.length

	while (scaleDegree < 0) {
		scaleDegree += this.scale.length
	}
	
	var freq = this.tonic*this.scale[scaleDegree]
	
	freq = freq*(Math.pow(2,octave))
	
	// truncate irrational numbers
	freq = Math.floor(freq*100000000000)/100000000000
	
	return freq

}

/* Force return ratio data */

Tune.prototype.ratio = function(stepIn, octaveIn) {

	if (this.mode.input == "midi" || this.mode.input == "MIDI" ) {
		this.stepIn += 60
	}
	
	// what octave is our input
	var octave = Math.floor(stepIn/this.scale.length)

	if (octaveIn) { 
		octave += octaveIn
	}
	
	// which scale degree (0 - scale length) is our input
	var scaleDegree = stepIn % this.scale.length

	// what ratio is our input to our key
	var ratio = Math.pow(2,octave)*this.scale[scaleDegree]

	ratio = Math.floor(ratio*100000000000)/100000000000

	return ratio

}

/* Force return adjusted MIDI data */

Tune.prototype.MIDI = function(stepIn,octaveIn) {

	var newvalue = this.frequency(stepIn,octaveIn)

	var n = 69 + 12*Math.log(newvalue/440)/Math.log(2)

	n = Math.floor(n*1000000000)/1000000000

	return n

}

/* Load a new scale */

Tune.prototype.loadScale = function(name){

	/* load the scale */
	var freqs = this.TuningList[name].frequencies
	this.scale = []
	for (var i=0;i<freqs.length-1;i++) {
		this.scale.push(freqs[i]/freqs[0])
	}

	/* visualize in console */
	//console.log(" ");
	//console.log("LOADED "+name);
	//console.log(this.TuningList[name].description);
	//console.log(this.scale);
	//var vis = [];
	//for (var i=0;i<100;i++) {
	//  vis[i] = " ";
	//}
	//for (var i=0;i<this.scale.length;i++) {
	//  var spot = Math.round(this.scale[i] * 100 - 100);
	//  if (i<10) {
	//    vis.splice(spot,1,i+1);
	//  } else {
	//    vis.splice(spot,5,i+1);
	//  }
	//}
	//var textvis = "";
	//for (var i=0;i<vis.length;i++) {
	//  textvis += vis[i];
	//}
	//console.log(name)
	//console.log(textvis)
	//// ET scale vis
	//var vis = [];
	//for (var i=0;i<100;i++) {
	//  vis[i] = " ";
	//}
	//for (var i=0;i<this.etmajor.length;i++) {
	//  var spot = Math.round(this.etmajor[i]/this.etmajor[0] * 100 - 100);
	//  if (i<10) {
	//    vis.splice(spot,1,i+1);
	//  } else {
	//    vis.splice(spot,5,i+1);
	//  }
		
	//}
	//var textvis = "";
	//for (var i=0;i<vis.length;i++) {
	//  textvis += vis[i];
	//}
	//console.log(textvis)
	//console.log("equal-tempered major (reference)")
}

/* Search the names of tunings
	 Returns an array of names of tunings */

Tune.prototype.search = function(letters) {
	var possible = []
	for (var key in this.TuningList) {
		if (key.toLowerCase().indexOf(letters.toLowerCase())!=-1) {
			possible.push(key)
		}
	}
	return possible
}

/* Return a collection of notes as an array */

Tune.prototype.chord = function(midis) {
	var output = []
	for (var i=0;i<midis.length;i++) {
		output.push(this.note(midis[i]))
	}
	return output;
}


/* Change the tonic frequency? */

Tune.prototype.root = function(newmidi, newfreq) {
	this.rootFreq = newfreq
	// not working now ... needs much work.
	// setKey is not transposing now, either.
}

module.exports = Tune

},{}],103:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const filterNames = [
  "none", "Filter24Moog", "Filter24TB303", "Filter12SVF", "Filter12Biquad", "Filter24Classic"
]

const Filters = {
  create( Audio ) {
    const filters = {}

    for( let filterName in Gibberish.filters ) {
      const gibberishConstructor = Gibberish.filters[ filterName ]

      const methods = Filters.descriptions[ filterName ] === undefined ? null : Filters.descriptions[ filterName ].methods
      const description = { 
        properties:gibberishConstructor.defaults || {}, 
        methods:methods,
        name:filterName,
        category:'effects'
      }
      description.__defaults__ = { isStereo : true }
      description.properties.isStereo = true
      description.properties.type = 'fx'

      filters[ filterName ] = Ugen( gibberishConstructor, description, Audio, false )
    }

    filters.LPF = filters.Filter24Moog

    filters.Filter = function( props ) {
      if( props === undefined ) props = { model: 1 }
      if( props.model === undefined ) props.model = 1

      const name = filterNames[ props.model ]

      delete props.model

      return filters[ name ]( props ) 
    }

    const description = { 
      properties: Object.assign( {}, Gibberish.filters[ 'Filter12Biquad' ].defaults, { mode:1 } ),
      methods:null,
      name:'HPF',
      category:'effects',
      __defaults__: { mode:1 }
    }
   
    filters.HPF = Ugen( Gibberish.filters[ 'Filter12Biquad' ], description, Audio, false )

    return filters
  },

  descriptions: {
    //Chorus:{ methods:[] },
  },
  
}

module.exports = Filters

},{"./ugen.js":128,"gibberish-dsp":174}],104:[function(require,module,exports){
module.exports = function( Audio ) {
  const token = '6a00f80ba02b2755a044cc4ef004febfc4ccd476'

  const Freesound = function( query, options ) {
    const props = Object.assign( { count:1, maxVoices:1, panVoices:true }, typeof query === 'object' ? query : options )
    const sampler = Audio.instruments.Multisampler( props )
    setTimeout( ()=>queries[ typeof query ]( query, sampler, props.count ), 0 )
 
    return sampler
  }

  Freesound.loaded = {}
  Freesound.queries = {}

  Freesound.defaults = {
    sort: 'downloads',
    single:true,
    filename:false,
    min: 0,
    max: .5,
    reverse:false,
    count:15
  }

  // add Freesound[5] notation...
  for( let i = 0; i < 20; i++ ) {
    Freesound[ i ] = function( ...args ) {
      if( args.length > 0 ) {
        if( typeof args[0] === 'string' ) {
          if( args.length > 1 ) {
            if( typeof args[1] === 'object' ) {
              args[1].maxVoices = i || 1
            } 
          }else{
            args[1] = { maxVoices:i || 1 }
          }
        }else if( typeof args[0] === 'object' ) {
          args[0].maxVoices = i || 1
        }
      }else{
        args[0] = { maxVoices:i || 1 }
      } 

      return Freesound( ...args ) 
    }
  }

  const queries = {
    number( id, sampler, num=0 ) {
      if (typeof Freesound.loaded[ id ] === 'undefined') {
        fetch( `https://freesound.org/apiv2/sounds/${id}/?&format=json&token=${token}` )
          .then( response => response.json() )
          .then( json => {
            const path = json.previews[ 'preview-hq-mp3' ]
            
            sampler.loadSample( path )
            //console.log( 'loading:', path )
          }) 
      }else{
        if( Audio.Gibberish.mode === 'worklet' ) {
          sampler.samplers[ num ].loadBuffer( Freesound.loaded[ id ] )
        }
      }
    },

    // search for text query, and then use returned id to 
    // fetch by number 
    string( query, sampler, count, originalQuery ) {
      sampler.length = count
      let queryString ='https://freesound.org/apiv2/search/text/?'

      console.group('Querying Freesound for: ' + originalQuery || query )
      if( query.indexOf( 'query' ) > -1 ) {
        queryString += query
        queryString += `&token=${token}&fields=name,id,previews,username,license&page_size=${count} `
      }else{
        queryString += `query=${query}&token=${token}&fields=name,id,previews,username,license&filter=original_filename:${query.split(' ')[0]} ac_single_event:true&sort=downloads_desc&page_size=${count}`

      }

      fetch( queryString )
        .then( data => data.json() )
        .then( sounds => {
          if( sounds.results.length > 0 ) {
            if( sounds.results.length > count ) sounds.results = sounds.results.slice(0,count)
            console.log(`%c${sounds.results.length} sounds found. Starting downloads:`, `background:black;color:white`)
          }else{
            console.log(`%cNo sounds were found for this query!`, `background:red;color:white`)
          }
          sampler.length = count < sounds.results.length ? count : sounds.results.length
          console.table( sounds.results.map( r=>({file:r.name,author:r.username,license:'CC/'+r.license.split('/').slice(4).join('/')}) ) )
          for( let i = 0; i < sampler.length; i++ ) {
            const result = sounds.results[i]
            if( result !== undefined ) {
              const filename = result.name,
                    id = result.id,
                    url = result.previews[ 'preview-hq-mp3' ] 

              if( Freesound.loaded[ url ] === undefined ) {
                //console.log( `%c${filename}`, `color:white;background:#333333;` )

                sampler.loadSample( url, (__sampler,buffer) => {
                  Freesound.loaded[ url ] = buffer.data.buffer
                })

              }else{
                // XXX memoing the files causes an error
                if( Gibberish.mode === 'worklet' ) {
                  //console.log( 'reusing freesound file:', filename )
                  sampler.loadSample( url, null, Freesound.loaded[ url ] )
                }
              }
            }
          }
          console.groupEnd()
        })
    },

    object( queryObj, sampler ) {
      const q = Object.assign( {}, Freesound.defaults, queryObj )
 
      let query = `query=${q.query}&format=json`
  
      query += `&filter=duration:[${q.min} TO ${q.max}]`
      if( q.single ) query += ` ac_single_event:true`
      if( q.filename ) query += ` original_filename:${q.query}`

      let sort = q.sort

      // user error check
      if( sort === 'ratings' ) sort = 'rating'

      sort += q.reverse ? '_asc' : '_desc'

      query += `&sort=${sort}`

      queries.string( query, sampler, q.count, q.query )
    }
  }

  return Freesound
}

},{}],105:[function(require,module,exports){
module.exports = function( Audio ) {
  
const binops = [ 
  'min','max','add','sub','mul','div','rdiv','mod',
  'and','or','gt','eq','eqp','gte','gtep','gtp','lt','lte','ltep','ltp','neq',
  'step' 
]

const monops = [
  'abs','acos','acosh','asin','asinh','atan','atan2','atanh','cos','cosh',
  'sin','sinh','tan','tanh', 'floor',
  'ceil', 'round', 'sign', 'trunc', 'fract', 'param', 'in',
]

const noops = [
  'noise'
]

const Gen  = {
  lastConnected:[],
  names:[],
  connected: [],

  isGen:true,
  debug:false,

  wavetable( frequency, props ) {
    const g = Audio.Gibberish.genish 
    let dataProps = { immutable:true }

    // use global references if applicable
    if( props.name !== undefined ) dataProps.global = props.name

    const buffer = Gen.ugens.data( props.buffer, 1, dataProps )

    return Gen.ugens.peek( buffer, Gen.ugens.phasor( frequency, 0, { min:0 } ) )
  },

  init() {
    Gen.ugens.wavetable = Gen.__wavetable
    Gen.createBinopFunctions()
    Gen.createMonopFunctions()

    Gen.names.push( ...binops )
    Gen.names.push( ...monops )
    Gen.names.push( ...Object.keys( Gen.constants ) )
    Gen.names.push( ...Object.keys( Gen.functions ) )
    //Gen.names.push( ...Object.keys( Gen.composites ) )
    Gen.names.push( 'gen' )
    Gen.names.push( 'lfo' )
    Gen.names.push( 'sine' )
    Gen.names.push( 'square' )
    Gen.names.push( 'tri' )
    Gen.names.push( 'saw' )

    //Gibber.subscribe( 'clear', ()=> Gen.lastConnected.length = 0 )
  },

  // if property is !== ugen (it's a number) a Param must be made using a default
  create( name ) {
    // rate needs custom function to skip sequencing input and only sequence rate adjustment

    const params = Array.prototype.slice.call( arguments, 1 )

    if( name === 'rate' ) return Gen.createRate( name, ...params )

    const obj = Object.create( this )
    let count = 0
    
    obj.name = name
    obj.active = false
    
    for( let key of Gen.functions[ name ].properties ) { 
      let value = params[ count++ ] || 0
      obj[ key ] = v => {
        if( v === undefined ) {
          return value
        }else{
          value = v
          if( obj.active ) {
            if( obj.__client === 'live' ) {
              Gibber.Communication.send( `genp ${obj.paramID} ${obj[ key ].uid} ${v}` ) 
            }else if( obj.__client === 'max' ) {
              Gibber.Communication.send( `sig ${obj.paramID} param ${obj[ key ].uid} ${v}`, 'max' ) 
            }
          }
        }
      }
      obj[ key ].uid = Gen.getUID()
 
      // XXX Gibber.addSequencingToMethod( obj, key )
    }

    // accomodate non-audio-rate options. during codegen the compiler
    // will check for the options property; if it exists it will write
    // the options into the generated code.
    if( params.length > Gen.functions[ name ].properties.length ) {
      obj.options = params[ Gen.functions[ name ].properties.length ]
    }

    return obj
  },

  createRate( name ) {
    let obj = Object.create( this ),
        count = 0,
        param = arguments[1] 
    
    obj.name = 'rate' 
    obj.active = false
    
    let value = param
    //console.log( 'value:', value, 'args:', arguments )
    obj[ 0 ] = v => {
      if( v === undefined ) {
        return value
      }else{
        value = v
        if( obj.active ) {
          Gibber.Communication.send( `genp ${obj.paramID} ${obj[ 0 ].uid} ${v}` ) 
        }
      }
    }

    Gen.getUID() // leave 0 behind...
    obj[ 0 ].uid = Gen.getUID()

    Gibber.addSequencingToMethod( obj, '0' )

    return obj
  },
 
  createBinopFunctions() {
    for( let key of binops ) {
      Gen.functions[ key ] = {
        properties:['0','1'], str:key
      }
    }
  },

  createMonopFunctions() {
    for( let key of monops ) {
      Gen.functions[ key ] = {
        properties:['0'], str:key
      }
    }
  },

  assignTrackAndParamID: function( track, id ) {
    this.paramID = id
    this.track = track

    let count = 0, param
    while( param = this[ count++ ] ) {
      if( typeof param() === 'object' ) {
        param().assignTrackAndParamID( track, id )
      }
    }
  },

  clear() {
    for( let ugen of Gen.connected ) {
      Gibber.Communication.send( `ungen ${ugen.paramID}` )
    }

    Gen.connected.length = 0
  },

  constants: {
    degtorad: Math.PI / 180,
    E :       Math.E,
    halfpi:   Math.PI / 2,
    invpi :   Math.PI * - 1,
    ln10  :   Math.LN10,
    ln2   :   Math.LN2,
    log10e:   Math.LOG10E,
    log2e :   Math.LOG2E,
    pi    :   Math.PI,  
    sqrt2 :   Math.SQRT2,
    sqrt1_2:  Math.SQRT1_2,
    twopi :   Math.PI * 2,
    samplerate: 'samplerate'
  },

  functions: {
    phasor: { properties:[ '0','1' ],  str:'phasor' },
    cycle:  { properties:[ '0' ],  str:'cycle' },
    phasorN:{ properties:[ '0','1' ],  str:'phasorN' },
    cycleN: { properties:[ '0' ],  str:'cycleN' },
    train:  { properties:[ '0','1' ],  str:'train' },
    rate:   { properties:[ '0' ], str:'rate' },
    noise:  { properties:[], str:'noise' },
    accum:  { properties:[ '0','1' ], str:'accum' },
    counter:{ properties:[ '0','1' ], str:'counter' },
    scale:  { properties: ['0', '1', '2', '3'], str:'scale' },
    sah:    { properties: ['0', '1', '2'], str:'sah' },
    clamp:  { properties: ['0', '1', '2'], str:'clamp' },
    ternary:{ properties: ['0', '1', '2'], str:'switch' },
    selector:{ properties: ['0', '1', '2'], str:'selector' },
    peek:   { properties:['0','1'], str:'peek' },
    data:   { properties:[], str:'data' }
  },

  _count: 0,

  getUID() {
    return 'p' + Gen._count++
  },

  time: 'time',

  out() {
    let paramArray = [],
        body, out
    
    body = this.gen( paramArray )

    out = paramArray.join( ';' )

    if( paramArray.length ) {
      out += ';'
    }
    
    out += 'out1='
    out += body + ';'
    
    if( Gen.debug ) console.log( out )

    return out
  },

  genMax( paramArray ) {
    let def = Gen.functions[ this.name ],
        str = def.str + '(',
        count = 0
    
    // tell Gibber that this gen object is part of an active gen graph
    // so that changes to it are forwarded to m4l
    this.active = true

    if( this.name === 'rate' ) {
      str += 'in1, '
      let pName = this[ 0 ].uid
      str += pName
      paramArray.push( `Param ${pName}(${this[0]()})` )
    }else{
      for( let property of def.properties ) {
        let p = this[ property ](),
            uid = this[ property ].uid
        
        //console.log( this.name, property, def.properties, uid )
        if( Gen.isPrototypeOf( p ) ) {
          str += p.gen( paramArray )
        }else if( typeof p === 'number' ) {
          let pName = uid
          str += pName
          paramArray.push( `Param ${pName}(${p})` )
        }else if( p === Gen.time ) {
          str += p
        }else if( typeof p === 'string' ) {
          str += p
        }else{
          console.log( 'CODEGEN ERROR:', p )
        }

        if( count++ < def.properties.length - 1 ) str += ','
      }
    }
    
    str += ')'

    return str
  },

  gen( paramArray ) {
    let def = Gen.functions[ this.name ],
        str = `g.${def.str}(`,
        count = 0
    
    // tell Gibber that this gen object is part of an active gen graph
    // so that changes to it are forwarded to m4l
    this.active = true

    for( let property of def.properties ) {
      let p = this[ property ](),
          uid = this[ property ].uid
      
      //console.log( this.name, property, def.properties, uid )
      if( Gen.isPrototypeOf( p ) ) {
        str += p.gen( paramArray )
      }else if( typeof p === 'number' ) {
        let pName = 'p'+paramArray.length
        //str += pName
        paramArray.push( [`${pName}`, p ] )
        str += `g.in('${pName}')`
      }else if( p === Gen.time ) {
        str += p
      }else if( typeof p === 'string' ) {
        str += p
      }else{
        console.log( 'CODEGEN ERROR:', p )
      }

      if( count++ < def.properties.length - 1 ) str += ','
    }

    if( this.options !== undefined ) {
      str += ',' + JSON.stringify( this.options )
    }
    
    str += ')'

    return str
  },

  composites: { 
    sine( frequency=2, amp=4, center=0, shouldRound=false ) {
      return Gen.composites.lfo( 'sine', frequency, amp, center, shouldRound )
    },
    siner( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'sine', frequency, amp, center, true )
    },
    square( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'square', frequency, amp, center )
    },
    saw( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'saw', frequency, amp, center )
    },
    tri( frequency=2, amp=4, center=0 ) {
      return Gen.composites.lfo( 'tri', frequency, amp, center )
    },
    lfo( type = 'sine', frequency = 2, amp = .5, center = .5, shouldRound = false ) {
      const g = Gen.ugens 
      const gibberish= Audio.Gibberish
      let osc

      switch( type ) {
        case 'saw':
          osc = g.phasor( frequency )
          break
        case 'square':
          osc = g.add( g.mul( g.gt( g.phasor( frequency ), 0 ), 2 ), -1 )
          break
        case 'noise':
          osc = g.sub( g.mul( g.noise(), 2 ), 1 )
          break
        case 'triangle':
        case 'tri':
          const p = g.phasor( frequency )
          osc = g.sub(
            1, 
            g.mul( 
              4, 
              g.abs(
                g.sub( 
                  g.round( p ),
                  p
                )
              )
            )
          )
            
          break
        case 'sine':
        default:
          osc = g.cycle( frequency )
          break
      }

      const _mul   = g.mul( osc, amp ),
            _add   = g.add( center, _mul ) 

      const lfo = shouldRound ? Gen.make( g.round( _add ) ) : Gen.make( _add )

      Object.defineProperties( lfo, {
        frequency: {
          set(v) { lfo.p1 = v },
          get()  { return lfo.p1 }
        },
        gain: {
          set(v) { lfo.p2 = v },
          get()  { return lfo.p2 }
        },
        bias: {
          set(v) { lfo.p0 = v },
          get()  { return lfo.p0 }
        }
      })

      lfo.copy = function() {
        return Gen.composites.lfo( type, this.frequency.value, this.gain.value, this.bias.value )
      }

      return lfo
    },

    fade( time = 1, from = 1, to = 0 ) {
      let g = Gen.ugens
      let fade, amt, beatsInSeconds = time * ( 60 / Gibber.Live.LOM.bpm )
     
      if( from > to ) {
        amt = from - to

        fade = g.gtp( g.sub( from, g.accum( g.div( amt, g.mul(beatsInSeconds, g.samplerate ) ), 0 ) ), to )
      }else{
        amt = to - from
        fade = g.add( from, g.ltp( g.accum( g.div( amt, g.mul( beatsInSeconds, g.samplerate ) ), 0 ), to ) )
      }
      
      // XXX should this be available in ms? msToBeats()?
      let numbeats = time / 4
      fade.shouldKill = {
        after: numbeats, 
        final: to
      }
      
      return fade
    },
    
    //beats( num ) {
    //  return Gen.ugens.rate( num )
    //  // beat( n ) => rate(in1, n)
    //  // final string should be rate( in1, num )
    //}
    beats( b ) {
      return Gen.ugens.phasor( Audio.Utilities.btof( b ), 0, { min:0 } )
    }, 
    beats2( b ) {
      return Gen.ugens.phasor( 
        Audio.Utilities.btof( b ), 
        0, 
        { min:0 } )
    }, 
  },

  ugens:{},

  export( obj ) {
    for( let key in Gen.functions ) {
      this.ugens[ key ] = Gen.create.bind( Gen, key )
    }

    Object.assign( this.ugens, Gen.constants )
    Object.assign( this.ugens, Gen.composites )

    const __in = this.ugens.in
    delete this.ugens.in
    Object.assign( obj, this.ugens )
    this.ugens.in = __in
  },


  // defer creating genish object until we know whether
  // this will be used by an audio or visual object
  make( graph, propertyNames ) {
    const defer = { 
      graph, 
      __graph:graph,
      propertyNames,
      type:'gen',
      id: Audio.Gibberish.utilities.getUID(),
      rendered:null,
      copy() {
        return Gen.make( this.__graph )
      },
      render( samplerate=44100, type='audio' ) {
        if( type === 'audio' ) {
          if( this.rendered === null ) { 
            this.rendered = Gen.__make( this.graph, this.propertyNames, defer )
            const props = this.rendered.__wrapped__.__properties__
            for( let key in props ) { 
              Object.defineProperty( this, key, {
                configurable:true,
                get() { return this.rendered[ key] },
                set(v){
                  this.rendered[ key ] = v 
                }
              })
            } 
            this.rendered.widget = this.widget
            this.rendered.__graph = graph
          }

          return this.rendered
        }

        const store = Audio.Gibberish.genish.samplerate
        const g = Audio.Gibberish.genish

        Audio.Gibberish.genish.gen.samplerate = samplerate
        const params = []
        const __graph = eval( graph.gen( params ) )
        const callback = g.gen.createCallback( __graph )
        Audio.Gibberish.genish.gen.samplerate = store      

        const out = callback.bind( null, ...params.map( v => v[1] ), g.memory )

        // annotations can be added to the original defer, so store the defer
        // to access the annotations later
        out.pre = defer 

        return out
      },

      // XXX connecting gen objects to audio properties no longer seems
      // to work... must be assigned. FIX
      connect( target ) {
        if( target.type === 'audio' ) {
          if( this.rendered === null ) { 
            this.rendered = Gen.__make( this.graph, this.propertyNames, defer )
          }
          this.rendered.connect( target )
        }
      }
    }

    return defer
  },

  __make( graph, propertyNames, target ) {
    const ugen = Audio.Gibberish.prototypes.Ugen
    const g = Audio.Gibberish.genish

    // store properties of our gen object in this array
    // they will then become properties of our Gibber object
    const paramArray = []

    // get genish.js codelet for our graph
    const genCode = graph.gen( paramArray )

    // create a properties object out of our paramArray
    const params = {}
    for( let param of paramArray ) {
      params[ param[0] ] = param[1]
    } 

    const id = Gen.getUID()

    params.id = Audio.Gibberish.utilities.getUID()

    // pass a constructor to our worklet processor
    Audio.Gibberish.worklet.port.postMessage({ 
      address:'addMethod', 
      id:-1,
      key:'Gen' + id,
      function:`function() { 
        const g = Gibberish.genish; 
        const mymod = Object.create( Gibberish.prototypes.Ugen ); 
        Gibberish.factory( mymod, ${genCode}, 'Gen${id}', ${JSON.stringify(params)}, null, true ); 
        return mymod; 
      }`
    })

    // create a worklet-side Gibberish constructor
    const make = function() {
      const mymod = Object.create( ugen )
      // the second parameter doesn't matter in the worklet, only in the processor
      // so we can just input zeroes. hmmmm... I gues it probably matters for
      // sequencing?
      
      return Audio.Gibberish.factory( mymod, g.add(0,0), 'Gen'+id, params )
    }

    // XXX do I really have to make a Gibberish constructor and a Gibber constructor to
    // turn a genish graph into a Gibber ugen? Is there a shortcut to take? Is it worth
    // writing custom code for?

    // create a Gibber constructor using our Gibberish constructor
    let temp = params.id
    //delete params.id
    const Make = Audio.Ugen( make, { name:'Gen'+id, properties:params, methods:[]}, Audio )

    // create Gibber ugen and pass in properties dictionary to initailize
    const out = Make({ params })
    out.__wrapped__.id = temp 
    out.__wrapped__.connected = []

    let count = 0
    out.__wrapped__.output = out.output = function( v ) {
      //if( Audio.Gibber.Environment !== undefined ) {
        // XXX should these be averaged instead of only taking every sixth sample (roughly
        // corresponds to 58 frames a second)
        if( count++ % 6 === 0 ) {
          // XXX this shouldn't happen here, should happen when the annotation is created.
          if( Audio.Gibber.Environment.Annotations.waveform.widgets[ temp ] === undefined ) {
            Audio.Gibber.Environment.Annotations.waveform.widgets[ temp ] = out.widget
          }
          Audio.Gibber.Environment.Annotations.waveform.updateWidget( out.widget, v, false )
        }
      //}

      out.output.value = v
    }

    // optionally map user provided names to p values for better control / sequencing
    if( Array.isArray( propertyNames )) {
      for( let i = 0; i < propertyNames.length; i++ ){
        const propertyName = propertyNames[ i ]
        if( out[ 'p'+i ] !== undefined && propertyName !== null && propertyName !== undefined ){
          out[ '__'+propertyName ] = out[ 'p'+i ]
          Object.defineProperty( out, propertyName, {
            get() { return out[ '__' + propertyName ] },
            set(v){
              if( v === undefined || v === null ) return
              out[ '__' + propertyName ].value = v
            }
          })
          Object.defineProperty( target, propertyName, {
            get() { return out[ '__' + propertyName ] },
            set(v){
              if( v === undefined || v === null ) return
              out[ '__' + propertyName ].value = v
            }
          })

        } 
      }
    }


    out.id = temp
    out.__isGen = out.__wrapped__.__isGen = true
    out.type = 'gen'

    return out
  }
}

Gen.init()

return Gen 
}

},{}],106:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Instruments = {
  create( Audio ) {
    const instruments = {}
    //const pooledInstruments = ['Synth','Monosynth','FM']
    for( let instrumentName in Gibberish.instruments ) {
      const gibberishConstructor = Gibberish.instruments[ instrumentName ]
      if( typeof gibberishConstructor.defaults === 'object' ) gibberishConstructor.defaults.octave = 0

      const methods = Instruments.descriptions[ instrumentName ] === undefined ? null : Instruments.descriptions[ instrumentName ].methods
      const description = { 
        properties:gibberishConstructor.defaults, 
        methods:methods,
        name:instrumentName,
        category:'instruments'
      }

      //const shouldPool = pooledInstruments.indexOf( instrumentName ) > -1
      instruments[ instrumentName ] = Ugen( gibberishConstructor, description, Audio, false ) 

      // for poly notation like Synth[3]()
      // create or extend dictionary with maxVoices property
      for( let i = 0; i < 20; i++ ) {
        instruments[ instrumentName ][i] = function( ...args ) {
          if( args.length > 0 ) {
            if( typeof args[0] === 'string' ) {
              if( args.length > 1 ) {
                if( typeof args[1] === 'object' ) {
                  args[1].maxVoices = i || 1
                } 
              }else{
                args[1] = { maxVoices:i || 1 }
              }
            }else if( typeof args[0] === 'object' ) {
              args[0].maxVoices = i || 1
            }
          }else{
            args[0] = { maxVoices:i || 1 }
          } 

          // use monophonic version if voice count is 1 or less
          let name
          if( i > 1 ) {
            name = instrumentName === 'Sampler' ? 'Multisampler' : 'Poly'+instrumentName
            if( name === 'PolyMonosynth' ) name = 'PolyMono' 
          }else{
            name = instrumentName
          }

          return instruments[ name ]( ...args )
        }
      }


      instruments[ instrumentName ].presets = Audio.Presets.instruments[ instrumentName ] 
      if( instruments[ instrumentName ].presets !== undefined ) {
        instruments[ instrumentName ].presets.inspect = function() {
          console.table( this )
        }
      }else{
        instruments[ instrumentName ].presets = { inspect() { console.log( `${instrumentName} has no presets.` ) } }
      }
    }
    instruments.Pluck = instruments.Karplus
    return instruments
  },

  descriptions: {
    Clap:{
      methods:[ 'trigger' ],
    },   
    Conga:{
      methods:[ 'note','trigger' ],
    },
    Clave:{
      methods:[ 'note','trigger' ],
    },
    Cowbell:{
      methods:[ 'note','trigger' ],
    },
    FM:{
      methods:[ 'note','trigger' ],
    },
    Hat:{
      methods:[ 'note','trigger' ],
    },
    Karplus:{
      methods:[ 'note','trigger' ],
    },
    Kick:{
      methods:[ 'note','trigger' ],
    },
    Monosynth:{
      methods:[ 'note','trigger' ],
    },
    Sampler:{
      methods:[ 'note', 'trigger', 'loadFile', 'loadBuffer' ],
    },
    Multisampler:{
      methods:[ 'note', 'trigger', 'pick', 'pickFile', 'pickplay', 'loadSample', 'setpan', 'setrate' ], 
    },
    Soundfont:{
      methods:[ 'note', 'trigger', 'midinote', 'midichord', 'chord', 'load', 'setpan', 'setrate' ], 
    },
    Snare:{
      methods:[ 'note','trigger' ],
    },
    Synth:{
      methods:[ 'note','trigger' ],
    },
    Complex:{
      methods:[ 'note','trigger' ],
    },
    Tom:{
      methods:[ 'note','trigger' ],
    },
    PolySynth:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyComplex:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyFM:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyKarplus:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyMono:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyConga:{
      methods:[ 'chord','note','trigger' ],
    },
    PolyTom:{
      methods:[ 'chord','note','trigger' ],
    },
  },
  
}

module.exports = Instruments

},{"./ugen.js":128,"gibberish-dsp":174}],107:[function(require,module,exports){
module.exports = function( Audio ) {
  const Gibberish = Audio.Gibberish

  const fnc = function( props ){
    const name = props.name
    const type = props.type
    const properties = props.properties || {}
    const block = `
    const ugen = Object.create( Gibberish.prototypes[ '${type}' ] )
    const graphfnc = ${props.constructor.toString()}

    const proxy = Gibberish.factory( ugen, graphfnc(), '${name}', ${JSON.stringify(properties)} )
    return proxy`

    Gibberish[ name ] = new Function( block )

    Gibberish.worklet.port.postMessage({
      name,
      address:'addConstructor',
      constructorString:`function( Gibberish ) {
      const fnc = ${Gibberish[ name ].toString()}

      return fnc
    }`
    })

    const out = Audio.Ugen( 
      Gibberish[ name  ],
      { properties, methods:[], name, category:'instruments'},
      Audio 
    )
    return out
  }

  return fnc
}

/* example use:
def = {
  name:'Mysine',
  type:'Ugen',
  properties:{ frequency:220 },
  constructor: function() {
    const gen = Gibberish.genish
    const graph = gen.cycle( gen.in('frequency') )
    return graph
  }
}
 
Mysine = Make( def )
sine = S()
sine.frequency.seq( [110,220,330], 1/8 )
sine.connect()
*/

},{}],108:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const Ugen      = require( './ugen.js' )

const Oscillators = {
  create( Audio ) {
    const oscillators = {}
    const defaults = {
      frequency:220, gain:.25, pulsewidth:.5
    }
    for( let oscillatorName in Gibberish.oscillators ) {
      const gibberishConstructor = Gibberish.oscillators[ oscillatorName ]

      //const methods = Oscillators.descriptions[ oscillatorName ] === undefined ? null : Oscillators.descriptions[ oscillatorName ].methods
      const description = { 
        properties:defaults, 
        methods:[],
        name:oscillatorName,
        category:'oscillators'
      }

      oscillators[ oscillatorName ] = Ugen( gibberishConstructor, description, Audio )

    }
    return oscillators
  },

  descriptions: {},
  
}

module.exports = Oscillators

},{"./ugen.js":128,"gibberish-dsp":174}],109:[function(require,module,exports){
const Presets = {
  process( description, args, Audio ) {
    let output

    // if the constructor arugment is not a string then no preset is being used
    if( typeof args[0] === 'object' ) {
      output = args[ 0 ]  
    }else if( typeof args[0] === 'string' ){
      if( args[0] === 'inspect' ) return null
      output = {}
      const preset = Presets[ description.category ][ description.name ][ args[0] ]

      if( preset !== undefined ) {
        for( let key in preset ) {
          if( key === 'presetInit' ) continue
          let value = preset[ key ]

          // if a value is a function, run the function to get the new value. these
          // preset functions are passed the main audio object, which they can typically
          // use, for example, to query the current sample rate.
          output[ key ] = typeof value === 'function' ? value( Audio ) : value
        }
        
        if( preset.presetInit !== undefined ) {
          output.__presetInit__ = preset.presetInit 
        } 
      }else{
        console.warn( `The preset ${args[0]} for the ${description.category.slice(0,-1)} ${description.name} does not exist.` )
      }
      // if there is an extra argument to modify the preset...
      if( args.length > 1 ) {
        Object.assign( output, args[1] )
      }
    }else{
      output = {}
    }
    
    if( description.__defaults__ !== undefined ) {
      console.log( 'defaults:', description.__defaults__ )
      Object.assign( output, description.__defaults__ )
    }

    return output
  },

  instruments: {
    Complex: require( './presets/complex_presets.js' ),
    Synth: require( './presets/synth_presets.js' ),
    FM:    require( './presets/fm_presets.js' ),
    Monosynth: require( './presets/monosynth_presets.js' ),
    PolyMono: require( './presets/monosynth_presets.js' ),
    Snare: require( './presets/snare_presets.js' ),
    Kick: require( './presets/kick_presets.js' ),
    Hat: require( './presets/hat_presets.js' ),

    EDrums: require( './presets/edrums_presets.js' ),
    Drums:  require( './presets/drums_presets.js' ),
    Multisampler: require( './presets/multisampler.js' ),
    Soundfont:    require( './presets/soundfont_presets.js' )
  },

  effects: {
    Chorus: require( './presets/chorus_presets.js' ),
    Distortion: require( './presets/distortion_presets.js' ),
    Flanger: require( './presets/flanger_presets.js' ),
    Reverb: require( './presets/reverb.js' ),
    Delay: require( './presets/delay_presets.js' ),
  },

  misc: {
    Bus2: require( './presets/bus2_presets.js' )
  }

}

Presets.instruments.Sampler   = Presets.instruments.Multisampler
Presets.instruments.PolySynth = Presets.instruments.Synth
Presets.instruments.PolyFM = Presets.instruments.FM
Presets.instruments.PolyMono = Presets.instruments.Monosynth

module.exports = Presets

},{"./presets/bus2_presets.js":110,"./presets/chorus_presets.js":111,"./presets/complex_presets.js":112,"./presets/delay_presets.js":113,"./presets/distortion_presets.js":114,"./presets/drums_presets.js":115,"./presets/edrums_presets.js":116,"./presets/flanger_presets.js":117,"./presets/fm_presets.js":118,"./presets/hat_presets.js":119,"./presets/kick_presets.js":120,"./presets/monosynth_presets.js":121,"./presets/multisampler.js":122,"./presets/reverb.js":123,"./presets/snare_presets.js":124,"./presets/soundfont_presets.js":125,"./presets/synth_presets.js":126}],110:[function(require,module,exports){
module.exports = {

  'spaceverb': {
    presetInit: function( audio ) {
      this.fx.verb = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.verb )
    }
  },
  'echoverb.1/3': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/3, feedback:.35, wetdry:.5 })
      this.fx.reverb  = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.delay )
      this.fx.add( this.fx.reverb )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
      this.roomSize = this.fx.reverb.roomSize
    }
  },
  'echoverb.1/6': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/6, feedback:.35, wetdry:.5 })
      this.fx.verb  = audio.effects.Freeverb({ roomSize:.985, dry:1 })
      this.fx.add( this.fx.delay, this.fx.reverb )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
      this.roomSize = this.fx.reverb.roomSize
    }
  },
  'delay.1/6': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/6, feedback:.35, wetdry:.5 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/3': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/3, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  }, 
  'delay.1/6.fb': {
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ time:1/6, feedback:.825, wetdry:1 })
      this.fx.add( this.delay ) 
    }
  },
  'delay.1/3.fb': {
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ time:1/3, feedback:.825, wetdry:1 })
      this.fx.add( this.delay )
    }
  },
  'delay.1/5': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/5, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/8': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/8, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
      this.feedback = this.fx.delay.feedback
      this.time = this.fx.delay.time
    }
  },
  'delay.1/9': {
    presetInit: function( audio ) {
      this.fx.delay = audio.effects.Delay({ time:1/9, feedback:.35, wetdry:1 })
      this.fx.add( this.fx.delay )
    }
  },
}

},{}],111:[function(require,module,exports){
module.exports = {

  lush: {
    fastFrequency:4,
    fastGain:.425,
    slowGain:3.5,
    slowFrequency:1,
    presetInit: function( audio ) {
      const gen = audio.Gen.ugens
      this.mod1 = audio.Gen.make( audio.Gen.ugens.cycle(.1) ).connect( this.fastFrequency )
      //this.fastGain =  audio.Gen.make( gen.add( .425, gen.cycle(.1) ) )
      this.mod2 = audio.Gen.make( audio.Gen.ugens.cycle(.05) ).connect( this.slowGain )
      //this.slowGain = audio.Gen.make( gen.add( 4.5, gen.cycle(.05) ) )
    }
  },

  warbly: {
    fastFrequency:4,
    slowGain:3,
    slowFrequency:1,
    fastGain:1.5,
    presetInit: function( audio ) {
      this.mod1 = audio.Gen.make( audio.Gen.ugens.cycle(.1) ).connect( this.fastFrequency )
      this.mod2 = audio.Gen.make( audio.Gen.ugens.cycle(.05) ).connect( this.slowGain )
    }
  }

}

},{}],112:[function(require,module,exports){
module.exports = {
  'plucked': {
    bias:.35,
    gain:1,
    decay:1/5,
    pregain:4,
    description:'a short, clean sounding preset with a minimum of distortion/wavefolding.'
  },
  
  'perc': {
    bias:.35,
    gain:1,
    decay:1/5,
    pregain:5,
    description:'a short, clean sounding preset with a minimum of distortion/wavefolding.'
  },

  stab: {
    waveform:'saw', 
    decay:1/4, 
    bias:.1, 
    filterMult:0, 
    cutoff:.8, 
    Q:.15, 
    pregain:10, 
    postgain:.25, 
    filterModel:2, 
    saturation:50,
    presetInit( audio ) {
      this.fx.push( audio.effects.Distortion('earshred') )
    },
    description:'a short, heavily distorted and filtered sound. in addition to the standard Complex wavefolding, this preset also adds an additional Distortion effect (preset earsred).'
  }

}

},{}],113:[function(require,module,exports){
module.exports = {
  '1/3' : {
    time:1/3, feedback:.35, wetdry:1 
  },
  '1/6' : {
    time:1/6, feedback:.35, wetdry:1
  },
  '1/8' : {
    time:1/8, feedback:.35, wetdry:1
  },
  '1/9' : {
    time:1/9, feedback:.35, wetdry:1
  },
  '1/3.fb' : {
    time:1/3, feedback:.85, wetdry:1 
  },
  '1/6.fb' : {
    time:1/6, feedback:.85, wetdry:1
  },
  '1/8.fb' : {
    time:1/8, feedback:.85, wetdry:1
  },
  '1/9.fb' : {
    time:1/9, feedback:.85, wetdry:1
  },
  '1/3.dry' : {
    time:1/3, feedback:.35, wetdry:.5 
  },
  '1/6.dry' : {
    time:1/6, feedback:.35, wetdry:.5
  },
  '1/8.dry' : {
    time:1/8, feedback:.35, wetdry:.5
  },
  '1/9.dry' : {
    time:1/9, feedback:.35, wetdry:.5
  },
  '1/3.dry.fb' : {
    time:1/3, feedback:.85, wetdry:.5 
  },
  '1/6.dry.fb' : {
    time:1/6, feedback:.35, wetdry:.5
  },
  '1/8.dry.fb' : {
    time:1/8, feedback:.85, wetdry:.5
  },
  '1/9.dry.fb' : {
    time:1/9, feedback:.85, wetdry:.5
  }
}

},{}],114:[function(require,module,exports){
module.exports = {

  crunch: {
    pregain:10, 
    postgain:.35
  },

  earshred: {
   pregain: 500,
   postgain: .06,
   shape1: .001,
   shape2: -3
  },

  bass: {
    pregain:10,
    postgain:.35,
    shape1:3,
    shape2:10
  },

  medium: {
    pregain:40,
    postgain:.125/4
  }
}

},{}],115:[function(require,module,exports){
module.exports = {

  earshred: {
    // unfortunately you can't write normal presets for
    // Drums and EDrums, because they don't go through
    // the Ugen constructor in the typical way (they are
    // processed as busses). It would also
    // be difficult to define properties for the individual
    // drum components (snare,kick etc.) using the standard
    // preset format. For these reasons, all property assignment
    // must be performed after initialization. 
    presetInit( audio ) {
      this.fx.add( audio.effects.Distortion('earshred') )
    }
  },

  hpf: {
    presetInit( audio ) {
      // XXX have to specify input because of filter errors...
      const hpf = audio.filters.Filter12Biquad({ input:this, mode:1, cutoff:.25, Q:.5, isStereo:true })
      this.fx.add( hpf )
      this.hpf = hpf
   }
  },
  lpf: {
    presetInit( audio ) {
      // XXX have to specify input because of filter errors...
      const lpf = audio.filters.Filter24Moog({ input:this, mode:0, cutoff:.25, Q:.75, isStereo:true })
      this.fx.add( lpf )
      this.lpf = lpf
    }
  }

}

},{}],116:[function(require,module,exports){
module.exports = {

  earshred: {
    // unfortunately you can't write normal presets for
    // Drums and EDrums, because they don't go through
    // the Ugen constructor in the typical way (they are
    // processed as busses). It would also
    // be difficult to define properties for the individual
    // drum components (snare,kick etc.) using the standard
    // preset format. For these reasons, all property assignment
    // must be performed after initialization. 
    presetInit( audio ) {
      this.fx.add( audio.effects.Distortion('earshred') )

      this.kick.frequency = 55
      this.kick.decay = .975

      this.snare.tune = .25
      this.snare.snappy = 1.5
    }
  },

  warbly: {
    presetInit( audio ) {
      const bc = audio.effects.BitCrusher({ input:this, sampleRate:.35, bitDepth:.5, isStereo:true })
      this.fx.add( bc )
      this.bitcrusher = bc
      const flanger = audio.effects.Flanger({ input:this, frequency:.8, feedback:.935, isStereo:true })
      this.fx.add( flanger )
      this.flanger = flanger
      this.gain.value *= 1.35
   }
  },
  hpf: {
    presetInit( audio ) {
      const hpf = audio.filters.Filter12Biquad({ input:this, mode:1, cutoff:.35, isStereo:true })
      this.fx.add( hpf )
      this.hpf = hpf
   }
  },
  lpf: {
    presetInit( audio ) {
      const lpf = audio.filters.Filter24Moog({ input:this, mode:1, cutoff:.35, isStereo:true })
      this.fx.add( lpf )
      this.lpf = lpf
    }
  },
  short: {
    presetInit( audio ) {
      this.kick.decay = .8
      this.snare.decay = .05
      this.closedHat.decay = .05
      this.openHat.decay = .2
      this.cowbell.decay = .1
    }
  },
  long: {
    presetInit( audio ) {
      this.kick.decay = .975
      this.snare.decay = .1
      this.closedHat.decay = .1
      this.openHat.decay = .25
    }
  }

}

},{}],117:[function(require,module,exports){
module.exports = {
  moderate: {
    feedback: .25,
    frequency:.5,
    offset:.1
  },

  extreme: {
    feedback:.85,
    offset:.05,
    frequency:4
  },

}

},{}],118:[function(require,module,exports){
module.exports = {

  bass : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/16,
    octave:-2
  },
  deepbass : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/2,
    octave:-3,
    feedback:.005
  },
  kick:{
    attack : 1/4096,
    index : 5,
    cmRatio : 4/3,
    decay : 1/4,
    octave : -3,
    shape:'exponential'
  },

  perc:{
    attack : 1/4096,
    index : .5,
    cmRatio : 4/3,
    decay : 1/8,
    shape:'exponential',
    presetInit: function( audio ) {
      if( this.voices && this.voices.length > 1 ) {
        this.spread( .99 )
      }
    }
  },

  'bass.electro' : {
    cmRatio:1,
    index:3,
    attack:1/256,
    decay:1/16,
    octave:-2,
    filterModel:2,
    saturation:200,
    Q:.25,
    cutoff:.6835
  },

  glockenspiel : {
    cmRatio	: 3.5307,
    index 	: 1,
    attack	: audio => audio.Clock.ms( 1 ),
    decay	: audio => audio.Clock.ms( 1000 ),
  },

  'glockenspiel.short' : {
    cmRatio	: 3.5307,
    index 	: 1,
    attack	: audio => audio.Clock.ms( 1 ),
    decay	  : 1/12,
    octave  : 1,
    gain    :.05 
  },

  frog : { //ljp
    cmRatio: 0.1,
    index: 2.0,
    attack: audio => audio.Clock.ms( 300 ), 
    decay: audio => audio.Clock.ms( 5 )
  },

  gong : {
    cmRatio: 1.4,
	  index: .95,
	  attack: 1/256,
	  decay: 2,
	},

  drum : {
	  cmRatio: 1.40007,
	  index: 2,
	  attack: 1/2048,
    decay: audio => audio.Clock.ms(1000) 
	},

	drum2: {
		cmRatio: 1 + Math.sqrt(2),
		index: .2,
		attack: 1/256,
		decay: audio => audio.Clock.ms(20) 
  },

	brass : {
    maxVoices:4,
	  cmRatio : 1 / 1.0007,
		index	: 5,
		attack: audio => audio.Clock.ms(100),
		decay	: 1,
    gain:.5,
  },

	clarinet : {
		cmRatio	: 3 / 2,
		index	: 1.5,
		attack: audio => audio.Clock.ms( 50 ), 
		decay:  audio => audio.Clock.ms( 200 )
  },

  fun : {
    decay:1/2,
    feedback: .0015,
    gain:.1
  },

  chirp: {
		attack: audio => audio.Clock.ms( 1 ), 
    index : 1.15,
    glide : 1,
    feedback : .5,
    cmRatio : 1.5,
    decay : 1/4,
    octave : 1,
    shape:'exponential'
  }
}

},{}],119:[function(require,module,exports){
module.exports = {
  short: {
    decay:.01
  }
}

},{}],120:[function(require,module,exports){
module.exports = {

  deep: {
    frequency:55,
    decay:.96,
  },

  tight: {
    frequency:80, 
    decay:.85,
    tone:.5
  },

  long: {
    frequency:80,
    decay:.975,
  },

  boom: {
    frequency:55,
    decay:.99,
    tone:.05
  }


}

},{}],121:[function(require,module,exports){
module.exports = {

  'short.dry' : { 
    attack: audio => audio.Clock.ms(.25), 
    decay: 1/12,
    cutoff:.3,
    filterModel:1,
    filterMult:3
  },

  arpy : {
    antialias:true,
    attack: audio => audio.Clock.ms(.5),
    decay: 1/16, 
    gain:0.2,
    cutoff:.15,
    filterMult:1,
    Q:.3,
    filterModel:1,
    filterMode:1
  },

  lead : {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.5),
    decay: 1/2, 
    octave3:0,
    cutoff:1,
    filterMult:2.5,
    Q:.975,
    filterModel:1,
    filterMode:1
  },
  // not as bright / loud
  lead2 : {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.5),
    decay: 1/2, 
    octave3:0,
    cutoff:1,
    filterMult:2.5,
    Q:.8,
    gain:.175,
    filterModel:1,
    filterMode:1
  },

  dirty: { 
    gain:.325,
    filterModel:2,
    attack:1/2048, 
    decay:1/4, 
    cutoff:1.5, 
    filterMult:4, 
    saturation:10000, 
    Q:.225, 
    detune2:-.505,
    detune3:-.5075,
    octave:-2,
    waveform:'pwm', 
    pulsewidth:.15 
  },

  winsome : {
    presetInit : function( audio ) { 
      this.lfo = audio.oscillators.Sine({ frequency:2, gain:.075 })
      this.lfo.connect( this.cutoff )
      this.lfo.connect( this.detune2 )
      this.lfo.connect( this.detune3 )
    },
    attack: audio => audio.Clock.ms(1), 
    decay:1,
    cutoff:.2,
  },

  pluckEcho: {
    presetInit : function( audio ) { this.fx.push( audio.effects.Delay({ time:1/6, feedback:.65 }) )  },
    attack: audio => audio.Clock.ms(.1),
    decay: 1/16, 
    octave3:0,
    cutoff:.15,
    filterMult:1,
    Q:.5,
    filterModel:1,
    filterMode:1,
    panVoices:true
  },

  bassPad : { 
    attack: audio => audio.Clock.ms(.1),
    decay: 2,	
    octave:-4,
    cutoff: .225,
    filterMult:3.5,
    Q:.5,
    detune2:1.0125,
    detune3:1-.0125
  },

  warble : { 
    attack: audio => audio.Clock.ms(1),
    decay: 1/2,	
    octave: -3,
    octave2 : -1,
    cutoff: .8,
    filterMult:3,
    Q:.75,
    detune2:.0275,
    detune3:-.0275
  }, 
  dark: { 
    attack: audio => audio.Clock.ms(1),
    decay: 1,	
    octave: -3,
    octave2 : -1,
    cutoff: 1.5,
    filterMult:3,
    Q:.75,
    detune2:.0125,
    detune3:-.0125
  },
  bass: { 
    attack: audio => audio.Clock.ms(1),
    decay: 1/4,	
    octave: -3,
    cutoff: .35,
    filterMult:3,
    Q:.15,
    glide:1250,
    waveform:'pwm',
    pulsewidth:.45,
    detune2:.005,
    detune3:-.005
  },
  bass2 : {
    attack: audio => audio.Clock.ms(1), 
    decay:	1/6,
    octave: -2,
    octave2 : 0,
    octave3 : 0,      
    cutoff: .5,
    filterMult:2,
    Q:.5,
    gain:.35
  },
  
  edgy: {
    decay:1/8,
    attack:1/1024,
    octave: -2,
    octave2: -1,
    cutoff: .5,
    filterMult:3,
    Q:.75, 
    waveform:'pwm', 
    pulsewidth:.2,
    detune2:0,
    gain:.2
  },

  easy : {
    attack: audio=> audio.Clock.ms(1),
    decay:2,
    cutoff:.3,
    glide:.9995,
  },
  
  easyfx : {
    attack: audio=> audio.Clock.ms(1),
    decay:2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Delay( Clock.time(1/6), .3) )
    },
    cutoff:.125,
    glide:1000,
    detune2:.001,
    detune3:-.001,
    filterModel:1,
    filterMult:4,
    Q:.5,
  },
  chords: {
    attack: audio=> audio.Clock.ms(1),
    decay:1/2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Delay( Clock.time(1/6), .5) )
    },
    amp:.3,
    octave2:0,
    octave3:0,
    cutoff:.5,
    glide:.9995,
    filterModel:1,
    filterMult:3,
    Q:.75,
  },

  wander: {
    attack: 1/2,
    decay:  2,
    presetInit: function( audio ) {},
    amp:.2,
    detune2:.501,
    detune3:-.501,
    cutoff:.2,
    glide:5000,
    filterModel:1,
    filterMult:1.5,
    Q:.25,
  },

  'chords.short': {
    attack: audio=> audio.Clock.ms(1),
    decay:1/8,
    presetInit: function( audio ) {
      this.delay = audio.effects.Delay({ delay:audio.Clock.time(1/8), feedback:.5, wetdry:.25 }) 
      this.fx.push( this.delay )
    },
    amp:.3,
    octave2:0,
    octave3:0,
    cutoff:.35,
    glide:1,
    filterModel:1,
    filterMult:3,
    Q:.5,
  },

  jump: { 
    decay:1/2048, 
    useADSR:true, 
    sustain:1/4, 
    release:1/1024,  
    maxVoices:3, 
    cutoff:35, 
    filterMult:0,
    detune2:.01,
    detune3:-.01 
  },

  shinybass2: {
    Q:.125,
    cutoff:35,
    useADSR:true,
    decay:1/10,
    sustain:1/4,
    filterMult:0,
    release:1/1024,
    octave:-3,
    panVoices:true
  },
  shinybass: {
    Q:.125,
    cutoff:5,
    useADSR:false,
    attack:1/1024,
    decay:1/10,
    filterMult:0,
    octave:-3,
    panVoices:true
  },

  'bass.muted': {
    Q:.45,
    cutoff:.5,
    useADSR:true,
    shape:'exponential',
    decay:1/8,
    sustain:1/4,
    release:1/1024,
    octave:-3,
    panVoices:true,
    filterMult:.5
  },
  'bass.stab': {
    Q:.35,
    detune2:1.5,
    detune3:.5,
    cutoff:.5,
    useADSR:true,
    shape:'exponential',
    decay:1/10,
    sustain:1/4,
    release:1/1024,
    octave:-3,
    filterMult:1.85,
    gain:.75
  },
  short: { 
    attack:1/4096,
    decay:1/16, 
    maxVoices:3, 
    cutoff:1.5, 
    filterMult:0,
    useADSR:false,
    gain:.5
  },

  noise: {
    decay:1/2,
    cutoff:.3,
    glide:10000,
    detune3:0,
    detune2:0,
    filterMult:0,
    presetInit: function( audio ) { this.fx.add( audio.effects.Gain(.1), audio.effects.Delay(1/6,.75) ) }
  },

}

},{}],122:[function(require,module,exports){
module.exports = {

  drums: { 
    files:[
      'resources/audiofiles/kick.wav',
      'resources/audiofiles/hat.wav',
      'resources/audiofiles/snare.wav',
      'resources/audiofiles/openhat.wav'
    ],
    presetInit() {
      this.length = 4
    }
  },
  test: {
    files:[
      'resources/audiofiles/kick.wav',
      'resources/audiofiles/openhat.wav'
    ],
    presetInit() {
      this.length = 2
    }
  },
  beatbox: {
    files:[
      'resources/audiofiles/beatbox/^k.wav',
      'resources/audiofiles/beatbox/^p.wav',
      'resources/audiofiles/beatbox/^tss.wav',
      'resources/audiofiles/beatbox/8.wav',
      'resources/audiofiles/beatbox/a.wav',
      'resources/audiofiles/beatbox/b.wav',
      'resources/audiofiles/beatbox/d.wav',
      'resources/audiofiles/beatbox/dot.wav',
      'resources/audiofiles/beatbox/duf.wav',
      'resources/audiofiles/beatbox/f.wav',
      'resources/audiofiles/beatbox/k.wav',
      'resources/audiofiles/beatbox/h.wav',
      'resources/audiofiles/beatbox/m.wav',
      'resources/audiofiles/beatbox/n.wav',
    ],
    presetInit() {
      this.length = 14
    }
  },
  bleeps: {
    files:[
      'resources/audiofiles/bent-bleeps/51063__stamperadam__bleep1.wav',
      'resources/audiofiles/bent-bleeps/51064__stamperadam__bleep2.wav',
      'resources/audiofiles/bent-bleeps/51065__stamperadam__clap.wav',
      'resources/audiofiles/bent-bleeps/51066__stamperadam__click.wav',
      'resources/audiofiles/bent-bleeps/51067__stamperadam__click1.wav',
      'resources/audiofiles/bent-bleeps/51068__stamperadam__g1.wav',
      'resources/audiofiles/bent-bleeps/51069__stamperadam__g2.wav',
      'resources/audiofiles/bent-bleeps/51070__stamperadam__g3.wav',
      'resources/audiofiles/bent-bleeps/51071__stamperadam__g4.wav',
      'resources/audiofiles/bent-bleeps/51072__stamperadam__g5.wav',
      'resources/audiofiles/bent-bleeps/51073__stamperadam__g6.wav',
      'resources/audiofiles/bent-bleeps/51074__stamperadam__g7.wav',
      'resources/audiofiles/bent-bleeps/51075__stamperadam__g8.wav',
      'resources/audiofiles/bent-bleeps/51076__stamperadam__g9.wav',
      'resources/audiofiles/bent-bleeps/51077__stamperadam__glitch.wav',
      'resources/audiofiles/bent-bleeps/51078__stamperadam__hatt.wav',
      'resources/audiofiles/bent-bleeps/51079__stamperadam__hit.wav',
      'resources/audiofiles/bent-bleeps/51080__stamperadam__hitt.wav',
      'resources/audiofiles/bent-bleeps/51081__stamperadam__hum.wav',
      'resources/audiofiles/bent-bleeps/51082__stamperadam__kik.wav',
      'resources/audiofiles/bent-bleeps/51083__stamperadam__snar.wav',
      'resources/audiofiles/bent-bleeps/51084__stamperadam__wa.wav',
    ],
    presetInit() {
      this.length = 22
    }
  },
  cr7030: {
    files:[
      'resources/audiofiles/cr7030/68602__birdflu__bongo7030.wav',
      'resources/audiofiles/cr7030/68603__birdflu__clave7030.wav',
      'resources/audiofiles/cr7030/68606__birdflu__hatclosed7030.wav',
      'resources/audiofiles/cr7030/68607__birdflu__hatopen7030.wav',
      'resources/audiofiles/cr7030/68608__birdflu__kick7030.wav',
      'resources/audiofiles/cr7030/68609__birdflu__snare7030.wav',
      'resources/audiofiles/cr7030/68610__birdflu__tom7030.wav',
    ],
    presetInit(){
      this.length = 7
    }
  },
  kicks: {
    files:[
      'resources/audiofiles/kicks/249200__netr-si__kick-32.wav',
      'resources/audiofiles/kicks/249201__netr-si__kick-33.wav',
      'resources/audiofiles/kicks/249202__netr-si__kick-27.wav',
      'resources/audiofiles/kicks/249203__netr-si__kick-28.wav',
      'resources/audiofiles/kicks/249204__netr-si__kick-25.wav',
      'resources/audiofiles/kicks/249205__netr-si__kick-26.wav',
      'resources/audiofiles/kicks/249206__netr-si__kick-30.wav',
      'resources/audiofiles/kicks/249207__netr-si__kick-31.wav',
      'resources/audiofiles/kicks/249208__netr-si__kick-29.wav',
      'resources/audiofiles/kicks/249209__netr-si__kick-3.wav',
      'resources/audiofiles/kicks/249211__netr-si__kick-42.wav',
      'resources/audiofiles/kicks/249212__netr-si__kick-41.wav',
      'resources/audiofiles/kicks/249213__netr-si__kick-35.wav',
      'resources/audiofiles/kicks/249214__netr-si__kick-34.wav',
      'resources/audiofiles/kicks/249215__netr-si__kick-37.wav',
      'resources/audiofiles/kicks/249216__netr-si__kick-36.wav',
      'resources/audiofiles/kicks/249217__netr-si__kick-39.wav',
      'resources/audiofiles/kicks/249218__netr-si__kick-38.wav',
      'resources/audiofiles/kicks/249219__netr-si__kick-40.wav',
      'resources/audiofiles/kicks/249220__netr-si__kick-4.wav',
      'resources/audiofiles/kicks/249222__netr-si__kick-87.wav',
      'resources/audiofiles/kicks/249223__netr-si__kick-9.wav',
      'resources/audiofiles/kicks/249224__netr-si__kick-83.wav',
      'resources/audiofiles/kicks/249225__netr-si__kick-84.wav',
      'resources/audiofiles/kicks/249226__netr-si__kick-85.wav',
      'resources/audiofiles/kicks/249227__netr-si__kick-86.wav',
      'resources/audiofiles/kicks/249228__netr-si__kick-8.wav',
      'resources/audiofiles/kicks/249229__netr-si__kick-80.wav',
      'resources/audiofiles/kicks/249230__netr-si__kick-81.wav',
      'resources/audiofiles/kicks/249231__netr-si__kick-82.wav',
      'resources/audiofiles/kicks/249232__netr-si__kick-20.wav',
      'resources/audiofiles/kicks/249233__netr-si__kick-2.wav',
      'resources/audiofiles/kicks/249234__netr-si__kick-19.wav',
      'resources/audiofiles/kicks/249235__netr-si__kick-18.wav',
      'resources/audiofiles/kicks/249236__netr-si__kick-24.wav',
      'resources/audiofiles/kicks/249237__netr-si__kick-23.wav',
      'resources/audiofiles/kicks/249238__netr-si__kick-22.wav',
      'resources/audiofiles/kicks/249239__netr-si__kick-21.wav',
      'resources/audiofiles/kicks/249240__netr-si__kick-25-2.wav',
      'resources/audiofiles/kicks/249241__netr-si__kick-25-1.wav',
      'resources/audiofiles/kicks/249242__netr-si__kick-12.wav',
      'resources/audiofiles/kicks/249243__netr-si__kick-11.wav',
      'resources/audiofiles/kicks/249244__netr-si__kick-10.wav',
      'resources/audiofiles/kicks/249245__netr-si__kick-1.wav',
      'resources/audiofiles/kicks/249246__netr-si__kick-15.wav',
      'resources/audiofiles/kicks/249247__netr-si__kick-14.wav',
      'resources/audiofiles/kicks/249248__netr-si__kick-14-1.wav',
      'resources/audiofiles/kicks/249249__netr-si__kick-13.wav',
      'resources/audiofiles/kicks/249250__netr-si__kick-17.wav',
      'resources/audiofiles/kicks/249251__netr-si__kick-16.wav',
      'resources/audiofiles/kicks/249252__netr-si__kick-67.wav',
      'resources/audiofiles/kicks/249253__netr-si__kick-68.wav',
      'resources/audiofiles/kicks/249254__netr-si__kick-65.wav',
      'resources/audiofiles/kicks/249255__netr-si__kick-66.wav',
      'resources/audiofiles/kicks/249256__netr-si__kick-63.wav',
      'resources/audiofiles/kicks/249257__netr-si__kick-64.wav',
      'resources/audiofiles/kicks/249258__netr-si__kick-61.wav',
      'resources/audiofiles/kicks/249259__netr-si__kick-62s.wav',
      'resources/audiofiles/kicks/249260__netr-si__kick-69.wav',
      'resources/audiofiles/kicks/249261__netr-si__kick-7.wav',
      'resources/audiofiles/kicks/249262__netr-si__kick-75.wav',
      'resources/audiofiles/kicks/249263__netr-si__kick-74.wav',
      'resources/audiofiles/kicks/249264__netr-si__kick-77.wav',
      'resources/audiofiles/kicks/249265__netr-si__kick-76.wav',
      'resources/audiofiles/kicks/249266__netr-si__kick-71.wav',
      'resources/audiofiles/kicks/249267__netr-si__kick-70.wav',
      'resources/audiofiles/kicks/249268__netr-si__kick-73.wav',
      'resources/audiofiles/kicks/249269__netr-si__kick-72.wav',
      'resources/audiofiles/kicks/249270__netr-si__kick-79.wav',
      'resources/audiofiles/kicks/249271__netr-si__kick-78.wav',
      'resources/audiofiles/kicks/249272__netr-si__kick-43.wav',
      'resources/audiofiles/kicks/249273__netr-si__kick-44.wav',
      'resources/audiofiles/kicks/249274__netr-si__kick-45.wav',
      'resources/audiofiles/kicks/249275__netr-si__kick-46.wav',
      'resources/audiofiles/kicks/249276__netr-si__kick-47.wav',
      'resources/audiofiles/kicks/249277__netr-si__kick-48.wav',
      'resources/audiofiles/kicks/249278__netr-si__kick-49.wav',
      'resources/audiofiles/kicks/249279__netr-si__kick-5.wav',
      'resources/audiofiles/kicks/249280__netr-si__kick-50.wav',
      'resources/audiofiles/kicks/249281__netr-si__kick-51.wav',
      'resources/audiofiles/kicks/249282__netr-si__kick-60.wav',
      'resources/audiofiles/kicks/249283__netr-si__kick-6.wav',
      'resources/audiofiles/kicks/249284__netr-si__kick-59.wav',
      'resources/audiofiles/kicks/249285__netr-si__kick-58.wav',
      'resources/audiofiles/kicks/249286__netr-si__kick-57.wav',
      'resources/audiofiles/kicks/249287__netr-si__kick-56.wav',
      'resources/audiofiles/kicks/249288__netr-si__kick-55.wav',
      'resources/audiofiles/kicks/249289__netr-si__kick-54.wav',
      'resources/audiofiles/kicks/249290__netr-si__kick-53.wav',
      'resources/audiofiles/kicks/249291__netr-si__kick-52.wav',
    ],
    presetInit() { this.length = 90 }
  }
}

},{}],123:[function(require,module,exports){
module.exports = {

  'space': {
    roomSize:.985, 
    dry:1 
  }
}

},{}],124:[function(require,module,exports){
module.exports = {

  snappy: {
    decay:.125,
    snappy:1.5,
    tune:.1
  },

  dull: {
    snappy:.15,
    decay:.15,
    tune:-.1
  }

}

},{}],125:[function(require,module,exports){
 const names = [
    "Acoustic Grand Piano",
    "Bright Acoustic Piano",
    "Electric Grand Piano",
    "Honky-tonk Piano",
    "Electric Piano 1",
    "Electric Piano 2",
    "Harpsichord",
    "Clavi",
    "Celesta",
    "Glockenspiel",
    "Music Box",
    "Vibraphone",
    "Marimba",
    "Xylophone",
    "Tubular Bells",
    "Dulcimer",
    "Drawbar Organ",
    "Percussive Organ",
    "Rock Organ",
    "Church Organ",
    "Reed Organ",
    "Accordion",
    "Harmonica",
    "Tango Accordion",
    "Acoustic Guitar (nylon)",
    "Acoustic Guitar (steel)",
    "Electric Guitar (jazz)",
    "Electric Guitar (clean)",
    "Electric Guitar (muted)",
    "Overdriven Guitar",
    "Distortion Guitar",
    "Guitar harmonics",
    "Acoustic Bass",
    "Electric Bass (finger)",
    "Electric Bass (pick)",
    "Fretless Bass",
    "Slap Bass 1",
    "Slap Bass 2",
    "Synth Bass 1",
    "Synth Bass 2",
    "Violin",
    "Viola",
    "Cello",
    "Contrabass",
    "Tremolo Strings",
    "Pizzicato Strings",
    "Orchestral Harp",
    "Timpani",
    "String Ensemble 1",
    "String Ensemble 2",
    "SynthStrings 1",
    "SynthStrings 2",
    "Choir Aahs",
    "Voice Oohs",
    "Synth Voice",
    "Orchestra Hit",
    "Trumpet",
    "Trombone",
    "Tuba",
    "Muted Trumpet",
    "French Horn",
    "Brass Section",
    "SynthBrass 1",
    "SynthBrass 2",
    "Soprano Sax",
    "Alto Sax",
    "Tenor Sax",
    "Baritone Sax",
    "Oboe",
    "English Horn",
    "Bassoon",
    "Clarinet",
    "Piccolo",
    "Flute",
    "Recorder",
    "Pan Flute",
    "Blown Bottle",
    "Shakuhachi",
    "Whistle",
    "Ocarina",
    "Lead 1 (square)",
    "Lead 2 (sawtooth)",
    "Lead 3 (calliope)",
    "Lead 4 (chiff)",
    "Lead 5 (charang)",
    "Lead 6 (voice)",
    "Lead 7 (fifths)",
    "Lead 8 (bass + lead)",
    "Pad 1 (new age)",
    "Pad 2 (warm)",
    "Pad 3 (polysynth)",
    "Pad 4 (choir)",
    "Pad 5 (bowed)",
    "Pad 6 (metallic)",
    "Pad 7 (halo)",
    "Pad 8 (sweep)",
    "FX 1 (rain)",
    "FX 2 (soundtrack)",
    "FX 3 (crystal)",
    "FX 4 (atmosphere)",
    "FX 5 (brightness)",
    "FX 6 (goblins)",
    "FX 7 (echoes)",
    "FX 8 (sci-fi)",
    "Sitar",
    "Banjo",
    "Shamisen",
    "Koto",
    "Kalimba",
    "Bag pipe",
    "Fiddle",
    "Shanai",
    "Tinkle Bell",
    "Agogo",
    "Steel Drums",
    "Woodblock",
    "Taiko Drum",
    "Melodic Tom",
    "Synth Drum",
    "Reverse Cymbal",
    "Guitar Fret Noise",
    "Breath Noise",
    "Seashore",
    "Bird Tweet",
    "Telephone Ring",
    "Helicopter",
    "Applause",
    "Gunshot"
  ]

module.exports = {}

for( let name of names ) {
  module.exports[ name ] = {
    presetInit( audio, props ) {
      this.load( names.indexOf( name ), props === undefined ? 0 : props.bank || 0 )
    }
  }
}


},{}],126:[function(require,module,exports){
module.exports = {

  acidBass: {
    Q:.9,
    filterModel:2,
    filterMult:4,
    cutoff:1.25,
    saturation:3.5,
    attack:1/8192,
    decay:1/10,
    octave:-3,
    glide:2000,
    description:`A sawtooth feeding a TB303-style lowpass filter, with high Q settings and a short envelope.`
  },

  acidBass2: {
    Q:.7,
    filterModel:2,
    filterMult:3.5,
    cutoff:.5,
    saturation:10,
    attack:1/8192,
    decay:1/10,
    octave:-2,
    glide:100
  },

  'bass.hollow': {
    Q:.2,
    filterModel:2,
    filterMult:4,
    cutoff:1.25,
    saturation:20,
    attack:1/8192,
    decay:1/4,
    octave:-3,
    glide:1000
  },

  'bleep.dry': { 
    attack:1/256, decay:1/32, 
    waveform:'sine' 
  },
  'bleep': { 
    attack:1/256, decay:1/32, 
    waveform:'sine' 
  },

  'bleep.echo': { 
    waveform:'sine', 
    attack:1/256, decay:1/32, 
    gain:.25,
    presetInit: function( audio ) {
      this.fx.push( audio.effects.Delay({ feedback:.5, time:1/12 }) )
    }
  },

  shimmer: {
    attack:1/128, decay:2,
    waveform:'pwm',
    filterModel:1,
    cutoff:1,
    filterMult:1,
    Q:.6,
    maxVoices:3,
    gain:.1,
    antialias:false,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Chorus('warbly') )
      this.pwmod = audio.Gen.make( audio.Gen.ugens.mul( audio.Gen.ugens.cycle(8), .275 ) )
      this.pwmod.connect( this.pulsewidth )
    }
  },

  stringPad: {
    attack:1/2, decay:1.5, gain:.015,
    presetInit: function( audio ) {
      this.fx.chorus = audio.effects.Chorus('lush')
      this.fx.add( this.fx.chorus  )
    }
  },

  cry: {
    attack:1/2, decay:1.5, gain:.045,
    panVoices:true,
    presetInit: function( audio ) {
      this.chorus = audio.effects.Chorus('lush', { isStereo:true })
      this.fx.add( this.chorus  )
      this.bitCrusher = audio.effects.BitCrusher({ bitDepth:.5, isStereo:true })
      this.fx.add( this.bitCrusher )
      //// gen( .5 + cycle( btof(16) ) * .35
      this.srmod = audio.Gen.make( audio.Gen.ugens.add( .5, audio.Gen.ugens.mul( audio.Gen.ugens.cycle(.125/2), .35 ) ) )
      this.bitCrusher.sampleRate = this.srmod
      this.delay = audio.effects.Delay({ time:1/6, feedback:.75 })
      this.fx.add( this.delay )
    }
  },

  brass: {
    attack:1/6, decay:1.5, gain:.05,
    filterModel:1, Q:.5575, cutoff:2,
    presetInit: function( audio ) {
      this.fx.add( audio.effects.Chorus('lush') )
      this.chorus = this.fx[0]
    }
  },

  'brass.short':{
    gain:.75,
    filterModel:1,
    antialias:true,
    attack:1/32,
    decay:1/16,
    filterMult:3,
    cutoff:.175,
    Q:.6
  },

  'pwm.squeak':{
    waveform:'pwm',
    attack:1/4096,
    decay:1/16,
    Q:.8,
    cutoff:.65,
    saturation:5,
    filterModel:2,
    glide:500
  },

  'pwm.short':{
    attack:1/1024,
    decay:1/8,
    antialias:true,
    waveform:'pwm'
  },

  chirp: { filterModel:2, cutoff:.325, decay:1/16 }, 

  'square.perc': { 
    waveform:'square', 
    shape:'exponential', 
    antialias:true, 
    filterModel:2, 
    cutoff:.25, 
    decay:1/8,
    panVoices:true
  },

  'square.perc.long': { 
    waveform:'square', 
    shape:'exponential', 
    antialias:true, 
    filterModel:2, 
    cutoff:.25, 
    decay:2,
    panVoices:true
  },

  rhodes:{
    waveform:'sine',
    presetInit( audio ) {
      this.tremolo = audio.effects.Tremolo()
      this.fx.add( this.tremolo )
    },
    decay:4,
    gain:.125,
    shape:'exponential'
  },

  blank: {
    filterModel:0,
    waveform:'sine',
    antialias:false
  }
}

},{}],127:[function(require,module,exports){
const Gibberish = require( 'gibberish-dsp' )
const serialize = require( 'serialize-javascript' )
const Tune      = require( './external/tune-api-only.js' )

let Gibber = null

const Theory = {
  // needed to force library to be serialized for transport to 
  // worklet processor, must use key:function() {} format
  // for methods for serialize to work
  __Tune:Tune,

  Tune:null,
  id:null,
  type: 'Audio',
  nogibberish:true,
  quality:'minor',
  baseNumber:60,
  __tuning:'et',
  __mode: 'aeolian',
  __root:440,
  __offset:0,
  __degree:'i',
  __loadingPrefix:'js/external/tune.json/', 
  __tunings:{
    et: {
      root:'60',
      mode:'absolute',
      frequencies:[
        261.62558,
        277.182617,
        293.664764,
        311.126984,
        329.627563,
        349.228241,
        369.994415,
        391.995422,
        415.304688,
        440,
        466.163757,
        493.883301,
        523.251083727363
      ],
      description:'equal tempered (edo)'
    }
  },  

  modes: {
    ionian:     [0,2,4,5,7,9,11],
    dorian:     [0,2,3,5,7,9,10],
    phrygian:   [0,1,3,5,7,8,10],
    lydian:     [0,2,4,6,7,9,11],
    mixolydian: [0,2,4,5,7,9,10],
    aeolian:    [0,2,3,5,7,8,10],
    locrian:    [0,1,3,5,6,8,10],
    melodicminor:[0,2,3,5,7,8,11],
    wholeHalf:  [0,2,3,5,6,8,9,11],
    halfWhole:  [0,1,3,4,6,7,9,10],
    chromatic:  [0,1,2,3,4,5,6,7,8,9,10,11],
  },

  store:function() { 
    Gibberish.Theory = this

    this.Tune.TuningList = this.__tunings

    this.initProperties()
  },

  setup( tuning='et', mode='aeolian' ) {
    this.tuning = tuning
    this.mode = mode
  }, 

  // adapted from https://gist.github.com/stuartmemo/3766449
  __noteToFreq( note ) {
    note = note.toUpperCase() 

    let notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'],
        octave,
        keyNumber

    if (note.length === 3) {
      octave = note.charAt(2)
    } else {
      octave = note.charAt(1)
    }
    keyNumber = notes.indexOf(note.slice(0, -1))
    if (keyNumber < 3) {
      keyNumber = keyNumber + 12 + ((octave - 1) * 12) + 1
    } else {
      keyNumber = keyNumber + ((octave - 1) * 12) + 1
    }

    return 440 * Math.pow(2, (keyNumber- 49) / 12)
  },

  deleteProperties: function() {
    if( Gibberish.mode === 'worklet' ) {
      delete this.__root
      delete this.__tuning
      delete this.__mode
      delete this.__offset
      delete this.__degree

      Theory.markup = {
        textMarkers : {},
        cssClasses: {}
      }

      this.__root = 440
      this.__tuning = 'et'
      this.__offset = 0
      this.__degree = 'i'
      this.__mode = 'aeolian'
    }
  },

  initProperties: function() {
    if( Gibberish.mode === 'worklet' ) {
      Gibber.createProperty( 
        this, 'root', 440, function() {
          if( typeof Theory.__root.value === 'string' ) {
            Theory.root = Theory.__noteToFreq( Theory.__root.value )
          } 
        },
        
        1
      )

      Gibber.createProperty( 
        this, 'tuning', 'et', 
        function() { // XXX why doesn't this work??? duplicated below... 
          this.loadScale( this.__tuning.value ) 
        },
        1
      )

      Gibber.createProperty( this, 'mode', 'aeolian', null, 0 )
      Gibber.createProperty( this, 'offset', 0, null, 0 )
      Gibber.createProperty( this, 'degree', 'i', null, 0 )

      //setTimeout( ()=> Theory.tuning = 'et', 250 )
      this.tuning = 'et'
      //this.loadScale('et')
    }else{
      this.__initDegrees()

      Object.defineProperty( this, 'root', {
        get() { return this.__root },
        set(v) {
          if( typeof v=== 'string' ) {
            v = this.__noteToFreq( v )
          } 
          this.__root = v
          this.Tune.tonicize( this.__root )
        }
      })

      Object.defineProperty( this, 'tuning', {
        get() { return this.__tuning },
        set(v) {
          this.__tuning = v
          //this.loadScale( v )
        }
      })

      Object.defineProperty( this, 'mode', {
        get()  { return this.__mode },
        set(v) { 
          if( this.modes[ v ] !== undefined || v === null ) {
            this.__mode = v 
          }else{
            console.error( `The mode "${v}" is not valid. Valid modes include ${Object.keys(this.modes).toString()}, and null. No change to Theory.mode was applied.` )
          }
        }
      })

      Object.defineProperty( this, 'offset', {
        get()  { return this.__offset },
        set(v) { this.__offset = v }
      })

      Object.defineProperty( this, 'degree', { 
        get() { return this.__degree },
        set( __degree ) {
          if( typeof __degree  === 'string' ) {
            const degree = this.__degrees[ this.quality ][ __degree ]
        
            this.__degree = degree
            //this.rootNumber = degree.offset + this.baseNumber
            this.mode = degree.mode
          }
        }
      })

      this.degree = 'i'
    }
  },

  __degrees: { major:{}, minor:{} },

  __initDegrees:function() {
    const base = [ 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii' ]

    const scales = [ { name:'minor', values:this.modes.aeolian }, { name:'major', values:this.modes.ionian } ]

    for( let scale of scales ) {
      let name = scale.name
      let values = scale.values

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ]
        this.__degrees[ name ][ chord ] = { mode:'aeolian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'aeolian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'aeolian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'aeolian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'aeolian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ].toUpperCase()
        this.__degrees[ name ][ chord ] = { mode:'ionian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'ionian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'ionian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'ionian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'ionian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + '7'
        this.__degrees[ name ][ chord ] = { mode:'dorian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'dorian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'dorian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'dorian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'dorian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ].toUpperCase() + '7'
        this.__degrees[ name ][ chord ] = { mode:'mixolydian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'mixolydian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'mixolydian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'mixolydian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'mixolydian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + 'o'
        this.__degrees[ name ][ chord ] = { mode:'locrian', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'locrian', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'locrian', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'locrian', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'locrian', offset: values[i] + 24 }
      }

      for( let i = 0; i < base.length; i++ ) {
        const chord = base[ i ] + 'M7'
        this.__degrees[ name ][ chord ] = { mode:'melodicminor', offset: values[i] }
        this.__degrees[ name ][ '-'+chord ] = { mode:'melodicminor', offset: values[i] - 12 }
        this.__degrees[ name ][ '--'+chord ] = { mode:'melodicminor', offset: values[i] - 24 }
        this.__degrees[ name ][ '+'+chord ] = { mode:'melodicminor', offset: values[i] + 12 }
        this.__degrees[ name ][ '++'+chord ] = { mode:'melodicminor', offset: values[i] + 24 }
      }
    }
  },

  init:function( __Gibber ) {
    Gibber = __Gibber

    this.Tune = new this.__Tune()
    this.Tune.TuningList = this.__tunings

    if( Gibberish.mode === 'worklet' ) {
      this.id = Gibberish.utilities.getUID()

      // can't send prototype methods of Tune over processor
      // so they need to be explicitly assigned
      this.Tune.loadScale = this.Tune.__proto__.loadScale
      this.Tune.note = this.Tune.__proto__.note
      this.Tune.frequency = this.Tune.__proto__.frequency
      this.Tune.tonicize = this.Tune.__proto__.tonicize
      this.Tune.ratio = this.Tune.__proto__.ratio
      this.Tune.MIDI = this.Tune.__proto__.MIDI
      
      Gibberish.worklet.port.postMessage({
        address:'add',
        properties:serialize( Theory ),
        id:this.id,
        post:'store'
      })

      Gibber.subscribe( 'clear', () => this.reset() )
      this.initProperties()
    }

    this.__initDegrees()
  },

  reset:function() {
    Theory.root = 440
    Theory.mode = 'aeolian'
    Theory.tuning = 'et'
    Theory.degree = 'i'
    Theory.offset = 0
  },

  freeze:function() {
    if( Gibberish.mode === 'worklet' ) {
      Gibber.Theory.degree.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.offset.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.mode.sequencers.forEach( s => s.stop() )  
      Gibber.Theory.root.sequencers.forEach( s => s.stop() )  
    }
  },

  thaw:function() {
    if( Gibberish.mode === 'worklet' ) {
      this.degree.sequencers.forEach( s => s.start() )  
      this.offset.sequencers.forEach( s => s.start() )  
      this.mode.sequencers.forEach( s => s.start() )  
      this.root.sequencers.forEach( s => s.start() )  
    }
  },

  loadScale: function( name ) {
    if( Gibberish.mode === 'worklet' ) {
      // if the scale is already loaded...
      if( this.__tunings[ name ] !== undefined ) {
        this.__tuning.value = name
        this.Tune.loadScale( name )

        Gibberish.worklet.port.postMessage({
          address:'method',
          object:this.id,
          name:'loadScale',
          args:[name]
        })
        return
      }

      const path = this.__loadingPrefix + name + '.js' 
      fetch( path )
        .catch( console.err )
        .then( data => {
          if( data.ok ) {
            return data.json()
          }else{
            console.error( `The tuning ${name} wasn't found. Please visit http://abbernie.github.io/tune/scales.html to find the names of valid tunings.`) 
          } 
        })
        .then( json => {
          this.__tuning.value = name
          Gibberish.worklet.port.postMessage({
            address:'addToProperty',
            object:this.id,
            name:'__tunings',
            key:name,
            value:json
          })

          Gibberish.worklet.port.postMessage({
            address:'method',
            object:this.id,
            name:'loadScale',
            args:[name]
          })

          this.__tunings[ name ] = json
          this.Tune.loadScale( name )
        })
    }else{
      this.Tune.loadScale( name )
    }
  },

  // REMEMBER THAT THE .note METHOD IS ALSO MONKEY-PATCHED
  // IN ugen.js, THIS IS WHERE MOST OF THE AWPROCESSOR NOTE
  // METHOD IS IMPLEMENTED.
  note: function( __idx, octave=0, round=true ) {
    let finalIdx, mode = null, __float = __idx % 1, baseOctave, nextOctave

    let isInt = __float === 0
    if( !isInt && round===true ) {
      __idx = Math.round( __idx )
      isInt = true
    }
    
    let baseIndex = __idx < 0 ? Math.ceil( __idx ) : Math.floor( __idx ),
        nextIndex = __idx >= 0 ? baseIndex + 1 : baseIndex - 1

    baseIndex += Gibberish.Theory.__offset
    nextIndex += Gibberish.Theory.__offset

    if( Gibberish.Theory.mode !== 'chromatic' && Gibberish.Theory.mode !== null ) {
      mode = Gibberish.Theory.modes[ Gibberish.Theory.mode ]
      baseOctave = Math.floor( baseIndex / mode.length )
      nextOctave = Math.floor( nextIndex / mode.length )
      
      // XXX this looks crazy ugly but works with negative note numbers...
      baseIndex = baseIndex < 0 
        ? mode[ (mode.length - (Math.abs( baseIndex ) % mode.length)) % mode.length ] 
        : mode[ Math.abs( baseIndex ) % mode.length ]

      if( !isInt ) {
        nextIndex = nextIndex < 0 
          ? mode[ (mode.length - (Math.abs( nextIndex ) % mode.length)) % mode.length ] 
          : mode[ Math.abs( nextIndex ) % mode.length ]
      }
    }else{
      // null mode also means to use 'chromatic' mode
      mode = Gibberish.Theory.modes[ 'chromatic' ]
      const l = Gibberish.Theory.Tune.scale.length 
      baseOctave = Math.floor( baseIndex / l )
      nextOctave = Math.floor( baseIndex / l )

      baseIndex = baseIndex < 0 
        ? mode[ (l - (Math.abs( baseIndex ) % l)) % l ] 
        : mode[ Math.abs( baseIndex ) % l ]

      if( !isInt ) {
        nextIndex = nextIndex < 0 
          ? mode[ (l - (Math.abs( nextIndex ) % l)) % l ] 
          : mode[ Math.abs( nextIndex ) % l ]
      }
    }

    baseIndex += this.__degree.offset
    nextIndex += this.__degree.offset

    let outputFreq = 0
    if( !isInt ) {
      const freq0 = Gibberish.Theory.Tune.note( baseIndex, baseOctave )
      const freq1 = Gibberish.Theory.Tune.note( nextIndex, nextOctave )
      let   diff  = freq1 - freq0
      if( __idx < 0 ) diff *= -1
      outputFreq = freq0 + (diff*__float)
    }else{
      outputFreq = Gibberish.Theory.Tune.note( baseIndex, baseOctave )
    }

    return outputFreq 
  },
}

module.exports = Theory

},{"./external/tune-api-only.js":102,"gibberish-dsp":174,"serialize-javascript":231}],128:[function(require,module,exports){
const Presets = require( './presets.js' )
const Theory  = require( './theory.js' )
const Gibberish = require( 'gibberish-dsp' )

// Gibber ugens are essentially wrappers around underlying gibberish 
// ugens, providing convenience methods for rapidly sequencing
// and modulating them.

const poolSize = 12

// DRY method for removing a sequence and its associated annotations.
const removeSeq = function( obj, seq ) {
  const idx = obj.__sequencers.indexOf( seq )
  obj.__sequencers.splice( idx, 1 )
  seq.stop()
  seq.clear()
}

const createMapping = function( from, to, name, wrappedTo ) {
  if( from.__useMapping === false ) {
    wrappedTo[ name ] = from
  }else if( from.type === 'audio' ) {
    const f = to[ '__' + name ].follow = Follow({ input: from })

    let m = f.multiplier
    Object.defineProperty( to[ name ], 'multiplier', {
      get() { return m },
      set(v) { m = v; f.multiplier = m }
    })

    let o = f.offset
    Object.defineProperty( to[ name ], 'offset', {
      get() { return o },
      set(v) { o = v; f.offset = o }
    })

    wrappedTo[ name ] = f
  }else if( from.type === 'gen' ) {
    // gen objects can be referred to without the graphics/audio abstraction,
    // in which case they will have no .render() function, and don't need to be rendered
    const gen = from.render !== undefined ? from.render() : from

    wrappedTo[ name ] = gen
  }
}

const Ugen = function( gibberishConstructor, description, Audio, shouldUsePool = false, isBinop = false ) {

  let   poolCount = poolSize
  const pool = []

  const constructor = function( ...args ) {
    const properties = Presets.process( description, args, Audio ) 
    const timeProps = Audio.timeProps[ description.name ] === undefined ? [] : Audio.timeProps[ description.name ]

    if( timeProps.length > 0 ) {
      for( let key in properties ) {
        if( timeProps.indexOf( key ) > -1 ) {
          properties[ key ] = Audio.Clock.time( properties[ key ] )
        }
      }
    }

    // XXX if you want to use pooling you must also uncomment near the bottom of this file...
    // Pooling could work for reverbs IF:
    // 1. There would have to be separate mono and stereo pools.2
    // 2. Reverbs would need to run with 0 input for a while so that the functions are JIT'd

    //if( shouldUsePool && poolCount < pool.length ) {
    //  pool[ poolCount ].inUse = true
    //  const poolUgen = pool[ poolCount ].ugen
    //  poolCount++
    //  Object.assign( poolUgen, properties, args )
    //  console.log( 'pool ugen:', poolUgen )
    //  return poolUgen
    //}

    let __wrappedObject
    if( isBinop === true ) {
      __wrappedObject = gibberishConstructor( ...args ) 
    }else{
      __wrappedObject = gibberishConstructor( properties )
    }
    
    const obj = { 
      __wrapped__ :__wrappedObject,
      __sequencers : [], 
      __tidals: [],
      name:description.name,
      type:'audio',

      stop( time=null ) {
        if( time === null ) {
          for( let seq of this.__sequencers ) seq.stop()
          for( let seq of this.__tidals ) seq.stop()
        }else{
          time = Audio.Clock.time( time )
          for( let seq of this.__sequencers ) {
            future( seq => seq.stop(), time, { seq })
          }

          for( let seq of this.__tidals ) {
            future( seq => seq.stop(), time, { seq })
          }
        }
        return this
      },
      play( time=null ) {
        if( time === null ) {
          for( let seq of this.__sequencers ) seq.start()
          for( let seq of this.__tidals ) seq.start()
        }else{
          time = Audio.Clock.time( time )
          for( let seq of this.__sequencers ) {
            future( seq => seq.start(), time, { seq })
          }

          for( let seq of this.__tidals ) {
            future( seq => seq.start(), time, { seq })
          }
        }

        return this
      },
      clear() {
        for( let seq of this.__sequencers ) {
          seq.clear()
        }
        for( let seq of this.__tidals ) {
          seq.clear()
        }
        //console.log( Gibberish.mode, __wrappedObject.connected )
        if( __wrappedObject.connected !== undefined ) {
          for( let connection of __wrappedObject.connected ) {
            if( this.fx.indexOf( connection[ 0 ] ) === -1 ) {
              this.disconnect( connection[ 0 ] )
            }else{
              this.disconnect()
            }
          }
        }
        if( this.__onclear !== undefined ) {
          this.__onclear()
        }
      }
    }

    // add poly methods
    if( description.name.indexOf('Poly') > -1 || description.name.indexOf('Multi') > -1 || description.name.indexOf('Soundfont') > -1 ) {
      let useProp = description.name.indexOf('Poly') > -1
      obj.spread = function( amt=1 ) {
        if( amt === 0 ) {
          children.forEach( (c,i) => { 
            if( useProp ) 
              c.pan = .5 
            else 
              if( obj.maxVoices.value > 1 ) obj.setpan(i,.5) 
          })
          return obj
        }
        const children = this.__wrapped__.voices
        const incr = 1/(children.length-1) * amt
        children.forEach( (c,i) => {
          if( useProp ) 
            c.pan = (.5 - amt/2) + i * incr
          else
            if( obj.maxVoices.value > 1 ) obj.setpan( i, (.5-amt/2) + i * incr )
        })

        return obj
      }
      obj.voices = obj.__wrapped__.voices
      obj.inspect = function() {
        console.group( 'Inspecting ' + description.name )
        console.table( Object.assign({}, obj.voices[0].__wrapped__.__properties__, obj.__wrapped__.__properties__ ) )
        console.groupEnd()
      }
      for( let i = 0; i < 20; i++ ) {
        Object.defineProperty( obj, i, { get() { return obj.voices[i] } })
      }
    }
//btos: function( beats ) {
//    const samplesPerBeat = Gibberish.ctx.sampleRate / (this.bpm / 60 )
//    return samplesPerBeat * beats 
//  }
    // transform beat values to samples
    // in the case of a gen graph convert to a new gen object
    const timetransform = function( v ) {
      const out = typeof v === 'number' 
        ? Audio.Clock.time( v ) 
        : v.type === 'gen' 
          ? Gen.make( 
              genish.mul( 
                genish.div( 44100, genish.div( Clock.bpm, 60 ) ),
                v.graph
              ) 
            )
          : v

      return out
    }

    // wrap properties and add sequencing to them
    for( let propertyName in description.properties ) {
      if( __wrappedObject.__requiredRecompilation && __wrappedObject.__requiresRecompilation.indexOf( propertyName ) > -1 ) continue
      // XXX we have to pass id in the values dictionary under 
      // certain conditions involoving gen ugens, but we don't 
      // want .id to be sequencable!
      if( propertyName !== 'id' && propertyName !== 'type' ){
        const transform = timeProps.indexOf( propertyName ) > -1 
          ? timetransform
          : null 

        const value = __wrappedObject[ propertyName ] === undefined 
          ? __wrappedObject.__properties__[ propertyName ]
          : __wrappedObject[ propertyName ]

        Audio.createProperty( obj, propertyName, value, null, 0, transform )

        // create per-voice version of property... what properties should be excluded?
        if( description.name.indexOf('Poly') > -1 || description.name.indexOf('Multi') > -1 || description.name.indexOf('Soundfont') > -1 ) {
          Audio.createProperty( obj, propertyName+'V', value, null, 0, transform, true )//, timeProps, Audio, true )

          //createProperty( obj, propertyName, __wrappedObject, timeProps, Audio, true )
          // we don't have a way to add properties to objects in the processor thread
          // so we'll just add a method... sequencing will still work the same.
          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:propertyName+'V',
            function:`function( v ) {this.voices[ this.voiceCount % this.voices.length ][ '${propertyName}' ] = v }`
          })
        }
      }
    }

    if( description.methods !== null && description.methods.indexOf( 'note' ) > -1 ) { 
      description.methods.push( 'notef' )
      description.methods.push( 'notec' )
    }

    // wrap methods and add sequencing to them
    if( description.methods !== null ) {
      for( let methodName of description.methods ) {
        if( methodName !== 'note' || description.name.indexOf('Sampler') > -1 || description.name.indexOf('Multisampler') > -1 ) { //|| description.name.indexOf('Soundfont') > -1 ) {
          //obj[ methodName ] = __wrappedObject[ methodName ].bind( __wrappedObject )
          obj[ methodName ] = function( ...args ) {
            if( args.length === 0 ) {
              __wrappedObject[ methodName ]()
            }else{ //if( args.length === 1 ) {
              //if( Array.isArray( args[0] ) ) {
              //  obj[ methodName ].seq( args[0], 1/args[0].length )
              //}else if( typeof args[0] === 'string' ) {
              //  obj[ methodName ].tidal( args[0] )
              //}else{
                __wrappedObject[ methodName ]( ...args )
              //}
            }/*else{
              // could be a .tidal or a seq 
              if( typeof args[0] === 'string' ) { // must be tidal with tidal id #
                obj[ methodName ].tidal( ...args )
              }else{
                obj[ methodName ].seq( ...args )  // must be sequence
              }
            }*/
            return obj
          }
        }else{
          // in this block we are monkey patching the note method of Gibberish synths so that
          // they use Gibber's harmonic system inside the AudioWorkletProcessor.

          obj[ methodName ] = function( ...args ) {
            let shouldSendNoteNow = false
            if( args.length === 0 ) {
               shouldSendNoteNow = true
            }else if( args.length === 1 ) {
              if( Array.isArray( args[0] ) ) {
                obj[ methodName ].seq( args[0], 1/args[0].length )
              }else if( typeof args[0] === 'string' ) {
                obj[ methodName ].tidal( args[0] )
              }else{
                shouldSendNoteNow = true
              }
            }else{
              /*
              // could be a .tidal or a seq 
              if( typeof args[0] === 'string' ) { // must be tidal with tidal id #
                obj[ methodName ].tidal( ...args )
              }else{
                obj[ methodName ].seq( ...args )  // must be sequence
              }
              */
            }

            // this should only be for direct calls from the IDE
            if( shouldSendNoteNow && Gibberish.mode === 'worklet' ) {
              Gibberish.worklet.port.postMessage({
                address:'method',
                object:__wrappedObject.id,
                name:methodName,
                args
              })
            }

            return obj
          }

          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:'notef',
            function:`function( note, __loudness=null ){
              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.___note( note, loudness ) 
            }`
          })
          Gibberish.worklet.port.postMessage({
            address:'addMethod',
            id:__wrappedObject.id,
            key:'notec',
            function:`function( note, __loudness=null ){
              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.note( note, loudness, false ) 
            }`
          })
          // when a message is received at the address 'monkeyPatch',
          // Gibberish will create a copy of the method identified by
          // the 'key' field, and then assign it back to the object prefaced
          // with double underscores (e.g. __note). The function that is being
          // patched in can then call the original function using the prefaced 
          // name, as is done in the last line of the argument function below.
          Gibberish.worklet.port.postMessage({
            address:'monkeyPatch',
            id:__wrappedObject.id,
            key:'note',
            function:`function( note, __loudness, round=true ){ 
              const octave = this.octave || 0
              let notesInOctave = 7
              const mode = Gibberish.Theory.mode

              if( mode !== null ) {
                notesInOctave = mode !== 'chromatic' ? Gibberish.Theory.modes[ mode ].length : Gibberish.Theory.Tune.scale.length
              }else{
                notesInOctave = Gibberish.Theory.Tune.scale.length
              }

              const offset = octave * notesInOctave
              let __note = Gibberish.Theory.note( note + offset, 0, round )

              const loudness = __loudness = null ? this.__triggerLoudness : __loudness
              this.___note( __note, loudness ) 
            }`
          })
          
        }

        if( methodName === 'notef' ) {
          obj.notef = function( ...args ) {
            __wrappedObject.frequency = args[0]
            __wrappedObject.trigger( __wrappedObject.__triggerLoudness )

            return obj
          }
        }

        if( methodName === 'notec' ) {
          obj.notec = function( ...args ) {
            //__wrappedObject.frequency = args[0]
            //__wrappedObject.trigger( __wrappedObject.__triggerLoudness )
            Gibberish.worklet.port.postMessage({
              address:'method',
              object:__wrappedObject.id,
              name:'notec',
              args
            })
            return obj
          }
        }
        obj[ methodName ].sequencers = []
        obj[ methodName ].tidals = []

        obj[ methodName ].seq = function( values, timings, number=0, delay=0, priority=10000 ) {
          console.log( 'method seq:', methodName, number )
          let prevSeq = obj[ methodName ].sequencers[ number ] 
          if( prevSeq !== undefined ) { 
            const idx = obj.__sequencers.indexOf( prevSeq )
            obj.__sequencers.splice( idx, 1 )
            //prevSeq.stop()
            prevSeq.clear()
            // removeSeq( obj, prevSeq )
          }

          let s = Audio.Core.Seq({ values, timings, target:obj/*__wrappedObject*/, key:methodName, priority })
          
          if( typeof delay !== 'function' ) {
            s.start( Audio.Clock.time( delay ) )
          }else{
            delay.seqs.push( s )
          }
          obj[ methodName ].sequencers[ number ] = obj[ methodName ][ number ] = s 
          obj.__sequencers.push( s )

          // return object for method chaining
          return obj
        }
        obj[ methodName ].tidal= function( pattern, number=0, delay=0 ) {
          let prevSeq = obj[ methodName ].tidals[ number ] 
          let s = Audio.Core.Tidal({ pattern, target:__wrappedObject, key:methodName })
          if( s !== null ) {
            if( prevSeq !== undefined ) { 
              const idx = obj.__tidals.indexOf( prevSeq )
              obj.__tidals.splice( idx, 1 )
              prevSeq.stop()
              prevSeq.clear()
              // removeSeq( obj, prevSeq )
            }

            s.start( Audio.Clock.time( delay ) )
            obj[ methodName ].tidals[ number ] = obj[ methodName ][ number ] = s 
            obj.__tidals.push( s )

            // XXX need to clean this up! this is solely here for annotations, and to 
            // match what I did for ensembles... 
            obj[ methodName ].__tidal = s
          }

          // return object for method chaining
          return obj
        }

        
      }
    }


    let id = __wrappedObject.id
    Object.defineProperty( __wrappedObject, 'id', {
      configurable:false,
      get() { return id },
      set(v) {
        //console.log( 'tried to change id:', obj )
        //debugger
      }
    })
    obj.id = __wrappedObject.id

    obj.__follow = null

    const followcheck = ()=> {

    }

    Object.defineProperty( obj, '__out', {
      configurable:false,
      get() {
        if( obj.__follow === null ) {
          obj.__follow = Audio.analysis.Follow({ input:obj }) 
        }

        const output = obj.__follow.output
         
        // will take a few buffers to initialize...
        if( output === undefined ) return 0

        return output[1] === undefined ? output[0] : output[0] + output[1] 
      },
      set(v) {}
    })

    obj.inspect = ()=> {
      console.group( 'Inspecting ' + description.name )
      const keys = Object.keys( obj.__wrapped__.__properties__ )
      const props = {}
      keys.forEach( key => {
        if( key[0] !== '_' ) {
          if( obj[ key ] !== null && obj[ key ] !== undefined ) {
            props[ key ] = obj[ key ].value
          }
        }
      })
      console.table( props ) 
      //console.table( obj.__wrapped__.__properties__ )
      console.groupEnd()
    }

    obj.out = function( scale=1, offset=0, bufferSize=null ) {
      // if the buffer size changes...
      if( bufferSize !== null ) {
        if( obj.__follow !== null ) {
          if( bufferSize !== obj.__follow.__wrapped__.bufferSize ) {
            //console.log( 'prev follow', bufferSize, obj.__follow.__wrapped__.bufferSize, obj.__follow )
            
            const tmp = obj.__follow
            // XXX need to remove the previous follow from the graph...
            obj.__follow = Audio.analysis.Follow({ input:Audio.Gibberish.worklet.ugens.get( obj.__follow.__wrapped__.input.id ), bufferSize })

            Audio.Gibberish.worklet.port.postMessage({
              address:'eval',
              code:`const idx = Gibberish.analyzers.findIndex( ugen => ugen.id === ${tmp.id} )
                    if( idx > -1 ) {
                      Gibberish.analyzers.splice(idx,1)
                      Gibberish.dirty( Gibberish.analyzers )
                    }`
            })
          }
        }
      }

      if( Ugen.OUTPUT === Ugen.OUTPUT_FUNCTION )
        return ()=> obj.__out * scale + offset
      else
        return Math.abs( obj.__out * scale ) + offset 
    }

    // XXX where does shouldAddToUgen come from? Not from presets.js...
    if( properties !== undefined && properties.shouldAddToUgen ) Object.assign( obj, properties )

    // create fx chaining api. e.g. synth.fx.add( Chorus(), Freeverb() )
    // we use the 'add' method to enable method chaining alongside instrument calls to
    // .connect() and .seq()

    const __fx = []
    __fx.__push = __fx.push.bind( __fx )
    __fx.add = function( ...args ) {
      args.forEach( fx => obj.__fx.push( fx ) )
      console.log( `added ${args.length} effect(s) to ${obj.name}` )
      return obj
    }
    __fx.inspect = function() {
      if( __fx.length > 0 )
        console.table( __fx.map( fx=>fx.name ) )
      else
        console.log( `there are no effects on ${obj.name} to inspect.` )
    }
    __fx.remove = function( effect=null ) {
      if( effect === null ) {
        obj.__fx.length = 0
        console.log( `all effects from ${obj.name} were removed.` )
      }else if( typeof effect === 'number' ) {
        // XXX broken for indices that !== 0
        const del = obj.__fx.splice( effect, 1 )
        console.log( `${del[0].name} at fx slot ${effect} was removed from ${obj.name}.` ) 
      }else if( typeof effect === 'string' ) {
        const indexesToErase = []
        __fx.forEach( (__effect,i) => { if( effect === __effect.name ) indexesToErase.push( i ) })
        console.log( `${indexesToErase.length} effect(s) were removed from ${obj.name}.` ) 
        for( let i = __fx.length - 1; i >= 0; i-- ) {
          if( indexesToErase.includes( i ) ) __fx.splice( i, 1 )
        }   
      } else if( typeof effect === 'object' ) {
        const idx = __fx.indexOf( effect )
        __fx.splice( idx, 1 )
        console.log( `effect ${effect.name} was removed from ${obj.name}.` ) 
      }
    }
    obj.__fx = new Proxy( __fx, {
      set( target, property, value, receiver ) {

        const lengthCheck = target.length
        const old = target.slice(0)
        target[ property ] = value
        
        if( property === 'length' ) { 
          if( target.length > 1 ) {
            // XXX need to store and reassign to end connection
            target[ target.length - 2 ].disconnect()
            target[ target.length - 2 ].connect( target[ target.length - 1 ] )
            target[ target.length - 1 ].connect()
          }else if( target.length === 1 ) {
            const connected = __wrappedObject.connected !== undefined ?__wrappedObject.connected.slice(0) : null
            __wrappedObject.disconnect()
            __wrappedObject.connect( target[ 0 ] )

            if( connected !== null ) {
              for( let connection of connected ) {
                // 0 is bus, 1 is ugen adding the fx, 2 is send amount
                target[0].connect( connection[0], connection[2] )
              }
            }else{
              target[0].connect( Audio.Master )
            }
          }else if( value === 0 && lengthCheck !== 0 ) {
            // ugh...
            if( __wrappedObject.connected !== undefined ) {
              if( __wrappedObject.connected[0] !== undefined ) {
                __wrappedObject.connect( 
                  __wrappedObject.connected[ 0 ][ 0 ].__wrapped__.connected[ 0 ][ 0 ], 
                  __wrappedObject.connected[ 0 ][ 0 ].__wrapped__.connected[ 0 ][ 2 ] 
                )

                __wrappedObject.connected[ 0 ][ 0 ].disconnect()
              }
            }
          }

        }

        return true
      }
    })

    Object.defineProperty( obj, 'fx', {
      get() { return obj.__fx },
      set(v) {
        const tmpLength = obj.__fx.length
        obj.__fx.length = 0
        if( Array.isArray( v ) ) {
          v.forEach( effect => obj.__fx.push( effect ) ) 
        }else{
          obj.__fx.push( v ) 
        }

        if( tmpLength > 0 ) {

            console.log( `${tmpLength} effect(s) were replaced with ${obj.__fx.length} effect(s) on ${obj.name}` )
        }else{

          if( Array.isArray( v ) ) {
            console.log( `${v.length} effect(s) were added to the fx chain of ${obj.name}` )
          }else{
            console.log( `a ${v.name} was added to the fx chain  of ${obj.name}` )
          }
        }
      }
    })

    obj.connect = (dest,level=1) => {
      if( typeof dest !== 'number' ) {
        if( dest !== undefined && dest.isProperty === true ) {
          // if first modulation for property, store it's initial
          // value before modulating it.
          if( dest.preModValue === undefined ) { 
            dest.preModValue = dest.value
          }

          dest.mods.push( obj )

          const sum = dest.mods.concat( dest.preModValue )
          const add = Audio.binops.Add( ...sum ) 
          // below works for oscillators, above works for instruments...
          //const add = Gibber.Gibberish.binops.Add( ...sum ) 
          add.__useMapping = false
          dest.__owner[ dest.name ] = add

          obj.__wrapped__.connected.push( [ dest.__owner[ dest.name ], obj ] )
        }else{
          // if no fx chain, connect directly to output
          if( obj.fx.length === 0 ) {
            __wrappedObject.connect( dest, level )
          }else{
            // otherwise, connect last effect in chain to output
            obj.fx[ obj.fx.length - 1 ].__wrapped__.connect( dest, level )
          }
        }
      }else{
        console.log( '%cYou cannot connect to a number; perhaps you meant this to be the level for your connection?', 'color:white;background:#900' )
      }

      return obj 
    } 

    obj.disconnect = dest => { 
      // if there's an effect chain, we disconnect that in addition
      // to disconnecting the ugen itself.
      if( dest === undefined && obj.fx.length > 0 ) {
        obj.fx[ obj.fx.length - 1 ].disconnect()
      }

      __wrappedObject.disconnect(); 
      
      return obj 
    } 

    Object.defineProperty( obj, '_', { get() { obj.disconnect(); return obj } })

    // presetInit is a function in presets that triggers actions after the ugen
    // has been instantiated... it is primarily used to add effects and modulations
    // to a preset.
    if( properties !== undefined && properties.__presetInit__ !== undefined ) {
      properties.__presetInit__.call( obj, Audio, args[1] )
    }

    // only connect if shouldNotConneect does not equal true (for LFOs and other modulation sources)
    if( obj.__wrapped__.type === 'instrument' || obj.__wrapped__.type === 'oscillator' || description.name.indexOf('Poly') > -1 ) {
      if( typeof properties !== 'object' || properties.shouldNotConnect !== true ) {
        
        if( Audio.autoConnect === true ) {
          // ensure that the ugen hasn't already been connected through the fx chain,
          // possibly through initialization of a preset
          if( obj.fx.length === 0 ) obj.connect( Audio.Master )
        }
      }

    }else if( obj.__wrapped__.type === 'effect' ) {
      obj.bus = function() {
        const b = Audio.busses.Bus2()
        b.fx.add( obj )

        const p = new Proxy( b, {
          set( target, property, value, receiver ) {
            // console.log( 'set:', target, property, value, receiver )
            if( b[ property ] === undefined && property !== 'input' ) {
              obj[ property ] = value
            }else{
              b[ property ] = value
            }
          },
          get( target, property, value, receiver ) {
            if( b[ property ] === undefined && property !== 'input' ) {
              return obj[ property ]
            }else{
              return b[ property ]
            }
          }
        })

        p.inspect = function() {
          console.group( 'Inspecting ' + description.name + ' ' + 'Bus' )

          const objKeys = Object.keys( obj.__wrapped__.__properties__ )
          const __obj = {}
          objKeys.forEach( key => {
            //console.log( 'key:', key, obj.__wrapped__ )
            if( key[0] !== '_' && key !== 'bypass' && obj[key] !== undefined ) {
              __obj[ key ] = obj[ key ].value !== undefined
                ? obj[ key ].value
                : obj.__wrapped__.__properties__[ key ].value
            }
          })
          console.group( description.name.toLowerCase() )
          console.table( __obj )
          console.groupEnd()

          console.group('bus')
          console.table( b.__wrapped__.__properties__ )
          console.groupEnd()

          console.groupEnd()
        }

        return p
      }
    }
    //console.log( `%c${description.name} created.`, 'color:white;background:#009' )
    Audio.publish( 'new ugen', description.name + ' created'  )

    return obj
  }

  //if( shouldUsePool ) {
  //  for( let i=0; i < poolSize; i++ ) {
  //    pool[ i ] = {
  //      inUse:false,
  //      ugen: constructor()
  //    }
  //  } 

  //  poolCount = 0
  //}
  
  //Ugen.createProperty = createProperty

  return constructor
}

Ugen.OUTPUT_FUNCTION = 0
Ugen.OUTPUT_SCALAR = 1
Ugen.OUTPUT = 1


module.exports = Ugen

},{"./presets.js":109,"./theory.js":127,"gibberish-dsp":174}],129:[function(require,module,exports){
const Utility = {
  rndf( min=0, max=1, number, canRepeat=true ) {
    let out = 0
  	if( number === undefined ) {
  		let diff = max - min,
  		    r = Math.random(),
  		    rr = diff * r

  		out =  min + rr;
  	}else{
      let output = [],
  		    tmp = []

  		for( let i = 0; i < number; i++ ) {
  			let num
        if( canRepeat ) {
          num = Utility.rndf(min, max)
        }else{
          num = Utility.rndf( min, max )
          while( tmp.indexOf( num ) > -1) {
            num = Utility.rndf( min, max )
          }
          tmp.push( num )
        }
  			output.push( num )
  		}

  		out = output
  	}

    return out
  },

  Rndf( _min = 0, _max = 1, quantity, canRepeat=true ) {
    // have to code gen function to hard code min / max values inside, as closures
    // or bound values won't be passed through the worklet port.XXX perhaps there should
    // be a way to transfer a function and its upvalues through the worklet? OTOH,
    // codegen works fine.

    const fncString = `const min = ${_min}
    const max = ${_max} 
    const range = max - min
    const canRepeat = ${quantity} > range ? true : ${ canRepeat }

    let out

    if( ${quantity} > 1 ) { 
      out = []
      for( let i = 0; i < ${quantity}; i++ ) {
        let num = min + Math.random() * range

        if( canRepeat === false ) {
          while( out.indexOf( num ) > -1 ) {
            num = min + Math.random() * range
          }
        }
        out[ i ] = num
      }
    }else{
      out = min + Math.random() * range 
    }

    return out;`
    
    return new Function( fncString )
  },

  rndi( min = 0, max = 1, number, canRepeat = true ) {
    let range = max - min,
        out
    
    if( range < number ) canRepeat = true

    if( typeof number === 'undefined' ) {
      range = max - min
      out = Math.round( min + Math.random() * range )
    }else{
  		let output = [],
  		    tmp = []

  		for( let i = 0; i < number; i++ ) {
  			let num
  			if( canRepeat ) {
  				num = Utility.rndi( min, max )
  			}else{
  				num = Utility.rndi( min, max )
  				while( tmp.indexOf( num ) > -1 ) {
  					num = Utility.rndi( min, max )
  				}
  				tmp.push( num )
  			}
  			output.push( num )
  		}
  		out = output
    }
    return out
  },

  Rndi( _min = 0, _max = 1, quantity=1, canRepeat = false ) {
    // have to code gen function to hard code min / max values inside, as closures
    // or bound values won't be passed through the worklet port.XXX perhaps there should
    // be a way to transfer a function and its upvalues through the worklet? OTOH,
    // codegen works fine.

    const fncString = `const min = ${_min}
    const max = ${_max} 
    const range = max - min
    const canRepeat = ${quantity} > range ? true : ${ canRepeat }

    let out

    if( ${quantity} > 1 ) { 
      out = []
      for( let i = 0; i < ${quantity}; i++ ) {
        let num = min + Math.round( Math.random() * range );

        if( canRepeat === false ) {
          while( out.indexOf( num ) > -1 ) {
            num = min + Math.round( Math.random() * range );
          }
        }
        out[ i ] = num
      }
    }else{
      out = min + Math.round( Math.random() * range ); 
    }

    return out;`
    
    return new Function( fncString )
  },

  time( v ) { return Gibber.Audio.Clock.time( v ) },
  btof( beats ) { return 1 / (beats * ( 60 / Gibber.Audio.Clock.bpm )) },

  random() {
    this.randomFlag = true
    this.randomArgs = Array.prototype.slice.call( arguments, 0 )

    return this
  },

  elementArray: function( list ) {
    let out = []

    for( var i = 0; i < list.length; i++ ) {
      out.push( list.item( i ) )
    }

    return out
  },
  
  __classListMethods: [ 'toggle', 'add', 'remove' ],

  create( query ) {
    let elementList = document.querySelectorAll( query ),
        arr = Utility.elementArray( elementList )
    
    for( let method of Utility.__classListMethods ) { 
      arr[ method ] = style => {
        for( let element of arr ) { 
          element.classList[ method ]( style )
        }
      } 
    }

    return arr
  },

  chord( ptrn, offsets ) {
    // gotta codegen function for worklet processor... similar to Rndi etc.
    let fncstr = `args.override = args[0]
    const values = []\n`

    for( let i = 0; i < offsets.length; i++ ) {
      fncstr += `values[${i}] = args[0] + ${offsets[i]}\n`
    }

    fncstr += `args[0] = values\n  return args`

    const fnc = new Function( 'args', fncstr )

    ptrn.addFilter( fnc )

    return ptrn
  },

  export( obj ) {
    obj.rndi = this.rndi
    obj.rndf = this.rndf
    obj.Rndi = this.Rndi
    obj.Rndf = this.Rndf
    obj.btof = this.btof
    obj.chord = this.chord
    obj.time = this.time

    Array.prototype.rnd = this.random
  }
}

module.exports = Utility

},{}],130:[function(require,module,exports){
module.exports = function( Gibber ) {
   const gen = Gibber.Gen.make  

   // will use this in a few places...
   const beats = b => {
     return phasor( Gibber.Utilities.btof( b ), 0, { min:0 } )
   }

   // needs to support changing values in more than one place
   // in the graph, hence the array of __params.
   const addProp = ( obj, prop, __params, __value ) => {
     let value = __value
     Object.defineProperty( obj, prop, {
       configurable:true,
       get() { return value },
       set(v) {
         value = v
         for( let __param of __params ) {
           __param.value = value
         }
       }
     })
   }

   const WavePatterns = {
     Beats( numBeats ) {
       const ugen = gen( beats( numBeats ) )
       ugen.isGen = ugen.__wrapped__.isGen = true
       
       return ugen 
     },

     SineR( period, gain, bias=0 ) {
       const ugen =  gen( floor( add( bias, mul( cycle( Gibber.Utilities.btof( period ) ), gain ) ) ), ['bias', 'period', 'gain'] )
       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     },

     LineR( period, from=0, to=1 ) {
       const b = beats( period )

       const diff = sub( to, from )
       const mult = mul( b, diff )
       const adder = add( from, mult )
       const ugen = gen( round( adder ) )
       
       addProp( ugen, 'from', [ ugen.p0, ugen.p4 ], from )
       addProp( ugen, 'to', [ ugen.p3 ], to )
       addProp( ugen, 'period', [ ugen.p1 ], period )

       const oldSetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).set
       const oldGetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).get

       Object.defineProperty( ugen, 'period', {
         get() { return oldGetter() },
         set(v) {
           oldSetter( btof(v) )
         }

       })
       
       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     },

     Line( period, from=0, to=1 ) {
       const b = beats( period )

       const diff = sub( to, from )
       const mult = mul( b, diff )
       const adder = add( from, mult )
       const ugen = gen( adder )
       
       addProp( ugen, 'from', [ ugen.p0, ugen.p4 ], from )
       addProp( ugen, 'to', [ ugen.p3 ], to )
       addProp( ugen, 'period', [ ugen.p1 ], period )

       const oldSetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).set
       const oldGetter = Object.getOwnPropertyDescriptor( ugen, 'period' ).get

       Object.defineProperty( ugen, 'period', {
         get() { return oldGetter() },
         set(v) {
            oldSetter( btof(v) )
         }

       })

       ugen.isGen = ugen.__wrapped__.isGen = true

       return ugen
     }
   }

   // stores names so that annotations will correctly interpret this as a gen object
   for( let key in WavePatterns ) {
     Gibber.Gen.names.push( key )
   }

  return WavePatterns
}

},{}],131:[function(require,module,exports){
module.exports = function( Gibber ) {

  const WavePattern = function( ugen ) {
    
    const fnc = function() {
      return fnc.ugen.__wrapped__.callback.out[0] 
    }

    fnc.ugen = ugen

    return Gibber.Pattern( fnc )
  }

  return WavePattern
}

},{}],132:[function(require,module,exports){
module.exports = function( Gibber ) {

let Pattern = Gibber.Pattern

let flatten = function(){
   let flat = []
   for ( let i = 0, l = this.length; i < l; i++ ){
     let type = Object.prototype.toString.call( this[ i ]).split(' ').pop().split( ']' ).shift().toLowerCase()

     if (type) { 
       flat = flat.concat( /^(array|collection|arguments|object)$/.test( type ) ? flatten.call( this[i] ) : this[i]) 
     }
   }
   return flat
}

let createStartingArray = function( length, ones ) {
  let out = []
  for( let i = 0; i < ones; i++ ) {
    out.push( [1] )
  }
  for( let j = ones; j < length; j++ ) {
    out.push( 0 )
  }
  return out
}

let printArray = function( array ) {
  let str = ''
  for( let i = 0; i < array.length; i++ ) {
    let outerElement = array[ i ]
    if( Array.isArray( outerElement ) ) {
      str += '['
      for( let j = 0; j < outerElement.length; j++ ) {
        str += outerElement[ j ]
      }
      str += '] '
    }else{
      str += outerElement + ''
    }
  }

  return str
}

let arraysEqual = function( a, b ) {
  if ( a === b ) return true
  if ( a == null || b == null ) return false
  if ( a.length != b.length ) return false

  for ( let i = 0; i < a.length; ++i ) {
    if ( a[ i ] !== b[ i ] ) return false
  }

  return true
}

let getLargestArrayCount = function( input ) {
  let length = 0, count = 0

  for( let i = 0; i < input.length; i++ ) {
    if( Array.isArray( input[ i ] ) ) { 
      if( input[ i ].length > length ) {
        length = input[ i ].length
        count = 1
      }else if( input[ i ].length === length ) {
        count++
      }
    }
  }

  return count
}

let Euclid = function( ones, length, time, rotation ) {
  let count = 0,
      out = createStartingArray( length, ones ),
      onesAndZeros

 	function Inner( n,k ) {
    let operationCount = count++ === 0 ? k : getLargestArrayCount( out ),
        moveCandidateCount = out.length - operationCount,
        numberOfMoves = operationCount >= moveCandidateCount ? moveCandidateCount : operationCount

    if( numberOfMoves > 1 || count === 1 ) {
      for( let i = 0; i < numberOfMoves; i++ ) {
        let willBeMoved = out.pop(), isArray = Array.isArray( willBeMoved )
        out[ i ].push( willBeMoved )
        if( isArray ) { 
          flatten.call( out[ i ] )
        }
      }
    }

    if( n % k !== 0 ) {
      return Inner( k, n % k )
    }else {
      return flatten.call( out )
    }
  }
  
  onesAndZeros = Inner( length, ones )

  let pattern = Gibber.Pattern( ...onesAndZeros )

  if( isNaN( time ) || time === null ) time = 1 / onesAndZeros.length

  pattern.onrender = function( rendered ) {
    rendered.type = 'Euclid'

    rendered.time = time

    rendered.output = { time, shouldExecute: 0 }

    rendered.addFilter( ( args, ptrn ) => {
      let val = args[ 0 ]

      ptrn.output.time = Gibberish.Clock.time( ptrn.time )
      ptrn.output.shouldExecute = val 

      args[ 0 ] = ptrn.output 

      return args
    })
  }

  pattern.reseed = ( ...args )=> {
    let n, k
    
    if( Array.isArray( args[0] ) ) {
      k = args[0][0]
      n = args[0][1]
    }else{
      k = args[0]
      n = args[1]
    }

    if( n === undefined ) n = 16
    
    out = createStartingArray( n,k )
    let _onesAndZeros = Inner( n,k )
    
    pattern.set( _onesAndZeros )
    pattern.time = 1 / n

    // this.checkForUpdateFunction( 'reseed', pattern )

    return pattern
  }

  //Gibber.addSequencingToMethod( pattern, 'reseed' )

  // out = calculateRhythms( onesAndZeros, dur )
  // out.initial = onesAndZeros
  if( typeof rotation === 'number' ) pattern.rotate( rotation )
  return pattern //out
}
// E(5,8) = [ .25, .125, .25, .125, .25 ]
let calculateRhythms = function( values, dur ) {
  let out = []
  
  if( typeof dur === 'undefined' ) dur = 1 / values.length

  let idx = 0,
      currentDur = 0
  
  while( idx < values.length ) {
    idx++
    currentDur += dur
    
    if( values[ idx ] == 1 || idx === values.length ) {
      out.push( currentDur )
      currentDur = 0
    } 
  }
  
  return out
}

let answers = {
  '1,4' : '1000',
  '2,3' : '101',
  '2,5' : '10100',
  '3,4' : '1011',
  '3,5' : '10101',
  '3,7' : '1010100',
  '3,8' : '10010010',
  '4,7' : '1010101',
  '4,9' : '101010100',
  '4,11': '10010010010',
  '5,6' : '101111',
  '5,7' : '1011011',
  '5,8' : '10110110',
  '5,9' : '101010101',
  '5,11': '10101010100',
  '5,12': '100101001010',
  '5,16': '1001001001001000',
  '7,8' : '10111111',
  '11,24': '100101010101001010101010'
}

Euclid.test = function( testKey ) {
  let failed = 0, passed = 0

  if( typeof testKey !== 'string' ) {
    for( let key in answers ) {
      let expectedResult = answers[ key ],
          result = flatten.call( Euclid.apply( null, key.split(',') ) ).join('')

      console.log( result, expectedResult )

      if( result === expectedResult ) {
        console.log("TEST PASSED", key )
        passed++
      }else{
        console.log("TEST FAILED", key )
        failed++
      }
    }
    console.log("*****************************TEST RESULTS - Passed: " + passed + ", Failed: " + failed )
  }else{
    let expectedResult = answers[testKey],
				result = flatten.call( Euclid.apply( null, testKey.split(',') ) ).join('')

    console.log( result, expectedResult )

    if( result == expectedResult ) {
      console.log("TEST PASSED FOR", testKey)
    }else{
      console.log("TEST FAILED FOR", testKey)
    }
  }
}

return Euclid
}

},{}],133:[function(require,module,exports){
module.exports = function( Gibber ) {

const Pattern = Gibber.Pattern

const Hex = function( hexString, time = 1/16, rotation ) {
  let count = 0,
      onesAndZeros = ''

  if( typeof hexString === 'string' ) {
    for( let chr of hexString ) {
      let num = Number( '0x'+chr )

      onesAndZeros += (num & 8) > 0 ? 1 : 0
      onesAndZeros += (num & 4) > 0 ? 1 : 0
      onesAndZeros += (num & 2) > 0 ? 1 : 0
      onesAndZeros += (num & 1) > 0 ? 1 : 0
    }
  }else{
    onesAndZeros = hexString.toString(2)
    while( onesAndZeros.length < 16 ) {
      onesAndZeros = '0'+onesAndZeros
    }
  }

  let __onesAndZeros = onesAndZeros.split('') 

  const pattern = Gibber.Pattern( ...__onesAndZeros ) 
  
  pattern.onrender = function( rendered ) {
    rendered.type = 'Hex'

    rendered.time = time

    rendered.output = { time, shouldExecute: 0 }

    rendered.addFilter( ( args, ptrn ) => {
      let val = args[ 0 ]

      ptrn.output.time = Gibberish.Clock.time( ptrn.time )
      ptrn.output.shouldExecute = parseInt(val) 

      args[ 0 ] = ptrn.output 

      return args
    })
  }

  pattern.reseed = ( ...args )=> {
    let n, k
    
    if( Array.isArray( args[0] ) ) {
      k = args[0][0]
      n = args[0][1]
    }else{
      k = args[0]
      n = args[1]
    }

    if( n === undefined ) n = 16
    
    out = createStartingArray( n,k )
    let _onesAndZeros = Inner( n,k )
    
    pattern.set( _onesAndZeros )
    pattern.time = 1 / n

    // this.checkForUpdateFunction( 'reseed', pattern )

    return pattern
  }

  //Gibber.addSequencingToMethod( pattern, 'reseed' )

  if( typeof rotation === 'number' ) pattern.rotate( rotation )

  return pattern
}

return Hex

}

},{}],134:[function(require,module,exports){
const Gibber = {
  initialized: false,
  exportTarget: null,
  plugins: [],
  // needed so audio plugin can transfer pattern function string to worklet
  __Pattern: require( './pattern.js' ),

  /* 
   * const promises = Gibber.init([
   *   {
   *     plugin:Audio, // Audio is required, imported, or grabbed via <script>
   *     options: { workletPath:'../dist/gibberish_worklet.js' }
   *   },
   *   {
   *     plugin:Graphics,
   *     options:{ canvas:document.querySelector('canvas' ) }
   *   }
   * ])
  */

  init( plugins ) { 
    this.createPubSub( this )
    this.plugins = plugins

    const promises = []

    // init each plugin and collect promises
    for( let plugin of plugins ) {
      promises.push( 
        plugin.plugin.init( plugin.options, this ) 
      )
    }

    const p = new Promise( (resolve,reject) => {
      const finishedInitPromise = Promise.all( promises ).then( values => {
        
        this.Pattern = this.__Pattern( this )
        this.Seq      = require( './seq.js'      )( this )
        this.Tidal    = require( './tidal.js'    )( this )
        this.Euclid   = require( './euclid.js'   )( this )
        this.Hex      = require( './hex.js'      )( this ) 
        this.Triggers = require( './triggers.js' )( this )
        this.Steps    = require( './steps.js'    )( this )

        values.forEach( v => {
          if( Array.isArray( v ) ) 
            this[ v[1] ] = v[0]
        })

        Gibber.publish( 'init' )
        
        resolve()
      })
    })
  
    return p
  },

  log( ...args ) {
    if( Gibber.Environment ) {
      Gibber.Environment.log( ...args )
    }else{
      console.log( ...args )
    }
  },

  error( ...args ) {
    if( Gibber.Environment ) {
      Gibber.Environment.error( ...args )
    }else{
      console.error( ...args )
    }
  },

  export( obj ) {
    // XXX must keep reference to main pattern function
    // so it can be serialized and transferred to audioworklet  
    obj.Pattern  = this.Pattern
    obj.Seq = this.Seq
    obj.Tidal = this.Tidal
    obj.Euclid = this.Euclid
    obj.Hex = this.Hex
    obj.Triggers = this.Triggers
    obj.Steps = this.Steps

    this.plugins.forEach( p => {
      p.plugin.export( obj, Gibber ) 
    })

    //obj.Clock = this.Clock
    //obj.WavePattern = this.WavePattern
  },

  // XXX stop clock from being cleared.
  clear() { 
    for( let plugin of Gibber.plugins ) {
      plugin.plugin.clear()
    }

    this.Seq.clear()
    this.Tidal.clear()

    this.publish( 'clear' )
  },

  onload() {},

  createPubSub( obj ) {
    const events = {}
    obj.subscribe = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
    }

    obj.unsubscribe = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
    }

    obj.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
    }
  },

  // When a property is created, a proxy-ish object is made that is
  // prefaced by a double underscore. This object holds the value of the 
  // property, sequencers for the property, and modulations for the property.
  // Alternative getter/setter methods can be passed as arguments.
  createProperty( obj, name, value, post=null, priority=0, transform=null, isPoly=false ) {
    obj[ '__' + name ] = { 
      value,
      isProperty:true,
      sequencers:[],
      tidals:[],
      mods:[],
      name,
      type:obj.type,
      __owner:obj,

      fade( from=0, to=1, time=4, delay=0 ) {
        Gibber[ obj.type ].createFade( from, to, time, obj, name, delay )
        return obj
      }
    }

    Gibber.addSequencing( obj, name, priority, value, '__' )

    Object.defineProperty( obj, name, {
      configurable:true,
      get: Gibber[ obj.type ].createGetter( obj, name ),
      set: Gibber[ obj.type ].createSetter( obj, name, post, transform, isPoly )
    })
  },

  getType( obj ) {
    let type
    switch( from.type ) {
      case 'audio':
      case 'Audio':
        type = Gibber.Audio
        break
      case 'graphics':
      case 'Graphics':
        type = Gibber.Graphics
        break
      case 'gen':
        type = 'gen'
        break
    }

    return type
  },

  mappings: {},
  
  createMapping( from, to, name, wrappedTo ) {
    const fromlib = this.getType( from ),
          tolib   = this.getType( to )


    if( mappings[ tolib ] !== undefined &&
      mappings[ tolib ][ fromlib ] !== undefined ) {
      
      const mapper = mappings[ tolib ][ fromlib ]

      mapper( name, to, from )
    }

  
    //if( from.type === 'audio' ) {
    //  const f = to[ '__' + name ].follow = Follow({ input: from, bufferSize:4096 })

    //  Marching.callbacks.push( time => {
    //    if( f.output !== undefined ) {
    //      to[ name ] = f.output
    //    }
    //  })

    //  let m = f.multiplier
    //  Object.defineProperty( to[ name ], 'multiplier', {
    //    configurable:true,
    //    get() { return m },
    //    set(v) { m = v; f.multiplier = m }
    //  })

    //  let o = f.offset
    //  Object.defineProperty( to[ name ], 'offset', {
    //    configurable:true,
    //    get() { return o },
    //    set(v) { o = v; f.offset = o }
    //  })
    //}else if( from.type === 'gen' ) {
    //  const gen = from.render( 60, 'graphics' )

    //  // needed for annotations
    //  to[ name ].value.id = to[ name ].value.varName

    //  // XXX fix the two possible locations for the callback
    //  if( to[ name ].value.callback !== undefined ) {
    //    const idx = Marching.callbacks.indexOf( to[ name ].value.callback )
    //    Marching.callbacks.splice( idx, 1 )
    //  }else if( to[ '__'+name ].callback !== undefined ) {
    //    const idx = Marching.callbacks.indexOf( to[ '__'+name ].callback )
    //    Marching.callbacks.splice( idx, 1 )
    //  }

    //  // XXX fix the two possible locations for the callback
    //  if( typeof to[ name ].value === 'object' ) {
    //    to[ name ].value.callback = t => {
    //      const val = gen()
    //      to[ name ] = val
    //      //console.log( 'val:', val, to[ name ].value.widget !== undefined )
    //      let target = to[ name ].value.widget !== undefined ? to[ name ].value.widget : from.widget

    //      if( target === undefined && to[ name ].value.mark !== undefined ) 
    //        target = to[ name ].value.mark.replacedWith

    //      Gibber.Environment.codeMarkup.waveform.updateWidget( target, val, false )
    //    }
    //  }else{
    //    // assignment hack while DOM creation is taking place,
    //    // only needed for mappings to individual vector elements.
    //    if( to[ '__'+name ].widget === undefined ) {
    //      setTimeout( ()=> to[ '__'+name ].widget = gen.pre.widget, 150 )
    //    }

    //    to[ '__'+name ].callback = t => {
    //      const val = gen()
    //      to[ name ] = val
    //      Gibber.Environment.codeMarkup.waveform.updateWidget( to[ '__'+name ].widget, val, false )
    //    }
    //  }

    //  if( typeof to[ name ].value !== 'object' ) {
    //    Marching.callbacks.push( to[ '__'+name ].callback )
    //  }else{
    //    Marching.callbacks.push( to[ name ].value.callback )
    //  }
    //}
  },

  addSequencing( obj, name, priority, value, prefix='' ) {
    if( obj[ prefix+name ] === undefined ) obj[ prefix+name ] = {}

    obj[ prefix+name ].sequencers = []
    obj[ prefix+name ].seq = function ( values, timings, number = 0, delay = 0 ) {
      if( value !== undefined && typeof value === 'object' ) value.name = obj.name
      const type = obj.type === 'gen' ? 'audio' : obj.type
      Gibber.Seq({ 
        values, 
        timings, 
        target:obj,
        key:name,
        priority,
        delay,
        number,
        standalone:false,
        name:obj.name
      })

      return obj
    }

    obj[ prefix+name ].tidal = function( pattern,  number = 0, delay = 0 ) {
      if( value !== undefined ) value.name = obj.name
      const type = obj.type === 'gen' ? 'audio' : obj.type
      const s = Gibber.Tidal({ 
        pattern, 
        target:obj, 
        key:name,
        number,
        delay,
        standalone:false
      })

      // return object for method chaining
      return obj
    }
  }
  
}

module.exports = Gibber 

},{"./euclid.js":132,"./hex.js":133,"./pattern.js":135,"./seq.js":136,"./steps.js":137,"./tidal.js":138,"./triggers.js":139}],135:[function(require,module,exports){
const patternWrapper = function( Gibber ) {
  "use strict"

  // hack to pass Gibberish to pattern generator from within worklet processor
  let Gibberish
  if( Gibber.Gibberish === undefined ) {
    Gibberish = Gibber.Audio !== undefined ? Gibber.Audio.Gibberish : Gibber 
  }else{
    Gibberish = Gibber.Gibberish
  }

  let PatternProto = Object.create( function(){} )

  // this prototype is somewhat limited, as we want to be able to add
  // .seq() methods to everything. This means that every pattern needs its own
  // copy of each method. One alternative would be to use a more comprehensive
  // prototype and then place proxies on each method of each pattern that access
  // object-specific sequencers... but just making copies of all functions is certainly
  // simpler.
  Object.assign( PatternProto, {
    type:'pattern',
    DNR: -987654321,
    concat( _pattern ) { this.values = this.values.concat( _pattern.values ) },  
    //toString() { return this.values.toString() },
    //valueOf() { return this.values },

    __message(  key, args ) {
      if( this.category === 'audio' ) {
        if( Gibberish.mode === 'processor' )
          Gibberish.processor.messages.push( this.id, key, args )
      } 
    },

    getLength() {
      let l
      if( this.start <= this.end ) {
        l = this.end - this.start + 1
      }else{
        l = this.values.length + this.end - this.start + 1
      }
      return l
    },

    runFilters( val, idx ) {
      let args = [ val, 1, idx ] // 1 is phaseModifier

      for( let filter of this.filters ) {
        const __args = args
        try {
          args = filter( args, this ) 
        } catch( e ) {
          console.error( e )
          console.log( 'filter problem?' )
          console.log( `removing bad filter from pattern: ${filter.toString()}` ) 
          const idx = this.filters.indexOf( filter )
          this.filters.splice( idx, 1 )
          args = __args
        }
      }

      // XXX why is this one off from the worklet-side pattern id?
      this.__message( 'update.value', args.override === undefined ? args[0] : args.override ) 
      this.__message( 'update.currentIndex', args[2] ) 
      if( this.isGen === true ) {
        this.__message( 'waveformPoint', args.override === undefined ? args[0] : args.override ) 
      }

      return args
    },

    checkForUpdateFunction( name, ...args ) {
      if( this.__delayAnnotations === true ) {
        setTimeout( ()=> {
          if( this.listeners[ name ] ) {
            this.listeners[ name ].apply( this, args )
          }else if( Pattern.listeners[ name ] ) {
            Pattern.listeners[ name ].apply( this, args )
          }
        }, 5 )
      }else{
        if( this.listeners[ name ] ) {
          this.listeners[ name ].apply( this, args )
        }else if( Pattern.listeners[ name ] ) {
          Pattern.listeners[ name ].apply( this, args )
        }
      }
    },

    // used when _onchange has not been assigned to individual patterns
    _onchange() {},

    // XXX it would be nice if filters used a similar style to fx chains...
    // pattern.filters.add( ) etc.
    addFilter( filter, name=null ) {
      if( name !== null ) {
        filter.__name = name
        const idx = this.filters.findIndex( f => f.__name === name )
        this.filters.splice( idx, 1 )  
      }
      this.filters.push( filter )
      return this
    },

    removeFilter( idx=null ) {
      if( idx !== null ) {
        this.filters.splice( idx, 1 )  
      }else{
        this.filters.length = 0
      }

      return this
    },

    inspect() {
      if( Gibberish.mode === 'processor' ) 
        console.table({ values:this.values.toString(), 'number of filters':this.filters.length, phase:this.phase })
    },

    render( cat='Audio' ) {
      this.category = cat
      if( typeof Gibber[ cat ] === 'object' && typeof Gibber[ cat ].patternRender === 'function' ) {
        Gibber[ cat ].patternRender( this )
      }
      if( typeof this.onrender === 'function' ) {
        this.onrender()
      }
    },

    copy() {
      const p = Pattern( ...this.values )
      //this.filters.forEach( f => p.addFilter( f ) )
      p.start = this.start
      p.end   = this.end
      p.phase = this.phase

      return p
    },

    __methodNames:  [
      'rotate','switch','invert','flip',
      'transpose','reverse','shuffle','scale',
      'store', 'range', 'set', 'freeze', 'thaw', 'double'
    ]

  })

  const Pattern = function( ...args ) {
    //console.log( 'args[0]:', args[0].isPattern, args[0] )
    //if( typeof args[0] === 'function' && args[0] !== null && args[0].isPattern === true ) {
    //  console.log( 'got pattern' )
    //  return args[0]
    //}

    const isFunction = args.length === 1 && typeof args[0] === 'function',
          isGen = typeof args[0] === 'object' && args[0].__isGen

    //if( isGen === true ) { 
    //  // must have a priority or it screws us codegen for analysis
    //  args[0].priority = 0
    //  Gibberish.analyzers.push( args[0] )
    //  Gibberish.dirty( Gibberish.analyzers )
    //}


    const fnc = function() {
      let len = fnc.getLength(),
          idx, val, args

      if( len === 1 ) { 
        idx = 0 
      }else{
        idx = fnc.phase > -1 ? Math.floor( fnc.start + (fnc.phase % len ) ) : Math.floor( fnc.end + (fnc.phase % len ) )
      }

      if( isFunction ) {
        val = fnc.values[ 0 ]()
        args = fnc.runFilters( val, idx )
        val = args[0]
      } else if( isGen === true ) {
        val = fnc.values[ 0 ].callback.out[0]

        args = fnc.runFilters( val, idx )
        val = args[0]
      }else{
        val = fnc.values[ Math.floor( idx % fnc.values.length ) ]
        args = fnc.runFilters( val, idx )
      
        fnc.phase += fnc.stepSize * args[ 1 ]


        val = args[ 0 ]
      }
      // check to see if value is a function, and if so evaluate it
      //if( typeof val === 'function' ) {
        //val = val()
      //}
      /*else if ( Array.isArray( val ) ) {
        // if val is an Array, loop through array and evaluate any functions found there. TODO: IS THIS SMART?

        for( let i = 0; i < val.length; i++ ){
          if( typeof val[ i ] === 'function' ) {
            val[ i ] = val[ i ]()
          }
        }
      }
      */

      //XXX is this needed? Adding it interferes with Steps
      //if( val === fnc.DNR ) val = null

      return val
    }



    let out 
    Object.assign( fnc, {
      category:'audio',
      start : 0,
      end   : 0,
      phase : 0,
      values : args, 
      isPattern: true,
      __frozen:false,
      // wrap annotation update in setTimeout( func, 0 )
      __delayAnnotations:false,
      //values : typeof arguments[0] !== 'string' || arguments.length > 1 ? Array.prototype.slice.call( arguments, 0 ) : arguments[0].split(''),    
      original : null,
      storage : [],
      stepSize : 1,
      integersOnly : false,
      filters : [],
      __listeners: [],
      onchange : null,
      isop:true,
      isGen,

      freeze( shouldFreezeTheory = true ) {
        fnc.__frozen = true
      },
      thaw() {
        fnc.__frozen = false
        Gibber.Theory.thaw()
      },

      setSeq( seq ) {
        this.seq = seq
      },

      range(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.range( ...args )
          return this
        }

        if( !fnc.__frozen ) {
          let start, end
          
          if( Array.isArray( arguments[0] ) ) {
            start = arguments[0][0]
            end   = arguments[0][1]
          }else{
            start = arguments[0]
            end   = arguments[1]
          }
          
          if( start < end ) {
            fnc.start = start
            fnc.end = end
          }else{
            fnc.start = end
            fnc.end = start
          }

          this.checkForUpdateFunction( 'range', fnc )
        }

        return fnc
      },
      double(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.double(...args)
          return this
        }
        if( !fnc.__frozen ) {

          fnc.values.push( ...fnc.values ) 
          
          fnc.end = fnc.values.length - 1
          
          // if( fnc.end > fnc.values.length - 1 ) {
          //   fnc.end = fnc.values.length - 1
          // }else if( fnc.end < )
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange()
        }
        
        return fnc
      },   

      set(...args) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.set(...args)
          return this
        }
        if( !fnc.__frozen ) {
          let args = Array.isArray( arguments[ 0 ] ) ? arguments[ 0 ] : arguments
          
          fnc.values.length = 0

          const tmp = [] 
          
          for( let i = 0; i < args.length; i++ ) {
            const val = args[i].isPattern === true ? args[ i ].original.slice(0) : args[ i ] 
            tmp.push( val )
          }
          fnc.values = tmp
          
          fnc.end = fnc.values.length - 1
          
          // if( fnc.end > fnc.values.length - 1 ) {
          //   fnc.end = fnc.values.length - 1
          // }else if( fnc.end < )
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange( 'set', fnc.values ) //args )
        }
        
        return fnc
      },
       
      reverse() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.reverse()
          return this
        }
        if( !fnc.__frozen ) {
          let array = fnc.values,
              left = null,
              right = null,
              length = array.length,
              temporary;
              
          for ( left = 0, right = length - 1; left < right; left += 1, right -= 1 ) {
            temporary = array[ left ]
            array[ left ] = array[ right ]
            array[ right ] = temporary;
          }
          
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', array ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'reverse', null )
        }
        
        return fnc
      },
      // humanize: function( randomMin, randomMax ) {
   //      let lastAmt = 0
   //
   //      for( let i = 0; i < this.filters.length; i++ ) {
   //        if( this.filters[ i ].humanize ) {
   //          lastAmt = this.filters[ i ].lastAmt
   //          this.filters.splice( i, 1 )
   //          break;
   //        }
   //      }
   //
   //      let filter = function( args ) {
   //        console.log( filter.lastAmt, args[0])
   //        args[ 0 ] -= filter.lastAmt
   //        filter.lastAmt = Gibber.Clock.time( Gibber.Utilities.rndi( randomMin, randomMax ) )
   //
   //        console.log( "LA", filter.lastAmt )
   //        args[0] += filter.lastAmt
   //
   //        return args
   //      }
   //      filter.lastAmt = lastAmt
   //      filter.humanize = true
   //
   //      this.filters.push( filter )
   //
   //      return this
   //    },
      repeat() {
        let counts = {}
      
        for( let i = 0; i < arguments.length; i +=2 ) {
          counts[ arguments[ i ] ] = {
            phase: 0,
            target: arguments[ i + 1 ]
          }
        }
        
        let repeating = false, repeatValue = null, repeatIndex = null
        let filter = function( args ) {
          let value = args[ 0 ], phaseModifier = args[ 1 ], output = args
          
          //console.log( args, counts )
          if( repeating === false && counts[ value ] ) {
            repeating = true
            repeatValue = value
            repeatIndex = args[2]
          }
          
          if( repeating === true ) {
            if( counts[ repeatValue ].phase !== counts[ repeatValue ].target ) {
              output[ 0 ] = repeatValue            
              output[ 1 ] = 0
              output[ 2 ] = repeatIndex
              //[ val, 1, idx ]
              counts[ repeatValue ].phase++
            }else{
              counts[ repeatValue ].phase = 0
              output[ 1 ] = 1
              if( value !== repeatValue ) { 
                repeating = false
              }else{
                counts[ repeatValue ].phase++
              }
            }
          }
        
          return output
        }
      
        fnc.filters.push( filter )
      
        return fnc
      },
    
      reset() { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.reset()
          return this
        }
        if( !fnc.__frozen ) {
          // XXX replace with some type of standard deep copy
          if( Array.isArray( fnc.original[0] ) ) {
            const arr = []
            for( let i = 0; i < fnc.original.length; i++ ) {
              const chord = fnc.original[ i ]
              arr[ i ] = []
              for( let j = 0; j < chord.length; j++ ) {
                arr[ i ][ j ] = chord[ j ] 
              }
            }
            fnc.values = arr
          }else{
            fnc.values = fnc.original.slice(0)
          }
          //fnc.set( fnc.original.slice( 0 ) );
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }  
          fnc._onchange( 'reset', null )
        }

        return fnc 
      },

      store( pos ) { fnc.storage[ pos || fnc.storage.length ] = fnc.values.slice( 0 ); return fnc; },

      transpose( amt ) { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.transpose( amt )
          return this
        }
        if( !fnc.__frozen ) {
          for( let i = 0; i < fnc.values.length; i++ ) { 
            let val = fnc.values[ i ]
            
            if( Array.isArray( val ) ) {
              for( let j = 0; j < val.length; j++ ) {
                if( typeof val[ j ] === 'number' ) {
                  val[ j ] = fnc.integersOnly ? Math.round( val[ j ] + amt ) : val[ j ] + amt
                }
              }
            }else{
              if( typeof val === 'number' ) {
                fnc.values[ i ] = fnc.integersOnly ? Math.round( fnc.values[ i ] + amt ) : fnc.values[ i ] + amt
              }
            }
          }
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', ['transpose', amt] ) 
          }      
          //fnc._onchange( 'transpose', amt )
        }
        
        return fnc
      },

      shuffle() { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.shuffle( )
          return this
        }
        if( !fnc.__frozen ) {
          Gibber.Utility.shuffle( fnc.values )
          fnc._onchange( 'shuffule', null )
        }
        
        return fnc
      },

      scale( amt ) { 
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.scale( amt )
          return this
        }
        if( !fnc.__frozen ) {
          fnc.values.map( (val, idx, array) => {
            if( Array.isArray( val ) ) {
              array[ idx ] = val.map( inside  => {
                if( typeof inside === 'number' ) {
                  return fnc.integersOnly ? Math.round( inside * amt ) : inside * amt
                } else {
                  return inside
                }
              })
            }else{
              if( typeof val === 'number' ) {
                array[ idx ] = fnc.integersOnly ? Math.round( val * amt ) : val * amt
              }
            }
          })
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }
          fnc._onchange( 'scale', amt )
        }
        
        return fnc
      },

      flip() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.flip( )
          return this
        }
        if( !fnc.__frozen ) {
          let start = [],
              ordered = null
        
          ordered = fnc.values.filter( function(elem) {
            let shouldPush = start.indexOf( elem ) === -1
            if( shouldPush ) start.push( elem )
            return shouldPush
          })
        
          ordered = ordered.sort( function( a,b ){ return a - b } )
        
          for( let i = 0; i < fnc.values.length; i++ ) {
            let pos = ordered.indexOf( fnc.values[ i ] )
            fnc.values[ i ] = ordered[ ordered.length - pos - 1 ]
          }
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }       
          fnc._onchange( 'flip', null )
        }
      
        return fnc
      },
      
      invert() {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.invert( )
          return this
        }
        if( !fnc.__frozen ) {
          let prime0 = fnc.values[ 0 ]
          
          for( let i = 1; i < fnc.values.length; i++ ) {
            if( typeof fnc.values[ i ] === 'number' ) {
              let inverse = prime0 + (prime0 - fnc.values[ i ])
              fnc.values[ i ] = inverse
            }
          }
          
          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'invert', null )
        }
        
        return fnc
      },
    
      switch( to ) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.switch( to )
          return this
        }
        if( !fnc.__frozen ) {
          if( fnc.storage[ to ] ) {
            fnc.values = fnc.storage[ to ].slice( 0 )
          }
          
          fnc._onchange( 'switch', to )
        }
        
        return fnc
      },
    
      rotate( amt ) {
        if( this.__rendered !== undefined && this.__rendered !== this ) {
          this.__rendered.rotate( amt )
          return this
        }
        if( !fnc.__frozen ) {
          if( amt > 0 ) {
            while( amt > 0 ) {
              let end = fnc.values.pop()
              fnc.values.unshift( end )
              amt--
            }
          }else if( amt < 0 ) {
            while( amt < 0 ) {
              let begin = fnc.values.shift()
              fnc.values.push( begin )
              amt++
            }
          }

          if( Gibberish.mode === 'processor' ) {
            fnc.__message( 'values', fnc.values ) 
            fnc.__message( '_onchange', true ) 
          }

          fnc._onchange( 'rotate', amt )
        }
        
        return fnc
      },

      clear() {
        if( Gibberish.mode === 'worklet' ) {
          for( let key of PatternProto.__methodNames ) {
            for( let i = 0; i < out[ key ].sequencers.length; i++ ) {
              // this can most certainly be optimized, but I had real problems
              // getting this clearing to work, perhaps related to proxy behaviors?
              const __seq = Gibber.Seq.sequencers.find( s => s.id === out[ key ][ i ].id )
              if( __seq !== undefined ) {
                Gibber.Audio.Gibberish.worklet.port.postMessage({ address:'method', object:__seq.id, name:'stop', args:[] })
              
                __seq.stop()
                __seq.clear()

                const idx = Gibber.Seq.sequencers.indexOf( __seq )
                Gibber.Seq.sequencers.splice( idx, 1 )
                __seq.target[ __seq.key ][0].stop()
              }
            }
          } 
        }else{
          // genish-based patterns are connected as analyzers so that they
          // don't have to feed into a bus to get rendered. we must remove them
          // from the analysis array to finalize clearing.
          if( out.isGen === true ) {
            const idx = Gibberish.analyzers.indexOf( args[0] )
            if( idx !== -1 ) {
              Gibberish.analyzers.splice( idx, 1 )
              Gibberish.analyzers.dirty = true
            }
          }
        }
      }
    })
    
    if( Gibberish.mode === 'worklet' ) {
      fnc.id = Gibberish.utilities.getUID()

      if( isGen === true ) {
        fnc.waveformPoint = val => {
          // accounts for annoying edge case where wave pattern is
          // inlined to a call to .seq
          // XXX fix in parsing or somehow figure out how to only do this once
          if( fnc.widget !== undefined ) fnc.values[0].widget = fnc.widget
          if( fnc.values[0].widget !== undefined ) {

            // convert samples to beats
            if( fnc.__patternType === 'timings' ) {
              val = Gibber.Clock.stob( val )
            }
            fnc.values[0].widget.values[ fnc.values[0].widget.values.length - 1 ] = { value:val } 
          }
        }
      }
    }
    //fnc.filters.pattern = fnc
    // can I resotre this without making the object non-serializable?
    //fnc.retrograde = fnc.reverse.bind( fnc )
    
    fnc.end = fnc.values.length - 1
    
    /*
    fnc.filters.test = function() { console.log( 'test' ) }
    
    fnc.filters.add = function( f ) {
      this.filters.push( f )
    }.bind(fnc)
    fnc.filters.remove = function( idx ) {
      console.log( 'filter:', this )
      this.filters.splice( idx, 1 )
    }.bind( fnc )
    fnc.filters.inspect = function() {
      console.log( `there are currenly ${this.length} filters on this pattern` )
    }.bind(fnc)
    */

    if( Array.isArray( fnc.values[0] ) ) {
      const arr = []
      for( let i = 0; i < fnc.values.length; i++ ) {
        const chord = fnc.values[ i ]
        arr[ i ] = []
        for( let j = 0; j < chord.length; j++ ) {
          arr[ i ][ j ] = chord[ j ] 
        }
      }
      fnc.original = arr
    }else{
      fnc.original = fnc.values.slice(0)
    }

    fnc.storage[ 0 ] = fnc.original.slice( 0 )
    fnc.integersOnly = fnc.values.every( function( n ) { return n === +n && n === (n|0); })
    
    fnc.listeners = {}
    fnc.sequences = {}

    if( Gibberish.mode === 'worklet' ) {

      for( let key of PatternProto.__methodNames ) { 
        Gibber.addSequencing( fnc,key,2,undefined )
      }
      //for( let key of PatternProto.__methodNames ) { 
      //  fnc.sequencers[ key ] = Gibber.Core !== undefined 
      //    ? Gibber.Core.addSequencing( fnc, key, 2 ) 
      //    : Gibber.addSequencing( fnc,key,2 )
      //}
      fnc.sequences.reset = Gibber.addSequencing( fnc, 'reset', 1 )
    }
    
    // TODO: Gibber.createProxyProperties( fnc, { 'stepSize':0, 'start':0, 'end':0 })
    
    fnc.__proto__ = PatternProto 

    let pn = ''
    Object.defineProperty( fnc, 'patternName', {
      get() { return pn },
      set(__pn) {
        pn = __pn
      }
    })

    fnc.render = function( mode='audio' ) {
      if( mode === 'audio' ) {
        // 'isPattern' is a hack to force pattern initialization arguments to be submitted as
        // a list, instead of in a property dictionary. When 'isPattern' is true, gibberish
        // looks for an 'inputs' property and then passes its value (assumed to be an array)
        // using the spread operator to the constructor. 
        out = Gibberish.Proxy( 'pattern', { inputs:fnc.values, isPattern:true, filters:fnc.filters, id:fnc.id }, fnc ) 

        if( isGen === true ) { 
          // must have a priority or it screws up codegen for analysis
          args[0].priority = 0
          Gibberish.analyzers.push( args[0] )
          Gibberish.dirty( Gibberish.analyzers )
        }
      }

      if( args.filters ) {
        args.filters.forEach( f => out.addFilter( f ) )
      }else if( typeof args[0] === 'object' && args[0].filters ) {
        args[0].filters.forEach( f => out.addFilter( f ) )
      }

      Pattern.children.push( out )

      if( fnc.onrender ) fnc.onrender( out )

      fnc.__rendered = out

      return out
    }
    if( Gibberish.mode === 'processor' ) return fnc.render()

    return fnc 
  }

  Pattern.listeners = {}
  Pattern.children = []
  Pattern.__isFrozen = false
  Pattern.freeze = function( shouldFreezeTheory = true ) {
    Pattern.children.forEach( p => p.freeze() ) 
    if( shouldFreezeTheory === true ) {
      Gibber.Theory.freeze()
      Pattern.__isFrozen = true
    }
  }
  Pattern.thaw = ()=> {
    Pattern.children.forEach( p => p.thaw() )
    if( Pattern.__isFrozen === true ) {
      Gibber.Theory.thaw()
      Pattern.__isFrozen = false
    }
  }

  Pattern.export = function( obj ) {
    obj.freeze = Pattern.freeze
    obj.thaw   = Pattern.thaw
  }

  Pattern.listeners.range = function( fnc ) {
    //if( !Notation.isRunning ) return
    
    if( Gibberish.mode === 'processor' ) return

    // TODO: don't use Gibber.currentTrack, store the object in the pattern
    let rangeStart = fnc.markers[ fnc.start ].find(),
        rangeEnd   = fnc.markers[ fnc.end ].find()

    if( !fnc.range.init ) {
      fnc.range.init = true
      var ptrnStart = fnc.markers[ 0 ].find(),
          ptrnEnd = fnc.markers[ fnc.markers.length - 1 ].find()

      //fnc.column.editor.markText( ptrnStart.from, ptrnEnd.to, { className:'rangeOutside' })
      Gibber.Environment.editor.markText( ptrnStart.from, ptrnEnd.to, { className:'rangeOutside' })//className:'pattern-update-range-outside' })
      if( !Pattern.listeners.range.initialzied ) Pattern.listeners.range.init()
    }

    if( fnc.range.mark ) fnc.range.mark.clear()
    //fnc.range.mark = fnc.column.editor.markText( rangeStart.from, rangeEnd.to, { className:'rangeInside' })
    // TODO: Dont use GE.codemirror... how else do I get this? stored in pattern is created?
    fnc.range.mark = Gibber.Environment.editor.markText( rangeStart.from, rangeEnd.to, { className:'rangeInside' })
  }

  Pattern.listeners.range.init = function() {
    //$.injectCSS({ 
    //  '.rangeOutside': {
    //    'color':'#666 !important'
    //  },
    //  '.rangeInside': {
    //    'color':'rgba(102, 153, 221, 1) !important'
    //  }
    //})
    Pattern.listeners.range.initialized = true
  }

  //Pattern.prototype = PatternProto*/

  return Pattern

}

// helper function to pass the pattern constructor to the gibberish worklet processor.
patternWrapper.transfer = function( Audio, constructorString ) {
  if( Audio.Gibberish !== undefined && Audio.Gibberish.mode === 'worklet' ) {
    Audio.Gibberish.worklet.port.postMessage({
      address:'addConstructor',
      name:'Pattern',
      constructorString
    })
  }
}


module.exports = patternWrapper

},{}],136:[function(require,module,exports){
module.exports = function( Gibber ) {
  const addValuesFilters = (seq,key,target) => {
    const values = seq.values
    const __values = seq.values

    if( __values.randomFlag ) {
      values.addFilter( ( args,ptrn ) => {
        const range = ptrn.values.length - 1
        const idx = Math.round( Math.random() * range )
        return [ ptrn.values[ idx ], 1, idx ] 
      })
      //for( let i = 0; i < this.values.randomArgs.length; i+=2 ) {
      //  valuesPattern.repeat( this.values.randomArgs[ i ], this.values.randomArgs[ i + 1 ] )
      //}
    }

    // trigger autotrig patterns
    if( key === 'note' || key === 'chord' || key === 'trigger' || key === 'notef' || key === 'pickplay' ) {
      values.addFilter( ( args,ptrn ) => {
        if( ptrn.seq.target.autotrig !== undefined ) {
          for( let s of ptrn.seq.target.autotrig ) {
            s.fire()
          }
        }
        return args
      })
    } 
  }

  const addTimingFilters = function( seq,key,renderMode ) {
    const __timings = seq.timings
    if( __timings.randomFlag ) {
      __timings.addFilter( ( args,ptrn ) => {
        const range = ptrn.values.length - 1
        const idx = Math.round( Math.random() * range )
        return [ ptrn.values[ idx ], 1, idx ] 
      })
      //for( let i = 0; i < this.values.randomArgs.length; i+=2 ) {
      //  valuesPattern.repeat( this.values.randomArgs[ i ], this.values.randomArgs[ i + 1 ] )
      //}
    }

    const filter = renderMode === 'Audio' 
      ? (args,ptrn) => {
        if( typeof args[0] === 'number' ) {
          args[0] = Gibberish.Clock.time( args[0] )
        }
        return args
      }
      : (args,ptrn) => {
        if( typeof args[0] === 'number' ) {
          args[0] = Gibber.Clock.time( args[0] )
        }
        return args
      }  

    seq.timings.addFilter( (args,ptrn)=>{
      if( args[0] === 0 ) {
        ptrn.seq.stop()
        console.warn( 'sequencer attempting to fire with a time of zero; this will result in an infinite loop, so the sequencer has been stopped.' )
      }
      return args
    })
    seq.timings.addFilter( filter ) 
  }

  const Seq = function( props ) { 
    let   __values  = props.values
    const __timings = props.timings
    const delay     = props.delay
    const target    = props.target
    const key       = props.key
    const priority  = props.priority
    let   rate      = props.rate || 1
    let   density   = props.density || 1
    let   autotrig  = false
    const render    = props.render || 'Audio'

    const Gibberish = Gibber.Audio.Gibberish !== undefined ? Gibber.Audio.Gibberish : null

    if( __values.type === 'gen' ) {
      __values = __values.render()
    }

    if( Array.isArray( __values ) && __values.length <= 0 ) throw Error('arrays passed to sequences must have at least one value inside of them')
    // convert to pattern if needed and render
    const values = Array.isArray( __values ) 
      ? Gibber.Pattern( ...__values ).render()
      : typeof __values === 'function' && __values.isPattern 
        ? __values.render()
        : __values.requiresRender 
          ? __values
          : Gibber.Pattern( __values ).render()

    // if an array of values is passed, let users call pattern method on that array, for example:
    // a.note.seq( b=[0,1,2,3], 1/4 )
    // b.transpose.seq( 1,1 )
    if( Array.isArray( __values ) ) {
      Object.assign( __values, values )
      __values.addFilter = values.addFilter.bind( values )
      __values.removeFilter = values.removeFilter.bind( values )
      __values.inspect = values.inspect.bind( values )
    } else if( typeof __values === 'object' && __values.type==='gen' ) {
      props.values.addFilter = values.addFilter.bind( values )
      props.values.removeFilter = values.removeFilter.bind( values )
      props.values.inspect = values.inspect.bind( values )
    }

    // process time values
    if( target !== undefined ) {
      if( Gibber[ render ].timeProps[ target.name ] !== undefined 
        && Gibber[ render ].timeProps[ target.name ].indexOf( key ) !== -1  ) {

        const filter = render === 'Audio' 
          ? (args,ptrn) => {
              args[0] = Gibberish.Clock.time( args[0] )
              return args
            }
          : (args,ptrn) => {
              args[0] = Gibber.Audio.Clock.time( args[0] )
              return args
            }

        values.addFilter( filter )
      }
    }
 
    const timings = Array.isArray( __timings ) 
      ? Gibber.Pattern( ...__timings ).render()
      : typeof __timings === 'function' && __timings.isPattern 
        ? __timings.render()
        : __timings === undefined || __timings === null 
          ? null
          : __timings.requiresRender
            ? __timings
            : Gibber.Pattern( __timings ).render()


    if( timings === null ) autotrig = true

    if( Array.isArray( __timings ) ) {
      Object.assign( __timings, timings )
      __timings.addFilter = timings.addFilter.bind( timings )
    }
    if( autotrig === false ) {
      timings.output = { time:'time', shouldExecute:0 }
      timings.density = 1

      // XXX delay annotations so that they occur after values annotations have occurred. There might
      // need to be more checks for this flag in the various annotation update files... right now
      // the check is only in createBorderCycle.js.
      timings.__delayAnnotations = true
    }

    // if an array is passed to the seq, enable users to call pattern methods on array
    //if( Array.isArray( __timings ) ) Object.assign( __timings, timings )

    const clear = render === 'Audio'
      ? function() {
          this.stop()
          
          if( this.values !== undefined && this.values.clear !== undefined  ) {
            this.values.clear()
          }
          if( this.timings !== undefined && this.timings !== null && this.timings.clear !== undefined ) this.timings.clear()

          
          if( Gibberish.mode === 'worklet' ) {
            const idx = Seq.sequencers.indexOf( seq )
            seq.stop()
            const __seq = Seq.sequencers.splice( idx, 1 )[0]
            if( __seq !== undefined ) {
              __seq.stop()
            }
          }
        }
      : function() {
          this.stop()
          
          if( this.values !== undefined && this.values.clear !== undefined  ) this.values.clear()
          if( this.timings !== undefined && this.timings !== null && this.timings.clear !== undefined ) this.timings.clear()

          const idx = Seq.sequencers.indexOf( seq )
          const __seq = Seq.sequencers.splice( idx, 1 )[0]
          if( __seq !== undefined ) {
            __seq.stop()
          }
        }

    values.__patternType = 'values'
    if( timings !== null ) timings.__patternType = 'timings'

    //const offsetRate = Gibberish.binops.Mul(rate, Gibber.Clock.AudioClock )

    // XXX need to fix so that we can use the clock rate as the base
    // XXX need to abstract this so that a graphics sequencer could also be called...
    const seq = Gibber.Audio.Gibberish.Sequencer({ values, timings, density, target, key, priority, rate:1/*Gibber.Clock.AudioClock*/, clear, autotrig, mainthreadonly:props.mainthreadonly })

    if( values.setSeq ) values.setSeq( seq )

    addValuesFilters( seq,key )

    if( autotrig === false ) {
      addTimingFilters( seq,key,render )
      if( timings.setSeq ) timings.setSeq( seq )
    }else{
      if( target !== undefined ) {
        if( target.autotrig === undefined ) {
          target.autotrig = []
          Gibber.Audio.Gibberish.worklet.port.postMessage({
            address:'property',
            name:'autotrig',
            value:[],
            object:target.id
          })

        }
        // object name key value
        if( Gibber.Audio.Gibberish.mode === 'worklet' ) {
          Gibber.Audio.Gibberish.worklet.port.postMessage({
            address:'addObjectToProperty',
            name:'autotrig',
            object:target.id,
            key:target.autotrig.length,
            value:seq.id
          })
          target.autotrig.push( seq )
        }
      }else{
        throw Error('you must define timings for any sequence without a target')
      }
    } 

    //Gibberish.proxyEnabled = false
    //Gibber.Ugen.createProperty( seq, 'density', timings, [], Gibber )
    //Gibberish.proxyEnabled = true

    Seq.sequencers.push( seq )

    // if x.y.seq() etc. 
    // standalone === false is most common use case
    if( props.standalone === false ) { 
      // required ternary because pattern methods don't have __ prefix 
      const targetProp = target[ '__' + key ] === undefined 
        ? target[ key ] 
        : target[ '__' + key ]
      
      const prevSeq = targetProp.sequencers[ props.number ] 
      if( prevSeq !== undefined ) { 
        prevSeq.clear();
      }


      // XXX you have to add a method that does all this shit on the worklet. crap.
      targetProp.sequencers[ props.number ] = seq
      targetProp[ props.number ] = seq 
      //target.__sequencers.push( seq )
      if( typeof delay !== 'function' ) { 
        seq.start( Gibber.Audio.Clock.time( delay ) )
      } else {
        delay.seqs.push( seq )
      }
    }

    Gibber.publish( 'new sequence', seq )

    return seq
  }

  Seq.sequencers = []
  Seq.clear = function() {
    Seq.sequencers.forEach( seq => seq.clear() )
    //for( let i = Seq.sequencers.length - 1; i >= 0; i-- ) {
    //  Seq.sequencers[ i ].clear()
    //}
    Seq.sequencers = []
  }
  Seq.DNR = -987654321

  return Seq

}

},{}],137:[function(require,module,exports){
module.exports = function( Gibber ) {
 
const Steps = {
  type:'Steps',
  create( _steps, target ) {
    const stepseq = Object.create( Steps )
    
    stepseq.seqs = {}

    for( let _key in _steps ) {
      let values = _steps[ _key ]
      const parsedKey = parseInt( _key )
      const key = isNaN( parsedKey ) ? _key : parsedKey

      let usesStringValues = false
      if( values.isPattern !== true ) {
        if( Array.isArray( values ) ) {
          values = Gibber.Pattern( ...values )
        }else if( typeof values === 'string' ) {
          values = values.split('')
          usesStringValues = true
        }else{
          values = Gibber.Pattern( values )
        }
      }

      const seq = Gibber.Seq({
        values: usesStringValues ? values : key,
        timings: usesStringValues ?  [ 1  / values.length ] : values,
        'key': target.__isEnsemble !== true ? 'note' : 'trigger', 
        target: target.__isEnsemble ? target[ target[ key ].name ] : target, 
        priority:0
      })

      const onlyUsesVelocity = typeof key === 'string'


      if( usesStringValues ) {
        seq.values.addFilter( new Function( 'args', 'ptrn', 
         `let sym = args[ 0 ],
              velocity = parseInt( sym, 16 ) / 15

          if( isNaN( velocity ) ) {
            velocity = sym === 'x' 
              ? 1
              : sym === 'X'
                ? 1.5
                : 0
          }

          // TODO: is there a better way to get access to beat, beatOffset and scheduler?
          if( velocity !== 0 ) {
            ${ onlyUsesVelocity ? '' :'ptrn.seq.target.__triggerLoudness = velocity' }
          }

          args[ 0 ] = sym === '.' ? -987654321 : ${typeof key === 'string' ? 'velocity' : key }

          return args
        `) )
      }

      stepseq.seqs[ _key ] = seq
      stepseq[ _key ] = usesStringValues ? seq.values : seq.timings
    }

    stepseq.start()
    stepseq.addPatternMethods()

    return stepseq
  },
  
  /* two parts:
   * 1. The easy part, make methods that can be called from the main thread
   *    and run over every seq instance in the step sequencer
   * 2. The hard part, make an object that lives in the audio thread
   *    and can be sequenced. It needs references to all sequencers in the 
   *    step sequencer.
   */
  addPatternMethods() {
    // XXX shouldn't use audio id by default... sigh
    const id = Gibber.Audio.Gibberish.utilities.getUID()

    // store ids of all controlled sequencers
    const seqIds = []
    for( let key in this.seqs ) {
      seqIds.push( this.seqs[ key ].id )
    }

    // this object will be transferred to audio thread
    const obj = { id, seqIds }

    groupMethodNames.forEach( name => {
      // EASY PART 
      this[ name ] = function( ...args ) { 
        for( let key in this.seqs ) { 
          this.seqs[ key ].values[ name ].apply( this, args ) 
        } 
      }

      this[ name ].sequencers = []
      this[ name ].seq = ( values, timings, number = 0, delay = 0 ) => {
        const s = Gibber.Seq({ 
          values, 
          timings, 
          target:this.__wrapped,
          key:name,
          priority:1,
        }).start()
        
        this[ name ].sequencers.push( s )

        // needed for annotations
        this[ name ][ number ] = s

        return this 
      } 

      // store function body to create function in audio thread representation of steps
      // needs to be one line for stringify / parsing
      // XXX ugh arguments? is there ever more than one argument?
      obj[ name ] = `for( let seq of this.seqs ) { seq.values.${name}.apply( this, arguments ); seq.timings.${name}.apply( this, arguments )}`
    })

    // HARD PART
    // code to be evaluated in audio thread
    // 1. create a new object, steps, bassed on stringifying obj
    // 2. add all of the transform methods
    // 3. store all controlled sequencers in steps.seqs after getting references
    //    from Gibberish.ugens 
    const code = `const steps = JSON.parse( \`${JSON.stringify(obj)}\` )
      const methods = ${JSON.stringify( groupMethodNames ) }
      steps.seqs = steps.seqIds.map( id => Gibberish.ugens.get( id ) )
      for( let method of methods ) {
        steps[ method ] = new Function( steps[ method ] ) 
      }
      Gibberish.ugens.set( steps.id, steps )`
 
    Gibber.Audio.Gibberish.worklet.port.postMessage({
      address:'eval',
      code
    }) 

    this.__wrapped = obj
  },

  start() {
    for( let key in this.seqs ) { 
      this.seqs[ key ].start()
    }
  },

  stop() {
    for( let key in this.seqs ) { 
      this.seqs[ key ].stop()
    }
  },

  clear() { 
    this.stop() 

    for( let key in this.seqs ) {
      this.seqs[ key ].timings.clear()
    }
  }

}

const groupMethodNames = [ 
  'rotate', 'reverse', 'transpose', 'range',
  'shuffle', 'scale', 'repeat', 'store', 
  'reset','flip', 'invert', 'set', 'double'
]

return Steps.create

}

},{}],138:[function(require,module,exports){
module.exports = function( Gibber ) {

  const Seq = function( props ) { 
    const pattern   = props.pattern
    const target    = props.target
    const key       = props.key
    const number    = props.number
    const delay     = props.delay
    const priority  = props.priority || 0
    let   rate      = props.rate || 1
    let   density   = props.density || 1
    let   autotrig  = false


    const render    = target.type !== undefined ? target.type.toLowerCase() : 'audio'
    //const Gibber.Audio.Gibberish = Gibber.Gibber.Audio.Gibberish !== undefined ? Gibber.Gibber.Audio.Gibberish : null

    const clear = render === 'audio'
      ? function() {
          this.stop()
          
          if( Gibber.Audio.Gibberish.mode === 'worklet' ) {
            const idx = Seq.sequencers.indexOf( seq )
            seq.stop()
            const __seq = Seq.sequencers.splice( idx, 1 )[0]
            if( __seq !== undefined ) {
              __seq.stop()
            }
          }
        }
      : function() {
          this.stop()
          
          const idx = Seq.sequencers.indexOf( seq )
          const __seq = Seq.sequencers.splice( idx, 1 )[0]
          if( __seq !== undefined ) {
            __seq.stop()
          }
      }

    const filters = [
      // report back triggered tokens for annotations
      function( val, tidal, uid ) {
        if( Gibberish.mode === 'processor' ) {
          Gibberish.processor.messages.push( tidal.id, 'update.uid', uid )   
          Gibberish.processor.messages.push( tidal.id, 'update.value', val )   
        }
        return val
      } 
    ]

    if( key === 'note' || key === 'chord' || key === 'trigger' ) {
      filters.push( ( args,tidal ) => {
        if( tidal.target.autotrig !== undefined ) {
          for( let s of tidal.target.autotrig ) {
            s.fire()
          }
        }
        return args
      })
    }

    let p
    try {
      p = Gibber.Audio.Gibberish.Tidal.Pattern( pattern ) 
    } catch(e) {
      Gibber.publish( 'error', `\nYour Tidal pattern ${pattern} used invalid syntax.\n` )
      //console.log(`%c\nYour Tidal pattern ${pattern} used invalid syntax.\n`, `color:white;background:#900` )
      return null
    }

    if( key !== 'degree' ) {
      const tokens = [...pattern.matchAll(/[a-zA-Z]+/g)].map( v=>v[0] )
      let tokenNotFound = false
      tokens.forEach( t => {
        if( target[ t ] === undefined ) {
          //console.error(
          //  `%c\nYour Tidal pattern is using a token (${t}) that can't be found on the targeted instrument.`, 
          //  `color:white;background:#900` 
          //  ) 
          
          Gibber.publish( 'error', `\nYour Tidal pattern is using a token (${t}) that can't be found on the targeted instrument.\n` )
          tokenNotFound = true
        }
      })

      if( tokenNotFound === true ) return null
    }

    const seq = Gibber.Audio.Gibberish.Tidal({ pattern, target, key, priority, filters, mainthreadonly:props.mainthreadonly })
    seq.clear = clear
    seq.uid = Gibber.Audio.Gibberish.Tidal.getUID()
    
    //Gibber.Audio.Gibberish.proxyEnabled = false
    //Audio.Ugen.createProperty( seq, 'density', timings, [], Audio )
    //Gibber.Audio.Gibberish.proxyEnabled = true

    Gibber.addSequencing( seq, 'rotate', 1 )

    Seq.sequencers.push( seq )

    Gibber.subscribe( 'clear', ()=> seq.clear() )

    // if x.y.tidal() etc. 
    // standalone === false is most common use case
    if( props.standalone === false ) {
      let prevSeq = target[ '__' + key ].tidals[ number ] 
      if( prevSeq !== undefined ) {
        if( target.__sequencers !== undefined ) {
          const idx = target.__sequencers.indexOf( prevSeq )
          target.__sequencers.splice( idx, 1 )
        }
        // XXX stop() destroys an extra sequencer for some reason????
        prevSeq.stop()
        prevSeq.clear()
        //removeSeq( obj, prevSeq )
      }

      seq.start( Gibber.Audio.Clock.time( delay ) )

      target[ '__' + key ].tidals[ number ] = target[ '__' + key ][ number ] = seq
    }

    Gibber.publish( 'new tidal', seq )
    return seq
  }

  Seq.sequencers = []
  Seq.clear = function() {
    Seq.sequencers.forEach( seq => seq.clear() )
    //for( let i = Seq.sequencers.length - 1; i >= 0; i-- ) {
    //  Seq.sequencers[ i ].clear()
    //}
    Seq.sequencers = []
  }
  Seq.DNR = -987654321

  let val = 1 
  Object.defineProperty( Seq, 'cps', {
    get() { return val },
    set(v) {
      val = v
      Gibber.Audio.Gibberish.Tidal.cps = v
    }
  })

  return Seq

}

},{}],139:[function(require,module,exports){
module.exports = function( Gibber ) {

const Pattern = Gibber.Pattern

const Triggers = function( __values ) {
  const values = __values.split('')
  const pattern = Pattern( ...values ) 
  pattern.isPattern = true
  pattern.type = 'Triggers'
  // need to define custom function to use key as value
  pattern.onrender = function( rendered ) {
    rendered.addFilter( new Function( 'args', 'ptrn', 
     `let sym = args[ 0 ],
          velocity = parseInt( sym, 16 ) / 15

      if( isNaN( velocity ) ) {
        velocity = 0
      }

      if( velocity !== 0 ) {
        ptrn.seq.target.__triggerLoudness = velocity
      }

      ptrn.output = {
        time : Gibberish.Clock.time( ${1/values.length} ),
        shouldExecute: sym !== '.' ? 1 : 0
      }

      args[0] = ptrn.output

      return args`
    ))
  }

  return pattern
}

return Triggers

}

},{}],140:[function(require,module,exports){
let ugen = require( '../ugen.js' )

let analyzer = Object.create( ugen )

Object.assign( analyzer, {
  __type__: 'analyzer',
  priority:0
})

module.exports = analyzer

},{"../ugen.js":210}],141:[function(require,module,exports){
module.exports = function( Gibberish ) {
  const { In, Out, SSD } = require( './singlesampledelay.js'  )( Gibberish )

  const analyzers = {
    SSD,
    SSD_In: In,
    SSD_Out: Out, 
    Follow: require( './follow.dsp.js'  )( Gibberish )
  }
  analyzers.Follow_out = analyzers.Follow.out
  analyzers.Follow_in  = analyzers.Follow.in
  
  analyzers.export = target => {
    for( let key in analyzers ) {
      if( key !== 'export' ) {
        target[ key ] = analyzers[ key ]
      }
    }
  }

  return analyzers

}

},{"./follow.dsp.js":142,"./singlesampledelay.js":143}],142:[function(require,module,exports){
const g = require( 'genish.js' ),
      analyzer = require( './analyzer.js' ),
      ugen = require( '../ugen.js' )

const genish = g

module.exports = function( Gibberish ) {

  const Follow = function( __props ){
    const props = Object.assign( {}, Follow.defaults, __props )

    let isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false

    let out = props 

    /* if we are in the main thread,
     * only send a command to make a Follow instance
     * to the processor thread and include the id #
     * of the input ugen.
     */

    //console.log( 'isStereo:', Gibberish.mode, isStereo, props.input )
    if( Gibberish.mode === 'worklet' ) {
      // send obj to be made in processor thread
      props.input = { id: props.input.id }
      props.isStereo = isStereo

      // creates clashes in processor thread unless
      // we skip a number here... nice
      Gibberish.utilities.getUID()

      props.overrideid = Gibberish.utilities.getUID()

      // XXX seems like this id gets overridden somewhere
      // hence .overrideid
      props.id = props.overrideid

      Gibberish.worklet.port.postMessage({
        address:'add',

        properties:JSON.stringify( props ),

        name:['analysis','Follow']
      })

      Gibberish.worklet.ugens.set( props.overrideid, out )

      let mult = props.multiplier

      Object.defineProperty( out, 'multiplier', {
        get() { return mult },
        set(v){
          mult = v
          Gibberish.worklet.port.postMessage({ 
            address:'set', 
            object:props.overrideid,
            name:'multiplier',
            value:mult
          })
        }
      })

      let offset = props.offset
      Object.defineProperty( out, 'offset', {
        get() { return offset },
        set(v){
          offset = v
          Gibberish.worklet.port.postMessage({ 
            address:'set', 
            object:props.overrideid,
            name:'offset',
            value:offset
          })
        }
      })
    }else{
      //isStereo = props.isStereo

      const buffer = g.data( props.bufferSize, 1 )
      const input  = g.in( 'input' )
      const multiplier = g.in( 'multiplier' )
      const offset     = g.in( 'offset' )
      
      const follow_out = Object.create( analyzer )
      follow_out.id = props.id = __props.overrideid

      let avg = g.data( 1,1, { meta:true } ) // output; make available outside jsdsp block
      const idx = avg.memory.values.idx
  
      const callback = function( memory ) {
        return avg[0]
      }

      const out = {
        callback,
        input:props.input,
        isStereo,
        dirty:true,
        inputNames:[ 'input', 'memory' ],
        inputs:[ props.input ],
        id: Gibberish.utilities.getUID(),

        __properties__: { input:props.input },
      }

      // nonsense to make our custom function work
      out.callback.ugenName = out.ugenName = `follow_out_${follow_out.id}`
      out.id = __props.overrideid

      // begin input tracker
      const follow_in = Object.create( ugen )

      if( isStereo === true ) {
        if( props.outputStereo === false ) {
          { 
            "use jsdsp"
            // phase to write to follow buffer
            const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

            // hold running sum
            const sum = g.data( 1, 1, { meta:true })

            const mono = props.abs === true ? g.abs( input[0] + input[1] ) : input[0] + input[1]

            sum[0] = sum[0] + mono - g.peek( buffer, bufferPhaseOut, { mode:'simple' })

            g.poke( buffer, g.abs( mono ), bufferPhaseOut )

            avg = (sum[0] / props.bufferSize) * multiplier + offset
          }
        }else{
          const bufferL = buffer
          const bufferR = g.data( props.bufferSize, 1 )

          { 
            "use jsdsp"
            // phase to write to follow buffer
            const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

            // hold running sum
            const sumL = g.data( 1, 1, { meta:true })
            const sumR = g.data( 1, 1, { meta:true })

            const left = props.abs === true  ? g.abs( input[0] ) : input[0]
            const right = props.abs === true ? g.abs( input[1] ) : input[1]

            sumL[0] = sumL[0] + left - g.peek( bufferL, bufferPhaseOut, { mode:'simple' })
            sumR[0] = sumR[0] + right- g.peek( bufferR, bufferPhaseOut, { mode:'simple' })

            g.poke( bufferL, g.abs( left  ), bufferPhaseOut )
            g.poke( bufferR, g.abs( right ), bufferPhaseOut )

            avg = [
              (sumL[0] / props.bufferSize) * multiplier + offset,
              (sumR[0] / props.bufferSize) * multiplier + offset,
            ]
          }
        }
      }else{
        {
          "use jsdsp"
          // phase to write to follow buffer
          const bufferPhaseOut = g.accum( 1,0,{ max:props.bufferSize, min:0 })

          // hold running sum
          const sum = g.data( 1, 1, { meta:true })

          const __input = props.abs === true ? g.abs( input ) : input

          sum[0] = sum[0] + __input - g.peek( buffer, bufferPhaseOut, { mode:'simple' })
          
          g.poke( buffer, g.abs( input ), bufferPhaseOut )

          avg = (sum[0] / props.bufferSize) * multiplier + offset
        }
      }
      Gibberish.utilities.getUID()

      props.isStereo = false
      const record = Gibberish.factory( 
        follow_in,
        avg, 
        ['analysis', 'follow_in'], 
        props
      )

      // nonsense to make our custom function work
      record.callback.ugenName = record.ugenName = `follow_in_${follow_out.id}`

      if( Gibberish.analyzers.indexOf( record ) === -1 ) Gibberish.analyzers.push( record )

      Gibberish.dirty( Gibberish.analyzers )

      Gibberish.ugens.set( __props.overrideid, record )

      out.record = record
    }

    return out

  }
 
  Follow.defaults = {
    input:0,
    bufferSize:1024,
    multiplier:1,
    abs: true,
    outputStereo:false,
    offset:0
  }

  return Follow

}

},{"../ugen.js":210,"./analyzer.js":140,"genish.js":51}],143:[function(require,module,exports){
const g = require( 'genish.js' ),
      analyzer = require( './analyzer.js' ),
      proxy    = require( '../workletProxy.js' ),
      ugen     = require( '../ugen.js' )

module.exports = function( Gibberish ) {
 
// an SSD ugen is in effect two-in-one,
// one for input and one for output.  
  
const SSD = inputProps => {
  const ssd = Object.create( analyzer )

  const props = Object.assign({}, SSD.defaults, inputProps )
  const isStereo = props.isStereo 
  const input    = g.in( 'input' )
  const historyL = g.history(0)
  const historyR = g.history(0)

  ssd.out = Out( [historyL,historyR], props )
  ssd.in  =  In( [historyL,historyR], props )

  ssd.listen = ssd.in.listen

  return ssd 
}

const Out = ( histories,props ) => {
  let history
  // if we don't find our history ugen in the processor thread,
  // just go ahead and make a new one, they're cheap...
  if( Gibberish.mode === 'processor' ) {
    const id = Array.isArray( histories ) ? histories[0].id : histories.id
    history = Gibberish.ugens.get( id )
    if( history === undefined ) {
      history = g.history( 0 )
      Gibberish.ugens.set( id, history )
    }
    if( props === undefined ) props = { id }
  }else{
    history = histories[0]
  }

  return Gibberish.factory( Object.create( ugen ), history.out, ['analysis','SSD_Out'], props, null )
}

const In = histories => {
  const input = g.in( 'input' )
  let historyL, historyR
  
  if( Gibberish.mode === 'processor' ) {
    // for some reason the proessor id is always one off from the main thread id
    historyL = Gibberish.ugens.get( histories.id - 1 )
    historyR = Gibberish.ugens.get( histories.id )
  }else{
    historyL = histories[0]
    historyR = histories[1]
  }

  // deliberate let
  let ssdin = Object.create( ugen )
  
  ssdin.listen = function( input ) {
    ssdin.input = input
    // changing the input must trigger codegen
    Gibberish.dirty( Gibberish.analyzers ) 

    let isStereo = input.isStereo
    if( input.isStereo === undefined && input.isop === true ) {
      isStereo = input.inputs[0].isStereo === true || input.inputs[1].isStereo === true 
    }
    if( isStereo === true && Gibberish.mode === 'processor' ) {
      const idx = historyL.graph.memory.value.idx     
      ssdin.callback = function( input, memory ) {
        memory[ idx ] = input[ 0 ]
        memory[ idx + 1 ] = input[ 1 ]
        return 0     
      }

      // when each ugen callback is passed to the master callback function
      // it needs to have a ugenName property; we'll just copy this over
      ssdin.callback.ugenName = ssdin.ugenName
    }
  }

  ssdin = Gibberish.factory( ssdin, input, ['analysis','SSD_In'], { 'input':0 } )

  // overwrite the callback function in the processor thread...
  if( Gibberish.mode === 'processor' ) {
    const idx = historyL.graph.memory.value.idx
    
    ssdin.callback = function( input, memory ) {
      memory[ idx ] = input
      return 0     
    }

    // when each ugen callback is passed to the master callback function
    // it needs to have a ugenName property; we'll just copy this over
    ssdin.callback.ugenName = ssdin.ugenName
  }

  ssdin.type = 'analysis'
  Gibberish.analyzers.push( ssdin )

  return ssdin
}

SSD.defaults = {
  input:0,
  isStereo:false
}

return { In, Out, SSD }

}

},{"../ugen.js":210,"../workletProxy.js":212,"./analyzer.js":140,"genish.js":51}],144:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const AD = function( argumentProps ) {
    const ad = Object.create( ugen ),
          attack  = g.in( 'attack' ),
          decay   = g.in( 'decay' )

    const props = Object.assign( {}, AD.defaults, argumentProps )

    const graph = g.ad( attack, decay, { shape:props.shape, alpha:props.alpha })

    ad.trigger = graph.trigger
    
    const __out = Gibberish.factory( ad, graph, ['envelopes','AD'], props )

    return __out
  }

  AD.defaults = { attack:44100, decay:44100, shape:'exponential', alpha:5 } 

  return AD

}

},{"../ugen.js":210,"genish.js":51}],145:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const ADSR = function( argumentProps ) {
    const adsr  = Object.create( ugen ),
          attack  = g.in( 'attack' ),
          decay   = g.in( 'decay' ),
          sustain = g.in( 'sustain' ),
          release = g.in( 'release' ),
          sustainLevel = g.in( 'sustainLevel' )

    const props = Object.assign( {}, ADSR.defaults, argumentProps )

    Object.assign( adsr, props )

    const graph = g.adsr( 
      attack, decay, sustain, sustainLevel, release, 
      { triggerRelease: props.triggerRelease, shape:props.shape, alpha:props.alpha } 
    )

    adsr.trigger = graph.trigger
    adsr.advance = graph.release

    const __out = Gibberish.factory( adsr, graph, ['envelopes','ADSR'], props )

    return __out 
  }

  ADSR.defaults = { 
    attack:22050, 
    decay:22050, 
    sustain:44100, 
    sustainLevel:.6, 
    release: 44100, 
    triggerRelease:false,
    shape:'exponential',
    alpha:5 
  } 

  return ADSR
}

},{"../ugen.js":210,"genish.js":51}],146:[function(require,module,exports){
const g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const Envelopes = {
    AD     : require( './ad.js' )( Gibberish ),
    ADSR   : require( './adsr.js' )( Gibberish ),
    Ramp   : require( './ramp.js' )( Gibberish ),

    export : target => {
      for( let key in Envelopes ) {
        if( key !== 'export' && key !== 'factory' ) {
          target[ key ] = Envelopes[ key ]
        }
      }
    },

    factory( useADSR, shape, attack, decay, sustain, sustainLevel, release, triggerRelease=false ) {
      let env

      // deliberate use of single = to accomodate both 1 and true
      if( useADSR != true ) {
        env = g.ad( attack, decay, { shape }) 
      }else {
        env = g.adsr( attack, decay, sustain, sustainLevel, release, { shape, triggerRelease })
        env.advance = env.release
      }

      return env
    }
  } 

  return Envelopes
}

},{"./ad.js":144,"./adsr.js":145,"./ramp.js":147,"genish.js":51}],147:[function(require,module,exports){
const ugen = require( '../ugen.js' ),
      g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  const Ramp = function( argumentProps ) {
    const ramp   = Object.create( ugen ),
          length = g.in( 'length' ),
          from   = g.in( 'from' ),
          to     = g.in( 'to' )

    const props = Object.assign({}, Ramp.defaults, argumentProps )

    const reset = g.bang()

    const phase = g.accum( g.div( 1, length ), reset, { shouldWrap:props.shouldLoop, shouldClamp:true }),
          diff = g.sub( to, from ),
          graph = g.add( from, g.mul( phase, diff ) )
        
    ramp.trigger = reset.trigger

    const out = Gibberish.factory( ramp, graph, ['envelopes','ramp'], props )


    return out
  }

  Ramp.defaults = { from:0, to:1, length:g.gen.samplerate, shouldLoop:false }

  return Ramp

}

},{"../ugen.js":210,"genish.js":51}],148:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./realm.js":150,"dup":39}],149:[function(require,module,exports){
/*
 * https://github.com/antimatter15/heapqueue.js/blob/master/heapqueue.js
 *
 * This implementation is very loosely based off js-priority-queue
 * by Adam Hooper from https://github.com/adamhooper/js-priority-queue
 *
 * The js-priority-queue implementation seemed a teensy bit bloated
 * with its require.js dependency and multiple storage strategies
 * when all but one were strongly discouraged. So here is a kind of
 * condensed version of the functionality with only the features that
 * I particularly needed.
 *
 * Using it is pretty simple, you just create an instance of HeapQueue
 * while optionally specifying a comparator as the argument:
 *
 * var heapq = new HeapQueue();
 *
 * //IF NEGATIVE, RETURN A
 *
 * var customq = new HeapQueue(function(a, b){
 *   // if b > a, return negative
 *   // means that it spits out the smallest item first
 *   return a - b;
 * });
 *
 * Note that in this case, the default comparator is identical to
 * the comparator which is used explicitly in the second queue.
 *
 * Once you've initialized the heapqueue, you can plop some new
 * elements into the queue with the push method (vaguely reminiscent
 * of typical javascript arays)
 *
 * heapq.push(42);
 * heapq.push("kitten");
 *
 * The push method returns the new number of elements of the queue.
 *
 * You can push anything you'd like onto the queue, so long as your
 * comparator function is capable of handling it. The default
 * comparator is really stupid so it won't be able to handle anything
 * other than an number by default.
 *
 * You can preview the smallest item by using peek.
 *
 * heapq.push(-9999);
 * heapq.peek(); // ==> -9999
 *
 * The useful complement to to the push method is the pop method,
 * which returns the smallest item and then removes it from the
 * queue.
 *
 * heapq.push(1);
 * heapq.push(2);
 * heapq.push(3);
 * heapq.pop(); // ==> 1
 * heapq.pop(); // ==> 2
 * heapq.pop(); // ==> 3
 */
const HeapQueue = function(cmp){
  this.cmp = (cmp || function(a, b){ return a - b; });
  this.length = 0;
  this.data = [];
}
HeapQueue.prototype.peek = function(){
  return this.data[0];
};
HeapQueue.prototype.push = function(value){
  this.data.push(value);

  var pos = this.data.length - 1,
  parent, x;

  while(pos > 0){
    parent = (pos - 1) >>> 1;
    if(this.cmp(this.data[pos], this.data[parent]) < 0){
      x = this.data[parent];
      this.data[parent] = this.data[pos];
      this.data[pos] = x;
      pos = parent;
    }else break;
  }
  return this.length++;
};
HeapQueue.prototype.pop = function(){
  var last_val = this.data.pop(),
  ret = this.data[0];
  if(this.data.length > 0){
    this.data[0] = last_val;
    var pos = 0,
    last = this.data.length - 1,
    left, right, minIndex, x;
    while(1){
      left = (pos << 1) + 1;
      right = left + 1;
      minIndex = pos;
      if(left <= last && this.cmp(this.data[left], this.data[minIndex]) < 0) minIndex = left;
      if(right <= last && this.cmp(this.data[right], this.data[minIndex]) < 0) minIndex = right;
      if(minIndex !== pos){
        x = this.data[minIndex];
        this.data[minIndex] = this.data[pos];
        this.data[pos] = x;
        pos = minIndex;
      }else break;
    }
  } else {
    ret = last_val;
  }
  this.length--;
  return ret;
};

module.exports = HeapQueue

},{}],150:[function(require,module,exports){

/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = function Realm (scope, parentElement) {
  const frame = document.createElement('iframe');
  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';
  parentElement.appendChild(frame);
  const win = frame.contentWindow;
  const doc = win.document;
  let vars = 'var window,$hook';
  for (const i in win) {
    if (!(i in scope) && i !== 'eval') {
      vars += ',';
      vars += i;
    }
  }
  for (const i in scope) {
    vars += ',';
    vars += i;
    vars += '=self.';
    vars += i;
  }
  const script = doc.createElement('script');
  script.appendChild(doc.createTextNode(
    `function $hook(self,console) {"use strict";
        ${vars};return function() {return eval(arguments[0])}}`
  ));
  doc.body.appendChild(script);
  this.exec = win.$hook.call(scope, scope, console);
}

},{}],151:[function(require,module,exports){
const __proxy = require( './workletProxy.js' )
const effectProto = require( './fx/effect.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )
  
  const factory = function( ugen, graph, __name, values, cb=null, shouldProxy = true ) {
    if( Gibberish.mode === 'processor' )
      ugen.callback = cb === null ? Gibberish.genish.gen.createCallback( graph, Gibberish.memory, false, true ) : cb
    else
      ugen.callback = { out:[] }

    let name = Array.isArray( __name ) ? __name[ __name.length - 1 ] : __name

    Object.assign( ugen, {
      //type: 'ugen',
      id: values.id || Gibberish.utilities.getUID(), 
      ugenName: name + '_',
      graph: graph,
      inputNames: ugen.inputNames || new Set( Gibberish.genish.gen.parameters ),
      isStereo: Array.isArray( graph ),
      dirty: true,
      __properties__:values,
      __addresses__:{}
    })

    ugen.ugenName += ugen.id
    if( Gibberish.mode === 'processor' ) {
      ugen.callback.ugenName = ugen.ugenName // XXX hacky
      ugen.callback.id = ugen.id
    }

    //console.log( 'ugen name/id:', ugen.ugenName, ugen.id )
    //console.log( 'callback name/id:', ugen.callback.ugenName, ugen.callback.id )

    for( let param of ugen.inputNames ) {
      if( param === 'memory' ) continue

      let value = values[ param ],
          isNumber = typeof value === 'object' || isNaN( value ) ? false : true,
          idx

      if( isNumber ) { 
        idx = Gibberish.memory.alloc( 1 )
        Gibberish.memory.heap[ idx ] = value
        ugen.__addresses__[ param ] = idx
      }

      // TODO: do we need to check for a setter?
      let desc = Object.getOwnPropertyDescriptor( ugen, param ),
          setter

      if( desc !== undefined ) {
        setter = desc.set
      }

      Object.defineProperty( ugen, param, {
        configurable:true,
        get() { 
          if( isNumber ) {
            return Gibberish.memory.heap[ idx ]
          }else{
            return value 
          }
        },
        set( v ) {
          //if( param === 'input' ) console.log( 'INPUT:', v, isNumber )
          if( value !== v ) {
            if( setter !== undefined ) setter( v )
            if( typeof v === 'number' ) {
              Gibberish.memory.heap[ idx ] = value = v
              if( isNumber === false ) Gibberish.dirty( ugen )
              isNumber = true
            }else{
              value = v
              /*if( isNumber === true )*/ Gibberish.dirty( ugen )
              //console.log( 'switching from number:', param, value )
              isNumber = false
            }
          }
        }
      })
    }

    // add bypass 
    if( effectProto.isPrototypeOf( ugen ) ) {
      let value = ugen.bypass
      Object.defineProperty( ugen, 'bypass', {
        configurable:true,
        get() { return value },
        set( v ) {
          if( value !== v ) {
            Gibberish.dirty( ugen )
            value = v
          }
        }
      })

    }

    if( ugen.__requiresRecompilation !== undefined ) {
      ugen.__requiresRecompilation.forEach( prop => {
        let value = values[ prop ]
        let isNumber = !isNaN( value )

        Object.defineProperty( ugen, prop, {
          configurable:true,
          get() { 
            if( isNumber ) {
              let idx = ugen.__addresses__[ prop ]
              return Gibberish.memory.heap[ idx ]
            }else{
              //console.log( 'returning:', prop, value, Gibberish.mode )
              return value 
            }
          },
          set( v ) {
            if( value !== v ) {
              if( typeof v === 'number' ) {
                let idx = ugen.__addresses__[ prop ]
                if( idx === undefined ){
                  idx = Gibberish.memory.alloc( 1 )
                  ugen.__addresses__[ prop ] = idx
                }
                value = values[ prop ] = Gibberish.memory.heap[ idx ] = v
                isNumber = true
              }else{
                value = values[ prop ] = v
                isNumber = false
                //console.log( 'setting ugen', value, Gibberish.mode )
                Gibberish.dirty( ugen )
              }

              //console.log( 'SETTING REDO GRAPH', prop, Gibberish.mode )
              
              // needed for filterType at the very least, becauae the props
              // are reused when re-creating the graph. This seems like a cheaper
              // way to solve this problem.
              //values[ prop ] = v

              this.__redoGraph()
            }
          }
        })
      })
    }

    // will only create proxy if worklets are being used
    // otherwise will return unaltered ugen

    if( values.shouldAddToUgen === true ) Object.assign( ugen, values )

    return shouldProxy ? proxy( __name, values, ugen ) : ugen
  }

  factory.getUID = () => { return Gibberish.utilities.getUID() }

  return factory
}

},{"./fx/effect.js":166,"./workletProxy.js":212}],152:[function(require,module,exports){
let g = require( 'genish.js' )
 
// constructor for schroeder allpass filters
let allPass = function( _input, length=500, feedback=.5 ) {
  let index  = g.counter( 1,0,length ),
      buffer = g.data( length ),
      bufferSample = g.peek( buffer, index, { interp:'none', mode:'samples' }),
      out = g.memo( g.add( g.mul( -1, _input), bufferSample ) )
                
  g.poke( buffer, g.add( _input, g.mul( bufferSample, feedback ) ), index )
 
  return out
}

module.exports = allPass

},{"genish.js":51}],153:[function(require,module,exports){
let g = require( 'genish.js' ),
    filter = require( './filter.js' )

module.exports = function( Gibberish ) {

  const genish = g
  Gibberish.genish.biquad = ( input, __cutoff, __Q, mode, isStereo ) => {
    'use jsdsp'
    let in1a0,x0a1,x1a2,y0b0,y1b1,
        in1a0_r,x0a1_r,x1a2_r,y0b0_r,y1b1_r,
        c

    let returnValue
    
    const x = genish.data([ 0,0 ], 1, { meta:true })
    const y = genish.data([ 0,0 ], 1, { meta:true })
    const a = genish.data([ 0,0,0 ], 1, { meta:true })
    const b = genish.data([ 0,0 ], 1, { meta:true })
    
    const Q = g.min( .5 + __Q * 22, 22.5 ) 
    const cutoff = g.max( .005, g.min( __cutoff,.995 ) ) * g.gen.samplerate / 4 
    //let w0 = g.memo( g.mul( 2 * Math.PI, g.div( g.max(.005, g.min(cutoff,.995)),  g.gen.samplerate ) ) ),
    let w0 =  (2 * Math.PI) * (cutoff / g.gen.samplerate),
        sinw0 = g.sin( w0 ),
        cosw0 = g.cos( w0 ),
        alpha = sinw0 / ( 2 * Q )

    //let w0 = g.memo( g.mul( 2 * Math.PI, g.div( cutoff,  g.gen.samplerate ) ) ),
      
    let oneMinusCosW = 1 - cosw0

    /******** process coefficients ********/
    switch( mode ) {
      case 1:
        a[0] = (1 + cosw0) / 2
        a[1] = (1 + cosw0) * -1
        a[2] = a[0]
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
        break;
      case 2:
        a[0] = Q * alpha
        a[1] = 0
        a[2] = a[0] * -1
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
        break;
      default: // LP
        a[0] = oneMinusCosW / 2
        a[1] = oneMinusCosW
        a[2] = a[0]
        c    = 1 + alpha
        b[0] = -2 * cosw0
        b[1] = 1 - alpha
    }

    a[0] = a[0] / c; a[1] = a[1] / c; a[2] = a[2] / c
    b[0] = b[0] / c; b[1] = b[1] / c

    /******** end coefficients ********/

    /****** left / mono output ********/

    let l = isStereo === true ? input[0] : input
    in1a0 = l * a[0]
    x0a1  = x[0] * a[1]
    x1a2  = x[1] * a[2]

    x[1] = x[0] 
    x[0] = l

    let sumLeft = in1a0 + x0a1 + x1a2

    y0b0 = y[0] * b[0]
    y1b1 = y[1] * b[1]
    y[1] = y[0] 

    let sumRight = y0b0 + y1b1

    let diff = sumLeft - sumRight

    y[0] = diff
    
    /******** end left/mono **********/

    if( isStereo ) {
      const xr = genish.data([ 0,0 ], 1, { meta:true })
      const yr = genish.data([ 0,0 ], 1, { meta:true })
      //let x1_1 = g.history(), x2_1 = g.history(), y1_1 = g.history(), y2_1 = g.history()

      const r = input[1] 
      in1a0_r = r * a[0] //g.mul( x1_1.in( input[1] ), a0 )
      x0a1_r  = xr[0] * a[1]//g.mul( x2_1.in( x1_1.out ), a1 )
      x1a2_r  = xr[1] * a[2]//g.mul( x2_1.out,            a2 )

      xr[1]   = xr[0]
      xr[0] = r

      const sumLeft_r = in1a0_r + x0a1_r + x1a2_r

      y0b0_r = yr[0] * b[0]//g.mul( y2_1.in( y1_1.out ), b1 )
      y1b1_r = yr[1] * b[1]//g.mul( y2_1.out, b2 )
      yr[1] = yr[0]

      const sumRight_r = y0b0_r + y1b1_r

      const diff_r = sumLeft_r - sumRight_r

      yr[0] = diff_r
      
      returnValue = [ diff, diff_r ]
    }else{
      returnValue = diff
    }

    return returnValue
  }

  let Biquad = inputProps => {
    const biquad = Object.create( filter )
    const props = Object.assign( {}, Biquad.defaults, inputProps ) 
    let __out

    Object.assign( biquad, props )

    biquad.__createGraph = function() {
      let isStereo = false
      if( __out === undefined ) {
        isStereo = props.input !== undefined && props.input.isStereo !== undefined ? props.input.isStereo : false 
      }else{
        isStereo = __out.input.isStereo
        __out.isStereo = isStereo
      }
      biquad.graph = Gibberish.genish.biquad( g.in('input'), g.in('cutoff'),  g.in('Q'), biquad.mode, isStereo )
    }

    biquad.__createGraph()
    biquad.__requiresRecompilation = [ 'mode', 'input' ]

    __out = Gibberish.factory(
      biquad,
      biquad.graph,
      ['filters','Filter12Biquad'], 
      props
    )

    return __out
  }

  Biquad.defaults = {
    input:0,
    Q: .15,
    cutoff:.05,
    mode:0
  }

  return Biquad

}


},{"./filter.js":156,"genish.js":51}],154:[function(require,module,exports){
let g = require( 'genish.js' )

let combFilter = function( _input, combLength, damping=.5*.4, feedbackCoeff=.84 ) {
  let lastSample   = g.history(),
  	  readWriteIdx = g.counter( 1,0,combLength ),
      combBuffer   = g.data( combLength ),
	    out          = g.peek( combBuffer, readWriteIdx, { interp:'none', mode:'samples' }),
      storeInput   = g.memo( g.add( g.mul( out, g.sub( 1, damping)), g.mul( lastSample.out, damping ) ) )
      
  lastSample.in( storeInput )
 
  g.poke( combBuffer, g.add( _input, g.mul( storeInput, feedbackCoeff ) ), readWriteIdx )
 
  return out
}

module.exports = combFilter

},{"genish.js":51}],155:[function(require,module,exports){
const g = require( 'genish.js' ),
      filter = require( './filter.js' )

const genish = g
module.exports = function( Gibberish ) {
  Gibberish.genish.diodeZDF = ( input, __Q, __freq, saturation, isStereo=false ) => {
    const iT = 1 / g.gen.samplerate,
          kz1 = g.history(0),
          kz2 = g.history(0),
          kz3 = g.history(0),
          kz4 = g.history(0)

    let   ka1 = 1.0,
          ka2 = 0.5,
          ka3 = 0.5,
          ka4 = 0.5,
          kindx = 0   

    const freq = g.mul( g.max(.005, g.min( __freq, .995)),  genish.gen.samplerate / 2 )
    //const freq = g.max(.005, g.min( __freq, .995))

    // XXX this is where the magic number hapens for Q...
    const Q = g.memo( g.add( .5, g.mul( __Q, g.add( 5, g.sub( 5, g.mul( g.div( freq, 20000  ), 5 ) ) ) ) ) )
    // kwd = 2 * $M_PI * acf[kindx]
    const kwd = g.memo( g.mul( Math.PI * 2, freq ) )

    // kwa = (2/iT) * tan(kwd * iT/2) 
    const kwa =g.memo( g.mul( 2/iT, g.tan( g.mul( kwd, iT/2 ) ) ) )

    // kG  = kwa * iT/2 
    const kg = g.memo( g.mul( kwa, iT/2 ) )
    
    const kG4 = g.memo( g.mul( .5, g.div( kg, g.add( 1, kg ) ) ) )
    const kG3 = g.memo( g.mul( .5, g.div( kg, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG4 ) ) ) ) )
    const kG2 = g.memo( g.mul( .5, g.div( kg, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG3 ) ) ) ) )
    const kG1 = g.memo( g.div( kg, g.sub( g.add( 1, kg ), g.mul( kg, kG2 ) ) ) )

    const kGAMMA = g.memo( g.mul( g.mul( kG4, kG3 ) , g.mul( kG2, kG1 ) ) )

    const kSG1 = g.memo( g.mul( g.mul( kG4, kG3 ), kG2 ) ) 

    const kSG2 = g.memo( g.mul( kG4, kG3) )  
    const kSG3 = kG4 
    let kSG4 = 1.0 
    // kk = 4.0*(kQ - 0.5)/(25.0 - 0.5)
    const kalpha = g.memo( g.div( kg, g.add(1.0, kg) ) )

    const kbeta1 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( kg, kG2 ) ) ) )
    const kbeta2 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG3 ) ) ) )
    const kbeta3 = g.memo( g.div( 1.0, g.sub( g.add( 1, kg ), g.mul( g.mul( .5, kg ), kG4 ) ) ) )
    const kbeta4 = g.memo( g.div( 1.0, g.add( 1, kg ) ) ) 

    const kgamma1 = g.memo( g.add( 1, g.mul( kG1, kG2 ) ) )
    const kgamma2 = g.memo( g.add( 1, g.mul( kG2, kG3 ) ) )
    const kgamma3 = g.memo( g.add( 1, g.mul( kG3, kG4 ) ) )

    const kdelta1 = kg
    const kdelta2 = g.memo( g.mul( 0.5, kg ) )
    const kdelta3 = g.memo( g.mul( 0.5, kg ) )

    const kepsilon1 = kG2
    const kepsilon2 = kG3
    const kepsilon3 = kG4

    const klastcut = freq

    //;; feedback inputs 
    const kfb4 = g.memo( g.mul( kbeta4 , kz4.out ) ) 
    const kfb3 = g.memo( g.mul( kbeta3, g.add( kz3.out, g.mul( kfb4, kdelta3 ) ) ) )
    const kfb2 = g.memo( g.mul( kbeta2, g.add( kz2.out, g.mul( kfb3, kdelta2 ) ) ) )

    //;; feedback process

    const kfbo1 = g.memo( g.mul( kbeta1, g.add( kz1.out, g.mul( kfb2, kdelta1 ) ) ) ) 
    const kfbo2 = g.memo( g.mul( kbeta2, g.add( kz2.out, g.mul( kfb3, kdelta2 ) ) ) ) 
    const kfbo3 = g.memo( g.mul( kbeta3, g.add( kz3.out, g.mul( kfb4, kdelta3 ) ) ) ) 
    const kfbo4 = kfb4

    const kSIGMA = g.memo( 
      g.add( 
        g.add( 
          g.mul( kSG1, kfbo1 ), 
          g.mul( kSG2, kfbo2 )
        ), 
        g.add(
          g.mul( kSG3, kfbo3 ), 
          g.mul( kSG4, kfbo4 )
        ) 
      ) 
    )

    //const kSIGMA = 1
    //;; non-linear processing
    //if (knlp == 1) then
    //  kin = (1.0 / tanh(ksaturation)) * tanh(ksaturation * kin)
    //elseif (knlp == 2) then
    //  kin = tanh(ksaturation * kin) 
    //endif
    //
    //const kin = input 
    let kin = isStereo === true ? g.add( input[0], input[1] ) : input//g.memo( g.mul( g.div( 1, g.tanh( saturation ) ), g.tanh( g.mul( saturation, input ) ) ) )
    kin = g.tanh( g.mul( saturation, kin ) )

    const kun = g.div( g.sub( kin, g.mul( Q, kSIGMA ) ), g.add( 1, g.mul( Q, kGAMMA ) ) )
    //const kun = g.div( 1, g.add( 1, g.mul( Q, kGAMMA ) ) )
        //(kin - kk * kSIGMA) / (1.0 + kk * kGAMMA)

    //;; 1st stage
    let kxin = g.memo( g.add( g.add( g.mul( kun, kgamma1 ), kfb2), g.mul( kepsilon1, kfbo1 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    let kv = g.memo( g.mul( g.sub( g.mul( ka1, kxin ), kz1.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    let klp = g.add( kv, kz1.out )
    //klp = kv + kz1
    kz1.in( g.add( klp, kv ) ) 
    //kz1 = klp + kv

        //;; 2nd stage
    //kxin = (klp * kgamma2 + kfb3 + kepsilon2 * kfbo2)
    //kv = (ka2 * kxin - kz2) * kalpha 
    //klp = kv + kz2
    //kz2 = klp + kv

    kxin = g.memo( g.add( g.add( g.mul( klp, kgamma2 ), kfb3), g.mul( kepsilon2, kfbo2 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka2, kxin ), kz2.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz2.out ) 
    //klp = kv + kz1
    kz2.in( g.add( klp, kv ) ) 
    //kz1 = klp + kv

    //;; 3rd stage
    //kxin = (klp * kgamma3 + kfb4 + kepsilon3 * kfbo3)
    //kv = (ka3 * kxin - kz3) * kalpha 
    //klp = kv + kz3
    //kz3 = klp + kv

    kxin = g.memo( g.add( g.add( g.mul( klp, kgamma3 ), kfb4), g.mul( kepsilon3, kfbo3 ) ) )
    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka3, kxin ), kz3.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz3.out )
    //klp = kv + kz1
    kz3.in( g.add( klp, kv ) )
    //kz1 = klp + kv

    //;; 4th stage
    //kv = (ka4 * klp - kz4) * kalpha 
    //klp = kv + kz4
    //kz4 = klp + kv

    // (kun * kgamma1 + kfb2 + kepsilon1 * kfbo1)
    kv = g.memo( g.mul( g.sub( g.mul( ka4, kxin ), kz4.out ), kalpha ) )
    //kv = (ka1 * kxin - kz1) * kalpha 
    klp = g.add( kv, kz4.out )
    //klp = kv + kz1
    kz4.in( g.add( klp, kv ) )

    //kz1 = klp + kv
    if( isStereo ) {
      //let polesR = g.data([ 0,0,0,0 ], 1, { meta:true }),
      //    rezzR = g.clamp( g.mul( polesR[3], rez ) ),
      //    outputR = g.sub( input[1], rezzR )         

      //polesR[0] = g.add( polesR[0], g.mul( g.add( g.mul(-1, polesR[0] ), outputR   ), cutoff ))
      //polesR[1] = g.add( polesR[1], g.mul( g.add( g.mul(-1, polesR[1] ), polesR[0] ), cutoff ))
      //polesR[2] = g.add( polesR[2], g.mul( g.add( g.mul(-1, polesR[2] ), polesR[1] ), cutoff ))
      //polesR[3] = g.add( polesR[3], g.mul( g.add( g.mul(-1, polesR[3] ), polesR[2] ), cutoff ))

      //let right = g.switch( isLowPass, polesR[3], g.sub( outputR, polesR[3] ) )

      //returnValue = [left, right]
    }else{
     // returnValue = klp
    }
    //returnValue = klp
    
    return klp
 }

  const DiodeZDF = inputProps => {
    const zdf      = Object.create( filter )
    const props    = Object.assign( {}, DiodeZDF.defaults, filter.defaults, inputProps )
    const isStereo = props.input.isStereo 

    Object.assign( zdf, props )

    const __out = Gibberish.factory(
      zdf, 
      Gibberish.genish.diodeZDF( g.in('input'), g.in('Q'), g.in('cutoff'), g.in('saturation'), isStereo ), 
      ['filters','Filter24TB303'],
      props
    )

    return __out 
  }

  DiodeZDF.defaults = {
    input:0,
    Q: .65,
    saturation: 1,
    cutoff:.5 
  }

  return DiodeZDF

}

},{"./filter.js":156,"genish.js":51}],156:[function(require,module,exports){
let ugen = require( '../ugen.js' )()

let filter = Object.create( ugen )

Object.assign( filter, {
  defaults: { bypass:false } 
})

module.exports = filter

},{"../ugen.js":210}],157:[function(require,module,exports){
let g = require( 'genish.js' ),
    filter = require( './filter.js' )

module.exports = function( Gibberish ) {

  Gibberish.genish.filter24 = ( input, _rez, _cutoff, isLowPass, isStereo=false ) => {
    let returnValue,
        polesL = g.data([ 0,0,0,0 ], 1, { meta:true }),
        peekProps = { interp:'none', mode:'simple' },
        rez = g.memo( g.mul( _rez, 5 ) ),
        cutoff = g.memo( g.div( _cutoff, 11025 ) ),
        rezzL = g.clamp( g.mul( polesL[3], rez ) ),
        outputL = g.sub( isStereo ? input[0] : input, rezzL ) 

    polesL[0] = g.add( polesL[0], g.mul( g.add( g.mul(-1, polesL[0] ), outputL   ), cutoff ))
    polesL[1] = g.add( polesL[1], g.mul( g.add( g.mul(-1, polesL[1] ), polesL[0] ), cutoff ))
    polesL[2] = g.add( polesL[2], g.mul( g.add( g.mul(-1, polesL[2] ), polesL[1] ), cutoff ))
    polesL[3] = g.add( polesL[3], g.mul( g.add( g.mul(-1, polesL[3] ), polesL[2] ), cutoff ))
    
    let left = g.switch( isLowPass, polesL[3], g.sub( outputL, polesL[3] ) )

    if( isStereo ) {
      let polesR = g.data([ 0,0,0,0 ], 1, { meta:true }),
          rezzR = g.clamp( g.mul( polesR[3], rez ) ),
          outputR = g.sub( input[1], rezzR )         

      polesR[0] = g.add( polesR[0], g.mul( g.add( g.mul(-1, polesR[0] ), outputR   ), cutoff ))
      polesR[1] = g.add( polesR[1], g.mul( g.add( g.mul(-1, polesR[1] ), polesR[0] ), cutoff ))
      polesR[2] = g.add( polesR[2], g.mul( g.add( g.mul(-1, polesR[2] ), polesR[1] ), cutoff ))
      polesR[3] = g.add( polesR[3], g.mul( g.add( g.mul(-1, polesR[3] ), polesR[2] ), cutoff ))

      let right = g.switch( isLowPass, polesR[3], g.sub( outputR, polesR[3] ) )

      returnValue = [left, right]
    }else{
      returnValue = left
    }

    return returnValue
  }

  let Filter24 = inputProps => {
    let filter24   = Object.create( filter )
    let props    = Object.assign( {}, Filter24.defaults, filter.defaults, inputProps )
    let isStereo = props.input.isStereo 

    const __out = Gibberish.factory(
      filter24, 
      Gibberish.genish.filter24( g.in('input'), g.in('Q'), g.in('cutoff'), g.in('isLowPass'), isStereo ), 
      ['filters','Filter24Classic'],
      props
    )

    return __out
  }


  Filter24.defaults = {
    input:0,
    Q: .25,
    cutoff: 880,
    isLowPass:1
  }

  return Filter24

}


},{"./filter.js":156,"genish.js":51}],158:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const g = Gibberish.genish

  const filters = {
    Filter24Classic : require( './filter24.js'  )( Gibberish ),
    Filter24Moog    : require( './ladder.dsp.js' )( Gibberish ),
    Filter24TB303   : require( './diodeFilterZDF.js' )( Gibberish ),
    Filter12Biquad  : require( './biquad.dsp.js'    )( Gibberish ),
    Filter12SVF     : require( './svf.js'       )( Gibberish ),
    
    // not for use by end-users
    genish: {
      Comb        : require( './combfilter.js' ),
      AllPass     : require( './allpass.js' )
    },

    factory( input, cutoff, saturation, _props, isStereo = false ) {
      let filteredOsc 

      let props = Object.assign({}, filters.defaults, _props )

      switch( props.filterModel ) {
        case 1:
          filteredOsc = g.zd24( input, g.min( g.in('Q'), .9999 ), cutoff, 0 ) // g.max(.005, g.min( cutoff, 1 ) ) )
          break;
        case 2:
          filteredOsc = g.diodeZDF( input, g.min( g.in('Q'), .9999 ), cutoff, saturation, isStereo ) 
          break;
        case 3:
          filteredOsc = g.svf( input, cutoff, g.sub( 1, g.in('Q')), props.filterMode, isStereo, true ) 
          break; 
        case 4:
          filteredOsc = g.biquad( input, cutoff,  g.in('Q'), props.filterMode, isStereo ) 
          break; 
        case 5:
          //isLowPass = g.param( 'lowPass', 1 ),
          filteredOsc = g.filter24( input, g.in('Q'), cutoff, props.filterMode, isStereo )
          break;
        default:
          // return unfiltered signal
          filteredOsc = input //g.filter24( oscWithGain, g.in('resonance'), cutoff, isLowPass )
          break;
      }

      return filteredOsc
    },

    defaults: { filterMode: 0, filterModel:0 }
  }

  filters.export = target => {
    for( let key in filters ) {
      if( key !== 'export' && key !== 'genish' ) {
        target[ key ] = filters[ key ]
      }
    }
  }

return filters

}

},{"./allpass.js":152,"./biquad.dsp.js":153,"./combfilter.js":154,"./diodeFilterZDF.js":155,"./filter24.js":157,"./ladder.dsp.js":159,"./svf.js":160}],159:[function(require,module,exports){
const genish = require( 'genish.js' ),
      filterProto = require( './filter.js' )

module.exports = function( Gibberish ) {

  const makeChannel = function( input, _Q, _freq ) {
    'use jsdsp'
    const iT = 1 / genish.gen.samplerate,
          z  = genish.data([ 0,0,0,0 ], 1, { meta:true })

    const freq = genish.max(.005, genish.min( _freq, 1 ) ) 
    const Q = .5 + _Q * 23
    // kwd = 2 * $M_PI * acf[kindx]
    const kwd = ( Math.PI * 2 ) * freq * genish.gen.samplerate / 2

    // kwa = (2/iT) * tan(kwd * iT/2) 
    const kwa = 2/iT * genish.tan( kwd * iT/2 )

    // kG  = kwa * iT/2 
    const kg = kwa * iT/2

    // kk = 4.0*(kQ - 0.5)/(25.0 - 0.5)
    const kk = 4 * (Q - .5) / 24.5

    // kg_plus_1 = (1.0 + kg)
    const kg_plus_1 = 1 + kg

    // kG = kg / kg_plus_1 
    const kG     = kg / kg_plus_1,
          kG_2   = kG * kG,
          kG_3   = kG_2 * kG,
          kGAMMA = kG_2 * kG_2

    const kS1 = z[0] / kg_plus_1,
          kS2 = z[1] / kg_plus_1,
          kS3 = z[2] / kg_plus_1,
          kS4 = z[3] / kg_plus_1

    //kS = kG_3 * kS1  + kG_2 * kS2 + kG * kS3 + kS4 
    const kS = kG_3 * kS1 + kG_2 * kS2 + kG * kS3 + kS4

    //ku = (kin - kk *  kS) / (1 + kk * kGAMMA)
    const ku  = (input - kk * kS) / (1 + kk * kGAMMA)

    let kv =  ( ku - z[0] ) * kG
    let klp = kv + z[0]
    z[0] = klp + kv

    kv  = ( klp - z[1] ) * kG
    klp = kv + z[1]
    z[1] = klp + kv

    kv  = (klp - z[2] ) * kG
    klp = kv + z[2]
    z[2] = klp + kv

    kv  = (klp - z[3] ) * kG
    klp = kv + z[3]
    z[3] = klp + kv

    return klp
  }

  Gibberish.genish.zd24 = ( input, _Q, freq, isStereo=false ) => {
    const leftInput = isStereo === true ? input[0] : input
    const left = makeChannel( leftInput, _Q, freq )

    let out
    if( isStereo === true ) {
      const right = makeChannel( input[1], _Q, freq )
      out = [ left, right ]
    }else{
      out = left
    }

    return out
  }

  const Zd24 = inputProps => {
    const filter   = Object.create( filterProto )
    const props    = Object.assign( {}, Zd24.defaults, filter.defaults, inputProps )
    let out

    filter.__requiresRecompilation = [ 'input' ]
    filter.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = props.input !== undefined && props.input.isStereo !== undefined ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      filter.graph = Gibberish.genish.zd24( genish.in('input'), genish.in('Q'), genish.in('cutoff'), isStereo ) 
    } 

    filter.__createGraph()

    out = Gibberish.factory(
      filter, 
      filter.graph, 
      ['filters','Filter24Moog'],
      props
    )

    return out
  }

  Zd24.defaults = {
    input:0,
    Q: .75,
    cutoff: .25,
  }

  return Zd24

}


},{"./filter.js":156,"genish.js":51}],160:[function(require,module,exports){
const g = require( 'genish.js' ),
      filter = require( './filter.js' )

module.exports = function( Gibberish ) {
  Gibberish.genish.svf = ( input, cutoff, Q, mode, isStereo=false, shouldConvertFreqQ=false ) => {
    let d1 = g.data([0,0], 1, { meta:true }), d2 = g.data([0,0], 1, { meta:true }),
        peekProps = { mode:'simple', interp:'none' }

    if( shouldConvertFreqQ === true ) {
      //Q = g.min( g.add(.01 , __Q), 1 ) 
      cutoff = g.mul( g.max( .005, g.min( cutoff,.995 ) ), g.div( g.gen.samplerate, 4 ) )
    }

    let f1 = g.memo( g.mul( 2 * Math.PI, g.div( cutoff, g.gen.samplerate ) ) )
    let oneOverQ = g.memo( g.div( 1, Q ) )
    let l = g.memo( g.add( d2[0], g.mul( f1, d1[0] ) ) ),
        h = g.memo( g.sub( g.sub( isStereo ? input[0] : input, l ), g.mul( Q, d1[0] ) ) ),
        b = g.memo( g.add( g.mul( f1, h ), d1[0] ) ),
        n = g.memo( g.add( h, l ) )

    d1[0] = b
    d2[0] = l

    let out = g.selector( mode, l, h, b, n )

    let returnValue
    if( isStereo ) {
      let d12 = g.data([0,0], 1, { meta:true }), d22 = g.data([0,0], 1, { meta:true })
      let l2 = g.memo( g.add( d22[0], g.mul( f1, d12[0] ) ) ),
          h2 = g.memo( g.sub( g.sub( input[1], l2 ), g.mul( Q, d12[0] ) ) ),
          b2 = g.memo( g.add( g.mul( f1, h2 ), d12[0] ) ),
          n2 = g.memo( g.add( h2, l2 ) )

      d12[0] = b2
      d22[0] = l2

      let out2 = g.selector( mode, l2, h2, b2, n2 )

      returnValue = [ out, out2 ]
    }else{
      returnValue = out
    }

    return returnValue
  }

  let SVF = inputProps => {
    const svf = Object.create( filter )
    const props = Object.assign( {}, SVF.defaults, filter.defaults, inputProps ) 

    const isStereo = props.input.isStereo
    
    // XXX NEEDS REFACTORING
    const __out = Gibberish.factory( 
      svf,
      //Gibberish.genish.svf( g.in('input'), g.mul( g.in('cutoff'), g.gen.samplerate / 5 ), g.sub( 1, g.in('Q') ), g.in('mode'), isStereo ), 
      Gibberish.genish.svf( g.in('input'), g.mul( g.in('cutoff'), g.gen.samplerate / 5 ), g.sub( 1, g.in('Q') ), g.in('mode'), isStereo, true ), 
      ['filters','Filter12SVF'], 
      props
    )

    return __out
  }


  SVF.defaults = {
    input:0,
    Q: .65,
    cutoff:.25,
    mode:0
  }

  return SVF

}


},{"./filter.js":156,"genish.js":51}],161:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let BitCrusher = inputProps => {
  const  props = Object.assign( { bitCrusherLength: 44100 }, BitCrusher.defaults, effect.defaults, inputProps ),
         bitCrusher = Object.create( effect )

  let out

  bitCrusher.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    let input = g.in( 'input' ),
        inputGain = g.in( 'inputGain' ),
        bitDepth = g.in( 'bitDepth' ),
        sampleRate = g.in( 'sampleRate' ),
        leftInput = isStereo ? input[ 0 ] : input,
        rightInput = isStereo ? input[ 1 ] : null
    
    let storeL = g.history(0)
    let sampleReduxCounter = g.counter( sampleRate, 0, 1 )

    let bitMult = g.pow( g.mul( bitDepth, 16 ), 2 )
    let crushedL = g.div( g.floor( g.mul( g.mul( leftInput, inputGain ), bitMult ) ), bitMult )

    let outL = g.switch(
      sampleReduxCounter.wrap,
      crushedL,
      storeL.out
    )

    if( isStereo ) {
      let storeR = g.history(0)
      let crushedR = g.div( g.floor( g.mul( g.mul( rightInput, inputGain ), bitMult ) ), bitMult )

      let outR = g.switch( 
        sampleReduxCounter.wrap,
        crushedR,
        storeL.out
      )

      bitCrusher.graph = [ outL, outR ]
    }else{
      bitCrusher.graph = outL
    }
  }

  bitCrusher.__createGraph()
  bitCrusher.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    bitCrusher,
    bitCrusher.graph,
    ['fx','bitCrusher'], 
    props 
  )
  return out 
}

BitCrusher.defaults = {
  input:0,
  bitDepth:.5,
  sampleRate: .5
}

return BitCrusher

}

},{"./effect.js":166,"genish.js":51}],162:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
  let proto = Object.create( effect )

  let Shuffler = inputProps => {
    let bufferShuffler = Object.create( proto ),
        bufferSize = 88200

    const props = Object.assign( {}, Shuffler.defaults, effect.defaults, inputProps )
    
    let out
    bufferShuffler.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : true 
      }else{
        isStereo = out.input.isStereo
        //out.isStereo = isStereo
      }      
      
      const phase = g.accum( 1,0,{ shouldWrap: false })

      const input = g.in( 'input' ),
            inputGain = g.in( 'inputGain' ),
            __leftInput = isStereo ? input[ 0 ] : input,
            __rightInput = isStereo ? input[ 1 ] : null,
            leftInput = g.mul( __leftInput, inputGain ),
            rightInput = g.mul( __rightInput, inputGain ),
            rateOfShuffling = g.in( 'rate' ),
            chanceOfShuffling = g.in( 'chance' ),
            reverseChance = g.in( 'reverseChance' ),
            repitchChance = g.in( 'repitchChance' ),
            repitchMin = g.in( 'repitchMin' ),
            repitchMax = g.in( 'repitchMax' )

      let pitchMemory = g.history(1)

      let shouldShuffleCheck = g.eq( g.mod( phase, rateOfShuffling ), 0 )
      let isShuffling = g.memo( g.sah( g.lt( g.noise(), chanceOfShuffling ), shouldShuffleCheck, 0 ) ) 

      // if we are shuffling and on a repeat boundary...
      let shuffleChanged = g.memo( g.and( shouldShuffleCheck, isShuffling ) )
      let shouldReverse = g.lt( g.noise(), reverseChance ),
          reverseMod = g.switch( shouldReverse, -1, 1 )

      let pitch = g.ifelse( 
        g.and( shuffleChanged, g.lt( g.noise(), repitchChance ) ),
        g.memo( g.mul( g.add( repitchMin, g.mul( g.sub( repitchMax, repitchMin ), g.noise() ) ), reverseMod ) ),
        reverseMod
      )
      
      // only switch pitches on repeat boundaries
      pitchMemory.in( g.switch( shuffleChanged, pitch, pitchMemory.out ) )

      let fadeLength = g.memo( g.div( rateOfShuffling, 100 ) ),
          fadeIncr = g.memo( g.div( 1, fadeLength ) )

      const bufferL = g.data( bufferSize )
      const bufferR = isStereo ? g.data( bufferSize ) : null
      let readPhase = g.accum( pitchMemory.out, 0, { shouldWrap:false }) 
      let stutter = g.wrap( g.sub( g.mod( readPhase, bufferSize ), 22050 ), 0, bufferSize )

      let normalSample = g.peek( bufferL, g.accum( 1, 0, { max:88200 }), { mode:'simple' })

      let stutterSamplePhase = g.switch( isShuffling, stutter, g.mod( readPhase, bufferSize ) )
      let stutterSample = g.memo( g.peek( 
        bufferL, 
        stutterSamplePhase,
        { mode:'samples' }
      ) )
      
      let stutterShouldFadeIn = g.and( shuffleChanged, isShuffling )
      let stutterPhase = g.accum( 1, shuffleChanged, { shouldWrap: false })

      let fadeInAmount = g.memo( g.div( stutterPhase, fadeLength ) )
      let fadeOutAmount = g.div( g.sub( rateOfShuffling, stutterPhase ), g.sub( rateOfShuffling, fadeLength ) )
      
      let fadedStutter = g.ifelse(
        g.lt( stutterPhase, fadeLength ),
        g.memo( g.mul( g.switch( g.lt( fadeInAmount, 1 ), fadeInAmount, 1 ), stutterSample ) ),
        g.gt( stutterPhase, g.sub( rateOfShuffling, fadeLength ) ),
        g.memo( g.mul( g.gtp( fadeOutAmount, 0 ), stutterSample ) ),
        stutterSample
      )
      
      let outputL = g.mix( normalSample, fadedStutter, isShuffling ) 

      let pokeL = g.poke( bufferL, leftInput, g.mod( g.add( phase, 44100 ), 88200 ) )

      let panner = g.pan( outputL, outputL, g.in( 'pan' ) )
      
      bufferShuffler.graph = [ panner.left, panner.right ]
    }

    bufferShuffler.__createGraph()
    bufferShuffler.__requiresRecompilation = [ 'input' ]
    
    out = Gibberish.factory( 
      bufferShuffler,
      bufferShuffler.graph,
      ['fx','shuffler'], 
      props 
    )

    return out 
  }
  
  Shuffler.defaults = {
    input:0,
    rate:22050,
    chance:.25,
    reverseChance:.5,
    repitchChance:.5,
    repitchMin:.5,
    repitchMax:2,
    pan:.5,
    mix:.5
  }

  return Shuffler 
}

},{"./effect.js":166,"genish.js":51}],163:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )
  
module.exports = function( Gibberish ) {
 
let __Chorus = inputProps => {
  const props = Object.assign({}, __Chorus.defaults, effect.defaults, inputProps )
  let out
  
  const chorus = Object.create( effect )

  chorus.__createGraph = function() {
    const input = g.in('input'),
          inputGain = g.in( 'inputGain' ),
          freq1 = g.in('slowFrequency'),
          freq2 = g.in('fastFrequency'),
          amp1  = g.in('slowGain'),
          amp2  = g.in('fastGain')

    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    const win0   = g.env( 'inversewelch', 1024 ),
          win120 = g.env( 'inversewelch', 1024, 0, .333 ),
          win240 = g.env( 'inversewelch', 1024, 0, .666 )
    
    const slowPhasor = g.phasor( freq1, 0, { min:0 }),
          slowPeek1  = g.mul( g.peek( win0,   slowPhasor ), amp1 ),
          slowPeek2  = g.mul( g.peek( win120, slowPhasor ), amp1 ),
          slowPeek3  = g.mul( g.peek( win240, slowPhasor ), amp1 )
    
    const fastPhasor = g.phasor( freq2, 0, { min:0 }),
          fastPeek1  = g.mul( g.peek( win0,   fastPhasor ), amp2 ),
          fastPeek2  = g.mul( g.peek( win120, fastPhasor ), amp2 ),
          fastPeek3  = g.mul( g.peek( win240, fastPhasor ), amp2 )


    let sampleRate = Gibberish.ctx.sampleRate
     
    const ms = sampleRate / 1000 
    const maxDelayTime = 1000 * ms

    //console.log( 'sr:', sampleRate, 'ms:', ms, 'maxDelayTime:', maxDelayTime )

    const time1 =  g.mul( g.add( slowPeek1, fastPeek1, 5 ), ms ),
          time2 =  g.mul( g.add( slowPeek2, fastPeek2, 5 ), ms ),
          time3 =  g.mul( g.add( slowPeek3, fastPeek3, 5 ), ms )

    const delay1L = g.delay( leftInput, time1, { size:maxDelayTime }),
          delay2L = g.delay( leftInput, time2, { size:maxDelayTime }),
          delay3L = g.delay( leftInput, time3, { size:maxDelayTime })

    
    const leftOutput = g.add( delay1L, delay2L, delay3L )
    if( isStereo ) {
      const rightInput = g.mul( input[1], inputGain )
      const delay1R = g.delay(rightInput, time1, { size:maxDelayTime }),
            delay2R = g.delay(rightInput, time2, { size:maxDelayTime }),
            delay3R = g.delay(rightInput, time3, { size:maxDelayTime })

      // flip a couple delay lines for stereo effect?
      const rightOutput = g.add( delay1R, delay2L, delay3R )
      chorus.graph = [ g.add( delay1L, delay2R, delay3L), rightOutput ]
    }else{
      chorus.graph = leftOutput
    }
  }

  chorus.__createGraph()
  chorus.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( chorus, chorus.graph, ['fx','chorus'], props )

  return out 
}

__Chorus.defaults = {
  input:0,
  slowFrequency: .18,
  slowGain:3,
  fastFrequency:6,
  fastGain:1,
  inputGain:1
}

return __Chorus

}

},{"./effect.js":166,"genish.js":51}],164:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let Delay = inputProps => {
  let props = Object.assign( { delayLength: 88200 }, effect.defaults, Delay.defaults, inputProps ),
      delay = Object.create( effect )

  let out
  delay.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input      = g.in( 'input' ),
          inputGain  = g.in( 'inputGain' ),
          delayTime  = g.in( 'time' ),
          wetdry     = g.in( 'wetdry' ),
          leftInput  = isStereo ? g.mul( input[ 0 ], inputGain ) : g.mul( input, inputGain ),
          rightInput = isStereo ? g.mul( input[ 1 ], inputGain ) : null
      
    const feedback = g.in( 'feedback' )

    // left channel
    const feedbackHistoryL = g.history()
    const echoL = g.delay( g.add( leftInput, g.mul( feedbackHistoryL.out, feedback ) ), delayTime, { size:props.delayLength })
    feedbackHistoryL.in( echoL )
    const left = g.mix( leftInput, echoL, wetdry )

    if( isStereo ) {
      // right channel
      const feedbackHistoryR = g.history()
      const echoR = g.delay( g.add( rightInput, g.mul( feedbackHistoryR.out, feedback ) ), delayTime, { size:props.delayLength })
      feedbackHistoryR.in( echoR )
      const right = g.mix( rightInput, echoR, wetdry )

      delay.graph = [ left, right ]
    }else{
      delay.graph = left 
    }
  }

  delay.__createGraph()
  delay.__requiresRecompilation = [ 'input' ]
  
  out = Gibberish.factory( 
    delay,
    delay.graph, 
    ['fx','delay'], 
    props 
  )

  return out
}

Delay.defaults = {
  input:0,
  feedback:.5,
  time: 11025,
  wetdry: .5
}

return Delay

}

},{"./effect.js":166,"genish.js":51}],165:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

const genish = g

// taken from csound: http://manual.freeshell.org/csound5/distort1.html
/*

         exp(asig * (shape1 + pregain)) - exp(asig * (shape2 - pregain))
  aout = ---------------------------------------------------------------
         exp(asig * pregain)            + exp(-asig * pregain)

*/

module.exports = function( Gibberish ) {

  let Distortion = inputProps => {
    let props = Object.assign( {}, effect.defaults, Distortion.defaults, inputProps ),
        distortion= Object.create( effect ),
        out

    distortion.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      const input = g.in( 'input' ),
            inputGain = g.in( 'inputGain' ),
            shape1 = g.in( 'shape1' ),
            shape2 = g.in( 'shape2' ),
            pregain = g.in( 'pregain' ),
            postgain = g.in( 'postgain' )

      let lout
      {
        'use jsdsp'
        const linput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )
        const ltop = g.exp( linput * (shape1 + pregain) ) - g.exp( linput * (shape2 - pregain) )
        const lbottom = g.exp( linput * pregain ) + g.exp( -1 * linput * pregain )
        lout = ( ltop / lbottom ) * postgain
      }

      if( isStereo ) {
        let rout
        {
          'use jsdsp'
          const rinput = isStereo ? g.mul( input[1], inputGain ) : g.mul( input, inputGain )
          const rtop = g.exp( rinput * (shape1 + pregain) ) - g.exp( rinput * (shape2 - pregain) )
          const rbottom = g.exp( rinput * pregain ) + g.exp( -1 * rinput * pregain )
          rout = ( rtop / rbottom ) * postgain
        }

        distortion.graph = [ lout, rout ]
      }else{
        distortion.graph = lout 
      }
    }

    distortion.__createGraph()
    distortion.__requiresRecompilation = [ 'input' ]

    out = Gibberish.factory( 
      distortion,
      distortion.graph, 
      [ 'fx','distortion' ], 
      props 
    )
    return out 
  }

  Distortion.defaults = {
    input:0,
    shape1:.1,
    shape2:.1,
    pregain:5,
    postgain:.5,
  }

  return Distortion

}

},{"./effect.js":166,"genish.js":51}],166:[function(require,module,exports){
let ugen = require( '../ugen.js' )()

let effect = Object.create( ugen )

Object.assign( effect, {
  defaults: { bypass:false, inputGain:1 },
  type:'effect'
})

module.exports = effect

},{"../ugen.js":210}],167:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const effects = {
    Freeverb    : require( './freeverb.js'  )( Gibberish ),
    //Plate       : require( './dattorro.dsp.js' )( Gibberish ),
    Flanger     : require( './flanger.js'   )( Gibberish ),
    Vibrato     : require( './vibrato.js'   )( Gibberish ),
    Delay       : require( './delay.js'     )( Gibberish ),
    BitCrusher  : require( './bitCrusher.js')( Gibberish ),
    Distortion  : require( './distortion.dsp.js')( Gibberish ),
    RingMod     : require( './ringMod.js'   )( Gibberish ),
    Tremolo     : require( './tremolo.js'   )( Gibberish ),
    Chorus      : require( './chorus.js'    )( Gibberish ),
    Wavefolder  : require( './wavefolder.dsp.js')( Gibberish )[0],
    Shuffler    : require( './bufferShuffler.js'  )( Gibberish ),
    //Gate        : require( './gate.js'      )( Gibberish ),
  }

  effects.export = target => {
    for( let key in effects ) {
      if( key !== 'export' ) {
        target[ key ] = effects[ key ]
      }
    }
  }

return effects

}

},{"./bitCrusher.js":161,"./bufferShuffler.js":162,"./chorus.js":163,"./delay.js":164,"./distortion.dsp.js":165,"./flanger.js":168,"./freeverb.js":169,"./ringMod.js":170,"./tremolo.js":171,"./vibrato.js":172,"./wavefolder.dsp.js":173}],168:[function(require,module,exports){
let g = require( 'genish.js' ),
    proto = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let Flanger = inputProps => {
  let props   = Object.assign( { delayLength:44100 }, Flanger.defaults, proto.defaults, inputProps ),
      flanger = Object.create( proto ),
      out

  flanger.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          delayLength = props.delayLength,
          feedbackCoeff = g.in( 'feedback' ),
          modAmount = g.in( 'offset' ),
          frequency = g.in( 'frequency' ),
          delayBufferL = g.data( delayLength )

    const writeIdx = g.accum( 1,0, { min:0, max:delayLength, interp:'none', mode:'samples' })
    
    const offset = g.mul( modAmount, 500 )

    const mod = props.mod === undefined ? g.cycle( frequency ) : props.mod
    
    const readIdx = g.wrap( 
      g.add( 
        g.sub( writeIdx, offset ), 
        mod//g.mul( mod, g.sub( offset, 1 ) ) 
      ), 
      0, 
      delayLength
    )

    const leftInput = isStereo ? input[0] : input

    const delayedOutL = g.peek( delayBufferL, readIdx, { interp:'linear', mode:'samples' })
    
    g.poke( delayBufferL, g.add( leftInput, g.mul( delayedOutL, feedbackCoeff ) ), writeIdx )

    const left = g.add( leftInput, delayedOutL )

    if( isStereo === true ) {
      const rightInput = input[1]
      const delayBufferR = g.data( delayLength )
      
      let delayedOutR = g.peek( delayBufferR, readIdx, { interp:'linear', mode:'samples' })

      g.poke( delayBufferR, g.add( rightInput, g.mul( delayedOutR, feedbackCoeff ) ), writeIdx )
      const right = g.add( rightInput, delayedOutR )

      flanger.graph = [ left, right ]

    }else{
      flanger.graph = left
    }
  }

  flanger.__createGraph()
  flanger.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    flanger,
    flanger.graph, 
    ['fx','flanger'], 
    props 
  ) 

  return out 
}

Flanger.defaults = {
  input:0,
  feedback:.81,
  offset:.125,
  frequency:1
}

return Flanger

}

},{"./effect.js":166,"genish.js":51}],169:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
  
const allPass = Gibberish.filters.genish.AllPass
const combFilter = Gibberish.filters.genish.Comb

const tuning = {
  combCount:	  	8,
  combTuning: 		[ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],                    
  allPassCount: 	4,
  allPassTuning:	[ 225, 556, 441, 341 ],
  allPassFeedback:0.5,
  fixedGain: 		  0.015,
  scaleDamping: 	0.4,
  scaleRoom: 		  0.28,
  offsetRoom: 	  0.7,
  stereoSpread:   23
}

const Freeverb = inputProps => {
  const props = Object.assign( {}, effect.defaults, Freeverb.defaults, inputProps ),
        reverb = Object.create( effect ) 

  let out 
  reverb.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
    }    

    const combsL = [], combsR = []

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          wet1 = g.in( 'wet1'),
          wet2 = g.in( 'wet2' ),  
          dry = g.in( 'dry' ), 
          roomSize = g.in( 'roomSize' ), 
          damping = g.in( 'damping' )
    
    const __summedInput = isStereo === true ? g.add( input[0], input[1] ) : input,
          summedInput = g.mul( __summedInput, inputGain ),
          attenuatedInput = g.memo( g.mul( summedInput, tuning.fixedGain ) )
    
    // create comb filters in parallel...
    for( let i = 0; i < 8; i++ ) { 
      combsL.push( 
        combFilter( 
          attenuatedInput, 
          tuning.combTuning[i], 
          g.mul(damping,.4),
          g.mul( tuning.scaleRoom + tuning.offsetRoom, roomSize ) 
        ) 
      )
      combsR.push( 
        combFilter( 
          attenuatedInput, 
          tuning.combTuning[i] + tuning.stereoSpread, 
          g.mul(damping,.4), 
          g.mul( tuning.scaleRoom + tuning.offsetRoom, roomSize ) 
        ) 
      )
    }
    
    // ... and sum them with attenuated input, use of let is deliberate here
    let outL = g.add( attenuatedInput, ...combsL )
    let outR = g.add( attenuatedInput, ...combsR )
    
    // run through allpass filters in series
    for( let i = 0; i < 4; i++ ) { 
      outL = allPass( outL, tuning.allPassTuning[ i ] + tuning.stereoSpread )
      outR = allPass( outR, tuning.allPassTuning[ i ] + tuning.stereoSpread )
    }
    
    const outputL = g.add( g.mul( outL, wet1 ), g.mul( outR, wet2 ), g.mul( isStereo === true ? input[0] : input, dry ) ),
          outputR = g.add( g.mul( outR, wet1 ), g.mul( outL, wet2 ), g.mul( isStereo === true ? input[1] : input, dry ) )

    reverb.graph = [ outputL, outputR ]
  }

  reverb.__createGraph()
  reverb.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( reverb, reverb.graph, ['fx','freeverb'], props )

  return out
}


Freeverb.defaults = {
  input: 0,
  wet1: 1,
  wet2: 0,
  dry: .5,
  roomSize: .925,
  damping:  .5,
}

return Freeverb 

}


},{"./effect.js":166,"genish.js":51}],170:[function(require,module,exports){
let g = require( 'genish.js' ),
    effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
let RingMod = inputProps => {
  let props   = Object.assign( {}, RingMod.defaults, effect.defaults, inputProps ),
      ringMod = Object.create( effect ),
      out

  ringMod.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          frequency = g.in( 'frequency' ),
          gain = g.in( 'gain' ),
          mix = g.in( 'mix' )
    
    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain ),
          sine = g.mul( g.cycle( frequency ), gain )
   
    const left = g.add( g.mul( leftInput, g.sub( 1, mix )), g.mul( g.mul( leftInput, sine ), mix ) ) 
        
    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain ),
            right = g.add( g.mul( rightInput, g.sub( 1, mix )), g.mul( g.mul( rightInput, sine ), mix ) ) 
      
      ringMod.graph = [ left, right ]
    }else{
      ringMod.graph = left
    }
  }

  ringMod.__createGraph() 
  ringMod.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    ringMod,
    ringMod.graph, 
    [ 'fx','ringMod'], 
    props 
  )
  
  return out 
}

RingMod.defaults = {
  input:0,
  frequency:220,
  gain: 1, 
  mix:1
}

return RingMod

}

},{"./effect.js":166,"genish.js":51}],171:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
const Tremolo = inputProps => {
  const props   = Object.assign( {}, Tremolo.defaults, effect.defaults, inputProps ),
        tremolo = Object.create( effect )
  
  let out
  tremolo.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          frequency = g.in( 'frequency' ),
          amount = g.in( 'amount' )
    
    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    let osc
    if( props.shape === 'square' ) {
      osc = g.gt( g.phasor( frequency ), 0 )
    }else if( props.shape === 'saw' ) {
      osc = g.gtp( g.phasor( frequency ), 0 )
    }else{
      osc = g.cycle( frequency )
    }

    const mod = g.mul( osc, amount )
   
    const left = g.sub( leftInput, g.mul( leftInput, mod ) )

    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain ),
            right = g.mul( rightInput, mod )

      tremolo.graph = [ left, right ]
    }else{
      tremolo.graph = left
    }
  }
  
  tremolo.__createGraph()
  tremolo.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    tremolo,
    tremolo.graph,
    ['fx','tremolo'], 
    props 
  ) 
  return out 
}

Tremolo.defaults = {
  input:0,
  frequency:2,
  amount: 1, 
  shape:'sine'
}

return Tremolo

}

},{"./effect.js":166,"genish.js":51}],172:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

module.exports = function( Gibberish ) {
 
const Vibrato = inputProps => {
  const props   = Object.assign( {}, Vibrato.defaults, effect.defaults, inputProps ),
        vibrato = Object.create( effect )

  let out
  vibrato.__createGraph = function() {
    let isStereo = false
    if( out === undefined ) {
      isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
    }else{
      isStereo = out.input.isStereo
      out.isStereo = isStereo
    }    

    const input = g.in( 'input' ),
          inputGain = g.in( 'inputGain' ),
          delayLength = 44100,
          feedbackCoeff = g.in( 'feedback' ),
          modAmount = g.in( 'amount' ),
          frequency = g.in( 'frequency' ),
          delayBufferL = g.data( delayLength )

    const writeIdx = g.accum( 1,0, { min:0, max:delayLength, interp:'none', mode:'samples' })
    
    const offset = g.mul( modAmount, 500 )
    
    const readIdx = g.wrap( 
      g.add( 
        g.sub( writeIdx, offset ), 
        g.mul( g.cycle( frequency ), g.sub( offset, 1 ) ) 
      ), 
      0, 
      delayLength
    )

    const leftInput = isStereo ? g.mul( input[0], inputGain ) : g.mul( input, inputGain )

    const delayedOutL = g.peek( delayBufferL, readIdx, { interp:'linear', mode:'samples' })
    
    g.poke( delayBufferL, g.add( leftInput, g.mul( delayedOutL, feedbackCoeff ) ), writeIdx )

    const left = delayedOutL

    if( isStereo === true ) {
      const rightInput = g.mul( input[1], inputGain )
      const delayBufferR = g.data( delayLength )
      
      const delayedOutR = g.peek( delayBufferR, readIdx, { interp:'linear', mode:'samples' })

      g.poke( delayBufferR, g.add( rightInput, mul( delayedOutR, feedbackCoeff ) ), writeIdx )
      const right = delayedOutR

      vibrato.graph = [ left, right ]
    }else{
      vibrato.graph = left 
    }
  }

  vibrato.__createGraph()
  vibrato.__requiresRecompilation = [ 'input' ]

  out = Gibberish.factory( 
    vibrato,
    vibrato.graph,    
    [ 'fx', 'vibrato' ], 
    props 
  ) 
  return out 
}

Vibrato.defaults = {
  input:0,
  feedback:.01,
  amount:.5,
  frequency:4
}

return Vibrato

}

},{"./effect.js":166,"genish.js":51}],173:[function(require,module,exports){
const g = require( 'genish.js' ),
      effect = require( './effect.js' )

const genish = g

const RL = 7.5e3,
       R = 15e3, 
      VT = 26e-3,
      Is = 10e-16,
       a = 2*RL/R,
       b = (R+2*RL)/(VT*R),
       d = (RL*Is)/VT

// Antialiasing error threshold
const thresh = 10e-10;

const wavestage = in1 => {
  const body = `  const thresh = 10e-10;

  let w = Ln1;
  let expw, p, r, s;

  const e = Math.E
  const pow = Math.pow
  const abs = Math.abs
  for(let i=0; i<1000; i++) {
    expw = pow(e,w);

    p = w*expw - x;
    r = (w+1)*expw;
    s = (w+2)/(2*(w+1));        
    err = (p/(r-(p*s)));

    if (abs(err)<thresh) {
      break;
    }

    w = w - err;
  }

  return w;`

  const Lambert_W = g.process( 'x','Ln1', body )

  const Ln1 = g.history(0),
        Fn1 = g.history(0),
        xn1 = g.history(0)

  {
    'use jsdsp'
    // Compute Antiderivative
    const l = g.sign(in1); 
    let u = d * g.pow( Math.E, l * b * in1 )
    let Ln = Lambert_W.call(u,Ln1.out)
    const Fn = (0.5 * VT/b ) * (Ln * (Ln + 2)) - 0.5*a*in1*in1

    let xn = 0.5 * ( in1 + xn1.out )
    u = d * g.pow( Math.E, l * b * xn )
    Ln = Lambert_W.call( u, Ln1.out )

    //out1 = ;
    // Check for ill-conditioning
    const out1 = g.ifelse(
      g.lt( g.abs( in1 - xn1.out ), thresh), 
      (l * VT * Ln) - ( a * xn ),
      (Fn - Fn1.out) / (in1 - xn1.out)
    )

    // Update States
    Ln1.in( Ln )
    Fn1.in( Fn )
    xn1.in( in1 )

    return out1
  }
}

module.exports = function( Gibberish ) {

  const Wavefolder = inputProps => {

    let props = Object.assign( {}, effect.defaults, Wavefolder.defaults, inputProps ),
        wavefolder = Object.create( effect ),
        out

    wavefolder.__createGraph = function() {
      let isStereo = false
      if( out === undefined ) {
        isStereo = typeof props.input.isStereo !== 'undefined' ? props.input.isStereo : false 
      }else{
        isStereo = out.input.isStereo
        out.isStereo = isStereo
      }

      const input = g.in( 'input' ),
            gain  = g.in( 'gain' ),
            postgain = g.in( 'postgain' )

      let lout
      {
        'use jsdsp'

        const linput = isStereo ? input[0] * gain : input * gain
        lout = linput * .333
        lout = wavestage( wavestage( wavestage( wavestage( lout ) ) ) )
        lout = lout * .6
        lout = g.tanh( lout ) * postgain
      }

      wavefolder.graph = lout

      if( isStereo ) {
        let rout
        {
          'use jsdsp'
          const rinput = isStereo ? input[1] * gain : input * gain
          rout = rinput * .333
          rout = wavestage( wavestage( wavestage( wavestage( rout ) ) ) )
          rout = rout * .6
          rout = g.tanh( rout ) * postgain
        }

        wavefolder.graph = [ lout, rout ]
      }
    }

    wavefolder.__createGraph()
    wavefolder.__requiresRecompilation = [ 'input' ]

    out = Gibberish.factory( 
      wavefolder,
      wavefolder.graph, 
      [ 'fx','wavefolder' ], 
      props 
    )

    return out 
  }

  Wavefolder.defaults = {
    input:0,
    gain:2,
    postgain:1
  }

  return [ Wavefolder, wavestage ]

}

},{"./effect.js":166,"genish.js":51}],174:[function(require,module,exports){
let MemoryHelper = require( 'memory-helper' ),
    genish       = require( 'genish.js' )
    
let Gibberish = {
  blockCallbacks: [], // called every block
  dirtyUgens: [],
  callbackUgens: [],
  callbackNames: [],
  analyzers: [],
  graphIsDirty: false,
  ugens: {},
  debug: false,
  id: -1,
  preventProxy:false,
  proxyEnabled: true,

  output: null,

  memory : null, // 20 minutes by default?
  factory: null, 
  genish,
  scheduler: require( './scheduling/scheduler.js' ),
  //workletProcessorLoader: require( './workletProcessor.js' ),
  workletProcessor: null,

  memoed: {},
  mode:'scriptProcessor',

  prototypes: {
    ugen: null,//require('./ugen.js'),
    instrument: require( './instruments/instrument.js' ),
    effect: require( './fx/effect.js' ),
    analyzer: require( './analysis/analyzer.js' )
  },

  mixins: {
    polyinstrument: require( './instruments/polyMixin.js' )
  },

  workletPath: './gibberish_worklet.js',

  init( memAmount, ctx, mode='worklet' ) {
    let numBytes = isNaN( memAmount ) ? 20 * 60 * 44100 : memAmount

    // regardless of whether or not gibberish is using worklets,
    // we still want genish to output vanilla js functions instead
    // of audio worklet classes; these functions will be called
    // from within the gibberish audioworklet processor node.
    this.genish.gen.mode = 'scriptProcessor'

    this.memory = MemoryHelper.create( numBytes, Float64Array )

    this.mode = mode

    const startup = this.utilities.createWorklet

    this.scheduler.init( this )
    
    this.analyzers.dirty = false

    if( this.mode === 'worklet' ) {

      const p = new Promise( (resolve, reject ) => {

        const pp = new Promise( (__resolve, __reject ) => {
          this.utilities.createContext( ctx, startup.bind( this.utilities ), __resolve )
        }).then( ()=> {
          Gibberish.preventProxy = true
          Gibberish.load()
          Gibberish.preventProxy = false
          Gibberish.output = this.Bus2()

          // Gibberish.output needs to be assign so that ugens can
          // connect to it by default. There's no other way to assign it
          // outside of evaling code at this point.
          Gibberish.worklet.port.postMessage({ 
            address:'eval', 
            code:`Gibberish.output = this.ugens.get(${Gibberish.output.id});` 
          })

          resolve()
        })

      })
      
      return p

    }else if( this.mode === 'processor' ) {
      Gibberish.load()
    }
  },

  load() {
    this.factory      = require( './factory.js' )( this )
    
    this.Panner       = require( './misc/panner.js' )( this )
    this.PolyTemplate = require( './instruments/polytemplate.js' )( this )
    this.oscillators  = require( './oscillators/oscillators.js' )( this )
    this.filters      = require( './filters/filters.js' )( this )
    this.binops       = require( './misc/binops.js' )( this )
    this.monops       = require( './misc/monops.js' )( this )
    this.Bus          = require( './misc/bus.js' )( this )
    this.Bus2         = require( './misc/bus2.js' )( this )
    this.instruments  = require( './instruments/instruments.js' )( this )
    this.fx           = require( './fx/effects.js' )( this )
    this.Sequencer    = require( './scheduling/sequencer.js' )( this )
    this.Sequencer2   = require( './scheduling/seq2.js' )( this )
    this.Tidal        = require( './scheduling/tidal.js' )( this )
    this.envelopes    = require( './envelopes/envelopes.js' )( this )
    this.analysis     = require( './analysis/analyzers.js' )( this )
    this.time         = require( './misc/time.js' )( this )
    this.Proxy        = require( './workletProxy.js' )( this )
  },

  export( target, shouldExportGenish=false ) {
    if( target === undefined ) throw Error('You must define a target object for Gibberish to export variables to.')

    if( shouldExportGenish ) this.genish.export( target )

    this.instruments.export( target )
    this.fx.export( target )
    this.filters.export( target )
    this.oscillators.export( target )
    this.binops.export( target )
    this.monops.export( target )
    this.envelopes.export( target )
    this.analysis.export( target )
    target.Sequencer = this.Sequencer
    target.Sequencer2 = this.Sequencer2
    target.Bus = this.Bus
    target.Bus2 = this.Bus2
    target.Scheduler = this.scheduler
    target.Tidal = this.Tidal
    this.time.export( target )
    this.utilities.export( target )
  },

  printcb() { 
    Gibberish.worklet.port.postMessage({ address:'callback' }) 
  },
  printobj( obj ) {
    Gibberish.worklet.port.postMessage({ address:'print', object:obj.id }) 
  },
  send( msg ){
    Gibberish.worklet.port.postMessage( msg )
  },

  dirty( ugen ) {
    if( ugen === this.analyzers ) {
      this.graphIsDirty = true
      this.analyzers.dirty = true
    } else {
      this.dirtyUgens.push( ugen )
      this.graphIsDirty = true
      if( this.memoed[ ugen.ugenName ] ) {
        delete this.memoed[ ugen.ugenName ]
      }
    } 
  },

  clear() {
    // do not delete the gain and the pan of the master bus 
    this.output.inputs.splice( 0, this.output.inputs.length - 2 )
    //this.output.inputNames.length = 0
    this.analyzers.length = 0
    this.scheduler.clear()
    this.dirty( this.output )
    if( this.mode === 'worklet' ) {
      this.worklet.port.postMessage({ 
        address:'method', 
        object:this.id,
        name:'clear',
        args:[]
      })
    }
    // clear memory... XXX should this be a MemoryHelper function?
    //this.memory.heap.fill(0)
    //this.memory.list = {}

    Gibberish.genish.gen.removeAllListeners('memory init')
    Gibberish.genish.gen.histories.clear()

    //Gibberish.output = this.Bus2()
    
  },

  // used to sort analysis ugens by priority.
  // higher priorities mean lower ordering in the array,
  // which means they will run first in the callback function.
  // by defult, analysis ugens are assigned a priority of 0 in the
  // analysis prototype.
  analysisCompare( a,b ) {
    return (isNaN(b.priority) ? 0 : b.priority) - (isNaN(a.priority) ? 0: a.priority )
  },

  generateCallback() {
    if( this.mode === 'worklet' ) {
      Gibberish.callback = function() { return 0 }
      Gibberish.callback.out = []
      return Gibberish.callback
    }
    let uid = 0,
        callbackBody, lastLine, analysis=''

    this.memoed = {}

    callbackBody = this.processGraph( this.output )
    lastLine = callbackBody[ callbackBody.length - 1]
    callbackBody.unshift( "\t'use strict'" )

    this.analyzers
      .sort( this.analysisCompare )
      .forEach( v=> {
        const analysisBlock = Gibberish.processUgen( v )
        //if( Gibberish.mode === 'processor' ) {
        //  console.log( 'analysis:', analysisBlock, v  )
        //}
        let analysisLine

        if( typeof analysisBlock === 'object' ) {
          analysisLine = analysisBlock.pop()

          analysisBlock.forEach( v => {
            callbackBody.splice( callbackBody.length - 1, 0, v )
          })
        }else{
          analysisLine = analysisBlock
        }

        callbackBody.push( analysisLine )
      })

    this.analyzers.forEach( v => {
      if( this.callbackUgens.indexOf( v.callback ) === -1 )
        this.callbackUgens.push( v.callback )
    })

    this.callbackNames = this.callbackUgens.map( v => v.ugenName )

    callbackBody.push( '\n\treturn ' + lastLine.split( '=' )[0].split( ' ' )[1] )

    if( this.debug === true ) console.log( 'callback:\n', callbackBody.join('\n') )
    
    this.callbackNames.push( 'mem' )
    this.callbackUgens.push( this.memory.heap )
    this.callback = Function( ...this.callbackNames, callbackBody.join( '\n' ) )//.bind( null, ...this.callbackUgens )
    this.callback.out = []

    if( this.oncallback ) this.oncallback( this.callback )

    return this.callback 
  },

  processGraph( output ) {
    this.callbackUgens.length = 0
    this.callbackNames.length = 0

    this.callbackUgens.push( output.callback )

    let body = this.processUgen( output )
    

    this.dirtyUgens.length = 0
    this.graphIsDirty = false

    return body
  },
  proxyReplace( obj ) {
    if( typeof obj === 'object' && obj !== null ) {
      if( obj.id !== undefined ) {
        const __obj = Gibberish.processor.ugens.get( obj.id )
        //console.log( 'retrieved:', __obj.name )

        //if( obj.prop !== undefined ) console.log( 'got a ssd.out', obj )
        return obj.prop !== undefined ? __obj[ obj.prop ] : __obj
      }else if( obj.isFunc === true ) {
        let func =  eval( '(' + obj.value + ')' )

        //console.log( 'replacing function:', func )

        return func
      }
    }

    return obj
  },

  processUgen( ugen, block ) {
    if( block === undefined ) block = []
    if( ugen === undefined ) return block


    let dirtyIdx = Gibberish.dirtyUgens.indexOf( ugen )

    let memo = Gibberish.memoed[ ugen.ugenName ]

    if( memo !== undefined ) {
      return memo
    } else if( ugen === true || ugen === false ) {
      throw "Why is ugen a boolean? [true] or [false]";
    } else if( ugen.block === undefined || dirtyIndex !== -1 ) {
      // weird edge case with analysis (follow) ugen
      if( ugen.id === undefined ) {
        ugen.id = ugen.__properties__.overrideid
      }

      let line = `\tconst v_${ugen.id} = ` 
      if( !ugen.isop ) line += `${ugen.ugenName}( `

      // must get array so we can keep track of length for comma insertion
      const keys = ugen.isop === true || ugen.type === 'bus'  
        ? Object.keys( ugen.inputs ) 
        : [...ugen.inputNames ] 

      line = ugen.isop === true 
        ? Gibberish.__processBinop( ugen, line, block, keys ) 
        : Gibberish.__processNonBinop( ugen, line, block, keys )

      line = Gibberish.__addLineEnding( line, ugen, keys )

      block.push( line )
      
      Gibberish.memoed[ ugen.ugenName ] = `v_${ugen.id}`

      if( dirtyIdx !== -1 ) {
        Gibberish.dirtyUgens.splice( dirtyIdx, 1 )
      }

    }else if( ugen.block ) {
      return ugen.block
    }

    return block
  }, 

  __processBinop( ugen, line, block, keys ) {
    //__getInputString( line, input, block, key, ugen ) {
    const isLeftStereo = Gibberish.__isStereo( ugen.inputs[0] ), 
          isRightStereo = Gibberish.__isStereo( ugen.inputs[1] ),
          left = Gibberish.__getInputString( line, ugen.inputs[0], block, '0', keys ),
          right= Gibberish.__getInputString( line, ugen.inputs[1], block, '1', keys ),
          op = ugen.op
        
    let graph, out

    if( isLeftStereo === true && isRightStereo === false ) {
      line += `[ ${left}[0] ${op} ${right}, ${left}[1] ${op} ${right} ]`
      //graph = [ g.add( args[0].graph[0], args[1] ), g.add( args[0].graph[1], args[1] )]
    }else if( isLeftStereo === false && isRightStereo === true ) {
      //graph = [ g.add( args[0], args[1].graph[0] ), g.add( args[0], args[1].graph[1] )]
      line += `[ ${left} ${op} ${right}[0], ${left} ${op} ${right}[1] ]`
    }else if( isLeftStereo === true && isRightStereo === true ) {
      //graph = [ g.add( args[0].graph[0], args[1].graph[0] ), g.add( args[0].graph[1], args[1].graph[1] )]
      line += `[ ${left}[0] ${op} ${right}[0], ${left}[1] ${op} ${right}[1] ]`
    }else{
      // XXX important, must re-assign when calling processNonBinop
      line = Gibberish.__processNonBinop( ugen, line, block, keys )
    }
    
    return line
  },

  __processNonBinop( ugen, line, block, keys ) {
    for( let i = 0; i < keys.length; i++ ) {
      let key = keys[ i ]
      // binop.inputs is actual values, not just property names
      let input 
      if( ugen.isop || ugen.type ==='bus' ) {
        input = ugen.inputs[ key ]
      }else{
        input = ugen[ key ] 
      }

      if( input !== undefined ) { 
        input = Gibberish.__getBypassedInput( input )
        line += Gibberish.__getInputString( line, input, block, key, ugen )
        line  = Gibberish.__addSeparator( line, input, ugen, i < keys.length - 1 )
      }
    }

    return line
  },

  // determine if a ugen is stereo
  __isStereo( ugen ) {
    let isStereo = false

    if( ugen === undefined || ugen === null ) return false

    if( ugen.isStereo === true ) return true

    if( ugen.isop === true ) {
      return Gibberish.__isStereo( ugen.inputs[0] ) || Gibberish.__isStereo( ugen.inputs[1] )
    }
    
    return isStereo
  },

  // if an effect is bypassed, get next one in chain (or output destination)
  __getBypassedInput( input ) {
    if( input.bypass === true ) {
      // loop through inputs of chain until one is found
      // that is not being bypassed

      let found = false

      while( input.input !== 'undefined' && found === false ) {
        if( typeof input.input.bypass !== 'undefined' ) {
          input = input.input
          if( input.bypass === false ) found = true
        }else{
          input = input.input
          found = true
        }
      }
    }

    return input
  },

  // get a string representing a ugen for insertion into callback.
  // if a ugen contains other ugens, trigger codegen for those ugens as well.
  __getInputString( line, input, block, key, ugen ) {
    let value = ''
    if( typeof input === 'number' ) {
      if( isNaN(key) ) {
        value += `mem[${ugen.__addresses__[ key ]}]`//input
      }else{
        value += input
      }
    } else if( typeof input === 'boolean' ) {
      value += '' + input
    }else{
      //console.log( 'key:', key, 'input:', ugen.inputs, ugen.inputs[ key ] ) 
      // XXX not sure why this has to be here, but somehow non-processed objects
      // that only contain id numbers are being passed here...

      if( input !== undefined ) {
        if( Gibberish.mode === 'processor' ) {
          if( input.ugenName === undefined && input.id !== undefined  ) {
            if( ugen === undefined  ) {
              input = Gibberish.processor.ugens.get( input.id )
            }else{
              if( ugen.type !== 'seq' ) {
                input = Gibberish.processor.ugens.get( input.id )
              }
            }
          }
        }

        Gibberish.processUgen( input, block )

        if( !input.isop ) {
          // check is needed so that graphs with ssds that refer to themselves
          // don't add the ssd in more than once
          if( Gibberish.callbackUgens.indexOf( input.callback ) === -1 ) {
            Gibberish.callbackUgens.push( input.callback )
          }
        }

        value += `v_${input.id}`
        input.__varname = value
      }
    }

    return value
  },

  // add separators for function calls and handle binops (mono only)
  __addSeparator( line, input, ugen, isNotEndOfLine ) {
    if( isNotEndOfLine === true ) {
      if( ugen.isop === true ) {
        if( ugen.op === '*' || ugen.op === '/' ) {
          if( input !== 1 ) {
            line += ' ' + ugen.op + ' '
          }else{
            line = line.slice( 0, -1 * (''+input).length )
          }
        }else{
          line += ' ' + ugen.op + ' '
        }
      }else{
        line += ', '
      }
    }

    return line
  },

  // add memory to end of function calls and close parenthesis 
  __addLineEnding( line, ugen, keys ) {
    if( (ugen.type === 'bus' && keys.length > 0) ) line += ', '
    if( !ugen.isop && ugen.type !== 'seq' ) line += 'mem'
    line += ugen.isop ? '' : ' )'

    return line
  },

}

Gibberish.prototypes.Ugen = Gibberish.prototypes.ugen = require( './ugen.js' )( Gibberish )
Gibberish.utilities = require( './utilities.js' )( Gibberish )

module.exports = Gibberish

},{"./analysis/analyzer.js":140,"./analysis/analyzers.js":141,"./envelopes/envelopes.js":146,"./factory.js":151,"./filters/filters.js":158,"./fx/effect.js":166,"./fx/effects.js":167,"./instruments/instrument.js":181,"./instruments/instruments.js":182,"./instruments/polyMixin.js":187,"./instruments/polytemplate.js":188,"./misc/binops.js":194,"./misc/bus.js":195,"./misc/bus2.js":196,"./misc/monops.js":197,"./misc/panner.js":198,"./misc/time.js":199,"./oscillators/oscillators.js":202,"./scheduling/scheduler.js":206,"./scheduling/seq2.js":207,"./scheduling/sequencer.js":208,"./scheduling/tidal.js":209,"./ugen.js":210,"./utilities.js":211,"./workletProxy.js":212,"genish.js":51,"memory-helper":221}],175:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g
  
module.exports = function( Gibberish ) {

  const Clap = argumentProps => {
    'use jsdsp' 

    const clap = Object.create( instrument ),
          decay = g.in( 'decay' ), // 0-1 input value
          scaledDecay = decay * (g.gen.samplerate * 2 ),
          gain  = g.in( 'gain' ),
          spacing = g.in( 'spacing' ), // spacing between clap, in Hzs
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          cutoff = g.in('cutoff'),
          Q      = g.in('Q')

    const props = Object.assign( {}, Clap.defaults, argumentProps )

    const eg = g.decay( scaledDecay, { initValue:0 } ), 
          check = g.gt( eg, .0005 ),
          noise = -1 + g.noise() * 2,
          rnd = noise,//g.gtp( noise, 0 ),// * eg,
          b   = g.bang(),
          saw = g.phasor( spacing, b, { min:0 }),
          rsaw = 1 - saw,
          saw_env = g.ad( 0, .035 * g.gen.samplerate, { shape:'linear' }), 
          b2 = g.bang(),
          count = g.accum( 1,b2,{ max:Infinity, min:0, initialValue:0 }),
          delayedNoise = g.switch( g.gte( count, g.gen.samplerate * .035 ), rnd, 0 ),
          bpf1 = g.svf( delayedNoise, 1000, .5, 2, false ),

          scaledOut = ( bpf1 * eg + ( rnd * rsaw * saw_env ) ) * gain * loudness * triggerLoudness,
          out = g.svf( scaledOut, cutoff, Q, 1, false )
    
    // XXX TODO : make this work with ifelse. the problem is that poke ugens put their
    // code at the bottom of the callback function, instead of at the end of the
    // associated if/else block.
    const ife = g.switch( check, out, 0 )
    
    clap.env = {
      trigger( vol ) {
        b.trigger()
        eg.trigger( vol )
        b2.trigger()
        saw_env.trigger()
      }
    } 
    
    return Gibberish.factory( clap, ife, ['instruments','clap'], props  )
  }
  
  Clap.defaults = {
    gain: 1,
    spacing:100,
    decay:.2,
    loudness:1,
    __triggerLoudness:1,
    cutoff:900,
    Q:.85
  }

  return Clap

}

},{"./instrument.js":181,"genish.js":51}],176:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' ),
      __wavefold   = require( '../fx/wavefolder.dsp.js' )

const genish = g

module.exports = function( Gibberish ) {
  const wavefold = __wavefold( Gibberish )[1]

  const Complex = inputProps => {
    const syn = Object.create( instrument )

    const frequency = g.in( 'frequency' ),
          loudness  = g.in( 'loudness' ), 
          triggerLoudness = g.in( '__triggerLoudness' ),
          glide   = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.slide( frequency, glide, glide ),
          attack  = g.in( 'attack' ), 
          decay   = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), 
          sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' ),
          pregain = g.in( 'pregain' ),
          postgain= g.in( 'postgain' ),
          bias    = g.in( 'bias' )

    const props = Object.assign( {}, Complex.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const osc = Gibberish.oscillators.factory( syn.waveform, slidingFreq, syn.antialias )

      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      const saturation = g.in('saturation')

      // below doesn't work as it attempts to assign to release property triggering codegen...
      // syn.release = ()=> { syn.env.release() }

      {
        'use jsdsp'
        let oscWithEnv = osc * env * loudness * triggerLoudness,
            panner

        let foldedOsc = wavefold( wavefold( wavefold( wavefold( bias + oscWithEnv * (pregain * env) * .333 ) ) ) )
        foldedOsc = g.tanh( foldedOsc * .6 ) * postgain
 
        // 16 is an unfortunate empirically derived magic number...
        const baseCutoffFreq = g.in('cutoff') * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness * triggerLoudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( foldedOsc, cutoff, saturation, props )

        let complexWithGain = filteredOsc * g.in( 'gain' )
        // XXX ugly, ugly hack
        if(  props.filterModel !== 2 ) complexWithGain = complexWithGain * saturation
    
        if( syn.panVoices === true ) { 
          panner = g.pan( complexWithGain, complexWithGain, g.in( 'pan' ) ) 
          syn.graph = [ panner.left, panner.right ]
        }else{
          syn.graph = complexWithGain
        }

        syn.env = env
        syn.osc = osc
        syn.filter = filteredOsc
      }

    }
    
    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel','filterMode', 'useADSR', 'shape' ]
    syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments', 'complex'], props  )

    return out
  }
  
  Complex.defaults = {
    waveform:'triangle',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'exponential',
    triggerRelease:false,
    gain: .5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:true,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    glide:1,
    saturation:1,
    filterMult:2,
    Q:.25,
    cutoff:.5,
    //filterType:1,
    filterModel:1,
    filterMode:0,
    isStereo:false,
    pregain:4,
    postgain:1,
    bias:0
  }

  // do not include velocity, which shoudl always be per voice
  let PolyComplex = Gibberish.PolyTemplate( Complex, ['frequency','attack','decay','pulsewidth','pan','gain','glide', 'saturation', 'filterMult', 'Q', 'cutoff', 'resonance', 'antialias', 'filterModel', 'waveform', 'filterMode', '__triggerLoudness', 'loudness', 'pregain', 'postgain', 'bias'] ) 
  PolyComplex.defaults = Complex.defaults

  return [ Complex, PolyComplex ]

}

},{"../fx/wavefolder.dsp.js":173,"./instrument.js":181,"genish.js":51}],177:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Conga = argumentProps => {
    const conga = Object.create( instrument ),
          frequency = g.in( 'frequency' ),
          decay = g.in( 'decay' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Conga.defaults, argumentProps )

    const trigger = g.bang(),
          impulse = g.mul( trigger, 60 ),
          _decay =  g.sub( .101, g.div( decay, 10 ) ), // create range of .001 - .099
          bpf = g.svf( impulse, frequency, _decay, 2, false ),
          out = g.mul( bpf, g.mul( g.mul( triggerLoudness,loudness ), gain ) )
    
    conga.isStereo = false
    conga.env = trigger
    return Gibberish.factory( conga, out, ['instruments','conga'], props  )
  }
  
  Conga.defaults = {
    gain: .125,
    frequency:190,
    decay: .85,
    loudness: 1,
    __triggerLoudness:1
  }

  const PolyConga = Gibberish.PolyTemplate( Conga, ['gain','frequency','decay','loudness','__triggerLoudness' ] ) 
  PolyConga.defaults = Conga.defaults

  return [ Conga, PolyConga ]
}

},{"./instrument.js":181,"genish.js":51}],178:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Cowbell = argumentProps => {
    let cowbell = Object.create( instrument )
    
    const decay   = g.in( 'decay' ),
          gain    = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Cowbell.defaults, argumentProps )

    const bpfCutoff = g.param( 'bpfc', 1000 ),
          s1 = Gibberish.oscillators.factory( 'square', 560 ),
          s2 = Gibberish.oscillators.factory( 'square', 845 ),
          eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 }), 
          bpf = g.svf( g.add( s1,s2 ), bpfCutoff, 3, 2, false ),
          envBpf = g.mul( bpf, eg ),
          out = g.mul( envBpf, g.mul( gain, loudness, triggerLoudness ) )

    cowbell.env = eg 

    cowbell.isStereo = false

    cowbell = Gibberish.factory( cowbell, out, ['instruments', 'cowbell'], props  )
    
    return cowbell
  }
  
  Cowbell.defaults = {
    gain: 1,
    decay:.5,
    loudness:1,
    __triggerLoudness:1
  }

  return Cowbell

}

},{"./instrument.js":181,"genish.js":51}],179:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {

  const FM = inputProps => {
    let syn = Object.create( instrument )

    let frequency = g.in( 'frequency' ),
        glide = g.max( 1, g.in( 'glide' ) ),
        slidingFreq = g.slide( frequency, glide, glide ),
        cmRatio = g.in( 'cmRatio' ),
        index = g.in( 'index' ),
        feedback = g.in( 'feedback' ),
        attack = g.in( 'attack' ), decay = g.in( 'decay' ),
        sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
        release = g.in( 'release' ),
        loudness = g.in( 'loudness' ),
        triggerLoudness = g.in( '__triggerLoudness' ),
        saturation = g.in( 'saturation' )

    const props = Object.assign( {}, FM.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      syn.advance = ()=> { env.release() }

      const feedbackssd = g.history( 0 )

      const modOsc = Gibberish.oscillators.factory( 
        syn.modulatorWaveform, 
        g.add( g.mul( slidingFreq, cmRatio ), g.mul( feedbackssd.out, feedback, index ) ), 
        syn.antialias 
      )

      {
        'use jsdsp'
        const Loudness = loudness * triggerLoudness
        const modOscWithIndex = modOsc * slidingFreq * index * Loudness
        const modOscWithEnv   = modOscWithIndex * env
        
        const modOscWithEnvAvg =  .5 * ( modOscWithEnv + feedbackssd.out )

        feedbackssd.in( modOscWithEnvAvg )

        const carrierOsc = Gibberish.oscillators.factory( syn.carrierWaveform, g.add( slidingFreq, modOscWithEnvAvg ), syn.antialias )

        // XXX horrible hack below to "use" saturation even when not using a diode filter 
        const carrierOscWithEnv = props.filterModel === 2 ? carrierOsc * env : g.mul(carrierOsc, g.mul(env,saturation) )

        const baseCutoffFreq = g.in( 'cutoff' ) * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * Loudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( carrierOscWithEnv, cutoff, saturation, syn )
        const synthWithGain = filteredOsc * g.in( 'gain' ) * Loudness
        
        let panner
        if( props.panVoices === true ) { 
          panner = g.pan( synthWithGain, synthWithGain, g.in( 'pan' ) ) 
          syn.graph = [panner.left, panner.right ]
          syn.isStereo = true
        }else{
          syn.graph = synthWithGain
          syn.isStereo = false
        }
      }

      syn.env = env

      return env
    }
    
    syn.__requiresRecompilation = [ 'carrierWaveform', 'modulatorWaveform', 'antialias', 'filterModel', 'filterMode' ]
    const env = syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph , ['instruments','FM'], props )

    out.env.advance = out.advance 
    return out
  }

  FM.defaults = {
    carrierWaveform:'sine',
    modulatorWaveform:'sine',
    attack: 44,
    feedback: 0,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .25,
    cmRatio:2,
    index:5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:false,
    panVoices:false,
    glide:1,
    saturation:1,
    filterMult:1.5,
    Q:.25,
    cutoff:.35,
    filterModel:0,
    filterMode:0,
    loudness: 1,
    __triggerLoudness:1

  }

  const PolyFM = Gibberish.PolyTemplate( FM, ['glide','frequency','attack','decay','pulsewidth','pan','gain','cmRatio','index', 'saturation', 'filterMult', 'Q', 'cutoff', 'antialias', 'filterModel', 'carrierWaveform', 'modulatorWaveform','filterMode', 'feedback', 'useADSR', 'sustain', 'release', 'sustainLevel', '__triggerLoudness','loudness' ] ) 
  PolyFM.defaults = FM.defaults

  return [ FM, PolyFM ]

}

},{"./instrument.js":181,"genish.js":51}],180:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  let Hat = argumentProps => {
    let hat = Object.create( instrument ),
        tune  = g.in( 'tune' ),
        scaledTune = g.memo( g.add( .4, tune ) ),
        decay  = g.in( 'decay' ),
        gain  = g.in( 'gain' ),
        loudness = g.in( 'loudness' ),
        triggerLoudness = g.in( '__triggerLoudness' )

    let props = Object.assign( {}, Hat.defaults, argumentProps )

    let baseFreq = g.mul( 325, scaledTune ), // range of 162.5 - 487.5
        bpfCutoff = g.mul( g.param( 'bpfc', 7000 ), scaledTune ),
        hpfCutoff = g.mul( g.param( 'hpfc', 11000 ), scaledTune ),  
        s1 = Gibberish.oscillators.factory( 'square', baseFreq, false ),
        s2 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.4471 ) ),
        s3 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.6170 ) ),
        s4 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,1.9265 ) ),
        s5 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,2.5028 ) ),
        s6 = Gibberish.oscillators.factory( 'square', g.mul( baseFreq,2.6637 ) ),
        sum = g.add( s1,s2,s3,s4,s5,s6 ),
        eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 }), 
        bpf = g.svf( sum, bpfCutoff, .5, 2, false ),
        envBpf = g.mul( bpf, eg ),
        hpf = g.filter24( envBpf, 0, hpfCutoff, 0 ),
        out = g.mul( hpf, g.mul( gain, g.mul( loudness, triggerLoudness ) ) )

    hat.env = eg 
    hat.isStereo = false

    const __hat = Gibberish.factory( hat, out, ['instruments','hat'], props  )
    

    return __hat
  }
  
  Hat.defaults = {
    gain:  .5,
    tune: .6,
    decay:.1,
    loudness:1,
    __triggerLoudness:1
  }

  return Hat

}

},{"./instrument.js":181,"genish.js":51}],181:[function(require,module,exports){
const ugen = require('../ugen.js')();

const instrument = Object.create(ugen);

Object.assign(instrument, {
  type: 'instrument',

  note(freq, loudness = null) {
    // if binop is should be used...
    if (isNaN(this.frequency)) {
      // and if we are assigning binop for the first time...
      let obj = Gibberish.processor.ugens.get(this.frequency.id);
      if (obj === undefined) {
        throw Error(`Incorrect note ${this.frequency} assigned to ${this.ugenName}; this value will be ignored.`);
        return;
      }
      if (obj.isop !== true) {
        obj.inputs[0] = freq;
      } else {
        obj.inputs[1] = freq;
        Gibberish.dirty(this);
      }
      this.frequency = obj;
    } else {
      this.frequency = freq;
    }

    if (loudness !== null) {
      this.__triggerLoudness = loudness;
    }

    this.env.trigger();
  },

  trigger(loudness = 1) {
    if (isNaN(loudness)) {
      throw Error(`A non-number was passed to trigger() on ${this.ugenName}; this value will be ignored and the envelope will not be triggered.`);
    } else {
      this.__triggerLoudness = loudness;
      this.env.trigger();
    }
  }

});

module.exports = instrument

},{"../ugen.js":210}],182:[function(require,module,exports){
module.exports = function( Gibberish ) {

const instruments = {
  Kick        : require( './kick.js' )( Gibberish ),
  Clave       : require( './conga.js' )( Gibberish )[0], // clave is same as conga with different defaults, see below
  Hat         : require( './hat.js' )( Gibberish ),
  Snare       : require( './snare.js' )( Gibberish ),
  Cowbell     : require( './cowbell.js' )( Gibberish ),
  Tom         : require( './tom.js' )( Gibberish ),
  Clap        : require( './clap.dsp.js' )( Gibberish ),
  Multisampler: require( './multisampler.dsp.js' )( Gibberish ),
  Soundfont   : require( './soundfont.js' )( Gibberish )
}

instruments.Clave.defaults.frequency = 2500
instruments.Clave.defaults.decay = .5;

[ instruments.Synth, instruments.PolySynth ]     = require( './synth.dsp.js' )( Gibberish );
[ instruments.Complex, instruments.PolyComplex]  = require( './complex.dsp.js' )( Gibberish );
[ instruments.Monosynth, instruments.PolyMono ]  = require( './monosynth.dsp.js' )( Gibberish );
[ instruments.FM, instruments.PolyFM ]           = require( './fm.dsp.js' )( Gibberish );
[ instruments.Sampler, instruments.PolySampler ] = require( './sampler.js' )( Gibberish );
[ instruments.Karplus, instruments.PolyKarplus ] = require( './karplusstrong.js' )( Gibberish );
[ instruments.Conga, instruments.PolyConga ]     = require( './conga.js' )( Gibberish )

instruments.export = target => {
  for( let key in instruments ) {
    if( key !== 'export' ) {
      target[ key ] = instruments[ key ]
    }
  }
}

return instruments

}

},{"./clap.dsp.js":175,"./complex.dsp.js":176,"./conga.js":177,"./cowbell.js":178,"./fm.dsp.js":179,"./hat.js":180,"./karplusstrong.js":183,"./kick.js":184,"./monosynth.dsp.js":185,"./multisampler.dsp.js":186,"./sampler.js":189,"./snare.js":190,"./soundfont.js":191,"./synth.dsp.js":192,"./tom.js":193}],183:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Karplus = inputProps => {

    const props = Object.assign( {}, Karplus.defaults, inputProps )
    let syn = Object.create( instrument )
    
    let sampleRate = Gibberish.ctx.sampleRate 

    const trigger = g.bang(),
          // high initialValue stops triggering on initialization
          phase = g.accum( 1, trigger, { shouldWrapMax:false, initialValue:1000000 } ),
          env = g.gtp( g.sub( 1, g.div( phase, 200 ) ), 0 ),
          impulse = g.mul( g.noise(), env ),
          feedback = g.history(),
          frequency = g.in('frequency'),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFrequency = g.slide( frequency, glide, glide ),
          delay = g.delay( g.add( impulse, feedback.out ), g.div( sampleRate, slidingFrequency )),
          decayed = g.mul( delay, g.t60( g.mul( g.in('decay'), slidingFrequency ) ) ),
          damped =  g.mix( decayed, feedback.out, g.in('damping') ),
          n = g.noise(),
          blendValue = g.switch( g.gt( n, g.in('blend') ), -1, 1 ), 
          withGain = g.mul( g.mul( blendValue, damped ), g.mul( g.mul( g.in('loudness'), g.in('__triggerLoudness') ), g .in('gain') ) )

    feedback.in( damped )

    const properties = Object.assign( {}, Karplus.defaults, props )

    Object.assign( syn, {
      properties : props,

      env : trigger,
      phase,

      getPhase() {
        return Gibberish.memory.heap[ phase.memory.value.idx ]
      },
    })

    if( properties.panVoices ) {  
      const panner = g.pan( withGain, withGain, g.in( 'pan' ) )
      syn = Gibberish.factory( syn, [panner.left, panner.right], ['instruments','karplus'], props  )
      syn.isStereo = true
    }else{
      syn = Gibberish.factory( syn, withGain, ['instruments','karplus'], props )
      syn.isStereo = false 
    }

    return syn
  }
  
  Karplus.defaults = {
    decay: .97,
    damping:.2,
    gain: .15,
    frequency:220,
    pan: .5,
    glide:1,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    blend:1
  }

  let envCheckFactory = ( syn,synth ) => {
    let envCheck = ()=> {
      let phase = syn.getPhase(),
          endTime = synth.decay * sampleRate

      if( phase > endTime ) {
        synth.disconnectUgen( syn )
        syn.isConnected = false
        Gibberish.memory.heap[ syn.phase.memory.value.idx ] = 0 // trigger doesn't seem to reset for some reason
      }else{
        Gibberish.blockCallbacks.push( envCheck )
      }
    }
    return envCheck
  }

  const PolyKarplus = Gibberish.PolyTemplate( Karplus, ['frequency','decay','damping','pan','gain', 'glide','loudness', '__triggerLoudness'], envCheckFactory ) 
  PolyKarplus.defaults = Karplus.defaults

  return [ Karplus, PolyKarplus ]

}

},{"./instrument.js":181,"genish.js":51}],184:[function(require,module,exports){
let g = require( 'genish.js' ),
    instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Kick = inputProps => {
    // establish prototype chain
    const kick = Object.create( instrument )

    // define inputs
    const frequency = g.in( 'frequency' ),
          decay = g.in( 'decay' ),
          tone  = g.in( 'tone' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          Loudness = g.mul( loudness, triggerLoudness )
    
    // create initial property set
    const props = Object.assign( {}, Kick.defaults, inputProps )
    Object.assign( kick, props )

    // create DSP graph
    const trigger = g.bang(),
          impulse = g.mul( trigger, 60 ),
          scaledDecay = g.sub( 1.005, decay ), // -> range { .005, 1.005 }
          scaledTone = g.add( 50, g.mul( tone, g.mul(4000, Loudness ) ) ), // -> range { 50, 4050 }
          bpf = g.svf( impulse, frequency, scaledDecay, 2, false ),
          lpf = g.svf( bpf, scaledTone, .5, 0, false ),
          graph = g.mul( lpf, g.mul( gain, Loudness ) )
    
    kick.env = trigger
    const out = Gibberish.factory( kick, graph, ['instruments','kick'], props  )

    return out
  }
  
  Kick.defaults = {
    gain: 1,
    frequency:85,
    tone: .25,
    decay:.9,
    loudness:1,
    __triggerLoudness:1
  }

  return Kick

}

},{"./instrument.js":181,"genish.js":51}],185:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' ),
      feedbackOsc = require( '../oscillators/fmfeedbackosc.js' )

module.exports = function( Gibberish ) {

  const Mono = argumentProps => {
    const syn = Object.create( instrument ),
          oscs = [], 
          frequency = g.in( 'frequency' ),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.memo( g.slide( frequency, glide, glide ) ),
          attack = g.in( 'attack' ), decay = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          Loudness = g.mul( loudness, triggerLoudness ),
          saturation = g.in( 'saturation' )

    const props = Object.assign( {}, Mono.defaults, argumentProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )

      for( let i = 0; i < 3; i++ ) {
        let osc, freq

        switch( i ) {
          case 1:
            freq = g.add( slidingFreq, g.mul( slidingFreq, g.in('detune2') ) )
            break;
          case 2:
            freq = g.add( slidingFreq, g.mul( slidingFreq, g.in('detune3') ) )
            break;
          default:
            freq = slidingFreq
        }

        osc = Gibberish.oscillators.factory( syn.waveform, freq, syn.antialias )
        
        oscs[ i ] = osc
      }


      //const baseCutoffFreq = g.in('cutoff') * (frequency /  (g.gen.samplerate / 16 ))
      //const cutoff = baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness ) * env 
      const oscSum = g.add( ...oscs ),
            // XXX horrible hack below to "use" saturation even when not using a diode filter 
            oscWithEnv = props.filterModel=== 2 ? g.mul( oscSum, env ) : g.sub( g.add( g.mul( oscSum, env), saturation ), saturation ),
            baseCutoffFreq = g.mul( g.in('cutoff'), g.div( frequency, g.gen.samplerate / 16 ) ),
            cutoff = g.mul( g.mul( baseCutoffFreq, g.pow( 2, g.mul( g.in('filterMult'), Loudness ) )), env ),
            filteredOsc = Gibberish.filters.factory( oscWithEnv, cutoff, g.in('saturation'), syn )
        
      if( props.panVoices ) {  
        const panner = g.pan( filteredOsc,filteredOsc, g.in( 'pan' ) )
        syn.graph = [ g.mul( panner.left, g.in('gain'), Loudness ), g.mul( panner.right, g.in('gain'), Loudness ) ]
        syn.isStereo = true
      }else{
        syn.graph = g.mul( filteredOsc, g.in('gain'), Loudness )
        syn.isStereo = false
      }

      syn.env = env
    }

    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel', 'filterMode' ]
    syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments','Monosynth'], props )

    return out
  } 
  
  Mono.defaults = {
    waveform: 'saw',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .25,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    detune2:.005,
    detune3:-.005,
    cutoff: .5,
    Q: .25,
    panVoices:false,
    glide: 1,
    antialias:false,
    //filterType: 1,
    filterModel: 1,
    filterMode: 0, // 0 = LP, 1 = HP, 2 = BP, 3 = Notch
    saturation:.5,
    filterMult: 2,
    loudness:1,
    __triggerLoudness:1
  }

  let PolyMono = Gibberish.PolyTemplate( Mono, 
    [ 'frequency','attack','decay','cutoff','Q',
      'detune2','detune3','pulsewidth','pan','gain', 
      'glide', 'saturation', 'filterMult',  'antialias', 
      'filterModel', 'waveform', 'filterMode', 'loudness', '__triggerLoudness' ]
  ) 
  PolyMono.defaults = Mono.defaults

  return [ Mono, PolyMono ]
}

},{"../oscillators/fmfeedbackosc.js":201,"./instrument.js":181,"genish.js":51}],186:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}
  
  Object.assign( proto, {
    pickFile( sample ) {
      this.currentSample = sample
    },
    pick( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
    },
    pickplay( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
      return this.trigger()
    },
    note( rate ) {
      //this.rate = rate
      return this.trigger( null, rate )
    },
    setpan( num=0, value=.5 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.pan.memory.values.idx )
        voice.pan = value
      }
    },
    setrate( num=0, value=1 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.rate.memory.values.idx )
        voice.rate = value
      }
    },
    trigger( volume=null, rate=null ) {
      'no jsdsp'
      if( volume !== null ) this.__triggerLoudness = volume

      let voice = null
      if( Gibberish.mode === 'processor' ) {
        const sampler = this.samplers[ this.currentSample ]

        // if sample isn't loaded...
        if( sampler === undefined ) return

        voice = this.__getVoice__()

        // set voice buffer length
        g.gen.memory.heap[ voice.bufferLength.memory.values.idx ] = sampler.dataLength

        // set voice data index
        g.gen.memory.heap[ voice.bufferLoc.memory.values.idx ] = sampler.dataIdx

        //if( rate !== null ) g.gen.memory.heap[ voice.rate.memory.values.idx ] = rate
        if( rate !== null ) voice.rate = rate
        if( rate > 0 ) {
          voice.trigger()
        }else{
          //console.log( 'reverse?', rate )
          voice.bang.trigger()
          //voice.phase.value = 0
          voice.phase.value = sampler.dataLength - 1
          //console.log( 'phase', voice.phase.value )
        }
        //if( rate < 0 ) {
        //  const phase = sampler.dataIdx + Math.round((sampler.dataLength/2)) - 1
        //  console.log( 'phase:', phase, 'length:', sampler.dataLength, 'start:', sampler.dataIdx )
        //  //voice.phase.value = phase
        //  //g.gen.memory.heap[ voice.phase.memory.value.idx ] = phase
        //}else{
        //  // will reset phase to 0
        //  voice.trigger()
        //}
        
        //voice.trigger()
        //g.gen.memory.heap[ voice.rate.memory.values.idx ] = rate
      }

      return voice
    },
    __getVoice__() {
      return this.voices[ this.voiceCount++ % this.voices.length ]
    },
  })

  const Sampler = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null, voiceCount:0, files:[] }, Sampler.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Multisampler'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    const voices = []
    for( let i = 0; i < syn.maxVoices; i++ ) {
      'use jsdsp'

      const voice = {
        bufferLength: g.data( [1], 1, { meta:true }),
        bufferLoc:    g.data( [1], 1, { meta:true }),
        bang: g.bang(),
        // XXX how do I change this from main thread?
        __pan: g.data( [.5], 1, { meta:true }),
        __rate: g.data( [1], 1, { meta:true }),
        __shouldLoop: g.data( [1], 1, { meta:true }),
        __loudness:  g.data( [1], 1, { meta:true }),
        get loudness() { 
          return g.gen.memory.heap[ this.__loudness.memory.values.idx   ]
        },
        set loudness( v ) {
          g.gen.memory.heap[ this.__loudness.memory.values.idx ] = v
        },
        set pan(v) {
          g.gen.memory.heap[ this.__pan.memory.values.idx ] = v
        },
        set rate(v) {
          g.gen.memory.heap[ this.__rate.memory.values.idx ] = v
        },
      }

      voice.phase = g.counter( 
        rate * voice.__rate[0], 
        start * voice.bufferLength[0],
        end * voice.bufferLength[0], 
        voice.bang,
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )

      voice.trigger = voice.bang.trigger

      voice.graph = g.ifelse(
        // if phase is greater than start and less than end... 
        g.and( 
          g.gte( voice.phase, start * voice.bufferLength[0] ), 
          g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
        ),
        // ...read data
        voice.peek = g.peekDyn( 
          voice.bufferLoc[0], 
          voice.bufferLength[0],
          voice.phase,
          { mode:'samples' }
        ),
        // ...else return 0
        0
      ) 
      * loudness 
      * voice.__loudness[0] 

      const pan = g.pan( voice.graph, voice.graph, voice.__pan[0] )
      voice.graph = [ pan.left, pan.right ]

      voices.push( voice )
    }

    // load in sample data
    const samplers = {}

    // bound to individual sampler objects in loadSample function
    syn.loadBuffer = function( buffer, onload ) {
      // main thread: when sample is loaded, copy it over message port
      // processor thread: onload is called via messageport handler, and
      // passed in the new buffer to be copied.
      if( Gibberish.mode === 'worklet' ) {
        const memIdx = Gibberish.memory.alloc( this.data.buffer.length, true )

        Gibberish.worklet.port.postMessage({
          address:'copy_multi',
          id:     syn.id,
          buffer: this.data.buffer,
          filename: this.filename
        })

        if( typeof onload === 'function' ) onload( this, buffer )

      }else if( Gibberish.mode === 'processor' ) {
        this.data.buffer = buffer 

        // set data memory spec before issuing memory request
        this.dataLength = this.data.memory.values.length = this.data.dim = this.data.buffer.length

        // request memory to copy the bufer over
        g.gen.requestMemory( this.data.memory, false )
        g.gen.memory.heap.set( this.data.buffer, this.data.memory.values.idx )

        // set location of buffer (does not work)
        this.dataIdx = this.data.memory.values.idx

        syn.currentSample = this.filename
      }
    }

    syn.loadSample = function( filename, __onload, buffer=null ) {
      'use jsdsp'

      const sampler = samplers[ filename ] = {
        dataLength: null,
        dataIdx: null,
        buffer: null,
        filename
      }

      const onload = syn.loadBuffer.bind( sampler ) 
      // passing a filename to data will cause it to be loaded in the main thread
      // onload will then be called to pass the buffer over the messageport. In the
      // processor thread, make a placeholder until data is available.
      if( Gibberish.mode === 'worklet' ) {
        sampler.data = g.data( buffer !== null ? buffer : filename, 1, { onload })

        // check to see if a promise is returned; a valid
        // data object is only return if the file has been
        // previously loaded and the corresponding buffer has
        // been cached.
        if( sampler.data instanceof Promise ) {
          sampler.data.then( d => {
            sampler.data = d
            memo[ filename ] = sampler.data 
            onload( sampler, __onload )
          })
        }else{
          // using a cached data buffer, no need
          // for asynchronous loading.
          memo[ filename ] = sampler
          onload( sampler, __onload )
        }     
      }else{
        sampler.data = g.data( new Float32Array(), 1, { onload, filename })
        sampler.data.onload = onload
      } 
    }

    props.files.forEach( filename => syn.loadSample( filename ) )

    syn.__createGraph = function() {
      'use jsdsp'
      
      const graphs = voices.map( voice => voice.graph )
      const left = g.add( ...voices.map( voice => voice.graph[0] ) )
      const right = g.add( ...voices.map( voice => voice.graph[1] ) )
      const gain = g.in( 'gain' )
      syn.graph = [ left * gain, right * gain ]

      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph[0], syn.graph[1], g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    syn.__createGraph()

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','multisampler'], 
      props 
    ) 

    Gibberish.preventProxy = true
    Gibberish.proxyEnabled = false

    out.voices = voices
    out.samplers = samplers

    Gibberish.proxyEnabled = true
    Gibberish.preventProxy = false

    return out
  }

  Sampler.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    shouldLoop:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    maxVoices:5, 
    __triggerLoudness:1
  }

  return Sampler
}

},{"./instrument.js":181,"genish.js":51}],187:[function(require,module,exports){
// XXX TOO MANY GLOBAL GIBBERISH VALUES

const Gibberish = require( '../index.js' )

module.exports = {
  note( freq ) {
    // will be sent to processor node via proxy method...
    if( Gibberish.mode !== 'worklet' ) {
      let voice = this.__getVoice__()
      //Object.assign( voice, this.properties )
      //if( gain === undefined ) gain = this.gain
      //voice.gain = gain
      voice.__triggerLoudness = this.__triggerLoudness
      voice.note( freq, this.__triggerLoudness )
      this.__runVoice__( voice, this )
      this.triggerNote = freq
    }
  },

  // XXX this is not particularly satisfying...
  // must check for both notes and chords
  trigger( loudness ) {
    if( this.triggerChord !== null ) {
      this.triggerChord.forEach( v => {
        let voice = this.__getVoice__()
        Object.assign( voice, this.properties )
        voice.note( v, loudness )
        this.__runVoice__( voice, this )
      })
    }else if( this.triggerNote !== null ) {
      let voice = this.__getVoice__()
      Object.assign( voice, this.properties )
      voice.note( this.triggerNote, loudness )
      this.__runVoice__( voice, this )
    }else{
      let voice = this.__getVoice__()
      Object.assign( voice, this.properties )
      voice.trigger( loudness )
      this.__runVoice__( voice, this )
    }
  },

  __runVoice__( voice, _poly ) {
    if( !voice.isConnected ) {
      voice.connect( _poly )
      voice.isConnected = true
    }

    //let envCheck
    //if( _poly.envCheck === undefined ) {
    //  envCheck = function() {
    //    if( voice.env.isComplete() ) {
    //      _poly.disconnectUgen( voice )
    //      voice.isConnected = false
    //    }else{
    //      Gibberish.blockCallbacks.push( envCheck )
    //    }
    //  }
    //}else{
    //  envCheck = _poly.envCheck( voice, _poly )
    //}

    // XXX uncomment this line to turn on dynamically connecting
    // disconnecting individual voices from graph
    //Gibberish.blockCallbacks.push( envCheck )
  },

  __getVoice__() {
    return this.voices[ this.voiceCount++ % this.voices.length ]
  },

  chord( frequencies ) {
    // will be sent to processor node via proxy method...
    if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
      frequencies.forEach( v => this.note( v ) )
      this.triggerChord = frequencies
    }
  },

  free() {
    for( let child of this.voices ) child.free()
  },

  triggerChord:null,
  triggerNote:null
}

},{"../index.js":174}],188:[function(require,module,exports){
/*
 * This files creates a factory generating polysynth constructors.
 */

const g = require( 'genish.js' )
const __proxy = require( '../workletProxy.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )

  const TemplateFactory = ( ugen, propertyList, _envCheck ) => {

    const Template = props => {
      const properties = Object.assign( {}, { isStereo:true, maxVoices:4 }, props )

      //const synth = properties.isStereo === true ? Object.create( stereoProto ) : Object.create( monoProto )
      const synth = properties.isStereo === true ? Gibberish.Bus2({ __useProxy__:false }) : Gibberish.Bus({ __useProxy__:false }) 

      Object.assign( 
        synth, 

        {
          maxVoices: properties.maxVoices, 
          voiceCount: 0,
          envCheck: _envCheck,
          dirty: true,
          ugenName: 'poly' + ugen.name + '_' + synth.id + '_' + ( properties.isStereo ? 2 : 1 ),
          properties
        },

        Gibberish.mixins.polyinstrument
      )

      properties.panVoices = true//false//properties.isStereo
      synth.callback.ugenName = synth.ugenName

      const storedId = properties.id
      if( properties.id !== undefined ) delete properties.id 

      const voices = []
      for( let i = 0; i < synth.maxVoices; i++ ) {
        properties.id = synth.id +'_'+i
        voices[i] = ugen( properties )
        if( Gibberish.mode === 'processor' )
          voices[i].callback.ugenName = voices[i].ugenName

        voices[i].isConnected = false
        //synth.__voices[i] = proxy( ['instruments', ugen.name], properties, synth.voices[i] )
      }

      let _propertyList 
      if( properties.isStereo === false ) {
        _propertyList = propertyList.slice( 0 )
        const idx =  _propertyList.indexOf( 'pan' )
        if( idx  > -1 ) _propertyList.splice( idx, 1 )
      }

      properties.id = storedId

      TemplateFactory.setupProperties( synth, ugen, properties.isStereo ? propertyList : _propertyList )
      
      const p = proxy( ['instruments', 'Poly'+ugen.name], properties, synth ) 

      // proxy workaround nightmare... if we include the voices when we create
      // the proxy, they wind up being strangely unaddressable. perhaps they
      // are being overwritting in the Processor.ugens map object?
      // manually adding each one seems to work around the problem
      if( Gibberish.mode === 'worklet' ) {
        p.voices = []
        let count = 0
        for( let v of voices ) {
          Gibberish.worklet.port.postMessage({
            address: 'addObjectToProperty',
            object: synth.id,
            name:'voices',
            key:count,
            value:v.id
          })

          p.voices[ count ] = v
          count++
        }
      }

      return p 
    }

    return Template
  }

  TemplateFactory.setupProperties = function( synth, ugen, props ) {
    for( let property of props ) {
      if( property === 'pan' || property === 'id' ) continue
      Object.defineProperty( synth, property, {
        configurable:true,
        get() {
          return synth.properties[ property ] || ugen.defaults[ property ]
        },
        set( v ) {
          synth.properties[ property ] = v
          for( let child of synth.voices ) {
            child[ property ] = v
          }
        }
      })
    }
  }

  return TemplateFactory

}

},{"../workletProxy.js":212,"genish.js":51}],189:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}

  Object.assign( proto, {
    note( rate ) {
      this.rate = rate
      if( rate > 0 ) {
        this.__trigger()
      }else{
        this.__phase__.value = this.end * (this.data.buffer.length - 1)
      }
    },
    trigger( volume ) {
      if( volume !== undefined ) this.gain = volume

      if( Gibberish.mode === 'processor' ) {
        // if we're playing the sample forwards...
        if( Gibberish.memory.heap[ this.__rateStorage__.memory.values.idx ] > 0 ) {
          this.__trigger()
        }else{
          this.__phase__.value = this.end * (this.data.buffer.length - 1)
        }
      }
    },
  })

  const Sampler = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null }, Sampler.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          bufferLength = g.in( 'bufferLength' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Sampler'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    syn.__createGraph = function() {
      syn.__bang__ = g.bang()
      syn.__trigger = syn.__bang__.trigger

      syn.__phase__ = g.counter( 
        rate, 
        g.mul(start,bufferLength), 
        g.mul( end, bufferLength ), 
        syn.__bang__, 
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )
      
      syn.__rateStorage__ = rateStorage
      rateStorage[0] = rate

      // XXX we added our recorded 'rate' param and then effectively subtract it,
      // so that its presence in the graph will force genish to actually record the 
      // rate as the input. this is extremely hacky... there should be a way to record
      // value without having to include it in the graph!
      syn.graph = g.add( g.mul( 
        g.ifelse( 
          g.and( g.gte( syn.__phase__, g.mul(start,bufferLength) ), g.lt( syn.__phase__, g.mul(end,bufferLength) ) ),
          g.peek( 
            syn.data, 
            syn.__phase__,
            { mode:'samples' }
          ),
          0
        ), 
        g.mul( g.mul( loudness, triggerLoudness ), g.in('gain') )
      ), rateStorage[0], g.mul( rateStorage[0], -1 ) )
      
      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph, syn.graph, g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    const onload = (buffer,filename) => {
      if( buffer === undefined ) return
      if( Gibberish.mode === 'worklet' ) {
        //const memIdx = memo[ filename ].idx !== undefined ? memo[ filename ].idx : Gibberish.memory.alloc( syn.data.memory.values.length, true )

        const memIdx = Gibberish.memory.alloc( buffer.length, true )
        //memo[ filename ].idx = memIdx

        Gibberish.worklet.port.postMessage({
          address:'copy',
          id:     syn.id,
          idx:    memIdx,
          buffer
        })

      }else if ( Gibberish.mode === 'processor' ) {
        syn.data.buffer = buffer
        syn.data.memory.values.length = syn.data.dim = buffer.length
        syn.__redoGraph() 
      }

      if( typeof syn.onload === 'function' ){  
        syn.onload( buffer || syn.data.buffer )
      }
      if( syn.bufferLength === -999999999 && syn.data.buffer !== undefined ) syn.bufferLength = syn.data.buffer.length - 1
    }

    //if( props.filename ) {
    syn.loadFile = function( filename ) {
      //if( memo[ filename ] === undefined ) {
        if( Gibberish.mode !== 'processor' ) {
          syn.data = g.data( filename, 1, { onload })


          // check to see if a promise is returned; a valid
          // data object is only return if the file has been
          // previously loaded and the corresponding buffer has
          // been cached.
          if( syn.data instanceof Promise ) {
            syn.data.then( d => {
              syn.data = d
              memo[ filename ] = syn.data
              onload( d.buffer, filename )
            })
          }else{
            // using a cached data buffer, no need
            // for asynchronous loading.
            memo[ filename ] = syn.data
            onload( syn.data.buffer, filename )
          }     
        }else{
          syn.data = g.data( new Float32Array(), 1, { onload, filename })
          //memo[ filename ] = syn.data
        }
      //}else{
      //  syn.data = memo[ filename ]
      //  console.log( 'memo data:', syn.data )
      //  onload( syn.data.buffer, filename )
      //}
    }

    syn.loadBuffer = function( buffer ) {
      if( Gibberish.mode === 'processor' ) {
        syn.data.buffer = buffer
        syn.data.memory.values.length = syn.data.dim = buffer.length
        syn.__redoGraph() 
      }
    }

    if( props.filename !== undefined ) {
      syn.loadFile( props.filename )
    }else{
      syn.data = g.data( new Float32Array() )
    }

    if( syn.data !== undefined ) {
      syn.data.onload = onload

      syn.__createGraph()
    }

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','sampler'], 
      props 
    ) 

    return out
  }

  Sampler.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    __triggerLoudness:1
  }

  const envCheckFactory = function( voice, _poly ) {
    const envCheck = () => {
      const phase = Gibberish.memory.heap[ voice.__phase__.memory.value.idx ]
      if( ( voice.rate > 0 && phase > voice.end ) || ( voice.rate < 0 && phase < 0 ) ) {
        _poly.disconnectUgen.call( _poly, voice )
        voice.isConnected = false
      }else{
        Gibberish.blockCallbacks.push( envCheck )
      }
    }

    return envCheck
  }

  const PolySampler = Gibberish.PolyTemplate( Sampler, ['rate','pan','gain','start','end','loops','bufferLength','__triggerLoudness','loudness'], envCheckFactory ) 

  return [ Sampler, PolySampler ]
}


},{"./instrument.js":181,"genish.js":51}],190:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )
  
module.exports = function( Gibberish ) {

  const Snare = argumentProps => {
    const snare = Object.create( instrument ),
          decay = g.in( 'decay' ),
          scaledDecay = g.mul( decay, g.gen.samplerate * 2 ),
          snappy= g.in( 'snappy' ),
          tune  = g.in( 'tune' ),
          gain  = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in('__triggerLoudness'),
          Loudness = g.mul( loudness, triggerLoudness ),
          eg = g.decay( scaledDecay, { initValue:0 } ), 
          check = g.memo( g.gt( eg, .0005 ) ),
          rnd = g.mul( g.noise(), eg ),
          hpf = g.svf( rnd, g.add( 1000, g.mul( g.add( 1, tune), 1000 ) ), .5, 1, false ),
          snap = g.mul( g.gtp( g.mul( hpf, snappy ), 0 ), Loudness ), // rectify
          bpf1 = g.svf( eg, g.mul( 180, g.add( tune, 1 ) ), .05, 2, false ),
          bpf2 = g.svf( eg, g.mul( 330, g.add( tune, 1 ) ), .05, 2, false ),
          out  = g.memo( g.add( snap, bpf1, g.mul( bpf2, .8 ) ) ), //XXX why is memo needed?
          scaledOut = g.mul( out, g.mul( gain, Loudness ) ),
          ife = g.switch( check, scaledOut, 0 ),
          props = Object.assign( {}, Snare.defaults, argumentProps )

    // XXX TODO : make above switch work with ifelse. the problem is that poke ugens put their
    // code at the bottom of the callback function, instead of at the end of the
    // associated if/else block.
    
    snare.env = eg 
    const __snare = Gibberish.factory( snare, ife, ['instruments','snare'], props  )
    
    return __snare
  }
  
  Snare.defaults = {
    gain: .5,
    tune:0,
    snappy: 1,
    decay:.1,
    loudness:1,
    __triggerLoudness:1
  }

  return Snare

}

},{"./instrument.js":181,"genish.js":51}],191:[function(require,module,exports){
/*fetch( '0000_Aspirin_sf2_file.json' )
.then( res => res.json() )
.then( json => {
  window.zones = json.zones
  console.log( window.zones )
})

ab = Gibberish.utilities..decodeArrayBuffer( zones[0].file )
genish.utilities.ctx.decodeAudioData( ab, buffer => {
  __ab = buffer
  console.log( 'buffer made' )
})


_d = data( __ab )
play( peek( _d, phasor(1,0,{min:0}) ) )
*/

const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

const soundfonts = {}

const banks = [
  'Aspirin',
  'Chaos',
  'FluidR3',
  'GeneralUserGS',
  'JCLive'
]

module.exports = function( Gibberish ) {
  const proto = Object.create( instrument )
  const memo = {}
  
  Object.assign( proto, {
    pickFile( sample ) {
      this.currentSample = sample
    },
    pick( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
    },
    pickplay( __idx ) {
      const idx = Math.floor( __idx )
      const keys = Object.keys( this.samplers )
      const key = keys[ idx ]
      this.currentSample = key
      return this.trigger()
    },
    __note( rate, loudness=null ) {
      // soundfont measures pitch in cents
      // originalPitch = findMidiForHz( hz ) * 100 // (100 cents per midi index)
      // rate = Math.pow(2, (100.0 * pitch - originalPitch) / 1200.0) // 1200 cents per octave
      return this.trigger( loudness, rate )
    },
    note( freq, loudness=null ) {
      'no jsdsp'
      const midinote = 69 + 12 * Math.log2( freq/440 )
      this.midinote( midinote, loudness )
    },
    midipick( midinote, loudness ) {
      // loop through zones to find correct sample #
      let idx = 0, pitch = 0
      for( let zone of this.zones ) {
        if( midinote >= zone.keyRangeLow && midinote <= zone.keyRangeHigh ) {
          pitch = zone.originalPitch
          break;
        }
        idx++
      }
      this.pick( idx )
      return pitch
    },
    midinote( midinote, loudness=null ) {
      'no jsdsp'
      const samplePitch = this.midipick( midinote )
      const pitch = Math.pow( 2, (100 * midinote - samplePitch ) / 1200 ) 
      //const pitch = 1//Math.pow( 2, (samplePitch ) ) 
      this.__note( pitch, loudness )
    }, 
    midichord( frequencies ) {
      if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
        frequencies.forEach( v => this.midinote( v ) )
        this.triggerChord = frequencies
      }
    },
    chord( frequencies ) {
      if( Gibberish !== undefined && Gibberish.mode !== 'worklet' ) {
        frequencies.forEach( v => this.note( v ) )
        this.triggerChord = frequencies
      }
    },

    setpan( num=0, value=.5 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.pan.memory.values.idx )
        voice.pan = value
      }
    },
    setrate( num=0, value=1 ) {
      if( Gibberish.mode === 'processor' ) {
        const voice = this.voices[ num ]
        // set voice buffer length
        //g.gen.memory.heap.set( [ value ], voice.rate.memory.values.idx )
        voice.rate = value
      }
    },
    trigger( volume=null, rate=null ) {
      'no jsdsp'
      //if( volume !== null ) this.__triggerLoudness = volume

      let voice = null
      if( Gibberish.mode === 'processor' ) {
        const sampler = this.samplers[ this.currentSample ]

        // if sample isn't loaded...
        if( sampler === undefined ) return

        voice = this.__getVoice__()

        // set voice buffer length
        g.gen.memory.heap[ voice.bufferLength.memory.values.idx ] = sampler.dataLength

        // set voice data index
        g.gen.memory.heap[ voice.bufferLoc.memory.values.idx ] = sampler.dataIdx

        g.gen.memory.heap[ voice.__loopStart.memory.values.idx ] = sampler.zone.loopStart
        g.gen.memory.heap[ voice.__loopEnd.memory.values.idx   ] = sampler.zone.loopEnd

        if( volume !== null )
          g.gen.memory.heap[ voice.loudness.memory.values.idx   ] = volume

        if( rate !== null ) voice.rate = rate 
        
        voice.trigger()
      }

      return voice
    },
    __getVoice__() {
      return this.voices[ this.voiceCount++ % this.voices.length ]
    },
  })

  const Soundfont = inputProps => {
    const syn = Object.create( proto )

    const props = Object.assign( { onload:null, voiceCount:0, files:[] }, Soundfont.defaults, inputProps )

    syn.isStereo = props.isStereo !== undefined ? props.isStereo : false

    const start = g.in( 'start' ), end = g.in( 'end' ), 
          rate = g.in( 'rate' ), shouldLoop = g.in( 'loops' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' ),
          // rate storage is used to determine whether we're playing
          // the sample forward or in reverse, for use in the 'trigger' method.
          rateStorage = g.data([0], 1, { meta:true })

    Object.assign( syn, props )

    if( Gibberish.mode === 'worklet' ) {
      syn.__meta__ = {
        address:'add',
        name: ['instruments', 'Soundfont'],
        properties: JSON.stringify(props), 
        id: syn.id
      }

      Gibberish.worklet.ugens.set( syn.id, syn )

      Gibberish.worklet.port.postMessage( syn.__meta__ )
    }

    // create all our vocecs
    const voices = []
    for( let i = 0; i < syn.maxVoices; i++ ) {
      'use jsdsp'

      const voice = {
        bufferLength: g.data( [1], 1, { meta:true }),
        bufferLoc:    g.data( [1], 1, { meta:true }),
        bang: g.bang(),
        // XXX how do I change this from main thread?
        __pan: g.data( [.5], 1, { meta:true }),
        __rate: g.data( [1], 1, { meta:true }),
        __shouldLoop: g.data( [1], 1, { meta:true }),
        __loopStart: g.data( [1], 1, { meta:true }),
        __loopEnd:   g.data( [1], 1, { meta:true }),
        __loudness:  g.data( [1], 1, { meta:true }),
        get loudness() { 
          return g.gen.memory.heap[ this.__loudness.memory.values.idx   ]
        },
        set loudness( v ) {
          g.gen.memory.heap[ this.__loudness.memory.values.idx ] = v
        },
        set pan(v) {
          g.gen.memory.heap[ this.__pan.memory.values.idx ] = v
        },
        set rate(v) {
          g.gen.memory.heap[ this.__rate.memory.values.idx ] = v
        },
      }

      voice.phase = g.counter( 
        rate * voice.__rate[0], 
        start * voice.bufferLength[0],
        end * voice.bufferLength[0], 
        voice.bang,
        shouldLoop, 
        { shouldWrap:false, initialValue:9999999 }
      )

      voice.trigger = voice.bang.trigger

      voice.graph = g.ifelse(
        // if phase is greater than start and less than end... 
        g.and( 
          g.gte( voice.phase, start * voice.bufferLength[0] ), 
          g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
        ),
        // ...read data
        voice.peek = g.peekDyn( 
          voice.bufferLoc[0], 
          voice.bufferLength[0],
          voice.phase,
          { mode:'samples' }
        ),
        // ...else return 0
        0
      ) 
      * loudness 
      * voice.__loudness[0] 

      // start of attempt to loop sustain...
      //voice.graph = g.ifelse(
      //  // if phase is greater than start and less than end... 
      //  g.and( 
      //    g.gte( voice.phase, start * voice.bufferLength[0] ), 
      //    g.lt(  voice.phase, end   * voice.bufferLength[0] ) 
      //  ),
      //  // ...read data
      //  voice.peek = g.peekDyn( 
      //    voice.bufferLoc[0], 
      //    voice.bufferLength[0],
      //    voice.phase,
      //    { mode:'samples' }
      //  ),
      //  // ...else return 0
      //  g.ifelse(
      //    g.and(
      //      voice.__shouldLoop[0],
      //      g.gt( voice.phase, voice.__loopEnd[0] )
      //    ),
      //    g.peekDyn( 
      //      voice.bufferLoc[0], 
      //      voice.bufferLength[0],
      //      g.add( 
      //        voice.__loopStart[0],
      //        g.mod(
      //          voice.phase,
      //          //g.sub( voice.phase, voice.__loopStart[0] ),
      //          g.sub( voice.__loopEnd[0], voice.__loopStart[0] )
      //        )
      //      ),
      //      { mode:'samples' }
      //    ),
      //    0
      //  )
      //) 
      //* loudness 
      //* triggerLoudness 
      
      const pan = g.pan( voice.graph, voice.graph, voice.__pan[0] )
      voice.graph = [ pan.left, pan.right ]

      voices.push( voice )
    }

    // load in sample data
    const samplers = {}

    // bound to individual sampler objects in loadSample function
    syn.loadBuffer = function( buffer, onload ) {
      // main thread: when sample is loaded, copy it over message port
      // processor thread: onload is called via messageport handler, and
      // passed in the new buffer to be copied.
      if( Gibberish.mode === 'worklet' ) {
        const memIdx = Gibberish.memory.alloc( this.data.buffer.length, true )

        Gibberish.worklet.port.postMessage({
          address:'copy_multi',
          id:     syn.id,
          buffer: this.data.buffer,
          filename: this.filename
        })

        if( typeof onload === 'function' ) onload( this, buffer )

      }else if( Gibberish.mode === 'processor' ) {
        this.data.buffer = buffer 

        // set data memory spec before issuing memory request
        this.dataLength = this.data.memory.values.length = this.data.dim = this.data.buffer.length
        this.zone = syn.zones[ this.filename ]

        // request memory to copy the bufer over
        g.gen.requestMemory( this.data.memory, false )
        g.gen.memory.heap.set( this.data.buffer, this.data.memory.values.idx )

        // set location of buffer (does not work)
        this.dataIdx = this.data.memory.values.idx

        syn.currentSample = this.filename
      }
    }

    syn.loadSample = function( filename, __onload, buffer=null ) {
      'use jsdsp'

      const sampler = samplers[ filename ] = {
        dataLength: null,
        dataIdx: null,
        buffer: null,
        filename
      }

      const onload = syn.loadBuffer.bind( sampler ) 
      // passing a filename to data will cause it to be loaded in the main thread
      // onload will then be called to pass the buffer over the messageport. In the
      // processor thread, make a placeholder until data is available.
      if( Gibberish.mode === 'worklet' ) {
        sampler.data = g.data( buffer !== null ? buffer : filename, 1, { onload })

        // check to see if a promise is returned; a valid
        // data object is only return if the file has been
        // previously loaded and the corresponding buffer has
        // been cached.
        if( sampler.data instanceof Promise ) {
          sampler.data.then( d => {
            sampler.data = d
            memo[ filename ] = sampler.data 
            onload( sampler, __onload )
          })
        }else{
          // using a cached data buffer, no need
          // for asynchronous loading.
          memo[ filename ] = sampler
          sampler.dataLength = buffer.length
          onload( sampler, __onload )
        }     
      }else{
        // not sure if first case will happen with soundfonts (it does with regular multisampler)
        if( buffer === null ) {
          sampler.data = g.data( new Float32Array(), 1, { onload, filename })
          sampler.data.onload = onload
        }else{
          sampler.data = g.data( buffer, 1, { onload, filename })
          //sampler.data.onload = onload
          onload( buffer, __onload )
        }
      }

      return sampler
    }

    syn.load = function( soundNumber=0, bankIndex=0 ) {
      'no jsdsp'

      // need to memoize... already storing in soundfonts
      if( Gibberish.mode === 'processor' ) return

      // in case users pass name of soundfont instead of number
      if( typeof soundNumber === 'string' ) {
        let __soundNumber = Soundfont.names.indexOf( soundNumber )
        if( __soundNumber === -1 ) {
          __soundNumber = 0
          console.warn( `The ${soundNumber} Soundfont can't be found. Using Piano instead.` )
        }
        soundNumber = __soundNumber
      }

      let num = (soundNumber) + '0'
      if( soundNumber < 100 ) num = '0'+num
      if( soundNumber < 10 )  num = '0'+num

      fetch( `${Soundfont.resourcePath}${num}_${banks[bankIndex]}.sf2.json` )
        .then( res => res.json() )
        .then( json => {
          const zones = soundfonts[ soundNumber ] = json.zones
          this.zones = zones
          for( let i = 0; i < zones.length; i++) {
            const zone = zones[i]
            const ab = Gibberish.utilities.base64.decodeArrayBuffer( zone.file )
            g.utilities.ctx.decodeAudioData( ab, buffer => {
              zone.sampler = syn.loadSample( i, null, buffer )
            })
          }
        })
    }

    //props.files.forEach( filename => syn.loadSample( filename ) )

    syn.__createGraph = function() {
      'use jsdsp'
      
      const graphs = voices.map( voice => voice.graph )
      const left = g.add( ...voices.map( voice => voice.graph[0] ) )
      const right = g.add( ...voices.map( voice => voice.graph[1] ) )
      const gain = g.in( 'gain' )
      syn.graph = [ left * gain, right * gain ]

      if( syn.panVoices === true ) { 
        const panner = g.pan( syn.graph[0], syn.graph[1], g.in( 'pan' ) ) 
        syn.graph = [ panner.left, panner.right ]
      }
    }

    syn.__createGraph()

    const out = Gibberish.factory( 
      syn,
      syn.graph,
      ['instruments','soundfont'], 
      props 
    ) 

    Gibberish.preventProxy = true
    Gibberish.proxyEnabled = false

    out.voices = voices
    out.samplers = samplers

    Gibberish.proxyEnabled = true
    Gibberish.preventProxy = false

    return out
  }

  Soundfont.defaults = {
    gain: 1,
    pan: .5,
    rate: 1,
    panVoices:false,
    shouldLoop:false,
    loops: 0,
    start:0,
    end:1,
    bufferLength:-999999999,
    loudness:1,
    maxVoices:5, 
    __triggerLoudness:1
  }

  Soundfont.resourcePath = 'resources/soundfonts/'
  Soundfont.names = [
    "Acoustic Grand Piano",
    "Bright Acoustic Piano",
    "Electric Grand Piano",
    "Honky-tonk Piano",
    "Electric Piano 1",
    "Electric Piano 2",
    "Harpsichord",
    "Clavi",
    "Celesta",
    "Glockenspiel",
    "Music Box",
    "Vibraphone",
    "Marimba",
    "Xylophone",
    "Tubular Bells",
    "Dulcimer",
    "Drawbar Organ",
    "Percussive Organ",
    "Rock Organ",
    "Church Organ",
    "Reed Organ",
    "Accordion",
    "Harmonica",
    "Tango Accordion",
    "Acoustic Guitar (nylon)",
    "Acoustic Guitar (steel)",
    "Electric Guitar (jazz)",
    "Electric Guitar (clean)",
    "Electric Guitar (muted)",
    "Overdriven Guitar",
    "Distortion Guitar",
    "Guitar harmonics",
    "Acoustic Bass",
    "Electric Bass (finger)",
    "Electric Bass (pick)",
    "Fretless Bass",
    "Slap Bass 1",
    "Slap Bass 2",
    "Synth Bass 1",
    "Synth Bass 2",
    "Violin",
    "Viola",
    "Cello",
    "Contrabass",
    "Tremolo Strings",
    "Pizzicato Strings",
    "Orchestral Harp",
    "Timpani",
    "String Ensemble 1",
    "String Ensemble 2",
    "SynthStrings 1",
    "SynthStrings 2",
    "Choir Aahs",
    "Voice Oohs",
    "Synth Voice",
    "Orchestra Hit",
    "Trumpet",
    "Trombone",
    "Tuba",
    "Muted Trumpet",
    "French Horn",
    "Brass Section",
    "SynthBrass 1",
    "SynthBrass 2",
    "Soprano Sax",
    "Alto Sax",
    "Tenor Sax",
    "Baritone Sax",
    "Oboe",
    "English Horn",
    "Bassoon",
    "Clarinet",
    "Piccolo",
    "Flute",
    "Recorder",
    "Pan Flute",
    "Blown Bottle",
    "Shakuhachi",
    "Whistle",
    "Ocarina",
    "Lead 1 (square)",
    "Lead 2 (sawtooth)",
    "Lead 3 (calliope)",
    "Lead 4 (chiff)",
    "Lead 5 (charang)",
    "Lead 6 (voice)",
    "Lead 7 (fifths)",
    "Lead 8 (bass + lead)",
    "Pad 1 (new age)",
    "Pad 2 (warm)",
    "Pad 3 (polysynth)",
    "Pad 4 (choir)",
    "Pad 5 (bowed)",
    "Pad 6 (metallic)",
    "Pad 7 (halo)",
    "Pad 8 (sweep)",
    "FX 1 (rain)",
    "FX 2 (soundtrack)",
    "FX 3 (crystal)",
    "FX 4 (atmosphere)",
    "FX 5 (brightness)",
    "FX 6 (goblins)",
    "FX 7 (echoes)",
    "FX 8 (sci-fi)",
    "Sitar",
    "Banjo",
    "Shamisen",
    "Koto",
    "Kalimba",
    "Bag pipe",
    "Fiddle",
    "Shanai",
    "Tinkle Bell",
    "Agogo",
    "Steel Drums",
    "Woodblock",
    "Taiko Drum",
    "Melodic Tom",
    "Synth Drum",
    "Reverse Cymbal",
    "Guitar Fret Noise",
    "Breath Noise",
    "Seashore",
    "Bird Tweet",
    "Telephone Ring",
    "Helicopter",
    "Applause",
    "Gunshot"
  ]

  Soundfont.inspect = function() {
    console.table( Soundfont.names )
  }

  return Soundfont
}

},{"./instrument.js":181,"genish.js":51}],192:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

const genish = g

module.exports = function( Gibberish ) {

  const Synth = inputProps => {
    const syn = Object.create( instrument )

    const frequency = g.in( 'frequency' ),
          loudness  = g.in( 'loudness' ), 
          triggerLoudness = g.in( '__triggerLoudness' ),
          glide = g.max( 1, g.in( 'glide' ) ),
          slidingFreq = g.slide( frequency, glide, glide ),
          attack = g.in( 'attack' ), decay = g.in( 'decay' ),
          sustain = g.in( 'sustain' ), sustainLevel = g.in( 'sustainLevel' ),
          release = g.in( 'release' )

    const props = Object.assign( {}, Synth.defaults, inputProps )
    Object.assign( syn, props )

    syn.__createGraph = function() {
      const osc = Gibberish.oscillators.factory( syn.waveform, slidingFreq, syn.antialias )

      const env = Gibberish.envelopes.factory( 
        props.useADSR, 
        props.shape, 
        attack, decay, 
        sustain, sustainLevel, 
        release, 
        props.triggerRelease
      )


      // syn.env = env
      // below doesn't work as it attempts to assign to release property triggering codegen...
      syn.advance = ()=> { env.release() }

      {
        'use jsdsp'
        let oscWithEnv = osc * env * loudness * triggerLoudness,
            saturation = g.in('saturation'),
            panner

        // 16 is an unfortunate empirically derived magic number...
        const baseCutoffFreq = g.in('cutoff') * ( frequency /  ( g.gen.samplerate / 16 ) ) 
        const cutoff = g.min( baseCutoffFreq * g.pow( 2, g.in('filterMult') * loudness * triggerLoudness ) * env, .995 ) 
        const filteredOsc = Gibberish.filters.factory( oscWithEnv, cutoff, saturation, props )

        let synthWithGain = filteredOsc * g.in( 'gain' )
        
        // XXX This line has to be here for correct code generation to work when
        // saturation is not being used... obviously this should cancel out. 
        if( syn.filterModel !== 2 ) synthWithGain = synthWithGain + saturation - saturation
    
        if( syn.panVoices === true ) { 
          panner = g.pan( synthWithGain, synthWithGain, g.in( 'pan' ) ) 
          syn.graph = [ panner.left, panner.right ]
          syn.isStereo = true
        }else{
          syn.graph = synthWithGain
          syn.isStereo = false
        }

        syn.env = env
        syn.osc = osc
        syn.filter = filteredOsc
      }

      return env

    }
    
    syn.__requiresRecompilation = [ 'waveform', 'antialias', 'filterModel','filterMode', 'useADSR', 'shape' ]
    const env = syn.__createGraph()

    const out = Gibberish.factory( syn, syn.graph, ['instruments', 'synth'], props, null, true, ['saturation']  )

    out.env.advance = out.advance 

    return out
  }
  
  Synth.defaults = {
    waveform:'saw',
    attack: 44,
    decay: 22050,
    sustain:44100,
    sustainLevel:.6,
    release:22050,
    useADSR:false,
    shape:'linear',
    triggerRelease:false,
    gain: .5,
    pulsewidth:.25,
    frequency:220,
    pan: .5,
    antialias:false,
    panVoices:false,
    loudness:1,
    __triggerLoudness:1,
    glide:1,
    saturation:1,
    filterMult:2,
    Q:.25,
    cutoff:.5,
    filterModel:1,
    filterMode:0
  }

  // do not include velocity, which shoudl always be per voice
  let PolySynth = Gibberish.PolyTemplate( Synth, ['frequency','attack','decay','pulsewidth','pan','gain','glide', 'saturation', 'filterMult', 'Q', 'cutoff', 'resonance', 'antialias', 'filterModel', 'waveform', 'filterMode', '__triggerLoudness', 'loudness'] ) 
  PolySynth.defaults = Synth.defaults

  return [ Synth, PolySynth ]

}

},{"./instrument.js":181,"genish.js":51}],193:[function(require,module,exports){
const g = require( 'genish.js' ),
      instrument = require( './instrument.js' )

module.exports = function( Gibberish ) {

  const Tom = argumentProps => {
    let tom = Object.create( instrument )
    
    const decay   = g.in( 'decay' ),
          pitch   = g.in( 'frequency' ),
          gain    = g.in( 'gain' ),
          loudness = g.in( 'loudness' ),
          triggerLoudness = g.in( '__triggerLoudness' )

    const props = Object.assign( {}, Tom.defaults, argumentProps )

    const trigger = g.bang(),
          impulse = g.mul( trigger, 1 ),
          eg = g.decay( g.mul( decay, g.gen.samplerate * 2 ), { initValue:0 } ), 
          bpf = g.mul( g.svf( impulse, pitch, .0175, 2, false ), 10 ),
          noise = g.gtp( g.noise(), 0 ), // rectify noise
          envelopedNoise = g.mul( noise, eg ),
          lpf = g.mul( g.svf( envelopedNoise, 120, .5, 0, false ), 2.5 ),
          out = g.mul( g.add( bpf, lpf ), g.mul( gain, g.mul( loudness, triggerLoudness ) ) )

    tom.env = {
      trigger: function() {
        eg.trigger()
        trigger.trigger()
      }
    }

    tom.isStereo = false

    tom = Gibberish.factory( tom, out, ['instruments', 'tom'], props  )
    
    return tom
  }
  
  Tom.defaults = {
    gain: 1,
    decay:.7,
    frequency:120,
    loudness:1,
    __triggerLoudness:1
  }

  return Tom
}

},{"./instrument.js":181,"genish.js":51}],194:[function(require,module,exports){
const ugenproto = require( '../ugen.js' )(),
     __proxy     = require( '../workletProxy.js' ),
     g = require( 'genish.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )

  const createProperties = function( p, id ) {
    for( let i = 0; i < 2; i++ ) {
      Object.defineProperty( p, i, {
        configurable:true,
        get() { return p.inputs[ i ] },
        set(v) {
          p.inputs[ i ] = v
          if( Gibberish.mode === 'worklet' ) {
            if( typeof v === 'number' ) {
              Gibberish.worklet.port.postMessage({ 
                address:'addToProperty', 
                object:id,
                name:'inputs',
                key:i,
                value:v
              })
            }else{
              Gibberish.worklet.port.postMessage({ 
                address:'addObjectToProperty', 
                object:id,
                name:'inputs',
                key:i,
                value:v.id
              })
            }
            Gibberish.worklet.port.postMessage({
              address:'dirty',
              id
            })
          }
        }
      })
    }
  }

  const Binops = {
    export( obj ) {
      for( let key in Binops ) {
        if( key !== 'export' ) {
          obj[ key ] = Binops[ key ]
        }
      }
    },
    
    Add( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'+', inputs:args, ugenName:'add' + id, id, isStereo } )
      
      const p = proxy( ['binops','Add'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },

    Sub( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'-', inputs:args, ugenName:'sub' + id, id, isStereo } )

      return proxy( ['binops','Sub'], { isop:true, inputs:args }, ugen )
    },

    Mul( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'*', inputs:args, ugenName:'mul' + id, id, isStereo } )

      const p = proxy( ['binops','Mul'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )
      return p
    },

    Div( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'/', inputs:args, ugenName:'div' + id, id, isStereo} )
    
      const p = proxy( ['binops','Div'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },

    Mod( ...args ) {
      const id = Gibberish.factory.getUID()
      const ugen = Object.create( ugenproto )
      const isStereo = Gibberish.__isStereo( args[0] ) || Gibberish.__isStereo( args[1] )
      Object.assign( ugen, { isop:true, op:'%', inputs:args, ugenName:'mod' + id, id, isStereo} )

      const p = proxy( ['binops','Mod'], { isop:true, inputs:args }, ugen )
      createProperties( p, id )

      return p
    },   
  }

  for( let key in Binops ) {
    Binops[ key ].defaults = { 0:0, 1:0 }
  }

  return Binops
}

},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],195:[function(require,module,exports){
let g = require( 'genish.js' ),
    ugen = require( '../ugen.js' )(),
    __proxy= require( '../workletProxy.js' )

module.exports = function( Gibberish ) {
  const proxy = __proxy( Gibberish )
  const Bus = Object.create( ugen )

  Object.assign( Bus, {
    gain: {
      set( v ) {
        this.mul.inputs[ 1 ] = v
        Gibberish.dirty( this )
      },
      get() {
        return this.mul[ 1 ]
      }
    },

    __addInput( input ) {
      this.sum.inputs.push( input )
      Gibberish.dirty( this )
    },

    create( _props ) {
      const props = Object.assign({}, Bus.defaults, { inputs:[0] }, _props )

      // MUST PREVENT PROXY
      // Othherwise these binops are created in the worklet and sent
      // across the thread to be instantiated, and then instantiated again
      // when the bus is created in the processor thread, messing up the various
      // uids involved. By preventing proxying the binops are only created
      // a single time when the bus is sent across the thread.
      Gibberish.preventProxy = true
      const sum = Gibberish.binops.Add( ...props.inputs )
      const mul = Gibberish.binops.Mul( sum, props.gain )
      Gibberish.preventProxy = false

      const graph = Gibberish.Panner({ input:mul, pan: props.pan })

      graph.sum = sum
      graph.mul = mul
      graph.disconnectUgen = Bus.disconnectUgen

      graph.__properties__ = props

      const out = props.__useProxy__ === true ? proxy( ['Bus'], props, graph ) : graph

      Object.defineProperty( out, 'gain', Bus.gain )

      if( false && Gibberish.preventProxy === false && Gibberish.mode === 'worklet' ) {
        const meta = {
          address:'add',
          name:['Bus'],
          props, 
          id:graph.id
        }
        Gibberish.worklet.port.postMessage( meta )
        Gibberish.worklet.port.postMessage({ 
          address:'method', 
          object:graph.id,
          name:'connect',
          args:[]
        })
      }

      return out 
    },

    disconnectUgen( ugen ) {
      let removeIdx = this.sum.inputs.indexOf( ugen )

      if( removeIdx !== -1 ) {
        this.sum.inputs.splice( removeIdx, 1 )
        Gibberish.dirty( this )
      }
    },

    // can't include inputs here as it will be sucked up by Gibber,
    // instead pass during Object.assign() after defaults.
    defaults: { gain:1, pan:.5, __useProxy__:true }
  })

  const constructor = Bus.create.bind( Bus )
  constructor.defaults = Bus.defaults

  return constructor
}


},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],196:[function(require,module,exports){
const g = require( 'genish.js' ),
      ugen = require( '../ugen.js' )(),
      __proxy = require( '../workletProxy.js' )


module.exports = function( Gibberish ) {
  const Bus2 = Object.create( ugen )
  const proxy = __proxy( Gibberish )

  let bufferL, bufferR
  
  Object.assign( Bus2, { 
    create( __props ) {

      if( bufferL === undefined ) {
        const p = g.pan()
        
        // copy memory... otherwise the wavetables don't have memory indices.
        bufferL = Gibberish.memory.alloc(1024)
        Gibberish.memory.heap.set( Gibberish.genish.gen.globals.panL.buffer, bufferL )

        bufferR = Gibberish.memory.alloc(1024)
        Gibberish.memory.heap.set( Gibberish.genish.gen.globals.panR.buffer, bufferR )
      }

      // XXX must be same type as what is returned by genish for type checks to work correctly
      const output = new Float64Array( 2 ) 

      const bus = Object.create( Bus2 )

      let init = false

      const props = Object.assign({}, Bus2.defaults, __props )

      Object.assign( 
        bus,

        {
          callback() {
            output[ 0 ] = output[ 1 ] = 0
            const lastIdx = arguments.length - 1
            const memory  = arguments[ lastIdx ]
            let pan  = arguments[ lastIdx - 1 ]
            const gain = arguments[ lastIdx - 2 ]

            for( let i = 0; i < lastIdx - 2; i+= 3 ) {
              const input = arguments[ i ],
                    level = arguments[ i + 1 ],
                    isStereo = arguments[ i + 2 ]

              output[ 0 ] += isStereo === true ? input[ 0 ] * level : input * level

              output[ 1 ] += isStereo === true ? input[ 1 ] * level : input * level
            }

            if( pan < 0 ) {
              pan = 0
            }else if( pan > 1 ){
              pan = 1
            }

            const panRawIndex  = pan * 1023,
                  panBaseIndex = panRawIndex | 0,
                  panNextIndex = (panBaseIndex + 1) & 1023,
                  interpAmount = panRawIndex - panBaseIndex,
                  panL = memory[ bufferL + panBaseIndex ] 
                    + ( interpAmount * ( memory[ bufferL + panNextIndex ] - memory[ bufferL + panBaseIndex ] ) ),
                  panR = memory[ bufferR + panBaseIndex ] 
                    + ( interpAmount * ( memory[ bufferR + panNextIndex ] - memory[ bufferR + panBaseIndex ] ) )
            
            output[0] *= gain * panL
            output[1] *= gain * panR

            return output
          },
          id : Gibberish.factory.getUID(),
          dirty : false,
          type : 'bus',
          inputs:[ 1, .5 ],
          isStereo: true,
          __properties__:props
        },

        Bus2.defaults,

        props
      )

      bus.ugenName = bus.callback.ugenName = 'bus2_' + bus.id

      const out = bus.__useProxy__ === true ? proxy( ['Bus2'], props, bus ) : bus


      // we have to include custom properties for these as the argument list for
      // the compiled output function is variable
      // so codegen can't know the correct argument order for the function
      let pan = .5
      Object.defineProperty( out, 'pan', {
        get() { return pan },
        set(v){ 
          pan = v
          out.inputs[ out.inputs.length - 1 ] = pan
          Gibberish.dirty( out )
        }
      })

      let gain = 1
      Object.defineProperty( out, 'gain', {
        get() { return gain },
        set(v){ 
          gain = v
          out.inputs[ out.inputs.length - 2 ] = gain
          Gibberish.dirty( out )
        }
      })

      return out
    },
    
    disconnectUgen( ugen ) {
      let removeIdx = this.inputs.indexOf( ugen )

      if( removeIdx !== -1 ) {
        this.inputs.splice( removeIdx, 3 )
        Gibberish.dirty( this )
      }
    },

    defaults: { gain:1, pan:.5, __useProxy__:true }
  })

  const constructor = Bus2.create.bind( Bus2 )
  constructor.defaults = Bus2.defaults

  return constructor

}

},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],197:[function(require,module,exports){
const  g    = require( 'genish.js'  ),
       ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {

  const Monops = {
    export( obj ) {
      for( let key in Monops ) {
        if( key !== 'export' ) {
          obj[ key ] = Monops[ key ]
        }
      }
    },
    
    Abs( input ) {
      const abs = Object.create( ugen )
      const graph = g.abs( g.in('input') )
      
      const __out = Gibberish.factory( abs, graph, ['monops','abs'], Object.assign({}, Monops.defaults, { inputs:[input], isop:true }) )

      return __out
    },

    Pow( input, exponent ) {
      const pow = Object.create( ugen )
      const graph = g.pow( g.in('input'), g.in('exponent') )
      
      Gibberish.factory( pow, graph, ['monops','pow'], Object.assign({}, Monops.defaults, { inputs:[input], exponent, isop:true }) )

      return pow
    },
    Clamp( input, min, max ) {
      const clamp = Object.create( ugen )
      const graph = g.clamp( g.in('input'), g.in('min'), g.in('max') )
      
      const __out = Gibberish.factory( clamp, graph, ['monops','clamp'], Object.assign({}, Monops.defaults, { inputs:[input], isop:true, min, max }) )

      return __out
    },

    Merge( input ) {
      const merger = Object.create( ugen )
      const cb = function( _input ) {
        return _input[0] + _input[1]
      }

      Gibberish.factory( merger, g.in( 'input' ), ['monops','merge'], { inputs:[input], isop:true }, cb )
      merger.type = 'analysis'
      merger.inputNames = [ 'input' ]
      merger.inputs = [ input ]
      merger.input = input
      
      return merger
    },
  }

  Monops.defaults = { input:0 }

  return Monops
}

},{"../ugen.js":210,"genish.js":51}],198:[function(require,module,exports){
const g = require( 'genish.js' )

const ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {
 
let Panner = inputProps => {
  const props  = Object.assign( {}, Panner.defaults, inputProps ),
        panner = Object.create( ugen )

  const isStereo = props.input.isStereo !== undefined ? props.input.isStereo : Array.isArray( props.input ) 
  
  const input = g.in( 'input' ),
        pan   = g.in( 'pan' )

  let graph 
  if( isStereo ) {
    graph = g.pan( input[0], input[1], pan )  
  }else{
    graph = g.pan( input, input, pan )
  }

  Gibberish.factory( panner, [ graph.left, graph.right], ['panner'], props )
  
  return panner
}

Panner.defaults = {
  input:0,
  pan:.5
}

return Panner 

}

},{"../ugen.js":210,"genish.js":51}],199:[function(require,module,exports){
module.exports = function( Gibberish ) {

  const Time = {
    bpm: 120,

    export: function(target) {
      Object.assign( target, Time )
    },

    ms : function(val) {
      return val * Gibberish.ctx.sampleRate / 1000;
    },

    seconds : function(val) {
      return val * Gibberish.ctx.sampleRate;
    },

    beats : function(val) {
      return function() { 
        var samplesPerBeat = Gibberish.ctx.sampleRate / ( Gibberish.Time.bpm / 60 ) ;
        return samplesPerBeat * val ;
      }
    }
  }

  return Time
}

},{}],200:[function(require,module,exports){
const genish = require( 'genish.js' ),
      ssd = genish.history,
      noise = genish.noise

module.exports = function() {
  "use jsdsp"

  const last = ssd( 0 )

  const white = ( noise() * 2 ) - 1

  let out = (last.out + (.02 * white)) / 1.02

  last.in( out )

  out *= 3.5
   
  return out
}

},{"genish.js":51}],201:[function(require,module,exports){
let g = require( 'genish.js' )

let feedbackOsc = function( frequency, filter, pulsewidth=.5, argumentProps ) {
  if( argumentProps === undefined ) argumentProps = { type: 0 }

  let lastSample = g.history(),
      // determine phase increment and memoize result
      w = g.memo( g.div( frequency, g.gen.samplerate ) ),
      // create scaling factor
      n = g.sub( -.5, w ),
      scaling = g.mul( g.mul( 13, filter ), g.pow( n, 5 ) ),
      // calculate dc offset and normalization factors
      DC = g.sub( .376, g.mul( w, .752 ) ),
      norm = g.sub( 1, g.mul( 2, w ) ),
      // determine phase
      osc1Phase = g.accum( w, 0, { min:-1 }),
      osc1, out

  // create current sample... from the paper:
  // osc = (osc + sin(2*pi*(phase + osc*scaling)))*0.5f;
  osc1 = g.memo( 
    g.mul(
      g.add(
        lastSample.out,
        g.sin(
          g.mul(
            Math.PI * 2,
            g.memo( g.add( osc1Phase, g.mul( lastSample.out, scaling ) ) )
          )
        )
      ),
      .5
    )
  )

  // store sample to use as modulation
  lastSample.in( osc1 )

  // if pwm / square waveform instead of sawtooth...
  if( argumentProps.type === 1 ) { 
    const lastSample2 = g.history() // for osc 2
    const lastSampleMaster = g.history() // for sum of osc1,osc2

    const osc2 = g.mul(
      g.add(
        lastSample2.out,
        g.sin(
          g.mul(
            Math.PI * 2,
            g.memo( g.add( osc1Phase, g.mul( lastSample2.out, scaling ), pulsewidth ) )
          )
        )
      ),
      .5
    )

    lastSample2.in( osc2 )
    out = g.memo( g.sub( lastSample.out, lastSample2.out ) )
    out = g.memo( g.add( g.mul( 2.5, out ), g.mul( -1.5, lastSampleMaster.out ) ) )
    
    lastSampleMaster.in( g.sub( osc1, osc2 ) )

  }else{
     // offset and normalize
    osc1 = g.add( g.mul( 2.5, osc1 ), g.mul( -1.5, lastSample.out ) )
    osc1 = g.add( osc1, DC )
 
    out = osc1
  }

  return g.mul( out, norm )
}

module.exports = feedbackOsc

},{"genish.js":51}],202:[function(require,module,exports){
const g = require( 'genish.js' ),
      ugen = require( '../ugen.js' )(),
      feedbackOsc = require( './fmfeedbackosc.js' ),
      polyBlep = require( './polyblep.dsp.js' )

//  __makeOscillator__( type, frequency, antialias ) {
    
module.exports = function( Gibberish ) {
  let Oscillators = {
    export( obj ) {
      for( let key in Oscillators ) {
        if( key !== 'export' ) {
          obj[ key ] = Oscillators[ key ]
        }
      }
    },

    genish: {
      Brown: require( './brownnoise.dsp.js' ),
      Pink:  require( './pinknoise.dsp.js'  )
    },

    Wavetable: require( './wavetable.js' )( Gibberish ),
    
    Square( inputProps ) {
      const sqr   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'square', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( sqr, graph, ['oscillators','square'], props )

      return out
    },

    Triangle( inputProps ) {
      const tri= Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'triangle', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( tri, graph, ['oscillators','triangle'], props )

      return out
    },

    PWM( inputProps ) {
      const pwm   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false, pulsewidth:.25 }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'pwm', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( pwm, graph, ['oscillators','PWM'], props )

      return out
    },

    Sine( inputProps ) {
      const sine  = Object.create( ugen )
      const props = Object.assign({}, Oscillators.defaults, inputProps )
      const graph = g.mul( g.cycle( g.in('frequency') ), g.in('gain') )

      const out = Gibberish.factory( sine, graph, ['oscillators','sine'], props )
      
      return out
    },

    Noise( inputProps ) {
      const noise = Object.create( ugen )
      const props = Object.assign( {}, { gain: 1, color:'white' }, inputProps )
      let graph 

      switch( props.color ) {
        case 'brown':
          graph = g.mul( Oscillators.genish.Brown(), g.in('gain') )
          break;
        case 'pink':
          graph = g.mul( Oscillators.genish.Pink(), g.in('gain') )
          break;
        default:
          graph = g.mul( g.noise(), g.in('gain') )
          break;
      }

      const out = Gibberish.factory( noise, graph, ['oscillators','noise'], props )

      return out
    },

    Saw( inputProps ) {
      const saw   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = Oscillators.factory( 'saw', g.in( 'frequency' ), props.antialias )
      const graph = g.mul( osc, g.in('gain' ) )

      const out = Gibberish.factory( saw, graph, ['oscillators','saw'], props )

      return out
    },

    ReverseSaw( inputProps ) {
      const saw   = Object.create( ugen ) 
      const props = Object.assign({ antialias:false }, Oscillators.defaults, inputProps )
      const osc   = g.sub( 1, Oscillators.factory( 'saw', g.in( 'frequency' ), props.antialias ) )
      const graph = g.mul( osc, g.in( 'gain' ) )

      const out = Gibberish.factory( saw, graph, ['oscillators','ReverseSaw'], props )
      
      return out
    },

    factory( type, frequency, antialias=false ) {
      let osc

      switch( type ) {
        case 'pwm':
          let pulsewidth = g.in('pulsewidth')
          if( antialias == true ) {
            osc = feedbackOsc( frequency, 1, pulsewidth, { type:1 })
          }else{
            let phase = g.phasor( frequency, 0, { min:0 } )
            osc = g.lt( phase, pulsewidth )
          }
          break;
        case 'saw':
          if( antialias == false ) {
            osc = g.phasor( frequency )
          }else{
            osc = polyBlep( frequency, { type })
          }
          break;
        case 'sine':
          osc = g.cycle( frequency )
          break;
        case 'square':
          if( antialias == true ) {
            //osc = feedbackOsc( frequency, 1, .5, { type:1 })
            osc = polyBlep( frequency, { type })
          }else{
            osc = g.wavetable( frequency, { buffer:Oscillators.Square.buffer, name:'square' } )
          }
          break;
        case 'triangle':
          if( antialias == true ) {
            osc = polyBlep( frequency, { type })
          }else{
            osc = g.wavetable( frequency, { buffer:Oscillators.Triangle.buffer, name:'triangle' } )
          }
          break;
        case 'noise':
          osc = g.noise()
          break;
      }

      return osc
    }
  }

  Oscillators.Square.buffer = new Float32Array( 1024 )

  for( let i = 1023; i >= 0; i-- ) { 
    Oscillators.Square.buffer [ i ] = i / 1024 > .5 ? 1 : -1
  }

  Oscillators.Triangle.buffer = new Float32Array( 1024 )

  
  for( let i = 1024; i--; i = i ) { Oscillators.Triangle.buffer[i] = 1 - 4 * Math.abs(( (i / 1024) + 0.25) % 1 - 0.5); }

  Oscillators.defaults = {
    frequency: 440,
    gain: 1
  }

  return Oscillators

}

},{"../ugen.js":210,"./brownnoise.dsp.js":200,"./fmfeedbackosc.js":201,"./pinknoise.dsp.js":203,"./polyblep.dsp.js":204,"./wavetable.js":205,"genish.js":51}],203:[function(require,module,exports){
const genish = require( 'genish.js' ),
      ssd = genish.history,
      data = genish.data,
      noise = genish.noise

module.exports = function() {
  "use jsdsp"

  const b = data( 8, 1, { meta: true })
  const white = noise() * 2 - 1

  b[0] = ( .99886 * b[0] ) + ( white * .0555179 )
  b[1] = ( .99332 * b[1] ) + ( white * .0750579 )
  b[2] = ( .96900 * b[2] ) + ( white * .1538520 )
  b[3] = ( .88650 * b[3] ) + ( white * .3104856 )
  b[4] = ( .55000 * b[4] ) + ( white * .5329522 )
  b[5] = ( -.7616 * b[5] ) - ( white * .0168980 )
 
  const out = ( b[0] + b[1] + b[2] + b[3] + b[4] + b[5] + b[6] + white * .5362 ) * .11

  b[6] = white * .115926

  return out

}

},{"genish.js":51}],204:[function(require,module,exports){
const genish = require( 'genish.js' )
const g = genish

// based on http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/
const polyBlep = function( __frequency, argumentProps ) {
  'use jsdsp'
  if( argumentProps === undefined ) argumentProps = { type: 'saw' }
  
  const mem = g.history(0)
  const type = argumentProps.type
  const frequency = __frequency === undefined ? 220 : __frequency
  const dt = frequency / g.gen.samplerate
  
  const t = g.accum( dt, 0, { min:0 })
  let osc

  // triangle waves are integrated square waves, so the below case accomodates both types
  if( type === 'triangle' || type === 'square' ) {
    // lt NOT gt to get correct phase
    osc = (2 * g.lt(t,.5) ) - 1
  }else{
    osc = 2 * t - 1
  }
  const case1 = g.lt(t,dt)
  const case2 = g.gt(t,1-dt)
  const adjustedT = g.switch( case1, t/dt, g.switch( case2, (t-1)/dt, t ) )
  
  // if/elseif/else with nested ternary operators
  const blep = g.switch(
    case1,
    adjustedT + adjustedT - adjustedT * adjustedT - 1,
    g.switch(
      case2,
      adjustedT * adjustedT + adjustedT + adjustedT + 1,
      // final else case is 0
      0
    )
  )
  
  // triangle waves are integrated square waves, so the below case accomodates both types
  if( type !== 'saw' ) {
    osc = osc + blep
    const t_2 = g.memo( g.mod( t + .5, 1 ) )
    const case1_2 = g.lt(t_2,dt)
    const case2_2 = g.gt(t_2,1-dt)
    const adjustedT_2 = g.switch( case1_2, t_2/dt, g.switch( case2_2, (t_2-1)/dt, t_2 ) )
 
    const blep2 = g.switch(
      case1_2,
      adjustedT_2 + adjustedT_2 - adjustedT_2 * adjustedT_2 - 1,
      g.switch(
        case2_2,
        adjustedT_2 * adjustedT_2 + adjustedT_2 + adjustedT_2 + 1,
        0
      )
    )
    osc = osc - blep2
    
    // leaky integrator to create triangle from square wave
    if( type === 'triangle' ) {
      osc = dt * osc + (1 - dt ) * mem.out
      mem.in( osc )
    }
  }else{
    osc = osc - blep
  }
  
  return osc
}

module.exports = polyBlep 

},{"genish.js":51}],205:[function(require,module,exports){
let g = require( 'genish.js' ),
    ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {

  const Wavetable = function( inputProps ) {
    const wavetable = Object.create( ugen )
    const props  = Object.assign({}, Gibberish.oscillators.defaults, inputProps )
    const osc = g.wavetable( g.in('frequency'), props )
    const graph = g.mul( 
      osc, 
      g.in( 'gain' )
    )

    Gibberish.factory( wavetable, graph, 'wavetable', props )

    return wavetable
  }

  g.wavetable = function( frequency, props ) {
    let dataProps = { immutable:true }

    // use global references if applicable
    if( props.name !== undefined ) dataProps.global = props.name

    const buffer = g.data( props.buffer, 1, dataProps )

    return g.peek( buffer, g.phasor( frequency, 0, { min:0 } ) )
  }

  return Wavetable
}

},{"../ugen.js":210,"genish.js":51}],206:[function(require,module,exports){
const Queue = require( '../external/priorityqueue.js' )

let Gibberish = null

const Scheduler = {
  phase: 0,

  queue: new Queue( ( a, b ) => {
    if( a.time === b.time ) { 
      return a.priority < b.priority ? -1 : a.priority > b.priority ? 1 : 0;
    }else{
      return a.time - b.time //a.time.minus( b.time )
    }
  }),

  init( __Gibberish ) {
    Gibberish = __Gibberish
  },

  clear() {
    this.queue.data.length = 0
    this.queue.length = 0
    this.phase = 0
  },

  add( time, func, priority = 0 ) {
    time += this.phase

    this.queue.push({ time, func, priority })

    return this.phase
  },

  tick( usingSync = false ) {
    if( this.shouldSync === usingSync ) {
      if( this.queue.length ) {
        let next = this.queue.peek()

        if( isNaN( next.time ) ) {
          this.queue.pop()
        }
        
        while( this.phase >= next.time ) {
          next.func( next.priority )
          this.queue.pop()
          next = this.queue.peek()

          // XXX this happens when calling sequencer.stop()... why?
          if( next === undefined ) break
        }
      }

      this.phase++
    }

    return this.phase
  },

  advance( amt ) {
    this.phase += amt
    this.tick( true )
  }
}

let shouldSync = false
Object.defineProperty( Scheduler, 'shouldSync', {
  get() { return shouldSync },
  set(v){ 
    shouldSync = v
    if( Gibberish.mode === 'worklet' ) {
      Gibberish.worklet.port.postMessage({
        address:'eval',
        code:'Gibberish.scheduler.shouldSync = ' + v
      })
    }
  }
})

module.exports = Scheduler

},{"../external/priorityqueue.js":149}],207:[function(require,module,exports){
const g = require( 'genish.js' ),
      __proxy = require( '../workletProxy.js' ),
      ugen = require( '../ugen.js' )()

module.exports = function( Gibberish ) {
  const __proto__ = Object.create( ugen )

  const proxy = __proxy( Gibberish )

  Object.assign( __proto__, {
    start( delay=0 ) {
      if( delay !== 0 ) {
        Gibberish.scheduler.add( delay, ()=> {
          Gibberish.analyzers.push( this )
          Gibberish.dirty( Gibberish.analyzers )
        })
      }else{
        Gibberish.analyzers.push( this )
        Gibberish.dirty( Gibberish.analyzers )
      }
      return this
    },
    stop( delay=0 ) {
      const idx = Gibberish.analyzers.indexOf( this )
      if( delay === 0 ) {
        if( idx > -1 ) {
          Gibberish.analyzers.splice( idx, 1 )
          Gibberish.dirty( Gibberish.analyzers )
        }
        this.phase = 0
        this.nextTime = 0
      }else{
        Gibberish.scheduler.add( delay, ()=> {
          if( idx > -1 ) {
            Gibberish.analyzers.splice( idx, 1 )
            Gibberish.dirty( Gibberish.analyzers )
          }
          this.phase = 0
          this.nextTime = 0
        })
      }

      return this
    },
    fire(){
      let value  = typeof this.values  === 'function' ? this.values  : this.values[ this.__valuesPhase++  % this.values.length  ]
      if( typeof value === 'function' && this.target === undefined ) {
        value()
      }else if( typeof this.target[ this.key ] === 'function' ) {
        if( typeof value === 'function' ) {
          value = value()
        }
        if( value !== this.DNR ) {
          this.target[ this.key ]( value )
        }
      }else{
        if( typeof value === 'function' ) value = value()
        if( value !== this.DNR )
          this.target[ this.key ] = value
      }
    }
  })

  // XXX we need to implement priority, which will in turn determine the order
  // that the sequencers are added to the callback function.
  const Seq2 = { 
    create( inputProps ) {
      const seq = Object.create( __proto__ ),
            properties = Object.assign({}, Seq2.defaults, inputProps )

      seq.phase = 0
      seq.inputNames = [ 'rate', 'density' ]
      seq.inputs = [ 1, 1 ]
      seq.nextTime = 0
      seq.__valuesPhase = 0
      seq.__timingsPhase = 0
      seq.id = Gibberish.factory.getUID()
      seq.dirty = true
      seq.type = 'seq'
      seq.__addresses__ = {}
      seq.DNR = -987654321

      properties.id = Gibberish.factory.getUID()

      Object.assign( seq, properties ) 
      seq.__properties__ = properties

      // support for sequences that are triggered via other means,
      // in Gibber this is when you provide timing to one sequence
      // on an object and want to use that one pattern to trigger
      // multiple sequences.
      if( seq.timings === null ) { seq.nextTime = Infinity } 

      // XXX this needs to be optimized as much as humanly possible, since it's running at audio rate...
      seq.callback = function( rate, density ) {
        while( seq.phase >= seq.nextTime ) {
          let value  = typeof seq.values  === 'function' ? seq.values  : seq.values[ seq.__valuesPhase++  % seq.values.length  ],
              shouldRun = true
          
          let timing = null
          if( seq.timings !== null && seq.timings !== undefined ) { 
            timing = typeof seq.timings === 'function' ? seq.timings : seq.timings[ seq.__timingsPhase++ % seq.timings.length ]
            if( typeof timing === 'function' ) timing = timing()
          }
          
          let shouldIncreaseSpeed = density <= 1 ? false : true

          // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
          // objects indicating both whether or not they should should trigger values as well
          // as the next time they should run. perhaps this could be made more generalizable?
          if( timing !== null && typeof timing === 'object' ) {
            if( timing.shouldExecute === 1 ) {
              shouldRun = true
            }else{
              shouldRun = false
            }
            timing = timing.time 
          }else if( timing !== null ) {
            if( Math.random() >= density ) shouldRun = false
          }

          if( shouldRun ) {
            if( seq.mainthreadonly !== undefined ) {
              if( typeof value === 'function' ) {
                value = value()
              }
              Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
            }else if( typeof value === 'function' && seq.target === undefined ) {
              value()
            }else if( typeof seq.target[ seq.key ] === 'function' ) {
              if( typeof value === 'function' ) {
                value = value()
              }
              if( value !== seq.DNR ) {
                seq.target[ seq.key ]( value )
              }
            }else{
              if( typeof value === 'function' ) value = value()
              if( value !== seq.DNR )
                seq.target[ seq.key ] = value
            }
          }

          if( timing === null ) return

          seq.phase -= seq.nextTime

          if( shouldIncreaseSpeed ) {
            timing = Math.random() > (2 - density) ? timing / 2 : timing
          }
          seq.nextTime = timing
        }

        seq.phase += rate

        return 0
      }

      seq.ugenName = seq.callback.ugenName = 'seq_' + seq.id

      // since we're not passing our sequencer through the ugen template, we need
      // to grab a memory address for its rate so it can be sequenced and define
      // a property that manipulates that memory address.
      const idx = Gibberish.memory.alloc( 1 )
      Gibberish.memory.heap[ idx ] = seq.rate
      seq.__addresses__.rate = idx

      let value = seq.rate
      Object.defineProperty( seq, 'rate', {
        get() { return value },
        set( v ) {
          if( value !== v ) {
            if( typeof v === 'number' ) Gibberish.memory.heap[ idx ] = v

            Gibberish.dirty( Gibberish.analyzers )
            value = v
          }
        }
      })

      const didx = Gibberish.memory.alloc( 1 )
      Gibberish.memory.heap[ didx ] = seq.density
      seq.__addresses__.density = didx

      let dvalue = seq.density
      Object.defineProperty( seq, 'density', {
        get() { return dvalue },
        set( v ) {
          if( dvalue !== v ) {
            if( typeof v === 'number' ) Gibberish.memory.heap[ didx ] = v

            Gibberish.dirty( Gibberish.analyzers )
            dvalue = v
          }
        }
      })

      if( Gibberish.mode === 'worklet' ) {
        Gibberish.utilities.createPubSub( seq )
      }

      return proxy( ['Sequencer2'], properties, seq ) 
    }
  }

  Seq2.defaults = { rate: 1, density:1, priority:0, phase:0 }
  Seq2.create.DO_NOT_OUTPUT = -987654321

  return Seq2.create

}


},{"../ugen.js":210,"../workletProxy.js":212,"genish.js":51}],208:[function(require,module,exports){
(function (global){(function (){
const __proxy = require( '../workletProxy.js' )

module.exports = function( Gibberish ) {

const renderFnc = function( pattern ) {
  const keys = Object.keys( pattern.dict )
  const objs = Object.values( pattern.dict )
    .map( v => typeof v === 'object' && !Array.isArray( v )
    ? Gibberish.processor.ugens.get(v.id) 
    : v 
    )

  // we create a new inner function using the function constructor,
  // where every argument is codegen'd as an upvalue to the
  // returned function. after codegen we call the functon
  // to get the inner function with the upvalues andd
  // return that. Store references to globals as upvalues as well.
  let code = 'let Gibberish = __Gibberish, global = __global;\n'
  keys.forEach( k => {
    let line = `let ${k} = `
    const value = pattern.dict[ k ]
    const getter = typeof value === 'object' 
      ? Array.isArray( value )
      ? `[${value.toString()}]`
      : `Gibberish.processor.ugens.get(${ value.id })`
      : value
    line += getter 
    code += line + '\n'

  })  
  code +=`return function() { ${ pattern.fncstr } }` 

  // pass in globals to be used as upvalues in final function
  const fnc = new Function( '__Gibberish', '__global', code )( Gibberish, global )

  return fnc 
}

const proxy = __proxy( Gibberish )

const Sequencer = props => {
  let __seq
  let floatError = 0

  const seq = {
    type:'seq',
    __isRunning:false,
    __valuesPhase:  0,
    __timingsPhase: 0,
    __onlyRunsOnce: false,
    __repeatCount: null,
    DNR : -987654321,

    tick( priority ) {
      let value  = typeof seq.values  === 'function' 
          ? seq.values  
          : seq.values[  seq.__valuesPhase++  % seq.values.length  ],

        timing = typeof seq.timings === 'function' 
          ? seq.timings 
          : seq.timings !== null
            ? seq.timings[ seq.__timingsPhase++ % seq.timings.length ]
            : null,

        shouldRun = true
      
      if( seq.__onlyRunsOnce === true ) {
        if( seq.__valuesPhase === seq.values.length ) {
          seq.stop()
        }
      }else if( seq.__repeatCount !== null ) {
        if( seq.__valuesPhase % seq.values.length === 0 ) {
          seq.__repeatCount--
          if( seq.__repeatCount === 0 ) {
            seq.stop()
            seq.__repeatCount = null
          }
        }
      }

      if( typeof timing === 'function' ) timing = timing()

      // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
      // objects indicating both whether or not they should should trigger values as well
      // as the next time they should run. perhaps this could be made more generalizable?
      if( timing !== null ) {
        if( typeof timing === 'object' ) {
          if( timing.shouldExecute === 1 ) {
            shouldRun = true
          }else{
            shouldRun = false
          }
          timing = timing.time 
        }

        timing *= seq.rate
      }else{
        shouldRun = false 
      }

      if( value === Sequencer.DO_NOT_OUTPUT ) shouldRun = false

      if( shouldRun ) {
        try{
          if( seq.mainthreadonly !== undefined ) {
            if( typeof value === 'function' ) {
              value = value()
            }
            //console.log( 'main thread only' )
            Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
          }else if( typeof value === 'function' && seq.target === undefined ) {
            value()
          }else if( typeof seq.target[ seq.key ] === 'function' ) {
            //console.log( seq.key, seq.target )
            if( typeof value === 'function' ) value = value()
            if( value !== seq.DNR )
              seq.target[ seq.key ]( value )
          }else{
            if( typeof value === 'function' ) value = value()
            if( value !== seq.DNR )
              seq.target[ seq.key ] = value
          }

          if( seq.reportOutput === true ) {
            Gibberish.processor.port.postMessage({
              address:'__sequencer',
              id: seq.id,
              name:'output',
              value,
              phase: seq.__valuesPhase,
              length: seq.values.length
            })
          }
        } catch(e) {
          console.error( `A sequence targeting ${seq.target.ugenName}.${seq.key} contains an improper value and will be stopped.` )
          return
        }
      }
      
      if( Gibberish.mode === 'processor' ) {
        if( seq.__isRunning === true && !isNaN( timing ) && seq.autotrig === false ) {
          timing += floatError
          Gibberish.scheduler.add( timing, seq.tick, seq.priority )
          floatError = timing - Math.floor( timing )
        }
      }
    },
    fire(){
      let value  = typeof this.values  === 'function' ? this.values  : this.values[ this.__valuesPhase++  % this.values.length  ]
      if( typeof value === 'function' && this.target === undefined ) {
        value()
      }else if( typeof this.target[ this.key ] === 'function' ) {
        if( typeof value === 'function' ) {
          value = value()
        }
        if( value !== this.DNR ) {
          this.target[ this.key ]( value )
        }
      }else{
        if( typeof value === 'function' ) value = value()
        if( value !== this.DNR )
          this.target[ this.key ] = value
      }
    },

    start( delay = 0 ) {
      if( Gibberish.mode === 'processor' && seq.__isRunning === false ) {
        Gibberish.scheduler.add( 
          delay, 
          priority => {
            seq.tick( priority )
            Gibberish.processor.port.postMessage({
              address:'__sequencer',
              id: seq.id,
              name:'start'
            })
          }, 
          seq.priority 
        )
      }
      seq.__isRunning = true
      seq.__delay = delay
      return __seq
    },

    stop( delay = null ) {
      if( delay === null ) {
        seq.__isRunning = false

        if( Gibberish.mode === 'processor' ) {
          Gibberish.processor.port.postMessage({
            address:'__sequencer',
            id: seq.id,
            name:'stop'
          })
        }
      
      }else{
        Gibberish.scheduler.add( delay, seq.stop )
      }
      return __seq
    },

    once() {
      seq.__onlyRunsOnce = true
      return __seq
    },

    repeat( repeatCount = 2 ) {
      seq.__repeatCount = repeatCount
      return __seq
    }
  }

  props.id = Gibberish.factory.getUID()

  if( Gibberish.mode === 'worklet' ) {
    Gibberish.utilities.createPubSub( seq )
  }else{
    // need a separate reference to the properties for worklet meta-programming
    if( typeof props.values === 'object' && props.values.requiresRender === true ) {
      props.values = renderFnc( props.values )
    }
    if( props.timings !== null && typeof props.timings === 'object' && props.timings.requiresRender === true ) {
      props.timings = renderFnc( props.timings )
    }
  }

  const properties = Object.assign( {}, Sequencer.defaults, props )
  Object.assign( seq, properties ) 
  seq.__properties__ = properties

  __seq =  proxy( ['Sequencer'], properties, seq )

  return __seq
}

Sequencer.defaults = { priority:100, rate:1, reportOutput:false, autotrig:false }

Sequencer.make = function( values, timings, target, key, priority, reportOutput ) {
  return Sequencer({ values, timings, target, key, priority, reportOutput })
}

Sequencer.DO_NOT_OUTPUT = -987654321

return Sequencer

}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../workletProxy.js":212}],209:[function(require,module,exports){
const __proxy = require( '../workletProxy.js' )
const Pattern = require( 'tidal.pegjs' )

module.exports = function( Gibberish ) {

const proxy = __proxy( Gibberish )

const Sequencer = props => {
  let __seq
  const seq = {
    __isRunning:false,

    __phase:  0,
    __type:'seq',
    __pattern: Pattern( props.pattern, { addLocations:true, addUID:true, enclose:true }),
    __events: null,

    tick( priority ) {
      // running for first time, perform a query
      if( seq.__events === null || seq.__events.length === 0 ) {
        seq.__events = seq.__pattern.query( seq.__phase++, 1 )
      }

      // used when scheduling events that are very far apart
      if( seq.__events.length <= 0 ) {
        if( Gibberish.mode === 'processor' ) {
          if( seq.__isRunning === true  ) {
            Gibberish.scheduler.add( Gibberish.ctx.sampleRate / Sequencer.clock.cps, seq.tick, seq.priority )
          }

        }

        return
      }

      const startTime = seq.__events[ 0 ].arc.start

      if( seq.key !== 'chord' ) {
        while( seq.__events.length > 0 && startTime.valueOf() === seq.__events[0].arc.start.valueOf() ) {
          let event  = seq.__events.shift(),
              value  = event.value,
              uid    = event.uid

          // for bjorklund etc.
          if( typeof value === 'object' ) value = value.value

          if( seq.filters !== null ) value = seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, uid ), value )  
          if( seq.mainthreadonly !== undefined ) {
            if( typeof value === 'function' ) {
              value = value()
            }
            Gibberish.processor.messages.push( seq.mainthreadonly, seq.key, value )
          }else if( typeof seq.target[ seq.key ] === 'function' ) {
            seq.target[ seq.key ]( value )
          }else{
            seq.target[ seq.key ] = value
          }
        }
      }else{
        let value = seq.__events.filter( evt => startTime.valueOf() === evt.arc.start.valueOf() ).map( evt => evt.value )
        let uid = seq.__events[0].uid

        const events = seq.__events.splice( 0, value.length )

        if( seq.filters !== null ) {
          if( value.length === 1 ) {
            value = seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, uid ), value )  
          }else{
            value.forEach( (v,i) => seq.filters.reduce( (currentValue, filter) => filter( currentValue, seq, events[ i ].uid ), v ) )
          }
        }

        if( typeof seq.target[ seq.key ] === 'function' ) {
          seq.target[ seq.key ]( value )
        }else{
          seq.target[ seq.key ] = value
        }
      }

      if( Gibberish.mode === 'processor' ) {
        let timing
        if( seq.__events.length <= 0 ) {
          let time = 0
          while( seq.__events.length <= 0 ) {
            seq.__events = seq.__pattern.query( seq.__phase++, 1 )
            time++
          }
          //seq.__events.forEach( evt => {
          //  evt.arc.start = evt.arc.start.add( 1 ).sub( startTime ) 
          //  evt.arc.end   = evt.arc.end.add( 1 ).sub( startTime )
          //})

          timing = time - startTime.valueOf() 
        }else{
          timing = seq.__events[0].arc.start.sub( startTime ).valueOf() 
        }
        
        timing *= Math.ceil( Gibberish.ctx.sampleRate / Sequencer.clock.cps ) + 1 

        if( seq.__isRunning === true && !isNaN( timing ) && timing > 0 ) {
          // XXX this supports an edge case in Gibber, where patterns like Euclid / Hex return
          // objects indicating both whether or not they should should trigger values as well
          // as the next time they should run. perhaps this could be made more generalizable?
          
          //if( typeof timing === 'object' ) {
          //  if( timing.shouldExecute === 1 ) {
          //    shouldRun = true
          //  }else{
          //    shouldRun = false
          //  }
          //  timing = timing.time 
          //}

          //timing *= seq.rate

          Gibberish.scheduler.add( timing, seq.tick, seq.priority )
        }
      }


    },

    rotate( amt ) {
      seq.__phase += amt
      return __seq 
    },

    start( delay = 0 ) {
      seq.__isRunning = true
      Gibberish.scheduler.add( delay, seq.tick, seq.priority )
      return __seq
    },

    stop() {
      seq.__isRunning = false
      return __seq
    },

    set( patternString ) {
      seq.__pattern = Pattern( patternString, { addLocations:true, addUID:true, enclose:true })

    }
  }

  props.id = Gibberish.factory.getUID()

  // need a separate reference to the properties for worklet meta-programming
  const properties = Object.assign( {}, Sequencer.defaults, props )
  Object.assign( seq, properties ) 
  seq.__properties__ = properties

  __seq =  proxy( ['Tidal'], properties, seq )

  return __seq
}

Sequencer.defaults = { priority:100000, pattern:'', rate:1, filters:null }

Sequencer.make = function( values, timings, target, key, priority ) {
  return Sequencer({ values, timings, target, key, priority })
}

let __uid = 0
Sequencer.getUID = ()=> {
  return __uid++
}

Sequencer.Pattern = Pattern

Sequencer.clock = { cps: 1 }

Sequencer.id = Gibberish.utilities.getUID()

if( Gibberish.mode === 'worklet' ) {
  Gibberish.worklet.port.postMessage({
    address:'eval',
    code:`Gibberish.Tidal.clock.id = ${Sequencer.id}; Gibberish.ugens.set( ${Sequencer.id}, Gibberish.Tidal.clock )`
  })
  
  let cps = 1
  Object.defineProperty( Sequencer, 'cps', {
    get() { return cps },
    set(v){ 
      cps = v
      if( Gibberish.mode === 'worklet' ) {
        Gibberish.worklet.port.postMessage({
          address:'set',
          object:Sequencer.id,
          name:'cps',
          value:cps 
        }) 
      }
    }
  })
}

return Sequencer

}

},{"../workletProxy.js":212,"tidal.pegjs":233}],210:[function(require,module,exports){
let Gibberish = null

const __ugen = function( __Gibberish ) {
  if( __Gibberish !== undefined && Gibberish == null ) Gibberish = __Gibberish
 
  const replace = obj => {
    if( typeof obj === 'object' ) {
      if( obj.id !== undefined ) {
        return processor.ugens.get( obj.id )
      } 
    }

    return obj
  }

  const ugen = {
    __Gibberish:Gibberish,

    free:function() {
      Gibberish.genish.gen.free( this.graph )
    },

    print:function() {
      console.log( this.callback.toString() )
    },

    connect:function( target, level=1 ) {
      if( this.connected === undefined ) this.connected = []

      //let input = level === 1 ? this : Gibberish.binops.Mul( this, level )
      let input = this

      if( target === undefined || target === null ) target = Gibberish.output 


      // XXX I forgot, where is __addInput found? Can we control the
      // level of the input?
      if( typeof target.__addInput == 'function' ) {
        target.__addInput( input )
      } else if( target.sum && target.sum.inputs ) {
        target.sum.inputs.push( input )
      } else if( target.inputs ) {
        const idx = target.inputs.indexOf( input )

        // if no connection exists...
        if( idx === -1 ) {
          target.inputs.unshift( input, level, input.isStereo )
        }else{
          // ... otherwise update the connection's level, which is stored
          // one index higher in the input list.
          target.inputs[ idx + 1 ] = level
        }
      } else {
        target.input = input
        target.inputGain = level
      }

      Gibberish.dirty( target )

      this.connected.push([ target, input, level ])
      
      return this
    },

    disconnect:function( target ) {
      if( target === undefined ){
        if( Array.isArray( this.connected ) ) {
          for( let connection of this.connected ) {
            if( connection[0].disconnectUgen !== undefined ) {
              connection[0].disconnectUgen( connection[1] )
            }else if( connection[0].input === this ) {
              connection[0].input = 0
            }
          }
          this.connected.length = 0
        }
      }else{
        const connection = this.connected.find( v => v[0] === target )
        // if target is a bus...
        if( target.disconnectUgen !== undefined ) {
          if( connection !== undefined ) {
            target.disconnectUgen( connection[1] )
          }
        }else{
          // must be an effect, set input to 0
          target.input = 0
        }

        const targetIdx = this.connected.indexOf( connection )

        if( targetIdx !== -1 ) {
          this.connected.splice( targetIdx, 1 )
        }
      }
    },

    chain:function( target, level=1 ) {
      this.connect( target,level )

      return target
    },

    __redoGraph:function() {
      let isStereo = this.isStereo
      this.__createGraph()
      this.callback = Gibberish.genish.gen.createCallback( this.graph, Gibberish.memory, false, true )
      this.inputNames = new Set( Gibberish.genish.gen.parameters ) 
      this.callback.ugenName = this.ugenName
      Gibberish.dirty( this )

      // if channel count has changed after recompiling graph...
      if( isStereo !== this.isStereo ) {

        // check for any connections before iterating...
        if( this.connected === undefined ) return
        // loop through all busses the ugen is connected to
        for( let connection of this.connected ) {
          // set the dirty flag of the bus
          Gibberish.dirty( connection[ 0 ] )

          // check for inputs array, which indicates connection is to a bus
          if( connection[0].inputs !== undefined ) {
            // find the input in the busses 'inputs' array
            const inputIdx = connection[ 0 ].inputs.indexOf( connection[ 1 ] )

            // assumiing it is found...
            if( inputIdx !== -1 ) {
              // change stereo field
              connection[ 0 ].inputs[ inputIdx + 2 ] = this.isStereo
            }
          }else if( connection[0].input !== undefined ) {
            if( connection[0].__redoGraph !== undefined ) {
              connection[0].__redoGraph()
            }
          }
        }
      }
    },
  }

  return ugen

}

module.exports = __ugen

},{}],211:[function(require,module,exports){
const genish = require( 'genish.js' ),
      AWPF = require( './external/audioworklet-polyfill.js' )

module.exports = function( Gibberish ) {

let uid = 0
const utilities = {
  Make: function( props ){
    const name = props.name || 'Ugen' + (Math.floor( Math.random()*10000 ) )
    const type = props.type || 'Ugen'
    const properties = props.properties || {}
    const block = `
    const ugen = Object.create( Gibberish.prototypes[ '${type}' ] )
    const graphfnc = ${props.constructor.toString()}

    const proxy = Gibberish.factory( ugen, graphfnc(), '${name}', ${JSON.stringify(properties)} )
    if( typeof props === 'object' ) Object.assign( proxy, props )

    return proxy`

    Gibberish[ name ] = new Function( 'props', block )

    Gibberish.worklet.port.postMessage({
      name,
      address:'addConstructor',
      constructorString:`function( Gibberish ) {
      const fnc = ${Gibberish[ name ].toString()}

      return fnc
    }`
    })

    return Gibberish[ name ]
  },

  createContext( ctx, cb, resolve, bufferSize=2048 ) {
    let AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext

    AWPF( window, bufferSize )

    const start = () => {
      if( typeof AC !== 'undefined' ) {
        this.ctx = Gibberish.ctx = ctx === undefined ? new AC({ latencyHint:.025 }) : ctx

        genish.gen.samplerate = this.ctx.sampleRate
        genish.utilities.ctx = this.ctx

        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
          window.removeEventListener( 'touchstart', start )
        }else{
          window.removeEventListener( 'mousedown', start )
          window.removeEventListener( 'keydown', start )
        }

        const mySource = utilities.ctx.createBufferSource()
        mySource.connect( utilities.ctx.destination )
        mySource.start()
      }

      if( typeof cb === 'function' ) cb( resolve )
    }

    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
      window.addEventListener( 'touchstart', start )
    }else{
      window.addEventListener( 'mousedown', start )
      window.addEventListener( 'keydown', start )
    }

    return Gibberish.ctx
  },
  
  createWorklet( resolve ) {
    Gibberish.ctx.audioWorklet.addModule( Gibberish.workletPath ).then( () => {
      Gibberish.worklet = new AudioWorkletNode( Gibberish.ctx, 'gibberish', { outputChannelCount:[2] } )

      Gibberish.worklet.connect( Gibberish.ctx.destination )
      Gibberish.worklet.port.onmessage = event => {
        const callback = Gibberish.utilities.workletHandlers[ event.data.address ]
        if( typeof callback === 'function' ) callback( event )     
      }
      Gibberish.worklet.ugens = new Map()

      resolve()
    })
  },

  future( fnc, time, dict ) {
    const keys = Object.keys( dict )
    const code = `
      const fnc = ${fnc.toString()}
      const args = [${keys.map( key => typeof dict[key] === 'object' ? dict[ key ].id : `'${dict[ key]}'` ).join(',')}]
      const objs = args.map( v => typeof v === 'number' ? Gibberish.processor.ugens.get(v) : v )
      Gibberish.scheduler.add( ${time}, ()=> fnc( ...objs ), 1 )
    ` 
    Gibberish.worklet.port.postMessage({ 
      address:'eval', 
      code
    })
  },

  workletHandlers: {
    phase( event ) {
      Gibberish.phase = event.data.value
      if( typeof Gibberish.onphaseupdate === 'function' ) {
        Gibberish.onphaseupdate( Gibberish.phase )
      }
    },
    __sequencer( event ) {
      const message = event.data
      const id = message.id
      const eventName = message.name
      const obj = Gibberish.worklet.ugens.get( id )
      if( obj !== undefined && obj.publish !== undefined )
        obj.publish( eventName, message )
    },
    callback( event ) {
      if( typeof Gibberish.oncallback === 'function' ) {
        Gibberish.oncallback( event.data.code )
      }
    },
    get( event ) {
      let name = event.data.name
      let value
      if( name[0] === 'Gibberish' ) {
        value = Gibberish
        name.shift()
      }
      for( let segment of name ) {
        value = value[ segment ]
      }

      Gibberish.worklet.port.postMessage({
        address:'set',
        name:'Gibberish.' + name.join('.'),
        value
      })
    },
    state( event ){
      const messages = event.data.messages
      if( messages.length === 0 ) return

      // XXX is preventProxy actually used?
      Gibberish.preventProxy = true
      Gibberish.proxyEnabled = false

      let i = 0
      while( i < messages.length ) {
        const id = messages[ i ] 
        const propName = messages[ i + 1 ]
        const valueL = messages[ i + 2 ]
        const valueR = messages[ i + 3 ]
        const value = valueL
        const obj = Gibberish.worklet.ugens.get( id )

        if( Gibberish.worklet.debug === true ) {
          if( propName !== 'output' ) console.log( propName, value, id )
        }

        if( typeof propName !== 'string' ) continue
        
        if( obj !== undefined && propName.indexOf('.') === -1 && propName !== 'id' ) { 
          if( obj[ propName ] !== undefined ) {
            if( typeof obj[ propName ] !== 'function' ) {
              if( propName === 'output' ) {
                obj[ propName ] = [ valueL, valueR ]
              }else{
                obj[ propName ] = value
              }
            }else{
              obj[ propName ]( value )
            }
          }else{
            obj[ propName ] = value
          }
        }else if( obj !== undefined ) {
          const propSplit = propName.split('.')
          if( obj[ propSplit[ 0 ] ] !== undefined ) {
            if( propSplit[1] !== undefined ) {
              if( typeof obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ] !== 'function' ) {
                obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ] = value
              }else{
                obj[ propSplit[ 0 ] ][ propSplit[ 1 ] ]( value )
              }
            }
          }else{
            //console.log( 'undefined split property!', id, propSplit[0], propSplit[1], value, obj )
          }
        }
        // XXX double check and make sure this isn't getting sent back to processornode...
        // console.log( propName, value, obj )
        i += propName === 'output' ? 4 : 3
      }
      Gibberish.preventProxy = false
      Gibberish.proxyEnabled = true
    }
  },

  createPubSub( obj ) {
    const events = {}
    obj.on = function( key, fcn ) {
      if( typeof events[ key ] === 'undefined' ) {
        events[ key ] = []
      }
      events[ key ].push( fcn )
      return obj
    }

    obj.off = function( key, fcn ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.splice( arr.indexOf( fcn ), 1 )
      }
      return obj
    }

    obj.publish = function( key, data ) {
      if( typeof events[ key ] !== 'undefined' ) {
        const arr = events[ key ]

        arr.forEach( v => v( data ) )
      }
      return obj
    }
  },

  wrap( func, ...args ) {
    const out = {
      action:'wrap',
      value:func,
      // must return objects containing only the id number to avoid
      // creating circular JSON references that would result from passing actual ugens
      args: args.map( v => { return { id:v.id } })
    }
    return out
  },

  // for wrapping upvalues in a dictionary and passing function across thread
  // to be reconstructed.
  // ex; wrapped = fn( ()=> { return Math.random() * test }, { test:20 })
  // syn.note.seq( wrapped, 1/4 )
  fn( fnc, dict={}) {
    const fncstr = fnc.toString()
    const firstBracketIdx = fncstr.indexOf('{')
    const code = fncstr.slice(firstBracketIdx+1, -1 )
    const s = { requiresRender:true, filters:[], fncstr:code, args:[], dict, addFilter( f ) { this.filters.push(f) } }  
    return s
  },

  run( fnc ) { 
    const str = fnc.tostring()
    const idx = str.indexof('=>') + 2
    const code = str.slice( idx ).trim()
    Gibberish.worklet.port.postMessage({ 
      address:'eval',
      code
    })
  },

  export( obj ) {
    obj.wrap = this.wrap
    obj.future = this.future
    obj.Make = this.Make
  },

  getUID() { return uid++ },

  base64 : {
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    // will return a  Uint8Array type
    decodeArrayBuffer: function(input) {
        var bytes = (input.length/4) * 3;
        var ab = new ArrayBuffer(bytes);
        this.decode(input, ab);

        return ab;
    },
    decode: function(input, arrayBuffer) {
      //get last chars to see if are valid
      var lkey1 = this._keyStr.indexOf(input.charAt(input.length-1));		 
      var lkey2 = this._keyStr.indexOf(input.charAt(input.length-2));		 
      var bytes = (input.length/4) * 3;
      if (lkey1 == 64) bytes--; //padding chars, so skip
      if (lkey2 == 64) bytes--; //padding chars, so skip
      var uarray;
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      var j = 0;
      if (arrayBuffer)
          uarray = new Uint8Array(arrayBuffer);
      else
          uarray = new Uint8Array(bytes);
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      for (i=0; i<bytes; i+=3) {	
          //get the 3 octects in 4 ascii chars
          enc1 = this._keyStr.indexOf(input.charAt(j++));
          enc2 = this._keyStr.indexOf(input.charAt(j++));
          enc3 = this._keyStr.indexOf(input.charAt(j++));
          enc4 = this._keyStr.indexOf(input.charAt(j++));

          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;

          uarray[i] = chr1;			
          if (enc3 != 64) uarray[i+1] = chr2;
          if (enc4 != 64) uarray[i+2] = chr3;
      }
      return uarray;	
    }
  }
}

return utilities

}

},{"./external/audioworklet-polyfill.js":148,"genish.js":51}],212:[function(require,module,exports){
const serialize = require('serialize-javascript')

module.exports = function( Gibberish ) {

const replaceObj = function( obj, shouldSerializeFunctions = true ) {
  if( typeof obj === 'object' && obj !== null && obj.id !== undefined ) {
    if( obj.__type !== 'seq' ) { // XXX why?
      return { id:obj.id, prop:obj.prop }
    }else{
      // shouldn't I be serializing most objects, not just seqs?
      return serialize( obj )
    }
  }else if( typeof obj === 'function' && shouldSerializeFunctions === true ) {
    return { isFunc:true, value:serialize( obj ) }
  }
  return obj
}

const makeAndSendObject = function( __name, values, obj ) {
  const properties = {}

  // object has already been sent through messageport...

  for( let key in values ) {
    const alreadyProcessed = (typeof values[ key ] === 'object' && values[ key ] !== null && values[ key ].__meta__ !== undefined) ||
      (typeof values[key] === 'function' && values[ key ].__meta__ !== undefined )

    if( alreadyProcessed ) { 
      properties[ key ] = { id:values[ key ].__meta__.id }
    }else if( Array.isArray( values[ key ] ) ) {
      const arr = []
      for( let i = 0; i < values[ key ].length; i++ ) {
        arr[ i ] = replaceObj( values[ key ][i], false  )
      }
      properties[ key ] = arr
    }else if( typeof values[key] === 'object' && values[key] !== null ){
      properties[ key ] = replaceObj( values[ key ], false )
    }else{
      properties[ key ] = values[ key ]
    }
  }

  let serializedProperties = serialize( properties )

  if( Array.isArray( __name ) ) {
    const oldName = __name[ __name.length - 1 ]
    __name[ __name.length - 1 ] = oldName[0].toUpperCase() + oldName.substring(1)
  }else{
    __name = [ __name[0].toUpperCase() + __name.substring(1) ]
  }

  obj.__meta__ = {
    address:'add',
    name:__name,
    properties:serializedProperties, 
    id:obj.id
  }

  Gibberish.worklet.ugens.set( obj.id, obj )

  Gibberish.worklet.port.postMessage( obj.__meta__ )
}

const doNotProxy = [ 'connected', 'input', 'wrap', 'callback', 'inputNames', 'on', 'off','publish' ]
   
const __proxy = function( __name, values, obj ) {

  if( Gibberish.mode === 'worklet' && Gibberish.preventProxy === false ) {
    makeAndSendObject( __name, values, obj )

    // proxy for all method calls to send to worklet
    const proxy = new Proxy( obj, {
      get( target, prop, receiver ) {
        if( typeof target[ prop ] === 'function' && prop.indexOf('__') === -1 && doNotProxy.indexOf( prop ) === -1 ) {
          const proxy = new Proxy( target[ prop ], {
            apply( __target, thisArg, args ) {

              if( Gibberish.proxyEnabled === true ) {
                const __args = args.map( __value => replaceObj( __value, true ) )

                Gibberish.worklet.port.postMessage({ 
                  address:'method', 
                  object:obj.id,
                  name:prop,
                  args:__args
                })
              }

              const temp = Gibberish.proxyEnabled
              Gibberish.proxyEnabled = false
              const out =  __target.apply( thisArg, args )
              Gibberish.proxyEnabled = temp
              return out
            }
          })
          
          return proxy
        }

        return target[ prop ]
      },
      set( target, prop, value, receiver ) {
        if( doNotProxy.indexOf( prop ) === -1 ) { 
          if( Gibberish.proxyEnabled === true ) {
            const __value = replaceObj( value )

            if( __value !== undefined ) {
              Gibberish.worklet.port.postMessage({ 
                address:'set', 
                object:obj.id,
                name:prop,
                value:__value
              })
            }
          }
        }

        target[ prop ] = value

        // must return true for any ES6 proxy setter
        return true
      }
    })

    // XXX XXX XXX XXX XXX XXX
    // REMEMBER THAT YOU MUST ASSIGN THE RETURNED VALUE TO YOUR UGEN,
    // YOU CANNOT USE THIS FUNCTION TO MODIFY A UGEN IN PLACE.
    // XXX XXX XXX XXX XXX XXX

    return proxy
  }else if( Gibberish.mode === 'processor' && Gibberish.preventProxy === false ) {

    const proxy = new Proxy( obj, {
      //get( target, prop, receiver ) { return target[ prop ] },
      set( target, prop, value, receiver ) {
        let valueType = typeof value
        if( prop.indexOf('__') === -1 && valueType !== 'function' && valueType !== 'object' ) {
          if( Gibberish.processor !== undefined ) { 
            Gibberish.processor.messages.push( obj.id, prop, value )
          }
        }
        target[ prop ] = value

        // must return true for any ES6 proxy setter
        return true
      }
    })

    return proxy
  }

  return obj
}

return __proxy

}

},{"serialize-javascript":231}],213:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":214}],214:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],215:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":214}],216:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":12}],217:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],218:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":4,"has-tostringtag/shams":215}],219:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":215}],220:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":1,"call-bind/callBound":4,"es-abstract/helpers/getOwnPropertyDescriptor":7,"foreach":9,"has-tostringtag/shams":215}],221:[function(require,module,exports){
'use strict'

let MemoryHelper = {
  create( sizeOrBuffer=4096, memtype=Float32Array ) {
    let helper = Object.create( this )

    // conveniently, buffer constructors accept either a size or an array buffer to use...
    // so, no matter which is passed to sizeOrBuffer it should work.
    Object.assign( helper, {
      heap: new memtype( sizeOrBuffer ),
      list: {},
      freeList: {}
    })

    return helper
  },

  alloc( size, immutable ) {
    let idx = -1

    if( size > this.heap.length ) {
      throw Error( 'Allocation request is larger than heap size of ' + this.heap.length )
    }

    for( let key in this.freeList ) {
      let candidate = this.freeList[ key ]

      if( candidate.size >= size ) {
        idx = key

        this.list[ idx ] = { size, immutable, references:1 }

        if( candidate.size !== size ) {
          let newIndex = idx + size,
              newFreeSize

          for( let key in this.list ) {
            if( key > newIndex ) {
              newFreeSize = key - newIndex
              this.freeList[ newIndex ] = newFreeSize
            }
          }
        }

        break
      }
    }

    if( idx !== -1 ) delete this.freeList[ idx ]

    if( idx === -1 ) {
      let keys = Object.keys( this.list ),
          lastIndex

      if( keys.length ) { // if not first allocation...
        lastIndex = parseInt( keys[ keys.length - 1 ] )

        idx = lastIndex + this.list[ lastIndex ].size
      }else{
        idx = 0
      }

      this.list[ idx ] = { size, immutable, references:1 }
    }

    if( idx + size >= this.heap.length ) {
      throw Error( 'No available blocks remain sufficient for allocation request.' )
    }
    return idx
  },

  addReference( index ) {
    if( this.list[ index ] !== undefined ) { 
      this.list[ index ].references++
    }
  },

  free( index ) {
    if( this.list[ index ] === undefined ) {
      throw Error( 'Calling free() on non-existing block.' )
    }

    let slot = this.list[ index ]
    if( slot === 0 ) return
    slot.references--

    if( slot.references === 0 && slot.immutable !== true ) {    
      this.list[ index ] = 0

      let freeBlockSize = 0
      for( let key in this.list ) {
        if( key > index ) {
          freeBlockSize = key - index
          break
        }
      }

      this.freeList[ index ] = freeBlockSize
    }
  },
}

module.exports = MemoryHelper

},{}],222:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],223:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":224,"./lib/tychei":225,"./lib/xor128":226,"./lib/xor4096":227,"./lib/xorshift7":228,"./lib/xorwow":229,"./seedrandom":230}],224:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],225:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],226:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],227:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],228:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],229:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],230:[function(require,module,exports){
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":3}],231:[function(require,module,exports){
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/

'use strict';

// Generate an internal UID to make the regexp pattern harder to guess.
var UID                 = Math.floor(Math.random() * 0x10000000000).toString(16);
var PLACE_HOLDER_REGEXP = new RegExp('"@__(F|R|D|M|S)-' + UID + '-(\\d+)__@"', 'g');

var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
var IS_PURE_FUNCTION = /function.*?\(/;
var IS_ARROW_FUNCTION = /.*?=>.*?/;
var UNSAFE_CHARS_REGEXP   = /[<>\/\u2028\u2029]/g;

var RESERVED_SYMBOLS = ['*', 'async'];

// Mapping of unsafe HTML and invalid JavaScript line terminator chars to their
// Unicode char counterparts which are safe to use in JavaScript strings.
var ESCAPED_CHARS = {
    '<'     : '\\u003C',
    '>'     : '\\u003E',
    '/'     : '\\u002F',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
};

function escapeUnsafeChars(unsafeChar) {
    return ESCAPED_CHARS[unsafeChar];
}

module.exports = function serialize(obj, options) {
    options || (options = {});

    // Backwards-compatibility for `space` as the second argument.
    if (typeof options === 'number' || typeof options === 'string') {
        options = {space: options};
    }

    var functions = [];
    var regexps   = [];
    var dates     = [];
    var maps      = [];
    var sets      = [];

    // Returns placeholders for functions and regexps (identified by index)
    // which are later replaced by their string representation.
    function replacer(key, value) {
        if (!value) {
            return value;
        }

        // If the value is an object w/ a toJSON method, toJSON is called before
        // the replacer runs, so we use this[key] to get the non-toJSONed value.
        var origValue = this[key];
        var type = typeof origValue;

        if (type === 'object') {
            if(origValue instanceof RegExp) {
                return '@__R-' + UID + '-' + (regexps.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Date) {
                return '@__D-' + UID + '-' + (dates.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Map) {
                return '@__M-' + UID + '-' + (maps.push(origValue) - 1) + '__@';
            }

            if(origValue instanceof Set) {
                return '@__S-' + UID + '-' + (sets.push(origValue) - 1) + '__@';
            }
        }

        if (type === 'function') {
            return '@__F-' + UID + '-' + (functions.push(origValue) - 1) + '__@';
        }

        return value;
    }

    function serializeFunc(fn) {
      var serializedFn = fn.toString();
      if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
          throw new TypeError('Serializing native function: ' + fn.name);
      }

      // pure functions, example: {key: function() {}}
      if(IS_PURE_FUNCTION.test(serializedFn)) {
          return serializedFn;
      }

      // arrow functions, example: arg1 => arg1+5
      if(IS_ARROW_FUNCTION.test(serializedFn)) {
          return serializedFn;
      }

      var argsStartsAt = serializedFn.indexOf('(');
      var def = serializedFn.substr(0, argsStartsAt)
        .trim()
        .split(' ')
        .filter(function(val) { return val.length > 0 });

      var nonReservedSymbols = def.filter(function(val) {
        return RESERVED_SYMBOLS.indexOf(val) === -1
      });

      // enhanced literal objects, example: {key() {}}
      if(nonReservedSymbols.length > 0) {
          return (def.indexOf('async') > -1 ? 'async ' : '') + 'function'
            + (def.join('').indexOf('*') > -1 ? '*' : '')
            + serializedFn.substr(argsStartsAt);
      }

      // arrow functions
      return serializedFn;
    }

    var str;

    // Creates a JSON string representation of the value.
    // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.
    if (options.isJSON && !options.space) {
        str = JSON.stringify(obj);
    } else {
        str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);
    }

    // Protects against `JSON.stringify()` returning `undefined`, by serializing
    // to the literal string: "undefined".
    if (typeof str !== 'string') {
        return String(str);
    }

    // Replace unsafe HTML and invalid JavaScript line terminator chars with
    // their safe Unicode char counterpart. This _must_ happen before the
    // regexps and functions are serialized and added back to the string.
    if (options.unsafe !== true) {
        str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
    }

    if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0) {
        return str;
    }

    // Replaces all occurrences of function, regexp, date, map and set placeholders in the
    // JSON string with their string representations. If the original value can
    // not be found, then `undefined` is used.
    return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {
        if (type === 'D') {
            return "new Date(\"" + dates[valueIndex].toISOString() + "\")";
        }

        if (type === 'R') {
            return regexps[valueIndex].toString();
        }

        if (type === 'M') {
            return "new Map(" + serialize(Array.from(maps[valueIndex].entries()), options) + ")";
        }

        if (type === 'S') {
            return "new Set(" + serialize(Array.from(sets[valueIndex].values()), options) + ")";
        }

        var fn = functions[valueIndex];

        return serializeFunc(fn);
    });
}

},{}],232:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { pattern: peg$parsepattern },
      peg$startRuleFunction  = peg$parsepattern,

      peg$c0 = function(value) {
        let out = value
        if( options.enclose === true && value.type !== 'group' ) {
          out = { type:'group', values:[ value ] }
        }
        
        return out
      },
      peg$c1 = function(_valuesstart, _valuesend) {
        _valuesend.unshift( _valuesstart )
        const values = _valuesend

        let out
        
        if( values.type === undefined ) {
          // getting nested arrays with feet...
          out = {
            values:Array.isArray( values[0] ) ? values[0] : values,
            type:'group' 
          }
        }else{
          out = values
          out.type = 'group'
        }
       
        addLoc( out, location() )

        return out
      },
      peg$c2 = peg$otherExpectation("group"),
      peg$c3 = "[",
      peg$c4 = peg$literalExpectation("[", false),
      peg$c5 = "]",
      peg$c6 = peg$literalExpectation("]", false),
      peg$c7 = function(values) {
        const out = {
          values,
          type:'group' 
        }
        
        return addLoc( out, location() ) 
      },
      peg$c8 = peg$otherExpectation("term"),
      peg$c9 = function(body) {return body},
      peg$c10 = "(",
      peg$c11 = peg$literalExpectation("(", false),
      peg$c12 = ",",
      peg$c13 = peg$literalExpectation(",", false),
      peg$c14 = ")",
      peg$c15 = peg$literalExpectation(")", false),
      peg$c16 = function(value, pulses, slots, rotation) {
        const result = {
          type:'bjorklund',
          pulses, 
          slots, 
          value,
          'rotation': rotation.length > 0 ? rotation[ 0 ] : null
        }
       
        const withLoc = addLoc( result, location() ) 
        //withLoc.value.uid = withLoc.uid
        return withLoc
      },
      peg$c17 = function(body) { return body },
      peg$c18 = "?",
      peg$c19 = peg$literalExpectation("?", false),
      peg$c20 = function(value) {
        const out = { type:'degrade', value }
        return out
        //return addLoc( out, location() )
      },
      peg$c21 = "*",
      peg$c22 = peg$literalExpectation("*", false),
      peg$c23 = function(value, rate) {
        const r =  { type:'speed', rate, value }

        if( options.addLocations === true ) {
          r.location = {
            start:value.location.start,
            end: rate.location.end
          }
        }
        
        return r 
      },
      peg$c24 = "/",
      peg$c25 = peg$literalExpectation("/", false),
      peg$c26 = function(value, rate) {
        /*const r =  { type:'slow', rate, value }*/

        //if( options.addLocations === true ) {
        //  r.location = {
        //    start:value.location.start,
        //    end: rate.location.end
        //  }
        //}
        //const group = value.type === 'group'
        //  ? value
        const group = { type:'group', values:[ value ] }

        const onestep = {
          type:'onestep',
          values:[ group ]
        }

        for( let i = 0; i < rate.value - 1; i++ ) {
          group.values.push({ type:'rest' })
        }

        addLoc( onestep, location() )
        return onestep
        /*return r */
      },
      peg$c27 = "{",
      peg$c28 = peg$literalExpectation("{", false),
      peg$c29 = "}",
      peg$c30 = peg$literalExpectation("}", false),
      peg$c31 = function(left, right) {
        const result = { 
          'left':{
            type:'group',
            values:left
          }, 
          'right':{
            type:'group',
            values:right,
          },
          type: 'polymeter' 
        }

        addLoc( result.left, location() )
        addLoc( result.right, location() )
        addLoc( result, location() )

        return result
      },
      peg$c32 = "~",
      peg$c33 = peg$literalExpectation("~", false),
      peg$c34 = function() {
       return { type:'rest' }
      },
      peg$c35 = function(start, end) {
        const out = {
          type:'group',
          values: start.map( grp => grp[0] )
        }
        out.values.push( end )

        return addLoc( out, location() )
      },
      peg$c36 = function(value) {
        return value
      },
      peg$c37 = function(body, end) {
        const values = body.map( val => val[0] )

        values.push( end )

        const result = {
          type: 'layers',
          values
        }

        return addLoc( result, location() )
      },
      peg$c38 = "<",
      peg$c39 = peg$literalExpectation("<", false),
      peg$c40 = ">",
      peg$c41 = peg$literalExpectation(">", false),
      peg$c42 = function(body, end) {
        const onestep = {
          type:'onestep',
          values:[body]
        }

        if( end !== null ) {
          onestep.values.push( end )
        }

        return addLoc( onestep, location() )
      },
      peg$c43 = peg$otherExpectation("word"),
      peg$c44 = /^[letter number]/,
      peg$c45 = peg$classExpectation(["l", "e", "t", "t", "e", "r", " ", "n", "u", "m", "b", "e", "r"], false, false),
      peg$c46 = function(value) { 
        return addLoc( { type:typeof value, value, }, location() )
      },
      peg$c47 = function(l) {
        return addLoc( { type:'string', value:text().trim() }, location() )
      },
      peg$c48 = /^[^ [\] {} () \t\n\r '*' '\/' '.' '~' '?' ',' '>' '<' ]/,
      peg$c49 = peg$classExpectation([" ", "[", "]", " ", "{", "}", " ", "(", ")", " ", "\t", "\n", "\r", " ", "'", "*", "'", " ", "'", "/", "'", " ", "'", ".", "'", " ", "'", "~", "'", " ", "'", "?", "'", " ", "'", ",", "'", " ", "'", ">", "'", " ", "'", "<", "'", " "], true, false),
      peg$c50 = function(value) {
        return addLoc( {type:'string', value }, location() )
      },
      peg$c51 = ".",
      peg$c52 = peg$literalExpectation(".", false),
      peg$c53 = "-",
      peg$c54 = peg$literalExpectation("-", false),
      peg$c55 = /^[0-9]/,
      peg$c56 = peg$classExpectation([["0", "9"]], false, false),
      peg$c57 = function() {
        return addLoc( { type:'number', value:+text().trim() }, location() )
      },
      peg$c58 = peg$otherExpectation("whitespace"),
      peg$c59 = /^[ \t\n\r ]/,
      peg$c60 = peg$classExpectation([" ", "\t", "\n", "\r", " "], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$resultsCache = {},

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsepattern() {
    var s0, s1;

    var key    = peg$currPos * 28 + 0,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsefeet();
    if (s1 === peg$FAILED) {
      s1 = peg$parselist();
      if (s1 === peg$FAILED) {
        s1 = peg$parseterm();
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselist() {
    var s0, s1, s2, s3, s4, s5;

    var key    = peg$currPos * 28 + 1,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseterm();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c1(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsegroup() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key    = peg$currPos * 28 + 2,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c3;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c5;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c2); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseterm() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 3,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsespeed();
      if (s1 === peg$FAILED) {
        s1 = peg$parseslow();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedegrade();
          if (s1 === peg$FAILED) {
            s1 = peg$parselayer();
            if (s1 === peg$FAILED) {
              s1 = peg$parsenumber();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletters();
                if (s1 === peg$FAILED) {
                  s1 = peg$parsepolymeter();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parsegroup();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseletter();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parserest();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseonestep();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseeuclid() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

    var key    = peg$currPos * 28 + 4,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenoteuclid();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseterm();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c12;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c13); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseterm();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s10 = peg$c14;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c15); }
                      }
                      if (s10 === peg$FAILED) {
                        s10 = null;
                      }
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s11 = peg$c12;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c13); }
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s13 = [];
                            s14 = peg$parseterm();
                            while (s14 !== peg$FAILED) {
                              s13.push(s14);
                              s14 = peg$parseterm();
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse_();
                              if (s14 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s15 = peg$c14;
                                  peg$currPos++;
                                } else {
                                  s15 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c15); }
                                }
                                if (s15 === peg$FAILED) {
                                  s15 = null;
                                }
                                if (s15 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c16(s2, s5, s8, s13);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenoteuclid() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 5,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsegroup();
    if (s1 === peg$FAILED) {
      s1 = peg$parsenumber();
      if (s1 === peg$FAILED) {
        s1 = peg$parseword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseletters();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletter();
            if (s1 === peg$FAILED) {
              s1 = peg$parserest();
              if (s1 === peg$FAILED) {
                s1 = peg$parseonestep();
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedegrade() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 6,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotdegrade();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 63) {
        s2 = peg$c18;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c20(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotdegrade() {
    var s0;

    var key    = peg$currPos * 28 + 7,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsenumber();
    if (s0 === peg$FAILED) {
      s0 = peg$parsespeed();
      if (s0 === peg$FAILED) {
        s0 = peg$parseslow();
        if (s0 === peg$FAILED) {
          s0 = peg$parseeuclid();
          if (s0 === peg$FAILED) {
            s0 = peg$parsegroup();
            if (s0 === peg$FAILED) {
              s0 = peg$parseletter();
              if (s0 === peg$FAILED) {
                s0 = peg$parseonestep();
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsespeed() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 8,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotspeed();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c21;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotspeed();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c23(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotspeed() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 9,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsepolymeter();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenumber();
        if (s1 === peg$FAILED) {
          s1 = peg$parselayer();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parsegroup();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseonestep();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseslow() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 10,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenotslow();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c24;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotslow();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotslow() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 11,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseeuclid();
    if (s1 === peg$FAILED) {
      s1 = peg$parsepolymeter();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenumber();
        if (s1 === peg$FAILED) {
          s1 = peg$parselayer();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parsegroup();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseonestep();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepolymeter() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    var key    = peg$currPos * 28 + 12,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c27;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseterm();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseterm();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c12;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseterm();
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseterm();
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s9 = peg$c29;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c30); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s4, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parserest() {
    var s0, s1;

    var key    = peg$currPos * 28 + 13,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 126) {
      s1 = peg$c32;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c33); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c34();
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefeet() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 14,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsefoot();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsefoot();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenotfoot();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefoot() {
    var s0, s1, s2, s3;

    var key    = peg$currPos * 28 + 15,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsenotfoot();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsenotfoot();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsedot();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotfoot() {
    var s0;

    var key    = peg$currPos * 28 + 16,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parselist();
    if (s0 === peg$FAILED) {
      s0 = peg$parsedegrade();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepolymeter();
        if (s0 === peg$FAILED) {
          s0 = peg$parserest();
          if (s0 === peg$FAILED) {
            s0 = peg$parsespeed();
            if (s0 === peg$FAILED) {
              s0 = peg$parseslow();
              if (s0 === peg$FAILED) {
                s0 = peg$parseeuclid();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsenumber();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseletter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseletters();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseword();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseonestep();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselayer() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var key    = peg$currPos * 28 + 17,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c3;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parsenotlayer();
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c12;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c13); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                if (s9 !== peg$FAILED) {
                  s6 = [s6, s7, s8, s9];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parsenotlayer();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s8 = peg$c12;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c13); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotlayer();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s7 = peg$c5;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c6); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c37(s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotlayer() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 18,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsespeed();
    if (s1 === peg$FAILED) {
      s1 = peg$parseslow();
      if (s1 === peg$FAILED) {
        s1 = peg$parselist();
        if (s1 === peg$FAILED) {
          s1 = peg$parsenumber();
          if (s1 === peg$FAILED) {
            s1 = peg$parseletters();
            if (s1 === peg$FAILED) {
              s1 = peg$parseeuclid();
              if (s1 === peg$FAILED) {
                s1 = peg$parsepolymeter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parsegroup();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseletter();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parserest();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseonestep();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseonestep() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key    = peg$currPos * 28 + 19,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      s1 = peg$c38;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenotonestep();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenotonestep();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s7 = peg$c40;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c41); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c42(s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenotonestep() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 20,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parselist();
    if (s1 === peg$FAILED) {
      s1 = peg$parseeuclid();
      if (s1 === peg$FAILED) {
        s1 = peg$parsepolymeter();
        if (s1 === peg$FAILED) {
          s1 = peg$parseword();
          if (s1 === peg$FAILED) {
            s1 = peg$parsegroup();
            if (s1 === peg$FAILED) {
              s1 = peg$parsenumber();
              if (s1 === peg$FAILED) {
                s1 = peg$parseletter();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserest();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parselayer();
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseword() {
    var s0, s1, s2, s3, s4;

    var key    = peg$currPos * 28 + 21,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c44.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c45); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c43); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseletters() {
    var s0, s1, s2, s3;

    var key    = peg$currPos * 28 + 22,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseletter();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseletter();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c47(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseletter() {
    var s0, s1, s2;

    var key    = peg$currPos * 28 + 23,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (peg$c48.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c50(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedot() {
    var s0;

    var key    = peg$currPos * 28 + 24,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.charCodeAt(peg$currPos) === 46) {
      s0 = peg$c51;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c52); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsequestion() {
    var s0;

    var key    = peg$currPos * 28 + 25,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.charCodeAt(peg$currPos) === 63) {
      s0 = peg$c18;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c19); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenumber() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key    = peg$currPos * 28 + 26,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c53;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c55.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c51;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c55.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
          }
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c51;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c55.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c56); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    var key    = peg$currPos * 28 + 27,
        cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = [];
    if (peg$c59.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c59.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }


    const addLocations = options.addLocations
   
    let uid = 0
    const addLoc = function( value, location ) {
      if( addLocations === true ) {
        value.location = location
      }
      
      if( options.addUID === true ) {
        value.uid = uid++
      }

      return value
    }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],233:[function(require,module,exports){
const parse = require('../dist/tidal.js').parse
const query = require('./queryArc.js' ).queryArc
const Fraction = require( 'fraction.js' )

/* The Pattern object is used to parse a pattern
 * a single time and then query it repeatedly, assuming
 * different start and end times for each query. A priority
 * queue is used to sort the events... 
*/
const Pattern = ( patternString, opts ) => {
  if( typeof patternString !== 'string' )
    throw 'You must provide a string to generate the pattern from'

  let __data
  try{
    __data = parse( patternString, opts )
  }catch( e ) {
    throw `We were unable to parse the pattern ${patternString}. ${e.toString()}`
  }

  const ptrn = {
    __rawString: patternString,
    __data,

    events: null,

    __sort( a,b ) { return a.arc.start.compare( b.arc.start ) },
    query( start, duration ) {
      if( typeof start !== 'object' ) start = Fraction( start )
      if( typeof duration !== 'object' ) duration = Fraction( duration )

      ptrn.events = query( 
        ptrn.__data, 
        start,
        duration 
      )
      .sort( ptrn.__sort )

      return ptrn.events
    },

    print() {
      if( ptrn.events !== null ) {
        ptrn.events.forEach( v => 
          console.log( 
            `${v.arc.start.toFraction()} - ${v.arc.end.toFraction()}: [ ${v.value.toString()} ]` 
          ) 
        )
      }else{
        console.log( 'No events have been generated from the pattern; have you queried it yet?' )
      }
    }
  }

  return ptrn
}

module.exports = Pattern

},{"../dist/tidal.js":232,"./queryArc.js":234,"fraction.js":10}],234:[function(require,module,exports){
const Fraction = require( 'fraction.js' )
const util     = require( 'util' )
const bjork    = require( 'bjork' ) 
const log      = util.inspect
const srand    = require( 'seedrandom' )

const rnd = function( phase ) {
  //console.log( 'phase', phase.toFraction() )
  return new srand( phase.toFraction() )()
}

/* queryArc
 *
 * Generates events for provided pattern, starting at
 * an initial phase, subdivides queries in individual 
 * cycles if duration of query is greater than 1 cycle.
 * Filters events outside of the the intended range. 
 * Remaps events to be relative to the initial phase.
 */
const queryArc = function( pattern, phase, duration ) {
  const start         = phase.clone(),
        end           = start.add( duration ),
        // get phase offset if scheduling begins in middle of event arc
        adjustedPhase = adjustPhase( phase, getPhaseIncr( pattern ), end )

  let eventList

  // if we're querying an arc that is less than or equal to one cycle in length..
  if( duration.valueOf() <= 1 ) {
    eventList = processPattern( 
      pattern, 
      duration, 
      adjustedPhase, 
      null, 
      null, 
      false//shouldRemap( pattern ) 
    )
  }else{
    // for longer arcs we need to query one cycle at a time
    eventList = []
    let count = 0
    for( let i = adjustedPhase.valueOf(); i < adjustedPhase.add( duration ).valueOf(); i++ ) {
      eventList = eventList.concat( 
        processPattern( 
          pattern, 
          Fraction(1),
          adjustedPhase.add( count++ ), 
          null, 
          null, 
          false
        )
      )
    }
  }

  // prune any events that fall before our start phase or after our end phase
  eventList = eventList.filter( evt => {
    return (evt.arc.start.valueOf() >= start.valueOf() 
        && evt.arc.start.valueOf()  <  end.valueOf() ) 
  })
  // remap events to make their arcs relative to initial phase argument
  .map( evt => {
    evt.arc.start = evt.arc.start.sub( start )
    evt.arc.end   = evt.arc.end.sub( start )
    return evt
  })
 
  //console.log( 'eventList:', log(eventList,{depth:4}) )
  return eventList
}

// if an event is found that represents a pattern (as opposed to a constant) this function
// is called to query the pattern and map any generated events to the appropriate timespan
const processPattern = ( pattern, duration, phase, phaseIncr=null, override = null, shouldRemapArcs=false ) => {
  //if( phaseIncr !== null ) debugger
  const state = []
  state.phase = phase
  let events = handlers[ pattern.type ]( 
    state, 
    pattern, 
    /*shouldReset( pattern ) === true ? Fraction(0) :*/ phase.clone(), 
    // XXX this is confusing. we are getting around a problem
    // with polymeters where duplicate events are generated by
    // not passing a phaseIncr... it's not needed since there's an
    // override. But this doesn't seem like correct way to solve
    // this problem and will probably cause future problems...
    phaseIncr !== null ? duration.div( phaseIncr ) : duration, 
    override 
  )

  // if needed, remap arcs for events
  if( shouldRemapArcs === true ) {
    if( phaseIncr === null ) phaseIncr = getPhaseIncr( pattern )
    events = events.map( v => ({
      value: v.value,
      arc: getMappedArc( v.arc, phase.clone(), phaseIncr )
    }) )
  }
 
  return events 
}
// placeholder for potentially adding more goodies (parent arc etc.) later
const Arc = ( start, end ) => ({ start, end })

const shouldNotRemap = ['polymeter', 'onestep']
const shouldRemap = pattern => shouldNotRemap.indexOf( pattern.type ) === -1

// XXX seems like getMappedArc should be changed to what onestep and group are now using?
// would that change work with how getMappedArc is used in processPattern?

// map arc time values to appropriate durations
const getMappedArc = ( arc, phase, phaseIncr ) => {
  let mappedArc
  
  if( phase.mod( phaseIncr ).valueOf() !== 0 ) {
    mappedArc = Arc( 
      arc.start.mul( phaseIncr ).add( phase ), 
      arc.end.mul( phaseIncr ).add( phaseIncr.mod( phase ) ) 
    )
  }else{
    mappedArc = Arc( 
      arc.start.mul( phaseIncr ).add( phase ), 
      arc.end.mul( phaseIncr ).add( phase ) 
    )
  }
  
  return mappedArc
}

// if initial phase is in the middle of an arc, advance to the end by calculating the difference
// between the current phase and the start of the next arc, and increasing phase accordingly.
const adjustPhase = ( phase, phaseIncr, end ) => phase.valueOf() === 0 
  ? Fraction(0) 
  : phase.sub( phase.mod( phaseIncr ) )

// check to see if phase should advance to next event, or, if next event is too far in the future, to the
// end of the current duration being requested.
const advancePhase = ( phase, phaseIncr, end ) => phase + phaseIncr <= end ? phase.add( phaseIncr ) : end 

// calculate the duration of the current event being processed.
const calculateDuration = ( phase, phaseIncr, end ) => phase + phaseIncr <= end ? phaseIncr : end.sub( phase )

// get an index number for a pattern for a particular phase
const getIndex = ( pattern, phase ) => {
  let idx = 0
  if( pattern.options !== undefined ) {
    if( pattern.options.overrideIncr === true ) {
      idx = phase.div( pattern.options.incr ).mod( pattern.values.length ).floor()
    }
  }else{
    // default list behavior
    idx = phase.mul( Fraction( pattern.values.length ) ).mod( pattern.values.length ).floor()
  }

  return idx.valueOf()
}

// in addition to 'fast', phase resets are also necessary when indexing subpatterns,
// which are currently arrays with no defined .type property, hence the inclusion of
// undefined in the array below
const shouldResetPhase = [ 'repeat', undefined, 'group', 'layers' ] 

// XXX does these need to look at all parents recursively? Right now we're only using one generation...
const shouldReset = pattern => {
  const reset = shouldResetPhase.indexOf( pattern.type ) > -1 
  const parent = pattern.parent !== undefined && shouldResetPhase.indexOf( pattern.parent.type ) > -1

  return reset && parent
}

// I assume this will need to be a switch on pattern.type in the future...
const getPhaseIncr = pattern => {
  let incr

  switch( pattern.type ) {
    case 'polymeter': incr = Fraction( 1, pattern.left.values.length ); break;
    case 'number': case 'string': incr = Fraction( 1 ); break;
    case 'onestep': incr = null; break;
    default:
      if( pattern.values === undefined ){
        incr = Fraction(1)
      } else {
        incr = Fraction( 1, pattern.values.length )
        //let len = 0
        //pattern.values.forEach( v => len += v.type === 'slow' ? v.rate.value : 1 )
        //incr = Fraction( 1, len ) 
      }
      break;

  }

  return incr
}

const handlers = {
  rest( state ) { return state },

  // standard lists e.g. '0 1 2 3' or '[0 1 2]'
  group( state, pattern, phase, duration, overrideIncr=null ) {
    const start     = phase.clone(),
          end       = start.add( duration ),
          phaseIncr = overrideIncr === null 
            ? getPhaseIncr( pattern ) 
            : overrideIncr
          
    let eventList = []

    //console.log( 
    //  'type:',  pattern.type, 
    //  'phase:', phase.toFraction(),
    //  'incr:',  phaseIncr.toFraction(),
    //  'dur:',   duration.toFraction()
    //)
    
    while( phase.compare( end ) < 0 ) {
      // if pattern is a list, read using current phase, else read directly
      const member = Array.isArray( pattern.values ) === true 
        ? pattern.values[ getIndex( pattern, phase ) ] 
        : pattern.value

      // get duration of current event being processed
      const dur = calculateDuration( phase, phaseIncr, end )

      // if value is not a numeric or string constant (if it's a pattern)...
      if( member === undefined || (isNaN( member.value ) && typeof member.value !== 'string') ) {
        // query the pattern and remap time values appropriately 
        if( member !== undefined ) member.parent = pattern
        //console.log( 'processing ', pattern.type, member.type, dur.toFraction(),  phaseIncr.toFraction() )
        const events = processPattern( 
          member, 
          Fraction(1), 
          //member.type !== 'slow' ? Fraction(0) : phase.clone(), 
          Fraction(0),
          null, //getPhaseIncr(member),
          null, 
          false//shouldRemap( member )
        )
        .map( evt => {
          evt.arc.start = evt.arc.start.mul( dur ).add( phase )
          evt.arc.end   = evt.arc.end.mul( dur ).add( phase )
          return evt
        })

        eventList = eventList.concat( events )
      }else{
        // XXX shouldn't we just process all patterns???
        // member does not need further processing, so add to event list
        const evt = { 
          value:member.value, 
          arc:Arc( phase, phase.add( dur ) ),
        }
        if( member.uid !== undefined ) evt.uid = member.uid 

        eventList.push( evt )
      }

      // assuming we are starting / ending at a regular phase increment value...
      
      if( phase.mod( phaseIncr ).valueOf() === 0 ) {
        phase = advancePhase( phase, phaseIncr, end )
      }else{
        // advance phase to next phase increment
        phase = phase.add( phaseIncr.sub( phase.mod( phaseIncr ) ) ) 
      }
    }

    // prune any events that fall before our start phase or after our end phase
    eventList = eventList.filter( evt => {
      return evt.arc.start.valueOf() >= start.valueOf() && evt.arc.start.valueOf() < end.valueOf()
    })
   
    return state.concat( eventList )
  },

  bjorklund( state, pattern, phase, duration ) {
    const onesAndZeros = bjork( pattern.pulses.value, pattern.slots.value )
    let rotation = pattern.rotation !== null ? pattern.rotation.value : 0
    
    // rotate right
    if( rotation > 0 ) {
      while( rotation > 0 ) {
        const right = onesAndZeros.pop()
        onesAndZeros.unshift( right )
        rotation--
      }
    } else if( rotation < 0 ) {
      // rotate left
      while( rotation < 0 ) {
        const left = onesAndZeros.shift()
        onesAndZeros.push( left )
        rotation++
      }
    }
    
    const slotDuration = duration.div( pattern.slots.value )
    const valueIsValue = pattern.value.type === 'number' || pattern.value.type === 'string'

    const events = onesAndZeros.map( ( shouldInclude, i, arr ) => {
      let evt
      // don't process unless an actual event will be included...
      if( shouldInclude === 1 ) {
        const startPhase = phase.add( slotDuration.mul( i ) )
        evt = {
          shouldInclude,
          // XXX is there a case where we should use more than 
          // the first value by querying the value pattern?
          value:valueIsValue ? pattern.value : processPattern( pattern.value, slotDuration, startPhase )[0].value,
          arc:Arc( startPhase, startPhase.add( slotDuration ) ) 
        }
      }else{
        evt = { shouldInclude }
      }

      return evt
    })
    .filter( evt => {
      let shouldInclude = evt.shouldInclude

      // needed to pass tests and is also cleaner...
      delete evt.shouldInclude
      return shouldInclude === 1
    })

    events.forEach( evt => {
      evt.uid = pattern.value.uid
      state.push( evt ) 
    })
    
    return state
  },

  onestep( state, pattern, phase, duration ) {
    pattern.values.forEach( group => {
      // initialize, then increment. this assumes that the pattern will be parsed once,
      // and then the resulting data structure will be queried repeatedly, enabling the use
      // of state.
      group.count = group.count === undefined ? 0 : group.count + 1

      const subpattern = group.values[ group.count % group.values.length ]
      const dur = duration.valueOf() <= 1 ? Fraction(1) : duration 
      const durDiff = duration.mul( dur ) 

      const events = processPattern( 
        subpattern, 
        dur,
        Fraction(0), 
        null,
        null,null,true
      ).map( evt => {
        evt.arc.start = evt.arc.start.mul( duration ).add( phase )
        evt.arc.end = evt.arc.end.mul( duration ).add( phase )

        return evt
      })  

      state.push( ...events )
    })

    return state
  },

  number( state, pattern, phase, duration ) {
    //if( phase.valueOf() === 0 ) {
      const evt = { arc:Arc( phase, phase.add( duration ) ), value:pattern.value }
      if( pattern.uid !== undefined ) evt.uid = pattern.uid
      state.push(evt)
    //}
    return state 
  },

  string( state, pattern, phase, duration ) {
    const evt = { arc:Arc( phase, phase.add( duration ) ), value:pattern.value }
    if( pattern.uid !== undefined ) evt.uid = pattern.uid
    state.push(evt)
    return state 
  },

  degrade( state, pattern, phase, duration ) {
    // attempt to seed random... rnd( state.phase )
    const rnum = Math.random()
    //console.log( 'rnd:', rnum, state.phase.toFraction() )
    if( rnum > .5 ) {
      const evt = { 
        arc:Arc( phase, phase.add( duration ) ), 
        value:pattern.value.value
      }

      //console.log( 'adding', evt )

      if( pattern.uid !== undefined ) evt.uid = pattern.uid

      state.push( evt )
    }

    return state 
  },

  polymeter( state, pattern, phase, duration ) {
    pattern.left.parent = pattern.right.parent = pattern

    const incr  = Fraction( 1, pattern.left.values.length )
    const left  = processPattern( pattern.left, duration, phase.clone(), duration, incr, false )

    pattern.right.options = { overrideIncr: true, incr }
    const right = processPattern( pattern.right, duration, phase.clone(), duration, incr, false ) 

    return state.concat( left ).concat( right )
  },

  layers( state, pattern, phase, duration ) {
    //pattern.left.parent = pattern.right.parent = pattern
    for( const group of pattern.values ) {
      const incr = getPhaseIncr( group )
      const events = processPattern( group, duration.clone(), phase.clone(), duration, null, false)
      // not sure why excess events are generated, but they need to be filtered...
      .filter( evt => 
        evt.arc.start.valueOf() >= phase.valueOf() 
        && evt.arc.start.valueOf() < phase.add( duration ).valueOf()
      )
      
      //console.log( 'group:', util.inspect( group, { depth:3 }) )
      //console.log( 'state:', util.inspect( events, { depth:3 }))
      state = state.concat( events )
    }

    return state
  },

  slow( state, pattern, phase, duration ) {
    const speed = pattern.rate.value

    let events
    //if( phase.valueOf() % speed === 0 ) {
      // XXX why do we need this edge case?
      const phaseDiff = phase.sub( phase.div( speed ) )

      if( pattern.value.type !== 'layers' ) {
        //events = queryArc(
        //  pattern.value,
        //  phase.div( speed ),
        //  duration.div( speed )
        //)
        //console.log( duration, phase, speed )
        //events = processPattern(
        //  pattern.value,
        //  duration.mul( speed ),
        //  phase.div( speed )
        //)       
        events = queryArc(
          pattern.value,
          Fraction(0),
          duration.div( speed ) 
        ).map( evt => {
          const diff = evt.arc.end.sub( evt.arc.start )
          evt.arc.start = evt.arc.start.add( phase )
          evt.arc.end   = evt.arc.start.add( duration.mul( speed ) ).add( phase )
          //console.log( diff, duration.mul( speed ), evt.arc.start, evt.arc.end )
          return evt
        })
      }else{
        events = handlers.layers( state, pattern.value, phase.div( speed ), duration.div( speed ) )
      }

      //console.log( log( events, { depth:3 }), phase.add( duration ).toFraction() )
      //if( pattern.value.type === 'group' ) {
      //  events = events.map( evt => {
      //    evt.arc.start = evt.arc.start.mul( speed )
      //    evt.arc.end   = evt.arc.end.mul( speed )
      //    return evt
      //  })
      //}
      //events = events.map( evt => {
      //  evt.arc.start = evt.arc.start.add( phaseDiff )
      //  evt.arc.end   = evt.arc.end.add( phaseDiff )
      //  //evt.arc.start = evt.arc.start.add( phase )
      //  //evt.arc.end   = evt.arc.end.add( phase )
      //  return evt
      //})
      //.filter( evt => evt.arc.start.valueOf() < phase.add( duration ).valueOf() )
    //}
    //console.log( 'slow:', log( events, { depth:3 }), phase.add( duration ).toFraction() )

    if( events !== undefined ) state = state.concat( events )

    return state
  },

//const processPattern = ( pattern, duration, phase, phaseIncr=null, override = null, shouldRemapArcs=true ) => {
  speed( state, pattern, phase, duration ) {
    // the general process of increasing the speed of a pattern is to query
    // for a longer duration according to the speed, and the scale the resulting
    // events.
    
    // following explanation from yaxu for how subpatterns work with rates...
    // https://talk.lurk.org/channel/tidal?msg=z5ck73H9EvxQwMqq6 
    // re: pattern a*[2 4 8]
    // "Anyway what happens in this kind of situation is that it splits the cycle in three, 
    // each a window on what would have happened if you'd have sped things up by the given number
    // so for the first third you'd get a third of two a's
    // for the second third you'd get the second third of four a's..."
    
    const speed = pattern.rate.value
    const events = queryArc(
      pattern.value,
      Fraction(0),
      duration.mul( speed ) 
    ).map( evt => {
      evt.arc.start = evt.arc.start.div( speed ).add( phase )
      evt.arc.end   = evt.arc.end.div( speed ).add( phase )
      return evt
    })

    // XXX account for having a speeds pattern!!!!
    /*
    
    const incr = Fraction(1, speeds.length)
    const speeds = queryArc( pattern.rate, Fraction(0), Fraction(1) )

    for( let i = 0; i < speeds.length; i++ ) {
      let speed = speeds[ i ].value

      if( pattern.operator === '*' ) {
        //events = queryArc( 
        //  pattern.value,
        //  phase.clone(), //Fraction( 0 ), 
        //  Fraction( speed ).mul( duration )
        //)
        events = processPattern(
          pattern.value,
          duration.mul( speed ),
          phase.clone()//Fraction( speed ).mul( duration )
          //phase.clone() 
        )
          
        // remap events to correct time spans
        .map( evt => {
          evt.arc.start = evt.arc.start.div( speed )//.add( phase )
          evt.arc.end   = evt.arc.end.div( speed )//.add( phase )
          return evt
        })
        //.filter( evt => 
        //  evt.arc.start.compare( incr.mul( i ) ) >= 0 
        //    && evt.arc.start.compare( incr.mul( i+1 ) ) < 0 
        //))
        // add to previous events
        .concat( events )
      }else{
        speed = 1/speed
        //console.log( 'phase:', phase.mul( speed ) )
        events = processPattern( 
          pattern.value, 
          duration.mul( Fraction( speed ) ), 
          phase.mul( speed ),
          getPhaseIncr( pattern ).mul( speed ), null, false
        )
        //console.log( 'events:', log( events, { depth:4 } ) )
        // remap events to correct time spans
        events.map( evt => {
          if( evt.arc.start.valueOf() !== 0 ) {
            // XXX I don't know why this is necessary but it gets rid of a off-by-one error
            evt.arc.start = evt.arc.start.sub( phase.div( 1/speed ) )
          }

          // also, does the event length need to be adjusted? might as well...
          //console.log( 'end:', evt.arc.end.toFraction(), phase.toFraction(), speed )
          evt.arc.end = evt.arc.end.mul( 1/speed )//.mul( 1/speed )
          //evt.arc.end.sub( phase.div( 1/speed ) ).add( 1/speed - 1)

          return evt
        })
        // remove events don't fall in the current window
        .filter( evt => 
          evt.arc.start.compare( incr.mul(i) ) >= 0 && 
          evt.arc.start.compare( incr.mul(i+1) ) <= 0 
        )
        // add to previous events
        .concat( events )
      }
    }*/

    //console.log( 'events:', log( events, { depth:4 }) )
    return state.concat( events )
  },
}

module.exports.queryArc = queryArc

},{"bjork":2,"fraction.js":10,"seedrandom":223,"util":237}],235:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],236:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":218,"is-generator-function":219,"is-typed-array":220,"which-typed-array":238}],237:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":235,"./support/types":236,"_process":222,"inherits":217}],238:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":1,"call-bind/callBound":4,"es-abstract/helpers/getOwnPropertyDescriptor":7,"foreach":9,"has-tostringtag/shams":215,"is-typed-array":220}],239:[function(require,module,exports){
const Audio = require("gibber.audio.lib"),
  Gibber = require("gibber.core.lib");
chroma = require("chroma-js");
const pallette = chroma.brewer.Set1;
console.log("pallette: ", pallette);

// console.log('Chroma: ', Chroma);
for (const key in Audio) {
  if (Object.hasOwnProperty.call(Audio, key)) {
    const element = Audio[key];
    // console.log('key: ', key, (typeof element));
  }
}
console.log("Audio: ", Audio);
const instruments = Audio.Presets.instruments;
console.log("instruments: ", instruments);
let counter = -1;
const descriptionsDisplays = [];
for (const name in instruments) {
  if (Object.hasOwnProperty.call(instruments, name)) {
    counter++;
    const instrumentTypes = instruments[name];
    // console.log('key: ', key);
    // console.log('element: ', Object.keys(element));
    const instrumentDiv = document.createElement("div");
    instrumentDiv.className = "instrument";
    const instrumentName = document.createElement("h3");
    instrumentName.className = "instrument-name";
    instrumentName.onclick = () => {
      instrumentDescription.innerHTML = "";
      claerAllDescriptions();
    };
    instrumentName.innerHTML = name + "---";
    instrumentDiv.appendChild(instrumentName);
    const instrumentDescription = document.createElement("h3");
    instrumentDiv.style.backgroundColor = chroma(
      pallette[counter % pallette.length]
    )
      .darken(2)
      .hex();
    const instrumentKeys = Object.keys(instrumentTypes);
    // if(false)

    for (let i = 0; i < instrumentKeys.length; i++) {
      const key = instrumentKeys[i];
      const properties = instrumentTypes[key];
      // console.log('properties: ', properties);
      const paramDiv = document.createElement("span");
      paramDiv.className = "param";
      const paramName = document.createElement("span");
      paramName.innerHTML = key;
      console.log("key: ", name, " - ", key);
      paramDiv.appendChild(paramName);
      paramDiv.onclick = () => {
        claerAllDescriptions();
        console.log(key, "", name);
        const properties = instruments[name][key];
        console.log("properties: ", properties);
        let string = "";
        for (const property in properties) {
          if (Object.hasOwnProperty.call(properties, property)) {
            const element = properties[property];
            console.log("property: ", property, typeof element);
            string += `${property}: ${element}<br>`;
          }
        }
        instrumentDescription.innerHTML = string;
      };
      const paramValue = document.createElement("span");
      // paramValue.innerHTML = properties;
      // if(false)
      for (const property in properties) {
        if (Object.hasOwnProperty.call(properties, property)) {
          const value = properties[property];
          // console.log('property: ', property);
          // console.log('value: ', value);
          const propertyDiv = document.createElement("div");
          propertyDiv.className = "property";
          const propertyName = document.createElement("span");
          propertyName.innerHTML = property + ".";
          propertyDiv.appendChild(propertyName);
          const propertyValue = document.createElement("span");
          propertyValue.innerHTML = value;
          propertyDiv.appendChild(propertyValue);
          paramDiv.appendChild(propertyDiv);
        }
      }
      paramDiv.appendChild(paramValue);
      instrumentDiv.appendChild(paramDiv);
    }
    instrumentDiv.appendChild(instrumentDescription);
    descriptionsDisplays.push(instrumentDescription);
    document.body.appendChild(instrumentDiv);
    // console.log('instrumentDiv: ', instrumentDiv);
  }
}
const claerAllDescriptions = () => {
  descriptionsDisplays.forEach((display) => {
    display.innerHTML = "";
  });
};
/*
//   window.onclick = function() {
    Audio.init({workletPath:'./out/gibberish_worklet.js'},Gibber).then( () => {

      const syn = Synth()
      syn.note.seq( [0,1], 1/4 )

      window.onclick = null
    })
//   }
*/

},{"chroma-js":6,"gibber.audio.lib":92,"gibber.core.lib":134}]},{},[239])


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iam9yay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hyb21hLWpzL2Nocm9tYS5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZnJhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hYnMuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2FjY3VtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hY29zLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hZC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hZHNyLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9hbmQuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2FzaW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2F0YW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2F0dGFjay5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYmFuZy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvYm9vbC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY2VpbC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY2xhbXAuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2Nvcy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY291bnRlci5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvY3ljbGUuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RhdGEuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RjYmxvY2suanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2RlY2F5LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9kZWxheS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZGVsdGEuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2Rpdi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZW52LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9lcS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZXhwLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9leHRlcm5hbC9hdWRpb3dvcmtsZXQtcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2V4dGVybmFsL3JlYWxtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZm9sZC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ2VuLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ndC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvZ3RlLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ndHAuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2hpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2lmZWxzZWlmLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9pbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2x0LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9sdGUuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL2x0cC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbWF4LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9tZW1vLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9taW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL21peC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbW9kLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9tc3Rvc2FtcHMuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL210b2YuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL211bC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbmVxLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9ub2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvbm90LmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9wYW4uanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3BhcmFtLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9wZWVrLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9waGFzb3IuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Bva2UuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Bvdy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvcm91bmQuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3NhaC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3NlcS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc2luLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9zbGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvc3ViLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy9zd2l0Y2guanMiLCJub2RlX21vZHVsZXMvZ2VuaXNoLmpzL2pzL3Q2MC5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvdGFuLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy90YW5oLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy90cmFpbi5qcyIsIm5vZGVfbW9kdWxlcy9nZW5pc2guanMvanMvdXRpbGl0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy93aW5kb3dzLmpzIiwibm9kZV9tb2R1bGVzL2dlbmlzaC5qcy9qcy93cmFwLmpzIiwibm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9hbmFseXNpcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2F1ZGlvLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvYmlub3BzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvYnVzc2VzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvY2xvY2suanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9kcnVtcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2VmZmVjdHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9lbnNlbWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2VudmVsb3Blcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2V4dGVybmFsL3JlYWxtLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvZXh0ZXJuYWwvdHVuZS1hcGktb25seS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL2ZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9mcmVlc291bmQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9nZW4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9pbnN0cnVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL21ha2UuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9vc2NpbGxhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL2J1czJfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvY2hvcnVzX3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL2NvbXBsZXhfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZGVsYXlfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZGlzdG9ydGlvbl9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9kcnVtc19wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9lZHJ1bXNfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvZmxhbmdlcl9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9mbV9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9oYXRfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMva2lja19wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9tb25vc3ludGhfcHJlc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3ByZXNldHMvbXVsdGlzYW1wbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9yZXZlcmIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL3NuYXJlX3ByZXNldHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy9wcmVzZXRzL3NvdW5kZm9udF9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvcHJlc2V0cy9zeW50aF9wcmVzZXRzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvdGhlb3J5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5hdWRpby5saWIvanMvdWdlbi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3V0aWxpdHkuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmF1ZGlvLmxpYi9qcy93YXZlT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuYXVkaW8ubGliL2pzL3dhdmVQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5jb3JlLmxpYi9qcy9ldWNsaWQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL2hleC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuY29yZS5saWIvanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3NlcS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXIuY29yZS5saWIvanMvc3RlcHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyLmNvcmUubGliL2pzL3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlci5jb3JlLmxpYi9qcy90cmlnZ2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2FuYWx5c2lzL2FuYWx5emVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvYW5hbHlzaXMvYW5hbHl6ZXJzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvYW5hbHlzaXMvZm9sbG93LmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2FuYWx5c2lzL3NpbmdsZXNhbXBsZWRlbGF5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL2FkLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL2Fkc3IuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9lbnZlbG9wZXMvZW52ZWxvcGVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZW52ZWxvcGVzL3JhbXAuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9leHRlcm5hbC9wcmlvcml0eXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZXh0ZXJuYWwvcmVhbG0uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9hbGxwYXNzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9iaXF1YWQuZHNwLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9jb21iZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9kaW9kZUZpbHRlclpERi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZmlsdGVycy9maWx0ZXIyNC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvZmlsdGVycy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvbGFkZGVyLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2ZpbHRlcnMvc3ZmLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvYml0Q3J1c2hlci5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2J1ZmZlclNodWZmbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvY2hvcnVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvZGVsYXkuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9kaXN0b3J0aW9uLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2VmZmVjdC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L2VmZmVjdHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9mbGFuZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvZnJlZXZlcmIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC9yaW5nTW9kLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvZngvdHJlbW9sby5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2Z4L3ZpYnJhdG8uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9meC93YXZlZm9sZGVyLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvY2xhcC5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9jb21wbGV4LmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2NvbmdhLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvY293YmVsbC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2ZtLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2hhdC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2luc3RydW1lbnQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9pbnN0cnVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL2thcnBsdXNzdHJvbmcuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9raWNrLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvbW9ub3N5bnRoLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL2luc3RydW1lbnRzL211bHRpc2FtcGxlci5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9wb2x5TWl4aW4uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9wb2x5dGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zYW1wbGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvaW5zdHJ1bWVudHMvc25hcmUuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zb3VuZGZvbnQuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy9zeW50aC5kc3AuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9pbnN0cnVtZW50cy90b20uanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9taXNjL2Jpbm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL21pc2MvYnVzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvbWlzYy9idXMyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvbWlzYy9tb25vcHMuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9taXNjL3Bhbm5lci5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL21pc2MvdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL2Jyb3dubm9pc2UuZHNwLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvb3NjaWxsYXRvcnMvZm1mZWVkYmFja29zYy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL29zY2lsbGF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvb3NjaWxsYXRvcnMvcGlua25vaXNlLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL3BvbHlibGVwLmRzcC5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL29zY2lsbGF0b3JzL3dhdmV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3NjaGVkdWxpbmcvc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvc2NoZWR1bGluZy9zZXEyLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvc2NoZWR1bGluZy9zZXF1ZW5jZXIuanMiLCJub2RlX21vZHVsZXMvZ2liYmVyaXNoLWRzcC9qcy9zY2hlZHVsaW5nL3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL2dpYmJlcmlzaC1kc3AvanMvdWdlbi5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9naWJiZXJpc2gtZHNwL2pzL3dvcmtsZXRQcm94eS5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LWhlbHBlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9zZXJpYWxpemUtamF2YXNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aWRhbC5wZWdqcy9kaXN0L3RpZGFsLmpzIiwibm9kZV9tb2R1bGVzL3RpZGFsLnBlZ2pzL3NyYy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3RpZGFsLnBlZ2pzL3NyYy9xdWVyeUFyYy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJzcmMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8vR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbndCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3IzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iLCJmdW5jdGlvbiBiam9ya2x1bmQoc2xvdHMsIHB1bHNlcyl7XG4gIHZhciBwYXR0ZXJuID0gW10sXG4gICAgICBjb3VudCA9IFtdLFxuICAgICAgcmVtYWluZGVyID0gW3B1bHNlc10sXG4gICAgICBkaXZpc29yID0gc2xvdHMgLSBwdWxzZXMsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICBidWlsZF9wYXR0ZXJuID0gZnVuY3Rpb24obHYpe1xuICAgICAgICBpZiggbHYgPT0gLTEgKXsgcGF0dGVybi5wdXNoKDApOyB9XG4gICAgICAgIGVsc2UgaWYoIGx2ID09IC0yICl7IHBhdHRlcm4ucHVzaCgxKTsgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIGZvcih2YXIgeD0wOyB4PGNvdW50W2x2XTsgeCsrKXtcbiAgICAgICAgICAgIGJ1aWxkX3BhdHRlcm4obHYtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYocmVtYWluZGVyW2x2XSl7XG4gICAgICAgICAgICBidWlsZF9wYXR0ZXJuKGx2LTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICA7XG5cbiAgd2hpbGUocmVtYWluZGVyW2xldmVsXSA+IDEpe1xuICAgIGNvdW50LnB1c2goTWF0aC5mbG9vcihkaXZpc29yL3JlbWFpbmRlcltsZXZlbF0pKTtcbiAgICByZW1haW5kZXIucHVzaChkaXZpc29yJXJlbWFpbmRlcltsZXZlbF0pO1xuICAgIGRpdmlzb3IgPSByZW1haW5kZXJbbGV2ZWxdO1xuICAgIGxldmVsKys7XG4gIH1cbiAgY291bnQucHVzaChkaXZpc29yKTtcblxuICBidWlsZF9wYXR0ZXJuKGxldmVsKTtcblxuICByZXR1cm4gcGF0dGVybi5yZXZlcnNlKCk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtLCBrKXtcbiAgaWYobSA+IGspIHJldHVybiBiam9ya2x1bmQobSwgayk7XG4gIGVsc2UgcmV0dXJuIGJqb3JrbHVuZChrLCBtKTtcbn07XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIvKipcbiAqIGNocm9tYS5qcyAtIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgY29sb3IgY29udmVyc2lvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxOSwgR3JlZ29yIEFpc2NoXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBUaGUgbmFtZSBHcmVnb3IgQWlzY2ggbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICogZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR1JFR09SIEFJU0NIIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORyxcbiAqIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxuICogRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogY2hyb21hLmpzIGluY2x1ZGVzIGNvbG9ycyBmcm9tIGNvbG9yYnJld2VyMi5vcmcsIHdoaWNoIGFyZSByZWxlYXNlZCB1bmRlclxuICogdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlcixcbiAqIGFuZCBUaGUgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsXG4gKiBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpY1xuICogbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBOYW1lZCBjb2xvcnMgYXJlIHRha2VuIGZyb20gWDExIENvbG9yIE5hbWVzLlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gKlxuICogQHByZXNlcnZlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuY2hyb21hID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBsaW1pdCQyID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmICggbWluID09PSB2b2lkIDAgKSBtaW49MDtcbiAgICAgICAgaWYgKCBtYXggPT09IHZvaWQgMCApIG1heD0xO1xuXG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG4gICAgfTtcblxuICAgIHZhciBsaW1pdCQxID0gbGltaXQkMjtcblxuICAgIHZhciBjbGlwX3JnYiQzID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgICByZ2IuX2NsaXBwZWQgPSBmYWxzZTtcbiAgICAgICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTw9MzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHsgcmdiLl9jbGlwcGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0JDEocmdiW2ldLCAwLCAyNTUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmdiW2ldID0gbGltaXQkMShyZ2JbaV0sIDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIC8vIHBvcnRlZCBmcm9tIGpRdWVyeSdzICQudHlwZVxuICAgIHZhciBjbGFzc1RvVHlwZSA9IHt9O1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IFsnQm9vbGVhbicsICdOdW1iZXInLCAnU3RyaW5nJywgJ0Z1bmN0aW9uJywgJ0FycmF5JywgJ0RhdGUnLCAnUmVnRXhwJywgJ1VuZGVmaW5lZCcsICdOdWxsJ107IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgY2xhc3NUb1R5cGVbKFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIildID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICB2YXIgdHlwZSRwID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBjbGFzc1RvVHlwZVtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIjtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGUkbyA9IHR5cGUkcDtcblxuICAgIHZhciB1bnBhY2skQiA9IGZ1bmN0aW9uIChhcmdzLCBrZXlPcmRlcikge1xuICAgICAgICBpZiAoIGtleU9yZGVyID09PSB2b2lkIDAgKSBrZXlPcmRlcj1udWxsO1xuXG4gICAgXHQvLyBpZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gMyBhcmd1bWVudHMsIHdlIHJldHVybiB0aGUgYXJndW1lbnRzXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgfVxuICAgICAgICAvLyB3aXRoIGxlc3MgdGhhbiAzIGFyZ3Mgd2UgY2hlY2sgaWYgZmlyc3QgYXJnIGlzIG9iamVjdFxuICAgICAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG4gICAgXHRpZiAodHlwZSRvKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgXHRcdHJldHVybiBrZXlPcmRlci5zcGxpdCgnJylcbiAgICBcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBhcmdzWzBdW2tdICE9PSB1bmRlZmluZWQ7IH0pXG4gICAgXHRcdFx0Lm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gYXJnc1swXVtrXTsgfSk7XG4gICAgXHR9XG4gICAgXHQvLyBvdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgXHQvLyAod2hpY2ggd2Ugc3VwcG9zZSBpcyBhbiBhcnJheSBvZiBhcmdzKVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGUkbiA9IHR5cGUkcDtcblxuICAgIHZhciBsYXN0JDQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBsID0gYXJncy5sZW5ndGgtMTtcbiAgICAgICAgaWYgKHR5cGUkbihhcmdzW2xdKSA9PSAnc3RyaW5nJykgeyByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgUEkkMiA9IE1hdGguUEk7XG5cbiAgICB2YXIgdXRpbHMgPSB7XG4gICAgXHRjbGlwX3JnYjogY2xpcF9yZ2IkMyxcbiAgICBcdGxpbWl0OiBsaW1pdCQyLFxuICAgIFx0dHlwZTogdHlwZSRwLFxuICAgIFx0dW5wYWNrOiB1bnBhY2skQixcbiAgICBcdGxhc3Q6IGxhc3QkNCxcbiAgICBcdFBJOiBQSSQyLFxuICAgIFx0VFdPUEk6IFBJJDIqMixcbiAgICBcdFBJVEhJUkQ6IFBJJDIvMyxcbiAgICBcdERFRzJSQUQ6IFBJJDIgLyAxODAsXG4gICAgXHRSQUQyREVHOiAxODAgLyBQSSQyXG4gICAgfTtcblxuICAgIHZhciBpbnB1dCRoID0ge1xuICAgIFx0Zm9ybWF0OiB7fSxcbiAgICBcdGF1dG9kZXRlY3Q6IFtdXG4gICAgfTtcblxuICAgIHZhciBsYXN0JDMgPSB1dGlscy5sYXN0O1xuICAgIHZhciBjbGlwX3JnYiQyID0gdXRpbHMuY2xpcF9yZ2I7XG4gICAgdmFyIHR5cGUkbSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIF9pbnB1dCA9IGlucHV0JGg7XG5cbiAgICB2YXIgQ29sb3IkRCA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlJG0oYXJnc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAvLyB0aGUgYXJndW1lbnQgaXMgYWxyZWFkeSBhIENvbG9yIGluc3RhbmNlXG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhc3QgYXJndW1lbnQgY291bGQgYmUgdGhlIG1vZGVcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDMoYXJncyk7XG4gICAgICAgIHZhciBhdXRvZGV0ZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgICBhdXRvZGV0ZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghX2lucHV0LnNvcnRlZCkge1xuICAgICAgICAgICAgICAgIF9pbnB1dC5hdXRvZGV0ZWN0ID0gX2lucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBiLnAgLSBhLnA7IH0pO1xuICAgICAgICAgICAgICAgIF9pbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0by1kZXRlY3QgZm9ybWF0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IF9pbnB1dC5hdXRvZGV0ZWN0OyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGsgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICAgICAgbW9kZSA9IGNoay50ZXN0LmFwcGx5KGNoaywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaW5wdXQuZm9ybWF0W21vZGVdKSB7XG4gICAgICAgICAgICB2YXIgcmdiID0gX2lucHV0LmZvcm1hdFttb2RlXS5hcHBseShudWxsLCBhdXRvZGV0ZWN0ID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwtMSkpO1xuICAgICAgICAgICAgbWUuX3JnYiA9IGNsaXBfcmdiJDIocmdiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQ6ICcrYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYWxwaGEgY2hhbm5lbFxuICAgICAgICBpZiAobWUuX3JnYi5sZW5ndGggPT09IDMpIHsgbWUuX3JnYi5wdXNoKDEpOyB9XG4gICAgfTtcblxuICAgIENvbG9yJEQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICBpZiAodHlwZSRtKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB0aGlzLmhleCgpOyB9XG4gICAgICAgIHJldHVybiAoXCJbXCIgKyAodGhpcy5fcmdiLmpvaW4oJywnKSkgKyBcIl1cIik7XG4gICAgfTtcblxuICAgIHZhciBDb2xvcl8xID0gQ29sb3IkRDtcblxuICAgIHZhciBjaHJvbWEkayA9IGZ1bmN0aW9uICgpIHtcbiAgICBcdHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgXHR3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgXHRyZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggY2hyb21hJGsuQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncykgKSk7XG4gICAgfTtcblxuICAgIGNocm9tYSRrLkNvbG9yID0gQ29sb3JfMTtcbiAgICBjaHJvbWEkay52ZXJzaW9uID0gJzIuNC4yJztcblxuICAgIHZhciBjaHJvbWFfMSA9IGNocm9tYSRrO1xuXG4gICAgdmFyIHVucGFjayRBID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBtYXgkMiA9IE1hdGgubWF4O1xuXG4gICAgdmFyIHJnYjJjbXlrJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRBKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgciA9IHIgLyAyNTU7XG4gICAgICAgIGcgPSBnIC8gMjU1O1xuICAgICAgICBiID0gYiAvIDI1NTtcbiAgICAgICAgdmFyIGsgPSAxIC0gbWF4JDIocixtYXgkMihnLGIpKTtcbiAgICAgICAgdmFyIGYgPSBrIDwgMSA/IDEgLyAoMS1rKSA6IDA7XG4gICAgICAgIHZhciBjID0gKDEtci1rKSAqIGY7XG4gICAgICAgIHZhciBtID0gKDEtZy1rKSAqIGY7XG4gICAgICAgIHZhciB5ID0gKDEtYi1rKSAqIGY7XG4gICAgICAgIHJldHVybiBbYyxtLHksa107XG4gICAgfTtcblxuICAgIHZhciByZ2IyY215a18xID0gcmdiMmNteWskMTtcblxuICAgIHZhciB1bnBhY2skeiA9IHV0aWxzLnVucGFjaztcblxuICAgIHZhciBjbXlrMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJHooYXJncywgJ2NteWsnKTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgbSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICAgICAgdmFyIGsgPSBhcmdzWzNdO1xuICAgICAgICB2YXIgYWxwaGEgPSBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogMTtcbiAgICAgICAgaWYgKGsgPT09IDEpIHsgcmV0dXJuIFswLDAsMCxhbHBoYV07IH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGMgPj0gMSA/IDAgOiAyNTUgKiAoMS1jKSAqICgxLWspLCAvLyByXG4gICAgICAgICAgICBtID49IDEgPyAwIDogMjU1ICogKDEtbSkgKiAoMS1rKSwgLy8gZ1xuICAgICAgICAgICAgeSA+PSAxID8gMCA6IDI1NSAqICgxLXkpICogKDEtayksIC8vIGJcbiAgICAgICAgICAgIGFscGhhXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciBjbXlrMnJnYl8xID0gY215azJyZ2I7XG5cbiAgICB2YXIgY2hyb21hJGogPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkQyA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JGcgPSBpbnB1dCRoO1xuICAgIHZhciB1bnBhY2skeSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRsID0gdXRpbHMudHlwZTtcblxuICAgIHZhciByZ2IyY215ayA9IHJnYjJjbXlrXzE7XG5cbiAgICBDb2xvciRDLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyY215ayh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkai5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRDLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnY215ayddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkZy5mb3JtYXQuY215ayA9IGNteWsycmdiXzE7XG5cbiAgICBpbnB1dCRnLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJHkoYXJncywgJ2NteWsnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGwoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NteWsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJHggPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxhc3QkMiA9IHV0aWxzLmxhc3Q7XG4gICAgdmFyIHJuZCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBNYXRoLnJvdW5kKGEqMTAwKS8xMDA7IH07XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSBoc2wyY3NzKGgscyxsKVxuICAgICAqIC0gaHNsMmNzcyhoLHMsbCxhKVxuICAgICAqIC0gaHNsMmNzcyhbaCxzLGxdLCBtb2RlKVxuICAgICAqIC0gaHNsMmNzcyhbaCxzLGwsYV0sIG1vZGUpXG4gICAgICogLSBoc2wyY3NzKHtoLHMsbCxhfSwgbW9kZSlcbiAgICAgKi9cbiAgICB2YXIgaHNsMmNzcyQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBoc2xhID0gdW5wYWNrJHgoYXJncywgJ2hzbGEnKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDIoYXJncykgfHwgJ2xzYSc7XG4gICAgICAgIGhzbGFbMF0gPSBybmQoaHNsYVswXSB8fCAwKTtcbiAgICAgICAgaHNsYVsxXSA9IHJuZChoc2xhWzFdKjEwMCkgKyAnJSc7XG4gICAgICAgIGhzbGFbMl0gPSBybmQoaHNsYVsyXSoxMDApICsgJyUnO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2hzbGEnIHx8IChoc2xhLmxlbmd0aCA+IDMgJiYgaHNsYVszXTwxKSkge1xuICAgICAgICAgICAgaHNsYVszXSA9IGhzbGEubGVuZ3RoID4gMyA/IGhzbGFbM10gOiAxO1xuICAgICAgICAgICAgbW9kZSA9ICdoc2xhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhzbGEubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG1vZGUgKyBcIihcIiArIChoc2xhLmpvaW4oJywnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciBoc2wyY3NzXzEgPSBoc2wyY3NzJDE7XG5cbiAgICB2YXIgdW5wYWNrJHcgPSB1dGlscy51bnBhY2s7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyaHNsKHIsZyxiKVxuICAgICAqIC0gcmdiMmhzbChyLGcsYixhKVxuICAgICAqIC0gcmdiMmhzbChbcixnLGJdKVxuICAgICAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gICAgICogLSByZ2IyaHNsKHtyLGcsYixhfSlcbiAgICAgKi9cbiAgICB2YXIgcmdiMmhzbCQzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skdyhhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuXG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG5cbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cbiAgICAgICAgdmFyIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgICAgIHZhciBzLCBoO1xuXG4gICAgICAgIGlmIChtYXggPT09IG1pbil7XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGwgPCAwLjUgPyAobWF4IC0gbWluKSAvIChtYXggKyBtaW4pIDogKG1heCAtIG1pbikgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA9PSBtYXgpIHsgaCA9IChnIC0gYikgLyAobWF4IC0gbWluKTsgfVxuICAgICAgICBlbHNlIGlmIChnID09IG1heCkgeyBoID0gMiArIChiIC0gcikgLyAobWF4IC0gbWluKTsgfVxuICAgICAgICBlbHNlIGlmIChiID09IG1heCkgeyBoID0gNCArIChyIC0gZykgLyAobWF4IC0gbWluKTsgfVxuXG4gICAgICAgIGggKj0gNjA7XG4gICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGg+MyAmJiBhcmdzWzNdIT09dW5kZWZpbmVkKSB7IHJldHVybiBbaCxzLGwsYXJnc1szXV07IH1cbiAgICAgICAgcmV0dXJuIFtoLHMsbF07XG4gICAgfTtcblxuICAgIHZhciByZ2IyaHNsXzEgPSByZ2IyaHNsJDM7XG5cbiAgICB2YXIgdW5wYWNrJHYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxhc3QkMSA9IHV0aWxzLmxhc3Q7XG4gICAgdmFyIGhzbDJjc3MgPSBoc2wyY3NzXzE7XG4gICAgdmFyIHJnYjJoc2wkMiA9IHJnYjJoc2xfMTtcbiAgICB2YXIgcm91bmQkNiA9IE1hdGgucm91bmQ7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyY3NzKHIsZyxiKVxuICAgICAqIC0gcmdiMmNzcyhyLGcsYixhKVxuICAgICAqIC0gcmdiMmNzcyhbcixnLGJdLCBtb2RlKVxuICAgICAqIC0gcmdiMmNzcyhbcixnLGIsYV0sIG1vZGUpXG4gICAgICogLSByZ2IyY3NzKHtyLGcsYixhfSwgbW9kZSlcbiAgICAgKi9cbiAgICB2YXIgcmdiMmNzcyQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrJHYoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDEoYXJncykgfHwgJ3JnYic7XG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDMpID09ICdoc2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gaHNsMmNzcyhyZ2IyaHNsJDIocmdiYSksIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJnYmFbMF0gPSByb3VuZCQ2KHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gcm91bmQkNihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IHJvdW5kJDYocmdiYVsyXSk7XG4gICAgICAgIGlmIChtb2RlID09PSAncmdiYScgfHwgKHJnYmEubGVuZ3RoID4gMyAmJiByZ2JhWzNdPDEpKSB7XG4gICAgICAgICAgICByZ2JhWzNdID0gcmdiYS5sZW5ndGggPiAzID8gcmdiYVszXSA6IDE7XG4gICAgICAgICAgICBtb2RlID0gJ3JnYmEnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobW9kZSArIFwiKFwiICsgKHJnYmEuc2xpY2UoMCxtb2RlPT09J3JnYic/Mzo0KS5qb2luKCcsJykpICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmNzc18xID0gcmdiMmNzcyQxO1xuXG4gICAgdmFyIHVucGFjayR1ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByb3VuZCQ1ID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBoc2wycmdiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhc3NpZ247XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayR1KGFyZ3MsICdoc2wnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBsID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgciA9IGcgPSBiID0gbCoyNTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdDMgPSBbMCwwLDBdO1xuICAgICAgICAgICAgdmFyIGMgPSBbMCwwLDBdO1xuICAgICAgICAgICAgdmFyIHQyID0gbCA8IDAuNSA/IGwgKiAoMStzKSA6IGwrcy1sKnM7XG4gICAgICAgICAgICB2YXIgdDEgPSAyICogbCAtIHQyO1xuICAgICAgICAgICAgdmFyIGhfID0gaCAvIDM2MDtcbiAgICAgICAgICAgIHQzWzBdID0gaF8gKyAxLzM7XG4gICAgICAgICAgICB0M1sxXSA9IGhfO1xuICAgICAgICAgICAgdDNbMl0gPSBoXyAtIDEvMztcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTwzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodDNbaV0gPCAwKSB7IHQzW2ldICs9IDE7IH1cbiAgICAgICAgICAgICAgICBpZiAodDNbaV0gPiAxKSB7IHQzW2ldIC09IDE7IH1cbiAgICAgICAgICAgICAgICBpZiAoNiAqIHQzW2ldIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNbaV07IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgyICogdDNbaV0gPCAxKVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MjsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDMgKiB0M1tpXSA8IDIpXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogKCgyIC8gMykgLSB0M1tpXSkgKiA2OyB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKGFzc2lnbiA9IFtyb3VuZCQ1KGNbMF0qMjU1KSxyb3VuZCQ1KGNbMV0qMjU1KSxyb3VuZCQ1KGNbMl0qMjU1KV0sIHIgPSBhc3NpZ25bMF0sIGcgPSBhc3NpZ25bMV0sIGIgPSBhc3NpZ25bMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgYWxwaGEgY2hhbm5lbFxuICAgICAgICAgICAgcmV0dXJuIFtyLGcsYixhcmdzWzNdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgIH07XG5cbiAgICB2YXIgaHNsMnJnYl8xID0gaHNsMnJnYiQxO1xuXG4gICAgdmFyIGhzbDJyZ2IgPSBoc2wycmdiXzE7XG4gICAgdmFyIGlucHV0JGYgPSBpbnB1dCRoO1xuXG4gICAgdmFyIFJFX1JHQiA9IC9ecmdiXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuICAgIHZhciBSRV9SR0JBID0gL15yZ2JhXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuICAgIHZhciBSRV9SR0JfUENUID0gL15yZ2JcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG4gICAgdmFyIFJFX1JHQkFfUENUID0gL15yZ2JhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuICAgIHZhciBSRV9IU0wgPSAvXmhzbFxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICAgIHZhciBSRV9IU0xBID0gL15oc2xhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG5cbiAgICB2YXIgcm91bmQkNCA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgY3NzMnJnYiQxID0gZnVuY3Rpb24gKGNzcykge1xuICAgICAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHZhciBtO1xuXG4gICAgICAgIGlmIChpbnB1dCRmLmZvcm1hdC5uYW1lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQkZi5mb3JtYXQubmFtZWQoY3NzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYigyNTAsMjAsMClcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQikpKSB7XG4gICAgICAgICAgICB2YXIgcmdiID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHJnYltpXSA9ICtyZ2JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZ2JbM10gPSAxOyAgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHJnYjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYmEoMjUwLDIwLDAsMC40KVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCQSkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDEgPSBtLnNsaWNlKDEsNSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDE9MDsgaSQxPDQ7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgcmdiJDFbaSQxXSA9ICtyZ2IkMVtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJnYiQxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiKDEwMCUsMCUsMCUpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JfUENUKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IkMiA9IG0uc2xpY2UoMSw0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMj0wOyBpJDI8MzsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkMltpJDJdID0gcm91bmQkNChyZ2IkMltpJDJdICogMi41NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZ2IkMlszXSA9IDE7ICAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gcmdiJDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2JhKDEwMCUsMCUsMCUsMC40KVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCQV9QQ1QpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiQzID0gbS5zbGljZSgxLDUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQzPTA7IGkkMzwzOyBpJDMrKykge1xuICAgICAgICAgICAgICAgIHJnYiQzW2kkM10gPSByb3VuZCQ0KHJnYiQzW2kkM10gKiAyLjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYiQzWzNdID0gK3JnYiQzWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHNsKDAsMTAwJSw1MCUpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9IU0wpKSkge1xuICAgICAgICAgICAgdmFyIGhzbCA9IG0uc2xpY2UoMSw0KTtcbiAgICAgICAgICAgIGhzbFsxXSAqPSAwLjAxO1xuICAgICAgICAgICAgaHNsWzJdICo9IDAuMDE7XG4gICAgICAgICAgICB2YXIgcmdiJDQgPSBoc2wycmdiKGhzbCk7XG4gICAgICAgICAgICByZ2IkNFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gcmdiJDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoc2xhKDAsMTAwJSw1MCUsMC41KVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfSFNMQSkpKSB7XG4gICAgICAgICAgICB2YXIgaHNsJDEgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBoc2wkMVsxXSAqPSAwLjAxO1xuICAgICAgICAgICAgaHNsJDFbMl0gKj0gMC4wMTtcbiAgICAgICAgICAgIHZhciByZ2IkNSA9IGhzbDJyZ2IoaHNsJDEpO1xuICAgICAgICAgICAgcmdiJDVbM10gPSArbVs0XTsgIC8vIGRlZmF1bHQgYWxwaGEgPSAxXG4gICAgICAgICAgICByZXR1cm4gcmdiJDU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY3NzMnJnYiQxLnRlc3QgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gUkVfUkdCLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX1JHQkEudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCX1BDVC50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9SR0JBX1BDVC50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9IU0wudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfSFNMQS50ZXN0KHMpO1xuICAgIH07XG5cbiAgICB2YXIgY3NzMnJnYl8xID0gY3NzMnJnYiQxO1xuXG4gICAgdmFyIGNocm9tYSRpID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJEIgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCRlID0gaW5wdXQkaDtcbiAgICB2YXIgdHlwZSRrID0gdXRpbHMudHlwZTtcblxuICAgIHZhciByZ2IyY3NzID0gcmdiMmNzc18xO1xuICAgIHZhciBjc3MycmdiID0gY3NzMnJnYl8xO1xuXG4gICAgQ29sb3IkQi5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgICByZXR1cm4gcmdiMmNzcyh0aGlzLl9yZ2IsIG1vZGUpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkaS5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJEIsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydjc3MnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGUuZm9ybWF0LmNzcyA9IGNzczJyZ2I7XG5cbiAgICBpbnB1dCRlLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDUsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJGsoaCkgPT09ICdzdHJpbmcnICYmIGNzczJyZ2IudGVzdChoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY3NzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIENvbG9yJEEgPSBDb2xvcl8xO1xuICAgIHZhciBjaHJvbWEkaCA9IGNocm9tYV8xO1xuICAgIHZhciBpbnB1dCRkID0gaW5wdXQkaDtcbiAgICB2YXIgdW5wYWNrJHQgPSB1dGlscy51bnBhY2s7XG5cbiAgICBpbnB1dCRkLmZvcm1hdC5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrJHQoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgcmdiWzBdICo9IDI1NTtcbiAgICAgICAgcmdiWzFdICo9IDI1NTtcbiAgICAgICAgcmdiWzJdICo9IDI1NTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9O1xuXG4gICAgY2hyb21hJGguZ2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJEEsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydnbCddKSApKTtcbiAgICB9O1xuXG4gICAgQ29sb3IkQS5wcm90b3R5cGUuZ2wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMuX3JnYjtcbiAgICAgICAgcmV0dXJuIFtyZ2JbMF0vMjU1LCByZ2JbMV0vMjU1LCByZ2JbMl0vMjU1LCByZ2JbM11dO1xuICAgIH07XG5cbiAgICB2YXIgdW5wYWNrJHMgPSB1dGlscy51bnBhY2s7XG5cbiAgICB2YXIgcmdiMmhjZyQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skcyhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICAgIHZhciBjID0gZGVsdGEgKiAxMDAgLyAyNTU7XG4gICAgICAgIHZhciBfZyA9IG1pbiAvICgyNTUgLSBkZWx0YSkgKiAxMDA7XG4gICAgICAgIHZhciBoO1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHIgPT09IG1heCkgeyBoID0gKGcgLSBiKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoZyA9PT0gbWF4KSB7IGggPSAyKyhiIC0gcikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGIgPT09IG1heCkgeyBoID0gNCsociAtIGcpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2gsIGMsIF9nXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoY2dfMSA9IHJnYjJoY2ckMTtcblxuICAgIHZhciB1bnBhY2skciA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgZmxvb3IkMyA9IE1hdGguZmxvb3I7XG5cbiAgICAvKlxuICAgICAqIHRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgSFNWIHdpdGggc29tZSBtaW5vciB0d2Vha3NcbiAgICAgKlxuICAgICAqIGh1ZS4uIFswLi4zNjBdXG4gICAgICogY2hyb21hIC4uIFswLi4xXVxuICAgICAqIGdyYXluZXNzIC4uIFswLi4xXVxuICAgICAqL1xuXG4gICAgdmFyIGhjZzJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMiwgYXNzaWduJDMsIGFzc2lnbiQ0LCBhc3NpZ24kNTtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICAgICAgICBhcmdzID0gdW5wYWNrJHIoYXJncywgJ2hjZycpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIF9nID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICBfZyA9IF9nICogMjU1O1xuICAgICAgICB2YXIgX2MgPSBjICogMjU1O1xuICAgICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgICAgciA9IGcgPSBiID0gX2c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaCA9PT0gMzYwKSB7IGggPSAwOyB9XG4gICAgICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgICAgICBoIC89IDYwO1xuICAgICAgICAgICAgdmFyIGkgPSBmbG9vciQzKGgpO1xuICAgICAgICAgICAgdmFyIGYgPSBoIC0gaTtcbiAgICAgICAgICAgIHZhciBwID0gX2cgKiAoMSAtIGMpO1xuICAgICAgICAgICAgdmFyIHEgPSBwICsgX2MgKiAoMSAtIGYpO1xuICAgICAgICAgICAgdmFyIHQgPSBwICsgX2MgKiBmO1xuICAgICAgICAgICAgdmFyIHYgPSBwICsgX2M7XG4gICAgICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IChhc3NpZ24gPSBbdiwgdCwgcF0sIHIgPSBhc3NpZ25bMF0sIGcgPSBhc3NpZ25bMV0sIGIgPSBhc3NpZ25bMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMTogKGFzc2lnbiQxID0gW3EsIHYsIHBdLCByID0gYXNzaWduJDFbMF0sIGcgPSBhc3NpZ24kMVsxXSwgYiA9IGFzc2lnbiQxWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IChhc3NpZ24kMiA9IFtwLCB2LCB0XSwgciA9IGFzc2lnbiQyWzBdLCBnID0gYXNzaWduJDJbMV0sIGIgPSBhc3NpZ24kMlsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAzOiAoYXNzaWduJDMgPSBbcCwgcSwgdl0sIHIgPSBhc3NpZ24kM1swXSwgZyA9IGFzc2lnbiQzWzFdLCBiID0gYXNzaWduJDNbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNDogKGFzc2lnbiQ0ID0gW3QsIHAsIHZdLCByID0gYXNzaWduJDRbMF0sIGcgPSBhc3NpZ24kNFsxXSwgYiA9IGFzc2lnbiQ0WzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IChhc3NpZ24kNSA9IFt2LCBwLCBxXSwgciA9IGFzc2lnbiQ1WzBdLCBnID0gYXNzaWduJDVbMV0sIGIgPSBhc3NpZ24kNVsyXSk7IGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBoY2cycmdiXzEgPSBoY2cycmdiO1xuXG4gICAgdmFyIHVucGFjayRxID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGogPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkZyA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR6ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkYyA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhjZyA9IHJnYjJoY2dfMTtcblxuICAgIENvbG9yJHoucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhjZyh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkZy5oY2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHosIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoY2cnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGMuZm9ybWF0LmhjZyA9IGhjZzJyZ2JfMTtcblxuICAgIGlucHV0JGMuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skcShhcmdzLCAnaGNnJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRqKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoY2cnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJHAgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxhc3QgPSB1dGlscy5sYXN0O1xuICAgIHZhciByb3VuZCQzID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciByZ2IyaGV4JDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRwKGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBhID0gcmVmWzNdO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QoYXJncykgfHwgJ2F1dG8nO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7IGEgPSAxOyB9XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIG1vZGUgPSBhIDwgMSA/ICdyZ2JhJyA6ICdyZ2InO1xuICAgICAgICB9XG4gICAgICAgIHIgPSByb3VuZCQzKHIpO1xuICAgICAgICBnID0gcm91bmQkMyhnKTtcbiAgICAgICAgYiA9IHJvdW5kJDMoYik7XG4gICAgICAgIHZhciB1ID0gciA8PCAxNiB8IGcgPDwgOCB8IGI7XG4gICAgICAgIHZhciBzdHIgPSBcIjAwMDAwMFwiICsgdS50b1N0cmluZygxNik7IC8vIy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSA2KTtcbiAgICAgICAgdmFyIGh4YSA9ICcwJyArIHJvdW5kJDMoYSAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgICAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcbiAgICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JnYmEnOiByZXR1cm4gKFwiI1wiICsgc3RyICsgaHhhKTtcbiAgICAgICAgICAgIGNhc2UgJ2FyZ2InOiByZXR1cm4gKFwiI1wiICsgaHhhICsgc3RyKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAoXCIjXCIgKyBzdHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZ2IyaGV4XzEgPSByZ2IyaGV4JDI7XG5cbiAgICB2YXIgUkVfSEVYID0gL14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLztcbiAgICB2YXIgUkVfSEVYQSA9IC9eIz8oW0EtRmEtZjAtOV17OH18W0EtRmEtZjAtOV17NH0pJC87XG5cbiAgICB2YXIgaGV4MnJnYiQxID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWCkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgc2l4LWRpZ2l0XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4WzBdK2hleFswXStoZXhbMV0raGV4WzFdK2hleFsyXStoZXhbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgdmFyIHIgPSB1ID4+IDE2O1xuICAgICAgICAgICAgdmFyIGcgPSB1ID4+IDggJiAweEZGO1xuICAgICAgICAgICAgdmFyIGIgPSB1ICYgMHhGRjtcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXRjaCByZ2JhIGhleCBmb3JtYXQsIGVnICNGRjAwMDA3N1xuICAgICAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWEEpKSB7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNSB8fCBoZXgubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgc2hvcnQtbm90YXRpb24gdG8gZnVsbCBlaWdodC1kaWdpdFxuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGhleCA9IGhleFswXStoZXhbMF0raGV4WzFdK2hleFsxXStoZXhbMl0raGV4WzJdK2hleFszXStoZXhbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdSQxID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICB2YXIgciQxID0gdSQxID4+IDI0ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBnJDEgPSB1JDEgPj4gMTYgJiAweEZGO1xuICAgICAgICAgICAgdmFyIGIkMSA9IHUkMSA+PiA4ICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBhID0gTWF0aC5yb3VuZCgodSQxICYgMHhGRikgLyAweEZGICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBbciQxLGckMSxiJDEsYV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSB1c2VkIHRvIGNoZWNrIGZvciBjc3MgY29sb3JzIGhlcmVcbiAgICAgICAgLy8gaWYgX2lucHV0LmNzcz8gYW5kIHJnYiA9IF9pbnB1dC5jc3MgaGV4XG4gICAgICAgIC8vICAgICByZXR1cm4gcmdiXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gaGV4IGNvbG9yOiBcIiArIGhleCkpO1xuICAgIH07XG5cbiAgICB2YXIgaGV4MnJnYl8xID0gaGV4MnJnYiQxO1xuXG4gICAgdmFyIGNocm9tYSRmID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHkgPSBDb2xvcl8xO1xuICAgIHZhciB0eXBlJGkgPSB1dGlscy50eXBlO1xuICAgIHZhciBpbnB1dCRiID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IyaGV4JDEgPSByZ2IyaGV4XzE7XG5cbiAgICBDb2xvciR5LnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgIHJldHVybiByZ2IyaGV4JDEodGhpcy5fcmdiLCBtb2RlKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJGYuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciR5LCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGV4J10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCRiLmZvcm1hdC5oZXggPSBoZXgycmdiXzE7XG4gICAgaW5wdXQkYi5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA0LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSRpKGgpID09PSAnc3RyaW5nJyAmJiBbMyw0LDUsNiw3LDgsOV0uaW5kZXhPZihoLmxlbmd0aCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRvID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBUV09QSSQyID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIG1pbiQyID0gTWF0aC5taW47XG4gICAgdmFyIHNxcnQkNCA9IE1hdGguc3FydDtcbiAgICB2YXIgYWNvcyA9IE1hdGguYWNvcztcblxuICAgIHZhciByZ2IyaHNpJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgICAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvcmdiMmhzaS5jcHBcbiAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRvKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICAgICAgdmFyIGg7XG4gICAgICAgIHZhciBtaW5fID0gbWluJDIocixnLGIpO1xuICAgICAgICB2YXIgaSA9IChyK2crYikgLyAzO1xuICAgICAgICB2YXIgcyA9IGkgPiAwID8gMSAtIG1pbl8vaSA6IDA7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCA9ICgoci1nKSsoci1iKSkgLyAyO1xuICAgICAgICAgICAgaCAvPSBzcXJ0JDQoKHItZykqKHItZykgKyAoci1iKSooZy1iKSk7XG4gICAgICAgICAgICBoID0gYWNvcyhoKTtcbiAgICAgICAgICAgIGlmIChiID4gZykge1xuICAgICAgICAgICAgICAgIGggPSBUV09QSSQyIC0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggLz0gVFdPUEkkMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2gqMzYwLHMsaV07XG4gICAgfTtcblxuICAgIHZhciByZ2IyaHNpXzEgPSByZ2IyaHNpJDE7XG5cbiAgICB2YXIgdW5wYWNrJG4gPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxpbWl0ID0gdXRpbHMubGltaXQ7XG4gICAgdmFyIFRXT1BJJDEgPSB1dGlscy5UV09QSTtcbiAgICB2YXIgUElUSElSRCA9IHV0aWxzLlBJVEhJUkQ7XG4gICAgdmFyIGNvcyQ0ID0gTWF0aC5jb3M7XG5cbiAgICAvKlxuICAgICAqIGh1ZSBbMC4uMzYwXVxuICAgICAqIHNhdHVyYXRpb24gWzAuLjFdXG4gICAgICogaW50ZW5zaXR5IFswLi4xXVxuICAgICAqL1xuICAgIHZhciBoc2kycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICAgICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL2hzaTJyZ2IuY3BwXG4gICAgICAgICovXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skbihhcmdzLCAnaHNpJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaSA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcblxuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaWYgKGlzTmFOKHMpKSB7IHMgPSAwOyB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBodWVcbiAgICAgICAgaWYgKGggPiAzNjApIHsgaCAtPSAzNjA7IH1cbiAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIGggLz0gMzYwO1xuICAgICAgICBpZiAoaCA8IDEvMykge1xuICAgICAgICAgICAgYiA9ICgxLXMpLzM7XG4gICAgICAgICAgICByID0gKDErcypjb3MkNChUV09QSSQxKmgpL2NvcyQ0KFBJVEhJUkQtVFdPUEkkMSpoKSkvMztcbiAgICAgICAgICAgIGcgPSAxIC0gKGIrcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaCA8IDIvMykge1xuICAgICAgICAgICAgaCAtPSAxLzM7XG4gICAgICAgICAgICByID0gKDEtcykvMztcbiAgICAgICAgICAgIGcgPSAoMStzKmNvcyQ0KFRXT1BJJDEqaCkvY29zJDQoUElUSElSRC1UV09QSSQxKmgpKS8zO1xuICAgICAgICAgICAgYiA9IDEgLSAocitnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggLT0gMi8zO1xuICAgICAgICAgICAgZyA9ICgxLXMpLzM7XG4gICAgICAgICAgICBiID0gKDErcypjb3MkNChUV09QSSQxKmgpL2NvcyQ0KFBJVEhJUkQtVFdPUEkkMSpoKSkvMztcbiAgICAgICAgICAgIHIgPSAxIC0gKGcrYik7XG4gICAgICAgIH1cbiAgICAgICAgciA9IGxpbWl0KGkqciozKTtcbiAgICAgICAgZyA9IGxpbWl0KGkqZyozKTtcbiAgICAgICAgYiA9IGxpbWl0KGkqYiozKTtcbiAgICAgICAgcmV0dXJuIFtyKjI1NSwgZyoyNTUsIGIqMjU1LCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBoc2kycmdiXzEgPSBoc2kycmdiO1xuXG4gICAgdmFyIHVucGFjayRtID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJGggPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkZSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciR4ID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQkYSA9IGlucHV0JGg7XG5cbiAgICB2YXIgcmdiMmhzaSA9IHJnYjJoc2lfMTtcblxuICAgIENvbG9yJHgucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhzaSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkZS5oc2kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHgsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoc2knXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JGEuZm9ybWF0LmhzaSA9IGhzaTJyZ2JfMTtcblxuICAgIGlucHV0JGEuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skbShhcmdzLCAnaHNpJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRoKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc2knO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGwgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZyA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRkID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHcgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ5ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IyaHNsJDEgPSByZ2IyaHNsXzE7XG5cbiAgICBDb2xvciR3LnByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc2wkMSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkZC5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHcsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoc2wnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDkuZm9ybWF0LmhzbCA9IGhzbDJyZ2JfMTtcblxuICAgIGlucHV0JDkuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skbChhcmdzLCAnaHNsJyk7XG4gICAgICAgICAgICBpZiAodHlwZSRnKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc2wnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGsgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIG1pbiQxID0gTWF0aC5taW47XG4gICAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyaHN2KHIsZyxiKVxuICAgICAqIC0gcmdiMmhzdihbcixnLGJdKVxuICAgICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgICAqL1xuICAgIHZhciByZ2IyaHNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skayhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgICAgIHZhciBtaW5fID0gbWluJDEociwgZywgYik7XG4gICAgICAgIHZhciBtYXhfID0gbWF4JDEociwgZywgYik7XG4gICAgICAgIHZhciBkZWx0YSA9IG1heF8gLSBtaW5fO1xuICAgICAgICB2YXIgaCxzLHY7XG4gICAgICAgIHYgPSBtYXhfIC8gMjU1LjA7XG4gICAgICAgIGlmIChtYXhfID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGRlbHRhIC8gbWF4XztcbiAgICAgICAgICAgIGlmIChyID09PSBtYXhfKSB7IGggPSAoZyAtIGIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChnID09PSBtYXhfKSB7IGggPSAyKyhiIC0gcikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGIgPT09IG1heF8pIHsgaCA9IDQrKHIgLSBnKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBoICo9IDYwO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoLCBzLCB2XVxuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzdiQxID0gcmdiMmhzbDtcblxuICAgIHZhciB1bnBhY2skaiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG5cbiAgICB2YXIgaHN2MnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skaihhcmdzLCAnaHN2Jyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgdiA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgdiAqPSAyNTU7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGggPT09IDM2MCkgeyBoID0gMDsgfVxuICAgICAgICAgICAgaWYgKGggPiAzNjApIHsgaCAtPSAzNjA7IH1cbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICAgICAgaCAvPSA2MDtcblxuICAgICAgICAgICAgdmFyIGkgPSBmbG9vciQyKGgpO1xuICAgICAgICAgICAgdmFyIGYgPSBoIC0gaTtcbiAgICAgICAgICAgIHZhciBwID0gdiAqICgxIC0gcyk7XG4gICAgICAgICAgICB2YXIgcSA9IHYgKiAoMSAtIHMgKiBmKTtcbiAgICAgICAgICAgIHZhciB0ID0gdiAqICgxIC0gcyAqICgxIC0gZikpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IChhc3NpZ24gPSBbdiwgdCwgcF0sIHIgPSBhc3NpZ25bMF0sIGcgPSBhc3NpZ25bMV0sIGIgPSBhc3NpZ25bMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMTogKGFzc2lnbiQxID0gW3EsIHYsIHBdLCByID0gYXNzaWduJDFbMF0sIGcgPSBhc3NpZ24kMVsxXSwgYiA9IGFzc2lnbiQxWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IChhc3NpZ24kMiA9IFtwLCB2LCB0XSwgciA9IGFzc2lnbiQyWzBdLCBnID0gYXNzaWduJDJbMV0sIGIgPSBhc3NpZ24kMlsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAzOiAoYXNzaWduJDMgPSBbcCwgcSwgdl0sIHIgPSBhc3NpZ24kM1swXSwgZyA9IGFzc2lnbiQzWzFdLCBiID0gYXNzaWduJDNbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNDogKGFzc2lnbiQ0ID0gW3QsIHAsIHZdLCByID0gYXNzaWduJDRbMF0sIGcgPSBhc3NpZ24kNFsxXSwgYiA9IGFzc2lnbiQ0WzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IChhc3NpZ24kNSA9IFt2LCBwLCBxXSwgciA9IGFzc2lnbiQ1WzBdLCBnID0gYXNzaWduJDVbMV0sIGIgPSBhc3NpZ24kNVsyXSk7IGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLGcsYixhcmdzLmxlbmd0aCA+IDM/YXJnc1szXToxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzdjJyZ2JfMSA9IGhzdjJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJGkgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZiA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSRjID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHYgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQ4ID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2IyaHN2ID0gcmdiMmhzdiQxO1xuXG4gICAgQ29sb3Ikdi5wcm90b3R5cGUuaHN2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHN2KHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRjLmhzdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkdiwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hzdiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkOC5mb3JtYXQuaHN2ID0gaHN2MnJnYl8xO1xuXG4gICAgaW5wdXQkOC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRpKGFyZ3MsICdoc3YnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGYoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hzdic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsYWJDb25zdGFudHMgPSB7XG4gICAgICAgIC8vIENvcnJlc3BvbmRzIHJvdWdobHkgdG8gUkdCIGJyaWdodGVyL2RhcmtlclxuICAgICAgICBLbjogMTgsXG5cbiAgICAgICAgLy8gRDY1IHN0YW5kYXJkIHJlZmVyZW50XG4gICAgICAgIFhuOiAwLjk1MDQ3MCxcbiAgICAgICAgWW46IDEsXG4gICAgICAgIFpuOiAxLjA4ODgzMCxcblxuICAgICAgICB0MDogMC4xMzc5MzEwMzQsICAvLyA0IC8gMjlcbiAgICAgICAgdDE6IDAuMjA2ODk2NTUyLCAgLy8gNiAvIDI5XG4gICAgICAgIHQyOiAwLjEyODQxODU1LCAgIC8vIDMgKiB0MSAqIHQxXG4gICAgICAgIHQzOiAwLjAwODg1NjQ1MiwgIC8vIHQxICogdDEgKiB0MVxuICAgIH07XG5cbiAgICB2YXIgTEFCX0NPTlNUQU5UUyQzID0gbGFiQ29uc3RhbnRzO1xuICAgIHZhciB1bnBhY2skaCA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcG93JGEgPSBNYXRoLnBvdztcblxuICAgIHZhciByZ2IybGFiJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRoKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gcmdiMnh5eihyLGcsYik7XG4gICAgICAgIHZhciB4ID0gcmVmJDFbMF07XG4gICAgICAgIHZhciB5ID0gcmVmJDFbMV07XG4gICAgICAgIHZhciB6ID0gcmVmJDFbMl07XG4gICAgICAgIHZhciBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgICByZXR1cm4gW2wgPCAwID8gMCA6IGwsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geildO1xuICAgIH07XG5cbiAgICB2YXIgcmdiX3h5eiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmICgociAvPSAyNTUpIDw9IDAuMDQwNDUpIHsgcmV0dXJuIHIgLyAxMi45MjsgfVxuICAgICAgICByZXR1cm4gcG93JGEoKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICB9O1xuXG4gICAgdmFyIHh5el9sYWIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodCA+IExBQl9DT05TVEFOVFMkMy50MykgeyByZXR1cm4gcG93JGEodCwgMSAvIDMpOyB9XG4gICAgICAgIHJldHVybiB0IC8gTEFCX0NPTlNUQU5UUyQzLnQyICsgTEFCX0NPTlNUQU5UUyQzLnQwO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMnh5eiA9IGZ1bmN0aW9uIChyLGcsYikge1xuICAgICAgICByID0gcmdiX3h5eihyKTtcbiAgICAgICAgZyA9IHJnYl94eXooZyk7XG4gICAgICAgIGIgPSByZ2JfeHl6KGIpO1xuICAgICAgICB2YXIgeCA9IHh5el9sYWIoKDAuNDEyNDU2NCAqIHIgKyAwLjM1NzU3NjEgKiBnICsgMC4xODA0Mzc1ICogYikgLyBMQUJfQ09OU1RBTlRTJDMuWG4pO1xuICAgICAgICB2YXIgeSA9IHh5el9sYWIoKDAuMjEyNjcyOSAqIHIgKyAwLjcxNTE1MjIgKiBnICsgMC4wNzIxNzUwICogYikgLyBMQUJfQ09OU1RBTlRTJDMuWW4pO1xuICAgICAgICB2YXIgeiA9IHh5el9sYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBMQUJfQ09OU1RBTlRTJDMuWm4pO1xuICAgICAgICByZXR1cm4gW3gseSx6XTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsYWJfMSA9IHJnYjJsYWIkMjtcblxuICAgIHZhciBMQUJfQ09OU1RBTlRTJDIgPSBsYWJDb25zdGFudHM7XG4gICAgdmFyIHVucGFjayRnID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBwb3ckOSA9IE1hdGgucG93O1xuXG4gICAgLypcbiAgICAgKiBMKiBbMC4uMTAwXVxuICAgICAqIGEgWy0xMDAuLjEwMF1cbiAgICAgKiBiIFstMTAwLi4xMDBdXG4gICAgICovXG4gICAgdmFyIGxhYjJyZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJGcoYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgeCx5LHosIHIsZyxiXztcblxuICAgICAgICB5ID0gKGwgKyAxNikgLyAxMTY7XG4gICAgICAgIHggPSBpc05hTihhKSA/IHkgOiB5ICsgYSAvIDUwMDtcbiAgICAgICAgeiA9IGlzTmFOKGIpID8geSA6IHkgLSBiIC8gMjAwO1xuXG4gICAgICAgIHkgPSBMQUJfQ09OU1RBTlRTJDIuWW4gKiBsYWJfeHl6KHkpO1xuICAgICAgICB4ID0gTEFCX0NPTlNUQU5UUyQyLlhuICogbGFiX3h5eih4KTtcbiAgICAgICAgeiA9IExBQl9DT05TVEFOVFMkMi5abiAqIGxhYl94eXooeik7XG5cbiAgICAgICAgciA9IHh5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KTsgIC8vIEQ2NSAtPiBzUkdCXG4gICAgICAgIGcgPSB4eXpfcmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopO1xuICAgICAgICBiXyA9IHh5el9yZ2IoMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KTtcblxuICAgICAgICByZXR1cm4gW3IsZyxiXyxhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciB4eXpfcmdiID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIDI1NSAqIChyIDw9IDAuMDAzMDQgPyAxMi45MiAqIHIgOiAxLjA1NSAqIHBvdyQ5KHIsIDEgLyAyLjQpIC0gMC4wNTUpXG4gICAgfTtcblxuICAgIHZhciBsYWJfeHl6ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPiBMQUJfQ09OU1RBTlRTJDIudDEgPyB0ICogdCAqIHQgOiBMQUJfQ09OU1RBTlRTJDIudDIgKiAodCAtIExBQl9DT05TVEFOVFMkMi50MClcbiAgICB9O1xuXG4gICAgdmFyIGxhYjJyZ2JfMSA9IGxhYjJyZ2IkMTtcblxuICAgIHZhciB1bnBhY2skZiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRlID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGIgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkdSA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDcgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJsYWIkMSA9IHJnYjJsYWJfMTtcblxuICAgIENvbG9yJHUucHJvdG90eXBlLmxhYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmxhYiQxKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSRiLmxhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkdSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2xhYiddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQkNy5mb3JtYXQubGFiID0gbGFiMnJnYl8xO1xuXG4gICAgaW5wdXQkNy5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRmKGFyZ3MsICdsYWInKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xhYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skZSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgUkFEMkRFRyA9IHV0aWxzLlJBRDJERUc7XG4gICAgdmFyIHNxcnQkMyA9IE1hdGguc3FydDtcbiAgICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIHJvdW5kJDIgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIGxhYjJsY2gkMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJGUoYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgYyA9IHNxcnQkMyhhICogYSArIGIgKiBiKTtcbiAgICAgICAgdmFyIGggPSAoYXRhbjIkMihiLCBhKSAqIFJBRDJERUcgKyAzNjApICUgMzYwO1xuICAgICAgICBpZiAocm91bmQkMihjKjEwMDAwKSA9PT0gMCkgeyBoID0gTnVtYmVyLk5hTjsgfVxuICAgICAgICByZXR1cm4gW2wsIGMsIGhdO1xuICAgIH07XG5cbiAgICB2YXIgbGFiMmxjaF8xID0gbGFiMmxjaCQyO1xuXG4gICAgdmFyIHVucGFjayRkID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByZ2IybGFiID0gcmdiMmxhYl8xO1xuICAgIHZhciBsYWIybGNoJDEgPSBsYWIybGNoXzE7XG5cbiAgICB2YXIgcmdiMmxjaCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skZChhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJsYWIocixnLGIpO1xuICAgICAgICB2YXIgbCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIGxhYjJsY2gkMShsLGEsYl8pO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmxjaF8xID0gcmdiMmxjaCQxO1xuXG4gICAgdmFyIHVucGFjayRjID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBERUcyUkFEID0gdXRpbHMuREVHMlJBRDtcbiAgICB2YXIgc2luJDMgPSBNYXRoLnNpbjtcbiAgICB2YXIgY29zJDMgPSBNYXRoLmNvcztcblxuICAgIHZhciBsY2gybGFiJDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgQ29udmVydCBmcm9tIGEgcXVhbGl0YXRpdmUgcGFyYW1ldGVyIGggYW5kIGEgcXVhbnRpdGF0aXZlIHBhcmFtZXRlciBsIHRvIGEgMjQtYml0IHBpeGVsLlxuICAgICAgICBUaGVzZSBmb3JtdWxhcyB3ZXJlIGludmVudGVkIGJ5IERhdmlkIERhbHJ5bXBsZSB0byBvYnRhaW4gbWF4aW11bSBjb250cmFzdCB3aXRob3V0IGdvaW5nXG4gICAgICAgIG91dCBvZiBnYW11dCBpZiB0aGUgcGFyYW1ldGVycyBhcmUgaW4gdGhlIHJhbmdlIDAtMS5cblxuICAgICAgICBBIHNhdHVyYXRpb24gbXVsdGlwbGllciB3YXMgYWRkZWQgYnkgR3JlZ29yIEFpc2NoXG4gICAgICAgICovXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skYyhhcmdzLCAnbGNoJyk7XG4gICAgICAgIHZhciBsID0gcmVmWzBdO1xuICAgICAgICB2YXIgYyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGggPSByZWZbMl07XG4gICAgICAgIGlmIChpc05hTihoKSkgeyBoID0gMDsgfVxuICAgICAgICBoID0gaCAqIERFRzJSQUQ7XG4gICAgICAgIHJldHVybiBbbCwgY29zJDMoaCkgKiBjLCBzaW4kMyhoKSAqIGNdXG4gICAgfTtcblxuICAgIHZhciBsY2gybGFiXzEgPSBsY2gybGFiJDI7XG5cbiAgICB2YXIgdW5wYWNrJGIgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxjaDJsYWIkMSA9IGxjaDJsYWJfMTtcbiAgICB2YXIgbGFiMnJnYiA9IGxhYjJyZ2JfMTtcblxuICAgIHZhciBsY2gycmdiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRiKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBoID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHJlZiA9IGxjaDJsYWIkMSAobCxjLGgpO1xuICAgICAgICB2YXIgTCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gbGFiMnJnYiAoTCxhLGJfKTtcbiAgICAgICAgdmFyIHIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGcgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBsY2gycmdiXzEgPSBsY2gycmdiJDE7XG5cbiAgICB2YXIgdW5wYWNrJGEgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxjaDJyZ2IgPSBsY2gycmdiXzE7XG5cbiAgICB2YXIgaGNsMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgaGNsID0gdW5wYWNrJGEoYXJncywgJ2hjbCcpLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGxjaDJyZ2IuYXBwbHkodm9pZCAwLCBoY2wpO1xuICAgIH07XG5cbiAgICB2YXIgaGNsMnJnYl8xID0gaGNsMnJnYjtcblxuICAgIHZhciB1bnBhY2skOSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSRkID0gdXRpbHMudHlwZTtcbiAgICB2YXIgY2hyb21hJGEgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkdCA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDYgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJsY2ggPSByZ2IybGNoXzE7XG5cbiAgICBDb2xvciR0LnByb3RvdHlwZS5sY2ggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYjJsY2godGhpcy5fcmdiKTsgfTtcbiAgICBDb2xvciR0LnByb3RvdHlwZS5oY2wgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYjJsY2godGhpcy5fcmdiKS5yZXZlcnNlKCk7IH07XG5cbiAgICBjaHJvbWEkYS5sY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHQsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydsY2gnXSkgKSk7XG4gICAgfTtcbiAgICBjaHJvbWEkYS5oY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHQsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoY2wnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0JDYuZm9ybWF0LmxjaCA9IGxjaDJyZ2JfMTtcbiAgICBpbnB1dCQ2LmZvcm1hdC5oY2wgPSBoY2wycmdiXzE7XG5cbiAgICBbJ2xjaCcsJ2hjbCddLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGlucHV0JDYuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skOShhcmdzLCBtKTtcbiAgICAgICAgICAgIGlmICh0eXBlJGQoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pOyB9KTtcblxuICAgIC8qKlxuICAgIFx0WDExIGNvbG9yIG5hbWVzXG5cbiAgICBcdGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAgICovXG5cbiAgICB2YXIgdzNjeDExJDEgPSB7XG4gICAgICAgIGFsaWNlYmx1ZTogJyNmMGY4ZmYnLFxuICAgICAgICBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JyxcbiAgICAgICAgYXF1YTogJyMwMGZmZmYnLFxuICAgICAgICBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsXG4gICAgICAgIGF6dXJlOiAnI2YwZmZmZicsXG4gICAgICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgICAgIGJpc3F1ZTogJyNmZmU0YzQnLFxuICAgICAgICBibGFjazogJyMwMDAwMDAnLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgICAgICBibHVlOiAnIzAwMDBmZicsXG4gICAgICAgIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJyxcbiAgICAgICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICAgICAgYnVybHl3b29kOiAnI2RlYjg4NycsXG4gICAgICAgIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLFxuICAgICAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgICAgIGNob2NvbGF0ZTogJyNkMjY5MWUnLFxuICAgICAgICBjb3JhbDogJyNmZjdmNTAnLFxuICAgICAgICBjb3JuZmxvd2VyOiAnIzY0OTVlZCcsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsXG4gICAgICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsXG4gICAgICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICAgICAgY3lhbjogJyMwMGZmZmYnLFxuICAgICAgICBkYXJrYmx1ZTogJyMwMDAwOGInLFxuICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsXG4gICAgICAgIGRhcmtncmF5OiAnI2E5YTlhOScsXG4gICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxuICAgICAgICBkYXJrZ3JleTogJyNhOWE5YTknLFxuICAgICAgICBkYXJra2hha2k6ICcjYmRiNzZiJyxcbiAgICAgICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJyxcbiAgICAgICAgZGFya29yYW5nZTogJyNmZjhjMDAnLFxuICAgICAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJyxcbiAgICAgICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLFxuICAgICAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsXG4gICAgICAgIGRhcmtzbGF0ZWdyZXk6ICcjMmY0ZjRmJyxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJyMwMGNlZDEnLFxuICAgICAgICBkYXJrdmlvbGV0OiAnIzk0MDBkMycsXG4gICAgICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXG4gICAgICAgIGRlZXBza3libHVlOiAnIzAwYmZmZicsXG4gICAgICAgIGRpbWdyYXk6ICcjNjk2OTY5JyxcbiAgICAgICAgZGltZ3JleTogJyM2OTY5NjknLFxuICAgICAgICBkb2RnZXJibHVlOiAnIzFlOTBmZicsXG4gICAgICAgIGZpcmVicmljazogJyNiMjIyMjInLFxuICAgICAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxuICAgICAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLFxuICAgICAgICBmdWNoc2lhOiAnI2ZmMDBmZicsXG4gICAgICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxuICAgICAgICBnaG9zdHdoaXRlOiAnI2Y4ZjhmZicsXG4gICAgICAgIGdvbGQ6ICcjZmZkNzAwJyxcbiAgICAgICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXG4gICAgICAgIGdyYXk6ICcjODA4MDgwJyxcbiAgICAgICAgZ3JlZW46ICcjMDA4MDAwJyxcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcbiAgICAgICAgZ3JleTogJyM4MDgwODAnLFxuICAgICAgICBob25leWRldzogJyNmMGZmZjAnLFxuICAgICAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgICAgIGluZGlhbnJlZDogJyNjZDVjNWMnLFxuICAgICAgICBpbmRpZ286ICcjNGIwMDgyJyxcbiAgICAgICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICAgICAga2hha2k6ICcjZjBlNjhjJyxcbiAgICAgICAgbGFzZXJsZW1vbjogJyNmZmZmNTQnLFxuICAgICAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAnI2ZmZjBmNScsXG4gICAgICAgIGxhd25ncmVlbjogJyM3Y2ZjMDAnLFxuICAgICAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcbiAgICAgICAgbGlnaHRibHVlOiAnI2FkZDhlNicsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICcjZjA4MDgwJyxcbiAgICAgICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9kOiAnI2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z3JheTogJyNkM2QzZDMnLFxuICAgICAgICBsaWdodGdyZWVuOiAnIzkwZWU5MCcsXG4gICAgICAgIGxpZ2h0Z3JleTogJyNkM2QzZDMnLFxuICAgICAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJyxcbiAgICAgICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLFxuICAgICAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyZXk6ICcjNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICAgICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJyxcbiAgICAgICAgbGltZTogJyMwMGZmMDAnLFxuICAgICAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICAgICAgbGluZW46ICcjZmFmMGU2JyxcbiAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLFxuICAgICAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICAgICAgbWFyb29uMjogJyM3ZjAwMDAnLFxuICAgICAgICBtYXJvb24zOiAnI2IwMzA2MCcsXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcbiAgICAgICAgbWVkaXVtYmx1ZTogJyMwMDAwY2QnLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6ICcjYmE1NWQzJyxcbiAgICAgICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkYicsXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJyM3YjY4ZWUnLFxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICcjNDhkMWNjJyxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnI2M3MTU4NScsXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxuICAgICAgICBtaW50Y3JlYW06ICcjZjVmZmZhJyxcbiAgICAgICAgbWlzdHlyb3NlOiAnI2ZmZTRlMScsXG4gICAgICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgICAgIG5hdmFqb3doaXRlOiAnI2ZmZGVhZCcsXG4gICAgICAgIG5hdnk6ICcjMDAwMDgwJyxcbiAgICAgICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxuICAgICAgICBvbGl2ZTogJyM4MDgwMDAnLFxuICAgICAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJyxcbiAgICAgICAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gICAgICAgIG9yYW5nZXJlZDogJyNmZjQ1MDAnLFxuICAgICAgICBvcmNoaWQ6ICcjZGE3MGQ2JyxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxuICAgICAgICBwYWxlZ3JlZW46ICcjOThmYjk4JyxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiAnI2RiNzA5MycsXG4gICAgICAgIHBhcGF5YXdoaXA6ICcjZmZlZmQ1JyxcbiAgICAgICAgcGVhY2hwdWZmOiAnI2ZmZGFiOScsXG4gICAgICAgIHBlcnU6ICcjY2Q4NTNmJyxcbiAgICAgICAgcGluazogJyNmZmMwY2InLFxuICAgICAgICBwbHVtOiAnI2RkYTBkZCcsXG4gICAgICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcbiAgICAgICAgcHVycGxlOiAnIzgwMDA4MCcsXG4gICAgICAgIHB1cnBsZTI6ICcjN2YwMDdmJyxcbiAgICAgICAgcHVycGxlMzogJyNhMDIwZjAnLFxuICAgICAgICByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsXG4gICAgICAgIHJlZDogJyNmZjAwMDAnLFxuICAgICAgICByb3N5YnJvd246ICcjYmM4ZjhmJyxcbiAgICAgICAgcm95YWxibHVlOiAnIzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXG4gICAgICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgICAgICBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXG4gICAgICAgIHNlYXNoZWxsOiAnI2ZmZjVlZScsXG4gICAgICAgIHNpZW5uYTogJyNhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcbiAgICAgICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgICAgICBzbGF0ZWJsdWU6ICcjNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gICAgICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxuICAgICAgICBzbm93OiAnI2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsXG4gICAgICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLFxuICAgICAgICB0YW46ICcjZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJyMwMDgwODAnLFxuICAgICAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsXG4gICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJyxcbiAgICAgICAgdmlvbGV0OiAnI2VlODJlZScsXG4gICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnI2ZmZmZmZicsXG4gICAgICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JyxcbiAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMidcbiAgICB9O1xuXG4gICAgdmFyIHczY3gxMV8xID0gdzNjeDExJDE7XG5cbiAgICB2YXIgQ29sb3IkcyA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDUgPSBpbnB1dCRoO1xuICAgIHZhciB0eXBlJGMgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIHczY3gxMSA9IHczY3gxMV8xO1xuICAgIHZhciBoZXgycmdiID0gaGV4MnJnYl8xO1xuICAgIHZhciByZ2IyaGV4ID0gcmdiMmhleF8xO1xuXG4gICAgQ29sb3Ikcy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGV4ID0gcmdiMmhleCh0aGlzLl9yZ2IsICdyZ2InKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh3M2N4MTEpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG4gPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAodzNjeDExW25dID09PSBoZXgpIHsgcmV0dXJuIG4udG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfTtcblxuICAgIGlucHV0JDUuZm9ybWF0Lm5hbWVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHczY3gxMVtuYW1lXSkgeyByZXR1cm4gaGV4MnJnYih3M2N4MTFbbmFtZV0pOyB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb2xvciBuYW1lOiAnK25hbWUpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ1LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDUsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJGMoaCkgPT09ICdzdHJpbmcnICYmIHczY3gxMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYW1lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bnBhY2skOCA9IHV0aWxzLnVucGFjaztcblxuICAgIHZhciByZ2IybnVtJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayQ4KGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJudW1fMSA9IHJnYjJudW0kMTtcblxuICAgIHZhciB0eXBlJGIgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIG51bTJyZ2IgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIGlmICh0eXBlJGIobnVtKSA9PSBcIm51bWJlclwiICYmIG51bSA+PSAwICYmIG51bSA8PSAweEZGRkZGRikge1xuICAgICAgICAgICAgdmFyIHIgPSBudW0gPj4gMTY7XG4gICAgICAgICAgICB2YXIgZyA9IChudW0gPj4gOCkgJiAweEZGO1xuICAgICAgICAgICAgdmFyIGIgPSBudW0gJiAweEZGO1xuICAgICAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG51bSBjb2xvcjogXCIrbnVtKTtcbiAgICB9O1xuXG4gICAgdmFyIG51bTJyZ2JfMSA9IG51bTJyZ2I7XG5cbiAgICB2YXIgY2hyb21hJDkgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkciA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDQgPSBpbnB1dCRoO1xuICAgIHZhciB0eXBlJGEgPSB1dGlscy50eXBlO1xuXG4gICAgdmFyIHJnYjJudW0gPSByZ2IybnVtXzE7XG5cbiAgICBDb2xvciRyLnByb3RvdHlwZS5udW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJudW0odGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDkubnVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRyLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbnVtJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQ0LmZvcm1hdC5udW0gPSBudW0ycmdiXzE7XG5cbiAgICBpbnB1dCQ0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDUsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZSRhKGFyZ3NbMF0pID09PSAnbnVtYmVyJyAmJiBhcmdzWzBdID49IDAgJiYgYXJnc1swXSA8PSAweEZGRkZGRikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGNocm9tYSQ4ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJHEgPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQzID0gaW5wdXQkaDtcbiAgICB2YXIgdW5wYWNrJDcgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkOSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIHJvdW5kJDEgPSBNYXRoLnJvdW5kO1xuXG4gICAgQ29sb3IkcS5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24ocm5kKSB7XG4gICAgICAgIGlmICggcm5kID09PSB2b2lkIDAgKSBybmQ9dHJ1ZTtcblxuICAgICAgICBpZiAocm5kID09PSBmYWxzZSkgeyByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsMyk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDMpLm1hcChyb3VuZCQxKTtcbiAgICB9O1xuXG4gICAgQ29sb3IkcS5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uKHJuZCkge1xuICAgICAgICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kPXRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDQpLm1hcChmdW5jdGlvbiAodixpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTwzID8gKHJuZCA9PT0gZmFsc2UgPyB2IDogcm91bmQkMSh2KSkgOiB2O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDgucmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciRxLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsncmdiJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQzLmZvcm1hdC5yZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJnYmEgPSB1bnBhY2skNyhhcmdzLCAncmdiYScpO1xuICAgICAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSB7IHJnYmFbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH07XG5cbiAgICBpbnB1dCQzLmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDMsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJDcoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJDkoYXJncykgPT09ICdhcnJheScgJiYgKGFyZ3MubGVuZ3RoID09PSAzIHx8XG4gICAgICAgICAgICAgICAgYXJncy5sZW5ndGggPT09IDQgJiYgdHlwZSQ5KGFyZ3NbM10pID09ICdudW1iZXInICYmIGFyZ3NbM10gPj0gMCAmJiBhcmdzWzNdIDw9IDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2InO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIEJhc2VkIG9uIGltcGxlbWVudGF0aW9uIGJ5IE5laWwgQmFydGxldHRcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbmVpbGJhcnRsZXR0L2NvbG9yLXRlbXBlcmF0dXJlXG4gICAgICovXG5cbiAgICB2YXIgbG9nJDEgPSBNYXRoLmxvZztcblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2IkMSA9IGZ1bmN0aW9uIChrZWx2aW4pIHtcbiAgICAgICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgaWYgKHRlbXAgPCA2Nikge1xuICAgICAgICAgICAgciA9IDI1NTtcbiAgICAgICAgICAgIGcgPSB0ZW1wIDwgNiA/IDAgOiAtMTU1LjI1NDg1NTYyNzA5MTc5IC0gMC40NDU5Njk1MDQ2OTU3OTEzMyAqIChnID0gdGVtcC0yKSArIDEwNC40OTIxNjE5OTM5Mzg4OCAqIGxvZyQxKGcpO1xuICAgICAgICAgICAgYiA9IHRlbXAgPCAyMCA/IDAgOiAtMjU0Ljc2OTM1MTg0MTIwOTAyICsgMC44Mjc0MDk2MDY0MDA3Mzk1ICogKGIgPSB0ZW1wLTEwKSArIDExNS42Nzk5NDQwMTA2NjE0NyAqIGxvZyQxKGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IDM1MS45NzY5MDU2NjgwNTY5MyArIDAuMTE0MjA2NDUzNzg0MTY1ICogKHIgPSB0ZW1wLTU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nJDEocik7XG4gICAgICAgICAgICBnID0gMzI1LjQ0OTQxMjU3MTE5NzQgKyAwLjA3OTQzNDU2NTM2NjYyMzQyICogKGcgPSB0ZW1wLTUwKSAtIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2ckMShnKTtcbiAgICAgICAgICAgIGIgPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICB9O1xuXG4gICAgdmFyIHRlbXBlcmF0dXJlMnJnYl8xID0gdGVtcGVyYXR1cmUycmdiJDE7XG5cbiAgICAvKlxuICAgICAqIEJhc2VkIG9uIGltcGxlbWVudGF0aW9uIGJ5IE5laWwgQmFydGxldHRcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbmVpbGJhcnRsZXR0L2NvbG9yLXRlbXBlcmF0dXJlXG4gICAgICoqL1xuXG4gICAgdmFyIHRlbXBlcmF0dXJlMnJnYiA9IHRlbXBlcmF0dXJlMnJnYl8xO1xuICAgIHZhciB1bnBhY2skNiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIHJnYjJ0ZW1wZXJhdHVyZSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2IgPSB1bnBhY2skNihhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmdiWzBdLCBiID0gcmdiWzJdO1xuICAgICAgICB2YXIgbWluVGVtcCA9IDEwMDA7XG4gICAgICAgIHZhciBtYXhUZW1wID0gNDAwMDA7XG4gICAgICAgIHZhciBlcHMgPSAwLjQ7XG4gICAgICAgIHZhciB0ZW1wO1xuICAgICAgICB3aGlsZSAobWF4VGVtcCAtIG1pblRlbXAgPiBlcHMpIHtcbiAgICAgICAgICAgIHRlbXAgPSAobWF4VGVtcCArIG1pblRlbXApICogMC41O1xuICAgICAgICAgICAgdmFyIHJnYiQxID0gdGVtcGVyYXR1cmUycmdiKHRlbXApO1xuICAgICAgICAgICAgaWYgKChyZ2IkMVsyXSAvIHJnYiQxWzBdKSA+PSAoYiAvIHIpKSB7XG4gICAgICAgICAgICAgICAgbWF4VGVtcCA9IHRlbXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3VuZCh0ZW1wKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJ0ZW1wZXJhdHVyZV8xID0gcmdiMnRlbXBlcmF0dXJlJDE7XG5cbiAgICB2YXIgY2hyb21hJDcgPSBjaHJvbWFfMTtcbiAgICB2YXIgQ29sb3IkcCA9IENvbG9yXzE7XG4gICAgdmFyIGlucHV0JDIgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJ0ZW1wZXJhdHVyZSA9IHJnYjJ0ZW1wZXJhdHVyZV8xO1xuXG4gICAgQ29sb3IkcC5wcm90b3R5cGUudGVtcCA9XG4gICAgQ29sb3IkcC5wcm90b3R5cGUua2VsdmluID1cbiAgICBDb2xvciRwLnByb3RvdHlwZS50ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMnRlbXBlcmF0dXJlKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYSQ3LnRlbXAgPVxuICAgIGNocm9tYSQ3LmtlbHZpbiA9XG4gICAgY2hyb21hJDcudGVtcGVyYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJHAsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWyd0ZW1wJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQyLmZvcm1hdC50ZW1wID1cbiAgICBpbnB1dCQyLmZvcm1hdC5rZWx2aW4gPVxuICAgIGlucHV0JDIuZm9ybWF0LnRlbXBlcmF0dXJlID0gdGVtcGVyYXR1cmUycmdiXzE7XG5cbiAgICB2YXIgdW5wYWNrJDUgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGNicnQgPSBNYXRoLmNicnQ7XG4gICAgdmFyIHBvdyQ4ID0gTWF0aC5wb3c7XG4gICAgdmFyIHNpZ24kMSA9IE1hdGguc2lnbjtcblxuICAgIHZhciByZ2Iyb2tsYWIkMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAvLyBPS0xhYiBjb2xvciBzcGFjZSBpbXBsZW1lbnRhdGlvbiB0YWtlbiBmcm9tXG4gICAgICAgIC8vIGh0dHBzOi8vYm90dG9zc29uLmdpdGh1Yi5pby9wb3N0cy9va2xhYi9cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayQ1KGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gW3JnYjJscmdiKHIgLyAyNTUpLCByZ2IybHJnYihnIC8gMjU1KSwgcmdiMmxyZ2IoYiAvIDI1NSldO1xuICAgICAgICB2YXIgbHIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGxnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBsYiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgbCA9IGNicnQoMC40MTIyMjE0NzA4ICogbHIgKyAwLjUzNjMzMjUzNjMgKiBsZyArIDAuMDUxNDQ1OTkyOSAqIGxiKTtcbiAgICAgICAgdmFyIG0gPSBjYnJ0KDAuMjExOTAzNDk4MiAqIGxyICsgMC42ODA2OTk1NDUxICogbGcgKyAwLjEwNzM5Njk1NjYgKiBsYik7XG4gICAgICAgIHZhciBzID0gY2JydCgwLjA4ODMwMjQ2MTkgKiBsciArIDAuMjgxNzE4ODM3NiAqIGxnICsgMC42Mjk5Nzg3MDA1ICogbGIpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAwLjIxMDQ1NDI1NTMgKiBsICsgMC43OTM2MTc3ODUgKiBtIC0gMC4wMDQwNzIwNDY4ICogcyxcbiAgICAgICAgICAgIDEuOTc3OTk4NDk1MSAqIGwgLSAyLjQyODU5MjIwNSAqIG0gKyAwLjQ1MDU5MzcwOTkgKiBzLFxuICAgICAgICAgICAgMC4wMjU5MDQwMzcxICogbCArIDAuNzgyNzcxNzY2MiAqIG0gLSAwLjgwODY3NTc2NiAqIHNcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJva2xhYl8xID0gcmdiMm9rbGFiJDI7XG5cbiAgICBmdW5jdGlvbiByZ2IybHJnYihjKSB7XG4gICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhjKTtcbiAgICAgICAgaWYgKGFicyA8IDAuMDQwNDUpIHtcbiAgICAgICAgICAgIHJldHVybiBjIC8gMTIuOTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzaWduJDEoYykgfHwgMSkgKiBwb3ckOCgoYWJzICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfVxuXG4gICAgdmFyIHVucGFjayQ0ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBwb3ckNyA9IE1hdGgucG93O1xuICAgIHZhciBzaWduID0gTWF0aC5zaWduO1xuXG4gICAgLypcbiAgICAgKiBMKiBbMC4uMTAwXVxuICAgICAqIGEgWy0xMDAuLjEwMF1cbiAgICAgKiBiIFstMTAwLi4xMDBdXG4gICAgICovXG4gICAgdmFyIG9rbGFiMnJnYiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skNChhcmdzLCAnbGFiJyk7XG4gICAgICAgIHZhciBMID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGEgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgYiA9IGFyZ3NbMl07XG5cbiAgICAgICAgdmFyIGwgPSBwb3ckNyhMICsgMC4zOTYzMzc3Nzc0ICogYSArIDAuMjE1ODAzNzU3MyAqIGIsIDMpO1xuICAgICAgICB2YXIgbSA9IHBvdyQ3KEwgLSAwLjEwNTU2MTM0NTggKiBhIC0gMC4wNjM4NTQxNzI4ICogYiwgMyk7XG4gICAgICAgIHZhciBzID0gcG93JDcoTCAtIDAuMDg5NDg0MTc3NSAqIGEgLSAxLjI5MTQ4NTU0OCAqIGIsIDMpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAyNTUgKiBscmdiMnJnYigrNC4wNzY3NDE2NjIxICogbCAtIDMuMzA3NzExNTkxMyAqIG0gKyAwLjIzMDk2OTkyOTIgKiBzKSxcbiAgICAgICAgICAgIDI1NSAqIGxyZ2IycmdiKC0xLjI2ODQzODAwNDYgKiBsICsgMi42MDk3NTc0MDExICogbSAtIDAuMzQxMzE5Mzk2NSAqIHMpLFxuICAgICAgICAgICAgMjU1ICogbHJnYjJyZ2IoLTAuMDA0MTk2MDg2MyAqIGwgLSAwLjcwMzQxODYxNDcgKiBtICsgMS43MDc2MTQ3MDEgKiBzKSxcbiAgICAgICAgICAgIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciBva2xhYjJyZ2JfMSA9IG9rbGFiMnJnYiQxO1xuXG4gICAgZnVuY3Rpb24gbHJnYjJyZ2IoYykge1xuICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMoYyk7XG4gICAgICAgIGlmIChhYnMgPiAwLjAwMzEzMDgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2lnbihjKSB8fCAxKSAqICgxLjA1NSAqIHBvdyQ3KGFicywgMSAvIDIuNCkgLSAwLjA1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMgKiAxMi45MjtcbiAgICB9XG5cbiAgICB2YXIgdW5wYWNrJDMgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkOCA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNocm9tYSQ2ID0gY2hyb21hXzE7XG4gICAgdmFyIENvbG9yJG8gPSBDb2xvcl8xO1xuICAgIHZhciBpbnB1dCQxID0gaW5wdXQkaDtcblxuICAgIHZhciByZ2Iyb2tsYWIkMSA9IHJnYjJva2xhYl8xO1xuXG4gICAgQ29sb3Ikby5wcm90b3R5cGUub2tsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZ2Iyb2tsYWIkMSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWEkNi5va2xhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IkbywgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ29rbGFiJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dCQxLmZvcm1hdC5va2xhYiA9IG9rbGFiMnJnYl8xO1xuXG4gICAgaW5wdXQkMS5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAzLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayQzKGFyZ3MsICdva2xhYicpO1xuICAgICAgICAgICAgaWYgKHR5cGUkOChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb2tsYWInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJDIgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJnYjJva2xhYiA9IHJnYjJva2xhYl8xO1xuICAgIHZhciBsYWIybGNoID0gbGFiMmxjaF8xO1xuXG4gICAgdmFyIHJnYjJva2xjaCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skMihhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJva2xhYihyLCBnLCBiKTtcbiAgICAgICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBsYWIybGNoKGwsIGEsIGJfKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJva2xjaF8xID0gcmdiMm9rbGNoJDE7XG5cbiAgICB2YXIgdW5wYWNrJDEgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGxjaDJsYWIgPSBsY2gybGFiXzE7XG4gICAgdmFyIG9rbGFiMnJnYiA9IG9rbGFiMnJnYl8xO1xuXG4gICAgdmFyIG9rbGNoMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJDEoYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcmVmID0gbGNoMmxhYihsLCBjLCBoKTtcbiAgICAgICAgdmFyIEwgPSByZWZbMF07XG4gICAgICAgIHZhciBhID0gcmVmWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IG9rbGFiMnJnYihMLCBhLCBiXyk7XG4gICAgICAgIHZhciByID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgb2tsY2gycmdiXzEgPSBva2xjaDJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDcgPSB1dGlscy50eXBlO1xuICAgIHZhciBjaHJvbWEkNSA9IGNocm9tYV8xO1xuICAgIHZhciBDb2xvciRuID0gQ29sb3JfMTtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dCRoO1xuXG4gICAgdmFyIHJnYjJva2xjaCA9IHJnYjJva2xjaF8xO1xuXG4gICAgQ29sb3Ikbi5wcm90b3R5cGUub2tsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZ2Iyb2tsY2godGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hJDUub2tsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yJG4sIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydva2xjaCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQuZm9ybWF0Lm9rbGNoID0gb2tsY2gycmdiXzE7XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAzLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnb2tsY2gnKTtcbiAgICAgICAgICAgIGlmICh0eXBlJDcoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29rbGNoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIENvbG9yJG0gPSBDb2xvcl8xO1xuICAgIHZhciB0eXBlJDYgPSB1dGlscy50eXBlO1xuXG4gICAgQ29sb3IkbS5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbihhLCBtdXRhdGUpIHtcbiAgICAgICAgaWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZT1mYWxzZTtcblxuICAgICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkICYmIHR5cGUkNihhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRtKFt0aGlzLl9yZ2JbMF0sIHRoaXMuX3JnYlsxXSwgdGhpcy5fcmdiWzJdLCBhXSwgJ3JnYicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2JbM107XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRsID0gQ29sb3JfMTtcblxuICAgIENvbG9yJGwucHJvdG90eXBlLmNsaXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5fY2xpcHBlZCB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGsgPSBDb2xvcl8xO1xuICAgIHZhciBMQUJfQ09OU1RBTlRTJDEgPSBsYWJDb25zdGFudHM7XG5cbiAgICBDb2xvciRrLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0dmFyIG1lID0gdGhpcztcbiAgICBcdHZhciBsYWIgPSBtZS5sYWIoKTtcbiAgICBcdGxhYlswXSAtPSBMQUJfQ09OU1RBTlRTJDEuS24gKiBhbW91bnQ7XG4gICAgXHRyZXR1cm4gbmV3IENvbG9yJGsobGFiLCAnbGFiJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIENvbG9yJGsucHJvdG90eXBlLmJyaWdodGVuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgICB9O1xuXG4gICAgQ29sb3Ikay5wcm90b3R5cGUuZGFya2VyID0gQ29sb3Ikay5wcm90b3R5cGUuZGFya2VuO1xuICAgIENvbG9yJGsucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3Ikay5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbiAgICB2YXIgQ29sb3IkaiA9IENvbG9yXzE7XG5cbiAgICBDb2xvciRqLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobWMpIHtcbiAgICAgICAgdmFyIHJlZiA9IG1jLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBtb2RlID0gcmVmWzBdO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXNbbW9kZV0oKTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBpID0gbW9kZS5pbmRleE9mKGNoYW5uZWwpIC0gKG1vZGUuc3Vic3RyKDAsIDIpID09PSAnb2snID8gMiA6IDApO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkgeyByZXR1cm4gc3JjW2ldOyB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwidW5rbm93biBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGluIG1vZGUgXCIgKyBtb2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRpID0gQ29sb3JfMTtcbiAgICB2YXIgdHlwZSQ1ID0gdXRpbHMudHlwZTtcbiAgICB2YXIgcG93JDYgPSBNYXRoLnBvdztcblxuICAgIHZhciBFUFMgPSAxZS03O1xuICAgIHZhciBNQVhfSVRFUiA9IDIwO1xuXG4gICAgQ29sb3IkaS5wcm90b3R5cGUubHVtaW5hbmNlID0gZnVuY3Rpb24obHVtKSB7XG4gICAgICAgIGlmIChsdW0gIT09IHVuZGVmaW5lZCAmJiB0eXBlJDUobHVtKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChsdW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcHVyZSBibGFja1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IkaShbMCwwLDAsdGhpcy5fcmdiWzNdXSwgJ3JnYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGx1bSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwdXJlIHdoaXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRpKFsyNTUsMjU1LDI1NSx0aGlzLl9yZ2JbM11dLCAncmdiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wdXRlIG5ldyBjb2xvciB1c2luZy4uLlxuICAgICAgICAgICAgdmFyIGN1cl9sdW0gPSB0aGlzLmx1bWluYW5jZSgpO1xuICAgICAgICAgICAgdmFyIG1vZGUgPSAncmdiJztcbiAgICAgICAgICAgIHZhciBtYXhfaXRlciA9IE1BWF9JVEVSO1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gbG93LmludGVycG9sYXRlKGhpZ2gsIDAuNSwgbW9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxtID0gbWlkLmx1bWluYW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsdW0gLSBsbSkgPCBFUFMgfHwgIW1heF9pdGVyLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsbSA+IGx1bSA/IHRlc3QobG93LCBtaWQpIDogdGVzdChtaWQsIGhpZ2gpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJnYiA9IChjdXJfbHVtID4gbHVtID8gdGVzdChuZXcgQ29sb3IkaShbMCwwLDBdKSwgdGhpcykgOiB0ZXN0KHRoaXMsIG5ldyBDb2xvciRpKFsyNTUsMjU1LDI1NV0pKSkucmdiKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJGkocmdiLmNvbmNhdCggW3RoaXMuX3JnYlszXV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiMmx1bWluYW5jZS5hcHBseSh2b2lkIDAsICh0aGlzLl9yZ2IpLnNsaWNlKDAsMykpO1xuICAgIH07XG5cblxuICAgIHZhciByZ2IybHVtaW5hbmNlID0gZnVuY3Rpb24gKHIsZyxiKSB7XG4gICAgICAgIC8vIHJlbGF0aXZlIGx1bWluYW5jZVxuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuICAgICAgICByID0gbHVtaW5hbmNlX3gocik7XG4gICAgICAgIGcgPSBsdW1pbmFuY2VfeChnKTtcbiAgICAgICAgYiA9IGx1bWluYW5jZV94KGIpO1xuICAgICAgICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICAgIH07XG5cbiAgICB2YXIgbHVtaW5hbmNlX3ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB4IC89IDI1NTtcbiAgICAgICAgcmV0dXJuIHggPD0gMC4wMzkyOCA/IHgvMTIuOTIgOiBwb3ckNigoeCswLjA1NSkvMS4wNTUsIDIuNCk7XG4gICAgfTtcblxuICAgIHZhciBpbnRlcnBvbGF0b3IkMSA9IHt9O1xuXG4gICAgdmFyIENvbG9yJGggPSBDb2xvcl8xO1xuICAgIHZhciB0eXBlJDQgPSB1dGlscy50eXBlO1xuICAgIHZhciBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0b3IkMTtcblxuICAgIHZhciBtaXgkMSA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIGlmICggZiA9PT0gdm9pZCAwICkgZj0wLjU7XG4gICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAzIF07XG5cbiAgICAgICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcbiAgICAgICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0gJiYgIXJlc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHN1cHBvcnRlZCBtb2RlXG4gICAgICAgICAgICBtb2RlID0gT2JqZWN0LmtleXMoaW50ZXJwb2xhdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVycG9sYXRvclttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUkNChjb2wxKSAhPT0gJ29iamVjdCcpIHsgY29sMSA9IG5ldyBDb2xvciRoKGNvbDEpOyB9XG4gICAgICAgIGlmICh0eXBlJDQoY29sMikgIT09ICdvYmplY3QnKSB7IGNvbDIgPSBuZXcgQ29sb3IkaChjb2wyKTsgfVxuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yW21vZGVdKGNvbDEsIGNvbDIsIGYpXG4gICAgICAgICAgICAuYWxwaGEoY29sMS5hbHBoYSgpICsgZiAqIChjb2wyLmFscGhhKCkgLSBjb2wxLmFscGhhKCkpKTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGcgPSBDb2xvcl8xO1xuICAgIHZhciBtaXggPSBtaXgkMTtcblxuICAgIENvbG9yJGcucHJvdG90eXBlLm1peCA9XG4gICAgQ29sb3IkZy5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihjb2wyLCBmKSB7XG4gICAgXHRpZiAoIGYgPT09IHZvaWQgMCApIGY9MC41O1xuICAgIFx0dmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgXHR3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICBcdHJldHVybiBtaXguYXBwbHkodm9pZCAwLCBbIHRoaXMsIGNvbDIsIGYgXS5jb25jYXQoIHJlc3QgKSk7XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRmID0gQ29sb3JfMTtcblxuICAgIENvbG9yJGYucHJvdG90eXBlLnByZW11bHRpcGx5ID0gZnVuY3Rpb24obXV0YXRlKSB7XG4gICAgXHRpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlPWZhbHNlO1xuXG4gICAgXHR2YXIgcmdiID0gdGhpcy5fcmdiO1xuICAgIFx0dmFyIGEgPSByZ2JbM107XG4gICAgXHRpZiAobXV0YXRlKSB7XG4gICAgXHRcdHRoaXMuX3JnYiA9IFtyZ2JbMF0qYSwgcmdiWzFdKmEsIHJnYlsyXSphLCBhXTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG4gICAgXHR9IGVsc2Uge1xuICAgIFx0XHRyZXR1cm4gbmV3IENvbG9yJGYoW3JnYlswXSphLCByZ2JbMV0qYSwgcmdiWzJdKmEsIGFdLCAncmdiJyk7XG4gICAgXHR9XG4gICAgfTtcblxuICAgIHZhciBDb2xvciRlID0gQ29sb3JfMTtcbiAgICB2YXIgTEFCX0NPTlNUQU5UUyA9IGxhYkNvbnN0YW50cztcblxuICAgIENvbG9yJGUucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHZhciBtZSA9IHRoaXM7XG4gICAgXHR2YXIgbGNoID0gbWUubGNoKCk7XG4gICAgXHRsY2hbMV0gKz0gTEFCX0NPTlNUQU5UUy5LbiAqIGFtb3VudDtcbiAgICBcdGlmIChsY2hbMV0gPCAwKSB7IGxjaFsxXSA9IDA7IH1cbiAgICBcdHJldHVybiBuZXcgQ29sb3IkZShsY2gsICdsY2gnKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgQ29sb3IkZS5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIFx0aWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudD0xO1xuXG4gICAgXHRyZXR1cm4gdGhpcy5zYXR1cmF0ZSgtYW1vdW50KTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGQgPSBDb2xvcl8xO1xuICAgIHZhciB0eXBlJDMgPSB1dGlscy50eXBlO1xuXG4gICAgQ29sb3IkZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG1jLCB2YWx1ZSwgbXV0YXRlKSB7XG4gICAgICAgIGlmICggbXV0YXRlID09PSB2b2lkIDAgKSBtdXRhdGUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgcmVmID0gbWMuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgICAgICB2YXIgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCkgLSAobW9kZS5zdWJzdHIoMCwgMikgPT09ICdvaycgPyAyIDogMCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkMyh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICo9ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDModmFsdWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzcmNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB2YWx1ZSBmb3IgQ29sb3Iuc2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gbmV3IENvbG9yJGQoc3JjLCBtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJGMgPSBDb2xvcl8xO1xuXG4gICAgdmFyIHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5fcmdiO1xuICAgICAgICB2YXIgeHl6MSA9IGNvbDIuX3JnYjtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciRjKFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXS14eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0teHl6MFsxXSksXG4gICAgICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdLXh5ejBbMl0pLFxuICAgICAgICAgICAgJ3JnYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5yZ2IgPSByZ2I7XG5cbiAgICB2YXIgQ29sb3IkYiA9IENvbG9yXzE7XG4gICAgdmFyIHNxcnQkMiA9IE1hdGguc3FydDtcbiAgICB2YXIgcG93JDUgPSBNYXRoLnBvdztcblxuICAgIHZhciBscmdiID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIHJlZiA9IGNvbDEuX3JnYjtcbiAgICAgICAgdmFyIHgxID0gcmVmWzBdO1xuICAgICAgICB2YXIgeTEgPSByZWZbMV07XG4gICAgICAgIHZhciB6MSA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gY29sMi5fcmdiO1xuICAgICAgICB2YXIgeDIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIHkyID0gcmVmJDFbMV07XG4gICAgICAgIHZhciB6MiA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yJGIoXG4gICAgICAgICAgICBzcXJ0JDIocG93JDUoeDEsMikgKiAoMS1mKSArIHBvdyQ1KHgyLDIpICogZiksXG4gICAgICAgICAgICBzcXJ0JDIocG93JDUoeTEsMikgKiAoMS1mKSArIHBvdyQ1KHkyLDIpICogZiksXG4gICAgICAgICAgICBzcXJ0JDIocG93JDUoejEsMikgKiAoMS1mKSArIHBvdyQ1KHoyLDIpICogZiksXG4gICAgICAgICAgICAncmdiJ1xuICAgICAgICApXG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmxyZ2IgPSBscmdiO1xuXG4gICAgdmFyIENvbG9yJGEgPSBDb2xvcl8xO1xuXG4gICAgdmFyIGxhYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5sYWIoKTtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLmxhYigpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yJGEoXG4gICAgICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdLXh5ejBbMF0pLFxuICAgICAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXS14eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0teHl6MFsyXSksXG4gICAgICAgICAgICAnbGFiJ1xuICAgICAgICApXG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmxhYiA9IGxhYjtcblxuICAgIHZhciBDb2xvciQ5ID0gQ29sb3JfMTtcblxuICAgIHZhciBfaHN4ID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYsIG0pIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG5cbiAgICAgICAgdmFyIHh5ejAsIHh5ejE7XG4gICAgICAgIGlmIChtID09PSAnaHNsJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEuaHNsKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5oc2woKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAnaHN2Jykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEuaHN2KCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5oc3YoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAnaGNnJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEuaGNnKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5oY2coKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAnaHNpJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEuaHNpKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5oc2koKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAnbGNoJyB8fCBtID09PSAnaGNsJykge1xuICAgICAgICAgICAgbSA9ICdoY2wnO1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEuaGNsKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5oY2woKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAnb2tsY2gnKSB7XG4gICAgICAgICAgICB4eXowID0gY29sMS5va2xjaCgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHh5ejEgPSBjb2wyLm9rbGNoKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGh1ZTAsIGh1ZTEsIHNhdDAsIHNhdDEsIGxidjAsIGxidjE7XG4gICAgICAgIGlmIChtLnN1YnN0cigwLCAxKSA9PT0gJ2gnIHx8IG0gPT09ICdva2xjaCcpIHtcbiAgICAgICAgICAgIChhc3NpZ24gPSB4eXowLCBodWUwID0gYXNzaWduWzBdLCBzYXQwID0gYXNzaWduWzFdLCBsYnYwID0gYXNzaWduWzJdKTtcbiAgICAgICAgICAgIChhc3NpZ24kMSA9IHh5ejEsIGh1ZTEgPSBhc3NpZ24kMVswXSwgc2F0MSA9IGFzc2lnbiQxWzFdLCBsYnYxID0gYXNzaWduJDFbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhdCwgaHVlLCBsYnYsIGRoO1xuXG4gICAgICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAgICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgICAgICAgaWYgKGh1ZTEgPiBodWUwICYmIGh1ZTEgLSBodWUwID4gMTgwKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWUxIC0gKGh1ZTAgKyAzNjApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChodWUxIDwgaHVlMCAmJiBodWUwIC0gaHVlMSA+IDE4MCkge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSArIDM2MCAtIGh1ZTA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodWUgPSBodWUwICsgZiAqIGRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihodWUwKSkge1xuICAgICAgICAgICAgaHVlID0gaHVlMDtcbiAgICAgICAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2JykgeyBzYXQgPSBzYXQwOyB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAgICAgICBodWUgPSBodWUxO1xuICAgICAgICAgICAgaWYgKChsYnYwID09IDEgfHwgbGJ2MCA9PSAwKSAmJiBtICE9ICdoc3YnKSB7IHNhdCA9IHNhdDE7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh1ZSA9IE51bWJlci5OYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHsgc2F0ID0gc2F0MCArIGYgKiAoc2F0MSAtIHNhdDApOyB9XG4gICAgICAgIGxidiA9IGxidjAgKyBmICogKGxidjEgLSBsYnYwKTtcbiAgICAgICAgcmV0dXJuIG0gPT09ICdva2xjaCcgPyBuZXcgQ29sb3IkOShbbGJ2LCBzYXQsIGh1ZV0sIG0pIDogbmV3IENvbG9yJDkoW2h1ZSwgc2F0LCBsYnZdLCBtKTtcbiAgICB9O1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCQ1ID0gX2hzeDtcblxuICAgIHZhciBsY2ggPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIGludGVycG9sYXRlX2hzeCQ1KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW50ZXJwb2xhdG9yJDEubGNoID0gbGNoO1xuICAgIGludGVycG9sYXRvciQxLmhjbCA9IGxjaDtcblxuICAgIHZhciBDb2xvciQ4ID0gQ29sb3JfMTtcblxuICAgIHZhciBudW0gPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgYzEgPSBjb2wxLm51bSgpO1xuICAgICAgICB2YXIgYzIgPSBjb2wyLm51bSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yJDgoYzEgKyBmICogKGMyLWMxKSwgJ251bScpXG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLm51bSA9IG51bTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkNCA9IF9oc3g7XG5cbiAgICB2YXIgaGNnID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkNChjb2wxLCBjb2wyLCBmLCAnaGNnJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmhjZyA9IGhjZztcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkMyA9IF9oc3g7XG5cbiAgICB2YXIgaHNpID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkMyhjb2wxLCBjb2wyLCBmLCAnaHNpJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmhzaSA9IGhzaTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkMiA9IF9oc3g7XG5cbiAgICB2YXIgaHNsID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkMihjb2wxLCBjb2wyLCBmLCAnaHNsJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmhzbCA9IGhzbDtcblxuICAgIHZhciBpbnRlcnBvbGF0ZV9oc3gkMSA9IF9oc3g7XG5cbiAgICB2YXIgaHN2ID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICBcdHJldHVybiBpbnRlcnBvbGF0ZV9oc3gkMShjb2wxLCBjb2wyLCBmLCAnaHN2Jyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvciQxLmhzdiA9IGhzdjtcblxuICAgIHZhciBDb2xvciQ3ID0gQ29sb3JfMTtcblxuICAgIHZhciBva2xhYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5va2xhYigpO1xuICAgICAgICB2YXIgeHl6MSA9IGNvbDIub2tsYWIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ3KFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXSAtIHh5ejBbMF0pLFxuICAgICAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXSAtIHh5ejBbMV0pLFxuICAgICAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLFxuICAgICAgICAgICAgJ29rbGFiJ1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5va2xhYiA9IG9rbGFiO1xuXG4gICAgdmFyIGludGVycG9sYXRlX2hzeCA9IF9oc3g7XG5cbiAgICB2YXIgb2tsY2ggPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdva2xjaCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IkMS5va2xjaCA9IG9rbGNoO1xuXG4gICAgdmFyIENvbG9yJDYgPSBDb2xvcl8xO1xuICAgIHZhciBjbGlwX3JnYiQxID0gdXRpbHMuY2xpcF9yZ2I7XG4gICAgdmFyIHBvdyQ0ID0gTWF0aC5wb3c7XG4gICAgdmFyIHNxcnQkMSA9IE1hdGguc3FydDtcbiAgICB2YXIgUEkkMSA9IE1hdGguUEk7XG4gICAgdmFyIGNvcyQyID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiQyID0gTWF0aC5zaW47XG4gICAgdmFyIGF0YW4yJDEgPSBNYXRoLmF0YW4yO1xuXG4gICAgdmFyIGF2ZXJhZ2UgPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlLCB3ZWlnaHRzKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gdm9pZCAwICkgbW9kZT0nbHJnYic7XG4gICAgICAgIGlmICggd2VpZ2h0cyA9PT0gdm9pZCAwICkgd2VpZ2h0cz1udWxsO1xuXG4gICAgICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF3ZWlnaHRzKSB7IHdlaWdodHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheShsKSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0pOyB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB3ZWlnaHRzXG4gICAgICAgIHZhciBrID0gbCAvIHdlaWdodHMucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9KTtcbiAgICAgICAgd2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh3LGkpIHsgd2VpZ2h0c1tpXSAqPSBrOyB9KTtcbiAgICAgICAgLy8gY29udmVydCBjb2xvcnMgdG8gQ29sb3Igb2JqZWN0c1xuICAgICAgICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZXcgQ29sb3IkNihjKTsgfSk7XG4gICAgICAgIGlmIChtb2RlID09PSAnbHJnYicpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXZlcmFnZV9scmdiKGNvbG9ycywgd2VpZ2h0cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBjb2xvcnMuc2hpZnQoKTtcbiAgICAgICAgdmFyIHh5eiA9IGZpcnN0LmdldChtb2RlKTtcbiAgICAgICAgdmFyIGNudCA9IFtdO1xuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAvLyBpbml0aWFsIGNvbG9yXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHh5eltpXSA9ICh4eXpbaV0gfHwgMCkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgY250LnB1c2goaXNOYU4oeHl6W2ldKSA/IDAgOiB3ZWlnaHRzWzBdKTtcbiAgICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnICYmICFpc05hTih4eXpbaV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIEEgPSB4eXpbaV0gLyAxODAgKiBQSSQxO1xuICAgICAgICAgICAgICAgIGR4ICs9IGNvcyQyKEEpICogd2VpZ2h0c1swXTtcbiAgICAgICAgICAgICAgICBkeSArPSBzaW4kMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxwaGEgPSBmaXJzdC5hbHBoYSgpICogd2VpZ2h0c1swXTtcbiAgICAgICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGMsY2kpIHtcbiAgICAgICAgICAgIHZhciB4eXoyID0gYy5nZXQobW9kZSk7XG4gICAgICAgICAgICBhbHBoYSArPSBjLmFscGhhKCkgKiB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oeHl6MltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY250W2ldICs9IHdlaWdodHNbY2krMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQSA9IHh5ejJbaV0gLyAxODAgKiBQSSQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gc2luJDIoQSkgKiB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeHl6W2ldICs9IHh5ejJbaV0gKiB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpJDE9MDsgaSQxPHh5ei5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSQxKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICAgICAgdmFyIEEkMSA9IGF0YW4yJDEoZHkgLyBjbnRbaSQxXSwgZHggLyBjbnRbaSQxXSkgLyBQSSQxICogMTgwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChBJDEgPCAwKSB7IEEkMSArPSAzNjA7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoQSQxID49IDM2MCkgeyBBJDEgLT0gMzYwOyB9XG4gICAgICAgICAgICAgICAgeHl6W2kkMV0gPSBBJDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHh5eltpJDFdID0geHl6W2kkMV0vY250W2kkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGEgLz0gbDtcbiAgICAgICAgcmV0dXJuIChuZXcgQ29sb3IkNih4eXosIG1vZGUpKS5hbHBoYShhbHBoYSA+IDAuOTk5OTkgPyAxIDogYWxwaGEsIHRydWUpO1xuICAgIH07XG5cblxuICAgIHZhciBfYXZlcmFnZV9scmdiID0gZnVuY3Rpb24gKGNvbG9ycywgd2VpZ2h0cykge1xuICAgICAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgIHZhciB4eXogPSBbMCwwLDAsMF07XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbCA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgIHZhciBmID0gd2VpZ2h0c1tpXSAvIGw7XG4gICAgICAgICAgICB2YXIgcmdiID0gY29sLl9yZ2I7XG4gICAgICAgICAgICB4eXpbMF0gKz0gcG93JDQocmdiWzBdLDIpICogZjtcbiAgICAgICAgICAgIHh5elsxXSArPSBwb3ckNChyZ2JbMV0sMikgKiBmO1xuICAgICAgICAgICAgeHl6WzJdICs9IHBvdyQ0KHJnYlsyXSwyKSAqIGY7XG4gICAgICAgICAgICB4eXpbM10gKz0gcmdiWzNdICogZjtcbiAgICAgICAgfVxuICAgICAgICB4eXpbMF0gPSBzcXJ0JDEoeHl6WzBdKTtcbiAgICAgICAgeHl6WzFdID0gc3FydCQxKHh5elsxXSk7XG4gICAgICAgIHh5elsyXSA9IHNxcnQkMSh4eXpbMl0pO1xuICAgICAgICBpZiAoeHl6WzNdID4gMC45OTk5OTk5KSB7IHh5elszXSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ2KGNsaXBfcmdiJDEoeHl6KSk7XG4gICAgfTtcblxuICAgIC8vIG1pbmltYWwgbXVsdGktcHVycG9zZSBpbnRlcmZhY2VcblxuICAgIC8vIEByZXF1aXJlcyB1dGlscyBjb2xvciBhbmFseXplXG5cbiAgICB2YXIgY2hyb21hJDQgPSBjaHJvbWFfMTtcbiAgICB2YXIgdHlwZSQyID0gdXRpbHMudHlwZTtcblxuICAgIHZhciBwb3ckMyA9IE1hdGgucG93O1xuXG4gICAgdmFyIHNjYWxlJDIgPSBmdW5jdGlvbihjb2xvcnMpIHtcblxuICAgICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICB2YXIgX21vZGUgPSAncmdiJztcbiAgICAgICAgdmFyIF9uYWNvbCA9IGNocm9tYSQ0KCcjY2NjJyk7XG4gICAgICAgIHZhciBfc3ByZWFkID0gMDtcbiAgICAgICAgLy8gY29uc3QgX2ZpeGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBfZG9tYWluID0gWzAsIDFdO1xuICAgICAgICB2YXIgX3BvcyA9IFtdO1xuICAgICAgICB2YXIgX3BhZGRpbmcgPSBbMCwwXTtcbiAgICAgICAgdmFyIF9jbGFzc2VzID0gZmFsc2U7XG4gICAgICAgIHZhciBfY29sb3JzID0gW107XG4gICAgICAgIHZhciBfb3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciBfbWluID0gMDtcbiAgICAgICAgdmFyIF9tYXggPSAxO1xuICAgICAgICB2YXIgX2NvcnJlY3RMaWdodG5lc3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9jb2xvckNhY2hlID0ge307XG4gICAgICAgIHZhciBfdXNlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB2YXIgX2dhbW1hID0gMTtcblxuICAgICAgICAvLyBwcml2YXRlIG1ldGhvZHNcblxuICAgICAgICB2YXIgc2V0Q29sb3JzID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgICAgICAgICBjb2xvcnMgPSBjb2xvcnMgfHwgWycjZmZmJywgJyMwMDAnXTtcbiAgICAgICAgICAgIGlmIChjb2xvcnMgJiYgdHlwZSQyKGNvbG9ycykgPT09ICdzdHJpbmcnICYmIGNocm9tYSQ0LmJyZXdlciAmJlxuICAgICAgICAgICAgICAgIGNocm9tYSQ0LmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBjaHJvbWEkNC5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUkMihjb2xvcnMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNpbmdsZSBjb2xvclxuICAgICAgICAgICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtjb2xvcnNbMF0sIGNvbG9yc1swXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2xvcnNcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0byBjaHJvbWEgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYzxjb2xvcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzW2NdID0gY2hyb21hJDQoY29sb3JzW2NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXV0by1maWxsIGNvbG9yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgX3Bvcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMkMT0wOyBjJDE8Y29sb3JzLmxlbmd0aDsgYyQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKGMkMS8oY29sb3JzLmxlbmd0aC0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldENsYXNzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChfY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBfY2xhc3Nlcy5sZW5ndGgtMTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBuICYmIHZhbHVlID49IF9jbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGktMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG4gICAgICAgIHZhciB0TWFwRG9tYWluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG5cbiAgICAgICAgLy8gY29uc3QgY2xhc3NpZnlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vICAgICBsZXQgdmFsID0gdmFsdWU7XG4gICAgICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IG4gPSBfY2xhc3Nlcy5sZW5ndGgtMTtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBpID0gZ2V0Q2xhc3ModmFsdWUpO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtYXhjID0gX2NsYXNzZXNbbi0xXSArICgoX2NsYXNzZXNbbl0tX2NsYXNzZXNbbi0xXSkgKiAoMSAtIChfc3ByZWFkICogMC41KSkpOyAgLy8gY2VudGVyIG9mIGxhc3QgY2xhc3NcbiAgICAgICAgLy8gICAgICAgICB2YWwgPSBfbWluICsgKCgoKF9jbGFzc2VzW2ldICsgKChfY2xhc3Nlc1tpKzFdIC0gX2NsYXNzZXNbaV0pICogMC41KSkgLSBtaW5jKSAvIChtYXhjLW1pbmMpKSAqIChfbWF4IC0gX21pbikpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgLy8gfTtcblxuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBmdW5jdGlvbih2YWwsIGJ5cGFzc01hcCkge1xuICAgICAgICAgICAgdmFyIGNvbCwgdDtcbiAgICAgICAgICAgIGlmIChieXBhc3NNYXAgPT0gbnVsbCkgeyBieXBhc3NNYXAgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbCkgfHwgKHZhbCA9PT0gbnVsbCkpIHsgcmV0dXJuIF9uYWNvbDsgfVxuICAgICAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NsYXNzZXMgJiYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZ2V0Q2xhc3ModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IGMgLyAoX2NsYXNzZXMubGVuZ3RoLTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX21heCAhPT0gX21pbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGludGVycG9sYXRlIGJldHdlZW4gbWluL21heFxuICAgICAgICAgICAgICAgICAgICB0ID0gKHZhbCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHQgPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbWFpbiBtYXBcbiAgICAgICAgICAgIHQgPSB0TWFwRG9tYWluKHQpO1xuXG4gICAgICAgICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICAgICAgICAgIHQgPSB0TWFwTGlnaHRuZXNzKHQpOyAgLy8gbGlnaHRuZXNzIGNvcnJlY3Rpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9nYW1tYSAhPT0gMSkgeyB0ID0gcG93JDModCwgX2dhbW1hKTsgfVxuXG4gICAgICAgICAgICB0ID0gX3BhZGRpbmdbMF0gKyAodCAqICgxIC0gX3BhZGRpbmdbMF0gLSBfcGFkZGluZ1sxXSkpO1xuXG4gICAgICAgICAgICB0ID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdCkpO1xuXG4gICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IodCAqIDEwMDAwKTtcblxuICAgICAgICAgICAgaWYgKF91c2VDYWNoZSAmJiBfY29sb3JDYWNoZVtrXSkge1xuICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvckNhY2hlW2tdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSQyKF9jb2xvcnMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIGkgaW4gWzAuLl9wb3MubGVuZ3RoLTFdXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxfcG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9wb3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCA+PSBwKSAmJiAoaSA9PT0gKF9wb3MubGVuZ3RoLTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IHAgJiYgdCA8IF9wb3NbaSsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodC1wKS8oX3Bvc1tpKzFdLXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNocm9tYSQ0LmludGVycG9sYXRlKF9jb2xvcnNbaV0sIF9jb2xvcnNbaSsxXSwgdCwgX21vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDIoX2NvbG9ycykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9ycyh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF91c2VDYWNoZSkgeyBfY29sb3JDYWNoZVtrXSA9IGNvbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzZXRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jb2xvckNhY2hlID0ge307IH07XG5cbiAgICAgICAgc2V0Q29sb3JzKGNvbG9ycyk7XG5cbiAgICAgICAgLy8gcHVibGljIGludGVyZmFjZVxuXG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdmFyIGMgPSBjaHJvbWEkNChnZXRDb2xvcih2KSk7XG4gICAgICAgICAgICBpZiAoX291dCAmJiBjW19vdXRdKSB7IHJldHVybiBjW19vdXRdKCk7IH0gZWxzZSB7IHJldHVybiBjOyB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5jbGFzc2VzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlJDIoY2xhc3NlcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICAgICAgICAgICAgICBfZG9tYWluID0gW2NsYXNzZXNbMF0sIGNsYXNzZXNbY2xhc3Nlcy5sZW5ndGgtMV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gY2hyb21hJDQuYW5hbHl6ZShfZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gW2QubWluLCBkLm1heF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IGNocm9tYSQ0LmxpbWl0cyhkLCAnZScsIGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9jbGFzc2VzO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgZi5kb21haW4gPSBmdW5jdGlvbihkb21haW4pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21pbiA9IGRvbWFpblswXTtcbiAgICAgICAgICAgIF9tYXggPSBkb21haW5bZG9tYWluLmxlbmd0aC0xXTtcbiAgICAgICAgICAgIF9wb3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBrID0gX2NvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGRvbWFpbi5sZW5ndGggPT09IGspICYmIChfbWluICE9PSBfbWF4KSkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IEFycmF5LmZyb20oZG9tYWluKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgICAgICAgICBfcG9zLnB1c2goKGQtX21pbikgLyAoX21heC1fbWluKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGM8azsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjLyhrLTEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBkb21haW4gbWFwXG4gICAgICAgICAgICAgICAgICAgIHZhciB0T3V0ID0gZG9tYWluLm1hcChmdW5jdGlvbiAoZCxpKSB7IHJldHVybiBpLyhkb21haW4ubGVuZ3RoLTEpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRCcmVha3MgPSBkb21haW4ubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB0T3V0W2ldID09PSB2YWw7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0TWFwRG9tYWluID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8PSAwIHx8IHQgPj0gMSkgeyByZXR1cm4gdDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA+PSB0QnJlYWtzW2krMV0pIHsgaSsrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSAodCAtIHRCcmVha3NbaV0pIC8gKHRCcmVha3NbaSsxXSAtIHRCcmVha3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSB0T3V0W2ldICsgZiAqICh0T3V0W2krMV0gLSB0T3V0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2RvbWFpbiA9IFtfbWluLCBfbWF4XTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYubW9kZSA9IGZ1bmN0aW9uKF9tKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbW9kZSA9IF9tO1xuICAgICAgICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5yYW5nZSA9IGZ1bmN0aW9uKGNvbG9ycywgX3Bvcykge1xuICAgICAgICAgICAgc2V0Q29sb3JzKGNvbG9ycyk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm91dCA9IGZ1bmN0aW9uKF9vKSB7XG4gICAgICAgICAgICBfb3V0ID0gX287XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnNwcmVhZCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ByZWFkID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5jb3JyZWN0TGlnaHRuZXNzID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkgeyB2ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgX2NvcnJlY3RMaWdodG5lc3MgPSB2O1xuICAgICAgICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgaWYgKF9jb3JyZWN0TGlnaHRuZXNzKSB7XG4gICAgICAgICAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEwwID0gZ2V0Q29sb3IoMCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBMMSA9IGdldENvbG9yKDEsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9sID0gTDAgPiBMMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIExfYWN0dWFsID0gZ2V0Q29sb3IodCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2lkZWFsID0gTDAgKyAoKEwxIC0gTDApICogdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhfaXRlciA9IDIwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKE1hdGguYWJzKExfZGlmZikgPiAxZS0yKSAmJiAobWF4X2l0ZXItLSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvbCkgeyBMX2RpZmYgKj0gLTE7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTF9kaWZmIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKHQxIC0gdCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MCAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucGFkZGluZyA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSQyKHApID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBwID0gW3AscF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9wYWRkaW5nID0gcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuY29sb3JzID0gZnVuY3Rpb24obnVtQ29sb3JzLCBvdXQpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGFyZ3VtZW50cyBhcmUgZ2l2ZW4sIHJldHVybiB0aGUgb3JpZ2luYWwgY29sb3JzIHRoYXQgd2VyZSBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7IG91dCA9ICdoZXgnOyB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbG9ycy5zbGljZSgwKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1Db2xvcnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZigwLjUpXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1Db2xvcnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRtID0gX2RvbWFpblswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX19yYW5nZV9fKDAsIG51bUNvbG9ycywgZmFsc2UpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gZiggZG0gKyAoKGkvKG51bUNvbG9ycy0xKSkgKiBkZCkgKTsgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHJldHVybnMgYWxsIGNvbG9ycyBiYXNlZCBvbiB0aGUgZGVmaW5lZCBjbGFzc2VzXG4gICAgICAgICAgICAgICAgY29sb3JzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoX2NsYXNzZXMgJiYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBlbmQgPSBfY2xhc3Nlcy5sZW5ndGgsIGFzYyA9IDEgPD0gZW5kOyBhc2MgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjID8gaSsrIDogaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goKF9jbGFzc2VzW2ktMV0rX2NsYXNzZXNbaV0pKjAuNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVzID0gX2RvbWFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2FtcGxlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGYodik7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hyb21hJDRbb3V0XSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNbb3V0XSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5jYWNoZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdXNlQ2FjaGUgPSBjO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3VzZUNhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuZ2FtbWEgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2dhbW1hID0gZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nYW1tYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLm5vZGF0YSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfbmFjb2wgPSBjaHJvbWEkNChkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYWNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX19yYW5nZV9fKGxlZnQsIHJpZ2h0LCBpbmNsdXNpdmUpIHtcbiAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgdmFyIGFzY2VuZGluZyA9IGxlZnQgPCByaWdodDtcbiAgICAgIHZhciBlbmQgPSAhaW5jbHVzaXZlID8gcmlnaHQgOiBhc2NlbmRpbmcgPyByaWdodCArIDEgOiByaWdodCAtIDE7XG4gICAgICBmb3IgKHZhciBpID0gbGVmdDsgYXNjZW5kaW5nID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzY2VuZGluZyA/IGkrKyA6IGktLSkge1xuICAgICAgICByYW5nZS5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgIC8vXG5cbiAgICAvLyBAcmVxdWlyZXMgdXRpbHMgbGFiXG4gICAgdmFyIENvbG9yJDUgPSBDb2xvcl8xO1xuXG4gICAgdmFyIHNjYWxlJDEgPSBzY2FsZSQyO1xuXG4gICAgLy8gbnRoIHJvdyBvZiB0aGUgcGFzY2FsIHRyaWFuZ2xlXG4gICAgdmFyIGJpbm9tX3JvdyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIHJvdyA9IFsxLCAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdyb3cgPSBbMV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdyb3dbal0gPSAocm93W2pdIHx8IDApICsgcm93W2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyA9IG5ld3JvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH07XG5cbiAgICB2YXIgYmV6aWVyID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMjtcblxuICAgICAgICB2YXIgSSwgbGFiMCwgbGFiMSwgbGFiMjtcbiAgICAgICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IENvbG9yJDUoYyk7IH0pO1xuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIChhc3NpZ24gPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmxhYigpOyB9KSwgbGFiMCA9IGFzc2lnblswXSwgbGFiMSA9IGFzc2lnblsxXSk7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbGFiMFtpXSArICh0ICogKGxhYjFbaV0gLSBsYWIwW2ldKSk7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJDUobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIHF1YWRyYXRpYyBiZXppZXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgKGFzc2lnbiQxID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ24kMVswXSwgbGFiMSA9IGFzc2lnbiQxWzFdLCBsYWIyID0gYXNzaWduJDFbMl0pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuICgoMS10KSooMS10KSAqIGxhYjBbaV0pICsgKDIgKiAoMS10KSAqIHQgKiBsYWIxW2ldKSArICh0ICogdCAqIGxhYjJbaV0pOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAvLyBjdWJpYyBiZXppZXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgdmFyIGxhYjM7XG4gICAgICAgICAgICAoYXNzaWduJDIgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmxhYigpOyB9KSwgbGFiMCA9IGFzc2lnbiQyWzBdLCBsYWIxID0gYXNzaWduJDJbMV0sIGxhYjIgPSBhc3NpZ24kMlsyXSwgbGFiMyA9IGFzc2lnbiQyWzNdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKDEtdCkqKDEtdCkqKDEtdCkgKiBsYWIwW2ldKSArICgzICogKDEtdCkgKiAoMS10KSAqIHQgKiBsYWIxW2ldKSArICgzICogKDEtdCkgKiB0ICogdCAqIGxhYjJbaV0pICsgKHQqdCp0ICogbGFiM1tpXSk7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yJDUobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgLy8gZ2VuZXJhbCBjYXNlIChkZWdyZWUgbiBiZXppZXIpXG4gICAgICAgICAgICB2YXIgbGFicywgcm93LCBuO1xuICAgICAgICAgICAgbGFicyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pO1xuICAgICAgICAgICAgbiA9IGNvbG9ycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcm93ID0gYmlub21fcm93KG4pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSAxIC0gdDtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGxhYnMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGVsLCBqKSB7IHJldHVybiAoc3VtICsgcm93W2pdICogTWF0aC5wb3coIHUsIChuIC0gaikgKSAqIE1hdGgucG93KCB0LCBqICkgKiBlbFtpXSk7IH0sIDApOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ1KGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gcG9pbnQgaW4gcnVubmluZyBiZXppZXIgd2l0aCBvbmx5IG9uZSBjb2xvci5cIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSTtcbiAgICB9O1xuXG4gICAgdmFyIGJlemllcl8xID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICAgICAgICB2YXIgZiA9IGJlemllcihjb2xvcnMpO1xuICAgICAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NhbGUkMShmKTsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgICAqIGJsZW5kIG1vZGUgZm9ybXVsYXMgdGFrZW4gZnJvbSBodHRwOi8vd3d3LnZlbnR1cmUtd2FyZS5jb20va2V2aW4vY29kaW5nL2xldHMtbGVhcm4tbWF0aC1waG90b3Nob3AtYmxlbmQtbW9kZXMvXG4gICAgICovXG5cbiAgICB2YXIgY2hyb21hJDMgPSBjaHJvbWFfMTtcblxuICAgIHZhciBibGVuZCA9IGZ1bmN0aW9uIChib3R0b20sIHRvcCwgbW9kZSkge1xuICAgICAgICBpZiAoIWJsZW5kW21vZGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYmxlbmQgbW9kZSAnICsgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsZW5kW21vZGVdKGJvdHRvbSwgdG9wKTtcbiAgICB9O1xuXG4gICAgdmFyIGJsZW5kX2YgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGJvdHRvbSx0b3ApIHtcbiAgICAgICAgICAgIHZhciBjMCA9IGNocm9tYSQzKHRvcCkucmdiKCk7XG4gICAgICAgICAgICB2YXIgYzEgPSBjaHJvbWEkMyhib3R0b20pLnJnYigpO1xuICAgICAgICAgICAgcmV0dXJuIGNocm9tYSQzLnJnYihmKGMwLCBjMSkpO1xuICAgICAgICB9OyB9O1xuXG4gICAgdmFyIGVhY2ggPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGMwLCBjMSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgb3V0WzBdID0gZihjMFswXSwgYzFbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gZihjMFsxXSwgYzFbMV0pO1xuICAgICAgICAgICAgb3V0WzJdID0gZihjMFsyXSwgYzFbMl0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTsgfTtcblxuICAgIHZhciBub3JtYWwgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYTsgfTtcbiAgICB2YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhICogYiAvIDI1NTsgfTtcbiAgICB2YXIgZGFya2VuID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA+IGIgPyBiIDogYTsgfTtcbiAgICB2YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgPiBiID8gYSA6IGI7IH07XG4gICAgdmFyIHNjcmVlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIDI1NSAqICgxIC0gKDEtYS8yNTUpICogKDEtYi8yNTUpKTsgfTtcbiAgICB2YXIgb3ZlcmxheSA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGIgPCAxMjggPyAyICogYSAqIGIgLyAyNTUgOiAyNTUgKiAoMSAtIDIgKiAoMSAtIGEgLyAyNTUgKSAqICggMSAtIGIgLyAyNTUgKSk7IH07XG4gICAgdmFyIGJ1cm4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiAyNTUgKiAoMSAtICgxIC0gYiAvIDI1NSkgLyAoYS8yNTUpKTsgfTtcbiAgICB2YXIgZG9kZ2UgPSBmdW5jdGlvbiAoYSxiKSB7XG4gICAgICAgIGlmIChhID09PSAyNTUpIHsgcmV0dXJuIDI1NTsgfVxuICAgICAgICBhID0gMjU1ICogKGIgLyAyNTUpIC8gKDEgLSBhIC8gMjU1KTtcbiAgICAgICAgcmV0dXJuIGEgPiAyNTUgPyAyNTUgOiBhXG4gICAgfTtcblxuICAgIC8vICMgYWRkID0gKGEsYikgLT5cbiAgICAvLyAjICAgICBpZiAoYSArIGIgPiAyNTUpIHRoZW4gMjU1IGVsc2UgYSArIGJcblxuICAgIGJsZW5kLm5vcm1hbCA9IGJsZW5kX2YoZWFjaChub3JtYWwpKTtcbiAgICBibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuICAgIGJsZW5kLnNjcmVlbiA9IGJsZW5kX2YoZWFjaChzY3JlZW4pKTtcbiAgICBibGVuZC5vdmVybGF5ID0gYmxlbmRfZihlYWNoKG92ZXJsYXkpKTtcbiAgICBibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuKSk7XG4gICAgYmxlbmQubGlnaHRlbiA9IGJsZW5kX2YoZWFjaChsaWdodGVuKSk7XG4gICAgYmxlbmQuZG9kZ2UgPSBibGVuZF9mKGVhY2goZG9kZ2UpKTtcbiAgICBibGVuZC5idXJuID0gYmxlbmRfZihlYWNoKGJ1cm4pKTtcbiAgICAvLyBibGVuZC5hZGQgPSBibGVuZF9mKGVhY2goYWRkKSk7XG5cbiAgICB2YXIgYmxlbmRfMSA9IGJsZW5kO1xuXG4gICAgLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbiAgICAvLyBiYXNlZCBvbiBELkEuIEdyZWVuIFwiQSBjb2xvdXIgc2NoZW1lIGZvciB0aGUgZGlzcGxheSBvZiBhc3Ryb25vbWljYWwgaW50ZW5zaXR5IGltYWdlc1wiXG4gICAgLy8gaHR0cDovL2FzdHJvbi1zb2MuaW4vYnVsbGV0aW4vMTFKdW5lLzI4OTM5MjAxMS5wZGZcblxuICAgIHZhciB0eXBlJDEgPSB1dGlscy50eXBlO1xuICAgIHZhciBjbGlwX3JnYiA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciBUV09QSSA9IHV0aWxzLlRXT1BJO1xuICAgIHZhciBwb3ckMiA9IE1hdGgucG93O1xuICAgIHZhciBzaW4kMSA9IE1hdGguc2luO1xuICAgIHZhciBjb3MkMSA9IE1hdGguY29zO1xuICAgIHZhciBjaHJvbWEkMiA9IGNocm9tYV8xO1xuXG4gICAgdmFyIGN1YmVoZWxpeCA9IGZ1bmN0aW9uKHN0YXJ0LCByb3RhdGlvbnMsIGh1ZSwgZ2FtbWEsIGxpZ2h0bmVzcykge1xuICAgICAgICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydD0zMDA7XG4gICAgICAgIGlmICggcm90YXRpb25zID09PSB2b2lkIDAgKSByb3RhdGlvbnM9LTEuNTtcbiAgICAgICAgaWYgKCBodWUgPT09IHZvaWQgMCApIGh1ZT0xO1xuICAgICAgICBpZiAoIGdhbW1hID09PSB2b2lkIDAgKSBnYW1tYT0xO1xuICAgICAgICBpZiAoIGxpZ2h0bmVzcyA9PT0gdm9pZCAwICkgbGlnaHRuZXNzPVswLDFdO1xuXG4gICAgICAgIHZhciBkaCA9IDAsIGRsO1xuICAgICAgICBpZiAodHlwZSQxKGxpZ2h0bmVzcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGRsID0gbGlnaHRuZXNzWzFdIC0gbGlnaHRuZXNzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGwgPSAwO1xuICAgICAgICAgICAgbGlnaHRuZXNzID0gW2xpZ2h0bmVzcywgbGlnaHRuZXNzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24oZnJhY3QpIHtcbiAgICAgICAgICAgIHZhciBhID0gVFdPUEkgKiAoKChzdGFydCsxMjApLzM2MCkgKyAocm90YXRpb25zICogZnJhY3QpKTtcbiAgICAgICAgICAgIHZhciBsID0gcG93JDIobGlnaHRuZXNzWzBdICsgKGRsICogZnJhY3QpLCBnYW1tYSk7XG4gICAgICAgICAgICB2YXIgaCA9IGRoICE9PSAwID8gaHVlWzBdICsgKGZyYWN0ICogZGgpIDogaHVlO1xuICAgICAgICAgICAgdmFyIGFtcCA9IChoICogbCAqICgxLWwpKSAvIDI7XG4gICAgICAgICAgICB2YXIgY29zX2EgPSBjb3MkMShhKTtcbiAgICAgICAgICAgIHZhciBzaW5fYSA9IHNpbiQxKGEpO1xuICAgICAgICAgICAgdmFyIHIgPSBsICsgKGFtcCAqICgoLTAuMTQ4NjEgKiBjb3NfYSkgKyAoMS43ODI3Nyogc2luX2EpKSk7XG4gICAgICAgICAgICB2YXIgZyA9IGwgKyAoYW1wICogKCgtMC4yOTIyNyAqIGNvc19hKSAtICgwLjkwNjQ5KiBzaW5fYSkpKTtcbiAgICAgICAgICAgIHZhciBiID0gbCArIChhbXAgKiAoKzEuOTcyOTQgKiBjb3NfYSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNocm9tYSQyKGNsaXBfcmdiKFtyKjI1NSxnKjI1NSxiKjI1NSwxXSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuc3RhcnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICBpZiAoKHMgPT0gbnVsbCkpIHsgcmV0dXJuIHN0YXJ0OyB9XG4gICAgICAgICAgICBzdGFydCA9IHM7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnJvdGF0aW9ucyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIGlmICgociA9PSBudWxsKSkgeyByZXR1cm4gcm90YXRpb25zOyB9XG4gICAgICAgICAgICByb3RhdGlvbnMgPSByO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5nYW1tYSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgIGlmICgoZyA9PSBudWxsKSkgeyByZXR1cm4gZ2FtbWE7IH1cbiAgICAgICAgICAgIGdhbW1hID0gZztcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuaHVlID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgaWYgKChoID09IG51bGwpKSB7IHJldHVybiBodWU7IH1cbiAgICAgICAgICAgIGh1ZSA9IGg7XG4gICAgICAgICAgICBpZiAodHlwZSQxKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZVsxXSAtIGh1ZVswXTtcbiAgICAgICAgICAgICAgICBpZiAoZGggPT09IDApIHsgaHVlID0gaHVlWzFdOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYubGlnaHRuZXNzID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgaWYgKChoID09IG51bGwpKSB7IHJldHVybiBsaWdodG5lc3M7IH1cbiAgICAgICAgICAgIGlmICh0eXBlJDEoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBsaWdodG5lc3MgPSBoO1xuICAgICAgICAgICAgICAgIGRsID0gaFsxXSAtIGhbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtoLGhdO1xuICAgICAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuc2NhbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjaHJvbWEkMi5zY2FsZShmKTsgfTtcblxuICAgICAgICBmLmh1ZShodWUpO1xuXG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkNCA9IENvbG9yXzE7XG4gICAgdmFyIGRpZ2l0cyA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICAgIHZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICB2YXIgcmFuZG9tXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlID0gJyMnO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8NjsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlICs9IGRpZ2l0cy5jaGFyQXQoZmxvb3IkMShyYW5kb20oKSAqIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvciQ0KGNvZGUsICdoZXgnKTtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGUgPSB0eXBlJHA7XG4gICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgIHZhciBwb3ckMSA9IE1hdGgucG93O1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cblxuICAgIHZhciBhbmFseXplID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgICAgICBpZiAoIGtleSA9PT0gdm9pZCAwICkga2V5PW51bGw7XG5cbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUqLTEsXG4gICAgICAgICAgICBzdW06IDAsXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUoZGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhID0gT2JqZWN0LnZhbHVlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKGtleSAmJiB0eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7IHZhbCA9IHZhbFtrZXldOyB9XG4gICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsICYmICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgci52YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIHIuc3VtICs9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgci5taW4pIHsgci5taW4gPSB2YWw7IH1cbiAgICAgICAgICAgICAgICBpZiAodmFsID4gci5tYXgpIHsgci5tYXggPSB2YWw7IH1cbiAgICAgICAgICAgICAgICByLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHIuZG9tYWluID0gW3IubWluLCByLm1heF07XG5cbiAgICAgICAgci5saW1pdHMgPSBmdW5jdGlvbiAobW9kZSwgbnVtKSB7IHJldHVybiBsaW1pdHMociwgbW9kZSwgbnVtKTsgfTtcblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG5cbiAgICB2YXIgbGltaXRzID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUsIG51bSkge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGU9J2VxdWFsJztcbiAgICAgICAgaWYgKCBudW0gPT09IHZvaWQgMCApIG51bT03O1xuXG4gICAgICAgIGlmICh0eXBlKGRhdGEpID09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhbmFseXplKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW4gPSBkYXRhLm1pbjtcbiAgICAgICAgdmFyIG1heCA9IGRhdGEubWF4O1xuICAgICAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhLWI7IH0pO1xuXG4gICAgICAgIGlmIChudW0gPT09IDEpIHsgcmV0dXJuIFttaW4sbWF4XTsgfVxuXG4gICAgICAgIHZhciBsaW1pdHMgPSBbXTtcblxuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2MnKSB7IC8vIGNvbnRpbnVvdXNcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdlJykgeyAvLyBlcXVhbCBpbnRlcnZhbFxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTxudW07IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbisoKGkvbnVtKSoobWF4LW1pbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnbCcpIHsgLy8gbG9nIHNjYWxlXG4gICAgICAgICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2FyaXRobWljIHNjYWxlcyBhcmUgb25seSBwb3NzaWJsZSBmb3IgdmFsdWVzID4gMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbl9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyhtaW4pO1xuICAgICAgICAgICAgdmFyIG1heF9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyhtYXgpO1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMT0xOyBpJDE8bnVtOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHBvdyQxKDEwLCBtaW5fbG9nICsgKChpJDEvbnVtKSAqIChtYXhfbG9nIC0gbWluX2xvZykpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ3EnKSB7IC8vIHF1YW50aWxlIHNjYWxlXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyPTE7IGkkMjxudW07IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSAoKHZhbHVlcy5sZW5ndGgtMSkgKiBpJDIpL251bTtcbiAgICAgICAgICAgICAgICB2YXIgcGIgPSBmbG9vcihwKTtcbiAgICAgICAgICAgICAgICBpZiAocGIgPT09IHApIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gcCA+IHBiXG4gICAgICAgICAgICAgICAgICAgIHZhciBwciA9IHAgLSBwYjtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzLnB1c2goKHZhbHVlc1twYl0qKDEtcHIpKSArICh2YWx1ZXNbcGIrMV0qcHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnaycpIHsgLy8gay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gYmFzZWQgb25cbiAgICAgICAgICAgIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9maWd1ZS9zb3VyY2UvYnJvd3NlL3RydW5rL2ZpZ3VlLmpzIzMzNlxuICAgICAgICAgICAgc2ltcGxpZmllZCBmb3IgMS1kIGlucHV0IHZhbHVlc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjbHVzdGVyO1xuICAgICAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXJTaXplcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbmJfaXRlcnMgPSAwO1xuICAgICAgICAgICAgdmFyIGNlbnRyb2lkcyA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGdldCBzZWVkIHZhbHVlc1xuICAgICAgICAgICAgY2VudHJvaWRzID0gW107XG4gICAgICAgICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQzPTE7IGkkMzxudW07IGkkMysrKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWluICsgKChpJDMvbnVtKSAqIChtYXgtbWluKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgc3RlcFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxudW07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2l6ZXNbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDQ9MDsgaSQ0PG47IGkkNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpJDRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZXN0ID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGokMT0wOyBqJDE8bnVtOyBqJDErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBhYnMkMShjZW50cm9pZHNbaiQxXS12YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5kaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0ID0gaiQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2Jlc3RdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50c1tpJDRdID0gYmVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjZW50cm9pZHMgc3RlcFxuICAgICAgICAgICAgICAgIHZhciBuZXdDZW50cm9pZHMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDI9MDsgaiQyPG51bTsgaiQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2okMl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDU9MDsgaSQ1PG47IGkkNSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q2VudHJvaWRzW2NsdXN0ZXJdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbY2x1c3Rlcl0gPSB2YWx1ZXNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSArPSB2YWx1ZXNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDM9MDsgaiQzPG51bTsgaiQzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2okM10gKj0gMS9jbHVzdGVyU2l6ZXNbaiQzXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb252ZXJnZW5jZVxuICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGokND0wOyBqJDQ8bnVtOyBqJDQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q2VudHJvaWRzW2okNF0gIT09IGNlbnRyb2lkc1tqJDRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZW50cm9pZHMgPSBuZXdDZW50cm9pZHM7XG4gICAgICAgICAgICAgICAgbmJfaXRlcnMrKztcblxuICAgICAgICAgICAgICAgIGlmIChuYl9pdGVycyA+IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGstbWVhbnMgY2x1c3RlcmluZ1xuICAgICAgICAgICAgLy8gdGhlIG5leHQgcGFydCBpcyBib3Jyb3dlZCBmcm9tIGdhYnJpZWxmbG9yLml0XG4gICAgICAgICAgICB2YXIga0NsdXN0ZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBqJDU9MDsgaiQ1PG51bTsgaiQ1KyspIHtcbiAgICAgICAgICAgICAgICBrQ2x1c3RlcnNbaiQ1XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSQ2PTA7IGkkNjxuOyBpJDYrKykge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpJDZdO1xuICAgICAgICAgICAgICAgIGtDbHVzdGVyc1tjbHVzdGVyXS5wdXNoKHZhbHVlc1tpJDZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0bXBLTWVhbnNCcmVha3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGokNj0wOyBqJDY8bnVtOyBqJDYrKykge1xuICAgICAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcy5wdXNoKGtDbHVzdGVyc1tqJDZdWzBdKTtcbiAgICAgICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbaiQ2XVtrQ2x1c3RlcnNbaiQ2XS5sZW5ndGgtMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzID0gdG1wS01lYW5zQnJlYWtzLnNvcnQoZnVuY3Rpb24gKGEsYil7IHJldHVybiBhLWI7IH0pO1xuICAgICAgICAgICAgbGltaXRzLnB1c2godG1wS01lYW5zQnJlYWtzWzBdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNz0xOyBpJDcgPCB0bXBLTWVhbnNCcmVha3MubGVuZ3RoOyBpJDcrPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0bXBLTWVhbnNCcmVha3NbaSQ3XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHYpICYmIChsaW1pdHMuaW5kZXhPZih2KSA9PT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGltaXRzO1xuICAgIH07XG5cbiAgICB2YXIgYW5hbHl6ZV8xID0ge2FuYWx5emU6IGFuYWx5emUsIGxpbWl0czogbGltaXRzfTtcblxuICAgIHZhciBDb2xvciQzID0gQ29sb3JfMTtcblxuXG4gICAgdmFyIGNvbnRyYXN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZlxuICAgICAgICBhID0gbmV3IENvbG9yJDMoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3IkMyhiKTtcbiAgICAgICAgdmFyIGwxID0gYS5sdW1pbmFuY2UoKTtcbiAgICAgICAgdmFyIGwyID0gYi5sdW1pbmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yJDIgPSBDb2xvcl8xO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIG1heCA9IE1hdGgubWF4O1xuICAgIHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGV4cCA9IE1hdGguZXhwO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICB2YXIgZGVsdGFFID0gZnVuY3Rpb24oYSwgYiwgS2wsIEtjLCBLaCkge1xuICAgICAgICBpZiAoIEtsID09PSB2b2lkIDAgKSBLbD0xO1xuICAgICAgICBpZiAoIEtjID09PSB2b2lkIDAgKSBLYz0xO1xuICAgICAgICBpZiAoIEtoID09PSB2b2lkIDAgKSBLaD0xO1xuXG4gICAgICAgIC8vIERlbHRhIEUgKENJRSAyMDAwKVxuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fRGVsdGFFX0NJRTIwMDAuaHRtbFxuICAgICAgICB2YXIgcmFkMmRlZyA9IGZ1bmN0aW9uKHJhZCkge1xuICAgICAgICAgICAgcmV0dXJuIDM2MCAqIHJhZCAvICgyICogUEkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVnMnJhZCA9IGZ1bmN0aW9uKGRlZykge1xuICAgICAgICAgICAgcmV0dXJuICgyICogUEkgKiBkZWcpIC8gMzYwO1xuICAgICAgICB9O1xuICAgICAgICBhID0gbmV3IENvbG9yJDIoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3IkMihiKTtcbiAgICAgICAgdmFyIHJlZiA9IEFycmF5LmZyb20oYS5sYWIoKSk7XG4gICAgICAgIHZhciBMMSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGExID0gcmVmWzFdO1xuICAgICAgICB2YXIgYjEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IEFycmF5LmZyb20oYi5sYWIoKSk7XG4gICAgICAgIHZhciBMMiA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYTIgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGIyID0gcmVmJDFbMl07XG4gICAgICAgIHZhciBhdmdMID0gKEwxICsgTDIpLzI7XG4gICAgICAgIHZhciBDMSA9IHNxcnQocG93KGExLCAyKSArIHBvdyhiMSwgMikpO1xuICAgICAgICB2YXIgQzIgPSBzcXJ0KHBvdyhhMiwgMikgKyBwb3coYjIsIDIpKTtcbiAgICAgICAgdmFyIGF2Z0MgPSAoQzEgKyBDMikvMjtcbiAgICAgICAgdmFyIEcgPSAwLjUqKDEtc3FydChwb3coYXZnQywgNykvKHBvdyhhdmdDLCA3KSArIHBvdygyNSwgNykpKSk7XG4gICAgICAgIHZhciBhMXAgPSBhMSooMStHKTtcbiAgICAgICAgdmFyIGEycCA9IGEyKigxK0cpO1xuICAgICAgICB2YXIgQzFwID0gc3FydChwb3coYTFwLCAyKSArIHBvdyhiMSwgMikpO1xuICAgICAgICB2YXIgQzJwID0gc3FydChwb3coYTJwLCAyKSArIHBvdyhiMiwgMikpO1xuICAgICAgICB2YXIgYXZnQ3AgPSAoQzFwICsgQzJwKS8yO1xuICAgICAgICB2YXIgYXJjdGFuMSA9IHJhZDJkZWcoYXRhbjIoYjEsIGExcCkpO1xuICAgICAgICB2YXIgYXJjdGFuMiA9IHJhZDJkZWcoYXRhbjIoYjIsIGEycCkpO1xuICAgICAgICB2YXIgaDFwID0gYXJjdGFuMSA+PSAwID8gYXJjdGFuMSA6IGFyY3RhbjEgKyAzNjA7XG4gICAgICAgIHZhciBoMnAgPSBhcmN0YW4yID49IDAgPyBhcmN0YW4yIDogYXJjdGFuMiArIDM2MDtcbiAgICAgICAgdmFyIGF2Z0hwID0gYWJzKGgxcCAtIGgycCkgPiAxODAgPyAoaDFwICsgaDJwICsgMzYwKS8yIDogKGgxcCArIGgycCkvMjtcbiAgICAgICAgdmFyIFQgPSAxIC0gMC4xNypjb3MoZGVnMnJhZChhdmdIcCAtIDMwKSkgKyAwLjI0KmNvcyhkZWcycmFkKDIqYXZnSHApKSArIDAuMzIqY29zKGRlZzJyYWQoMyphdmdIcCArIDYpKSAtIDAuMipjb3MoZGVnMnJhZCg0KmF2Z0hwIC0gNjMpKTtcbiAgICAgICAgdmFyIGRlbHRhSHAgPSBoMnAgLSBoMXA7XG4gICAgICAgIGRlbHRhSHAgPSBhYnMoZGVsdGFIcCkgPD0gMTgwID8gZGVsdGFIcCA6IGgycCA8PSBoMXAgPyBkZWx0YUhwICsgMzYwIDogZGVsdGFIcCAtIDM2MDtcbiAgICAgICAgZGVsdGFIcCA9IDIqc3FydChDMXAqQzJwKSpzaW4oZGVnMnJhZChkZWx0YUhwKS8yKTtcbiAgICAgICAgdmFyIGRlbHRhTCA9IEwyIC0gTDE7XG4gICAgICAgIHZhciBkZWx0YUNwID0gQzJwIC0gQzFwOyAgICBcbiAgICAgICAgdmFyIHNsID0gMSArICgwLjAxNSpwb3coYXZnTCAtIDUwLCAyKSkvc3FydCgyMCArIHBvdyhhdmdMIC0gNTAsIDIpKTtcbiAgICAgICAgdmFyIHNjID0gMSArIDAuMDQ1KmF2Z0NwO1xuICAgICAgICB2YXIgc2ggPSAxICsgMC4wMTUqYXZnQ3AqVDtcbiAgICAgICAgdmFyIGRlbHRhVGhldGEgPSAzMCpleHAoLXBvdygoYXZnSHAgLSAyNzUpLzI1LCAyKSk7XG4gICAgICAgIHZhciBSYyA9IDIqc3FydChwb3coYXZnQ3AsIDcpLyhwb3coYXZnQ3AsIDcpICsgcG93KDI1LCA3KSkpO1xuICAgICAgICB2YXIgUnQgPSAtUmMqc2luKDIqZGVnMnJhZChkZWx0YVRoZXRhKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzcXJ0KHBvdyhkZWx0YUwvKEtsKnNsKSwgMikgKyBwb3coZGVsdGFDcC8oS2Mqc2MpLCAyKSArIHBvdyhkZWx0YUhwLyhLaCpzaCksIDIpICsgUnQqKGRlbHRhQ3AvKEtjKnNjKSkqKGRlbHRhSHAvKEtoKnNoKSkpO1xuICAgICAgICByZXR1cm4gbWF4KDAsIG1pbigxMDAsIHJlc3VsdCkpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IkMSA9IENvbG9yXzE7XG5cbiAgICAvLyBzaW1wbGUgRXVjbGlkZWFuIGRpc3RhbmNlXG4gICAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYiwgbW9kZSkge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGU9J2xhYic7XG5cbiAgICAgICAgLy8gRGVsdGEgRSAoQ0lFIDE5NzYpXG4gICAgICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG4gICAgICAgIGEgPSBuZXcgQ29sb3IkMShhKTtcbiAgICAgICAgYiA9IG5ldyBDb2xvciQxKGIpO1xuICAgICAgICB2YXIgbDEgPSBhLmdldChtb2RlKTtcbiAgICAgICAgdmFyIGwyID0gYi5nZXQobW9kZSk7XG4gICAgICAgIHZhciBzdW1fc3EgPSAwO1xuICAgICAgICBmb3IgKHZhciBpIGluIGwxKSB7XG4gICAgICAgICAgICB2YXIgZCA9IChsMVtpXSB8fCAwKSAtIChsMltpXSB8fCAwKTtcbiAgICAgICAgICAgIHN1bV9zcSArPSBkKmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xuICAgIH07XG5cbiAgICB2YXIgQ29sb3IgPSBDb2xvcl8xO1xuXG4gICAgdmFyIHZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzKSApKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG4gICAgdmFyIGNocm9tYSQxID0gY2hyb21hXzE7XG5cbiAgICB2YXIgc2NhbGUgPSBzY2FsZSQyO1xuXG4gICAgdmFyIHNjYWxlcyA9IHtcbiAgICBcdGNvb2w6IGZ1bmN0aW9uIGNvb2woKSB7IHJldHVybiBzY2FsZShbY2hyb21hJDEuaHNsKDE4MCwxLC45KSwgY2hyb21hJDEuaHNsKDI1MCwuNywuNCldKSB9LFxuICAgIFx0aG90OiBmdW5jdGlvbiBob3QoKSB7IHJldHVybiBzY2FsZShbJyMwMDAnLCcjZjAwJywnI2ZmMCcsJyNmZmYnXSkubW9kZSgncmdiJykgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgQ29sb3JCcmV3ZXIgY29sb3JzIGZvciBjaHJvbWEuanNcblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMDIgQ3ludGhpYSBCcmV3ZXIsIE1hcmsgSGFycm93ZXIsIGFuZCBUaGVcbiAgICAgICAgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG5cbiAgICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgICAgICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZFxuICAgICAgICB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUlxuICAgICAgICBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICAgICAgICBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG5cbiAgICB2YXIgY29sb3JicmV3ZXIgPSB7XG4gICAgICAgIC8vIHNlcXVlbnRpYWxcbiAgICAgICAgT3JSZDogWycjZmZmN2VjJywgJyNmZWU4YzgnLCAnI2ZkZDQ5ZScsICcjZmRiYjg0JywgJyNmYzhkNTknLCAnI2VmNjU0OCcsICcjZDczMDFmJywgJyNiMzAwMDAnLCAnIzdmMDAwMCddLFxuICAgICAgICBQdUJ1OiBbJyNmZmY3ZmInLCAnI2VjZTdmMicsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzc0YTljZicsICcjMzY5MGMwJywgJyMwNTcwYjAnLCAnIzA0NWE4ZCcsICcjMDIzODU4J10sXG4gICAgICAgIEJ1UHU6IFsnI2Y3ZmNmZCcsICcjZTBlY2Y0JywgJyNiZmQzZTYnLCAnIzllYmNkYScsICcjOGM5NmM2JywgJyM4YzZiYjEnLCAnIzg4NDE5ZCcsICcjODEwZjdjJywgJyM0ZDAwNGInXSxcbiAgICAgICAgT3JhbmdlczogWycjZmZmNWViJywgJyNmZWU2Y2UnLCAnI2ZkZDBhMicsICcjZmRhZTZiJywgJyNmZDhkM2MnLCAnI2YxNjkxMycsICcjZDk0ODAxJywgJyNhNjM2MDMnLCAnIzdmMjcwNCddLFxuICAgICAgICBCdUduOiBbJyNmN2ZjZmQnLCAnI2U1ZjVmOScsICcjY2NlY2U2JywgJyM5OWQ4YzknLCAnIzY2YzJhNCcsICcjNDFhZTc2JywgJyMyMzhiNDUnLCAnIzAwNmQyYycsICcjMDA0NDFiJ10sXG4gICAgICAgIFlsT3JCcjogWycjZmZmZmU1JywgJyNmZmY3YmMnLCAnI2ZlZTM5MScsICcjZmVjNDRmJywgJyNmZTk5MjknLCAnI2VjNzAxNCcsICcjY2M0YzAyJywgJyM5OTM0MDQnLCAnIzY2MjUwNiddLFxuICAgICAgICBZbEduOiBbJyNmZmZmZTUnLCAnI2Y3ZmNiOScsICcjZDlmMGEzJywgJyNhZGRkOGUnLCAnIzc4YzY3OScsICcjNDFhYjVkJywgJyMyMzg0NDMnLCAnIzAwNjgzNycsICcjMDA0NTI5J10sXG4gICAgICAgIFJlZHM6IFsnI2ZmZjVmMCcsICcjZmVlMGQyJywgJyNmY2JiYTEnLCAnI2ZjOTI3MicsICcjZmI2YTRhJywgJyNlZjNiMmMnLCAnI2NiMTgxZCcsICcjYTUwZjE1JywgJyM2NzAwMGQnXSxcbiAgICAgICAgUmRQdTogWycjZmZmN2YzJywgJyNmZGUwZGQnLCAnI2ZjYzVjMCcsICcjZmE5ZmI1JywgJyNmNzY4YTEnLCAnI2RkMzQ5NycsICcjYWUwMTdlJywgJyM3YTAxNzcnLCAnIzQ5MDA2YSddLFxuICAgICAgICBHcmVlbnM6IFsnI2Y3ZmNmNScsICcjZTVmNWUwJywgJyNjN2U5YzAnLCAnI2ExZDk5YicsICcjNzRjNDc2JywgJyM0MWFiNWQnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICAgICAgWWxHbkJ1OiBbJyNmZmZmZDknLCAnI2VkZjhiMScsICcjYzdlOWI0JywgJyM3ZmNkYmInLCAnIzQxYjZjNCcsICcjMWQ5MWMwJywgJyMyMjVlYTgnLCAnIzI1MzQ5NCcsICcjMDgxZDU4J10sXG4gICAgICAgIFB1cnBsZXM6IFsnI2ZjZmJmZCcsICcjZWZlZGY1JywgJyNkYWRhZWInLCAnI2JjYmRkYycsICcjOWU5YWM4JywgJyM4MDdkYmEnLCAnIzZhNTFhMycsICcjNTQyNzhmJywgJyMzZjAwN2QnXSxcbiAgICAgICAgR25CdTogWycjZjdmY2YwJywgJyNlMGYzZGInLCAnI2NjZWJjNScsICcjYThkZGI1JywgJyM3YmNjYzQnLCAnIzRlYjNkMycsICcjMmI4Y2JlJywgJyMwODY4YWMnLCAnIzA4NDA4MSddLFxuICAgICAgICBHcmV5czogWycjZmZmZmZmJywgJyNmMGYwZjAnLCAnI2Q5ZDlkOScsICcjYmRiZGJkJywgJyM5Njk2OTYnLCAnIzczNzM3MycsICcjNTI1MjUyJywgJyMyNTI1MjUnLCAnIzAwMDAwMCddLFxuICAgICAgICBZbE9yUmQ6IFsnI2ZmZmZjYycsICcjZmZlZGEwJywgJyNmZWQ5NzYnLCAnI2ZlYjI0YycsICcjZmQ4ZDNjJywgJyNmYzRlMmEnLCAnI2UzMWExYycsICcjYmQwMDI2JywgJyM4MDAwMjYnXSxcbiAgICAgICAgUHVSZDogWycjZjdmNGY5JywgJyNlN2UxZWYnLCAnI2Q0YjlkYScsICcjYzk5NGM3JywgJyNkZjY1YjAnLCAnI2U3Mjk4YScsICcjY2UxMjU2JywgJyM5ODAwNDMnLCAnIzY3MDAxZiddLFxuICAgICAgICBCbHVlczogWycjZjdmYmZmJywgJyNkZWViZjcnLCAnI2M2ZGJlZicsICcjOWVjYWUxJywgJyM2YmFlZDYnLCAnIzQyOTJjNicsICcjMjE3MWI1JywgJyMwODUxOWMnLCAnIzA4MzA2YiddLFxuICAgICAgICBQdUJ1R246IFsnI2ZmZjdmYicsICcjZWNlMmYwJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNjdhOWNmJywgJyMzNjkwYzAnLCAnIzAyODE4YScsICcjMDE2YzU5JywgJyMwMTQ2MzYnXSxcbiAgICAgICAgVmlyaWRpczogWycjNDQwMTU0JywgJyM0ODI3NzcnLCAnIzNmNGE4YScsICcjMzE2NzhlJywgJyMyNjgzOGYnLCAnIzFmOWQ4YScsICcjNmNjZTVhJywgJyNiNmRlMmInLCAnI2ZlZTgyNSddLFxuXG4gICAgICAgIC8vIGRpdmVyZ2luZ1xuXG4gICAgICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgICAgICBSZFlsR246IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDhiJywgJyNmZmZmYmYnLCAnI2Q5ZWY4YicsICcjYTZkOTZhJywgJyM2NmJkNjMnLCAnIzFhOTg1MCcsICcjMDA2ODM3J10sXG4gICAgICAgIFJkQnU6IFsnIzY3MDAxZicsICcjYjIxODJiJywgJyNkNjYwNGQnLCAnI2Y0YTU4MicsICcjZmRkYmM3JywgJyNmN2Y3ZjcnLCAnI2QxZTVmMCcsICcjOTJjNWRlJywgJyM0MzkzYzMnLCAnIzIxNjZhYycsICcjMDUzMDYxJ10sXG4gICAgICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgICAgIFBSR246IFsnIzQwMDA0YicsICcjNzYyYTgzJywgJyM5OTcwYWInLCAnI2MyYTVjZicsICcjZTdkNGU4JywgJyNmN2Y3ZjcnLCAnI2Q5ZjBkMycsICcjYTZkYmEwJywgJyM1YWFlNjEnLCAnIzFiNzgzNycsICcjMDA0NDFiJ10sXG4gICAgICAgIFJkWWxCdTogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOTAnLCAnI2ZmZmZiZicsICcjZTBmM2Y4JywgJyNhYmQ5ZTknLCAnIzc0YWRkMScsICcjNDU3NWI0JywgJyMzMTM2OTUnXSxcbiAgICAgICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICAgICAgUmRHeTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2ZmZmZmZicsICcjZTBlMGUwJywgJyNiYWJhYmEnLCAnIzg3ODc4NycsICcjNGQ0ZDRkJywgJyMxYTFhMWEnXSxcbiAgICAgICAgUHVPcjogWycjN2YzYjA4JywgJyNiMzU4MDYnLCAnI2UwODIxNCcsICcjZmRiODYzJywgJyNmZWUwYjYnLCAnI2Y3ZjdmNycsICcjZDhkYWViJywgJyNiMmFiZDInLCAnIzgwNzNhYycsICcjNTQyNzg4JywgJyMyZDAwNGInXSxcblxuICAgICAgICAvLyBxdWFsaXRhdGl2ZVxuXG4gICAgICAgIFNldDI6IFsnIzY2YzJhNScsICcjZmM4ZDYyJywgJyM4ZGEwY2InLCAnI2U3OGFjMycsICcjYTZkODU0JywgJyNmZmQ5MmYnLCAnI2U1YzQ5NCcsICcjYjNiM2IzJ10sXG4gICAgICAgIEFjY2VudDogWycjN2ZjOTdmJywgJyNiZWFlZDQnLCAnI2ZkYzA4NicsICcjZmZmZjk5JywgJyMzODZjYjAnLCAnI2YwMDI3ZicsICcjYmY1YjE3JywgJyM2NjY2NjYnXSxcbiAgICAgICAgU2V0MTogWycjZTQxYTFjJywgJyMzNzdlYjgnLCAnIzRkYWY0YScsICcjOTg0ZWEzJywgJyNmZjdmMDAnLCAnI2ZmZmYzMycsICcjYTY1NjI4JywgJyNmNzgxYmYnLCAnIzk5OTk5OSddLFxuICAgICAgICBTZXQzOiBbJyM4ZGQzYzcnLCAnI2ZmZmZiMycsICcjYmViYWRhJywgJyNmYjgwNzInLCAnIzgwYjFkMycsICcjZmRiNDYyJywgJyNiM2RlNjknLCAnI2ZjY2RlNScsICcjZDlkOWQ5JywgJyNiYzgwYmQnLCAnI2NjZWJjNScsICcjZmZlZDZmJ10sXG4gICAgICAgIERhcmsyOiBbJyMxYjllNzcnLCAnI2Q5NWYwMicsICcjNzU3MGIzJywgJyNlNzI5OGEnLCAnIzY2YTYxZScsICcjZTZhYjAyJywgJyNhNjc2MWQnLCAnIzY2NjY2NiddLFxuICAgICAgICBQYWlyZWQ6IFsnI2E2Y2VlMycsICcjMWY3OGI0JywgJyNiMmRmOGEnLCAnIzMzYTAyYycsICcjZmI5YTk5JywgJyNlMzFhMWMnLCAnI2ZkYmY2ZicsICcjZmY3ZjAwJywgJyNjYWIyZDYnLCAnIzZhM2Q5YScsICcjZmZmZjk5JywgJyNiMTU5MjgnXSxcbiAgICAgICAgUGFzdGVsMjogWycjYjNlMmNkJywgJyNmZGNkYWMnLCAnI2NiZDVlOCcsICcjZjRjYWU0JywgJyNlNmY1YzknLCAnI2ZmZjJhZScsICcjZjFlMmNjJywgJyNjY2NjY2MnXSxcbiAgICAgICAgUGFzdGVsMTogWycjZmJiNGFlJywgJyNiM2NkZTMnLCAnI2NjZWJjNScsICcjZGVjYmU0JywgJyNmZWQ5YTYnLCAnI2ZmZmZjYycsICcjZTVkOGJkJywgJyNmZGRhZWMnLCAnI2YyZjJmMiddLFxuICAgIH07XG5cbiAgICAvLyBhZGQgbG93ZXJjYXNlIGFsaWFzZXMgZm9yIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gbGlzdFtpXTtcblxuICAgICAgICBjb2xvcmJyZXdlcltrZXkudG9Mb3dlckNhc2UoKV0gPSBjb2xvcmJyZXdlcltrZXldO1xuICAgIH1cblxuICAgIHZhciBjb2xvcmJyZXdlcl8xID0gY29sb3JicmV3ZXI7XG5cbiAgICB2YXIgY2hyb21hID0gY2hyb21hXzE7XG5cbiAgICAvLyBmZWVsIGZyZWUgdG8gY29tbWVudCBvdXQgYW55dGhpbmcgdG8gcm9sbHVwXG4gICAgLy8gYSBzbWFsbGVyIGNocm9tYS5qcyBidWlsdFxuXG4gICAgLy8gaW8gLS0+IGNvbnZlcnQgY29sb3JzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIG9wZXJhdG9ycyAtLT4gbW9kaWZ5IGV4aXN0aW5nIENvbG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gaW50ZXJwb2xhdG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIGdlbmVyYXRvcnMgLS0gPiBjcmVhdGUgbmV3IGNvbG9yc1xuICAgIGNocm9tYS5hdmVyYWdlID0gYXZlcmFnZTtcbiAgICBjaHJvbWEuYmV6aWVyID0gYmV6aWVyXzE7XG4gICAgY2hyb21hLmJsZW5kID0gYmxlbmRfMTtcbiAgICBjaHJvbWEuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICAgIGNocm9tYS5taXggPSBjaHJvbWEuaW50ZXJwb2xhdGUgPSBtaXgkMTtcbiAgICBjaHJvbWEucmFuZG9tID0gcmFuZG9tXzE7XG4gICAgY2hyb21hLnNjYWxlID0gc2NhbGUkMjtcblxuICAgIC8vIG90aGVyIHV0aWxpdHkgbWV0aG9kc1xuICAgIGNocm9tYS5hbmFseXplID0gYW5hbHl6ZV8xLmFuYWx5emU7XG4gICAgY2hyb21hLmNvbnRyYXN0ID0gY29udHJhc3Q7XG4gICAgY2hyb21hLmRlbHRhRSA9IGRlbHRhRTtcbiAgICBjaHJvbWEuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBjaHJvbWEubGltaXRzID0gYW5hbHl6ZV8xLmxpbWl0cztcbiAgICBjaHJvbWEudmFsaWQgPSB2YWxpZDtcblxuICAgIC8vIHNjYWxlXG4gICAgY2hyb21hLnNjYWxlcyA9IHNjYWxlcztcblxuICAgIC8vIGNvbG9yc1xuICAgIGNocm9tYS5jb2xvcnMgPSB3M2N4MTFfMTtcbiAgICBjaHJvbWEuYnJld2VyID0gY29sb3JicmV3ZXJfMTtcblxuICAgIHZhciBjaHJvbWFfanMgPSBjaHJvbWE7XG5cbiAgICByZXR1cm4gY2hyb21hX2pzO1xuXG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIvKipcbiAqIEBsaWNlbnNlIEZyYWN0aW9uLmpzIHY0LjIuMCAwNS8wMy8yMDIyXG4gKiBodHRwczovL3d3dy54YXJnLm9yZy8yMDE0LzAzL3JhdGlvbmFsLW51bWJlcnMtaW4tamF2YXNjcmlwdC9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEsIFJvYmVydCBFaXNlbGUgKHJvYmVydEB4YXJnLm9yZylcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICoqL1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3Mgb2ZmZXJzIHRoZSBwb3NzaWJpbGl0eSB0byBjYWxjdWxhdGUgZnJhY3Rpb25zLlxuICogWW91IGNhbiBwYXNzIGEgZnJhY3Rpb24gaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBhcnJheSwgYXMgZG91YmxlLCBhcyBzdHJpbmcgb3IgYXMgYW4gaW50ZWdlci5cbiAqXG4gKiBBcnJheS9PYmplY3QgZm9ybVxuICogWyAwID0+IDxub21pbmF0b3I+LCAxID0+IDxkZW5vbWluYXRvcj4gXVxuICogWyBuID0+IDxub21pbmF0b3I+LCBkID0+IDxkZW5vbWluYXRvcj4gXVxuICpcbiAqIEludGVnZXIgZm9ybVxuICogLSBTaW5nbGUgaW50ZWdlciB2YWx1ZVxuICpcbiAqIERvdWJsZSBmb3JtXG4gKiAtIFNpbmdsZSBkb3VibGUgdmFsdWVcbiAqXG4gKiBTdHJpbmcgZm9ybVxuICogMTIzLjQ1NiAtIGEgc2ltcGxlIGRvdWJsZVxuICogMTIzLzQ1NiAtIGEgc3RyaW5nIGZyYWN0aW9uXG4gKiAxMjMuJzQ1NicgLSBhIGRvdWJsZSB3aXRoIHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlc1xuICogMTIzLig0NTYpIC0gc3lub255bVxuICogMTIzLjQ1JzYnIC0gYSBkb3VibGUgd2l0aCByZXBlYXRpbmcgbGFzdCBwbGFjZVxuICogMTIzLjQ1KDYpIC0gc3lub255bVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogdmFyIGYgPSBuZXcgRnJhY3Rpb24oXCI5LjQnMzEnXCIpO1xuICogZi5tdWwoWy00LCAzXSkuZGl2KDQuOSk7XG4gKlxuICovXG5cbihmdW5jdGlvbihyb290KSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gTWF4aW11bSBzZWFyY2ggZGVwdGggZm9yIGN5Y2xpYyByYXRpb25hbCBudW1iZXJzLiAyMDAwIHNob3VsZCBiZSBtb3JlIHRoYW4gZW5vdWdoLlxuICAvLyBFeGFtcGxlOiAxLzcgPSAwLigxNDI4NTcpIGhhcyA2IHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlcy5cbiAgLy8gSWYgTUFYX0NZQ0xFX0xFTiBnZXRzIHJlZHVjZWQsIGxvbmcgY3ljbGVzIHdpbGwgbm90IGJlIGRldGVjdGVkIGFuZCB0b1N0cmluZygpIG9ubHkgZ2V0cyB0aGUgZmlyc3QgMTAgZGlnaXRzXG4gIHZhciBNQVhfQ1lDTEVfTEVOID0gMjAwMDtcblxuICAvLyBQYXJzZWQgZGF0YSB0byBhdm9pZCBjYWxsaW5nIFwibmV3XCIgYWxsIHRoZSB0aW1lXG4gIHZhciBQID0ge1xuICAgIFwic1wiOiAxLFxuICAgIFwiblwiOiAwLFxuICAgIFwiZFwiOiAxXG4gIH07XG5cbiAgZnVuY3Rpb24gYXNzaWduKG4sIHMpIHtcblxuICAgIGlmIChpc05hTihuID0gcGFyc2VJbnQobiwgMTApKSkge1xuICAgICAgdGhyb3cgRnJhY3Rpb25bJ0ludmFsaWRQYXJhbWV0ZXInXTtcbiAgICB9XG4gICAgcmV0dXJuIG4gKiBzO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIG5ldyBGcmFjdGlvbiBpbnRlcm5hbGx5IHdpdGhvdXQgdGhlIG5lZWQgb2YgdGhlIGJ1bGt5IGNvbnN0cnVjdG9yXG4gIGZ1bmN0aW9uIG5ld0ZyYWN0aW9uKG4sIGQpIHtcblxuICAgIGlmIChkID09PSAwKSB7XG4gICAgICB0aHJvdyBGcmFjdGlvblsnRGl2aXNpb25CeVplcm8nXTtcbiAgICB9XG5cbiAgICB2YXIgZiA9IE9iamVjdC5jcmVhdGUoRnJhY3Rpb24ucHJvdG90eXBlKTtcbiAgICBmW1wic1wiXSA9IG4gPCAwID8gLTEgOiAxO1xuXG4gICAgbiA9IG4gPCAwID8gLW4gOiBuO1xuXG4gICAgdmFyIGEgPSBnY2QobiwgZCk7XG5cbiAgICBmW1wiblwiXSA9IG4gLyBhO1xuICAgIGZbXCJkXCJdID0gZCAvIGE7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICBmdW5jdGlvbiBmYWN0b3JpemUobnVtKSB7XG5cbiAgICB2YXIgZmFjdG9ycyA9IHt9O1xuXG4gICAgdmFyIG4gPSBudW07XG4gICAgdmFyIGkgPSAyO1xuICAgIHZhciBzID0gNDtcblxuICAgIHdoaWxlIChzIDw9IG4pIHtcblxuICAgICAgd2hpbGUgKG4gJSBpID09PSAwKSB7XG4gICAgICAgIG4vPSBpO1xuICAgICAgICBmYWN0b3JzW2ldID0gKGZhY3RvcnNbaV0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgcys9IDEgKyAyICogaSsrO1xuICAgIH1cblxuICAgIGlmIChuICE9PSBudW0pIHtcbiAgICAgIGlmIChuID4gMSlcbiAgICAgICAgZmFjdG9yc1tuXSA9IChmYWN0b3JzW25dIHx8IDApICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFjdG9yc1tudW1dID0gKGZhY3RvcnNbbnVtXSB8fCAwKSArIDE7XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3JzO1xuICB9XG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocDEsIHAyKSB7XG5cbiAgICB2YXIgbiA9IDAsIGQgPSAxLCBzID0gMTtcbiAgICB2YXIgdiA9IDAsIHcgPSAwLCB4ID0gMCwgeSA9IDEsIHogPSAxO1xuXG4gICAgdmFyIEEgPSAwLCBCID0gMTtcbiAgICB2YXIgQyA9IDEsIEQgPSAxO1xuXG4gICAgdmFyIE4gPSAxMDAwMDAwMDtcbiAgICB2YXIgTTtcblxuICAgIGlmIChwMSA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSBudWxsKSB7XG4gICAgICAvKiB2b2lkICovXG4gICAgfSBlbHNlIGlmIChwMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuID0gcDE7XG4gICAgICBkID0gcDI7XG4gICAgICBzID0gbiAqIGQ7XG5cbiAgICAgIGlmIChuICUgMSAhPT0gMCB8fCBkICUgMSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBGcmFjdGlvblsnTm9uSW50ZWdlclBhcmFtZXRlciddO1xuICAgICAgfVxuXG4gICAgfSBlbHNlXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBwMSkge1xuXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoXCJkXCIgaW4gcDEgJiYgXCJuXCIgaW4gcDEpIHtcbiAgICAgICAgICAgICAgbiA9IHAxW1wiblwiXTtcbiAgICAgICAgICAgICAgZCA9IHAxW1wiZFwiXTtcbiAgICAgICAgICAgICAgaWYgKFwic1wiIGluIHAxKVxuICAgICAgICAgICAgICAgIG4qPSBwMVtcInNcIl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKDAgaW4gcDEpIHtcbiAgICAgICAgICAgICAgbiA9IHAxWzBdO1xuICAgICAgICAgICAgICBpZiAoMSBpbiBwMSlcbiAgICAgICAgICAgICAgICBkID0gcDFbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBGcmFjdGlvblsnSW52YWxpZFBhcmFtZXRlciddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IG4gKiBkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHAxIDwgMCkge1xuICAgICAgICAgICAgICBzID0gcDE7XG4gICAgICAgICAgICAgIHAxID0gLXAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDEgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgIG4gPSBwMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEgPiAwKSB7IC8vIGNoZWNrIGZvciAhPSAwLCBzY2FsZSB3b3VsZCBiZWNvbWUgTmFOIChsb2coMCkpLCB3aGljaCBjb252ZXJnZXMgcmVhbGx5IHNsb3dcblxuICAgICAgICAgICAgICBpZiAocDEgPj0gMSkge1xuICAgICAgICAgICAgICAgIHogPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcigxICsgTWF0aC5sb2cocDEpIC8gTWF0aC5MTjEwKSk7XG4gICAgICAgICAgICAgICAgcDEvPSB6O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVXNpbmcgRmFyZXkgU2VxdWVuY2VzXG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuam9obmRjb29rLmNvbS9ibG9nLzIwMTAvMTAvMjAvYmVzdC1yYXRpb25hbC1hcHByb3hpbWF0aW9uL1xuXG4gICAgICAgICAgICAgIHdoaWxlIChCIDw9IE4gJiYgRCA8PSBOKSB7XG4gICAgICAgICAgICAgICAgTSA9IChBICsgQykgLyAoQiArIEQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHAxID09PSBNKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoQiArIEQgPD0gTikge1xuICAgICAgICAgICAgICAgICAgICBuID0gQSArIEM7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBCICsgRDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRCA+IEIpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IEM7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IEE7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICBpZiAocDEgPiBNKSB7XG4gICAgICAgICAgICAgICAgICAgIEErPSBDO1xuICAgICAgICAgICAgICAgICAgICBCKz0gRDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEMrPSBBO1xuICAgICAgICAgICAgICAgICAgICBEKz0gQjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKEIgPiBOKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBDO1xuICAgICAgICAgICAgICAgICAgICBkID0gRDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBBO1xuICAgICAgICAgICAgICAgICAgICBkID0gQjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbio9IHo7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHAxKSB8fCBpc05hTihwMikpIHtcbiAgICAgICAgICAgICAgZCA9IG4gPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBCID0gcDEubWF0Y2goL1xcZCt8Li9nKTtcblxuICAgICAgICAgICAgaWYgKEIgPT09IG51bGwpXG4gICAgICAgICAgICAgIHRocm93IEZyYWN0aW9uWydJbnZhbGlkUGFyYW1ldGVyJ107XG5cbiAgICAgICAgICAgIGlmIChCW0FdID09PSAnLScpIHsvLyBDaGVjayBmb3IgbWludXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgIHMgPSAtMTtcbiAgICAgICAgICAgICAgQSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChCW0FdID09PSAnKycpIHsvLyBDaGVjayBmb3IgcGx1cyBzaWduIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgQSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQi5sZW5ndGggPT09IEEgKyAxKSB7IC8vIENoZWNrIGlmIGl0J3MganVzdCBhIHNpbXBsZSBudW1iZXIgXCIxMjM0XCJcbiAgICAgICAgICAgICAgdyA9IGFzc2lnbihCW0ErK10sIHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChCW0EgKyAxXSA9PT0gJy4nIHx8IEJbQV0gPT09ICcuJykgeyAvLyBDaGVjayBpZiBpdCdzIGEgZGVjaW1hbCBudW1iZXJcblxuICAgICAgICAgICAgICBpZiAoQltBXSAhPT0gJy4nKSB7IC8vIEhhbmRsZSAwLjUgYW5kIC41XG4gICAgICAgICAgICAgICAgdiA9IGFzc2lnbihCW0ErK10sIHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEErKztcblxuICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgICAgaWYgKEEgKyAxID09PSBCLmxlbmd0aCB8fCBCW0EgKyAxXSA9PT0gJygnICYmIEJbQSArIDNdID09PSAnKScgfHwgQltBICsgMV0gPT09IFwiJ1wiICYmIEJbQSArIDNdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBXSwgcyk7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgucG93KDEwLCBCW0FdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgQSsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHJlcGVhdGluZyBwbGFjZXNcbiAgICAgICAgICAgICAgaWYgKEJbQV0gPT09ICcoJyAmJiBCW0EgKyAyXSA9PT0gJyknIHx8IEJbQV0gPT09IFwiJ1wiICYmIEJbQSArIDJdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHggPSBhc3NpZ24oQltBICsgMV0sIHMpO1xuICAgICAgICAgICAgICAgIHogPSBNYXRoLnBvdygxMCwgQltBICsgMV0ubGVuZ3RoKSAtIDE7XG4gICAgICAgICAgICAgICAgQSs9IDM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChCW0EgKyAxXSA9PT0gJy8nIHx8IEJbQSArIDFdID09PSAnOicpIHsgLy8gQ2hlY2sgZm9yIGEgc2ltcGxlIGZyYWN0aW9uIFwiMTIzLzQ1NlwiIG9yIFwiMTIzOjQ1NlwiXG4gICAgICAgICAgICAgIHcgPSBhc3NpZ24oQltBXSwgcyk7XG4gICAgICAgICAgICAgIHkgPSBhc3NpZ24oQltBICsgMl0sIDEpO1xuICAgICAgICAgICAgICBBKz0gMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQltBICsgM10gPT09ICcvJyAmJiBCW0EgKyAxXSA9PT0gJyAnKSB7IC8vIENoZWNrIGZvciBhIGNvbXBsZXggZnJhY3Rpb24gXCIxMjMgMS8yXCJcbiAgICAgICAgICAgICAgdiA9IGFzc2lnbihCW0FdLCBzKTtcbiAgICAgICAgICAgICAgdyA9IGFzc2lnbihCW0EgKyAyXSwgcyk7XG4gICAgICAgICAgICAgIHkgPSBhc3NpZ24oQltBICsgNF0sIDEpO1xuICAgICAgICAgICAgICBBKz0gNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEIubGVuZ3RoIDw9IEEpIHsgLy8gQ2hlY2sgZm9yIG1vcmUgdG9rZW5zIG9uIHRoZSBzdGFja1xuICAgICAgICAgICAgICBkID0geSAqIHo7XG4gICAgICAgICAgICAgIHMgPSAvKiB2b2lkICovXG4gICAgICAgICAgICAgIG4gPSB4ICsgZCAqIHYgKyB6ICogdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIEZhbGwgdGhyb3VnaCBvbiBlcnJvciAqL1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBGcmFjdGlvblsnSW52YWxpZFBhcmFtZXRlciddO1xuICAgICAgfVxuXG4gICAgaWYgKGQgPT09IDApIHtcbiAgICAgIHRocm93IEZyYWN0aW9uWydEaXZpc2lvbkJ5WmVybyddO1xuICAgIH1cblxuICAgIFBbXCJzXCJdID0gcyA8IDAgPyAtMSA6IDE7XG4gICAgUFtcIm5cIl0gPSBNYXRoLmFicyhuKTtcbiAgICBQW1wiZFwiXSA9IE1hdGguYWJzKGQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vZHBvdyhiLCBlLCBtKSB7XG5cbiAgICB2YXIgciA9IDE7XG4gICAgZm9yICg7IGUgPiAwOyBiID0gKGIgKiBiKSAlIG0sIGUgPj49IDEpIHtcblxuICAgICAgaWYgKGUgJiAxKSB7XG4gICAgICAgIHIgPSAociAqIGIpICUgbTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGN5Y2xlTGVuKG4sIGQpIHtcblxuICAgIGZvciAoOyBkICUgMiA9PT0gMDtcbiAgICAgIGQvPSAyKSB7XG4gICAgfVxuXG4gICAgZm9yICg7IGQgJSA1ID09PSAwO1xuICAgICAgZC89IDUpIHtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gMSkgLy8gQ2F0Y2ggbm9uLWN5Y2xpYyBudW1iZXJzXG4gICAgICByZXR1cm4gMDtcblxuICAgIC8vIElmIHdlIHdvdWxkIGxpa2UgdG8gY29tcHV0ZSByZWFsbHkgbGFyZ2UgbnVtYmVycyBxdWlja2VyLCB3ZSBjb3VsZCBtYWtlIHVzZSBvZiBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbTpcbiAgICAvLyAxMF4oZC0xKSAlIGQgPT0gMVxuICAgIC8vIEhvd2V2ZXIsIHdlIGRvbid0IG5lZWQgc3VjaCBsYXJnZSBudW1iZXJzIGFuZCBNQVhfQ1lDTEVfTEVOIHNob3VsZCBiZSB0aGUgY2Fwc3RvbmUsXG4gICAgLy8gYXMgd2Ugd2FudCB0byB0cmFuc2xhdGUgdGhlIG51bWJlcnMgdG8gc3RyaW5ncy5cblxuICAgIHZhciByZW0gPSAxMCAlIGQ7XG4gICAgdmFyIHQgPSAxO1xuXG4gICAgZm9yICg7IHJlbSAhPT0gMTsgdCsrKSB7XG4gICAgICByZW0gPSByZW0gKiAxMCAlIGQ7XG5cbiAgICAgIGlmICh0ID4gTUFYX0NZQ0xFX0xFTilcbiAgICAgICAgcmV0dXJuIDA7IC8vIFJldHVybmluZyAwIGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndCBwcmludCBpdCBhcyBhIGN5Y2xpYyBudW1iZXIuIEl0J3MgbGlrZWx5IHRoYXQgdGhlIGFuc3dlciBpcyBgZC0xYFxuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY3ljbGVTdGFydChuLCBkLCBsZW4pIHtcblxuICAgIHZhciByZW0xID0gMTtcbiAgICB2YXIgcmVtMiA9IG1vZHBvdygxMCwgbGVuLCBkKTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMzAwOyB0KyspIHsgLy8gcyA8IH5sb2cxMChOdW1iZXIuTUFYX1ZBTFVFKVxuICAgICAgLy8gU29sdmUgMTBecyA9PSAxMF4ocyt0KSAobW9kIGQpXG5cbiAgICAgIGlmIChyZW0xID09PSByZW0yKVxuICAgICAgICByZXR1cm4gdDtcblxuICAgICAgcmVtMSA9IHJlbTEgKiAxMCAlIGQ7XG4gICAgICByZW0yID0gcmVtMiAqIDEwICUgZDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBnY2QoYSwgYikge1xuXG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKCFiKVxuICAgICAgcmV0dXJuIGE7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgYSU9IGI7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHJldHVybiBiO1xuICAgICAgYiU9IGE7XG4gICAgICBpZiAoIWIpXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW9kdWxlIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge251bWJlcnxGcmFjdGlvbj19IGFcbiAgICogQHBhcmFtIHtudW1iZXI9fSBiXG4gICAqL1xuICBmdW5jdGlvbiBGcmFjdGlvbihhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRnJhY3Rpb24pIHtcbiAgICAgIGEgPSBnY2QoUFtcImRcIl0sIFBbXCJuXCJdKTsgLy8gQWJ1c2UgdmFyaWFibGUgYVxuICAgICAgdGhpc1tcInNcIl0gPSBQW1wic1wiXTtcbiAgICAgIHRoaXNbXCJuXCJdID0gUFtcIm5cIl0gLyBhO1xuICAgICAgdGhpc1tcImRcIl0gPSBQW1wiZFwiXSAvIGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihQWydzJ10gKiBQWyduJ10sIFBbJ2QnXSk7XG4gICAgfVxuICB9XG5cbiAgRnJhY3Rpb25bJ0RpdmlzaW9uQnlaZXJvJ10gPSBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSBaZXJvXCIpO1xuICBGcmFjdGlvblsnSW52YWxpZFBhcmFtZXRlciddID0gbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgRnJhY3Rpb25bJ05vbkludGVnZXJQYXJhbWV0ZXInXSA9IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgbXVzdCBiZSBpbnRlZ2VyXCIpO1xuXG4gIEZyYWN0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIFwic1wiOiAxLFxuICAgIFwiblwiOiAwLFxuICAgIFwiZFwiOiAxLFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oLTQpLmFicygpID0+IDRcbiAgICAgKiovXG4gICAgXCJhYnNcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzW1wiblwiXSwgdGhpc1tcImRcIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnRzIHRoZSBzaWduIG9mIHRoZSBjdXJyZW50IGZyYWN0aW9uXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKC00KS5uZWcoKSA9PiA0XG4gICAgICoqL1xuICAgIFwibmVnXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oLXRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0sIHRoaXNbXCJkXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbih7bjogMiwgZDogM30pLmFkZChcIjE0LjlcIikgPT4gNDY3IC8gMzBcbiAgICAgKiovXG4gICAgXCJhZGRcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgICAgdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdICsgUFtcInNcIl0gKiB0aGlzW1wiZFwiXSAqIFBbXCJuXCJdLFxuICAgICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IC00MjcgLyAzMFxuICAgICAqKi9cbiAgICBcInN1YlwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgICB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gLSBQW1wic1wiXSAqIHRoaXNbXCJkXCJdICogUFtcIm5cIl0sXG4gICAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikubXVsKDMpID0+IDU3NzYgLyAxMTFcbiAgICAgKiovXG4gICAgXCJtdWxcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcIm5cIl0sXG4gICAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikuaW52ZXJzZSgpLmRpdigzKVxuICAgICAqKi9cbiAgICBcImRpdlwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgICB0aGlzW1wic1wiXSAqIFBbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSxcbiAgICAgICAgdGhpc1tcImRcIl0gKiBQW1wiblwiXVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmNsb25lKClcbiAgICAgKiovXG4gICAgXCJjbG9uZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzWydzJ10gKiB0aGlzWyduJ10sIHRoaXNbJ2QnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsbyBvZiB0d28gcmF0aW9uYWwgbnVtYmVycyAtIGEgbW9yZSBwcmVjaXNlIGZtb2RcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykubW9kKFs3LCA4XSkgPT4gKDEzLzMpICUgKDcvOCkgPSAoNS82KVxuICAgICAqKi9cbiAgICBcIm1vZFwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIGlmIChpc05hTih0aGlzWyduJ10pIHx8IGlzTmFOKHRoaXNbJ2QnXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihOYU4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICUgdGhpc1tcImRcIl0sIDEpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIGlmICgwID09PSBQW1wiblwiXSAmJiAwID09PSB0aGlzW1wiZFwiXSkge1xuICAgICAgICB0aHJvdyBGcmFjdGlvblsnRGl2aXNpb25CeVplcm8nXTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqIEZpcnN0IHNpbGx5IGF0dGVtcHQsIGtpbmRhIHNsb3dcbiAgICAgICAqXG4gICAgICAgcmV0dXJuIHRoYXRbXCJzdWJcIl0oe1xuICAgICAgIFwiblwiOiBudW1bXCJuXCJdICogTWF0aC5mbG9vcigodGhpcy5uIC8gdGhpcy5kKSAvIChudW0ubiAvIG51bS5kKSksXG4gICAgICAgXCJkXCI6IG51bVtcImRcIl0sXG4gICAgICAgXCJzXCI6IHRoaXNbXCJzXCJdXG4gICAgICAgfSk7Ki9cblxuICAgICAgLypcbiAgICAgICAqIE5ldyBhdHRlbXB0OiBhMSAvIGIxID0gYTIgLyBiMiAqIHEgKyByXG4gICAgICAgKiA9PiBiMiAqIGExID0gYTIgKiBiMSAqIHEgKyBiMSAqIGIyICogclxuICAgICAgICogPT4gKGIyICogYTEgJSBhMiAqIGIxKSAvIChiMSAqIGIyKVxuICAgICAgICovXG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICAgIHRoaXNbXCJzXCJdICogKFBbXCJkXCJdICogdGhpc1tcIm5cIl0pICUgKFBbXCJuXCJdICogdGhpc1tcImRcIl0pLFxuICAgICAgICBQW1wiZFwiXSAqIHRoaXNbXCJkXCJdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmcmFjdGlvbmFsIGdjZCBvZiB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbig1LDgpLmdjZCgzLDcpID0+IDEvNTZcbiAgICAgKi9cbiAgICBcImdjZFwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgICAvLyBnY2QoYSAvIGIsIGMgLyBkKSA9IGdjZChhLCBjKSAvIGxjbShiLCBkKVxuXG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oZ2NkKFBbXCJuXCJdLCB0aGlzW1wiblwiXSkgKiBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSwgUFtcImRcIl0gKiB0aGlzW1wiZFwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uYWwgbGNtIG9mIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKDUsOCkubGNtKDMsNykgPT4gMTVcbiAgICAgKi9cbiAgICBcImxjbVwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgICAvLyBsY20oYSAvIGIsIGMgLyBkKSA9IGxjbShhLCBjKSAvIGdjZChiLCBkKVxuXG4gICAgICBpZiAoUFtcIm5cIl0gPT09IDAgJiYgdGhpc1tcIm5cIl0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKDAsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFBbXCJuXCJdICogdGhpc1tcIm5cIl0sIGdjZChQW1wiblwiXSwgdGhpc1tcIm5cIl0pICogZ2NkKFBbXCJkXCJdLCB0aGlzW1wiZFwiXSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBjZWlsIG9mIGEgcmF0aW9uYWwgbnVtYmVyXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKCc0LigzKScpLmNlaWwoKSA9PiAoNSAvIDEpXG4gICAgICoqL1xuICAgIFwiY2VpbFwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgaWYgKGlzTmFOKHRoaXNbXCJuXCJdKSB8fCBpc05hTih0aGlzW1wiZFwiXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihOYU4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKE1hdGguY2VpbChwbGFjZXMgKiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pLCBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmbG9vciBvZiBhIHJhdGlvbmFsIG51bWJlclxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5mbG9vcigpID0+ICg0IC8gMSlcbiAgICAgKiovXG4gICAgXCJmbG9vclwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgaWYgKGlzTmFOKHRoaXNbXCJuXCJdKSB8fCBpc05hTih0aGlzW1wiZFwiXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihOYU4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKE1hdGguZmxvb3IocGxhY2VzICogdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdKSwgcGxhY2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIGEgcmF0aW9uYWwgbnVtYmVyc1xuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5yb3VuZCgpID0+ICg0IC8gMSlcbiAgICAgKiovXG4gICAgXCJyb3VuZFwiOiBmdW5jdGlvbihwbGFjZXMpIHtcblxuICAgICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgICAgaWYgKGlzTmFOKHRoaXNbXCJuXCJdKSB8fCBpc05hTih0aGlzW1wiZFwiXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihOYU4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKE1hdGgucm91bmQocGxhY2VzICogdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdKSwgcGxhY2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW52ZXJzZSBvZiB0aGUgZnJhY3Rpb24sIG1lYW5zIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IgYXJlIGV4Y2hhbmdlZFxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbihbLTMsIDRdKS5pbnZlcnNlKCkgPT4gLTQgLyAzXG4gICAgICoqL1xuICAgIFwiaW52ZXJzZVwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbXCJzXCJdICogdGhpc1tcImRcIl0sIHRoaXNbXCJuXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb24gdG8gc29tZSByYXRpb25hbCBleHBvbmVudCwgaWYgcG9zc2libGVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oLTEsMikucG93KC0zKSA9PiAtOFxuICAgICAqL1xuICAgIFwicG93XCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7XG5cbiAgICAgIC8vIFRyaXZpYWwgY2FzZSB3aGVuIGV4cCBpcyBhbiBpbnRlZ2VyXG5cbiAgICAgIGlmIChQWydkJ10gPT09IDEpIHtcblxuICAgICAgICBpZiAoUFsncyddIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuZXdGcmFjdGlvbihNYXRoLnBvdyh0aGlzWydzJ10gKiB0aGlzW1wiZFwiXSwgUFsnbiddKSwgTWF0aC5wb3codGhpc1tcIm5cIl0sIFBbJ24nXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXdGcmFjdGlvbihNYXRoLnBvdyh0aGlzWydzJ10gKiB0aGlzW1wiblwiXSwgUFsnbiddKSwgTWF0aC5wb3codGhpc1tcImRcIl0sIFBbJ24nXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZ2F0aXZlIHJvb3RzIGJlY29tZSBjb21wbGV4XG4gICAgICAvLyAgICAgKC1hL2IpXihjL2QpID0geFxuICAgICAgLy8gPD0+ICgtMSleKGMvZCkgKiAoYS9iKV4oYy9kKSA9IHhcbiAgICAgIC8vIDw9PiAoY29zKHBpKSArIGkqc2luKHBpKSleKGMvZCkgKiAoYS9iKV4oYy9kKSA9IHggICAgICAgICAjIHJvdGF0ZSAxIGJ5IDE4MMKwXG4gICAgICAvLyA8PT4gKGNvcyhjKnBpL2QpICsgaSpzaW4oYypwaS9kKSkgKiAoYS9iKV4oYy9kKSA9IHggICAgICAgIyBEZU1vaXZyZSdzIGZvcm11bGEgaW4gUSAoIGh0dHBzOi8vcHJvb2Z3aWtpLm9yZy93aWtpL0RlX01vaXZyZSUyN3NfRm9ybXVsYS9SYXRpb25hbF9JbmRleCApXG4gICAgICAvLyBGcm9tIHdoaWNoIGZvbGxvd3MgdGhhdCBvbmx5IGZvciBjPTAgdGhlIHJvb3QgaXMgbm9uLWNvbXBsZXguIGMvZCBpcyBhIHJlZHVjZWQgZnJhY3Rpb24sIHNvIHRoYXQgc2luKGMvZHBpKT0wIG9jY3VycyBmb3IgZD0xLCB3aGljaCBpcyBoYW5kbGVkIGJ5IG91ciB0cml2aWFsIGNhc2UuXG4gICAgICBpZiAodGhpc1sncyddIDwgMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIE5vdyBwcmltZSBmYWN0b3IgbiBhbmQgZFxuICAgICAgdmFyIE4gPSBmYWN0b3JpemUodGhpc1snbiddKTtcbiAgICAgIHZhciBEID0gZmFjdG9yaXplKHRoaXNbJ2QnXSk7XG5cbiAgICAgIC8vIEV4cG9uZW50aWF0ZSBhbmQgdGFrZSByb290IGZvciBuIGFuZCBkIGluZGl2aWR1YWxseVxuICAgICAgdmFyIG4gPSAxO1xuICAgICAgdmFyIGQgPSAxO1xuICAgICAgZm9yICh2YXIgayBpbiBOKSB7XG4gICAgICAgIGlmIChrID09PSAnMScpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoayA9PT0gJzAnKSB7XG4gICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgTltrXSo9IFBbJ24nXTtcblxuICAgICAgICBpZiAoTltrXSAlIFBbJ2QnXSA9PT0gMCkge1xuICAgICAgICAgIE5ba10vPSBQWydkJ107XG4gICAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgbio9IE1hdGgucG93KGssIE5ba10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrIGluIEQpIHtcbiAgICAgICAgaWYgKGsgPT09ICcxJykgY29udGludWU7XG4gICAgICAgIERba10qPSBQWyduJ107XG5cbiAgICAgICAgaWYgKERba10gJSBQWydkJ10gPT09IDApIHtcbiAgICAgICAgICBEW2tdLz0gUFsnZCddO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgIGQqPSBNYXRoLnBvdyhrLCBEW2tdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBbJ3MnXSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGQsIG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKG4sIGQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZXF1YWxzKFs5OCwgNV0pO1xuICAgICAqKi9cbiAgICBcImVxdWFsc1wiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpO1xuICAgICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA9PT0gUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdOyAvLyBTYW1lIGFzIGNvbXBhcmUoKSA9PT0gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZXF1YWxzKFs5OCwgNV0pO1xuICAgICAqKi9cbiAgICBcImNvbXBhcmVcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHZhciB0ID0gKHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSk7XG4gICAgICByZXR1cm4gKDAgPCB0KSAtICh0IDwgMCk7XG4gICAgfSxcblxuICAgIFwic2ltcGxpZnlcIjogZnVuY3Rpb24oZXBzKSB7XG5cbiAgICAgIGlmIChpc05hTih0aGlzWyduJ10pIHx8IGlzTmFOKHRoaXNbJ2QnXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGVwcyA9IGVwcyB8fCAwLjAwMTtcblxuICAgICAgdmFyIHRoaXNBQlMgPSB0aGlzWydhYnMnXSgpO1xuICAgICAgdmFyIGNvbnQgPSB0aGlzQUJTWyd0b0NvbnRpbnVlZCddKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29udC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBzID0gbmV3RnJhY3Rpb24oY29udFtpIC0gMV0sIDEpO1xuICAgICAgICBmb3IgKHZhciBrID0gaSAtIDI7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcyA9IHNbJ2ludmVyc2UnXSgpWydhZGQnXShjb250W2tdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzWydzdWInXSh0aGlzQUJTKVsnYWJzJ10oKS52YWx1ZU9mKCkgPCBlcHMpIHtcbiAgICAgICAgICByZXR1cm4gc1snbXVsJ10odGhpc1sncyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byByYXRpb25hbCBudW1iZXJzIGFyZSBkaXZpc2libGVcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZGl2aXNpYmxlKDEuNSk7XG4gICAgICovXG4gICAgXCJkaXZpc2libGVcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTtcbiAgICAgIHJldHVybiAhKCEoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkgfHwgKCh0aGlzW1wiblwiXSAqIFBbXCJkXCJdKSAlIChQW1wiblwiXSAqIHRoaXNbXCJkXCJdKSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnJhY3Rpb25cbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxMDAuJzkxODIzJ1wiKS52YWx1ZU9mKCkgPT4gMTAwLjkxODIzOTE4MjM5MTgzXG4gICAgICoqL1xuICAgICd2YWx1ZU9mJzogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmctZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgYSBGcmFjdGlvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxLiczJ1wiKS50b0ZyYWN0aW9uKHRydWUpID0+IFwiNCAxLzNcIlxuICAgICAqKi9cbiAgICAndG9GcmFjdGlvbic6IGZ1bmN0aW9uKGV4Y2x1ZGVXaG9sZSkge1xuXG4gICAgICB2YXIgd2hvbGUsIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgbiA9IHRoaXNbXCJuXCJdO1xuICAgICAgdmFyIGQgPSB0aGlzW1wiZFwiXTtcbiAgICAgIGlmICh0aGlzW1wic1wiXSA8IDApIHtcbiAgICAgICAgc3RyKz0gJy0nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCA9PT0gMSkge1xuICAgICAgICBzdHIrPSBuO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoZXhjbHVkZVdob2xlICYmICh3aG9sZSA9IE1hdGguZmxvb3IobiAvIGQpKSA+IDApIHtcbiAgICAgICAgICBzdHIrPSB3aG9sZTtcbiAgICAgICAgICBzdHIrPSBcIiBcIjtcbiAgICAgICAgICBuJT0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cis9IG47XG4gICAgICAgIHN0cis9ICcvJztcbiAgICAgICAgc3RyKz0gZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsYXRleCByZXByZXNlbnRhdGlvbiBvZiBhIEZyYWN0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEuJzMnXCIpLnRvTGF0ZXgoKSA9PiBcIlxcZnJhY3s0fXszfVwiXG4gICAgICoqL1xuICAgICd0b0xhdGV4JzogZnVuY3Rpb24oZXhjbHVkZVdob2xlKSB7XG5cbiAgICAgIHZhciB3aG9sZSwgc3RyID0gXCJcIjtcbiAgICAgIHZhciBuID0gdGhpc1tcIm5cIl07XG4gICAgICB2YXIgZCA9IHRoaXNbXCJkXCJdO1xuICAgICAgaWYgKHRoaXNbXCJzXCJdIDwgMCkge1xuICAgICAgICBzdHIrPSAnLSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkID09PSAxKSB7XG4gICAgICAgIHN0cis9IG47XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChleGNsdWRlV2hvbGUgJiYgKHdob2xlID0gTWF0aC5mbG9vcihuIC8gZCkpID4gMCkge1xuICAgICAgICAgIHN0cis9IHdob2xlO1xuICAgICAgICAgIG4lPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyKz0gXCJcXFxcZnJhY3tcIjtcbiAgICAgICAgc3RyKz0gbjtcbiAgICAgICAgc3RyKz0gJ317JztcbiAgICAgICAgc3RyKz0gZDtcbiAgICAgICAgc3RyKz0gJ30nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjb250aW51ZWQgZnJhY3Rpb24gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEV4OiBuZXcgRnJhY3Rpb24oXCI3LzhcIikudG9Db250aW51ZWQoKSA9PiBbMCwxLDddXG4gICAgICovXG4gICAgJ3RvQ29udGludWVkJzogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0O1xuICAgICAgdmFyIGEgPSB0aGlzWyduJ107XG4gICAgICB2YXIgYiA9IHRoaXNbJ2QnXTtcbiAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGIpKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgcmVzLnB1c2goTWF0aC5mbG9vcihhIC8gYikpO1xuICAgICAgICB0ID0gYSAlIGI7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gd2hpbGUgKGEgIT09IDEpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZnJhY3Rpb24gd2l0aCBhbGwgZGlnaXRzXG4gICAgICpcbiAgICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMTAwLic5MTgyMydcIikudG9TdHJpbmcoKSA9PiBcIjEwMC4oOTE4MjMpXCJcbiAgICAgKiovXG4gICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oZGVjKSB7XG5cbiAgICAgIHZhciBOID0gdGhpc1tcIm5cIl07XG4gICAgICB2YXIgRCA9IHRoaXNbXCJkXCJdO1xuXG4gICAgICBpZiAoaXNOYU4oTikgfHwgaXNOYU4oRCkpIHtcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICB9XG5cbiAgICAgIGRlYyA9IGRlYyB8fCAxNTsgLy8gMTUgPSBkZWNpbWFsIHBsYWNlcyB3aGVuIG5vIHJlcGV0YXRpb25cblxuICAgICAgdmFyIGN5Y0xlbiA9IGN5Y2xlTGVuKE4sIEQpOyAvLyBDeWNsZSBsZW5ndGhcbiAgICAgIHZhciBjeWNPZmYgPSBjeWNsZVN0YXJ0KE4sIEQsIGN5Y0xlbik7IC8vIEN5Y2xlIHN0YXJ0XG5cbiAgICAgIHZhciBzdHIgPSB0aGlzWydzJ10gPCAwID8gXCItXCIgOiBcIlwiO1xuXG4gICAgICBzdHIrPSBOIC8gRCB8IDA7XG5cbiAgICAgIE4lPSBEO1xuICAgICAgTio9IDEwO1xuXG4gICAgICBpZiAoTilcbiAgICAgICAgc3RyKz0gXCIuXCI7XG5cbiAgICAgIGlmIChjeWNMZW4pIHtcblxuICAgICAgICBmb3IgKHZhciBpID0gY3ljT2ZmOyBpLS07KSB7XG4gICAgICAgICAgc3RyKz0gTiAvIEQgfCAwO1xuICAgICAgICAgIE4lPSBEO1xuICAgICAgICAgIE4qPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBzdHIrPSBcIihcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IGN5Y0xlbjsgaS0tOykge1xuICAgICAgICAgIHN0cis9IE4gLyBEIHwgMDtcbiAgICAgICAgICBOJT0gRDtcbiAgICAgICAgICBOKj0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyKz0gXCIpXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gZGVjOyBOICYmIGktLTspIHtcbiAgICAgICAgICBzdHIrPSBOIC8gRCB8IDA7XG4gICAgICAgICAgTiU9IEQ7XG4gICAgICAgICAgTio9IDEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZVtcImFtZFwiXSkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRnJhY3Rpb247XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhY3Rpb24sIFwiX19lc01vZHVsZVwiLCB7ICd2YWx1ZSc6IHRydWUgfSk7XG4gICAgRnJhY3Rpb25bJ2RlZmF1bHQnXSA9IEZyYWN0aW9uO1xuICAgIEZyYWN0aW9uWydGcmFjdGlvbiddID0gRnJhY3Rpb247XG4gICAgbW9kdWxlWydleHBvcnRzJ10gPSBGcmFjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICByb290WydGcmFjdGlvbiddID0gRnJhY3Rpb247XG4gIH1cblxufSkodGhpcyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidhYnMnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQgPyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiBpc1dvcmtsZXQgPyAnTWF0aC5hYnMnIDogTWF0aC5hYnMgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfWFicyggJHtpbnB1dHNbMF19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5hYnMoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBhYnMgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgYWJzLmlucHV0cyA9IFsgeCBdXG5cbiAgcmV0dXJuIGFic1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidhY2N1bScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBjb2RlLFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIGdlbk5hbWUgPSAnZ2VuLicgKyB0aGlzLm5hbWUsXG4gICAgICAgIGZ1bmN0aW9uQm9keVxuXG4gICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcblxuICAgIGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF0gPSB0aGlzLmluaXRpYWxWYWx1ZVxuXG4gICAgZnVuY3Rpb25Cb2R5ID0gdGhpcy5jYWxsYmFjayggZ2VuTmFtZSwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIGBtZW1vcnlbJHt0aGlzLm1lbW9yeS52YWx1ZS5pZHh9XWAgKVxuXG4gICAgLy9nZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogdGhpcyB9KSBcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZSArICdfdmFsdWUnXG4gICAgXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lICsgJ192YWx1ZScsIGZ1bmN0aW9uQm9keSBdXG4gIH0sXG5cbiAgY2FsbGJhY2soIF9uYW1lLCBfaW5jciwgX3Jlc2V0LCB2YWx1ZVJlZiApIHtcbiAgICBsZXQgZGlmZiA9IHRoaXMubWF4IC0gdGhpcy5taW4sXG4gICAgICAgIG91dCA9ICcnLFxuICAgICAgICB3cmFwID0gJydcbiAgICBcbiAgICAvKiB0aHJlZSBkaWZmZXJlbnQgbWV0aG9kcyBvZiB3cmFwcGluZywgdGhpcmQgaXMgbW9zdCBleHBlbnNpdmU6XG4gICAgICpcbiAgICAgKiAxOiByYW5nZSB7MCwxfTogeSA9IHggLSAoeCB8IDApXG4gICAgICogMjogbG9nMih0aGlzLm1heCkgPT0gaW50ZWdlcjogeSA9IHggJiAodGhpcy5tYXggLSAxKVxuICAgICAqIDM6IGFsbCBvdGhlcnM6IGlmKCB4ID49IHRoaXMubWF4ICkgeSA9IHRoaXMubWF4IC14XG4gICAgICpcbiAgICAgKi9cblxuICAgIC8vIG11c3QgY2hlY2sgZm9yIHJlc2V0IGJlZm9yZSBzdG9yaW5nIHZhbHVlIGZvciBvdXRwdXRcbiAgICBpZiggISh0eXBlb2YgdGhpcy5pbnB1dHNbMV0gPT09ICdudW1iZXInICYmIHRoaXMuaW5wdXRzWzFdIDwgMSkgKSB7IFxuICAgICAgaWYoIHRoaXMucmVzZXRWYWx1ZSAhPT0gdGhpcy5taW4gKSB7XG5cbiAgICAgICAgb3V0ICs9IGAgIGlmKCAke19yZXNldH0gPj0xICkgJHt2YWx1ZVJlZn0gPSAke3RoaXMucmVzZXRWYWx1ZX1cXG5cXG5gXG4gICAgICAgIC8vb3V0ICs9IGAgIGlmKCAke19yZXNldH0gPj0xICkgJHt2YWx1ZVJlZn0gPSAke3RoaXMubWlufVxcblxcbmBcbiAgICAgIH1lbHNle1xuICAgICAgICBvdXQgKz0gYCAgaWYoICR7X3Jlc2V0fSA+PTEgKSAke3ZhbHVlUmVmfSA9ICR7dGhpcy5taW59XFxuXFxuYFxuICAgICAgICAvL291dCArPSBgICBpZiggJHtfcmVzZXR9ID49MSApICR7dmFsdWVSZWZ9ID0gJHt0aGlzLmluaXRpYWxWYWx1ZX1cXG5cXG5gXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0ICs9IGAgIHZhciAke3RoaXMubmFtZX1fdmFsdWUgPSAke3ZhbHVlUmVmfVxcbmBcbiAgICBcbiAgICBpZiggdGhpcy5zaG91bGRXcmFwID09PSBmYWxzZSAmJiB0aGlzLnNob3VsZENsYW1wID09PSB0cnVlICkge1xuICAgICAgb3V0ICs9IGAgIGlmKCAke3ZhbHVlUmVmfSA8ICR7dGhpcy5tYXggfSApICR7dmFsdWVSZWZ9ICs9ICR7X2luY3J9XFxuYFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IGAgICR7dmFsdWVSZWZ9ICs9ICR7X2luY3J9XFxuYCAvLyBzdG9yZSBvdXRwdXQgdmFsdWUgYmVmb3JlIGFjY3VtdWxhdGluZyAgXG4gICAgfVxuXG4gICAgaWYoIHRoaXMubWF4ICE9PSBJbmZpbml0eSAgJiYgdGhpcy5zaG91bGRXcmFwTWF4ICkgd3JhcCArPSBgICBpZiggJHt2YWx1ZVJlZn0gPj0gJHt0aGlzLm1heH0gKSAke3ZhbHVlUmVmfSAtPSAke2RpZmZ9XFxuYFxuICAgIGlmKCB0aGlzLm1pbiAhPT0gLUluZmluaXR5ICYmIHRoaXMuc2hvdWxkV3JhcE1pbiApIHdyYXAgKz0gYCAgaWYoICR7dmFsdWVSZWZ9IDwgJHt0aGlzLm1pbn0gKSAke3ZhbHVlUmVmfSArPSAke2RpZmZ9XFxuYFxuXG4gICAgLy9pZiggdGhpcy5taW4gPT09IDAgJiYgdGhpcy5tYXggPT09IDEgKSB7IFxuICAgIC8vICB3cmFwID0gIGAgICR7dmFsdWVSZWZ9ID0gJHt2YWx1ZVJlZn0gLSAoJHt2YWx1ZVJlZn0gfCAwKVxcblxcbmBcbiAgICAvL30gZWxzZSBpZiggdGhpcy5taW4gPT09IDAgJiYgKCBNYXRoLmxvZzIoIHRoaXMubWF4ICkgfCAwICkgPT09IE1hdGgubG9nMiggdGhpcy5tYXggKSApIHtcbiAgICAvLyAgd3JhcCA9ICBgICAke3ZhbHVlUmVmfSA9ICR7dmFsdWVSZWZ9ICYgKCR7dGhpcy5tYXh9IC0gMSlcXG5cXG5gXG4gICAgLy99IGVsc2UgaWYoIHRoaXMubWF4ICE9PSBJbmZpbml0eSApe1xuICAgIC8vICB3cmFwID0gYCAgaWYoICR7dmFsdWVSZWZ9ID49ICR7dGhpcy5tYXh9ICkgJHt2YWx1ZVJlZn0gLT0gJHtkaWZmfVxcblxcbmBcbiAgICAvL31cblxuICAgIG91dCA9IG91dCArIHdyYXAgKyAnXFxuJ1xuXG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG4gIGRlZmF1bHRzIDogeyBtaW46MCwgbWF4OjEsIHJlc2V0VmFsdWU6MCwgaW5pdGlhbFZhbHVlOjAsIHNob3VsZFdyYXA6dHJ1ZSwgc2hvdWxkV3JhcE1heDogdHJ1ZSwgc2hvdWxkV3JhcE1pbjp0cnVlLCBzaG91bGRDbGFtcDpmYWxzZSB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbmNyLCByZXNldD0wLCBwcm9wZXJ0aWVzICkgPT4ge1xuICBjb25zdCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICAgICAgXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIFxuICAgIHsgXG4gICAgICB1aWQ6ICAgIGdlbi5nZXRVSUQoKSxcbiAgICAgIGlucHV0czogWyBpbmNyLCByZXNldCBdLFxuICAgICAgbWVtb3J5OiB7XG4gICAgICAgIHZhbHVlOiB7IGxlbmd0aDoxLCBpZHg6bnVsbCB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm90by5kZWZhdWx0cyxcbiAgICBwcm9wZXJ0aWVzIFxuICApXG5cbiAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLnNob3VsZFdyYXBNYXggPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLnNob3VsZFdyYXBNaW4gPT09IHVuZGVmaW5lZCApIHtcbiAgICBpZiggcHJvcGVydGllcy5zaG91bGRXcmFwICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICB1Z2VuLnNob3VsZFdyYXBNaW4gPSB1Z2VuLnNob3VsZFdyYXBNYXggPSBwcm9wZXJ0aWVzLnNob3VsZFdyYXBcbiAgICB9XG4gIH1cblxuICBpZiggcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMucmVzZXRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHVnZW4ucmVzZXRWYWx1ZSA9IHVnZW4ubWluXG4gIH1cblxuICBpZiggdWdlbi5pbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCApIHVnZW4uaW5pdGlhbFZhbHVlID0gdWdlbi5taW5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sICd2YWx1ZScsIHtcbiAgICBnZXQoKSAgeyBcbiAgICAgIC8vY29uc29sZS5sb2coICdnZW46JywgZ2VuLCBnZW4ubWVtb3J5IClcbiAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdIFxuICAgIH0sXG4gICAgc2V0KHYpIHsgZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLm1lbW9yeS52YWx1ZS5pZHggXSA9IHYgfVxuICB9KVxuXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonYWNvcycsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldCA/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdhY29zJzogaXNXb3JrbGV0ID8gJ01hdGguYWNvcycgOk1hdGguYWNvcyB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9YWNvcyggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguYWNvcyggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IGFjb3MgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgYWNvcy5pbnB1dHMgPSBbIHggXVxuICBhY29zLmlkID0gZ2VuLmdldFVJRCgpXG4gIGFjb3MubmFtZSA9IGAke2Fjb3MuYmFzZW5hbWV9e2Fjb3MuaWR9YFxuXG4gIHJldHVybiBhY29zXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIG11bCAgICAgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIHN1YiAgICAgID0gcmVxdWlyZSggJy4vc3ViLmpzJyApLFxuICAgIGRpdiAgICAgID0gcmVxdWlyZSggJy4vZGl2LmpzJyApLFxuICAgIGRhdGEgICAgID0gcmVxdWlyZSggJy4vZGF0YS5qcycgKSxcbiAgICBwZWVrICAgICA9IHJlcXVpcmUoICcuL3BlZWsuanMnICksXG4gICAgYWNjdW0gICAgPSByZXF1aXJlKCAnLi9hY2N1bS5qcycgKSxcbiAgICBpZmVsc2UgICA9IHJlcXVpcmUoICcuL2lmZWxzZWlmLmpzJyApLFxuICAgIGx0ICAgICAgID0gcmVxdWlyZSggJy4vbHQuanMnICksXG4gICAgYmFuZyAgICAgPSByZXF1aXJlKCAnLi9iYW5nLmpzJyApLFxuICAgIGVudiAgICAgID0gcmVxdWlyZSggJy4vZW52LmpzJyApLFxuICAgIGFkZCAgICAgID0gcmVxdWlyZSggJy4vYWRkLmpzJyApLFxuICAgIHBva2UgICAgID0gcmVxdWlyZSggJy4vcG9rZS5qcycgKSxcbiAgICBuZXEgICAgICA9IHJlcXVpcmUoICcuL25lcS5qcycgKSxcbiAgICBhbmQgICAgICA9IHJlcXVpcmUoICcuL2FuZC5qcycgKSxcbiAgICBndGUgICAgICA9IHJlcXVpcmUoICcuL2d0ZS5qcycgKSxcbiAgICBtZW1vICAgICA9IHJlcXVpcmUoICcuL21lbW8uanMnICksXG4gICAgdXRpbGl0aWVzPSByZXF1aXJlKCAnLi91dGlsaXRpZXMuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGF0dGFja1RpbWUgPSA0NDEwMCwgZGVjYXlUaW1lID0gNDQxMDAsIF9wcm9wcyApID0+IHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IHNoYXBlOidleHBvbmVudGlhbCcsIGFscGhhOjUsIHRyaWdnZXI6bnVsbCB9LCBfcHJvcHMgKVxuICBjb25zdCBfYmFuZyA9IHByb3BzLnRyaWdnZXIgIT09IG51bGwgPyBwcm9wcy50cmlnZ2VyIDogYmFuZygpLFxuICAgICAgICBwaGFzZSA9IGFjY3VtKCAxLCBfYmFuZywgeyBtaW46MCwgbWF4OiBJbmZpbml0eSwgaW5pdGlhbFZhbHVlOi1JbmZpbml0eSwgc2hvdWxkV3JhcDpmYWxzZSB9KVxuICAgICAgXG4gIGxldCBidWZmZXJEYXRhLCBidWZmZXJEYXRhUmV2ZXJzZSwgZGVjYXlEYXRhLCBvdXQsIGJ1ZmZlclxuXG4gIC8vY29uc29sZS5sb2coICdzaGFwZTonLCBwcm9wcy5zaGFwZSwgJ2F0dGFjayB0aW1lOicsIGF0dGFja1RpbWUsICdkZWNheSB0aW1lOicsIGRlY2F5VGltZSApXG4gIGxldCBjb21wbGV0ZUZsYWcgPSBkYXRhKCBbMF0gKVxuICBcbiAgLy8gc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdG8gdXNlIGV4aXN0aW5nIHBoYXNlIGFjY3VtdWxhdG9yIGZvciBsaW5lYXIgZW52ZWxvcGVzXG4gIGlmKCBwcm9wcy5zaGFwZSA9PT0gJ2xpbmVhcicgKSB7XG4gICAgb3V0ID0gaWZlbHNlKCBcbiAgICAgIGFuZCggZ3RlKCBwaGFzZSwgMCksIGx0KCBwaGFzZSwgYXR0YWNrVGltZSApKSxcbiAgICAgIGRpdiggcGhhc2UsIGF0dGFja1RpbWUgKSxcblxuICAgICAgYW5kKCBndGUoIHBoYXNlLCAwKSwgIGx0KCBwaGFzZSwgYWRkKCBhdHRhY2tUaW1lLCBkZWNheVRpbWUgKSApICksXG4gICAgICBzdWIoIDEsIGRpdiggc3ViKCBwaGFzZSwgYXR0YWNrVGltZSApLCBkZWNheVRpbWUgKSApLFxuICAgICAgXG4gICAgICBuZXEoIHBoYXNlLCAtSW5maW5pdHkpLFxuICAgICAgcG9rZSggY29tcGxldGVGbGFnLCAxLCAwLCB7IGlubGluZTowIH0pLFxuXG4gICAgICAwIFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJEYXRhID0gZW52KHsgbGVuZ3RoOjEwMjQsIHR5cGU6cHJvcHMuc2hhcGUsIGFscGhhOnByb3BzLmFscGhhIH0pXG4gICAgYnVmZmVyRGF0YVJldmVyc2UgPSBlbnYoeyBsZW5ndGg6MTAyNCwgdHlwZTpwcm9wcy5zaGFwZSwgYWxwaGE6cHJvcHMuYWxwaGEsIHJldmVyc2U6dHJ1ZSB9KVxuXG4gICAgb3V0ID0gaWZlbHNlKCBcbiAgICAgIGFuZCggZ3RlKCBwaGFzZSwgMCksIGx0KCBwaGFzZSwgYXR0YWNrVGltZSApICksIFxuICAgICAgcGVlayggYnVmZmVyRGF0YSwgZGl2KCBwaGFzZSwgYXR0YWNrVGltZSApLCB7IGJvdW5kbW9kZTonY2xhbXAnIH0gKSwgXG5cbiAgICAgIGFuZCggZ3RlKHBoYXNlLDApLCBsdCggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lICkgKSApLCBcbiAgICAgIHBlZWsoIGJ1ZmZlckRhdGFSZXZlcnNlLCBkaXYoIHN1YiggcGhhc2UsIGF0dGFja1RpbWUgKSwgZGVjYXlUaW1lICksIHsgYm91bmRtb2RlOidjbGFtcCcgfSksXG5cbiAgICAgIG5lcSggcGhhc2UsIC1JbmZpbml0eSApLFxuICAgICAgcG9rZSggY29tcGxldGVGbGFnLCAxLCAwLCB7IGlubGluZTowIH0pLFxuXG4gICAgICAwXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdXNpbmdXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICBpZiggdXNpbmdXb3JrbGV0ID09PSB0cnVlICkge1xuICAgIG91dC5ub2RlID0gbnVsbFxuICAgIHV0aWxpdGllcy5yZWdpc3Rlciggb3V0IClcbiAgfVxuXG4gIC8vIG5lZWRlZCBmb3IgZ2liYmVyaXNoLi4uIGdldHRpbmcgdGhpcyB0byB3b3JrIHJpZ2h0IHdpdGggd29ya2xldHNcbiAgLy8gdmlhIHByb21pc2VzIHdpbGwgcHJvYmFibHkgYmUgdHJpY2t5XG4gIG91dC5pc0NvbXBsZXRlID0gKCk9PiB7XG4gICAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSAmJiBvdXQubm9kZSAhPT0gbnVsbCApIHtcbiAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICAgIG91dC5ub2RlLmdldE1lbW9yeVZhbHVlKCBjb21wbGV0ZUZsYWcubWVtb3J5LnZhbHVlcy5pZHgsIHJlc29sdmUgKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHBcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIGNvbXBsZXRlRmxhZy5tZW1vcnkudmFsdWVzLmlkeCBdXG4gICAgfVxuICB9XG5cbiAgb3V0LnRyaWdnZXIgPSAoKT0+IHtcbiAgICBpZiggdXNpbmdXb3JrbGV0ID09PSB0cnVlICYmIG91dC5ub2RlICE9PSBudWxsICkge1xuICAgICAgb3V0Lm5vZGUucG9ydC5wb3N0TWVzc2FnZSh7IGtleTonc2V0JywgaWR4OmNvbXBsZXRlRmxhZy5tZW1vcnkudmFsdWVzLmlkeCwgdmFsdWU6MCB9KVxuICAgIH1lbHNle1xuICAgICAgZ2VuLm1lbW9yeS5oZWFwWyBjb21wbGV0ZUZsYWcubWVtb3J5LnZhbHVlcy5pZHggXSA9IDBcbiAgICB9XG4gICAgX2JhbmcudHJpZ2dlcigpXG4gIH1cblxuICByZXR1cm4gb3V0IFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxuY29uc3QgcHJvdG8gPSB7IFxuICBiYXNlbmFtZTonYWRkJyxcbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIG91dD0nJyxcbiAgICAgICAgc3VtID0gMCwgbnVtQ291bnQgPSAwLCBhZGRlckF0RW5kID0gZmFsc2UsIGFscmVhZHlGdWxsU3VtbWVkID0gdHJ1ZVxuXG4gICAgaWYoIGlucHV0cy5sZW5ndGggPT09IDAgKSByZXR1cm4gMFxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGBcblxuICAgIGlucHV0cy5mb3JFYWNoKCAodixpKSA9PiB7XG4gICAgICBpZiggaXNOYU4oIHYgKSApIHtcbiAgICAgICAgb3V0ICs9IHZcbiAgICAgICAgaWYoIGkgPCBpbnB1dHMubGVuZ3RoIC0xICkge1xuICAgICAgICAgIGFkZGVyQXRFbmQgPSB0cnVlXG4gICAgICAgICAgb3V0ICs9ICcgKyAnXG4gICAgICAgIH1cbiAgICAgICAgYWxyZWFkeUZ1bGxTdW1tZWQgPSBmYWxzZVxuICAgICAgfWVsc2V7XG4gICAgICAgIHN1bSArPSBwYXJzZUZsb2F0KCB2IClcbiAgICAgICAgbnVtQ291bnQrK1xuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiggbnVtQ291bnQgPiAwICkge1xuICAgICAgb3V0ICs9IGFkZGVyQXRFbmQgfHwgYWxyZWFkeUZ1bGxTdW1tZWQgPyBzdW0gOiAnICsgJyArIHN1bVxuICAgIH1cblxuICAgIG91dCArPSAnXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIC4uLmFyZ3MgKSA9PiB7XG4gIGNvbnN0IGFkZCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgYWRkLmlkID0gZ2VuLmdldFVJRCgpXG4gIGFkZC5uYW1lID0gYWRkLmJhc2VuYW1lICsgYWRkLmlkXG4gIGFkZC5pbnB1dHMgPSBhcmdzXG5cbiAgcmV0dXJuIGFkZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBtdWwgICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBzdWIgICAgICA9IHJlcXVpcmUoICcuL3N1Yi5qcycgKSxcbiAgICBkaXYgICAgICA9IHJlcXVpcmUoICcuL2Rpdi5qcycgKSxcbiAgICBkYXRhICAgICA9IHJlcXVpcmUoICcuL2RhdGEuanMnICksXG4gICAgcGVlayAgICAgPSByZXF1aXJlKCAnLi9wZWVrLmpzJyApLFxuICAgIGFjY3VtICAgID0gcmVxdWlyZSggJy4vYWNjdW0uanMnICksXG4gICAgaWZlbHNlICAgPSByZXF1aXJlKCAnLi9pZmVsc2VpZi5qcycgKSxcbiAgICBsdCAgICAgICA9IHJlcXVpcmUoICcuL2x0LmpzJyApLFxuICAgIGJhbmcgICAgID0gcmVxdWlyZSggJy4vYmFuZy5qcycgKSxcbiAgICBlbnYgICAgICA9IHJlcXVpcmUoICcuL2Vudi5qcycgKSxcbiAgICBwYXJhbSAgICA9IHJlcXVpcmUoICcuL3BhcmFtLmpzJyApLFxuICAgIGFkZCAgICAgID0gcmVxdWlyZSggJy4vYWRkLmpzJyApLFxuICAgIGd0cCAgICAgID0gcmVxdWlyZSggJy4vZ3RwLmpzJyApLFxuICAgIG5vdCAgICAgID0gcmVxdWlyZSggJy4vbm90LmpzJyApLFxuICAgIGFuZCAgICAgID0gcmVxdWlyZSggJy4vYW5kLmpzJyApLFxuICAgIG5lcSAgICAgID0gcmVxdWlyZSggJy4vbmVxLmpzJyApLFxuICAgIHBva2UgICAgID0gcmVxdWlyZSggJy4vcG9rZS5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggYXR0YWNrVGltZT00NCwgZGVjYXlUaW1lPTIyMDUwLCBzdXN0YWluVGltZT00NDEwMCwgc3VzdGFpbkxldmVsPS42LCByZWxlYXNlVGltZT00NDEwMCwgX3Byb3BzICkgPT4ge1xuICBsZXQgZW52VHJpZ2dlciA9IGJhbmcoKSxcbiAgICAgIHBoYXNlID0gYWNjdW0oIDEsIGVudlRyaWdnZXIsIHsgbWF4OiBJbmZpbml0eSwgc2hvdWxkV3JhcDpmYWxzZSwgaW5pdGlhbFZhbHVlOkluZmluaXR5IH0pLFxuICAgICAgc2hvdWxkU3VzdGFpbiA9IHBhcmFtKCAxICksXG4gICAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgIHNoYXBlOiAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgYWxwaGE6IDUsXG4gICAgICAgICB0cmlnZ2VyUmVsZWFzZTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgX3Byb3BzICksXG4gICAgICBidWZmZXJEYXRhLCBkZWNheURhdGEsIG91dCwgYnVmZmVyLCBzdXN0YWluQ29uZGl0aW9uLCByZWxlYXNlQWNjdW0sIHJlbGVhc2VDb25kaXRpb25cblxuXG4gIGNvbnN0IGNvbXBsZXRlRmxhZyA9IGRhdGEoIFswXSApXG5cbiAgYnVmZmVyRGF0YSA9IGVudih7IGxlbmd0aDoxMDI0LCBhbHBoYTpwcm9wcy5hbHBoYSwgc2hpZnQ6MCwgdHlwZTpwcm9wcy5zaGFwZSB9KVxuXG4gIHN1c3RhaW5Db25kaXRpb24gPSBwcm9wcy50cmlnZ2VyUmVsZWFzZSBcbiAgICA/IHNob3VsZFN1c3RhaW5cbiAgICA6IGx0KCBwaGFzZSwgYWRkKCBhdHRhY2tUaW1lLCBkZWNheVRpbWUsIHN1c3RhaW5UaW1lICkgKVxuXG4gIHJlbGVhc2VBY2N1bSA9IHByb3BzLnRyaWdnZXJSZWxlYXNlXG4gICAgPyBndHAoIHN1Yiggc3VzdGFpbkxldmVsLCBhY2N1bSggZGl2KCBzdXN0YWluTGV2ZWwsIHJlbGVhc2VUaW1lICkgLCAwLCB7IHNob3VsZFdyYXA6ZmFsc2UgfSkgKSwgMCApXG4gICAgOiBzdWIoIHN1c3RhaW5MZXZlbCwgbXVsKCBkaXYoIHN1YiggcGhhc2UsIGFkZCggYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXN0YWluVGltZSApICksIHJlbGVhc2VUaW1lICksIHN1c3RhaW5MZXZlbCApICksIFxuXG4gIHJlbGVhc2VDb25kaXRpb24gPSBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgID8gbm90KCBzaG91bGRTdXN0YWluIClcbiAgICA6IGx0KCBwaGFzZSwgYWRkKCBhdHRhY2tUaW1lLCBkZWNheVRpbWUsIHN1c3RhaW5UaW1lLCByZWxlYXNlVGltZSApIClcblxuICBvdXQgPSBpZmVsc2UoXG4gICAgLy8gYXR0YWNrIFxuICAgIGx0KCBwaGFzZSwgIGF0dGFja1RpbWUgKSwgXG4gICAgcGVlayggYnVmZmVyRGF0YSwgZGl2KCBwaGFzZSwgYXR0YWNrVGltZSApLCB7IGJvdW5kbW9kZTonY2xhbXAnIH0gKSwgXG5cbiAgICAvLyBkZWNheVxuICAgIGx0KCBwaGFzZSwgYWRkKCBhdHRhY2tUaW1lLCBkZWNheVRpbWUgKSApLCBcbiAgICBwZWVrKCBidWZmZXJEYXRhLCBzdWIoIDEsIG11bCggZGl2KCBzdWIoIHBoYXNlLCAgYXR0YWNrVGltZSApLCAgZGVjYXlUaW1lICksIHN1YiggMSwgIHN1c3RhaW5MZXZlbCApICkgKSwgeyBib3VuZG1vZGU6J2NsYW1wJyB9KSxcblxuICAgIC8vIHN1c3RhaW5cbiAgICBhbmQoIHN1c3RhaW5Db25kaXRpb24sIG5lcSggcGhhc2UsIEluZmluaXR5ICkgKSxcbiAgICBwZWVrKCBidWZmZXJEYXRhLCAgc3VzdGFpbkxldmVsICksXG5cbiAgICAvLyByZWxlYXNlXG4gICAgcmVsZWFzZUNvbmRpdGlvbiwgLy9sdCggcGhhc2UsICBhdHRhY2tUaW1lICsgIGRlY2F5VGltZSArICBzdXN0YWluVGltZSArICByZWxlYXNlVGltZSApLFxuICAgIHBlZWsoIFxuICAgICAgYnVmZmVyRGF0YSxcbiAgICAgIHJlbGVhc2VBY2N1bSwgXG4gICAgICAvL3N1YiggIHN1c3RhaW5MZXZlbCwgbXVsKCBkaXYoIHN1YiggcGhhc2UsICBhdHRhY2tUaW1lICsgIGRlY2F5VGltZSArICBzdXN0YWluVGltZSksICByZWxlYXNlVGltZSApLCAgc3VzdGFpbkxldmVsICkgKSwgXG4gICAgICB7IGJvdW5kbW9kZTonY2xhbXAnIH1cbiAgICApLFxuXG4gICAgbmVxKCBwaGFzZSwgSW5maW5pdHkgKSxcbiAgICBwb2tlKCBjb21wbGV0ZUZsYWcsIDEsIDAsIHsgaW5saW5lOjAgfSksXG5cbiAgICAwXG4gIClcbiAgIFxuICBjb25zdCB1c2luZ1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gIGlmKCB1c2luZ1dvcmtsZXQgPT09IHRydWUgKSB7XG4gICAgb3V0Lm5vZGUgPSBudWxsXG4gICAgdXRpbGl0aWVzLnJlZ2lzdGVyKCBvdXQgKVxuICB9XG5cbiAgb3V0LnRyaWdnZXIgPSAoKT0+IHtcbiAgICBzaG91bGRTdXN0YWluLnZhbHVlID0gMVxuICAgIGVudlRyaWdnZXIudHJpZ2dlcigpXG4gIH1cbiBcbiAgLy8gbmVlZGVkIGZvciBnaWJiZXJpc2guLi4gZ2V0dGluZyB0aGlzIHRvIHdvcmsgcmlnaHQgd2l0aCB3b3JrbGV0c1xuICAvLyB2aWEgcHJvbWlzZXMgd2lsbCBwcm9iYWJseSBiZSB0cmlja3lcbiAgb3V0LmlzQ29tcGxldGUgPSAoKT0+IHtcbiAgICBpZiggdXNpbmdXb3JrbGV0ID09PSB0cnVlICYmIG91dC5ub2RlICE9PSBudWxsICkge1xuICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKCByZXNvbHZlID0+IHtcbiAgICAgICAgb3V0Lm5vZGUuZ2V0TWVtb3J5VmFsdWUoIGNvbXBsZXRlRmxhZy5tZW1vcnkudmFsdWVzLmlkeCwgcmVzb2x2ZSApXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gcFxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIGdlbi5tZW1vcnkuaGVhcFsgY29tcGxldGVGbGFnLm1lbW9yeS52YWx1ZXMuaWR4IF1cbiAgICB9XG4gIH1cblxuXG4gIG91dC5yZWxlYXNlID0gKCk9PiB7XG4gICAgc2hvdWxkU3VzdGFpbi52YWx1ZSA9IDBcbiAgICAvLyBYWFggcHJldHR5IG5hc3R5Li4uIGdyYWJzIGFjY3VtIGluc2lkZSBvZiBndHAgYW5kIHJlc2V0cyB2YWx1ZSBtYW51YWxseVxuICAgIC8vIHVuZm9ydHVuYXRlbHkgZW52VHJpZ2dlciB3b24ndCB3b3JrIGFzIGl0J3MgYmFjayB0byAwIGJ5IHRoZSB0aW1lIHRoZSByZWxlYXNlIGJsb2NrIGlzIHRyaWdnZXJlZC4uLlxuICAgIGlmKCB1c2luZ1dvcmtsZXQgJiYgb3V0Lm5vZGUgIT09IG51bGwgKSB7XG4gICAgICBvdXQubm9kZS5wb3J0LnBvc3RNZXNzYWdlKHsga2V5OidzZXQnLCBpZHg6cmVsZWFzZUFjY3VtLmlucHV0c1swXS5pbnB1dHNbMV0ubWVtb3J5LnZhbHVlLmlkeCwgdmFsdWU6MCB9KVxuICAgIH1lbHNle1xuICAgICAgZ2VuLm1lbW9yeS5oZWFwWyByZWxlYXNlQWNjdW0uaW5wdXRzWzBdLmlucHV0c1sxXS5tZW1vcnkudmFsdWUuaWR4IF0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dCBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2FuZCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksIG91dFxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9ICgke2lucHV0c1swXX0gIT09IDAgJiYgJHtpbnB1dHNbMV19ICE9PSAwKSB8IDBcXG5cXG5gXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgJHt0aGlzLm5hbWV9YFxuXG4gICAgcmV0dXJuIFsgYCR7dGhpcy5uYW1lfWAsIG91dCBdXG4gIH0sXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgaW4yICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICBbIGluMSwgaW4yIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2FzaW4nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0ID8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ2FzaW4nOiBpc1dvcmtsZXQgPyAnTWF0aC5zaW4nIDogTWF0aC5hc2luIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1hc2luKCAke2lucHV0c1swXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5hc2luKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgYXNpbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBhc2luLmlucHV0cyA9IFsgeCBdXG4gIGFzaW4uaWQgPSBnZW4uZ2V0VUlEKClcbiAgYXNpbi5uYW1lID0gYCR7YXNpbi5iYXNlbmFtZX17YXNpbi5pZH1gXG5cbiAgcmV0dXJuIGFzaW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonYXRhbicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQgPyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyAnYXRhbic6IGlzV29ya2xldCA/ICdNYXRoLmF0YW4nIDogTWF0aC5hdGFuIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1hdGFuKCAke2lucHV0c1swXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5hdGFuKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgYXRhbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBhdGFuLmlucHV0cyA9IFsgeCBdXG4gIGF0YW4uaWQgPSBnZW4uZ2V0VUlEKClcbiAgYXRhbi5uYW1lID0gYCR7YXRhbi5iYXNlbmFtZX17YXRhbi5pZH1gXG5cbiAgcmV0dXJuIGF0YW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBoaXN0b3J5ID0gcmVxdWlyZSggJy4vaGlzdG9yeS5qcycgKSxcbiAgICBtdWwgICAgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIHN1YiAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGRlY2F5VGltZSA9IDQ0MTAwICkgPT4ge1xuICBsZXQgc3NkID0gaGlzdG9yeSAoIDEgKSxcbiAgICAgIHQ2MCA9IE1hdGguZXhwKCAtNi45MDc3NTUyNzg5MjEgLyBkZWNheVRpbWUgKVxuXG4gIHNzZC5pbiggbXVsKCBzc2Qub3V0LCB0NjAgKSApXG5cbiAgc3NkLm91dC50cmlnZ2VyID0gKCk9PiB7XG4gICAgc3NkLnZhbHVlID0gMVxuICB9XG5cbiAgcmV0dXJuIHN1YiggMSwgc3NkLm91dCApXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBnZW4oKSB7XG4gICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcbiAgICBcbiAgICBsZXQgb3V0ID0gXG5gICB2YXIgJHt0aGlzLm5hbWV9ID0gbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1cbiAgaWYoICR7dGhpcy5uYW1lfSA9PT0gMSApIG1lbW9yeVske3RoaXMubWVtb3J5LnZhbHVlLmlkeH1dID0gMCAgICAgIFxuICAgICAgXG5gXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH0gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBfcHJvcHMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBtaW46MCwgbWF4OjEgfSwgX3Byb3BzIClcblxuICB1Z2VuLm5hbWUgPSAnYmFuZycgKyBnZW4uZ2V0VUlEKClcblxuICB1Z2VuLm1pbiA9IHByb3BzLm1pblxuICB1Z2VuLm1heCA9IHByb3BzLm1heFxuXG4gIGNvbnN0IHVzaW5nV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgaWYoIHVzaW5nV29ya2xldCA9PT0gdHJ1ZSApIHtcbiAgICB1Z2VuLm5vZGUgPSBudWxsXG4gICAgdXRpbGl0aWVzLnJlZ2lzdGVyKCB1Z2VuIClcbiAgfVxuXG4gIHVnZW4udHJpZ2dlciA9ICgpID0+IHtcbiAgICBpZiggdXNpbmdXb3JrbGV0ID09PSB0cnVlICYmIHVnZW4ubm9kZSAhPT0gbnVsbCApIHtcbiAgICAgIHVnZW4ubm9kZS5wb3J0LnBvc3RNZXNzYWdlKHsga2V5OidzZXQnLCBpZHg6dWdlbi5tZW1vcnkudmFsdWUuaWR4LCB2YWx1ZTp1Z2VuLm1heCB9KVxuICAgIH1lbHNle1xuICAgICAgZ2VuLm1lbW9yeS5oZWFwWyB1Z2VuLm1lbW9yeS52YWx1ZS5pZHggXSA9IHVnZW4ubWF4IFxuICAgIH1cbiAgfVxuXG4gIHVnZW4ubWVtb3J5ID0ge1xuICAgIHZhbHVlOiB7IGxlbmd0aDoxLCBpZHg6bnVsbCB9XG4gIH1cblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonYm9vbCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksIG91dFxuXG4gICAgb3V0ID0gYCR7aW5wdXRzWzBdfSA9PT0gMCA/IDAgOiAxYFxuICAgIFxuICAgIC8vZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gYGdlbi5kYXRhLiR7dGhpcy5uYW1lfWBcblxuICAgIC8vcmV0dXJuIFsgYGdlbi5kYXRhLiR7dGhpcy5uYW1lfWAsICcgJyArb3V0IF1cbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBcbiAgICB1aWQ6ICAgICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgICAgWyBpbjEgXSxcbiAgfSlcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2NlaWwnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQgPyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiBpc1dvcmtsZXQgPyAnTWF0aC5jZWlsJyA6IE1hdGguY2VpbCB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9Y2VpbCggJHtpbnB1dHNbMF19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5jZWlsKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgY2VpbCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBjZWlsLmlucHV0cyA9IFsgeCBdXG5cbiAgcmV0dXJuIGNlaWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgZmxvb3I9IHJlcXVpcmUoJy4vZmxvb3IuanMnKSxcbiAgICBzdWIgID0gcmVxdWlyZSgnLi9zdWIuanMnKSxcbiAgICBtZW1vID0gcmVxdWlyZSgnLi9tZW1vLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonY2xpcCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBjb2RlLFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIG91dFxuXG4gICAgb3V0ID1cblxuYCB2YXIgJHt0aGlzLm5hbWV9ID0gJHtpbnB1dHNbMF19XG4gIGlmKCAke3RoaXMubmFtZX0gPiAke2lucHV0c1syXX0gKSAke3RoaXMubmFtZX0gPSAke2lucHV0c1syXX1cbiAgZWxzZSBpZiggJHt0aGlzLm5hbWV9IDwgJHtpbnB1dHNbMV19ICkgJHt0aGlzLm5hbWV9ID0gJHtpbnB1dHNbMV19XG5gXG4gICAgb3V0ID0gJyAnICsgb3V0XG4gICAgXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIG1pbj0tMSwgbWF4PTEgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgbWluLCBcbiAgICBtYXgsXG4gICAgdWlkOiAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBbIGluMSwgbWluLCBtYXggXSxcbiAgfSlcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonY29zJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0ID8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ2Nvcyc6IGlzV29ya2xldCA/ICdNYXRoLmNvcycgOiBNYXRoLmNvcyB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9Y29zKCAke2lucHV0c1swXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5jb3MoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBjb3MgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgY29zLmlucHV0cyA9IFsgeCBdXG4gIGNvcy5pZCA9IGdlbi5nZXRVSUQoKVxuICBjb3MubmFtZSA9IGAke2Nvcy5iYXNlbmFtZX17Y29zLmlkfWBcblxuICByZXR1cm4gY29zXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2NvdW50ZXInLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgY29kZSxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBnZW5OYW1lID0gJ2dlbi4nICsgdGhpcy5uYW1lLFxuICAgICAgICBmdW5jdGlvbkJvZHlcbiAgICAgICBcbiAgICBpZiggdGhpcy5tZW1vcnkudmFsdWUuaWR4ID09PSBudWxsICkgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcbiAgICBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdID0gdGhpcy5pbml0aWFsVmFsdWVcbiAgICBcbiAgICBmdW5jdGlvbkJvZHkgID0gdGhpcy5jYWxsYmFjayggZ2VuTmFtZSwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIGlucHV0c1syXSwgaW5wdXRzWzNdLCBpbnB1dHNbNF0sICBgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1gLCBgbWVtb3J5WyR7dGhpcy5tZW1vcnkud3JhcC5pZHh9XWAgIClcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZSArICdfdmFsdWUnXG4gICBcbiAgICBpZiggZ2VuLm1lbW9bIHRoaXMud3JhcC5uYW1lIF0gPT09IHVuZGVmaW5lZCApIHRoaXMud3JhcC5nZW4oKVxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lICsgJ192YWx1ZScsIGZ1bmN0aW9uQm9keSBdXG4gIH0sXG5cbiAgY2FsbGJhY2soIF9uYW1lLCBfaW5jciwgX21pbiwgX21heCwgX3Jlc2V0LCBsb29wcywgdmFsdWVSZWYsIHdyYXBSZWYgKSB7XG4gICAgbGV0IGRpZmYgPSB0aGlzLm1heCAtIHRoaXMubWluLFxuICAgICAgICBvdXQgPSAnJyxcbiAgICAgICAgd3JhcCA9ICcnXG4gICAgLy8gbXVzdCBjaGVjayBmb3IgcmVzZXQgYmVmb3JlIHN0b3JpbmcgdmFsdWUgZm9yIG91dHB1dFxuICAgIGlmKCAhKHR5cGVvZiB0aGlzLmlucHV0c1szXSA9PT0gJ251bWJlcicgJiYgdGhpcy5pbnB1dHNbM10gPCAxKSApIHsgXG4gICAgICBvdXQgKz0gYCAgaWYoICR7X3Jlc2V0fSA+PSAxICkgJHt2YWx1ZVJlZn0gPSAke19taW59XFxuYFxuICAgIH1cblxuICAgIG91dCArPSBgICB2YXIgJHt0aGlzLm5hbWV9X3ZhbHVlID0gJHt2YWx1ZVJlZn07XFxuICAke3ZhbHVlUmVmfSArPSAke19pbmNyfVxcbmAgLy8gc3RvcmUgb3V0cHV0IHZhbHVlIGJlZm9yZSBhY2N1bXVsYXRpbmcgIFxuICAgIFxuICAgIGlmKCB0eXBlb2YgdGhpcy5tYXggPT09ICdudW1iZXInICYmIHRoaXMubWF4ICE9PSBJbmZpbml0eSAmJiB0eXBlb2YgdGhpcy5taW4gIT09ICdudW1iZXInICkge1xuICAgICAgd3JhcCA9IFxuYCAgaWYoICR7dmFsdWVSZWZ9ID49ICR7dGhpcy5tYXh9ICYmICAke2xvb3BzfSA+IDApIHtcbiAgICAke3ZhbHVlUmVmfSAtPSAke2RpZmZ9XG4gICAgJHt3cmFwUmVmfSA9IDFcbiAgfWVsc2V7XG4gICAgJHt3cmFwUmVmfSA9IDBcbiAgfVxcbmBcbiAgICB9ZWxzZSBpZiggdGhpcy5tYXggIT09IEluZmluaXR5ICYmIHRoaXMubWluICE9PSBJbmZpbml0eSApIHtcbiAgICAgIHdyYXAgPSBcbmAgIGlmKCAke3ZhbHVlUmVmfSA+PSAke19tYXh9ICYmICAke2xvb3BzfSA+IDApIHtcbiAgICAke3ZhbHVlUmVmfSAtPSAke19tYXh9IC0gJHtfbWlufVxuICAgICR7d3JhcFJlZn0gPSAxXG4gIH1lbHNlIGlmKCAke3ZhbHVlUmVmfSA8ICR7X21pbn0gJiYgICR7bG9vcHN9ID4gMCkge1xuICAgICR7dmFsdWVSZWZ9ICs9ICR7X21heH0gLSAke19taW59XG4gICAgJHt3cmFwUmVmfSA9IDFcbiAgfWVsc2V7XG4gICAgJHt3cmFwUmVmfSA9IDBcbiAgfVxcbmBcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSAnXFxuJ1xuICAgIH1cblxuICAgIG91dCA9IG91dCArIHdyYXBcblxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW5jcj0xLCBtaW49MCwgbWF4PUluZmluaXR5LCByZXNldD0wLCBsb29wcz0xLCAgcHJvcGVydGllcyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKCB7IGluaXRpYWxWYWx1ZTogMCwgc2hvdWxkV3JhcDp0cnVlIH0sIHByb3BlcnRpZXMgKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgbWluOiAgICBtaW4sIFxuICAgIG1heDogICAgbWF4LFxuICAgIGluaXRpYWxWYWx1ZTogZGVmYXVsdHMuaW5pdGlhbFZhbHVlLFxuICAgIHZhbHVlOiAgZGVmYXVsdHMuaW5pdGlhbFZhbHVlLFxuICAgIHVpZDogICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogWyBpbmNyLCBtaW4sIG1heCwgcmVzZXQsIGxvb3BzIF0sXG4gICAgbWVtb3J5OiB7XG4gICAgICB2YWx1ZTogeyBsZW5ndGg6MSwgaWR4OiBudWxsIH0sXG4gICAgICB3cmFwOiAgeyBsZW5ndGg6MSwgaWR4OiBudWxsIH0gXG4gICAgfSxcbiAgICB3cmFwIDoge1xuICAgICAgZ2VuKCkgeyBcbiAgICAgICAgaWYoIHVnZW4ubWVtb3J5LndyYXAuaWR4ID09PSBudWxsICkge1xuICAgICAgICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB1Z2VuLm1lbW9yeSApXG4gICAgICAgIH1cbiAgICAgICAgZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGBtZW1vcnlbICR7dWdlbi5tZW1vcnkud3JhcC5pZHh9IF1gXG4gICAgICAgIHJldHVybiBgbWVtb3J5WyAke3VnZW4ubWVtb3J5LndyYXAuaWR4fSBdYCBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzIClcbiBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAndmFsdWUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYoIHRoaXMubWVtb3J5LnZhbHVlLmlkeCAhPT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuIGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldCggdiApIHtcbiAgICAgIGlmKCB0aGlzLm1lbW9yeS52YWx1ZS5pZHggIT09IG51bGwgKSB7XG4gICAgICAgIGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF0gPSB2IFxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIHVnZW4ud3JhcC5pbnB1dHMgPSBbIHVnZW4gXVxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuICB1Z2VuLndyYXAubmFtZSA9IHVnZW4ubmFtZSArICdfd3JhcCdcbiAgcmV0dXJuIHVnZW5cbn0gXG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgYWNjdW09IHJlcXVpcmUoICcuL3BoYXNvci5qcycgKSxcbiAgICBkYXRhID0gcmVxdWlyZSggJy4vZGF0YS5qcycgKSxcbiAgICBwZWVrID0gcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgICBtdWwgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIHBoYXNvcj1yZXF1aXJlKCAnLi9waGFzb3IuanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidjeWNsZScsXG5cbiAgaW5pdFRhYmxlKCkgeyAgICBcbiAgICBsZXQgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMTAyNCApXG5cbiAgICBmb3IoIGxldCBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICBidWZmZXJbIGkgXSA9IE1hdGguc2luKCAoIGkgLyBsICkgKiAoIE1hdGguUEkgKiAyICkgKVxuICAgIH1cblxuICAgIGdlbi5nbG9iYWxzLmN5Y2xlID0gZGF0YSggYnVmZmVyLCAxLCB7IGltbXV0YWJsZTp0cnVlIH0gKVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGZyZXF1ZW5jeT0xLCByZXNldD0wLCBfcHJvcHMgKSA9PiB7XG4gIGlmKCB0eXBlb2YgZ2VuLmdsb2JhbHMuY3ljbGUgPT09ICd1bmRlZmluZWQnICkgcHJvdG8uaW5pdFRhYmxlKCkgXG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBtaW46MCB9LCBfcHJvcHMgKVxuXG4gIGNvbnN0IHVnZW4gPSBwZWVrKCBnZW4uZ2xvYmFscy5jeWNsZSwgcGhhc29yKCBmcmVxdWVuY3ksIHJlc2V0LCBwcm9wcyApKVxuICB1Z2VuLm5hbWUgPSAnY3ljbGUnICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKSxcbiAgICAgIHV0aWxpdGllcyA9IHJlcXVpcmUoICcuL3V0aWxpdGllcy5qcycgKSxcbiAgICAgIHBlZWsgPSByZXF1aXJlKCcuL3BlZWsuanMnKSxcbiAgICAgIHBva2UgPSByZXF1aXJlKCcuL3Bva2UuanMnKVxuXG5jb25zdCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2RhdGEnLFxuICBnbG9iYWxzOiB7fSxcbiAgbWVtbzp7fSxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlkeFxuICAgIC8vY29uc29sZS5sb2coICdkYXRhIG5hbWU6JywgdGhpcy5uYW1lLCBwcm90by5tZW1vIClcbiAgICAvL2RlYnVnZ2VyXG4gICAgaWYoIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgbGV0IHVnZW4gPSB0aGlzXG4gICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5tZW1vcnksIHRoaXMuaW1tdXRhYmxlICkgXG4gICAgICBpZHggPSB0aGlzLm1lbW9yeS52YWx1ZXMuaWR4XG4gICAgICBpZiggdGhpcy5idWZmZXIgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBnZW4ubWVtb3J5LmhlYXAuc2V0KCB0aGlzLmJ1ZmZlciwgaWR4IClcbiAgICAgICAgfWNhdGNoKCBlICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCBlIClcbiAgICAgICAgICB0aHJvdyBFcnJvciggJ2Vycm9yIHdpdGggcmVxdWVzdC4gYXNraW5nIGZvciAnICsgdGhpcy5idWZmZXIubGVuZ3RoICsnLiBjdXJyZW50IGluZGV4OiAnICsgZ2VuLm1lbW9yeUluZGV4ICsgJyBvZiAnICsgZ2VuLm1lbW9yeS5oZWFwLmxlbmd0aCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZ2VuLmRhdGFbIHRoaXMubmFtZSBdID0gdGhpc1xuICAgICAgLy9yZXR1cm4gJ2dlbi5tZW1vcnknICsgdGhpcy5uYW1lICsgJy5idWZmZXInXG4gICAgICBpZiggdGhpcy5uYW1lLmluZGV4T2YoJ2RhdGEnKSA9PT0gLTEgKSB7XG4gICAgICAgIHByb3RvLm1lbW9bIHRoaXMubmFtZSBdID0gaWR4XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gaWR4XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAvL2NvbnNvbGUubG9nKCAndXNpbmcgZ2VuIGRhdGEgbWVtbycsIHByb3RvLm1lbW9bIHRoaXMubmFtZSBdIClcbiAgICAgIGlkeCA9IGdlbi5tZW1vWyB0aGlzLm5hbWUgXVxuICAgIH1cbiAgICByZXR1cm4gaWR4XG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCB4LCB5PTEsIHByb3BlcnRpZXMgKSA9PiB7XG4gIGxldCB1Z2VuLCBidWZmZXIsIHNob3VsZExvYWQgPSBmYWxzZVxuICBcbiAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmdsb2JhbCAhPT0gdW5kZWZpbmVkICkge1xuICAgIGlmKCBnZW4uZ2xvYmFsc1sgcHJvcGVydGllcy5nbG9iYWwgXSApIHtcbiAgICAgIHJldHVybiBnZW4uZ2xvYmFsc1sgcHJvcGVydGllcy5nbG9iYWwgXVxuICAgIH1cbiAgfVxuXG4gIGlmKCB0eXBlb2YgeCA9PT0gJ251bWJlcicgKSB7XG4gICAgaWYoIHkgIT09IDEgKSB7XG4gICAgICBidWZmZXIgPSBbXVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB5OyBpKysgKSB7XG4gICAgICAgIGJ1ZmZlclsgaSBdID0gbmV3IEZsb2F0MzJBcnJheSggeCApXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCB4IClcbiAgICB9XG4gIH1lbHNlIGlmKCBBcnJheS5pc0FycmF5KCB4ICkgKSB7IC8vISAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApICkge1xuICAgIGxldCBzaXplID0geC5sZW5ndGhcbiAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplIClcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKysgKSB7XG4gICAgICBidWZmZXJbIGkgXSA9IHhbIGkgXVxuICAgIH1cbiAgfWVsc2UgaWYoIHR5cGVvZiB4ID09PSAnc3RyaW5nJyApIHtcbiAgICAvL2J1ZmZlciA9IHsgbGVuZ3RoOiB5ID4gMSA/IHkgOiBnZW4uc2FtcGxlcmF0ZSAqIDYwIH0gLy8gWFhYIHdoYXQ/Pz9cbiAgICAvL2lmKCBwcm90by5tZW1vWyB4IF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGJ1ZmZlciA9IHsgbGVuZ3RoOiB5ID4gMSA/IHkgOiAxIH0gLy8gWFhYIHdoYXQ/Pz9cbiAgICAgIHNob3VsZExvYWQgPSB0cnVlXG4gICAgLy99ZWxzZXtcbiAgICAgIC8vYnVmZmVyID0gcHJvdG8ubWVtb1sgeCBdXG4gICAgLy99XG4gIH1lbHNlIGlmKCB4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xuICAgIGJ1ZmZlciA9IHhcbiAgfVxuICBcbiAgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICkgXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgXG4gIHsgXG4gICAgYnVmZmVyLFxuICAgIG5hbWU6IHByb3RvLmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpLFxuICAgIGRpbTogIGJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gYnVmZmVyLmxlbmd0aCA6IDEsIC8vIFhYWCBob3cgZG8gd2UgZHluYW1pY2FsbHkgYWxsb2NhdGUgdGhpcz9cbiAgICBjaGFubmVscyA6IDEsXG4gICAgb25sb2FkOiBudWxsLFxuICAgIC8vdGhlbiggZm5jICkge1xuICAgIC8vICB1Z2VuLm9ubG9hZCA9IGZuY1xuICAgIC8vICByZXR1cm4gdWdlblxuICAgIC8vfSxcbiAgICBpbW11dGFibGU6IHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmltbXV0YWJsZSA9PT0gdHJ1ZSA/IHRydWUgOiBmYWxzZSxcbiAgICBsb2FkKCBmaWxlbmFtZSwgX19yZXNvbHZlICkge1xuICAgICAgbGV0IHByb21pc2UgPSB1dGlsaXRpZXMubG9hZFNhbXBsZSggZmlsZW5hbWUsIHVnZW4gKVxuICAgICAgcHJvbWlzZS50aGVuKCBfYnVmZmVyID0+IHsgXG4gICAgICAgIHByb3RvLm1lbW9bIHggXSA9IF9idWZmZXJcbiAgICAgICAgdWdlbi5uYW1lID0gZmlsZW5hbWVcbiAgICAgICAgdWdlbi5tZW1vcnkudmFsdWVzLmxlbmd0aCA9IHVnZW4uZGltID0gX2J1ZmZlci5sZW5ndGhcblxuICAgICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdWdlbi5tZW1vcnksIHVnZW4uaW1tdXRhYmxlICkgXG4gICAgICAgIGdlbi5tZW1vcnkuaGVhcC5zZXQoIF9idWZmZXIsIHVnZW4ubWVtb3J5LnZhbHVlcy5pZHggKVxuICAgICAgICBpZiggdHlwZW9mIHVnZW4ub25sb2FkID09PSAnZnVuY3Rpb24nICkgdWdlbi5vbmxvYWQoIF9idWZmZXIgKSBcbiAgICAgICAgX19yZXNvbHZlKCB1Z2VuIClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBtZW1vcnkgOiB7XG4gICAgICB2YWx1ZXM6IHsgbGVuZ3RoOmJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gYnVmZmVyLmxlbmd0aCA6IDEsIGlkeDpudWxsIH1cbiAgICB9XG4gIH0sXG4gIHByb3BlcnRpZXNcbiAgKVxuXG4gIFxuICBpZiggcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICkge1xuICAgIGlmKCBwcm9wZXJ0aWVzLmdsb2JhbCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgZ2VuLmdsb2JhbHNbIHByb3BlcnRpZXMuZ2xvYmFsIF0gPSB1Z2VuXG4gICAgfVxuICAgIGlmKCBwcm9wZXJ0aWVzLm1ldGEgPT09IHRydWUgKSB7XG4gICAgICBmb3IoIGxldCBpID0gMCwgbGVuZ3RoID0gdWdlbi5idWZmZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgaSwge1xuICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVlayggdWdlbiwgaSwgeyBtb2RlOidzaW1wbGUnLCBpbnRlcnA6J25vbmUnIH0gKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgICAgcmV0dXJuIHBva2UoIHVnZW4sIHYsIGkgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcmV0dXJuVmFsdWVcbiAgaWYoIHNob3VsZExvYWQgPT09IHRydWUgKSB7XG4gICAgcmV0dXJuVmFsdWUgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICAgICAvL3VnZW4ubG9hZCggeCwgcmVzb2x2ZSApXG4gICAgICBsZXQgcHJvbWlzZSA9IHV0aWxpdGllcy5sb2FkU2FtcGxlKCB4LCB1Z2VuIClcbiAgICAgIHByb21pc2UudGhlbiggX2J1ZmZlciA9PiB7IFxuICAgICAgICBwcm90by5tZW1vWyB4IF0gPSBfYnVmZmVyXG4gICAgICAgIHVnZW4ubWVtb3J5LnZhbHVlcy5sZW5ndGggPSB1Z2VuLmRpbSA9IF9idWZmZXIubGVuZ3RoXG5cbiAgICAgICAgdWdlbi5idWZmZXIgPSBfYnVmZmVyXG4gICAgICAgIC8vZ2VuLm9uY2UoICdtZW1vcnkgaW5pdCcsICgpPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coIFwiQ0FMTEVEXCIsIHVnZW4ubWVtb3J5IClcbiAgICAgICAgLy8gIGdlbi5yZXF1ZXN0TWVtb3J5KCB1Z2VuLm1lbW9yeSwgdWdlbi5pbW11dGFibGUgKSBcbiAgICAgICAgLy8gIGdlbi5tZW1vcnkuaGVhcC5zZXQoIF9idWZmZXIsIHVnZW4ubWVtb3J5LnZhbHVlcy5pZHggKVxuICAgICAgICAvLyAgaWYoIHR5cGVvZiB1Z2VuLm9ubG9hZCA9PT0gJ2Z1bmN0aW9uJyApIHVnZW4ub25sb2FkKCBfYnVmZmVyICkgXG4gICAgICAgIC8vfSlcbiAgICAgICAgXG4gICAgICAgIHJlc29sdmUoIHVnZW4gKVxuICAgICAgfSkgICAgIFxuICAgIH0pXG4gIH1lbHNlIGlmKCBwcm90by5tZW1vWyB4IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIGdlbi5vbmNlKCAnbWVtb3J5IGluaXQnLCAoKT0+IHtcbiAgICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB1Z2VuLm1lbW9yeSwgdWdlbi5pbW11dGFibGUgKSBcbiAgICAgIGdlbi5tZW1vcnkuaGVhcC5zZXQoIHVnZW4uYnVmZmVyLCB1Z2VuLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgIGlmKCB0eXBlb2YgdWdlbi5vbmxvYWQgPT09ICdmdW5jdGlvbicgKSB1Z2VuLm9ubG9hZCggdWdlbi5idWZmZXIgKSBcbiAgICB9KVxuXG4gICAgcmV0dXJuVmFsdWUgPSB1Z2VuXG4gIH1lbHNle1xuICAgIHJldHVyblZhbHVlID0gdWdlblxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlIFxufVxuXG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgaGlzdG9yeSA9IHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gICAgc3ViICAgICA9IHJlcXVpcmUoICcuL3N1Yi5qcycgKSxcbiAgICBhZGQgICAgID0gcmVxdWlyZSggJy4vYWRkLmpzJyApLFxuICAgIG11bCAgICAgPSByZXF1aXJlKCAnLi9tdWwuanMnICksXG4gICAgbWVtbyAgICA9IHJlcXVpcmUoICcuL21lbW8uanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSApID0+IHtcbiAgbGV0IHgxID0gaGlzdG9yeSgpLFxuICAgICAgeTEgPSBoaXN0b3J5KCksXG4gICAgICBmaWx0ZXJcblxuICAvL0hpc3RvcnkgeDEsIHkxOyB5ID0gaW4xIC0geDEgKyB5MSowLjk5OTc7IHgxID0gaW4xOyB5MSA9IHk7IG91dDEgPSB5O1xuICBmaWx0ZXIgPSBtZW1vKCBhZGQoIHN1YiggaW4xLCB4MS5vdXQgKSwgbXVsKCB5MS5vdXQsIC45OTk3ICkgKSApXG4gIHgxLmluKCBpbjEgKVxuICB5MS5pbiggZmlsdGVyIClcblxuICByZXR1cm4gZmlsdGVyXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgaGlzdG9yeSA9IHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gICAgbXVsICAgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICB0NjAgICAgID0gcmVxdWlyZSggJy4vdDYwLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gKCBkZWNheVRpbWUgPSA0NDEwMCwgcHJvcHMgKSA9PiB7XG4gIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBpbml0VmFsdWU6MSB9LCBwcm9wcyApLFxuICAgICAgc3NkID0gaGlzdG9yeSAoIHByb3BlcnRpZXMuaW5pdFZhbHVlIClcblxuICBzc2QuaW4oIG11bCggc3NkLm91dCwgdDYwKCBkZWNheVRpbWUgKSApIClcblxuICBzc2Qub3V0LnRyaWdnZXIgPSAoKT0+IHtcbiAgICBzc2QudmFsdWUgPSAxXG4gIH1cblxuICByZXR1cm4gc3NkLm91dCBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBnZW4gID0gcmVxdWlyZSggJy4vZ2VuLmpzJyAgKSxcbiAgICAgIGRhdGEgPSByZXF1aXJlKCAnLi9kYXRhLmpzJyApLFxuICAgICAgcG9rZSA9IHJlcXVpcmUoICcuL3Bva2UuanMnICksXG4gICAgICBwZWVrID0gcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgICAgIHN1YiAgPSByZXF1aXJlKCAnLi9zdWIuanMnICApLFxuICAgICAgd3JhcCA9IHJlcXVpcmUoICcuL3dyYXAuanMnICksXG4gICAgICBhY2N1bT0gcmVxdWlyZSggJy4vYWNjdW0uanMnKSxcbiAgICAgIG1lbW8gPSByZXF1aXJlKCAnLi9tZW1vLmpzJyApXG5cbmNvbnN0IHByb3RvID0ge1xuICBiYXNlbmFtZTonZGVsYXknLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gaW5wdXRzWzBdXG4gICAgXG4gICAgcmV0dXJuIGlucHV0c1swXVxuICB9LFxufVxuXG5jb25zdCBkZWZhdWx0cyA9IHsgc2l6ZTogNTEyLCBpbnRlcnA6J25vbmUnIH1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgdGFwcywgcHJvcGVydGllcyApID0+IHtcbiAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgbGV0IHdyaXRlSWR4LCByZWFkSWR4LCBkZWxheWRhdGFcblxuICBpZiggQXJyYXkuaXNBcnJheSggdGFwcyApID09PSBmYWxzZSApIHRhcHMgPSBbIHRhcHMgXVxuICBcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdHMsIHByb3BlcnRpZXMgKVxuXG4gIGNvbnN0IG1heFRhcFNpemUgPSBNYXRoLm1heCggLi4udGFwcyApXG4gIGlmKCBwcm9wcy5zaXplIDwgbWF4VGFwU2l6ZSApIHByb3BzLnNpemUgPSBtYXhUYXBTaXplXG5cbiAgZGVsYXlkYXRhID0gZGF0YSggcHJvcHMuc2l6ZSApXG4gIFxuICB1Z2VuLmlucHV0cyA9IFtdXG5cbiAgd3JpdGVJZHggPSBhY2N1bSggMSwgMCwgeyBtYXg6cHJvcHMuc2l6ZSwgbWluOjAgfSlcbiAgXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgdGFwcy5sZW5ndGg7IGkrKyApIHtcbiAgICB1Z2VuLmlucHV0c1sgaSBdID0gcGVlayggZGVsYXlkYXRhLCB3cmFwKCBzdWIoIHdyaXRlSWR4LCB0YXBzW2ldICksIDAsIHByb3BzLnNpemUgKSx7IG1vZGU6J3NhbXBsZXMnLCBpbnRlcnA6cHJvcHMuaW50ZXJwIH0pXG4gIH1cbiAgXG4gIHVnZW4ub3V0cHV0cyA9IHVnZW4uaW5wdXRzIC8vIFhYWCB1Z2gsIFVnaCwgVUdIISBidXQgaSBndWVzcyBpdCB3b3Jrcy5cblxuICBwb2tlKCBkZWxheWRhdGEsIGluMSwgd3JpdGVJZHggKVxuXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHtnZW4uZ2V0VUlEKCl9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgaGlzdG9yeSA9IHJlcXVpcmUoICcuL2hpc3RvcnkuanMnICksXG4gICAgc3ViICAgICA9IHJlcXVpcmUoICcuL3N1Yi5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xICkgPT4ge1xuICBsZXQgbjEgPSBoaXN0b3J5KClcbiAgICBcbiAgbjEuaW4oIGluMSApXG5cbiAgbGV0IHVnZW4gPSBzdWIoIGluMSwgbjEub3V0IClcbiAgdWdlbi5uYW1lID0gJ2RlbHRhJytnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmNvbnN0IHByb3RvID0ge1xuICBiYXNlbmFtZTonZGl2JyxcbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIG91dD1gICB2YXIgJHt0aGlzLm5hbWV9ID0gYCxcbiAgICAgICAgZGlmZiA9IDAsIFxuICAgICAgICBudW1Db3VudCA9IDAsXG4gICAgICAgIGxhc3ROdW1iZXIgPSBpbnB1dHNbIDAgXSxcbiAgICAgICAgbGFzdE51bWJlcklzVWdlbiA9IGlzTmFOKCBsYXN0TnVtYmVyICksIFxuICAgICAgICBkaXZBdEVuZCA9IGZhbHNlXG5cbiAgICBpbnB1dHMuZm9yRWFjaCggKHYsaSkgPT4ge1xuICAgICAgaWYoIGkgPT09IDAgKSByZXR1cm5cblxuICAgICAgbGV0IGlzTnVtYmVyVWdlbiA9IGlzTmFOKCB2ICksXG4gICAgICAgIGlzRmluYWxJZHggICA9IGkgPT09IGlucHV0cy5sZW5ndGggLSAxXG5cbiAgICAgIGlmKCAhbGFzdE51bWJlcklzVWdlbiAmJiAhaXNOdW1iZXJVZ2VuICkge1xuICAgICAgICBsYXN0TnVtYmVyID0gbGFzdE51bWJlciAvIHZcbiAgICAgICAgb3V0ICs9IGxhc3ROdW1iZXJcbiAgICAgIH1lbHNle1xuICAgICAgICBvdXQgKz0gYCR7bGFzdE51bWJlcn0gLyAke3Z9YFxuICAgICAgfVxuXG4gICAgICBpZiggIWlzRmluYWxJZHggKSBvdXQgKz0gJyAvICcgXG4gICAgfSlcblxuICAgIG91dCArPSAnXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBkaXYgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIFxuICBPYmplY3QuYXNzaWduKCBkaXYsIHtcbiAgICBpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6IGFyZ3MsXG4gIH0pXG5cbiAgZGl2Lm5hbWUgPSBkaXYuYmFzZW5hbWUgKyBkaXYuaWRcbiAgXG4gIHJldHVybiBkaXZcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbicgKSxcbiAgICB3aW5kb3dzID0gcmVxdWlyZSggJy4vd2luZG93cycgKSxcbiAgICBkYXRhICAgID0gcmVxdWlyZSggJy4vZGF0YScgKSxcbiAgICBwZWVrICAgID0gcmVxdWlyZSggJy4vcGVlaycgKSxcbiAgICBwaGFzb3IgID0gcmVxdWlyZSggJy4vcGhhc29yJyApLFxuICAgIGRlZmF1bHRzID0ge1xuICAgICAgdHlwZTondHJpYW5ndWxhcicsIGxlbmd0aDoxMDI0LCBhbHBoYTouMTUsIHNoaWZ0OjAsIHJldmVyc2U6ZmFsc2UgXG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BzID0+IHtcbiAgXG4gIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHRzLCBwcm9wcyApXG4gIGxldCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCBwcm9wZXJ0aWVzLmxlbmd0aCApXG5cbiAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzLnR5cGUgKyAnXycgKyBwcm9wZXJ0aWVzLmxlbmd0aCArICdfJyArIHByb3BlcnRpZXMuc2hpZnQgKyAnXycgKyBwcm9wZXJ0aWVzLnJldmVyc2UgKyAnXycgKyBwcm9wZXJ0aWVzLmFscGhhXG4gIGlmKCB0eXBlb2YgZ2VuLmdsb2JhbHMud2luZG93c1sgbmFtZSBdID09PSAndW5kZWZpbmVkJyApIHsgXG5cbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBidWZmZXJbIGkgXSA9IHdpbmRvd3NbIHByb3BlcnRpZXMudHlwZSBdKCBwcm9wZXJ0aWVzLmxlbmd0aCwgaSwgcHJvcGVydGllcy5hbHBoYSwgcHJvcGVydGllcy5zaGlmdCApXG4gICAgfVxuXG4gICAgaWYoIHByb3BlcnRpZXMucmV2ZXJzZSA9PT0gdHJ1ZSApIHsgXG4gICAgICBidWZmZXIucmV2ZXJzZSgpXG4gICAgfVxuICAgIGdlbi5nbG9iYWxzLndpbmRvd3NbIG5hbWUgXSA9IGRhdGEoIGJ1ZmZlciApXG4gIH1cblxuICBsZXQgdWdlbiA9IGdlbi5nbG9iYWxzLndpbmRvd3NbIG5hbWUgXSBcbiAgdWdlbi5uYW1lID0gJ2VudicgKyBnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonZXEnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIG91dCA9IHRoaXMuaW5wdXRzWzBdID09PSB0aGlzLmlucHV0c1sxXSA/IDEgOiBgICB2YXIgJHt0aGlzLm5hbWV9ID0gKCR7aW5wdXRzWzBdfSA9PT0gJHtpbnB1dHNbMV19KSB8IDBcXG5cXG5gXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgJHt0aGlzLm5hbWV9YFxuXG4gICAgcmV0dXJuIFsgYCR7dGhpcy5uYW1lfWAsIG91dCBdXG4gIH0sXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgaW4yICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICBbIGluMSwgaW4yIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonZXhwJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiBpc1dvcmtsZXQgPyAnTWF0aC5leHAnIDogTWF0aC5leHAgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfWV4cCggJHtpbnB1dHNbMF19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5leHAoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCBleHAgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgZXhwLmlucHV0cyA9IFsgeCBdXG5cbiAgcmV0dXJuIGV4cFxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mXG4gKiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVRcbiAqIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZVxuICogTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXJcbiAqIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIG9yaWdpbmFsbHkgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL2F1ZGlvd29ya2xldC1wb2x5ZmlsbFxuLy8gSSBhbSBtb2RpZnlpbmcgaXQgdG8gYWNjZXB0IHZhcmlhYmxlIGJ1ZmZlciBzaXplc1xuLy8gYW5kIHRvIGdldCByaWQgb2Ygc29tZSBzdHJhbmdlIGdsb2JhbCBpbml0aWFsaXphdGlvbiB0aGF0IHNlZW1zIHJlcXVpcmVkIHRvIHVzZSBpdFxuLy8gd2l0aCBicm93c2VyaWZ5LiBBbHNvLCBJIGFkZGVkIGNoYW5nZXMgdG8gZml4IGEgYnVnIGluIFNhZmFyaSBmb3IgdGhlIEF1ZGlvV29ya2xldFByb2Nlc3NvclxuLy8gcHJvcGVydHkgbm90IGhhdmluZyBhIHByb3RvdHlwZSAoc2VlOmh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL2F1ZGlvd29ya2xldC1wb2x5ZmlsbC9wdWxsLzI1KVxuLy8gVE9ETzogV2h5IGlzIHRoZXJlIGFuIGlmcmFtZSBpbnZvbHZlZD8gKHJlYWxtLmpzKVxuXG5jb25zdCBSZWFsbSA9IHJlcXVpcmUoICcuL3JlYWxtLmpzJyApXG5cbmNvbnN0IEFXUEYgPSBmdW5jdGlvbiggc2VsZiA9IHdpbmRvdywgYnVmZmVyU2l6ZSA9IDQwOTYgKSB7XG4gIGNvbnN0IFBBUkFNUyA9IFtdXG4gIGxldCBuZXh0UG9ydFxuXG4gIGlmICh0eXBlb2YgQXVkaW9Xb3JrbGV0Tm9kZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhKFwiYXVkaW9Xb3JrbGV0XCIgaW4gQXVkaW9Db250ZXh0LnByb3RvdHlwZSkpIHtcbiAgICBzZWxmLkF1ZGlvV29ya2xldE5vZGUgPSBmdW5jdGlvbiBBdWRpb1dvcmtsZXROb2RlIChjb250ZXh0LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBwcm9jZXNzb3IgPSBnZXRQcm9jZXNzb3JzRm9yQ29udGV4dChjb250ZXh0KVtuYW1lXTtcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzID0gb3B0aW9ucyAmJiBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCA/IG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50WzBdIDogMjtcbiAgICAgIGNvbnN0IHNjcmlwdFByb2Nlc3NvciA9IGNvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKCBidWZmZXJTaXplLCAyLCBvdXRwdXRDaGFubmVscyk7XG5cbiAgICAgIHNjcmlwdFByb2Nlc3Nvci5wYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKHByb2Nlc3Nvci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvY2Vzc29yLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwcm9wID0gcHJvY2Vzc29yLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpLmdhaW47XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IHByb3AuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIC8vIEBUT0RPIHRoZXJlJ3Mgbm8gZ29vZCB3YXkgdG8gY29uc3RydWN0IHRoZSBwcm94eSBBdWRpb1BhcmFtIGhlcmVcbiAgICAgICAgICBzY3JpcHRQcm9jZXNzb3IucGFyYW1ldGVycy5zZXQocHJvcC5uYW1lLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtYyA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgbmV4dFBvcnQgPSBtYy5wb3J0MjtcbiAgICAgIGNvbnN0IGluc3QgPSBuZXcgcHJvY2Vzc29yLlByb2Nlc3NvcihvcHRpb25zIHx8IHt9KTtcbiAgICAgIG5leHRQb3J0ID0gbnVsbDtcblxuICAgICAgc2NyaXB0UHJvY2Vzc29yLnBvcnQgPSBtYy5wb3J0MTtcbiAgICAgIHNjcmlwdFByb2Nlc3Nvci5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICBzY3JpcHRQcm9jZXNzb3IuaW5zdGFuY2UgPSBpbnN0O1xuICAgICAgc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gb25BdWRpb1Byb2Nlc3M7XG4gICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yO1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoKHNlbGYuQXVkaW9Db250ZXh0IHx8IHNlbGYud2Via2l0QXVkaW9Db250ZXh0KS5wcm90b3R5cGUsICdhdWRpb1dvcmtsZXQnLCB7XG4gICAgICBnZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kJGF1ZGlvV29ya2xldCB8fCAodGhpcy4kJGF1ZGlvV29ya2xldCA9IG5ldyBzZWxmLkF1ZGlvV29ya2xldCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBYWFggLSBBRERFRCBUTyBPVkVSQ09NRSBQUk9CTEVNIElOIFNBRkFSSSBXSEVSRSBBVURJT1dPUktMRVRQUk9DRVNTT1IgUFJPVE9UWVBFIElTIE5PVCBBTiBPQkpFQ1QgKi9cbiAgICBjb25zdCBBdWRpb1dvcmtsZXRQcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucG9ydCA9IG5leHRQb3J0XG4gICAgfVxuICAgIEF1ZGlvV29ya2xldFByb2Nlc3Nvci5wcm90b3R5cGUgPSB7fVxuXG4gICAgc2VsZi5BdWRpb1dvcmtsZXQgPSBjbGFzcyBBdWRpb1dvcmtsZXQge1xuICAgICAgY29uc3RydWN0b3IgKGF1ZGlvQ29udGV4dCkge1xuICAgICAgICB0aGlzLiQkY29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICAgIH1cblxuICAgICAgYWRkTW9kdWxlICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbihyID0+IHtcbiAgICAgICAgICBpZiAoIXIub2spIHRocm93IEVycm9yKHIuc3RhdHVzKTtcbiAgICAgICAgICByZXR1cm4gci50ZXh0KCk7XG4gICAgICAgIH0pLnRoZW4oIGNvZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLiQkY29udGV4dC5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6IHRoaXMuJCRjb250ZXh0LmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yLFxuICAgICAgICAgICAgcmVnaXN0ZXJQcm9jZXNzb3I6IChuYW1lLCBQcm9jZXNzb3IpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29ycyA9IGdldFByb2Nlc3NvcnNGb3JDb250ZXh0KHRoaXMuJCRjb250ZXh0KTtcbiAgICAgICAgICAgICAgcHJvY2Vzc29yc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICByZWFsbSxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIFByb2Nlc3NvcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBQcm9jZXNzb3IucGFyYW1ldGVyRGVzY3JpcHRvcnMgfHwgW11cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29udGV4dC5zZWxmID0gY29udGV4dDtcbiAgICAgICAgICBjb25zdCByZWFsbSA9IG5ldyBSZWFsbShjb250ZXh0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgIHJlYWxtLmV4ZWMoKChvcHRpb25zICYmIG9wdGlvbnMudHJhbnNwaWxlKSB8fCBTdHJpbmcpKGNvZGUpKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXVkaW9Qcm9jZXNzIChlKSB7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIHRoaXMucGFyYW1ldGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBQQVJBTVNbKytpbmRleF0gfHwgKFBBUkFNU1tpbmRleF0gPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYnVmZmVyU2l6ZSkpO1xuICAgICAgLy8gQFRPRE8gcHJvcGVyIHZhbHVlcyBoZXJlIGlmIHBvc3NpYmxlXG4gICAgICBhcnIuZmlsbCh2YWx1ZS52YWx1ZSk7XG4gICAgICBwYXJhbWV0ZXJzW2tleV0gPSBhcnI7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9jZXNzb3IucmVhbG0uZXhlYyhcbiAgICAgICdzZWxmLnNhbXBsZVJhdGU9c2FtcGxlUmF0ZT0nICsgdGhpcy5jb250ZXh0LnNhbXBsZVJhdGUgKyAnOycgK1xuICAgICAgJ3NlbGYuY3VycmVudFRpbWU9Y3VycmVudFRpbWU9JyArIHRoaXMuY29udGV4dC5jdXJyZW50VGltZVxuICAgICk7XG4gICAgY29uc3QgaW5wdXRzID0gY2hhbm5lbFRvQXJyYXkoZS5pbnB1dEJ1ZmZlcik7XG4gICAgY29uc3Qgb3V0cHV0cyA9IGNoYW5uZWxUb0FycmF5KGUub3V0cHV0QnVmZmVyKTtcbiAgICB0aGlzLmluc3RhbmNlLnByb2Nlc3MoW2lucHV0c10sIFtvdXRwdXRzXSwgcGFyYW1ldGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFubmVsVG9BcnJheSAoY2gpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuICAgICAgb3V0W2ldID0gY2guZ2V0Q2hhbm5lbERhdGEoaSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9jZXNzb3JzRm9yQ29udGV4dCAoYXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuIGF1ZGlvQ29udGV4dC4kJHByb2Nlc3NvcnMgfHwgKGF1ZGlvQ29udGV4dC4kJHByb2Nlc3NvcnMgPSB7fSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBV1BGXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdFxuICogdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVFxuICogV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxuICogdGhlIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWFsbSAoc2NvcGUsIHBhcmVudEVsZW1lbnQpIHtcbiAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgZnJhbWUuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOi05OTlweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGZyYW1lKTtcbiAgY29uc3Qgd2luID0gZnJhbWUuY29udGVudFdpbmRvdztcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICBsZXQgdmFycyA9ICd2YXIgd2luZG93LCRob29rJztcbiAgZm9yIChjb25zdCBpIGluIHdpbikge1xuICAgIGlmICghKGkgaW4gc2NvcGUpICYmIGkgIT09ICdldmFsJykge1xuICAgICAgdmFycyArPSAnLCc7XG4gICAgICB2YXJzICs9IGk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaSBpbiBzY29wZSkge1xuICAgIHZhcnMgKz0gJywnO1xuICAgIHZhcnMgKz0gaTtcbiAgICB2YXJzICs9ICc9c2VsZi4nO1xuICAgIHZhcnMgKz0gaTtcbiAgfVxuICBjb25zdCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXG4gICAgYGZ1bmN0aW9uICRob29rKHNlbGYsY29uc29sZSkge1widXNlIHN0cmljdFwiO1xuICAgICAgICAke3ZhcnN9O3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gZXZhbChhcmd1bWVudHNbMF0pfX1gXG4gICkpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB0aGlzLmV4ZWMgPSB3aW4uJGhvb2suY2FsbChzY29wZSwgc2NvcGUsIGNvbnNvbGUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2Zsb29yJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgLy9nZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogTWF0aC5mbG9vciB9KVxuXG4gICAgICBvdXQgPSBgKCAke2lucHV0c1swXX0gfCAwIClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gaW5wdXRzWzBdIHwgMFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IGZsb29yID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGZsb29yLmlucHV0cyA9IFsgeCBdXG5cbiAgcmV0dXJuIGZsb29yXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2ZvbGQnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgY29kZSxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXRcblxuICAgIG91dCA9IHRoaXMuY3JlYXRlQ2FsbGJhY2soIGlucHV0c1swXSwgdGhpcy5taW4sIHRoaXMubWF4ICkgXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWUgKyAnX3ZhbHVlJ1xuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lICsgJ192YWx1ZScsIG91dCBdXG4gIH0sXG5cbiAgY3JlYXRlQ2FsbGJhY2soIHYsIGxvLCBoaSApIHtcbiAgICBsZXQgb3V0ID1cbmAgdmFyICR7dGhpcy5uYW1lfV92YWx1ZSA9ICR7dn0sXG4gICAgICAke3RoaXMubmFtZX1fcmFuZ2UgPSAke2hpfSAtICR7bG99LFxuICAgICAgJHt0aGlzLm5hbWV9X251bVdyYXBzID0gMFxuXG4gIGlmKCR7dGhpcy5uYW1lfV92YWx1ZSA+PSAke2hpfSl7XG4gICAgJHt0aGlzLm5hbWV9X3ZhbHVlIC09ICR7dGhpcy5uYW1lfV9yYW5nZVxuICAgIGlmKCR7dGhpcy5uYW1lfV92YWx1ZSA+PSAke2hpfSl7XG4gICAgICAke3RoaXMubmFtZX1fbnVtV3JhcHMgPSAoKCR7dGhpcy5uYW1lfV92YWx1ZSAtICR7bG99KSAvICR7dGhpcy5uYW1lfV9yYW5nZSkgfCAwXG4gICAgICAke3RoaXMubmFtZX1fdmFsdWUgLT0gJHt0aGlzLm5hbWV9X3JhbmdlICogJHt0aGlzLm5hbWV9X251bVdyYXBzXG4gICAgfVxuICAgICR7dGhpcy5uYW1lfV9udW1XcmFwcysrXG4gIH0gZWxzZSBpZigke3RoaXMubmFtZX1fdmFsdWUgPCAke2xvfSl7XG4gICAgJHt0aGlzLm5hbWV9X3ZhbHVlICs9ICR7dGhpcy5uYW1lfV9yYW5nZVxuICAgIGlmKCR7dGhpcy5uYW1lfV92YWx1ZSA8ICR7bG99KXtcbiAgICAgICR7dGhpcy5uYW1lfV9udW1XcmFwcyA9ICgoJHt0aGlzLm5hbWV9X3ZhbHVlIC0gJHtsb30pIC8gJHt0aGlzLm5hbWV9X3JhbmdlLSAxKSB8IDBcbiAgICAgICR7dGhpcy5uYW1lfV92YWx1ZSAtPSAke3RoaXMubmFtZX1fcmFuZ2UgKiAke3RoaXMubmFtZX1fbnVtV3JhcHNcbiAgICB9XG4gICAgJHt0aGlzLm5hbWV9X251bVdyYXBzLS1cbiAgfVxuICBpZigke3RoaXMubmFtZX1fbnVtV3JhcHMgJiAxKSAke3RoaXMubmFtZX1fdmFsdWUgPSAke2hpfSArICR7bG99IC0gJHt0aGlzLm5hbWV9X3ZhbHVlXG5gXG4gICAgcmV0dXJuICcgJyArIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBpbjEsIG1pbj0wLCBtYXg9MSApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBcbiAgICBtaW4sIFxuICAgIG1heCxcbiAgICB1aWQ6ICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6IFsgaW4xIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidnYXRlJyxcbiAgY29udHJvbFN0cmluZzpudWxsLCAvLyBpbnNlcnQgaW50byBvdXRwdXQgY29kZWdlbiBmb3IgZGV0ZXJtaW5pbmcgaW5kZXhpbmdcbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksIG91dFxuICAgIFxuICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG4gICAgXG4gICAgbGV0IGxhc3RJbnB1dE1lbW9yeUlkeCA9ICdtZW1vcnlbICcgKyB0aGlzLm1lbW9yeS5sYXN0SW5wdXQuaWR4ICsgJyBdJyxcbiAgICAgICAgb3V0cHV0TWVtb3J5U3RhcnRJZHggPSB0aGlzLm1lbW9yeS5sYXN0SW5wdXQuaWR4ICsgMSxcbiAgICAgICAgaW5wdXRTaWduYWwgPSBpbnB1dHNbMF0sXG4gICAgICAgIGNvbnRyb2xTaWduYWwgPSBpbnB1dHNbMV1cbiAgICBcbiAgICAvKiBcbiAgICAgKiB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgY29udHJvbCBpbnB1dHMgZXF1YWxzIG91ciBsYXN0IGlucHV0XG4gICAgICogaWYgc28sIHdlIHN0b3JlIHRoZSBzaWduYWwgaW5wdXQgaW4gdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseVxuICAgICAqIHNlbGVjdGVkIGluZGV4LiBJZiBub3QsIHdlIHB1dCAwIGluIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXN0IHNlbGVjdGVkIGluZGV4LFxuICAgICAqIGNoYW5nZSB0aGUgc2VsZWN0ZWQgaW5kZXgsIGFuZCB0aGVuIHN0b3JlIHRoZSBzaWduYWwgaW4gcHV0IGluIHRoZSBtZW1lcnkgYXNzb2ljYXRlZFxuICAgICAqIHdpdGggdGhlIG5ld2x5IHNlbGVjdGVkIGluZGV4XG4gICAgICovXG4gICAgXG4gICAgb3V0ID1cblxuYCBpZiggJHtjb250cm9sU2lnbmFsfSAhPT0gJHtsYXN0SW5wdXRNZW1vcnlJZHh9ICkge1xuICAgIG1lbW9yeVsgJHtsYXN0SW5wdXRNZW1vcnlJZHh9ICsgJHtvdXRwdXRNZW1vcnlTdGFydElkeH0gIF0gPSAwIFxuICAgICR7bGFzdElucHV0TWVtb3J5SWR4fSA9ICR7Y29udHJvbFNpZ25hbH1cbiAgfVxuICBtZW1vcnlbICR7b3V0cHV0TWVtb3J5U3RhcnRJZHh9ICsgJHtjb250cm9sU2lnbmFsfSBdID0gJHtpbnB1dFNpZ25hbH1cblxuYFxuICAgIHRoaXMuY29udHJvbFN0cmluZyA9IGlucHV0c1sxXVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWVcblxuICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKCB2ID0+IHYuZ2VuKCkgKVxuXG4gICAgcmV0dXJuIFsgbnVsbCwgJyAnICsgb3V0IF1cbiAgfSxcblxuICBjaGlsZGdlbigpIHtcbiAgICBpZiggdGhpcy5wYXJlbnQuaW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xuICAgICAgZ2VuLmdldElucHV0cyggdGhpcyApIC8vIHBhcmVudCBnYXRlIGlzIG9ubHkgaW5wdXQgb2YgYSBnYXRlIG91dHB1dCwgc2hvdWxkIG9ubHkgYmUgZ2VuJ2Qgb25jZS5cbiAgICB9XG5cbiAgICBpZiggZ2VuLm1lbW9bIHRoaXMubmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5tZW1vcnkgKVxuXG4gICAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgbWVtb3J5WyAke3RoaXMubWVtb3J5LnZhbHVlLmlkeH0gXWBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICBgbWVtb3J5WyAke3RoaXMubWVtb3J5LnZhbHVlLmlkeH0gXWBcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggY29udHJvbCwgaW4xLCBwcm9wZXJ0aWVzICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICksXG4gICAgICBkZWZhdWx0cyA9IHsgY291bnQ6IDIgfVxuXG4gIGlmKCB0eXBlb2YgcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICkgT2JqZWN0LmFzc2lnbiggZGVmYXVsdHMsIHByb3BlcnRpZXMgKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICBvdXRwdXRzOiBbXSxcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBpbjEsIGNvbnRyb2wgXSxcbiAgICBtZW1vcnk6IHtcbiAgICAgIGxhc3RJbnB1dDogeyBsZW5ndGg6MSwgaWR4Om51bGwgfVxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZWQ6ZmFsc2VcbiAgfSxcbiAgZGVmYXVsdHMgKVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke2dlbi5nZXRVSUQoKX1gXG5cbiAgZm9yKCBsZXQgaSA9IDA7IGkgPCB1Z2VuLmNvdW50OyBpKysgKSB7XG4gICAgdWdlbi5vdXRwdXRzLnB1c2goe1xuICAgICAgaW5kZXg6aSxcbiAgICAgIGdlbjogcHJvdG8uY2hpbGRnZW4sXG4gICAgICBwYXJlbnQ6dWdlbixcbiAgICAgIGlucHV0czogWyB1Z2VuIF0sXG4gICAgICBtZW1vcnk6IHtcbiAgICAgICAgdmFsdWU6IHsgbGVuZ3RoOjEsIGlkeDpudWxsIH1cbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplZDpmYWxzZSxcbiAgICAgIG5hbWU6IGAke3VnZW4ubmFtZX1fb3V0JHtnZW4uZ2V0VUlEKCl9YFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qIGdlbi5qc1xuICpcbiAqIGxvdy1sZXZlbCBjb2RlIGdlbmVyYXRpb24gZm9yIHVuaXQgZ2VuZXJhdG9yc1xuICpcbiAqL1xuY29uc3QgTWVtb3J5SGVscGVyID0gcmVxdWlyZSggJ21lbW9yeS1oZWxwZXInIClcbmNvbnN0IEVFID0gcmVxdWlyZSggJ2V2ZW50cycgKS5FdmVudEVtaXR0ZXJcblxuY29uc3QgZ2VuID0ge1xuXG4gIGFjY3VtOjAsXG4gIGdldFVJRCgpIHsgcmV0dXJuIHRoaXMuYWNjdW0rKyB9LFxuICBkZWJ1ZzpmYWxzZSxcbiAgc2FtcGxlcmF0ZTogNDQxMDAsIC8vIGNoYW5nZSBvbiBhdWRpb2NvbnRleHQgY3JlYXRpb25cbiAgc2hvdWxkTG9jYWxpemU6IGZhbHNlLFxuICBncmFwaDpudWxsLFxuICBnbG9iYWxzOntcbiAgICB3aW5kb3dzOiB7fSxcbiAgfSxcbiAgbW9kZTond29ya2xldCcsXG4gIFxuICAvKiBjbG9zdXJlc1xuICAgKlxuICAgKiBGdW5jdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgYXMgYXJndW1lbnRzIHRvIG1hc3RlciBjYWxsYmFjay4gRXhhbXBsZXM6IE1hdGguYWJzLCBNYXRoLnJhbmRvbSBldGMuXG4gICAqIFhYWCBTaG91bGQgcHJvYmFibHkgYmUgcmVuYW1lZCBjYWxsYmFja1Byb3BlcnRpZXMgb3Igc29tZXRoaW5nIHNpbWlsYXIuLi4gY2xvc3VyZXMgYXJlIG5vIGxvbmdlciB1c2VkLlxuICAgKi9cblxuICBjbG9zdXJlczogbmV3IFNldCgpLFxuICBwYXJhbXM6ICAgbmV3IFNldCgpLFxuICBpbnB1dHM6ICAgbmV3IFNldCgpLFxuXG4gIHBhcmFtZXRlcnM6IG5ldyBTZXQoKSxcbiAgZW5kQmxvY2s6IG5ldyBTZXQoKSxcbiAgaGlzdG9yaWVzOiBuZXcgTWFwKCksXG5cbiAgbWVtbzoge30sXG5cbiAgLy9kYXRhOiB7fSxcbiAgXG4gIC8qIGV4cG9ydFxuICAgKlxuICAgKiBwbGFjZSBnZW4gZnVuY3Rpb25zIGludG8gYW5vdGhlciBvYmplY3QgZm9yIGVhc2llciByZWZlcmVuY2VcbiAgICovXG5cbiAgZXhwb3J0KCBvYmogKSB7fSxcblxuICBhZGRUb0VuZEJsb2NrKCB2ICkge1xuICAgIHRoaXMuZW5kQmxvY2suYWRkKCAnICAnICsgdiApXG4gIH0sXG4gIFxuICByZXF1ZXN0TWVtb3J5KCBtZW1vcnlTcGVjLCBpbW11dGFibGU9ZmFsc2UgKSB7XG4gICAgZm9yKCBsZXQga2V5IGluIG1lbW9yeVNwZWMgKSB7XG4gICAgICBsZXQgcmVxdWVzdCA9IG1lbW9yeVNwZWNbIGtleSBdXG5cbiAgICAgIC8vY29uc29sZS5sb2coICdyZXF1ZXN0aW5nICcgKyBrZXkgKyAnOicgLCBKU09OLnN0cmluZ2lmeSggcmVxdWVzdCApIClcblxuICAgICAgaWYoIHJlcXVlc3QubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCAndW5kZWZpbmVkIGxlbmd0aCBmb3I6Jywga2V5IClcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmlkeCA9IGdlbi5tZW1vcnkuYWxsb2MoIHJlcXVlc3QubGVuZ3RoLCBpbW11dGFibGUgKVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVNZW1vcnkoIGFtb3VudD00MDk2LCB0eXBlICkge1xuICAgIGNvbnN0IG1lbSA9IE1lbW9yeUhlbHBlci5jcmVhdGUoIGFtb3VudCwgdHlwZSApXG4gICAgcmV0dXJuIG1lbVxuICB9LFxuXG4gIGNyZWF0ZUNhbGxiYWNrKCB1Z2VuLCBtZW0sIGRlYnVnID0gZmFsc2UsIHNob3VsZElubGluZU1lbW9yeT1mYWxzZSwgbWVtVHlwZSA9IEZsb2F0NjRBcnJheSApIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBBcnJheS5pc0FycmF5KCB1Z2VuICkgJiYgdWdlbi5sZW5ndGggPiAxLFxuICAgICAgICBjYWxsYmFjaywgXG4gICAgICAgIGNoYW5uZWwxLCBjaGFubmVsMlxuXG4gICAgaWYoIHR5cGVvZiBtZW0gPT09ICdudW1iZXInIHx8IG1lbSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgdGhpcy5tZW1vcnkgPSB0aGlzLmNyZWF0ZU1lbW9yeSggbWVtLCBtZW1UeXBlIClcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMubWVtb3J5ID0gbWVtXG4gICAgfVxuICAgIFxuICAgIHRoaXMub3V0cHV0SWR4ID0gdGhpcy5tZW1vcnkuYWxsb2MoIDIsIHRydWUgKVxuICAgIHRoaXMuZW1pdCggJ21lbW9yeSBpbml0JyApXG5cbiAgICAvL2NvbnNvbGUubG9nKCAnY2IgbWVtb3J5OicsIG1lbSApXG4gICAgdGhpcy5ncmFwaCA9IHVnZW5cbiAgICB0aGlzLm1lbW8gPSB7fSBcbiAgICB0aGlzLmVuZEJsb2NrLmNsZWFyKClcbiAgICB0aGlzLmNsb3N1cmVzLmNsZWFyKClcbiAgICB0aGlzLmlucHV0cy5jbGVhcigpXG4gICAgdGhpcy5wYXJhbXMuY2xlYXIoKVxuICAgIHRoaXMuZ2xvYmFscyA9IHsgd2luZG93czp7fSB9XG4gICAgXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmNsZWFyKClcbiAgICBcbiAgICB0aGlzLmZ1bmN0aW9uQm9keSA9IFwiICAndXNlIHN0cmljdCdcXG5cIlxuICAgIGlmKCBzaG91bGRJbmxpbmVNZW1vcnk9PT1mYWxzZSApIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25Cb2R5ICs9IHRoaXMubW9kZSA9PT0gJ3dvcmtsZXQnID8gXG4gICAgICAgIFwiICB2YXIgbWVtb3J5ID0gdGhpcy5tZW1vcnlcXG5cXG5cIiA6XG4gICAgICAgIFwiICB2YXIgbWVtb3J5ID0gZ2VuLm1lbW9yeVxcblxcblwiXG4gICAgfVxuXG4gICAgLy8gY2FsbCAuZ2VuKCkgb24gdGhlIGhlYWQgb2YgdGhlIGdyYXBoIHdlIGFyZSBnZW5lcmF0aW5nIHRoZSBjYWxsYmFjayBmb3JcbiAgICAvL2NvbnNvbGUubG9nKCAnSEVBRCcsIHVnZW4gKVxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgMSArIGlzU3RlcmVvOyBpKysgKSB7XG4gICAgICBpZiggdHlwZW9mIHVnZW5baV0gPT09ICdudW1iZXInICkgY29udGludWVcblxuICAgICAgLy9sZXQgY2hhbm5lbCA9IGlzU3RlcmVvID8gdWdlbltpXS5nZW4oKSA6IHVnZW4uZ2VuKCksXG4gICAgICBsZXQgY2hhbm5lbCA9IGlzU3RlcmVvID8gdGhpcy5nZXRJbnB1dCggdWdlbltpXSApIDogdGhpcy5nZXRJbnB1dCggdWdlbiApLCBcbiAgICAgICAgICBib2R5ID0gJydcblxuICAgICAgLy8gaWYgLmdlbigpIHJldHVybnMgYXJyYXksIGFkZCB1Z2VuIGNhbGxiYWNrIChncmFwaE91dHB1dFsxXSkgdG8gb3VyIG91dHB1dCBmdW5jdGlvbnMgYm9keVxuICAgICAgLy8gYW5kIHRoZW4gcmV0dXJuIG5hbWUgb2YgdWdlbi4gSWYgLmdlbigpIG9ubHkgZ2VuZXJhdGVzIGEgbnVtYmVyIChmb3IgcmVhbGx5IHNpbXBsZSBncmFwaHMpXG4gICAgICAvLyBqdXN0IHJldHVybiB0aGF0IG51bWJlciAoZ3JhcGhPdXRwdXRbMF0pLlxuICAgICAgYm9keSArPSBBcnJheS5pc0FycmF5KCBjaGFubmVsICkgPyBjaGFubmVsWzFdICsgJ1xcbicgKyBjaGFubmVsWzBdIDogY2hhbm5lbFxuXG4gICAgICAvLyBzcGxpdCBib2R5IHRvIGluamVjdCByZXR1cm4ga2V5d29yZCBvbiBsYXN0IGxpbmVcbiAgICAgIGJvZHkgPSBib2R5LnNwbGl0KCdcXG4nKVxuICAgICBcbiAgICAgIC8vaWYoIGRlYnVnICkgY29uc29sZS5sb2coICdmdW5jdGlvbkJvZHkgbGVuZ3RoJywgYm9keSApXG4gICAgICBcbiAgICAgIC8vIG5leHQgbGluZSBpcyB0byBhY2NvbW1vZGF0ZSBtZW1vIGFzIGdyYXBoIGhlYWRcbiAgICAgIGlmKCBib2R5WyBib2R5Lmxlbmd0aCAtMSBdLnRyaW0oKS5pbmRleE9mKCdsZXQnKSA+IC0xICkgeyBib2R5LnB1c2goICdcXG4nICkgfSBcblxuICAgICAgLy8gZ2V0IGluZGV4IG9mIGxhc3QgbGluZVxuICAgICAgbGV0IGxhc3RpZHggPSBib2R5Lmxlbmd0aCAtIDFcblxuICAgICAgLy8gaW5zZXJ0IHJldHVybiBrZXl3b3JkXG4gICAgICBib2R5WyBsYXN0aWR4IF0gPSAnICBtZW1vcnlbJyArICh0aGlzLm91dHB1dElkeCArIGkpICsgJ10gID0gJyArIGJvZHlbIGxhc3RpZHggXSArICdcXG4nXG5cbiAgICAgIHRoaXMuZnVuY3Rpb25Cb2R5ICs9IGJvZHkuam9pbignXFxuJylcbiAgICB9XG4gICAgXG4gICAgdGhpcy5oaXN0b3JpZXMuZm9yRWFjaCggdmFsdWUgPT4ge1xuICAgICAgaWYoIHZhbHVlICE9PSBudWxsIClcbiAgICAgICAgdmFsdWUuZ2VuKCkgICAgICBcbiAgICB9KVxuXG4gICAgY29uc3QgcmV0dXJuU3RhdGVtZW50ID0gaXNTdGVyZW8gPyBgICByZXR1cm4gWyBtZW1vcnlbJHt0aGlzLm91dHB1dElkeH1dLCBtZW1vcnlbJHt0aGlzLm91dHB1dElkeCArIDF9XSBdYCA6IGAgIHJldHVybiBtZW1vcnlbJHt0aGlzLm91dHB1dElkeH1dYFxuICAgIFxuICAgIHRoaXMuZnVuY3Rpb25Cb2R5ID0gdGhpcy5mdW5jdGlvbkJvZHkuc3BsaXQoJ1xcbicpXG5cbiAgICBpZiggdGhpcy5lbmRCbG9jay5zaXplICkgeyBcbiAgICAgIHRoaXMuZnVuY3Rpb25Cb2R5ID0gdGhpcy5mdW5jdGlvbkJvZHkuY29uY2F0KCBBcnJheS5mcm9tKCB0aGlzLmVuZEJsb2NrICkgKVxuICAgICAgdGhpcy5mdW5jdGlvbkJvZHkucHVzaCggcmV0dXJuU3RhdGVtZW50IClcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuZnVuY3Rpb25Cb2R5LnB1c2goIHJldHVyblN0YXRlbWVudCApXG4gICAgfVxuICAgIC8vIHJlYXNzZW1ibGUgZnVuY3Rpb24gYm9keVxuICAgIHRoaXMuZnVuY3Rpb25Cb2R5ID0gdGhpcy5mdW5jdGlvbkJvZHkuam9pbignXFxuJylcblxuICAgIC8vIHdlIGNhbiBvbmx5IGR5bmFtaWNhbGx5IGNyZWF0ZSBhIG5hbWVkIGZ1bmN0aW9uIGJ5IGR5bmFtaWNhbGx5IGNyZWF0aW5nIGFub3RoZXIgZnVuY3Rpb25cbiAgICAvLyB0byBjb25zdHJ1Y3QgdGhlIG5hbWVkIGZ1bmN0aW9uISBzaGVlc2guLi5cbiAgICAvL1xuICAgIGlmKCBzaG91bGRJbmxpbmVNZW1vcnkgPT09IHRydWUgKSB7XG4gICAgICB0aGlzLnBhcmFtZXRlcnMuYWRkKCAnbWVtb3J5JyApXG4gICAgfVxuXG4gICAgbGV0IHBhcmFtU3RyaW5nID0gJydcbiAgICBpZiggdGhpcy5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICBmb3IoIGxldCBuYW1lIG9mIHRoaXMucGFyYW1ldGVycy52YWx1ZXMoKSApIHtcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gbmFtZSArICcsJ1xuICAgICAgfVxuICAgICAgcGFyYW1TdHJpbmcgPSBwYXJhbVN0cmluZy5zbGljZSgwLC0xKVxuICAgIH1cblxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHRoaXMucGFyYW1ldGVycy5zaXplICE9PSAwICYmIHRoaXMuaW5wdXRzLnNpemUgPiAwID8gJywgJyA6ICcnXG5cbiAgICBsZXQgaW5wdXRTdHJpbmcgPSAnJ1xuICAgIGlmKCB0aGlzLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIGZvciggbGV0IHVnZW4gb2YgdGhpcy5pbnB1dHMudmFsdWVzKCkgKSB7XG4gICAgICAgIGlucHV0U3RyaW5nICs9IHVnZW4ubmFtZSArICcsJ1xuICAgICAgfVxuICAgICAgaW5wdXRTdHJpbmcgPSBpbnB1dFN0cmluZy5zbGljZSgwLC0xKVxuICAgIH1cblxuICAgIGxldCBidWlsZFN0cmluZyA9IHRoaXMubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgICA/IGByZXR1cm4gZnVuY3Rpb24oICR7aW5wdXRTdHJpbmd9ICR7c2VwYXJhdG9yfSAke3BhcmFtU3RyaW5nfSApeyBcXG4keyB0aGlzLmZ1bmN0aW9uQm9keSB9XFxufWBcbiAgICAgIDogYHJldHVybiBmdW5jdGlvbiBnZW4oICR7IFsuLi50aGlzLnBhcmFtZXRlcnNdLmpvaW4oJywnKSB9ICl7IFxcbiR7IHRoaXMuZnVuY3Rpb25Cb2R5IH1cXG59YFxuICAgIFxuICAgIGlmKCB0aGlzLmRlYnVnIHx8IGRlYnVnICkgY29uc29sZS5sb2coIGJ1aWxkU3RyaW5nICkgXG5cbiAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbiggYnVpbGRTdHJpbmcgKSgpXG5cbiAgICAvLyBhc3NpZ24gcHJvcGVydGllcyB0byBuYW1lZCBmdW5jdGlvblxuICAgIGZvciggbGV0IGRpY3Qgb2YgdGhpcy5jbG9zdXJlcy52YWx1ZXMoKSApIHtcbiAgICAgIGxldCBuYW1lID0gT2JqZWN0LmtleXMoIGRpY3QgKVswXSxcbiAgICAgICAgICB2YWx1ZSA9IGRpY3RbIG5hbWUgXVxuXG4gICAgICBjYWxsYmFja1sgbmFtZSBdID0gdmFsdWVcbiAgICB9XG5cbiAgICBmb3IoIGxldCBkaWN0IG9mIHRoaXMucGFyYW1zLnZhbHVlcygpICkge1xuICAgICAgbGV0IG5hbWUgPSBPYmplY3Qua2V5cyggZGljdCApWzBdLFxuICAgICAgICAgIHVnZW4gPSBkaWN0WyBuYW1lIF1cbiAgICAgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBjYWxsYmFjaywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHVnZW4udmFsdWUgfSxcbiAgICAgICAgc2V0KHYpeyB1Z2VuLnZhbHVlID0gdiB9XG4gICAgICB9KVxuICAgICAgLy9jYWxsYmFja1sgbmFtZSBdID0gdmFsdWVcbiAgICB9XG5cbiAgICBjYWxsYmFjay5tZW1iZXJzID0gdGhpcy5jbG9zdXJlc1xuICAgIGNhbGxiYWNrLmRhdGEgPSB0aGlzLmRhdGFcbiAgICBjYWxsYmFjay5wYXJhbXMgPSB0aGlzLnBhcmFtc1xuICAgIGNhbGxiYWNrLmlucHV0cyA9IHRoaXMuaW5wdXRzXG4gICAgY2FsbGJhY2sucGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycy8vLnNsaWNlKCAwIClcbiAgICBjYWxsYmFjay5vdXQgPSB0aGlzLm1lbW9yeS5oZWFwLnN1YmFycmF5KCB0aGlzLm91dHB1dElkeCwgdGhpcy5vdXRwdXRJZHggKyAyIClcbiAgICBjYWxsYmFjay5pc1N0ZXJlbyA9IGlzU3RlcmVvXG5cbiAgICAvL2lmKCBNZW1vcnlIZWxwZXIuaXNQcm90b3R5cGVPZiggdGhpcy5tZW1vcnkgKSApIFxuICAgIGNhbGxiYWNrLm1lbW9yeSA9IHRoaXMubWVtb3J5LmhlYXBcblxuICAgIHRoaXMuaGlzdG9yaWVzLmNsZWFyKClcblxuICAgIHJldHVybiBjYWxsYmFja1xuICB9LFxuICBcbiAgLyogZ2V0SW5wdXRzXG4gICAqXG4gICAqIENhbGxlZCBieSBlYWNoIGluZGl2aWR1YWwgdWdlbiB3aGVuIHRoZWlyIC5nZW4oKSBtZXRob2QgaXMgY2FsbGVkIHRvIHJlc29sdmUgdGhlaXIgdmFyaW91cyBpbnB1dHMuXG4gICAqIElmIGFuIGlucHV0IGlzIGEgbnVtYmVyLCByZXR1cm4gdGhlIG51bWJlci4gSWZcbiAgICogaXQgaXMgYW4gdWdlbiwgY2FsbCAuZ2VuKCkgb24gdGhlIHVnZW4sIG1lbW9pemUgdGhlIHJlc3VsdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuIElmIHRoZVxuICAgKiB1Z2VuIGhhcyBwcmV2aW91c2x5IGJlZW4gbWVtb2l6ZWQgcmV0dXJuIHRoZSBtZW1vaXplZCB2YWx1ZS5cbiAgICpcbiAgICovXG4gIGdldElucHV0cyggdWdlbiApIHtcbiAgICByZXR1cm4gdWdlbi5pbnB1dHMubWFwKCBnZW4uZ2V0SW5wdXQgKSBcbiAgfSxcblxuICBnZXRJbnB1dCggaW5wdXQgKSB7XG4gICAgbGV0IGlzT2JqZWN0ID0gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyxcbiAgICAgICAgcHJvY2Vzc2VkSW5wdXRcblxuICAgIGlmKCBpc09iamVjdCApIHsgLy8gaWYgaW5wdXQgaXMgYSB1Z2VuLi4uIFxuICAgICAgLy9jb25zb2xlLmxvZyggaW5wdXQubmFtZSwgZ2VuLm1lbW9bIGlucHV0Lm5hbWUgXSApXG4gICAgICBpZiggZ2VuLm1lbW9bIGlucHV0Lm5hbWUgXSApIHsgLy8gaWYgaXQgaGFzIGJlZW4gbWVtb2l6ZWQuLi5cbiAgICAgICAgcHJvY2Vzc2VkSW5wdXQgPSBnZW4ubWVtb1sgaW5wdXQubmFtZSBdXG4gICAgICB9ZWxzZSBpZiggQXJyYXkuaXNBcnJheSggaW5wdXQgKSApIHtcbiAgICAgICAgZ2VuLmdldElucHV0KCBpbnB1dFswXSApXG4gICAgICAgIGdlbi5nZXRJbnB1dCggaW5wdXRbMV0gKVxuICAgICAgfWVsc2V7IC8vIGlmIG5vdCBtZW1vaXplZCBnZW5lcmF0ZSBjb2RlICBcbiAgICAgICAgaWYoIHR5cGVvZiBpbnB1dC5nZW4gIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coICdubyBnZW4gZm91bmQ6JywgaW5wdXQsIGlucHV0LmdlbiApXG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5ncmFwaFxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlID0gaW5wdXQuZ2VuKClcbiAgICAgICAgLy9pZiggY29kZS5pbmRleE9mKCAnT2JqZWN0JyApID4gLTEgKSBjb25zb2xlLmxvZyggJ2JhZCBpbnB1dDonLCBpbnB1dCwgY29kZSApXG4gICAgICAgIFxuICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggY29kZSApICkge1xuICAgICAgICAgIGlmKCAhZ2VuLnNob3VsZExvY2FsaXplICkge1xuICAgICAgICAgICAgZ2VuLmZ1bmN0aW9uQm9keSArPSBjb2RlWzFdXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBnZW4uY29kZU5hbWUgPSBjb2RlWzBdXG4gICAgICAgICAgICBnZW4ubG9jYWxpemVkQ29kZS5wdXNoKCBjb2RlWzFdIClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyggJ2FmdGVyIEdFTicgLCB0aGlzLmZ1bmN0aW9uQm9keSApXG4gICAgICAgICAgcHJvY2Vzc2VkSW5wdXQgPSBjb2RlWzBdXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHByb2Nlc3NlZElucHV0ID0gY29kZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2V7IC8vIGl0IGlucHV0IGlzIGEgbnVtYmVyXG4gICAgICBwcm9jZXNzZWRJbnB1dCA9IGlucHV0XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZElucHV0XG4gIH0sXG5cbiAgc3RhcnRMb2NhbGl6ZSgpIHtcbiAgICB0aGlzLmxvY2FsaXplZENvZGUgPSBbXVxuICAgIHRoaXMuc2hvdWxkTG9jYWxpemUgPSB0cnVlXG4gIH0sXG4gIGVuZExvY2FsaXplKCkge1xuICAgIHRoaXMuc2hvdWxkTG9jYWxpemUgPSBmYWxzZVxuXG4gICAgcmV0dXJuIFsgdGhpcy5jb2RlTmFtZSwgdGhpcy5sb2NhbGl6ZWRDb2RlLnNsaWNlKDApIF1cbiAgfSxcblxuICBmcmVlKCBncmFwaCApIHtcbiAgICBpZiggQXJyYXkuaXNBcnJheSggZ3JhcGggKSApIHsgLy8gc3RlcmVvIHVnZW5cbiAgICAgIGZvciggbGV0IGNoYW5uZWwgb2YgZ3JhcGggKSB7XG4gICAgICAgIHRoaXMuZnJlZSggY2hhbm5lbCApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCB0eXBlb2YgZ3JhcGggPT09ICdvYmplY3QnICkge1xuICAgICAgICBpZiggZ3JhcGgubWVtb3J5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgZm9yKCBsZXQgbWVtb3J5S2V5IGluIGdyYXBoLm1lbW9yeSApIHtcbiAgICAgICAgICAgIHRoaXMubWVtb3J5LmZyZWUoIGdyYXBoLm1lbW9yeVsgbWVtb3J5S2V5IF0uaWR4IClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoIEFycmF5LmlzQXJyYXkoIGdyYXBoLmlucHV0cyApICkge1xuICAgICAgICAgIGZvciggbGV0IHVnZW4gb2YgZ3JhcGguaW5wdXRzICkge1xuICAgICAgICAgICAgdGhpcy5mcmVlKCB1Z2VuIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZ2VuLl9fcHJvdG9fXyA9IG5ldyBFRSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuXG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2d0JyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9IGAgIFxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApIHx8IGlzTmFOKCB0aGlzLmlucHV0c1sxXSApICkge1xuICAgICAgb3V0ICs9IGAoKCAke2lucHV0c1swXX0gPiAke2lucHV0c1sxXX0pIHwgMCApYFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gaW5wdXRzWzBdID4gaW5wdXRzWzFdID8gMSA6IDAgXG4gICAgfVxuICAgIG91dCArPSAnXFxuXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gW3RoaXMubmFtZSwgb3V0XVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHgseSkgPT4ge1xuICBsZXQgZ3QgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgZ3QuaW5wdXRzID0gWyB4LHkgXVxuICBndC5uYW1lID0gZ3QuYmFzZW5hbWUgKyBnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gZ3Rcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J2d0ZScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSBgICBcblxuICAgIGlmKCBpc05hTiggdGhpcy5pbnB1dHNbMF0gKSB8fCBpc05hTiggdGhpcy5pbnB1dHNbMV0gKSApIHtcbiAgICAgIG91dCArPSBgKCAke2lucHV0c1swXX0gPj0gJHtpbnB1dHNbMV19IHwgMCApYFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gaW5wdXRzWzBdID49IGlucHV0c1sxXSA/IDEgOiAwIFxuICAgIH1cbiAgICBvdXQgKz0gJ1xcblxcbidcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZVxuXG4gICAgcmV0dXJuIFt0aGlzLm5hbWUsIG91dF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGd0ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGd0LmlucHV0cyA9IFsgeCx5IF1cbiAgZ3QubmFtZSA9ICdndGUnICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIGd0XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonZ3RwJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBpZiggaXNOYU4oIHRoaXMuaW5wdXRzWzBdICkgfHwgaXNOYU4oIHRoaXMuaW5wdXRzWzFdICkgKSB7XG4gICAgICBvdXQgPSBgKCR7aW5wdXRzWyAwIF19ICogKCAoICR7aW5wdXRzWzBdfSA+ICR7aW5wdXRzWzFdfSApIHwgMCApIClgIFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBpbnB1dHNbMF0gKiAoICggaW5wdXRzWzBdID4gaW5wdXRzWzFdICkgfCAwIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHgseSkgPT4ge1xuICBsZXQgZ3RwID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGd0cC5pbnB1dHMgPSBbIHgseSBdXG5cbiAgcmV0dXJuIGd0cFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xPTAgKSA9PiB7XG4gIGxldCB1Z2VuID0ge1xuICAgIGlucHV0czogWyBpbjEgXSxcbiAgICBtZW1vcnk6IHsgdmFsdWU6IHsgbGVuZ3RoOjEsIGlkeDogbnVsbCB9IH0sXG4gICAgcmVjb3JkZXI6IG51bGwsXG5cbiAgICBpbiggdiApIHtcbiAgICAgIGlmKCBnZW4uaGlzdG9yaWVzLmhhcyggdiApICl7XG4gICAgICAgIGxldCBtZW1vSGlzdG9yeSA9IGdlbi5oaXN0b3JpZXMuZ2V0KCB2IClcbiAgICAgICAgdWdlbi5uYW1lID0gbWVtb0hpc3RvcnkubmFtZVxuICAgICAgICByZXR1cm4gbWVtb0hpc3RvcnlcbiAgICAgIH1cblxuICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgZ2VuKCkge1xuICAgICAgICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB1Z2VuIClcblxuICAgICAgICAgIGlmKCB1Z2VuLm1lbW9yeS52YWx1ZS5pZHggPT09IG51bGwgKSB7XG4gICAgICAgICAgICBnZW4ucmVxdWVzdE1lbW9yeSggdWdlbi5tZW1vcnkgKVxuICAgICAgICAgICAgZ2VuLm1lbW9yeS5oZWFwWyB1Z2VuLm1lbW9yeS52YWx1ZS5pZHggXSA9IGluMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBpZHggPSB1Z2VuLm1lbW9yeS52YWx1ZS5pZHhcbiAgICAgICAgICBcbiAgICAgICAgICBnZW4uYWRkVG9FbmRCbG9jayggJ21lbW9yeVsgJyArIGlkeCArICcgXSA9ICcgKyBpbnB1dHNbIDAgXSApXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gcmV0dXJuIHVnZW4gdGhhdCBpcyBiZWluZyByZWNvcmRlZCBpbnN0ZWFkIG9mIHNzZC5cbiAgICAgICAgICAvLyB0aGlzIGVmZmVjdGl2ZWx5IG1ha2VzIGEgY2FsbCB0byBzc2QucmVjb3JkKCkgdHJhbnNwYXJlbnQgdG8gdGhlIGdyYXBoLlxuICAgICAgICAgIC8vIHJlY29yZGluZyBpcyB0cmlnZ2VyZWQgYnkgcHJpb3IgY2FsbCB0byBnZW4uYWRkVG9FbmRCbG9jay5cbiAgICAgICAgICBnZW4uaGlzdG9yaWVzLnNldCggdiwgb2JqIClcblxuICAgICAgICAgIHJldHVybiBpbnB1dHNbIDAgXVxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB1Z2VuLm5hbWUgKyAnX2luJytnZW4uZ2V0VUlEKCksXG4gICAgICAgIG1lbW9yeTogdWdlbi5tZW1vcnlcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnB1dHNbIDAgXSA9IHZcbiAgICAgIFxuICAgICAgdWdlbi5yZWNvcmRlciA9IG9ialxuXG4gICAgICByZXR1cm4gb2JqXG4gICAgfSxcbiAgICBcbiAgICBvdXQ6IHtcbiAgICAgICAgICAgIFxuICAgICAgZ2VuKCkge1xuICAgICAgICBpZiggdWdlbi5tZW1vcnkudmFsdWUuaWR4ID09PSBudWxsICkge1xuICAgICAgICAgIGlmKCBnZW4uaGlzdG9yaWVzLmdldCggdWdlbi5pbnB1dHNbMF0gKSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgZ2VuLmhpc3Rvcmllcy5zZXQoIHVnZW4uaW5wdXRzWzBdLCB1Z2VuLnJlY29yZGVyIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHVnZW4ubWVtb3J5IClcbiAgICAgICAgICBnZW4ubWVtb3J5LmhlYXBbIHVnZW4ubWVtb3J5LnZhbHVlLmlkeCBdID0gcGFyc2VGbG9hdCggaW4xIClcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWR4ID0gdWdlbi5tZW1vcnkudmFsdWUuaWR4XG4gICAgICAgICBcbiAgICAgICAgcmV0dXJuICdtZW1vcnlbICcgKyBpZHggKyAnIF0gJ1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgdWlkOiBnZW4uZ2V0VUlEKCksXG4gIH1cbiAgXG4gIHVnZW4ub3V0Lm1lbW9yeSA9IHVnZW4ubWVtb3J5IFxuXG4gIHVnZW4ubmFtZSA9ICdoaXN0b3J5JyArIHVnZW4udWlkXG4gIHVnZW4ub3V0Lm5hbWUgPSB1Z2VuLm5hbWUgKyAnX291dCdcbiAgdWdlbi5pbi5fbmFtZSAgPSB1Z2VuLm5hbWUgPSAnX2luJ1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ3ZhbHVlJywge1xuICAgIGdldCgpIHtcbiAgICAgIGlmKCB0aGlzLm1lbW9yeS52YWx1ZS5pZHggIT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQoIHYgKSB7XG4gICAgICBpZiggdGhpcy5tZW1vcnkudmFsdWUuaWR4ICE9PSBudWxsICkge1xuICAgICAgICBnZW4ubWVtb3J5LmhlYXBbIHRoaXMubWVtb3J5LnZhbHVlLmlkeCBdID0gdiBcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2lmZWxzZScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBjb25kaXRpb25hbHMgPSB0aGlzLmlucHV0c1swXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gZ2VuLmdldElucHV0KCBjb25kaXRpb25hbHNbIGNvbmRpdGlvbmFscy5sZW5ndGggLSAxXSApLFxuICAgICAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9X291dCA9ICR7ZGVmYXVsdFZhbHVlfVxcbmAgXG5cbiAgICAvL2NvbnNvbGUubG9nKCAnY29uZGl0aW9uYWxzOicsIHRoaXMubmFtZSwgY29uZGl0aW9uYWxzIClcblxuICAgIC8vY29uc29sZS5sb2coICdkZWZhdWx0VmFsdWU6JywgZGVmYXVsdFZhbHVlIClcblxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgY29uZGl0aW9uYWxzLmxlbmd0aCAtIDI7IGkrPSAyICkge1xuICAgICAgbGV0IGlzRW5kQmxvY2sgPSBpID09PSBjb25kaXRpb25hbHMubGVuZ3RoIC0gMyxcbiAgICAgICAgICBjb25kICA9IGdlbi5nZXRJbnB1dCggY29uZGl0aW9uYWxzWyBpIF0gKSxcbiAgICAgICAgICBwcmVibG9jayA9IGNvbmRpdGlvbmFsc1sgaSsxIF0sXG4gICAgICAgICAgYmxvY2ssIGJsb2NrTmFtZSwgb3V0cHV0XG5cbiAgICAgIC8vY29uc29sZS5sb2coICdwYicsIHByZWJsb2NrIClcblxuICAgICAgaWYoIHR5cGVvZiBwcmVibG9jayA9PT0gJ251bWJlcicgKXtcbiAgICAgICAgYmxvY2sgPSBwcmVibG9ja1xuICAgICAgICBibG9ja05hbWUgPSBudWxsXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYoIGdlbi5tZW1vWyBwcmVibG9jay5uYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAvLyB1c2VkIHRvIHBsYWNlIGFsbCBjb2RlIGRlcGVuZGVuY2llcyBpbiBhcHByb3ByaWF0ZSBibG9ja3NcbiAgICAgICAgICBnZW4uc3RhcnRMb2NhbGl6ZSgpXG5cbiAgICAgICAgICBnZW4uZ2V0SW5wdXQoIHByZWJsb2NrIClcblxuICAgICAgICAgIGJsb2NrID0gZ2VuLmVuZExvY2FsaXplKClcbiAgICAgICAgICBibG9ja05hbWUgPSBibG9ja1swXVxuICAgICAgICAgIGJsb2NrID0gYmxvY2tbIDEgXS5qb2luKCcnKVxuICAgICAgICAgIGJsb2NrID0gJyAgJyArIGJsb2NrLnJlcGxhY2UoIC9cXG4vZ2ksICdcXG4gICcgKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBibG9jayA9ICcnXG4gICAgICAgICAgYmxvY2tOYW1lID0gZ2VuLm1lbW9bIHByZWJsb2NrLm5hbWUgXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCA9IGJsb2NrTmFtZSA9PT0gbnVsbCA/IFxuICAgICAgICBgICAke3RoaXMubmFtZX1fb3V0ID0gJHtibG9ja31gIDpcbiAgICAgICAgYCR7YmxvY2t9ICAke3RoaXMubmFtZX1fb3V0ID0gJHtibG9ja05hbWV9YFxuICAgICAgXG4gICAgICBpZiggaT09PTAgKSBvdXQgKz0gJyAnXG4gICAgICBvdXQgKz0gXG5gIGlmKCAke2NvbmR9ID09PSAxICkge1xuJHtvdXRwdXR9XG4gIH1gXG5cbiAgICAgIGlmKCAhaXNFbmRCbG9jayApIHtcbiAgICAgICAgb3V0ICs9IGAgZWxzZWBcbiAgICAgIH1lbHNle1xuICAgICAgICBvdXQgKz0gYFxcbmBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBgJHt0aGlzLm5hbWV9X291dGBcblxuICAgIHJldHVybiBbIGAke3RoaXMubmFtZX1fb3V0YCwgb3V0IF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggLi4uYXJncyAgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIGNvbmRpdGlvbnMgPSBBcnJheS5pc0FycmF5KCBhcmdzWzBdICkgPyBhcmdzWzBdIDogYXJnc1xuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHtcbiAgICB1aWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiAgWyBjb25kaXRpb25zIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonaW4nLFxuXG4gIGdlbigpIHtcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG5cbiAgICBpZiggaXNXb3JrbGV0ICkge1xuICAgICAgZ2VuLmlucHV0cy5hZGQoIHRoaXMgKVxuICAgIH1lbHNle1xuICAgICAgZ2VuLnBhcmFtZXRlcnMuYWRkKCB0aGlzLm5hbWUgKVxuICAgIH1cblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGlzV29ya2xldCA9PT0gdHJ1ZSA/IHRoaXMubmFtZSArICdbaV0nIDogdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gZ2VuLm1lbW9bIHRoaXMubmFtZSBdXG4gIH0gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBuYW1lLCBpbnB1dE51bWJlcj0wLCBjaGFubmVsTnVtYmVyPTAsIGRlZmF1bHRWYWx1ZT0wLCBtaW49MCwgbWF4PTEgKSA9PiB7XG4gIGxldCBpbnB1dCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBpbnB1dC5pZCAgID0gZ2VuLmdldFVJRCgpXG4gIGlucHV0Lm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogYCR7aW5wdXQuYmFzZW5hbWV9JHtpbnB1dC5pZH1gXG4gIE9iamVjdC5hc3NpZ24oIGlucHV0LCB7IGRlZmF1bHRWYWx1ZSwgbWluLCBtYXgsIGlucHV0TnVtYmVyLCBjaGFubmVsTnVtYmVyIH0pXG5cbiAgaW5wdXRbMF0gPSB7XG4gICAgZ2VuKCkge1xuICAgICAgaWYoICEgZ2VuLnBhcmFtZXRlcnMuaGFzKCBpbnB1dC5uYW1lICkgKSBnZW4ucGFyYW1ldGVycy5hZGQoIGlucHV0Lm5hbWUgKVxuICAgICAgcmV0dXJuIGlucHV0Lm5hbWUgKyAnWzBdJ1xuICAgIH1cbiAgfVxuICBpbnB1dFsxXSA9IHtcbiAgICBnZW4oKSB7XG4gICAgICBpZiggISBnZW4ucGFyYW1ldGVycy5oYXMoIGlucHV0Lm5hbWUgKSApIGdlbi5wYXJhbWV0ZXJzLmFkZCggaW5wdXQubmFtZSApXG4gICAgICByZXR1cm4gaW5wdXQubmFtZSArICdbMV0nXG4gICAgfVxuICB9XG5cblxuICByZXR1cm4gaW5wdXRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsaWJyYXJ5ID0ge1xuICBleHBvcnQoIGRlc3RpbmF0aW9uICkge1xuICAgIGlmKCBkZXN0aW5hdGlvbiA9PT0gd2luZG93ICkge1xuICAgICAgZGVzdGluYXRpb24uc3NkID0gbGlicmFyeS5oaXN0b3J5ICAgIC8vIGhpc3RvcnkgaXMgd2luZG93IG9iamVjdCBwcm9wZXJ0eSwgc28gdXNlIHNzZCBhcyBhbGlhc1xuICAgICAgZGVzdGluYXRpb24uaW5wdXQgPSBsaWJyYXJ5LmluICAgICAgIC8vIGluIGlzIGEga2V5d29yZCBpbiBqYXZhc2NyaXB0XG4gICAgICBkZXN0aW5hdGlvbi50ZXJuYXJ5ID0gbGlicmFyeS5zd2l0Y2ggLy8gc3dpdGNoIGlzIGEga2V5d29yZCBpbiBqYXZhc2NyaXB0XG5cbiAgICAgIGRlbGV0ZSBsaWJyYXJ5Lmhpc3RvcnlcbiAgICAgIGRlbGV0ZSBsaWJyYXJ5LmluXG4gICAgICBkZWxldGUgbGlicmFyeS5zd2l0Y2hcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBkZXN0aW5hdGlvbiwgbGlicmFyeSApXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGxpYnJhcnksICdzYW1wbGVyYXRlJywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gbGlicmFyeS5nZW4uc2FtcGxlcmF0ZSB9LFxuICAgICAgc2V0KHYpIHt9XG4gICAgfSlcblxuICAgIGxpYnJhcnkuaW4gPSBkZXN0aW5hdGlvbi5pbnB1dFxuICAgIGxpYnJhcnkuaGlzdG9yeSA9IGRlc3RpbmF0aW9uLnNzZFxuICAgIGxpYnJhcnkuc3dpdGNoID0gZGVzdGluYXRpb24udGVybmFyeVxuXG4gICAgZGVzdGluYXRpb24uY2xpcCA9IGxpYnJhcnkuY2xhbXBcbiAgfSxcblxuICBnZW46ICAgICAgcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICBcbiAgYWJzOiAgICAgIHJlcXVpcmUoICcuL2Ficy5qcycgKSxcbiAgcm91bmQ6ICAgIHJlcXVpcmUoICcuL3JvdW5kLmpzJyApLFxuICBwYXJhbTogICAgcmVxdWlyZSggJy4vcGFyYW0uanMnICksXG4gIGFkZDogICAgICByZXF1aXJlKCAnLi9hZGQuanMnICksXG4gIHN1YjogICAgICByZXF1aXJlKCAnLi9zdWIuanMnICksXG4gIG11bDogICAgICByZXF1aXJlKCAnLi9tdWwuanMnICksXG4gIGRpdjogICAgICByZXF1aXJlKCAnLi9kaXYuanMnICksXG4gIGFjY3VtOiAgICByZXF1aXJlKCAnLi9hY2N1bS5qcycgKSxcbiAgY291bnRlcjogIHJlcXVpcmUoICcuL2NvdW50ZXIuanMnICksXG4gIHNpbjogICAgICByZXF1aXJlKCAnLi9zaW4uanMnICksXG4gIGNvczogICAgICByZXF1aXJlKCAnLi9jb3MuanMnICksXG4gIHRhbjogICAgICByZXF1aXJlKCAnLi90YW4uanMnICksXG4gIHRhbmg6ICAgICByZXF1aXJlKCAnLi90YW5oLmpzJyApLFxuICBhc2luOiAgICAgcmVxdWlyZSggJy4vYXNpbi5qcycgKSxcbiAgYWNvczogICAgIHJlcXVpcmUoICcuL2Fjb3MuanMnICksXG4gIGF0YW46ICAgICByZXF1aXJlKCAnLi9hdGFuLmpzJyApLCAgXG4gIHBoYXNvcjogICByZXF1aXJlKCAnLi9waGFzb3IuanMnICksXG4gIGRhdGE6ICAgICByZXF1aXJlKCAnLi9kYXRhLmpzJyApLFxuICBwZWVrOiAgICAgcmVxdWlyZSggJy4vcGVlay5qcycgKSxcbiAgY3ljbGU6ICAgIHJlcXVpcmUoICcuL2N5Y2xlLmpzJyApLFxuICBoaXN0b3J5OiAgcmVxdWlyZSggJy4vaGlzdG9yeS5qcycgKSxcbiAgZGVsdGE6ICAgIHJlcXVpcmUoICcuL2RlbHRhLmpzJyApLFxuICBmbG9vcjogICAgcmVxdWlyZSggJy4vZmxvb3IuanMnICksXG4gIGNlaWw6ICAgICByZXF1aXJlKCAnLi9jZWlsLmpzJyApLFxuICBtaW46ICAgICAgcmVxdWlyZSggJy4vbWluLmpzJyApLFxuICBtYXg6ICAgICAgcmVxdWlyZSggJy4vbWF4LmpzJyApLFxuICBzaWduOiAgICAgcmVxdWlyZSggJy4vc2lnbi5qcycgKSxcbiAgZGNibG9jazogIHJlcXVpcmUoICcuL2RjYmxvY2suanMnICksXG4gIG1lbW86ICAgICByZXF1aXJlKCAnLi9tZW1vLmpzJyApLFxuICByYXRlOiAgICAgcmVxdWlyZSggJy4vcmF0ZS5qcycgKSxcbiAgd3JhcDogICAgIHJlcXVpcmUoICcuL3dyYXAuanMnICksXG4gIG1peDogICAgICByZXF1aXJlKCAnLi9taXguanMnICksXG4gIGNsYW1wOiAgICByZXF1aXJlKCAnLi9jbGFtcC5qcycgKSxcbiAgcG9rZTogICAgIHJlcXVpcmUoICcuL3Bva2UuanMnICksXG4gIGRlbGF5OiAgICByZXF1aXJlKCAnLi9kZWxheS5qcycgKSxcbiAgZm9sZDogICAgIHJlcXVpcmUoICcuL2ZvbGQuanMnICksXG4gIG1vZCA6ICAgICByZXF1aXJlKCAnLi9tb2QuanMnICksXG4gIHNhaCA6ICAgICByZXF1aXJlKCAnLi9zYWguanMnICksXG4gIG5vaXNlOiAgICByZXF1aXJlKCAnLi9ub2lzZS5qcycgKSxcbiAgbm90OiAgICAgIHJlcXVpcmUoICcuL25vdC5qcycgKSxcbiAgZ3Q6ICAgICAgIHJlcXVpcmUoICcuL2d0LmpzJyApLFxuICBndGU6ICAgICAgcmVxdWlyZSggJy4vZ3RlLmpzJyApLFxuICBsdDogICAgICAgcmVxdWlyZSggJy4vbHQuanMnICksIFxuICBsdGU6ICAgICAgcmVxdWlyZSggJy4vbHRlLmpzJyApLCBcbiAgYm9vbDogICAgIHJlcXVpcmUoICcuL2Jvb2wuanMnICksXG4gIGdhdGU6ICAgICByZXF1aXJlKCAnLi9nYXRlLmpzJyApLFxuICB0cmFpbjogICAgcmVxdWlyZSggJy4vdHJhaW4uanMnICksXG4gIHNsaWRlOiAgICByZXF1aXJlKCAnLi9zbGlkZS5qcycgKSxcbiAgaW46ICAgICAgIHJlcXVpcmUoICcuL2luLmpzJyApLFxuICB0NjA6ICAgICAgcmVxdWlyZSggJy4vdDYwLmpzJyksXG4gIG10b2Y6ICAgICByZXF1aXJlKCAnLi9tdG9mLmpzJyksXG4gIGx0cDogICAgICByZXF1aXJlKCAnLi9sdHAuanMnKSwgICAgICAgIC8vIFRPRE86IHRlc3RcbiAgZ3RwOiAgICAgIHJlcXVpcmUoICcuL2d0cC5qcycpLCAgICAgICAgLy8gVE9ETzogdGVzdFxuICBzd2l0Y2g6ICAgcmVxdWlyZSggJy4vc3dpdGNoLmpzJyApLFxuICBtc3Rvc2FtcHM6cmVxdWlyZSggJy4vbXN0b3NhbXBzLmpzJyApLCAvLyBUT0RPOiBuZWVkcyB0ZXN0LFxuICBzZWxlY3RvcjogcmVxdWlyZSggJy4vc2VsZWN0b3IuanMnICksXG4gIHV0aWxpdGllczpyZXF1aXJlKCAnLi91dGlsaXRpZXMuanMnICksXG4gIHBvdzogICAgICByZXF1aXJlKCAnLi9wb3cuanMnICksXG4gIGF0dGFjazogICByZXF1aXJlKCAnLi9hdHRhY2suanMnICksXG4gIGRlY2F5OiAgICByZXF1aXJlKCAnLi9kZWNheS5qcycgKSxcbiAgd2luZG93czogIHJlcXVpcmUoICcuL3dpbmRvd3MuanMnICksXG4gIGVudjogICAgICByZXF1aXJlKCAnLi9lbnYuanMnICksXG4gIGFkOiAgICAgICByZXF1aXJlKCAnLi9hZC5qcycgICksXG4gIGFkc3I6ICAgICByZXF1aXJlKCAnLi9hZHNyLmpzJyApLFxuICBpZmVsc2U6ICAgcmVxdWlyZSggJy4vaWZlbHNlaWYuanMnICksXG4gIGJhbmc6ICAgICByZXF1aXJlKCAnLi9iYW5nLmpzJyApLFxuICBhbmQ6ICAgICAgcmVxdWlyZSggJy4vYW5kLmpzJyApLFxuICBwYW46ICAgICAgcmVxdWlyZSggJy4vcGFuLmpzJyApLFxuICBlcTogICAgICAgcmVxdWlyZSggJy4vZXEuanMnICksXG4gIG5lcTogICAgICByZXF1aXJlKCAnLi9uZXEuanMnICksXG4gIGV4cDogICAgICByZXF1aXJlKCAnLi9leHAuanMnICksXG4gIHByb2Nlc3M6ICByZXF1aXJlKCAnLi9wcm9jZXNzLmpzJyApLFxuICBzZXE6ICAgICAgcmVxdWlyZSggJy4vc2VxLmpzJyApXG59XG5cbmxpYnJhcnkuZ2VuLmxpYiA9IGxpYnJhcnlcblxubW9kdWxlLmV4cG9ydHMgPSBsaWJyYXJ5XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J2x0JyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gYCAgXG5cbiAgICBpZiggaXNOYU4oIHRoaXMuaW5wdXRzWzBdICkgfHwgaXNOYU4oIHRoaXMuaW5wdXRzWzFdICkgKSB7XG4gICAgICBvdXQgKz0gYCgoICR7aW5wdXRzWzBdfSA8ICR7aW5wdXRzWzFdfSkgfCAwICApYFxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gaW5wdXRzWzBdIDwgaW5wdXRzWzFdID8gMSA6IDAgXG4gICAgfVxuICAgIG91dCArPSAnXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gW3RoaXMubmFtZSwgb3V0XVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGx0ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGx0LmlucHV0cyA9IFsgeCx5IF1cbiAgbHQubmFtZSA9IGx0LmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIGx0XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonbHRlJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gYCAgXG5cbiAgICBpZiggaXNOYU4oIHRoaXMuaW5wdXRzWzBdICkgfHwgaXNOYU4oIHRoaXMuaW5wdXRzWzFdICkgKSB7XG4gICAgICBvdXQgKz0gYCggJHtpbnB1dHNbMF19IDw9ICR7aW5wdXRzWzFdfSB8IDAgIClgXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBpbnB1dHNbMF0gPD0gaW5wdXRzWzFdID8gMSA6IDAgXG4gICAgfVxuICAgIG91dCArPSAnXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gW3RoaXMubmFtZSwgb3V0XVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGx0ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIGx0LmlucHV0cyA9IFsgeCx5IF1cbiAgbHQubmFtZSA9ICdsdGUnICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIGx0XG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonbHRwJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBpZiggaXNOYU4oIHRoaXMuaW5wdXRzWzBdICkgfHwgaXNOYU4oIHRoaXMuaW5wdXRzWzFdICkgKSB7XG4gICAgICBvdXQgPSBgKCR7aW5wdXRzWyAwIF19ICogKCggJHtpbnB1dHNbMF19IDwgJHtpbnB1dHNbMV19ICkgfCAwICkgKWAgXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IGlucHV0c1swXSAqICgoIGlucHV0c1swXSA8IGlucHV0c1sxXSApIHwgMCApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IGx0cCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBsdHAuaW5wdXRzID0gWyB4LHkgXVxuXG4gIHJldHVybiBsdHBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidtYXgnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApIHx8IGlzTmFOKCBpbnB1dHNbMV0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyBbIHRoaXMubmFtZSBdOiBpc1dvcmtsZXQgPyAnTWF0aC5tYXgnIDogTWF0aC5tYXggfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfW1heCggJHtpbnB1dHNbMF19LCAke2lucHV0c1sxXX0gKWBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLm1heCggcGFyc2VGbG9hdCggaW5wdXRzWzBdICksIHBhcnNlRmxvYXQoIGlucHV0c1sxXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHgseSkgPT4ge1xuICBsZXQgbWF4ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIG1heC5pbnB1dHMgPSBbIHgseSBdXG5cbiAgcmV0dXJuIG1heFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J21lbW8nLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gJHtpbnB1dHNbMF19XFxuYFxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH0gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGluMSxtZW1vTmFtZSkgPT4ge1xuICBsZXQgbWVtbyA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgXG4gIG1lbW8uaW5wdXRzID0gWyBpbjEgXVxuICBtZW1vLmlkICAgPSBnZW4uZ2V0VUlEKClcbiAgbWVtby5uYW1lID0gbWVtb05hbWUgIT09IHVuZGVmaW5lZCA/IG1lbW9OYW1lICsgJ18nICsgZ2VuLmdldFVJRCgpIDogYCR7bWVtby5iYXNlbmFtZX0ke21lbW8uaWR9YFxuXG4gIHJldHVybiBtZW1vXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonbWluJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSB8fCBpc05hTiggaW5wdXRzWzFdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGgubWluJyA6IE1hdGgubWluIH0pXG5cbiAgICAgIG91dCA9IGAke3JlZn1taW4oICR7aW5wdXRzWzBdfSwgJHtpbnB1dHNbMV19IClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC5taW4oIHBhcnNlRmxvYXQoIGlucHV0c1swXSApLCBwYXJzZUZsb2F0KCBpbnB1dHNbMV0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IG1pbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBtaW4uaW5wdXRzID0gWyB4LHkgXVxuXG4gIHJldHVybiBtaW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKSxcbiAgICBhZGQgPSByZXF1aXJlKCcuL2FkZC5qcycpLFxuICAgIG11bCA9IHJlcXVpcmUoJy4vbXVsLmpzJyksXG4gICAgc3ViID0gcmVxdWlyZSgnLi9zdWIuanMnKSxcbiAgICBtZW1vPSByZXF1aXJlKCcuL21lbW8uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xLCBpbjIsIHQ9LjUgKSA9PiB7XG4gIGxldCB1Z2VuID0gbWVtbyggYWRkKCBtdWwoaW4xLCBzdWIoMSx0ICkgKSwgbXVsKCBpbjIsIHQgKSApIClcbiAgdWdlbi5uYW1lID0gJ21peCcgKyBnZW4uZ2V0VUlEKClcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gKC4uLmFyZ3MpID0+IHtcbiAgbGV0IG1vZCA9IHtcbiAgICBpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6IGFyZ3MsXG5cbiAgICBnZW4oKSB7XG4gICAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICAgIG91dD0nKCcsXG4gICAgICAgICAgZGlmZiA9IDAsIFxuICAgICAgICAgIG51bUNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0TnVtYmVyID0gaW5wdXRzWyAwIF0sXG4gICAgICAgICAgbGFzdE51bWJlcklzVWdlbiA9IGlzTmFOKCBsYXN0TnVtYmVyICksIFxuICAgICAgICAgIG1vZEF0RW5kID0gZmFsc2VcblxuICAgICAgaW5wdXRzLmZvckVhY2goICh2LGkpID0+IHtcbiAgICAgICAgaWYoIGkgPT09IDAgKSByZXR1cm5cblxuICAgICAgICBsZXQgaXNOdW1iZXJVZ2VuID0gaXNOYU4oIHYgKSxcbiAgICAgICAgICAgIGlzRmluYWxJZHggICA9IGkgPT09IGlucHV0cy5sZW5ndGggLSAxXG5cbiAgICAgICAgaWYoICFsYXN0TnVtYmVySXNVZ2VuICYmICFpc051bWJlclVnZW4gKSB7XG4gICAgICAgICAgbGFzdE51bWJlciA9IGxhc3ROdW1iZXIgJSB2XG4gICAgICAgICAgb3V0ICs9IGxhc3ROdW1iZXJcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgb3V0ICs9IGAke2xhc3ROdW1iZXJ9ICUgJHt2fWBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhaXNGaW5hbElkeCApIG91dCArPSAnICUgJyBcbiAgICAgIH0pXG5cbiAgICAgIG91dCArPSAnKSdcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIG1vZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidtc3Rvc2FtcHMnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIHJldHVyblZhbHVlXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lIH0gPSAke2dlbi5zYW1wbGVyYXRlfSAvIDEwMDAgKiAke2lucHV0c1swXX0gXFxuXFxuYFxuICAgICBcbiAgICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IG91dFxuICAgICAgXG4gICAgICByZXR1cm5WYWx1ZSA9IFsgdGhpcy5uYW1lLCBvdXQgXVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBnZW4uc2FtcGxlcmF0ZSAvIDEwMDAgKiB0aGlzLmlucHV0c1swXVxuXG4gICAgICByZXR1cm5WYWx1ZSA9IG91dFxuICAgIH0gICAgXG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgbXN0b3NhbXBzID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIG1zdG9zYW1wcy5pbnB1dHMgPSBbIHggXVxuICBtc3Rvc2FtcHMubmFtZSA9IHByb3RvLmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIG1zdG9zYW1wc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J210b2YnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogTWF0aC5leHAgfSlcblxuICAgICAgb3V0ID0gYCggJHt0aGlzLnR1bmluZ30gKiBnZW4uZXhwKCAuMDU3NzYyMjY1ICogKCR7aW5wdXRzWzBdfSAtIDY5KSApIClgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gdGhpcy50dW5pbmcgKiBNYXRoLmV4cCggLjA1Nzc2MjI2NSAqICggaW5wdXRzWzBdIC0gNjkpIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCB4LCBwcm9wcyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgZGVmYXVsdHMgPSB7IHR1bmluZzo0NDAgfVxuICBcbiAgaWYoIHByb3BzICE9PSB1bmRlZmluZWQgKSBPYmplY3QuYXNzaWduKCBwcm9wcy5kZWZhdWx0cyApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgZGVmYXVsdHMgKVxuICB1Z2VuLmlucHV0cyA9IFsgeCBdXG4gIFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5jb25zdCBwcm90byA9IHtcbiAgYmFzZW5hbWU6ICdtdWwnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gYCxcbiAgICAgICAgc3VtID0gMSwgbnVtQ291bnQgPSAwLCBtdWxBdEVuZCA9IGZhbHNlLCBhbHJlYWR5RnVsbFN1bW1lZCA9IHRydWVcblxuICAgIGlucHV0cy5mb3JFYWNoKCAodixpKSA9PiB7XG4gICAgICBpZiggaXNOYU4oIHYgKSApIHtcbiAgICAgICAgb3V0ICs9IHZcbiAgICAgICAgaWYoIGkgPCBpbnB1dHMubGVuZ3RoIC0xICkge1xuICAgICAgICAgIG11bEF0RW5kID0gdHJ1ZVxuICAgICAgICAgIG91dCArPSAnICogJ1xuICAgICAgICB9XG4gICAgICAgIGFscmVhZHlGdWxsU3VtbWVkID0gZmFsc2VcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggaSA9PT0gMCApIHtcbiAgICAgICAgICBzdW0gPSB2XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHN1bSAqPSBwYXJzZUZsb2F0KCB2IClcbiAgICAgICAgfVxuICAgICAgICBudW1Db3VudCsrXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKCBudW1Db3VudCA+IDAgKSB7XG4gICAgICBvdXQgKz0gbXVsQXRFbmQgfHwgYWxyZWFkeUZ1bGxTdW1tZWQgPyBzdW0gOiAnICogJyArIHN1bVxuICAgIH1cblxuICAgIG91dCArPSAnXFxuJ1xuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIC4uLmFyZ3MgKSA9PiB7XG4gIGNvbnN0IG11bCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgXG4gIE9iamVjdC5hc3NpZ24oIG11bCwge1xuICAgICAgaWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgICBpbnB1dHM6IGFyZ3MsXG4gIH0pXG4gIFxuICBtdWwubmFtZSA9IG11bC5iYXNlbmFtZSArIG11bC5pZFxuXG4gIHJldHVybiBtdWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J25lcScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksIG91dFxuXG4gICAgb3V0ID0gLyp0aGlzLmlucHV0c1swXSAhPT0gdGhpcy5pbnB1dHNbMV0gPyAxIDoqLyBgICB2YXIgJHt0aGlzLm5hbWV9ID0gKCR7aW5wdXRzWzBdfSAhPT0gJHtpbnB1dHNbMV19KSB8IDBcXG5cXG5gXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWVcblxuICAgIHJldHVybiBbIHRoaXMubmFtZSwgb3V0IF1cbiAgfSxcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xLCBpbjIgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7XG4gICAgdWlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogIFsgaW4xLCBpbjIgXSxcbiAgfSlcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBuYW1lOidub2lzZScsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXRcblxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ25vaXNlJyA6IGlzV29ya2xldCA/ICdNYXRoLnJhbmRvbScgOiBNYXRoLnJhbmRvbSB9KVxuXG4gICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfSA9ICR7cmVmfW5vaXNlKClcXG5gXG4gICAgXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lXG5cbiAgICByZXR1cm4gWyB0aGlzLm5hbWUsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IG5vaXNlID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBub2lzZS5uYW1lID0gcHJvdG8ubmFtZSArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiBub2lzZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIG5hbWU6J25vdCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgaWYoIGlzTmFOKCB0aGlzLmlucHV0c1swXSApICkge1xuICAgICAgb3V0ID0gYCggJHtpbnB1dHNbMF19ID09PSAwID8gMSA6IDAgKWBcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gIWlucHV0c1swXSA9PT0gMCA/IDEgOiAwXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgbm90ID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIG5vdC5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBub3Rcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGRhdGEgPSByZXF1aXJlKCAnLi9kYXRhLmpzJyApLFxuICAgIHBlZWsgPSByZXF1aXJlKCAnLi9wZWVrLmpzJyApLFxuICAgIG11bCAgPSByZXF1aXJlKCAnLi9tdWwuanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZToncGFuJywgXG4gIGluaXRUYWJsZSgpIHsgICAgXG4gICAgbGV0IGJ1ZmZlckwgPSBuZXcgRmxvYXQzMkFycmF5KCAxMDI0ICksXG4gICAgICAgIGJ1ZmZlclIgPSBuZXcgRmxvYXQzMkFycmF5KCAxMDI0IClcblxuICAgIGNvbnN0IGFuZ1RvUmFkID0gTWF0aC5QSSAvIDE4MFxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgMTAyNDsgaSsrICkgeyBcbiAgICAgIGxldCBwYW4gPSBpICogKCA5MCAvIDEwMjQgKVxuICAgICAgYnVmZmVyTFtpXSA9IE1hdGguY29zKCBwYW4gKiBhbmdUb1JhZCApIFxuICAgICAgYnVmZmVyUltpXSA9IE1hdGguc2luKCBwYW4gKiBhbmdUb1JhZCApXG4gICAgfVxuXG4gICAgZ2VuLmdsb2JhbHMucGFuTCA9IGRhdGEoIGJ1ZmZlckwsIDEsIHsgaW1tdXRhYmxlOnRydWUgfSlcbiAgICBnZW4uZ2xvYmFscy5wYW5SID0gZGF0YSggYnVmZmVyUiwgMSwgeyBpbW11dGFibGU6dHJ1ZSB9KVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGxlZnRJbnB1dCwgcmlnaHRJbnB1dCwgcGFuID0uNSwgcHJvcGVydGllcyApID0+IHtcbiAgaWYoIGdlbi5nbG9iYWxzLnBhbkwgPT09IHVuZGVmaW5lZCApIHByb3RvLmluaXRUYWJsZSgpXG5cbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICBbIGxlZnRJbnB1dCwgcmlnaHRJbnB1dCBdLFxuICAgIGxlZnQ6ICAgIG11bCggbGVmdElucHV0LCBwZWVrKCBnZW4uZ2xvYmFscy5wYW5MLCBwYW4sIHsgYm91bmRtb2RlOidjbGFtcCcgfSkgKSxcbiAgICByaWdodDogICBtdWwoIHJpZ2h0SW5wdXQsIHBlZWsoIGdlbi5nbG9iYWxzLnBhblIsIHBhbiwgeyBib3VuZG1vZGU6J2NsYW1wJyB9KSApXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTogJ3BhcmFtJyxcblxuICBnZW4oKSB7XG4gICAgZ2VuLnJlcXVlc3RNZW1vcnkoIHRoaXMubWVtb3J5IClcbiAgICBcbiAgICBnZW4ucGFyYW1zLmFkZCggdGhpcyApXG5cbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG5cbiAgICBpZiggaXNXb3JrbGV0ICkgZ2VuLnBhcmFtZXRlcnMuYWRkKCB0aGlzLm5hbWUgKVxuXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSBpc1dvcmtsZXQgPyB0aGlzLm5hbWUgOiBgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1gXG5cbiAgICByZXR1cm4gZ2VuLm1lbW9bIHRoaXMubmFtZSBdXG4gIH0gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBwcm9wTmFtZT0wLCB2YWx1ZT0wLCBtaW49MCwgbWF4PTEgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBcbiAgaWYoIHR5cGVvZiBwcm9wTmFtZSAhPT0gJ3N0cmluZycgKSB7XG4gICAgdWdlbi5uYW1lID0gdWdlbi5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKVxuICAgIHVnZW4uaW5pdGlhbFZhbHVlID0gcHJvcE5hbWVcbiAgfWVsc2V7XG4gICAgdWdlbi5uYW1lID0gcHJvcE5hbWVcbiAgICB1Z2VuLmluaXRpYWxWYWx1ZSA9IHZhbHVlXG4gIH1cblxuICB1Z2VuLm1pbiA9IG1pblxuICB1Z2VuLm1heCA9IG1heFxuICB1Z2VuLmRlZmF1bHRWYWx1ZSA9IHVnZW4uaW5pdGlhbFZhbHVlXG5cbiAgLy8gZm9yIHN0b3Jpbmcgd29ya2xldCBub2RlcyBvbmNlIHRoZXkncmUgaW5zdGFudGlhdGVkXG4gIHVnZW4ud2FhcGkgPSBudWxsXG5cbiAgdWdlbi5pc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAndmFsdWUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYoIHRoaXMubWVtb3J5LnZhbHVlLmlkeCAhPT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuIGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF1cbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldCggdiApIHtcbiAgICAgIGlmKCB0aGlzLm1lbW9yeS52YWx1ZS5pZHggIT09IG51bGwgKSB7XG4gICAgICAgIGlmKCB0aGlzLmlzV29ya2xldCAmJiB0aGlzLndhYXBpICE9PSBudWxsICkge1xuICAgICAgICAgIHRoaXMud2FhcGkudmFsdWUgPSB2XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGdlbi5tZW1vcnkuaGVhcFsgdGhpcy5tZW1vcnkudmFsdWUuaWR4IF0gPSB2XG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVnZW4ubWVtb3J5ID0ge1xuICAgIHZhbHVlOiB7IGxlbmd0aDoxLCBpZHg6bnVsbCB9XG4gIH1cblxuICByZXR1cm4gdWdlblxufVxuIiwiXG5jb25zdCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKSxcbiAgICAgIGRhdGFVZ2VuID0gcmVxdWlyZSgnLi9kYXRhLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZToncGVlaycsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBnZW5OYW1lID0gJ2dlbi4nICsgdGhpcy5uYW1lLFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzICksXG4gICAgICAgIG91dCwgZnVuY3Rpb25Cb2R5LCBuZXh0LCBsZW5ndGhJc0xvZzIsIGlkeFxuICAgIFxuICAgIGlkeCA9IGlucHV0c1sxXVxuICAgIGxlbmd0aElzTG9nMiA9IChNYXRoLmxvZzIoIHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoICkgfCAwKSAgPT09IE1hdGgubG9nMiggdGhpcy5kYXRhLmJ1ZmZlci5sZW5ndGggKVxuXG4gICAgaWYoIHRoaXMubW9kZSAhPT0gJ3NpbXBsZScgKSB7XG5cbiAgICBmdW5jdGlvbkJvZHkgPSBgICB2YXIgJHt0aGlzLm5hbWV9X2RhdGFJZHggID0gJHtpZHh9LCBcbiAgICAgICR7dGhpcy5uYW1lfV9waGFzZSA9ICR7dGhpcy5tb2RlID09PSAnc2FtcGxlcycgPyBpbnB1dHNbMF0gOiBpbnB1dHNbMF0gKyAnICogJyArICh0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCkgfSwgXG4gICAgICAke3RoaXMubmFtZX1faW5kZXggPSAke3RoaXMubmFtZX1fcGhhc2UgfCAwLFxcbmBcblxuICAgIGlmKCB0aGlzLmJvdW5kbW9kZSA9PT0gJ3dyYXAnICkge1xuICAgICAgbmV4dCA9IGxlbmd0aElzTG9nMiA/XG4gICAgICBgKCAke3RoaXMubmFtZX1faW5kZXggKyAxICkgJiAoJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aH0gLSAxKWAgOlxuICAgICAgYCR7dGhpcy5uYW1lfV9pbmRleCArIDEgPj0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aH0gPyAke3RoaXMubmFtZX1faW5kZXggKyAxIC0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aH0gOiAke3RoaXMubmFtZX1faW5kZXggKyAxYFxuICAgIH1lbHNlIGlmKCB0aGlzLmJvdW5kbW9kZSA9PT0gJ2NsYW1wJyApIHtcbiAgICAgIG5leHQgPSBcbiAgICAgICAgYCR7dGhpcy5uYW1lfV9pbmRleCArIDEgPj0gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDF9ID8gJHt0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCAtIDF9IDogJHt0aGlzLm5hbWV9X2luZGV4ICsgMWBcbiAgICB9IGVsc2UgaWYoIHRoaXMuYm91bmRtb2RlID09PSAnZm9sZCcgfHwgdGhpcy5ib3VuZG1vZGUgPT09ICdtaXJyb3InICkge1xuICAgICAgbmV4dCA9IFxuICAgICAgICBgJHt0aGlzLm5hbWV9X2luZGV4ICsgMSA+PSAke3RoaXMuZGF0YS5idWZmZXIubGVuZ3RoIC0gMX0gPyAke3RoaXMubmFtZX1faW5kZXggLSAke3RoaXMuZGF0YS5idWZmZXIubGVuZ3RoIC0gMX0gOiAke3RoaXMubmFtZX1faW5kZXggKyAxYFxuICAgIH1lbHNle1xuICAgICAgIG5leHQgPSBcbiAgICAgIGAke3RoaXMubmFtZX1faW5kZXggKyAxYCAgICAgXG4gICAgfVxuXG4gICAgaWYoIHRoaXMuaW50ZXJwID09PSAnbGluZWFyJyApIHsgICAgICBcbiAgICBmdW5jdGlvbkJvZHkgKz0gYCAgICAgICR7dGhpcy5uYW1lfV9mcmFjICA9ICR7dGhpcy5uYW1lfV9waGFzZSAtICR7dGhpcy5uYW1lfV9pbmRleCxcbiAgICAgICR7dGhpcy5uYW1lfV9iYXNlICA9IG1lbW9yeVsgJHt0aGlzLm5hbWV9X2RhdGFJZHggKyAgJHt0aGlzLm5hbWV9X2luZGV4IF0sXG4gICAgICAke3RoaXMubmFtZX1fbmV4dCAgPSAke25leHR9LGBcbiAgICAgIFxuICAgICAgaWYoIHRoaXMuYm91bmRtb2RlID09PSAnaWdub3JlJyApIHtcbiAgICAgICAgZnVuY3Rpb25Cb2R5ICs9IGBcbiAgICAgICR7dGhpcy5uYW1lfV9vdXQgICA9ICR7dGhpcy5uYW1lfV9pbmRleCA+PSAke3RoaXMuZGF0YS5idWZmZXIubGVuZ3RoIC0gMX0gfHwgJHt0aGlzLm5hbWV9X2luZGV4IDwgMCA/IDAgOiAke3RoaXMubmFtZX1fYmFzZSArICR7dGhpcy5uYW1lfV9mcmFjICogKCBtZW1vcnlbICR7dGhpcy5uYW1lfV9kYXRhSWR4ICsgJHt0aGlzLm5hbWV9X25leHQgXSAtICR7dGhpcy5uYW1lfV9iYXNlIClcXG5cXG5gXG4gICAgICB9ZWxzZXtcbiAgICAgICAgZnVuY3Rpb25Cb2R5ICs9IGBcbiAgICAgICR7dGhpcy5uYW1lfV9vdXQgICA9ICR7dGhpcy5uYW1lfV9iYXNlICsgJHt0aGlzLm5hbWV9X2ZyYWMgKiAoIG1lbW9yeVsgJHt0aGlzLm5hbWV9X2RhdGFJZHggKyAke3RoaXMubmFtZX1fbmV4dCBdIC0gJHt0aGlzLm5hbWV9X2Jhc2UgKVxcblxcbmBcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIGZ1bmN0aW9uQm9keSArPSBgICAgICAgJHt0aGlzLm5hbWV9X291dCA9IG1lbW9yeVsgJHt0aGlzLm5hbWV9X2RhdGFJZHggKyAke3RoaXMubmFtZX1faW5kZXggXVxcblxcbmBcbiAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBtb2RlIGlzIHNpbXBsZVxuICAgICAgZnVuY3Rpb25Cb2R5ID0gYG1lbW9yeVsgJHtpZHh9ICsgJHsgaW5wdXRzWzBdIH0gXWBcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uQm9keVxuICAgIH1cblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IHRoaXMubmFtZSArICdfb3V0J1xuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lKydfb3V0JywgZnVuY3Rpb25Cb2R5IF1cbiAgfSxcblxuICBkZWZhdWx0cyA6IHsgY2hhbm5lbHM6MSwgbW9kZToncGhhc2UnLCBpbnRlcnA6J2xpbmVhcicsIGJvdW5kbW9kZTond3JhcCcgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW5wdXRfZGF0YSwgaW5kZXg9MCwgcHJvcGVydGllcyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgLy9jb25zb2xlLmxvZyggZGF0YVVnZW4sIGdlbi5kYXRhIClcblxuICAvLyBYWFggd2h5IGlzIGRhdGFVZ2VuIG5vdCB0aGUgYWN0dWFsIGZ1bmN0aW9uPyBzb21lIHR5cGUgb2YgYnJvd3NlcmlmeSBub25zZW5zZS4uLlxuICBjb25zdCBmaW5hbERhdGEgPSB0eXBlb2YgaW5wdXRfZGF0YS5iYXNlbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyBnZW4ubGliLmRhdGEoIGlucHV0X2RhdGEgKSA6IGlucHV0X2RhdGFcblxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCBcbiAgICB7IFxuICAgICAgJ2RhdGEnOiAgICAgZmluYWxEYXRhLFxuICAgICAgZGF0YU5hbWU6ICAgZmluYWxEYXRhLm5hbWUsXG4gICAgICB1aWQ6ICAgICAgICBnZW4uZ2V0VUlEKCksXG4gICAgICBpbnB1dHM6ICAgICBbIGluZGV4LCBmaW5hbERhdGEgXSxcbiAgICB9LFxuICAgIHByb3RvLmRlZmF1bHRzLFxuICAgIHByb3BlcnRpZXMgXG4gIClcbiAgXG4gIHVnZW4ubmFtZSA9IHVnZW4uYmFzZW5hbWUgKyB1Z2VuLnVpZFxuXG4gIHJldHVybiB1Z2VuXG59XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgYWNjdW0gPSByZXF1aXJlKCAnLi9hY2N1bS5qcycgKSxcbiAgICBtdWwgICA9IHJlcXVpcmUoICcuL211bC5qcycgKSxcbiAgICBwcm90byA9IHsgYmFzZW5hbWU6J3BoYXNvcicgfSxcbiAgICBkaXYgICA9IHJlcXVpcmUoICcuL2Rpdi5qcycgKVxuXG5jb25zdCBkZWZhdWx0cyA9IHsgbWluOiAtMSwgbWF4OiAxIH1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGZyZXF1ZW5jeSA9IDEsIHJlc2V0ID0gMCwgX3Byb3BzICkgPT4ge1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0cywgX3Byb3BzIClcblxuICBjb25zdCByYW5nZSA9IHByb3BzLm1heCAtIHByb3BzLm1pblxuXG4gIGNvbnN0IHVnZW4gPSB0eXBlb2YgZnJlcXVlbmN5ID09PSAnbnVtYmVyJyBcbiAgICA/IGFjY3VtKCAoZnJlcXVlbmN5ICogcmFuZ2UpIC8gZ2VuLnNhbXBsZXJhdGUsIHJlc2V0LCBwcm9wcyApIFxuICAgIDogYWNjdW0oIFxuICAgICAgICBkaXYoIFxuICAgICAgICAgIG11bCggZnJlcXVlbmN5LCByYW5nZSApLFxuICAgICAgICAgIGdlbi5zYW1wbGVyYXRlXG4gICAgICAgICksIFxuICAgICAgICByZXNldCwgcHJvcHMgXG4gICAgKVxuXG4gIHVnZW4ubmFtZSA9IHByb3RvLmJhc2VuYW1lICsgZ2VuLmdldFVJRCgpXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJyksXG4gICAgbXVsICA9IHJlcXVpcmUoJy4vbXVsLmpzJyksXG4gICAgd3JhcCA9IHJlcXVpcmUoJy4vd3JhcC5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3Bva2UnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgZGF0YU5hbWUgPSAnbWVtb3J5JyxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBpZHgsIG91dCwgd3JhcHBlZFxuICAgIFxuICAgIGlkeCA9IHRoaXMuZGF0YS5nZW4oKVxuXG4gICAgLy9nZW4ucmVxdWVzdE1lbW9yeSggdGhpcy5tZW1vcnkgKVxuICAgIC8vd3JhcHBlZCA9IHdyYXAoIHRoaXMuaW5wdXRzWzFdLCAwLCB0aGlzLmRhdGFMZW5ndGggKS5nZW4oKVxuICAgIC8vaWR4ID0gd3JhcHBlZFswXVxuICAgIC8vZ2VuLmZ1bmN0aW9uQm9keSArPSB3cmFwcGVkWzFdXG4gICAgbGV0IG91dHB1dFN0ciA9IHRoaXMuaW5wdXRzWzFdID09PSAwID9cbiAgICAgIGAgICR7ZGF0YU5hbWV9WyAke2lkeH0gXSA9ICR7aW5wdXRzWzBdfVxcbmAgOlxuICAgICAgYCAgJHtkYXRhTmFtZX1bICR7aWR4fSArICR7aW5wdXRzWzFdfSBdID0gJHtpbnB1dHNbMF19XFxuYFxuXG4gICAgaWYoIHRoaXMuaW5saW5lID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBnZW4uZnVuY3Rpb25Cb2R5ICs9IG91dHB1dFN0clxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIFsgdGhpcy5pbmxpbmUsIG91dHB1dFN0ciBdXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9ICggZGF0YSwgdmFsdWUsIGluZGV4LCBwcm9wZXJ0aWVzICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvICksXG4gICAgICBkZWZhdWx0cyA9IHsgY2hhbm5lbHM6MSB9IFxuXG4gIGlmKCBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgKSBPYmplY3QuYXNzaWduKCBkZWZhdWx0cywgcHJvcGVydGllcyApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBcbiAgICBkYXRhLFxuICAgIGRhdGFOYW1lOiAgIGRhdGEubmFtZSxcbiAgICBkYXRhTGVuZ3RoOiBkYXRhLmJ1ZmZlci5sZW5ndGgsXG4gICAgdWlkOiAgICAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogICAgIFsgdmFsdWUsIGluZGV4IF0sXG4gIH0sXG4gIGRlZmF1bHRzIClcblxuXG4gIHVnZW4ubmFtZSA9IHVnZW4uYmFzZW5hbWUgKyB1Z2VuLnVpZFxuICBcbiAgZ2VuLmhpc3Rvcmllcy5zZXQoIHVnZW4ubmFtZSwgdWdlbiApXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZToncG93JyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgfHwgaXNOYU4oIGlucHV0c1sxXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdwb3cnOiBpc1dvcmtsZXQgPyAnTWF0aC5wb3cnIDogTWF0aC5wb3cgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXBvdyggJHtpbnB1dHNbMF19LCAke2lucHV0c1sxXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIHR5cGVvZiBpbnB1dHNbMF0gPT09ICdzdHJpbmcnICYmIGlucHV0c1swXVswXSA9PT0gJygnICkge1xuICAgICAgICBpbnB1dHNbMF0gPSBpbnB1dHNbMF0uc2xpY2UoMSwtMSlcbiAgICAgIH1cbiAgICAgIGlmKCB0eXBlb2YgaW5wdXRzWzFdID09PSAnc3RyaW5nJyAmJiBpbnB1dHNbMV1bMF0gPT09ICcoJyApIHtcbiAgICAgICAgaW5wdXRzWzFdID0gaW5wdXRzWzFdLnNsaWNlKDEsLTEpXG4gICAgICB9XG5cbiAgICAgIG91dCA9IE1hdGgucG93KCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSwgcGFyc2VGbG9hdCggaW5wdXRzWzFdKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh4LHkpID0+IHtcbiAgbGV0IHBvdyA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICBwb3cuaW5wdXRzID0gWyB4LHkgXVxuICBwb3cuaWQgPSBnZW4uZ2V0VUlEKClcbiAgcG93Lm5hbWUgPSBgJHtwb3cuYmFzZW5hbWV9e3Bvdy5pZH1gXG5cbiAgcmV0dXJuIHBvd1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuY29uc3QgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidwcm9jZXNzJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG5cbiAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWycnK3RoaXMuZnVuY25hbWVdIDogdGhpcy5mdW5jIH0pXG5cbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9ID0gZ2VuWycke3RoaXMuZnVuY25hbWV9J10oYFxuXG4gICAgaW5wdXRzLmZvckVhY2goICh2LGksYXJyICkgPT4ge1xuICAgICAgb3V0ICs9IGFyclsgaSBdXG4gICAgICBpZiggaSA8IGFyci5sZW5ndGggLSAxICkgb3V0ICs9ICcsJ1xuICAgIH0pXG5cbiAgICBvdXQgKz0gJylcXG4nXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWVcblxuICAgIHJldHVybiBbdGhpcy5uYW1lLCBvdXRdXG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgcHJvY2VzcyA9IHt9Ly8gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuICBjb25zdCBpZCA9IGdlbi5nZXRVSUQoKVxuICBwcm9jZXNzLm5hbWUgPSAncHJvY2VzcycgKyBpZCBcblxuICBwcm9jZXNzLmZ1bmMgPSBuZXcgRnVuY3Rpb24oIC4uLmFyZ3MgKVxuXG4gIC8vZ2VuLmdsb2JhbHNbIHByb2Nlc3MubmFtZSBdID0gcHJvY2Vzcy5mdW5jXG5cbiAgcHJvY2Vzcy5jYWxsID0gZnVuY3Rpb24oIC4uLmFyZ3MgICkge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgICBvdXRwdXQuZnVuY25hbWUgPSBwcm9jZXNzLm5hbWVcbiAgICBvdXRwdXQuZnVuYyA9IHByb2Nlc3MuZnVuY1xuICAgIG91dHB1dC5uYW1lID0gJ3Byb2Nlc3Nfb3V0XycgKyBpZFxuICAgIG91dHB1dC5wcm9jZXNzID0gcHJvY2Vzc1xuXG4gICAgb3V0cHV0LmlucHV0cyA9IGFyZ3NcblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIHJldHVybiBwcm9jZXNzIFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGhpc3RvcnkgPSByZXF1aXJlKCAnLi9oaXN0b3J5LmpzJyApLFxuICAgIHN1YiAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnICksXG4gICAgYWRkICAgICA9IHJlcXVpcmUoICcuL2FkZC5qcycgKSxcbiAgICBtdWwgICAgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIG1lbW8gICAgPSByZXF1aXJlKCAnLi9tZW1vLmpzJyApLFxuICAgIGRlbHRhICAgPSByZXF1aXJlKCAnLi9kZWx0YS5qcycgKSxcbiAgICB3cmFwICAgID0gcmVxdWlyZSggJy4vd3JhcC5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidyYXRlJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgcGhhc2UgID0gaGlzdG9yeSgpLFxuICAgICAgICBpbk1pbnVzMSA9IGhpc3RvcnkoKSxcbiAgICAgICAgZ2VuTmFtZSA9ICdnZW4uJyArIHRoaXMubmFtZSxcbiAgICAgICAgZmlsdGVyLCBzdW0sIG91dFxuXG4gICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IHRoaXMgfSkgXG5cbiAgICBvdXQgPSBcbmAgdmFyICR7dGhpcy5uYW1lfV9kaWZmID0gJHtpbnB1dHNbMF19IC0gJHtnZW5OYW1lfS5sYXN0U2FtcGxlXG4gIGlmKCAke3RoaXMubmFtZX1fZGlmZiA8IC0uNSApICR7dGhpcy5uYW1lfV9kaWZmICs9IDFcbiAgJHtnZW5OYW1lfS5waGFzZSArPSAke3RoaXMubmFtZX1fZGlmZiAqICR7aW5wdXRzWzFdfVxuICBpZiggJHtnZW5OYW1lfS5waGFzZSA+IDEgKSAke2dlbk5hbWV9LnBoYXNlIC09IDFcbiAgJHtnZW5OYW1lfS5sYXN0U2FtcGxlID0gJHtpbnB1dHNbMF19XG5gXG4gICAgb3V0ID0gJyAnICsgb3V0XG5cbiAgICByZXR1cm4gWyBnZW5OYW1lICsgJy5waGFzZScsIG91dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgcmF0ZSApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBcbiAgICBwaGFzZTogICAgICAwLFxuICAgIGxhc3RTYW1wbGU6IDAsXG4gICAgdWlkOiAgICAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0czogICAgIFsgaW4xLCByYXRlIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZToncm91bmQnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcblxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgdGhpcy5uYW1lIF06IGlzV29ya2xldCA/ICdNYXRoLnJvdW5kJyA6IE1hdGgucm91bmQgfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXJvdW5kKCAke2lucHV0c1swXX0gKWBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgcm91bmQgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgcm91bmQuaW5wdXRzID0gWyB4IF1cblxuICByZXR1cm4gcm91bmRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICAgICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidzYWgnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIC8vZ2VuLmRhdGFbIHRoaXMubmFtZSBdID0gMFxuICAgIC8vZ2VuLmRhdGFbIHRoaXMubmFtZSArICdfY29udHJvbCcgXSA9IDBcblxuICAgIGdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLm1lbW9yeSApXG5cblxuICAgIG91dCA9IFxuYCB2YXIgJHt0aGlzLm5hbWV9X2NvbnRyb2wgPSBtZW1vcnlbJHt0aGlzLm1lbW9yeS5jb250cm9sLmlkeH1dLFxuICAgICAgJHt0aGlzLm5hbWV9X3RyaWdnZXIgPSAke2lucHV0c1sxXX0gPiAke2lucHV0c1syXX0gPyAxIDogMFxuXG4gIGlmKCAke3RoaXMubmFtZX1fdHJpZ2dlciAhPT0gJHt0aGlzLm5hbWV9X2NvbnRyb2wgICkge1xuICAgIGlmKCAke3RoaXMubmFtZX1fdHJpZ2dlciA9PT0gMSApIFxuICAgICAgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV0gPSAke2lucHV0c1swXX1cbiAgICBcbiAgICBtZW1vcnlbJHt0aGlzLm1lbW9yeS5jb250cm9sLmlkeH1dID0gJHt0aGlzLm5hbWV9X3RyaWdnZXJcbiAgfVxuYFxuICAgIFxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGBtZW1vcnlbJHt0aGlzLm1lbW9yeS52YWx1ZS5pZHh9XWAvL2BnZW4uZGF0YS4ke3RoaXMubmFtZX1gXG5cbiAgICByZXR1cm4gWyBgbWVtb3J5WyR7dGhpcy5tZW1vcnkudmFsdWUuaWR4fV1gLCAnICcgK291dCBdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgY29udHJvbCwgdGhyZXNob2xkPTAsIHByb3BlcnRpZXMgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKSxcbiAgICAgIGRlZmF1bHRzID0geyBpbml0OjAgfVxuXG4gIGlmKCBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgKSBPYmplY3QuYXNzaWduKCBkZWZhdWx0cywgcHJvcGVydGllcyApXG5cbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBcbiAgICBsYXN0U2FtcGxlOiAwLFxuICAgIHVpZDogICAgICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICAgICBbIGluMSwgY29udHJvbCx0aHJlc2hvbGQgXSxcbiAgICBtZW1vcnk6IHtcbiAgICAgIGNvbnRyb2w6IHsgaWR4Om51bGwsIGxlbmd0aDoxIH0sXG4gICAgICB2YWx1ZTogICB7IGlkeDpudWxsLCBsZW5ndGg6MSB9LFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHMgKVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gPSByZXF1aXJlKCAnLi9nZW4uanMnIClcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTonc2VsZWN0b3InLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXQsIHJldHVyblZhbHVlID0gMFxuICAgIFxuICAgIHN3aXRjaCggaW5wdXRzLmxlbmd0aCApIHtcbiAgICAgIGNhc2UgMiA6XG4gICAgICAgIHJldHVyblZhbHVlID0gaW5wdXRzWzFdXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzIDpcbiAgICAgICAgb3V0ID0gYCAgdmFyICR7dGhpcy5uYW1lfV9vdXQgPSAke2lucHV0c1swXX0gPT09IDEgPyAke2lucHV0c1sxXX0gOiAke2lucHV0c1syXX1cXG5cXG5gO1xuICAgICAgICByZXR1cm5WYWx1ZSA9IFsgdGhpcy5uYW1lICsgJ19vdXQnLCBvdXQgXVxuICAgICAgICBicmVhazsgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ID0gXG5gIHZhciAke3RoaXMubmFtZX1fb3V0ID0gMFxuICBzd2l0Y2goICR7aW5wdXRzWzBdfSArIDEgKSB7XFxuYFxuXG4gICAgICAgIGZvciggbGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgb3V0ICs9YCAgICBjYXNlICR7aX06ICR7dGhpcy5uYW1lfV9vdXQgPSAke2lucHV0c1tpXX07IGJyZWFrO1xcbmAgXG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gJyAgfVxcblxcbidcbiAgICAgICAgXG4gICAgICAgIHJldHVyblZhbHVlID0gWyB0aGlzLm5hbWUgKyAnX291dCcsICcgJyArIG91dCBdXG4gICAgfVxuXG4gICAgZ2VuLm1lbW9bIHRoaXMubmFtZSBdID0gdGhpcy5uYW1lICsgJ19vdXQnXG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIC4uLmlucHV0cyApID0+IHtcbiAgbGV0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG4gIFxuICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7XG4gICAgdWlkOiAgICAgZ2VuLmdldFVJRCgpLFxuICAgIGlucHV0c1xuICB9KVxuICBcbiAgdWdlbi5uYW1lID0gYCR7dWdlbi5iYXNlbmFtZX0ke3VnZW4udWlkfWBcblxuICByZXR1cm4gdWdlblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICA9IHJlcXVpcmUoICcuL2dlbi5qcycgKSxcbiAgICBhY2N1bSA9IHJlcXVpcmUoICcuL2FjY3VtLmpzJyApLFxuICAgIGNvdW50ZXI9IHJlcXVpcmUoICcuL2NvdW50ZXIuanMnICksXG4gICAgcGVlayAgPSByZXF1aXJlKCAnLi9wZWVrLmpzJyApLFxuICAgIHNzZCAgID0gcmVxdWlyZSggJy4vaGlzdG9yeS5qcycgKSxcbiAgICBkYXRhICA9IHJlcXVpcmUoICcuL2RhdGEuanMnICksXG4gICAgcHJvdG8gPSB7IGJhc2VuYW1lOidzZXEnIH1cblxubW9kdWxlLmV4cG9ydHMgPSAoIGR1cmF0aW9ucyA9IDExMDI1LCB2YWx1ZXMgPSBbMCwxXSwgcGhhc2VJbmNyZW1lbnQgPSAxKSA9PiB7XG4gIGxldCBjbG9ja1xuICBcbiAgaWYoIEFycmF5LmlzQXJyYXkoIGR1cmF0aW9ucyApICkge1xuICAgIC8vIHdlIHdhbnQgYSBjb3VudGVyIHRoYXQgaXMgdXNpbmcgb3VyIGN1cnJlbnRcbiAgICAvLyByYXRlIHZhbHVlLCBidXQgd2Ugd2FudCB0aGUgcmF0ZSB2YWx1ZSB0byBiZSBkZXJpdmVkIGZyb21cbiAgICAvLyB0aGUgY291bnRlci4gbXVzdCBpbnNlcnQgYSBzaW5nbGUtc2FtcGxlIGRlYWx5IHRvIGF2b2lkXG4gICAgLy8gaW5maW5pdGUgbG9vcC5cbiAgICBjb25zdCBjbG9jazIgPSBjb3VudGVyKCAwLCAwLCBkdXJhdGlvbnMubGVuZ3RoIClcbiAgICBjb25zdCBfX2R1cmF0aW9ucyA9IHBlZWsoIGRhdGEoIGR1cmF0aW9ucyApLCBjbG9jazIsIHsgbW9kZTonc2ltcGxlJyB9KSBcbiAgICBjbG9jayA9IGNvdW50ZXIoIHBoYXNlSW5jcmVtZW50LCAwLCBfX2R1cmF0aW9ucyApXG4gICAgXG4gICAgLy8gYWRkIG9uZSBzYW1wbGUgZGVsYXkgdG8gYXZvaWQgY29kZWdlbiBsb29wXG4gICAgY29uc3QgcyA9IHNzZCgpXG4gICAgcy5pbiggY2xvY2sud3JhcCApXG4gICAgY2xvY2syLmlucHV0c1swXSA9IHMub3V0XG4gIH1lbHNle1xuICAgIC8vIGlmIHRoZSByYXRlIGFyZ3VtZW50IGlzIGEgc2luZ2xlIHZhbHVlIHdlIGRvbid0IG5lZWQgdG9cbiAgICAvLyBkbyBhbnl0aGluZyB0cmlja3kuXG4gICAgY2xvY2sgPSBjb3VudGVyKCBwaGFzZUluY3JlbWVudCwgMCwgZHVyYXRpb25zIClcbiAgfVxuICBcbiAgY29uc3Qgc3RlcHBlciA9IGFjY3VtKCBjbG9jay53cmFwLCAwLCB7IG1pbjowLCBtYXg6dmFsdWVzLmxlbmd0aCB9KVxuICAgXG4gIGNvbnN0IHVnZW4gPSBwZWVrKCBkYXRhKCB2YWx1ZXMgKSwgc3RlcHBlciwgeyBtb2RlOidzaW1wbGUnIH0pXG5cbiAgdWdlbi5uYW1lID0gcHJvdG8uYmFzZW5hbWUgKyBnZW4uZ2V0VUlEKClcbiAgdWdlbi50cmlnZ2VyID0gY2xvY2sud3JhcFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgbmFtZTonc2lnbicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgWyB0aGlzLm5hbWUgXTogaXNXb3JrbGV0ID8gJ01hdGguc2lnbicgOiBNYXRoLnNpZ24gfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXNpZ24oICR7aW5wdXRzWzBdfSApYFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguc2lnbiggcGFyc2VGbG9hdCggaW5wdXRzWzBdICkgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IHNpZ24gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgc2lnbi5pbnB1dHMgPSBbIHggXVxuXG4gIHJldHVybiBzaWduXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3NpbicsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKVxuICAgIFxuICAgIFxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7ICdzaW4nOiBpc1dvcmtsZXQgPyAnTWF0aC5zaW4nIDogTWF0aC5zaW4gfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXNpbiggJHtpbnB1dHNbMF19IClgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IE1hdGguc2luKCBwYXJzZUZsb2F0KCBpbnB1dHNbMF0gKSApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHggPT4ge1xuICBsZXQgc2luID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIHNpbi5pbnB1dHMgPSBbIHggXVxuICBzaW4uaWQgPSBnZW4uZ2V0VUlEKClcbiAgc2luLm5hbWUgPSBgJHtzaW4uYmFzZW5hbWV9e3Npbi5pZH1gXG5cbiAgcmV0dXJuIHNpblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGhpc3RvcnkgPSByZXF1aXJlKCAnLi9oaXN0b3J5LmpzJyApLFxuICAgIHN1YiAgICAgPSByZXF1aXJlKCAnLi9zdWIuanMnICksXG4gICAgYWRkICAgICA9IHJlcXVpcmUoICcuL2FkZC5qcycgKSxcbiAgICBtdWwgICAgID0gcmVxdWlyZSggJy4vbXVsLmpzJyApLFxuICAgIG1lbW8gICAgPSByZXF1aXJlKCAnLi9tZW1vLmpzJyApLFxuICAgIGd0ICAgICAgPSByZXF1aXJlKCAnLi9ndC5qcycgKSxcbiAgICBkaXYgICAgID0gcmVxdWlyZSggJy4vZGl2LmpzJyApLFxuICAgIF9zd2l0Y2ggPSByZXF1aXJlKCAnLi9zd2l0Y2guanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSAoIGluMSwgc2xpZGVVcCA9IDEsIHNsaWRlRG93biA9IDEgKSA9PiB7XG4gIGxldCB5MSA9IGhpc3RvcnkoMCksXG4gICAgICBmaWx0ZXIsIHNsaWRlQW1vdW50XG5cbiAgLy95IChuKSA9IHkgKG4tMSkgKyAoKHggKG4pIC0geSAobi0xKSkvc2xpZGUpIFxuICBzbGlkZUFtb3VudCA9IF9zd2l0Y2goIGd0KGluMSx5MS5vdXQpLCBzbGlkZVVwLCBzbGlkZURvd24gKVxuXG4gIGZpbHRlciA9IG1lbW8oIGFkZCggeTEub3V0LCBkaXYoIHN1YiggaW4xLCB5MS5vdXQgKSwgc2xpZGVBbW91bnQgKSApIClcblxuICB5MS5pbiggZmlsdGVyIClcblxuICByZXR1cm4gZmlsdGVyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZ2VuID0gcmVxdWlyZSgnLi9nZW4uanMnKVxuXG5jb25zdCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3N1YicsXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLFxuICAgICAgICBvdXQ9MCxcbiAgICAgICAgZGlmZiA9IDAsXG4gICAgICAgIG5lZWRzUGFyZW5zID0gZmFsc2UsIFxuICAgICAgICBudW1Db3VudCA9IDAsXG4gICAgICAgIGxhc3ROdW1iZXIgPSBpbnB1dHNbIDAgXSxcbiAgICAgICAgbGFzdE51bWJlcklzVWdlbiA9IGlzTmFOKCBsYXN0TnVtYmVyICksIFxuICAgICAgICBzdWJBdEVuZCA9IGZhbHNlLFxuICAgICAgICBoYXNVZ2VucyA9IGZhbHNlLFxuICAgICAgICByZXR1cm5WYWx1ZSA9IDBcblxuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goIHZhbHVlID0+IHsgaWYoIGlzTmFOKCB2YWx1ZSApICkgaGFzVWdlbnMgPSB0cnVlIH0pXG5cbiAgICBvdXQgPSAnICB2YXIgJyArIHRoaXMubmFtZSArICcgPSAnXG5cbiAgICBpbnB1dHMuZm9yRWFjaCggKHYsaSkgPT4ge1xuICAgICAgaWYoIGkgPT09IDAgKSByZXR1cm5cblxuICAgICAgbGV0IGlzTnVtYmVyVWdlbiA9IGlzTmFOKCB2ICksXG4gICAgICAgICAgaXNGaW5hbElkeCAgID0gaSA9PT0gaW5wdXRzLmxlbmd0aCAtIDFcblxuICAgICAgaWYoICFsYXN0TnVtYmVySXNVZ2VuICYmICFpc051bWJlclVnZW4gKSB7XG4gICAgICAgIGxhc3ROdW1iZXIgPSBsYXN0TnVtYmVyIC0gdlxuICAgICAgICBvdXQgKz0gbGFzdE51bWJlclxuICAgICAgICByZXR1cm5cbiAgICAgIH1lbHNle1xuICAgICAgICBuZWVkc1BhcmVucyA9IHRydWVcbiAgICAgICAgb3V0ICs9IGAke2xhc3ROdW1iZXJ9IC0gJHt2fWBcbiAgICAgIH1cblxuICAgICAgaWYoICFpc0ZpbmFsSWR4ICkgb3V0ICs9ICcgLSAnIFxuICAgIH0pXG5cbiAgICBvdXQgKz0gJ1xcbidcblxuICAgIHJldHVyblZhbHVlID0gWyB0aGlzLm5hbWUsIG91dCBdXG5cbiAgICBnZW4ubWVtb1sgdGhpcy5uYW1lIF0gPSB0aGlzLm5hbWVcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoIC4uLmFyZ3MgKSA9PiB7XG4gIGxldCBzdWIgPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgT2JqZWN0LmFzc2lnbiggc3ViLCB7XG4gICAgaWQ6ICAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBhcmdzXG4gIH0pXG4gICAgICAgXG4gIHN1Yi5uYW1lID0gJ3N1YicgKyBzdWIuaWRcblxuICByZXR1cm4gc3ViXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiA9IHJlcXVpcmUoICcuL2dlbi5qcycgKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOidzd2l0Y2gnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApLCBvdXRcblxuICAgIGlmKCBpbnB1dHNbMV0gPT09IGlucHV0c1syXSApIHJldHVybiBpbnB1dHNbMV0gLy8gaWYgYm90aCBwb3RlbnRpYWwgb3V0cHV0cyBhcmUgdGhlIHNhbWUganVzdCByZXR1cm4gb25lIG9mIHRoZW1cbiAgICBcbiAgICBvdXQgPSBgICB2YXIgJHt0aGlzLm5hbWV9X291dCA9ICR7aW5wdXRzWzBdfSA9PT0gMSA/ICR7aW5wdXRzWzFdfSA6ICR7aW5wdXRzWzJdfVxcbmBcblxuICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IGAke3RoaXMubmFtZX1fb3V0YFxuXG4gICAgcmV0dXJuIFsgYCR7dGhpcy5uYW1lfV9vdXRgLCBvdXQgXVxuICB9LFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCBjb250cm9sLCBpbjEgPSAxLCBpbjIgPSAwICkgPT4ge1xuICBsZXQgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcbiAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgIHVpZDogICAgIGdlbi5nZXRVSUQoKSxcbiAgICBpbnB1dHM6ICBbIGNvbnRyb2wsIGluMSwgaW4yIF0sXG4gIH0pXG4gIFxuICB1Z2VuLm5hbWUgPSBgJHt1Z2VuLmJhc2VuYW1lfSR7dWdlbi51aWR9YFxuXG4gIHJldHVybiB1Z2VuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3Q2MCcsXG5cbiAgZ2VuKCkge1xuICAgIGxldCBvdXQsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgcmV0dXJuVmFsdWVcblxuICAgIGNvbnN0IGlzV29ya2xldCA9IGdlbi5tb2RlID09PSAnd29ya2xldCdcbiAgICBjb25zdCByZWYgPSBpc1dvcmtsZXQ/ICcnIDogJ2dlbi4nXG5cbiAgICBpZiggaXNOYU4oIGlucHV0c1swXSApICkge1xuICAgICAgZ2VuLmNsb3N1cmVzLmFkZCh7IFsgJ2V4cCcgXTogaXNXb3JrbGV0ID8gJ01hdGguZXhwJyA6IE1hdGguZXhwIH0pXG5cbiAgICAgIG91dCA9IGAgIHZhciAke3RoaXMubmFtZX0gPSAke3JlZn1leHAoIC02LjkwNzc1NTI3ODkyMSAvICR7aW5wdXRzWzBdfSApXFxuXFxuYFxuICAgICBcbiAgICAgIGdlbi5tZW1vWyB0aGlzLm5hbWUgXSA9IG91dFxuICAgICAgXG4gICAgICByZXR1cm5WYWx1ZSA9IFsgdGhpcy5uYW1lLCBvdXQgXVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLmV4cCggLTYuOTA3NzU1Mjc4OTIxIC8gaW5wdXRzWzBdIClcblxuICAgICAgcmV0dXJuVmFsdWUgPSBvdXRcbiAgICB9ICAgIFxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB4ID0+IHtcbiAgbGV0IHQ2MCA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICB0NjAuaW5wdXRzID0gWyB4IF1cbiAgdDYwLm5hbWUgPSBwcm90by5iYXNlbmFtZSArIGdlbi5nZXRVSUQoKVxuXG4gIHJldHVybiB0NjBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgZ2VuICA9IHJlcXVpcmUoJy4vZ2VuLmpzJylcblxubGV0IHByb3RvID0ge1xuICBiYXNlbmFtZTondGFuJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IG91dCxcbiAgICAgICAgaW5wdXRzID0gZ2VuLmdldElucHV0cyggdGhpcyApXG4gICAgXG4gICAgXG4gICAgY29uc3QgaXNXb3JrbGV0ID0gZ2VuLm1vZGUgPT09ICd3b3JrbGV0J1xuICAgIGNvbnN0IHJlZiA9IGlzV29ya2xldD8gJycgOiAnZ2VuLidcblxuICAgIGlmKCBpc05hTiggaW5wdXRzWzBdICkgKSB7XG4gICAgICBnZW4uY2xvc3VyZXMuYWRkKHsgJ3Rhbic6IGlzV29ya2xldCA/ICdNYXRoLnRhbicgOiBNYXRoLnRhbiB9KVxuXG4gICAgICBvdXQgPSBgJHtyZWZ9dGFuKCAke2lucHV0c1swXX0gKWAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gTWF0aC50YW4oIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCB0YW4gPSBPYmplY3QuY3JlYXRlKCBwcm90byApXG5cbiAgdGFuLmlucHV0cyA9IFsgeCBdXG4gIHRhbi5pZCA9IGdlbi5nZXRVSUQoKVxuICB0YW4ubmFtZSA9IGAke3Rhbi5iYXNlbmFtZX17dGFuLmlkfWBcblxuICByZXR1cm4gdGFuXG59XG4iLCIndXNlIHN0cmljdCdcblxubGV0IGdlbiAgPSByZXF1aXJlKCcuL2dlbi5qcycpXG5cbmxldCBwcm90byA9IHtcbiAgYmFzZW5hbWU6J3RhbmgnLFxuXG4gIGdlbigpIHtcbiAgICBsZXQgb3V0LFxuICAgICAgICBpbnB1dHMgPSBnZW4uZ2V0SW5wdXRzKCB0aGlzIClcbiAgICBcbiAgICBcbiAgICBjb25zdCBpc1dvcmtsZXQgPSBnZW4ubW9kZSA9PT0gJ3dvcmtsZXQnXG4gICAgY29uc3QgcmVmID0gaXNXb3JrbGV0PyAnJyA6ICdnZW4uJ1xuXG4gICAgaWYoIGlzTmFOKCBpbnB1dHNbMF0gKSApIHtcbiAgICAgIGdlbi5jbG9zdXJlcy5hZGQoeyAndGFuaCc6IGlzV29ya2xldCA/ICdNYXRoLnRhbicgOiBNYXRoLnRhbmggfSlcblxuICAgICAgb3V0ID0gYCR7cmVmfXRhbmgoICR7aW5wdXRzWzBdfSApYCBcblxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBNYXRoLnRhbmgoIHBhcnNlRmxvYXQoIGlucHV0c1swXSApIClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geCA9PiB7XG4gIGxldCB0YW5oID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIHRhbmguaW5wdXRzID0gWyB4IF1cbiAgdGFuaC5pZCA9IGdlbi5nZXRVSUQoKVxuICB0YW5oLm5hbWUgPSBgJHt0YW5oLmJhc2VuYW1lfXt0YW5oLmlkfWBcblxuICByZXR1cm4gdGFuaFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gICAgID0gcmVxdWlyZSggJy4vZ2VuLmpzJyApLFxuICAgIGx0ICAgICAgPSByZXF1aXJlKCAnLi9sdC5qcycgKSxcbiAgICBhY2N1bSAgID0gcmVxdWlyZSggJy4vYWNjdW0uanMnICksXG4gICAgZGl2ICAgICA9IHJlcXVpcmUoICcuL2Rpdi5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggZnJlcXVlbmN5PTQ0MCwgcHVsc2V3aWR0aD0uNSApID0+IHtcbiAgbGV0IGdyYXBoID0gbHQoIGFjY3VtKCBkaXYoIGZyZXF1ZW5jeSwgNDQxMDAgKSApLCBwdWxzZXdpZHRoIClcblxuICBncmFwaC5uYW1lID0gYHRyYWluJHtnZW4uZ2V0VUlEKCl9YFxuXG4gIHJldHVybiBncmFwaFxufVxuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQVdQRiA9IHJlcXVpcmUoICcuL2V4dGVybmFsL2F1ZGlvd29ya2xldC1wb2x5ZmlsbC5qcycgKSxcbiAgICAgIGdlbiAgPSByZXF1aXJlKCAnLi9nZW4uanMnICksXG4gICAgICBkYXRhID0gcmVxdWlyZSggJy4vZGF0YS5qcycgKVxuXG5sZXQgaXNTdGVyZW8gPSBmYWxzZVxuXG5jb25zdCB1dGlsaXRpZXMgPSB7XG4gIGN0eDogbnVsbCxcbiAgYnVmZmVyczoge30sXG4gIGlzU3RlcmVvOmZhbHNlLFxuXG4gIGNsZWFyKCkge1xuICAgIGlmKCB0aGlzLndvcmtsZXROb2RlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICB0aGlzLndvcmtsZXROb2RlLmRpc2Nvbm5lY3QoKVxuICAgIH1lbHNle1xuICAgICAgdGhpcy5jYWxsYmFjayA9ICgpID0+IDBcbiAgICB9XG4gICAgdGhpcy5jbGVhci5jYWxsYmFja3MuZm9yRWFjaCggdiA9PiB2KCkgKVxuICAgIHRoaXMuY2xlYXIuY2FsbGJhY2tzLmxlbmd0aCA9IDBcblxuICAgIHRoaXMuaXNTdGVyZW8gPSBmYWxzZVxuXG4gICAgaWYoIGdlbi5ncmFwaCAhPT0gbnVsbCApIGdlbi5mcmVlKCBnZW4uZ3JhcGggKVxuICB9LFxuXG4gIGNyZWF0ZUNvbnRleHQoIGJ1ZmZlclNpemUgPSAyMDQ4ICkge1xuICAgIGNvbnN0IEFDID0gdHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB3ZWJraXRBdWRpb0NvbnRleHQgOiBBdWRpb0NvbnRleHRcbiAgICBcbiAgICAvLyB0ZWxsIHBvbHlmaWxsIGdsb2JhbCBvYmplY3QgYW5kIGJ1ZmZlcnNpemVcbiAgICBBV1BGKCB3aW5kb3csIGJ1ZmZlclNpemUgKVxuXG4gICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiggdHlwZW9mIEFDICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQUMoeyBsYXRlbmN5SGludDouMDEyNSB9KVxuXG4gICAgICAgIGdlbi5zYW1wbGVyYXRlID0gdGhpcy5jdHguc2FtcGxlUmF0ZVxuXG4gICAgICAgIGlmKCBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHN0YXJ0IClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBzdGFydCApXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgc3RhcnQgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbXlTb3VyY2UgPSB1dGlsaXRpZXMuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gICAgICAgIG15U291cmNlLmNvbm5lY3QoIHV0aWxpdGllcy5jdHguZGVzdGluYXRpb24gKVxuICAgICAgICBteVNvdXJjZS5zdGFydCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBzdGFydCApXG4gICAgfWVsc2V7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIHN0YXJ0IClcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHN0YXJ0IClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIGNyZWF0ZVNjcmlwdFByb2Nlc3NvcigpIHtcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoIDEwMjQsIDAsIDIgKVxuICAgIHRoaXMuY2xlYXJGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9XG4gICAgaWYoIHR5cGVvZiB0aGlzLmNhbGxiYWNrID09PSAndW5kZWZpbmVkJyApIHRoaXMuY2FsbGJhY2sgPSB0aGlzLmNsZWFyRnVuY3Rpb25cblxuICAgIHRoaXMubm9kZS5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uKCBhdWRpb1Byb2Nlc3NpbmdFdmVudCApIHtcbiAgICAgIHZhciBvdXRwdXRCdWZmZXIgPSBhdWRpb1Byb2Nlc3NpbmdFdmVudC5vdXRwdXRCdWZmZXI7XG5cbiAgICAgIHZhciBsZWZ0ID0gb3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKCAwICksXG4gICAgICAgICAgcmlnaHQ9IG91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSggMSApLFxuICAgICAgICAgIGlzU3RlcmVvID0gdXRpbGl0aWVzLmlzU3RlcmVvXG5cbiAgICAgZm9yKCB2YXIgc2FtcGxlID0gMDsgc2FtcGxlIDwgbGVmdC5sZW5ndGg7IHNhbXBsZSsrICkge1xuICAgICAgICB2YXIgb3V0ID0gdXRpbGl0aWVzLmNhbGxiYWNrKClcblxuICAgICAgICBpZiggaXNTdGVyZW8gPT09IGZhbHNlICkge1xuICAgICAgICAgIGxlZnRbIHNhbXBsZSBdID0gcmlnaHRbIHNhbXBsZSBdID0gb3V0IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBsZWZ0WyBzYW1wbGUgIF0gPSBvdXRbMF1cbiAgICAgICAgICByaWdodFsgc2FtcGxlIF0gPSBvdXRbMV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubm9kZS5jb25uZWN0KCB0aGlzLmN0eC5kZXN0aW5hdGlvbiApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8vIHJlbW92ZSBzdGFydGluZyBzdHVmZiBhbmQgYWRkIHRhYnNcbiAgcHJldHR5UHJpbnRDYWxsYmFjayggY2IgKSB7XG4gICAgLy8gZ2V0IHJpZCBvZiBcImZ1bmN0aW9uIGdlblwiIGFuZCBzdGFydCB3aXRoIHBhcmVudGhlc2lzXG4gICAgLy8gY29uc3Qgc2hvcnRlbmRDQiA9IGNiLnRvU3RyaW5nKCkuc2xpY2UoOSlcbiAgICBjb25zdCBjYlNwbGl0ID0gY2IudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylcbiAgICBjb25zdCBjYlRyaW0gPSBjYlNwbGl0LnNsaWNlKCAzLCAtMiApXG4gICAgY29uc3QgY2JUYWJiZWQgPSBjYlRyaW0ubWFwKCB2ID0+ICcgICAgICAnICsgdiApIFxuICAgIFxuICAgIHJldHVybiBjYlRhYmJlZC5qb2luKCdcXG4nKVxuICB9LFxuXG4gIGNyZWF0ZVBhcmFtZXRlckRlc2NyaXB0b3JzKCBjYiApIHtcbiAgICAvLyBbe25hbWU6ICdhbXBsaXR1ZGUnLCBkZWZhdWx0VmFsdWU6IDAuMjUsIG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogMX1dO1xuICAgIGxldCBwYXJhbVN0ciA9ICcnXG5cbiAgICAvL2ZvciggbGV0IHVnZW4gb2YgY2IucGFyYW1zLnZhbHVlcygpICkge1xuICAgIC8vICBwYXJhbVN0ciArPSBgeyBuYW1lOicke3VnZW4ubmFtZX0nLCBkZWZhdWx0VmFsdWU6JHt1Z2VuLnZhbHVlfSwgbWluVmFsdWU6JHt1Z2VuLm1pbn0sIG1heFZhbHVlOiR7dWdlbi5tYXh9IH0sXFxuICAgICAgYFxuICAgIC8vfVxuICAgIGZvciggbGV0IHVnZW4gb2YgY2IucGFyYW1zLnZhbHVlcygpICkge1xuICAgICAgcGFyYW1TdHIgKz0gYHsgbmFtZTonJHt1Z2VuLm5hbWV9JywgYXV0b21hdGlvblJhdGU6J2stcmF0ZScsIGRlZmF1bHRWYWx1ZToke3VnZW4uZGVmYXVsdFZhbHVlfSwgbWluVmFsdWU6JHt1Z2VuLm1pbn0sIG1heFZhbHVlOiR7dWdlbi5tYXh9IH0sXFxuICAgICAgYFxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1TdHJcbiAgfSxcblxuICBjcmVhdGVQYXJhbWV0ZXJEZXJlZmVyZW5jZXMoIGNiICkge1xuICAgIGxldCBzdHIgPSBjYi5wYXJhbXMuc2l6ZSA+IDAgPyAnXFxuICAgICAgJyA6ICcnXG4gICAgZm9yKCBsZXQgdWdlbiBvZiBjYi5wYXJhbXMudmFsdWVzKCkgKSB7XG4gICAgICBzdHIgKz0gYGNvbnN0ICR7dWdlbi5uYW1lfSA9IHBhcmFtZXRlcnMuJHt1Z2VuLm5hbWV9WzBdXFxuICAgICAgYFxuICAgIH1cblxuICAgIHJldHVybiBzdHJcbiAgfSxcblxuICBjcmVhdGVQYXJhbWV0ZXJBcmd1bWVudHMoIGNiICkge1xuICAgIGxldCAgcGFyYW1MaXN0ID0gJydcbiAgICBmb3IoIGxldCB1Z2VuIG9mIGNiLnBhcmFtcy52YWx1ZXMoKSApIHtcbiAgICAgIHBhcmFtTGlzdCArPSB1Z2VuLm5hbWUgKyAnW2ldLCdcbiAgICB9XG4gICAgcGFyYW1MaXN0ID0gcGFyYW1MaXN0LnNsaWNlKCAwLCAtMSApXG5cbiAgICByZXR1cm4gcGFyYW1MaXN0XG4gIH0sXG5cbiAgY3JlYXRlSW5wdXREZXJlZmVyZW5jZXMoIGNiICkge1xuICAgIGxldCBzdHIgPSBjYi5pbnB1dHMuc2l6ZSA+IDAgPyAnXFxuJyA6ICcnXG4gICAgZm9yKCBsZXQgaW5wdXQgb2YgIGNiLmlucHV0cy52YWx1ZXMoKSApIHtcbiAgICAgIHN0ciArPSBgY29uc3QgJHtpbnB1dC5uYW1lfSA9IGlucHV0c1sgJHtpbnB1dC5pbnB1dE51bWJlcn0gXVsgJHtpbnB1dC5jaGFubmVsTnVtYmVyfSBdXFxuICAgICAgYFxuICAgIH1cblxuICAgIHJldHVybiBzdHJcbiAgfSxcblxuXG4gIGNyZWF0ZUlucHV0QXJndW1lbnRzKCBjYiApIHtcbiAgICBsZXQgIHBhcmFtTGlzdCA9ICcnXG4gICAgZm9yKCBsZXQgaW5wdXQgb2YgY2IuaW5wdXRzLnZhbHVlcygpICkge1xuICAgICAgcGFyYW1MaXN0ICs9IGlucHV0Lm5hbWUgKyAnW2ldLCdcbiAgICB9XG4gICAgcGFyYW1MaXN0ID0gcGFyYW1MaXN0LnNsaWNlKCAwLCAtMSApXG5cbiAgICByZXR1cm4gcGFyYW1MaXN0XG4gIH0sXG4gICAgICBcbiAgY3JlYXRlRnVuY3Rpb25EZXJlZmVyZW5jZXMoIGNiICkge1xuICAgIGxldCBtZW1iZXJTdHJpbmcgPSBjYi5tZW1iZXJzLnNpemUgPiAwID8gJ1xcbicgOiAnJ1xuICAgIGxldCBtZW1vID0ge31cbiAgICBmb3IoIGxldCBkaWN0IG9mIGNiLm1lbWJlcnMudmFsdWVzKCkgKSB7XG4gICAgICBjb25zdCBuYW1lID0gT2JqZWN0LmtleXMoIGRpY3QgKVswXSxcbiAgICAgICAgICAgIHZhbHVlID0gZGljdFsgbmFtZSBdXG5cbiAgICAgIGlmKCBtZW1vWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIGNvbnRpbnVlXG4gICAgICBtZW1vWyBuYW1lIF0gPSB0cnVlXG5cbiAgICAgIG1lbWJlclN0cmluZyArPSBgICAgICAgY29uc3QgJHtuYW1lfSA9ICR7dmFsdWV9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiBtZW1iZXJTdHJpbmdcbiAgfSxcblxuICBjcmVhdGVXb3JrbGV0UHJvY2Vzc29yKCBncmFwaCwgbmFtZSwgZGVidWcsIG1lbT00NDEwMCoxMCApIHtcbiAgICAvL2NvbnN0IG1lbSA9IE1lbW9yeUhlbHBlci5jcmVhdGUoIDQwOTYsIEZsb2F0NjRBcnJheSApXG4gICAgY29uc3QgY2IgPSBnZW4uY3JlYXRlQ2FsbGJhY2soIGdyYXBoLCBtZW0sIGRlYnVnIClcbiAgICBjb25zdCBpbnB1dHMgPSBjYi5pbnB1dHNcblxuICAgIC8vIGdldCBhbGwgaW5wdXRzIGFuZCBjcmVhdGUgYXBwcm9wcmlhdGUgYXVkaW9wYXJhbSBpbml0aWFsaXplcnNcbiAgICBjb25zdCBwYXJhbWV0ZXJEZXNjcmlwdG9ycyA9IHRoaXMuY3JlYXRlUGFyYW1ldGVyRGVzY3JpcHRvcnMoIGNiIClcbiAgICBjb25zdCBwYXJhbWV0ZXJEZXJlZmVyZW5jZXMgPSB0aGlzLmNyZWF0ZVBhcmFtZXRlckRlcmVmZXJlbmNlcyggY2IgKVxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuY3JlYXRlUGFyYW1ldGVyQXJndW1lbnRzKCBjYiApXG4gICAgY29uc3QgaW5wdXREZXJlZmVyZW5jZXMgPSB0aGlzLmNyZWF0ZUlucHV0RGVyZWZlcmVuY2VzKCBjYiApXG4gICAgY29uc3QgaW5wdXRMaXN0ID0gdGhpcy5jcmVhdGVJbnB1dEFyZ3VtZW50cyggY2IgKSAgIFxuICAgIGNvbnN0IG1lbWJlclN0cmluZyA9IHRoaXMuY3JlYXRlRnVuY3Rpb25EZXJlZmVyZW5jZXMoIGNiIClcblxuICAgIC8vIGNoYW5nZSBvdXRwdXQgYmFzZWQgb24gbnVtYmVyIG9mIGNoYW5uZWxzLlxuICAgIGNvbnN0IGdlbmlzaE91dHB1dExpbmUgPSBjYi5pc1N0ZXJlbyA9PT0gZmFsc2VcbiAgICAgID8gYGxlZnRbIGkgXSA9IG1lbW9yeVswXWBcbiAgICAgIDogYGxlZnRbIGkgXSA9IG1lbW9yeVswXTtcXG5cXHRcXHRyaWdodFsgaSBdID0gbWVtb3J5WzFdXFxuYFxuXG4gICAgY29uc3QgcHJldHR5Q2FsbGJhY2sgPSB0aGlzLnByZXR0eVByaW50Q2FsbGJhY2soIGNiIClcblxuICAgIC8qKioqKiBiZWdpbiBjYWxsYmFjayBjb2RlICoqKiovXG4gICAgLy8gbm90ZSB0aGF0IHdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIHRoYXQgbWVtb3J5IGhhcyBiZWVuIHBhc3NlZFxuICAgIC8vIHRvIHRoZSB3b3JrZXIgYmVmb3JlIHJ1bm5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBvdGhlcndpc2VcbiAgICAvLyBpdCBjYW4gYmUgcGFzc2VkIHRvbyBzbG93bHkgYW5kIGZhaWwgb24gb2NjYXNzaW9uXG5cbiAgICBjb25zdCB3b3JrbGV0Q29kZSA9IGBcbmNsYXNzICR7bmFtZX1Qcm9jZXNzb3IgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3Ige1xuXG4gIHN0YXRpYyBnZXQgcGFyYW1ldGVyRGVzY3JpcHRvcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgJHsgcGFyYW1ldGVyRGVzY3JpcHRvcnMgfSAgICAgIFxuICAgIF1cbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cbiBcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XG4gICAgc3VwZXIoIG9wdGlvbnMgKVxuICAgIHRoaXMucG9ydC5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCggdGhpcyApXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlXG4gIH1cblxuICBoYW5kbGVNZXNzYWdlKCBldmVudCApIHtcbiAgICBpZiggZXZlbnQuZGF0YS5rZXkgPT09ICdpbml0JyApIHtcbiAgICAgIHRoaXMubWVtb3J5ID0gZXZlbnQuZGF0YS5tZW1vcnlcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgfWVsc2UgaWYoIGV2ZW50LmRhdGEua2V5ID09PSAnc2V0JyApIHtcbiAgICAgIHRoaXMubWVtb3J5WyBldmVudC5kYXRhLmlkeCBdID0gZXZlbnQuZGF0YS52YWx1ZVxuICAgIH1lbHNlIGlmKCBldmVudC5kYXRhLmtleSA9PT0gJ2dldCcgKSB7XG4gICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoeyBrZXk6J3JldHVybicsIGlkeDpldmVudC5kYXRhLmlkeCwgdmFsdWU6dGhpcy5tZW1vcnlbZXZlbnQuZGF0YS5pZHhdIH0pICAgICBcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzKCBpbnB1dHMsIG91dHB1dHMsIHBhcmFtZXRlcnMgKSB7XG4gICAgaWYoIHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzWzBdXG4gICAgICBjb25zdCBsZWZ0ICAgPSBvdXRwdXRbIDAgXVxuICAgICAgY29uc3QgcmlnaHQgID0gb3V0cHV0WyAxIF1cbiAgICAgIGNvbnN0IGxlbiAgICA9IGxlZnQubGVuZ3RoXG4gICAgICBjb25zdCBtZW1vcnkgPSB0aGlzLm1lbW9yeSAke3BhcmFtZXRlckRlcmVmZXJlbmNlc30ke2lucHV0RGVyZWZlcmVuY2VzfSR7bWVtYmVyU3RyaW5nfVxuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAke3ByZXR0eUNhbGxiYWNrfVxuICAgICAgICAke2dlbmlzaE91dHB1dExpbmV9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cbiAgICBcbnJlZ2lzdGVyUHJvY2Vzc29yKCAnJHtuYW1lfScsICR7bmFtZX1Qcm9jZXNzb3IpYFxuXG4gICAgXG4gICAgLyoqKioqIGVuZCBjYWxsYmFjayBjb2RlICoqKioqL1xuXG5cbiAgICBpZiggZGVidWcgPT09IHRydWUgKSBjb25zb2xlLmxvZyggd29ya2xldENvZGUgKVxuXG4gICAgY29uc3QgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICBuZXcgQmxvYihcbiAgICAgICAgWyB3b3JrbGV0Q29kZSBdLCBcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9XG4gICAgICApXG4gICAgKVxuXG4gICAgcmV0dXJuIFsgdXJsLCB3b3JrbGV0Q29kZSwgaW5wdXRzLCBjYi5wYXJhbXMsIGNiLmlzU3RlcmVvIF0gXG4gIH0sXG5cbiAgcmVnaXN0ZXJlZEZvck5vZGVBc3NpZ25tZW50OiBbXSxcbiAgcmVnaXN0ZXIoIHVnZW4gKSB7XG4gICAgaWYoIHRoaXMucmVnaXN0ZXJlZEZvck5vZGVBc3NpZ25tZW50LmluZGV4T2YoIHVnZW4gKSA9PT0gLTEgKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRGb3JOb2RlQXNzaWdubWVudC5wdXNoKCB1Z2VuIClcbiAgICB9XG4gIH0sXG5cbiAgcGxheVdvcmtsZXQoIGdyYXBoLCBuYW1lLCBkZWJ1Zz1mYWxzZSwgbWVtPTQ0MTAwICogNjAgKSB7XG4gICAgdXRpbGl0aWVzLmNsZWFyKClcblxuICAgIGNvbnN0IFsgdXJsLCBjb2RlU3RyaW5nLCBpbnB1dHMsIHBhcmFtcywgaXNTdGVyZW8gXSA9IHV0aWxpdGllcy5jcmVhdGVXb3JrbGV0UHJvY2Vzc29yKCBncmFwaCwgbmFtZSwgZGVidWcsIG1lbSApXG5cbiAgICBjb25zdCBub2RlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSxyZWplY3QpID0+IHtcbiAgIFxuICAgICAgdXRpbGl0aWVzLmN0eC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKCB1cmwgKS50aGVuKCAoKT0+IHtcbiAgICAgICAgY29uc3Qgd29ya2xldE5vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZSggdXRpbGl0aWVzLmN0eCwgbmFtZSwgeyBvdXRwdXRDaGFubmVsQ291bnQ6WyBpc1N0ZXJlbyA/IDIgOiAxIF0gfSlcblxuICAgICAgICB3b3JrbGV0Tm9kZS5jYWxsYmFja3MgPSB7fVxuICAgICAgICB3b3JrbGV0Tm9kZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgaWYoIGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3JldHVybicgKSB7XG4gICAgICAgICAgICB3b3JrbGV0Tm9kZS5jYWxsYmFja3NbIGV2ZW50LmRhdGEuaWR4IF0oIGV2ZW50LmRhdGEudmFsdWUgKVxuICAgICAgICAgICAgZGVsZXRlIHdvcmtsZXROb2RlLmNhbGxiYWNrc1sgZXZlbnQuZGF0YS5pZHggXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtsZXROb2RlLmdldE1lbW9yeVZhbHVlID0gZnVuY3Rpb24oIGlkeCwgY2IgKSB7XG4gICAgICAgICAgdGhpcy53b3JrbGV0Q2FsbGJhY2tzWyBpZHggXSA9IGNiXG4gICAgICAgICAgdGhpcy53b3JrbGV0Tm9kZS5wb3J0LnBvc3RNZXNzYWdlKHsga2V5OidnZXQnLCBpZHg6IGlkeCB9KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB3b3JrbGV0Tm9kZS5wb3J0LnBvc3RNZXNzYWdlKHsga2V5Oidpbml0JywgbWVtb3J5Omdlbi5tZW1vcnkuaGVhcCB9KVxuICAgICAgICB1dGlsaXRpZXMud29ya2xldE5vZGUgPSB3b3JrbGV0Tm9kZVxuXG4gICAgICAgIHV0aWxpdGllcy5yZWdpc3RlcmVkRm9yTm9kZUFzc2lnbm1lbnQuZm9yRWFjaCggdWdlbiA9PiB1Z2VuLm5vZGUgPSB3b3JrbGV0Tm9kZSApXG4gICAgICAgIHV0aWxpdGllcy5yZWdpc3RlcmVkRm9yTm9kZUFzc2lnbm1lbnQubGVuZ3RoID0gMFxuXG4gICAgICAgIC8vIGFzc2lnbiBhbGwgcGFyYW1zIGFzIHByb3BlcnRpZXMgb2Ygbm9kZSBmb3IgZWFzaWVyIHJlZmVyZW5jZSBcbiAgICAgICAgZm9yKCBsZXQgZGljdCBvZiBpbnB1dHMudmFsdWVzKCkgKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IE9iamVjdC5rZXlzKCBkaWN0IClbMF1cbiAgICAgICAgICBjb25zdCBwYXJhbSA9IHdvcmtsZXROb2RlLnBhcmFtZXRlcnMuZ2V0KCBuYW1lIClcbiAgICAgIFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggd29ya2xldE5vZGUsIG5hbWUsIHtcbiAgICAgICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWUgPSB2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW0udmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCBsZXQgdWdlbiBvZiBwYXJhbXMudmFsdWVzKCkgKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHVnZW4ubmFtZVxuICAgICAgICAgIGNvbnN0IHBhcmFtID0gd29ya2xldE5vZGUucGFyYW1ldGVycy5nZXQoIG5hbWUgKVxuICAgICAgICAgIHVnZW4ud2FhcGkgPSBwYXJhbSBcbiAgICAgICAgICAvLyBpbml0aWFsaXplP1xuICAgICAgICAgIHBhcmFtLnZhbHVlID0gdWdlbi5kZWZhdWx0VmFsdWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggd29ya2xldE5vZGUsIG5hbWUsIHtcbiAgICAgICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICAgICAgcGFyYW0udmFsdWUgPSB2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW0udmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHV0aWxpdGllcy5jb25zb2xlICkgdXRpbGl0aWVzLmNvbnNvbGUuc2V0VmFsdWUoIGNvZGVTdHJpbmcgKVxuXG4gICAgICAgIHdvcmtsZXROb2RlLmNvbm5lY3QoIHV0aWxpdGllcy5jdHguZGVzdGluYXRpb24gKVxuXG4gICAgICAgIHJlc29sdmUoIHdvcmtsZXROb2RlIClcbiAgICAgIH0pXG5cbiAgICB9KVxuXG4gICAgcmV0dXJuIG5vZGVQcm9taXNlXG4gIH0sXG4gIFxuICBwbGF5R3JhcGgoIGdyYXBoLCBkZWJ1ZywgbWVtPTQ0MTAwKjEwLCBtZW1UeXBlPUZsb2F0MzJBcnJheSApIHtcbiAgICB1dGlsaXRpZXMuY2xlYXIoKVxuICAgIGlmKCBkZWJ1ZyA9PT0gdW5kZWZpbmVkICkgZGVidWcgPSBmYWxzZVxuICAgICAgICAgIFxuICAgIHRoaXMuaXNTdGVyZW8gPSBBcnJheS5pc0FycmF5KCBncmFwaCApXG5cbiAgICB1dGlsaXRpZXMuY2FsbGJhY2sgPSBnZW4uY3JlYXRlQ2FsbGJhY2soIGdyYXBoLCBtZW0sIGRlYnVnLCBmYWxzZSwgbWVtVHlwZSApXG4gICAgXG4gICAgaWYoIHV0aWxpdGllcy5jb25zb2xlICkgdXRpbGl0aWVzLmNvbnNvbGUuc2V0VmFsdWUoIHV0aWxpdGllcy5jYWxsYmFjay50b1N0cmluZygpIClcblxuICAgIHJldHVybiB1dGlsaXRpZXMuY2FsbGJhY2tcbiAgfSxcblxuICBsb2FkU2FtcGxlKCBzb3VuZEZpbGVQYXRoLCBkYXRhICkge1xuICAgIGNvbnN0IGlzTG9hZGVkID0gdXRpbGl0aWVzLmJ1ZmZlcnNbIHNvdW5kRmlsZVBhdGggXSAhPT0gdW5kZWZpbmVkXG5cbiAgICBsZXQgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICByZXEub3BlbiggJ0dFVCcsIHNvdW5kRmlsZVBhdGgsIHRydWUgKVxuICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInIFxuICAgIFxuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoIChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICAgICAgaWYoICFpc0xvYWRlZCApIHtcbiAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhdWRpb0RhdGEgPSByZXEucmVzcG9uc2VcblxuICAgICAgICAgIHV0aWxpdGllcy5jdHguZGVjb2RlQXVkaW9EYXRhKCBhdWRpb0RhdGEsIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYnVmZmVyID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApXG4gICAgICAgICAgICB1dGlsaXRpZXMuYnVmZmVyc1sgc291bmRGaWxlUGF0aCBdID0gZGF0YS5idWZmZXJcbiAgICAgICAgICAgIHJlc29sdmUoIGRhdGEuYnVmZmVyIClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgc2V0VGltZW91dCggKCk9PiByZXNvbHZlKCB1dGlsaXRpZXMuYnVmZmVyc1sgc291bmRGaWxlUGF0aCBdICksIDAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiggIWlzTG9hZGVkICkgcmVxLnNlbmQoKVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG59XG5cbnV0aWxpdGllcy5jbGVhci5jYWxsYmFja3MgPSBbXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxpdGllc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gKiBtYW55IHdpbmRvd3MgaGVyZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvcmJhbmJyb29rL2RzcC5qcy9ibG9iL21hc3Rlci9kc3AuanNcbiAqIHN0YXJ0aW5nIGF0IGxpbmUgMTQyN1xuICogdGFrZW4gOC8xNS8xNlxuKi8gXG5cbmNvbnN0IHdpbmRvd3MgPSBtb2R1bGUuZXhwb3J0cyA9IHsgXG4gIGJhcnRsZXR0KCBsZW5ndGgsIGluZGV4ICkge1xuICAgIHJldHVybiAyIC8gKGxlbmd0aCAtIDEpICogKChsZW5ndGggLSAxKSAvIDIgLSBNYXRoLmFicyhpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpKSBcbiAgfSxcblxuICBiYXJ0bGV0dEhhbm4oIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIDAuNjIgLSAwLjQ4ICogTWF0aC5hYnMoaW5kZXggLyAobGVuZ3RoIC0gMSkgLSAwLjUpIC0gMC4zOCAqIE1hdGguY29zKCAyICogTWF0aC5QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKVxuICB9LFxuXG4gIGJsYWNrbWFuKCBsZW5ndGgsIGluZGV4LCBhbHBoYSApIHtcbiAgICBsZXQgYTAgPSAoMSAtIGFscGhhKSAvIDIsXG4gICAgICAgIGExID0gMC41LFxuICAgICAgICBhMiA9IGFscGhhIC8gMlxuXG4gICAgcmV0dXJuIGEwIC0gYTEgKiBNYXRoLmNvcygyICogTWF0aC5QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKSArIGEyICogTWF0aC5jb3MoNCAqIE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSlcbiAgfSxcblxuICBjb3NpbmUoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIE1hdGguY29zKE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSAtIE1hdGguUEkgLyAyKVxuICB9LFxuXG4gIGdhdXNzKCBsZW5ndGgsIGluZGV4LCBhbHBoYSApIHtcbiAgICByZXR1cm4gTWF0aC5wb3coTWF0aC5FLCAtMC41ICogTWF0aC5wb3coKGluZGV4IC0gKGxlbmd0aCAtIDEpIC8gMikgLyAoYWxwaGEgKiAobGVuZ3RoIC0gMSkgLyAyKSwgMikpXG4gIH0sXG5cbiAgaGFtbWluZyggbGVuZ3RoLCBpbmRleCApIHtcbiAgICByZXR1cm4gMC41NCAtIDAuNDYgKiBNYXRoLmNvcyggTWF0aC5QSSAqIDIgKiBpbmRleCAvIChsZW5ndGggLSAxKSlcbiAgfSxcblxuICBoYW5uKCBsZW5ndGgsIGluZGV4ICkge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKCBNYXRoLlBJICogMiAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKSApXG4gIH0sXG5cbiAgbGFuY3pvcyggbGVuZ3RoLCBpbmRleCApIHtcbiAgICBsZXQgeCA9IDIgKiBpbmRleCAvIChsZW5ndGggLSAxKSAtIDE7XG4gICAgcmV0dXJuIE1hdGguc2luKE1hdGguUEkgKiB4KSAvIChNYXRoLlBJICogeClcbiAgfSxcblxuICByZWN0YW5ndWxhciggbGVuZ3RoLCBpbmRleCApIHtcbiAgICByZXR1cm4gMVxuICB9LFxuXG4gIHRyaWFuZ3VsYXIoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgcmV0dXJuIDIgLyBsZW5ndGggKiAobGVuZ3RoIC8gMiAtIE1hdGguYWJzKGluZGV4IC0gKGxlbmd0aCAtIDEpIC8gMikpXG4gIH0sXG5cbiAgLy8gcGFyYWJvbGFcbiAgd2VsY2goIGxlbmd0aCwgX2luZGV4LCBpZ25vcmUsIHNoaWZ0PTAgKSB7XG4gICAgLy93W25dID0gMSAtIE1hdGgucG93KCAoIG4gLSAoIChOLTEpIC8gMiApICkgLyAoKCBOLTEgKSAvIDIgKSwgMiApXG4gICAgY29uc3QgaW5kZXggPSBzaGlmdCA9PT0gMCA/IF9pbmRleCA6IChfaW5kZXggKyBNYXRoLmZsb29yKCBzaGlmdCAqIGxlbmd0aCApKSAlIGxlbmd0aFxuICAgIGNvbnN0IG5fMV9vdmVyMiA9IChsZW5ndGggLSAxKSAvIDIgXG5cbiAgICByZXR1cm4gMSAtIE1hdGgucG93KCAoIGluZGV4IC0gbl8xX292ZXIyICkgLyBuXzFfb3ZlcjIsIDIgKVxuICB9LFxuICBpbnZlcnNld2VsY2goIGxlbmd0aCwgX2luZGV4LCBpZ25vcmUsIHNoaWZ0PTAgKSB7XG4gICAgLy93W25dID0gMSAtIE1hdGgucG93KCAoIG4gLSAoIChOLTEpIC8gMiApICkgLyAoKCBOLTEgKSAvIDIgKSwgMiApXG4gICAgbGV0IGluZGV4ID0gc2hpZnQgPT09IDAgPyBfaW5kZXggOiAoX2luZGV4ICsgTWF0aC5mbG9vciggc2hpZnQgKiBsZW5ndGggKSkgJSBsZW5ndGhcbiAgICBjb25zdCBuXzFfb3ZlcjIgPSAobGVuZ3RoIC0gMSkgLyAyXG5cbiAgICByZXR1cm4gTWF0aC5wb3coICggaW5kZXggLSBuXzFfb3ZlcjIgKSAvIG5fMV9vdmVyMiwgMiApXG4gIH0sXG5cbiAgcGFyYWJvbGEoIGxlbmd0aCwgaW5kZXggKSB7XG4gICAgaWYoIGluZGV4IDw9IGxlbmd0aCAvIDIgKSB7XG4gICAgICByZXR1cm4gd2luZG93cy5pbnZlcnNld2VsY2goIGxlbmd0aCAvIDIsIGluZGV4ICkgLSAxXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gMSAtIHdpbmRvd3MuaW52ZXJzZXdlbGNoKCBsZW5ndGggLyAyLCBpbmRleCAtIGxlbmd0aCAvIDIgKVxuICAgIH1cbiAgfSxcblxuICBleHBvbmVudGlhbCggbGVuZ3RoLCBpbmRleCwgYWxwaGEgKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KCBpbmRleCAvIGxlbmd0aCwgYWxwaGEgKVxuICB9LFxuXG4gIGxpbmVhciggbGVuZ3RoLCBpbmRleCApIHtcbiAgICByZXR1cm4gaW5kZXggLyBsZW5ndGhcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBnZW4gID0gcmVxdWlyZSgnLi9nZW4uanMnKSxcbiAgICBmbG9vcj0gcmVxdWlyZSgnLi9mbG9vci5qcycpLFxuICAgIHN1YiAgPSByZXF1aXJlKCcuL3N1Yi5qcycpLFxuICAgIG1lbW8gPSByZXF1aXJlKCcuL21lbW8uanMnKVxuXG5sZXQgcHJvdG8gPSB7XG4gIGJhc2VuYW1lOid3cmFwJyxcblxuICBnZW4oKSB7XG4gICAgbGV0IGNvZGUsXG4gICAgICAgIGlucHV0cyA9IGdlbi5nZXRJbnB1dHMoIHRoaXMgKSxcbiAgICAgICAgc2lnbmFsID0gaW5wdXRzWzBdLCBtaW4gPSBpbnB1dHNbMV0sIG1heCA9IGlucHV0c1syXSxcbiAgICAgICAgb3V0LCBkaWZmXG5cbiAgICAvL291dCA9IGAoKCgke2lucHV0c1swXX0gLSAke3RoaXMubWlufSkgJSAke2RpZmZ9ICArICR7ZGlmZn0pICUgJHtkaWZmfSArICR7dGhpcy5taW59KWBcbiAgICAvL2NvbnN0IGxvbmcgbnVtV3JhcHMgPSBsb25nKCh2LWxvKS9yYW5nZSkgLSAodiA8IGxvKTtcbiAgICAvL3JldHVybiB2IC0gcmFuZ2UgKiBkb3VibGUobnVtV3JhcHMpOyAgIFxuICAgIFxuICAgIGlmKCB0aGlzLm1pbiA9PT0gMCApIHtcbiAgICAgIGRpZmYgPSBtYXhcbiAgICB9ZWxzZSBpZiAoIGlzTmFOKCBtYXggKSB8fCBpc05hTiggbWluICkgKSB7XG4gICAgICBkaWZmID0gYCR7bWF4fSAtICR7bWlufWBcbiAgICB9ZWxzZXtcbiAgICAgIGRpZmYgPSBtYXggLSBtaW5cbiAgICB9XG5cbiAgICBvdXQgPVxuYCB2YXIgJHt0aGlzLm5hbWV9ID0gJHtpbnB1dHNbMF19XG4gIGlmKCAke3RoaXMubmFtZX0gPCAke3RoaXMubWlufSApICR7dGhpcy5uYW1lfSArPSAke2RpZmZ9XG4gIGVsc2UgaWYoICR7dGhpcy5uYW1lfSA+ICR7dGhpcy5tYXh9ICkgJHt0aGlzLm5hbWV9IC09ICR7ZGlmZn1cblxuYFxuXG4gICAgcmV0dXJuIFsgdGhpcy5uYW1lLCAnICcgKyBvdXQgXVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICggaW4xLCBtaW49MCwgbWF4PTEgKSA9PiB7XG4gIGxldCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgXG4gICAgbWluLCBcbiAgICBtYXgsXG4gICAgdWlkOiAgICBnZW4uZ2V0VUlEKCksXG4gICAgaW5wdXRzOiBbIGluMSwgbWluLCBtYXggXSxcbiAgfSlcbiAgXG4gIHVnZW4ubmFtZSA9IGAke3VnZW4uYmFzZW5hbWV9JHt1Z2VuLnVpZH1gXG5cbiAgcmV0dXJuIHVnZW5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuXG5jb25zdCBBbmFseXNpcyA9IHtcbiAgY3JlYXRlKCBBdWRpbyApIHtcbiAgICBjb25zdCBhbmFseXNpcyA9IHt9XG5cbiAgICBmb3IoIGxldCBhbmFseXNpc05hbWUgaW4gR2liYmVyaXNoLmFuYWx5c2lzICkge1xuICAgICAgY29uc3QgZ2liYmVyaXNoQ29uc3RydWN0b3IgPSBHaWJiZXJpc2guYW5hbHlzaXNbIGFuYWx5c2lzTmFtZSBdXG5cbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBBbmFseXNpcy5kZXNjcmlwdGlvbnNbIGFuYWx5c2lzTmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogQW5hbHlzaXMuZGVzY3JpcHRpb25zWyBhbmFseXNpc05hbWUgXS5tZXRob2RzXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHsgXG4gICAgICAgIHByb3BlcnRpZXM6IHsgdHlwZTonYW5hbHlzaXMnIH0sXG4gICAgICAgIG5hbWU6YW5hbHlzaXNOYW1lLFxuICAgICAgICBtZXRob2RzLFxuICAgICAgICBjYXRlZ29yeTonYW5hbHlzaXMnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gVWdlbiggZ2liYmVyaXNoQ29uc3RydWN0b3IsIGRlc2NyaXB0aW9uLCBBdWRpbywgZmFsc2UsIHRydWUgKVxuICAgICAgYW5hbHlzaXNbIGFuYWx5c2lzTmFtZSBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICAgIGNvbnN0IHVnZW4gPSBjb25zdHJ1Y3RvciggLi4uYXJncyApXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggdWdlbi5pZCwgdWdlbiApXG4gICAgICAgIHVnZW4ub3V0ID0gdWdlbi5fX3dyYXBwZWRfXy5vdXRcbiAgICAgICAgXG4gICAgICAgIGlmKCBhbmFseXNpc05hbWUgPT09ICdGb2xsb3cnICkge1xuICAgICAgICAgIGxldCBtID0gdWdlbi5fX3dyYXBwZWRfXy5tdWx0aXBsaWVyIHx8IDFcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sICdtdWx0aXBsaWVyJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgICAgICBnZXQoKSB7IHJldHVybiBtIH0sXG4gICAgICAgICAgICBzZXQodikgeyBtID0gdjsgdWdlbi5fX3dyYXBwZWRfXy5tdWx0aXBsaWVyID0gbSB9XG4gICAgICAgICAgfSkgXG4gICAgICAgICAgbGV0IG8gPSB1Z2VuLl9fd3JhcHBlZF9fLm9mZnNldCB8fCAwXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAnb2Zmc2V0Jywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgICAgICBnZXQoKSB7IHJldHVybiBvIH0sXG4gICAgICAgICAgICBzZXQodikgeyBvID0gdjsgdWdlbi5fX3dyYXBwZWRfXy5vZmZzZXQgPSBvIH1cbiAgICAgICAgICB9KSBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWdlblxuICAgICAgfSBcblxuICAgIH1cbiAgICByZXR1cm4gYW5hbHlzaXNcbiAgfSxcblxuICBkZXNjcmlwdGlvbnM6IHtcbiAgICAvL1NTRDogeyBtZXRob2RzOlsgJ2xpc3RlbicgXSB9XG4gICAgLy9DaG9ydXM6eyBtZXRob2RzOltdIH0sXG4gIH0sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuYWx5c2lzIFxuIiwiY29uc3QgR2liYmVyaXNoICAgPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgICAgPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5jb25zdCBJbnN0cnVtZW50cyA9IHJlcXVpcmUoICcuL2luc3RydW1lbnRzLmpzJyApXG5jb25zdCBPc2NpbGxhdG9ycyA9IHJlcXVpcmUoICcuL29zY2lsbGF0b3JzLmpzJyApXG5jb25zdCBFZmZlY3RzICAgICA9IHJlcXVpcmUoICcuL2VmZmVjdHMuanMnIClcbmNvbnN0IEZpbHRlcnMgICAgID0gcmVxdWlyZSggJy4vZmlsdGVycy5qcycgKVxuY29uc3QgQmlub3BzICAgICAgPSByZXF1aXJlKCAnLi9iaW5vcHMuanMnIClcbmNvbnN0IEFuYWx5c2lzICAgID0gcmVxdWlyZSggJy4vYW5hbHlzaXMuanMnIClcbmNvbnN0IEVudmVsb3BlcyAgID0gcmVxdWlyZSggJy4vZW52ZWxvcGVzLmpzJyApXG5jb25zdCBCdXNzZXMgICAgICA9IHJlcXVpcmUoICcuL2J1c3Nlcy5qcycgKVxuY29uc3QgRW5zZW1ibGUgICAgPSByZXF1aXJlKCAnLi9lbnNlbWJsZS5qcycgKVxuY29uc3QgVXRpbGl0eSAgICAgPSByZXF1aXJlKCAnLi91dGlsaXR5LmpzJyApXG5jb25zdCBGcmVlc291bmQgICA9IHJlcXVpcmUoICcuL2ZyZWVzb3VuZC5qcycgKVxuY29uc3QgR2VuICAgICAgICAgPSByZXF1aXJlKCAnLi9nZW4uanMnIClcbmNvbnN0IFdhdmVQYXR0ZXJuID0gcmVxdWlyZSggJy4vd2F2ZVBhdHRlcm4uanMnIClcbmNvbnN0IFdhdmVPYmplY3RzID0gcmVxdWlyZSggJy4vd2F2ZU9iamVjdHMuanMnIClcbi8vY29uc3QgQ29yZSAgICAgICAgPSByZXF1aXJlKCAnZ2liYmVyLmNvcmUubGliJyApXG5jb25zdCBBV1BGICAgICAgICA9IHJlcXVpcmUoICcuL2V4dGVybmFsL2F1ZGlvd29ya2xldC1wb2x5ZmlsbC5qcycgKVxuLy9jb25zdCBBcnAgICAgICAgICA9IHJlcXVpcmUoICcuL2FycC5qcycgKVxuXG5jb25zdCBBdWRpbyA9IHtcbiAgQ2xvY2s6IHJlcXVpcmUoICcuL2Nsb2NrLmpzJyApLFxuICBUaGVvcnk6IHJlcXVpcmUoICcuL3RoZW9yeS5qcycgKSxcbiAgUHJlc2V0czogcmVxdWlyZSggJy4vcHJlc2V0cy5qcycgKSxcbiAgX19NYWtlOiByZXF1aXJlKCAnLi9tYWtlLmpzJyApLFxuICBpbml0aWFsaXplZDpmYWxzZSxcbiAgYXV0b0Nvbm5lY3Q6dHJ1ZSxcbiAgc2hvdWxkRGVsYXk6ZmFsc2UsXG4gIGluc3RydW1lbnRzOnt9LFxuICBvc2NpbGxhdG9yczp7fSxcbiAgZWZmZWN0czp7fSxcbiAgZXhwb3J0VGFyZ2V0Om51bGwsXG5cbiAgZXhwb3J0KCBvYmogKSB7XG4gICAgaWYoIEF1ZGlvLmluaXRpYWxpemVkICl7IFxuICAgICAgT2JqZWN0LmFzc2lnbiggXG4gICAgICAgIG9iaiwgXG4gICAgICAgIHRoaXMuaW5zdHJ1bWVudHMsIFxuICAgICAgICB0aGlzLm9zY2lsbGF0b3JzLFxuICAgICAgICB0aGlzLmVmZmVjdHMsXG4gICAgICAgIHRoaXMuZmlsdGVycyxcbiAgICAgICAgdGhpcy5idXNzZXMsIFxuICAgICAgICB0aGlzLmVudmVsb3BlcywgXG4gICAgICAgIHRoaXMud2F2ZU9iamVjdHMsIFxuICAgICAgICB0aGlzLmJpbm9wcywgXG4gICAgICAgIHRoaXMuYW5hbHlzaXMgXG4gICAgICApXG4gICAgICBcbiAgICAgIFV0aWxpdHkuZXhwb3J0KCBvYmogKVxuICAgICAgdGhpcy5HZW4uZXhwb3J0KCBvYmogKVxuXG4gICAgICBvYmouR2liYmVyaXNoID0gdGhpcy5HaWJiZXJpc2hcblxuICAgICAgb2JqLmdlbiA9IHRoaXMuR2VuLm1ha2VcbiAgICAgIG9iai5sZm8gPSB0aGlzLkdlbi5jb21wb3NpdGVzLmxmb1xuICAgICAgb2JqLkVuc2VtYmxlID0gdGhpcy5FbnNlbWJsZVxuICAgICAgb2JqLkRydW1zID0gdGhpcy5EcnVtc1xuICAgICAgb2JqLkVEcnVtcyA9IHRoaXMuRURydW1zXG4gICAgICBvYmouVGhlb3J5ID0gdGhpcy5UaGVvcnlcbiAgICAgIG9iai5GcmVlc291bmQgPSB0aGlzLkZyZWVzb3VuZFxuICAgICAgb2JqLkNsb2NrID0gdGhpcy5DbG9ja1xuICAgICAgb2JqLkNsb2NrLmV4cG9ydCggb2JqIClcbiAgICAgIG9iai5XYXZlUGF0dGVybiA9IHRoaXMuV2F2ZVBhdHRlcm5cbiAgICAgIG9iai5HZW4gPSB0aGlzLkdlblxuICAgICAgb2JqLnN0b3AgPSB0aGlzLnN0b3BcblxuICAgICAgb2JqLk91dCA9IHRoaXMuT3V0XG4gICAgICBvYmouTWFrZSA9IHRoaXMuTWFrZVxuICAgICAgb2JqLmZ1dHVyZSA9IHRoaXMuR2liYmVyaXNoLnV0aWxpdGllcy5mdXR1cmVcbiAgICB9ZWxzZXtcbiAgICAgIEF1ZGlvLmV4cG9ydFRhcmdldCA9IG9ialxuICAgIH0gXG4gIH0sXG5cbiAgX19kZWZhdWx0cyA6IHtcbiAgICB3b3JrbGV0UGF0aDogJy4uL2Rpc3QvZ2liYmVyaXNoX3dvcmtsZXQuanMnLFxuICAgIGN0eDogICAgICAgICBudWxsLFxuICAgIGJ1ZmZlclNpemU6ICAyMDQ4LFxuICAgIGxhdGVuY3lIaW50OiAuMDVcbiAgfSxcblxuICBpbml0KCBvcHRpb25zLCBHaWJiZXIgICkge1xuICAgIGxldCB7IHdvcmtsZXRQYXRoLCBjdHgsIGJ1ZmZlclNpemUsIGxhdGVuY3lIaW50IH0gPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy5fX2RlZmF1bHRzLCBvcHRpb25zICkgXG4gICAgdGhpcy5HaWJiZXIgPSBHaWJiZXJcbiAgICB0aGlzLkNvcmUgPSBHaWJiZXJcblxuICAgIC8vIFhYWCBzaG91bGQgcHJvYmFibHkganVzdCBjYWxsIEF1ZGlvLkNvcmUuY3JlYXRlUHJvcGVydHkgdG8gYXZvaWQgY29uZnVzaW9uLi4uXG4gICAgdGhpcy5jcmVhdGVQcm9wZXJ0eSA9IEdpYmJlci5jcmVhdGVQcm9wZXJ0eVxuXG4gICAgR2liYmVyLkF1ZGlvID0gdGhpc1xuICAgIHRoaXMuR2liYmVyaXNoID0gR2liYmVyaXNoXG5cbiAgICBHaWJiZXJpc2gud29ya2xldFBhdGggPSB3b3JrbGV0UGF0aCBcblxuICAgIHRoaXMuY3JlYXRlUHViU3ViKClcblxuICAgIGNvbnN0IEFDID0gdHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB3ZWJraXRBdWRpb0NvbnRleHQgOiBBdWRpb0NvbnRleHRcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gQUNcbiAgICBBV1BGKCB3aW5kb3csIGJ1ZmZlclNpemUgKSBcblxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYoIGN0eCA9PT0gbnVsbCApIHtcbiAgICAgICAgY3R4ID0gbmV3IEFDKHsgbGF0ZW5jeUhpbnQgfSlcbiAgICAgICAgLy9jdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgIH1cblxuICAgICAgR2liYmVyaXNoLmluaXQoIDQ0MTAwKjYwKjIwLCBjdHggKS50aGVuKCBwcm9jZXNzb3JOb2RlID0+IHtcbiAgICAgICAgLy8gWFhYIHJlbW92ZSBvbmNlIGdpYmJlci5jb3JlLmxpYiBoYXMgYmVlbiBwcm9wZXJseSBpbnRlZ3JhdGVkIFxuICAgICAgICBBdWRpby5Db3JlLkF1ZGlvID0gQXVkaW8uQ29yZS5hdWRpbyA9IEF1ZGlvXG5cbiAgICAgICAgQXVkaW8uR2liYmVyaXNoID0gR2liYmVyaXNoXG5cbiAgICAgICAgQXVkaW8uaW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICAgIEF1ZGlvLm5vZGUgPSBwcm9jZXNzb3JOb2RlXG4gICAgICAgIEF1ZGlvLlVnZW4gPSBVZ2VuXG4gICAgICAgIEF1ZGlvLk1ha2UgPSBBdWRpby5fX01ha2UoIEF1ZGlvIClcbiAgICAgICAgQXVkaW8uR2VuID0gR2VuKCBBdWRpbyApXG4gICAgICAgIEF1ZGlvLkdlbi5pbml0KClcbiAgICAgICAgQXVkaW8uR2VuLmV4cG9ydCggQXVkaW8uR2VuLnVnZW5zIClcbiAgICAgICAgQXVkaW8uVGhlb3J5LmluaXQoIHdpbmRvdy5HaWJiZXIgKVxuICAgICAgICBBdWRpby5VdGlsaXRpZXMgPSBVdGlsaXR5XG4gICAgICAgIEF1ZGlvLldhdmVQYXR0ZXJuID0gV2F2ZVBhdHRlcm4oIEF1ZGlvIClcbiAgICAgICAgQXVkaW8uY3R4ID0gY3R4XG4gICAgICAgIEF1ZGlvLk91dCA9IEdpYmJlcmlzaC5vdXRwdXRcbiAgICAgICAgXG4gICAgICAgIC8vIG11c3Qgd2FpdCBmb3IgR2VuIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICAgIEF1ZGlvLkNsb2NrLmluaXQoIEF1ZGlvLkdlbiwgQXVkaW8gKVxuXG4gICAgICAgIEF1ZGlvLmNyZWF0ZVVnZW5zKClcbiAgICAgICAgXG4gICAgICAgIGlmKCBBdWRpby5leHBvcnRUYXJnZXQgIT09IG51bGwgKSBBdWRpby5leHBvcnQoIEF1ZGlvLmV4cG9ydFRhcmdldCApXG5cbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5fX3Bvc3RNZXNzYWdlID0gR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZVxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiggZGljdCApIHtcbiAgICAgICAgICBpZiggQXVkaW8uc2hvdWxkRGVsYXkgPT09IHRydWUgKSBkaWN0LmRlbGF5ID0gdHJ1ZVxuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5fX3Bvc3RNZXNzYWdlKCBkaWN0IClcbiAgICAgICAgfVxuXG4gICAgICAgIEF1ZGlvLmV4cG9ydCggd2luZG93IClcblxuICAgICAgICAvL2NvbnN0IGRydW1zID0gQXVkaW8uRHJ1bXMoJ3gqby0nKVxuICAgICAgICAvL2RydW1zLmRpc2Nvbm5lY3QoKVxuICAgICAgICAvL2RydW1zLnN0b3AoKVxuXG4gICAgICAgIC8vIHN0b3JlIGxhc3QgbG9jYXRpb24gaW4gbWVtb3J5Li4uIHdlIGNhbiBjbGVhciBldmVyeXRoaW5nIGVsc2UgaW4gR2liYmVyLmNsZWFyOSlcbiAgICAgICAgY29uc3QgbWVtSWR4ID0gT2JqZWN0LmtleXMoIEdpYmJlcmlzaC5tZW1vcnkubGlzdCApLnJldmVyc2UoKVswXVxuICAgICAgICB0aGlzLl9fbWVtb3J5RW5kID0gcGFyc2VJbnQoIG1lbUlkeCApICsgR2liYmVyaXNoLm1lbW9yeS5saXN0WyBtZW1JZHggXVxuXG4gICAgICAgIC8vIFhYWCB0aGlzIGZvcmNlcyB0aGUgZ2liYmVyaXNoIHNjaGVkdWxlciB0byBzdGFydFxuICAgICAgICAvLyBydW5uaW5nLCBidXQgaXQncyBhYm91dCBhcyBoYWNreSBhcyBpdCBjYW4gZ2V0Li4uXG4gICAgICAgIC8vY29uc3QgX19zdGFydCA9IEF1ZGlvLmluc3RydW1lbnRzLlN5bnRoKCkuY29ubmVjdCgpXG4gICAgICAgIC8vX19zdGFydC5kaXNjb25uZWN0KClcblxuICAgICAgICAvL0F1ZGlvLkdpYmJlcmlzaC5nZW5pc2hpLmdlbi5oaXN0b3JpZXMuY2xlYXIoKVxuICAgICAgICBBdWRpby5jbGVhcigpXG5cbiAgICAgICAgcmVzb2x2ZSggW0F1ZGlvLCdBdWRpbyddIClcbiAgICAgIH0pXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gcFxuICB9LFxuXG4gIHJlc3RhcnQoKSB7XG4gICAgR2liYmVyLmNsZWFyKClcbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LmNsb3NlKClcbiAgICB3aW5kb3cudyA9IEdpYmJlcmlzaC53b3JrbGV0XG4gICAgR2liYmVyaXNoLndvcmtsZXQuZGlzY29ubmVjdCgpXG5cbiAgICBHaWJiZXJpc2guaW5pdCggNDQxMDAqNjAqMjAsIHVuZGVmaW5lZCwgJ3dvcmtsZXQnLCB0cnVlICkudGhlbiggcHJvY2Vzc29yTm9kZSA9PiB7XG4gICAgICBBdWRpby5vdXQgPSBHaWJiZXJpc2gub3V0cHV0XG4gICAgICBBdWRpby5ub2RlID0gcHJvY2Vzc29yTm9kZVxuXG4gICAgICBBdWRpby5UaGVvcnkuZGVsZXRlUHJvcGVydGllcygpXG4gICAgICBBdWRpby5UaGVvcnkuaW5pdCggd2luZG93LkdpYmJlciApXG5cbiAgICAgIEF1ZGlvLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgQXVkaW8ubm9kZSA9IHByb2Nlc3Nvck5vZGVcbiAgICAgIEF1ZGlvLk91dCA9IEdpYmJlcmlzaC5vdXRwdXRcblxuICAgICAgQXVkaW8uTWFrZSA9IEF1ZGlvLl9fTWFrZSggQXVkaW8gKVxuICAgICAgQXVkaW8uR2VuID0gR2VuKCBBdWRpbyApXG4gICAgICBBdWRpby5HZW4uaW5pdCgpXG4gICAgICBBdWRpby5HZW4uZXhwb3J0KCBBdWRpby5HZW4udWdlbnMgKVxuXG4gICAgICBBdWRpby5XYXZlUGF0dGVybiA9IFdhdmVQYXR0ZXJuKCBBdWRpbyApXG4gICAgICBBdWRpby5jcmVhdGVVZ2VucygpXG4gICAgICAgIFxuICAgICAgQXVkaW8uQ2xvY2suaW5pdCggQXVkaW8uR2VuLCBBdWRpbyApXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQuX19wb3N0TWVzc2FnZSA9IEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2VcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiggZGljdCApIHtcbiAgICAgICAgaWYoIEF1ZGlvLnNob3VsZERlbGF5ID09PSB0cnVlICkgZGljdC5kZWxheSA9IHRydWVcblxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0Ll9fcG9zdE1lc3NhZ2UoIGRpY3QgKVxuICAgICAgfVxuXG4gICAgICBBdWRpby5leHBvcnQoIHdpbmRvdyApXG4gICAgICBHaWJiZXIuZXhwb3J0KCB3aW5kb3cgKVxuXG4gICAgICBjb25zdCBtZW1JZHggPSBPYmplY3Qua2V5cyggR2liYmVyaXNoLm1lbW9yeS5saXN0ICkucmV2ZXJzZSgpWzBdXG4gICAgICB0aGlzLl9fbWVtb3J5RW5kID0gcGFyc2VJbnQoIG1lbUlkeCApICsgR2liYmVyaXNoLm1lbW9yeS5saXN0WyBtZW1JZHggXVxuXG4gICAgICAvLyBYWFggdGhpcyBmb3JjZXMgdGhlIGdpYmJlcmlzaCBzY2hlZHVsZXIgdG8gc3RhcnRcbiAgICAgIC8vIHJ1bm5pbmcsIGJ1dCBpdCdzIGFib3V0IGFzIGhhY2t5IGFzIGl0IGNhbiBnZXQuLi5cbiAgICAgIGNvbnN0IF9fc3RhcnQgPSBBdWRpby5pbnN0cnVtZW50cy5TeW50aCgpLmNvbm5lY3QoKVxuICAgICAgX19zdGFydC5kaXNjb25uZWN0KClcblxuICAgICAgLy9BdWRpby5HaWJiZXJpc2guZ2VuaXNoaS5nZW4uaGlzdG9yaWVzLmNsZWFyKClcblxuICAgICAgLy9BdWRpby5jbGVhcigpXG4gICAgICBjb25zb2xlLmxvZyggJ2F1ZGlvIGVuZ2luZSBzdWNjZXNzZnVsbHkgcmVzdGFydGVkLicgKVxuICAgICAgQXVkaW8ucHVibGlzaCggJ3Jlc3RhcnQnIClcbiAgICB9KVxuICB9LFxuXG4gIC8vIFhYWCBzdG9wIGNsb2NrIGZyb20gYmVpbmcgY2xlYXJlZC5cbiAgY2xlYXIoKSB7IFxuICAgIEdpYmJlcmlzaC5jbGVhcigpIFxuICAgIEF1ZGlvLkNsb2NrLmluaXQoIEF1ZGlvLkdlbiwgQXVkaW8gKVxuXG4gICAgLy8gdGhlIGlkZWEgaXMgdGhhdCB3ZSBvbmx5IGNsZWFyIG1lbW9yeSB0aGF0IHdhcyBmaWxsZWQgYWZ0ZXJcbiAgICAvLyB0aGUgaW5pdGlhbCBHaWJiZXIgaW5pdGlhbGl6YXRpb24uLi4gdGhpcyBzdG9wcyBvYmplY3RzXG4gICAgLy8gbGlrZSBDbG9jayBhbmQgVGhlb3J5IGZyb20gaGF2aW5nIHRoZWlyIG1lbW9yeSBjbGVhcmVkIGFuZFxuICAgIC8vIGZyb20gaGF2aW5nIHRvIHJlLWluaXRpYWxpemUgdGhlbS5cblxuICAgIC8vIGZpbGwgbWVtb3J5IHdpdGggemVyb3MgZnJvbSB0aGUgZW5kIGluaXRpYWxpemF0aW9uIGJsb2NrIG9ud2FyZHNcbiAgICBHaWJiZXJpc2gubWVtb3J5LmhlYXAuZmlsbCggMCwgdGhpcy5fX21lbW9yeUVuZCApXG5cbiAgICAvLyBnZXQgbG9jYXRpb25zIG9mIGFsbCBtZW1vcnkgYmxvY2tzXG4gICAgY29uc3QgbWVtS2V5cyA9IE9iamVjdC5rZXlzKCBHaWJiZXJpc2gubWVtb3J5Lmxpc3QgKVxuXG4gICAgLy8gZ2V0IGlkeCBvZiBmaW5hbCBpbml0aWFsaXphdGlvbiBibG9ja1xuICAgIGNvbnN0IGVuZElkeCA9ICBtZW1LZXlzLmluZGV4T2YoICcnK3RoaXMuX19tZW1vcnlFbmQgKVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBibG9ja3MgYWZ0ZXIgZmluYWwgaW5pdGlhbHphdGlvbiBibG9ja1xuICAgIC8vIGFuZCBkZWxldGUgdGhlbSBpbiB0aGUgbWVtb3J5IGxpc3QuLi4gdGhleSd2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiB6ZXJvZWQgb3V0LlxuICAgIGZvciggbGV0IGkgPSBlbmRJZHg7IGkgPCBtZW1LZXlzLmxlbmd0aDsgaSsrICkge1xuICAgICAgZGVsZXRlIEdpYmJlcmlzaC5tZW1vcnkubGlzdFsgbWVtS2V5c1sgaSBdIF1cbiAgICB9XG4gICAgXG4gICAgQXVkaW8ucHVibGlzaCgnY2xlYXInKVxuICB9LFxuXG4gIHN0b3AoKSB7XG4gICAgR2liYmVyLlNlcS5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdG9wKCkgKVxuICB9LFxuXG4gIHN0YXJ0KCkge1xuICAgIEdpYmJlci5TZXEuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RhcnQoKSApXG4gIH0sXG4gIG9ubG9hZCgpIHt9LFxuXG4gIGNyZWF0ZVVnZW5zKCkge1xuICAgIC8vQ29yZS5leHBvcnQoIHRoaXMsIHRoaXMgKVxuXG4gICAgdGhpcy5GcmVlc291bmQgPSBGcmVlc291bmQoIHRoaXMgKVxuICAgIHRoaXMuYmlub3BzID0gQmlub3BzLmNyZWF0ZSggdGhpcyApXG4gICAgdGhpcy5hbmFseXNpcyA9IEFuYWx5c2lzLmNyZWF0ZSggdGhpcyApXG4gICAgdGhpcy5vc2NpbGxhdG9ycyA9IE9zY2lsbGF0b3JzLmNyZWF0ZSggdGhpcyApXG4gICAgdGhpcy5pbnN0cnVtZW50cyA9IEluc3RydW1lbnRzLmNyZWF0ZSggdGhpcyApIFxuICAgIHRoaXMuZW52ZWxvcGVzICAgPSBFbnZlbG9wZXMuY3JlYXRlKCB0aGlzIClcbiAgICB0aGlzLmZpbHRlcnMgICAgID0gRmlsdGVycy5jcmVhdGUoIHRoaXMgKVxuICAgIHRoaXMuZWZmZWN0cyA9IEVmZmVjdHMuY3JlYXRlKCB0aGlzIClcbiAgICB0aGlzLmJ1c3NlcyA9IEJ1c3Nlcy5jcmVhdGUoIHRoaXMgKVxuICAgIHRoaXMuRW5zZW1ibGUgPSBFbnNlbWJsZSggdGhpcyApXG4gICAgdGhpcy53YXZlT2JqZWN0cyA9IFdhdmVPYmplY3RzKCB0aGlzIClcblxuICAgIGNvbnN0IFBhdHRlcm4gPSB0aGlzLkNvcmUuX19QYXR0ZXJuXG4gICAgUGF0dGVybi50cmFuc2ZlciggdGhpcywgUGF0dGVybi50b1N0cmluZygpIClcblxuICAgIFxuICAgIGNvbnN0IGRydW1zID0gcmVxdWlyZSggJy4vZHJ1bXMuanMnICkoIHRoaXMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMsIGRydW1zIClcbiAgfSxcblxuICBwcmludGNiKCkgeyBcbiAgICBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IGFkZHJlc3M6J2NhbGxiYWNrJyB9KSBcbiAgfSxcbiAgcHJpbnRvYmooIG9iaiApIHtcbiAgICBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IGFkZHJlc3M6J3ByaW50Jywgb2JqZWN0Om9iai5pZCB9KSBcbiAgfSxcbiAgc2VuZCggbXNnICl7XG4gICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoIG1zZyApXG4gIH0sXG5cbiAgY3JlYXRlUHViU3ViKCkge1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucHViZXZlbnRzID0ge31cbiAgICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uKCBrZXksIGZjbiApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGV2ZW50c1sga2V5IF0gPSBbXVxuICAgICAgfVxuICAgICAgZXZlbnRzWyBrZXkgXS5wdXNoKCBmY24gKVxuICAgIH1cblxuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigga2V5LCBmY24gKSB7XG4gICAgICBpZiggdHlwZW9mIGV2ZW50c1sga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBjb25zdCBhcnIgPSBldmVudHNbIGtleSBdXG5cbiAgICAgICAgYXJyLnNwbGljZSggYXJyLmluZGV4T2YoIGZjbiApLCAxIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnB1Ymxpc2ggPSBmdW5jdGlvbigga2V5LCBkYXRhICkge1xuICAgICAgaWYoIHR5cGVvZiBldmVudHNbIGtleSBdICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgY29uc3QgYXJyID0gZXZlbnRzWyBrZXkgXVxuXG4gICAgICAgIGFyci5mb3JFYWNoKCB2ID0+IHYoIGRhdGEgKSApXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZU1hcHBpbmcoIGZyb20sIHRvLCBuYW1lLCB3cmFwcGVkVG8gKSB7XG4gICAgaWYoIGZyb20uX191c2VNYXBwaW5nID09PSBmYWxzZSApIHtcbiAgICAgIHRvWyBuYW1lIF0udmFsdWUgPSBmcm9tXG4gICAgfWVsc2UgaWYoIGZyb20udHlwZSA9PT0gJ2F1ZGlvJyApIHtcbiAgICAgIGNvbnN0IGYgPSB0b1sgJ19fJyArIG5hbWUgXS5mb2xsb3cgPSBGb2xsb3coeyBpbnB1dDogZnJvbSB9KVxuXG4gICAgICBsZXQgbSA9IGYubXVsdGlwbGllclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0b1sgbmFtZSBdLCAnbXVsdGlwbGllcicsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gbSB9LFxuICAgICAgICBzZXQodikgeyBtID0gdjsgZi5tdWx0aXBsaWVyID0gbSB9XG4gICAgICB9KVxuXG4gICAgICBsZXQgbyA9IGYub2Zmc2V0XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRvWyBuYW1lIF0sICdvZmZzZXQnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIG8gfSxcbiAgICAgICAgc2V0KHYpIHsgbyA9IHY7IGYub2Zmc2V0ID0gbyB9XG4gICAgICB9KVxuXG4gICAgICB3cmFwcGVkVG9bIG5hbWUgXSA9IGZcbiAgICAgIC8vdG9bICdfXycrbmFtZV0udmFsdWUgPSBmXG5cbiAgICB9ZWxzZSBpZiggZnJvbS50eXBlID09PSAnZ2VuJyApIHtcbiAgICAgIC8vIGdlbiBvYmplY3RzIGNhbiBiZSByZWZlcnJlZCB0byB3aXRob3V0IHRoZSBncmFwaGljcy9hdWRpbyBhYnN0cmFjdGlvbixcbiAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIGhhdmUgbm8gLnJlbmRlcigpIGZ1bmN0aW9uLCBhbmQgZG9uJ3QgbmVlZCB0byBiZSByZW5kZXJlZFxuICAgICAgY29uc3QgZ2VuID0gZnJvbS5yZW5kZXIgIT09IHVuZGVmaW5lZCA/IGZyb20ucmVuZGVyKCkgOiBmcm9tXG5cbiAgICAgIHdyYXBwZWRUb1sgbmFtZSBdID0gZ2VuXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUdldHRlciggb2JqLCBuYW1lICkgeyByZXR1cm4gKCkgPT4gb2JqWyAnX18nICsgbmFtZSBdIH0sXG5cbiAgY3JlYXRlU2V0dGVyKCBvYmosIG5hbWUsIHBvc3QsIHRyYW5zZm9ybT1udWxsLCBpc1BvbHk9ZmFsc2UgKSB7XG4gICAgaWYoIHR5cGVvZiBvYmouX193cmFwcGVkX18gPT09ICdvYmplY3QnICkge1xuICAgICAgbGV0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBvYmouX193cmFwcGVkX18sIG5hbWUgKVxuXG4gICAgICBpZiggZGVzYyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iai5fX3dyYXBwZWRfXywgbmFtZSwgIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgb2JqWyAnX18nK25hbWUgXS52YWx1ZSA9IHZcbiAgICAgICAgICAgIGlmKCBkZXNjLnNldCApIHtcbiAgICAgICAgICAgICAgZGVzYy5zZXQoIHYgKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIG9iai5fX3dyYXBwZWRfXy52YWx1ZSA9IHZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNldHRlciA9IHYgPT4ge1xuICAgICAgbGV0IHZhbHVlLCBzaG91bGRTZW5kID0gdHJ1ZVxuXG5cbiAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHYgPT09IG51bGwgKSB7XG4gICAgICAgIHZhbHVlID0gdHJhbnNmb3JtICE9PSBudWxsID8gdHJhbnNmb3JtKCB2ICkgOiB2XG5cbiAgICAgICAgaWYoIGlzUG9seSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICBjb25zdCBfX3dyYXBwZWRPYmplY3QgPSBvYmouX193cmFwcGVkX19cbiAgICAgICAgICBjb25zdCB2b2ljZSA9IF9fd3JhcHBlZE9iamVjdC52b2ljZXNbIF9fd3JhcHBlZE9iamVjdC52b2ljZUNvdW50ICUgX193cmFwcGVkT2JqZWN0LnZvaWNlcy5sZW5ndGggXVxuICAgICAgICAgIHZvaWNlWyBuYW1lIF0gPSB2YWx1ZVxuXG4gICAgICAgICAgc2hvdWxkU2VuZCA9IGZhbHNlXG5cbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J3Byb3BlcnR5JyxcbiAgICAgICAgICAgIG9iamVjdDp2b2ljZS5pZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pIFxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG9ialsgJ19fJytuYW1lXS52YWx1ZSA9IHZcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmIHYudHlwZSA9PT0gJ2dlbicgKSB7XG4gICAgICAgIC8vIGdlbiBvYmplY3RzIGNhbiBiZSByZWZlcnJlZCB0byB3aXRob3V0IHRoZSBncmFwaGljcy9hdWRpbyBhYnN0cmFjdGlvbixcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB0aGV5IHdpbGwgaGF2ZSBubyAucmVuZGVyKCkgZnVuY3Rpb24sIGFuZCBkb24ndCBuZWVkIHRvIGJlIHJlbmRlcmVkXG5cbiAgICAgICAgdiA9IHRyYW5zZm9ybSAhPT0gbnVsbCA/IHRyYW5zZm9ybSggdiApIDogdiAgICAgICBcbiAgICAgICAgY29uc3QgZ2VuID0gdi5yZW5kZXIgIT09IHVuZGVmaW5lZCA/IHYucmVuZGVyKCkgOiB2IFxuXG4gICAgICAgIG9ialsnX18nKyBuYW1lIF0udmFsdWUgPSBnZW4gXG4gICAgICAgIHZhbHVlID0geyBpZDogZ2VuLmlkIH1cbiAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7IC8vJiYgdHlwZW9mIHYgIT09IG51bGwgKSB7XG4gICAgICAgIC8vaWYoIG9iai5fX3VzZU1hcHBpbmcgPT09IGZhbHNlIHx8IG5hbWUgPT09ICdpbnB1dCcgKSB7XG4gICAgICAgIC8vICBvYmpbICdfXycrbmFtZV0udmFsdWUgPSB2XG4gICAgICAgIC8vICB2YWx1ZSA9IHYgIT09IG51bGwgPyB7IGlkOnYuaWQgfSA6IHZcbiAgICAgICAgLy99ZWxzZXtcbiAgICAgICAgLy8gIC8vQXVkaW8uY3JlYXRlTWFwcGluZyggdiwgb2JqLCBuYW1lLCBvYmouX193cmFwcGVkX18gKVxuICAgICAgICAvLyAgY29uc3QgZiA9IG9ialsgJ19fJyArIG5hbWUgXS5mb2xsb3cgPSBGb2xsb3coeyBpbnB1dDogdiB9KVxuXG4gICAgICAgIC8vICBsZXQgbSA9IGYubXVsdGlwbGllclxuICAgICAgICAvLyAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmpbIG5hbWUgXSwgJ211bHRpcGxpZXInLCB7XG4gICAgICAgIC8vICAgIGdldCgpIHsgcmV0dXJuIG0gfSxcbiAgICAgICAgLy8gICAgc2V0KHYpIHsgbSA9IHY7IGYubXVsdGlwbGllciA9IG0gfVxuICAgICAgICAvLyAgfSlcblxuICAgICAgICAvLyAgbGV0IG8gPSBmLm9mZnNldFxuICAgICAgICAvLyAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmpbIG5hbWUgXSwgJ29mZnNldCcsIHtcbiAgICAgICAgLy8gICAgZ2V0KCkgeyByZXR1cm4gbyB9LFxuICAgICAgICAvLyAgICBzZXQodikgeyBvID0gdjsgZi5vZmZzZXQgPSBvIH1cbiAgICAgICAgLy8gIH0pXG5cbiAgICAgICAgICAvL3dyYXBwZWRUb1sgbmFtZSBdID0gZlxuICAgICAgICAgIC8vb2JqWyAnX18nK25hbWUgXS52YWx1ZSA9IGYuX193cmFwcGVkX19cbiAgICAgICAgICAvL3ZhbHVlID0geyBpZDpmLmlkIH1cbiAgICAgICAgICBvYmpbICdfXycrbmFtZSBdLnZhbHVlID0gdi5fX3dyYXBwZWRfX1xuICAgICAgICAgIHZhbHVlID0geyBpZDp2LmlkIH1cbiAgICAgICAgLy99XG4gICAgICAgICAgICAgICAvL1xuICAgICAgICAvL29ialsgJ19fJytuYW1lXS52YWx1ZSA9IHZcbiAgICAgICAgLy92YWx1ZSA9IHYgIT09IG51bGwgPyB7IGlkOnYuaWQgfSA6IHZcbiAgICAgIH1cblxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgJiYgc2hvdWxkU2VuZCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWRkcmVzczoncHJvcGVydHknLFxuICAgICAgICAgIG9iamVjdDpvYmouaWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KSBcbiAgICAgIH1cbiAgICAgIGlmKCBwb3N0ICE9PSBudWxsICkge1xuICAgICAgICBwb3N0LmNhbGwoIG9iaiApXG4gICAgICB9ICAgICBcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkgQXVkaW8ucHVibGlzaCggYHByb3BlcnR5LnNldDoke29iai5pZH1gLCBvYmosIHYgKVxuICAgIH1cblxuICAgIHJldHVybiBzZXR0ZXJcbiAgfSxcblxuICBjcmVhdGVGYWRlKCBmcm9tPW51bGwsIHRvPW51bGwsIHRpbWU9MSwgb2JqLCBuYW1lLCBkZWxheT0wICkge1xuICAgIGlmKCBmcm9tID09PSBudWxsICkgZnJvbSA9IG9ialsgbmFtZSBdLnZhbHVlXG4gICAgaWYoIHRvID09PSBudWxsICkgdG8gPSBvYmpbIG5hbWUgXS52YWx1ZVxuXG4gICAgdGltZSA9IEF1ZGlvLkNsb2NrLnRpbWUoIHRpbWUgKVxuXG4gICAgLy8gWFhYIG9ubHkgY292ZXJzIGNvbmRpdGlvbiB3aGVyZSByYW1wcyBmcm9tIGZhZGVzIGFyZSBhc3NpZ25lZC4uLlxuICAgIC8vIGRvZXMgdGhpcyBuZWVkIHRvIGJlIG1vcmUgZ2VuZXJpYz9cbiAgICBpZiggaXNOYU4oIGZyb20gKSAmJiBmcm9tLl9fd3JhcHBlZF9fLnVnZW5OYW1lLmluZGV4T2YoJ3JhbXAnKSA+IC0xICkge1xuICAgICAgZnJvbSA9IGZyb20udG8udmFsdWVcbiAgICB9XG4gICAgaWYoIGlzTmFOKCB0byApICYmIHRvLl9fd3JhcHBlZF9fLnVnZW5OYW1lLmluZGV4T2YoJ3JhbXAnKSA+IC0xICkge1xuICAgICAgdG8gPSB0by50by52YWx1ZVxuICAgIH1cblxuICAgIGxldCByYW1wID0gQXVkaW8uZW52ZWxvcGVzLlJhbXAoeyBmcm9tLCB0bywgbGVuZ3RoOnRpbWUsIHNob3VsZExvb3A6ZmFsc2UgfSlcbiAgICAvLyB0aGlzIGlzIGEga2V5IHRvIG5vdCB1c2UgYW4gZW52ZWxvcGUgZm9sbG93ZXIgZm9yIG1hcHBpbmdcbiAgICByYW1wLl9fdXNlTWFwcGluZyA9IGZhbHNlXG5cbiAgICBpZiggZGVsYXkgPT09IDAgKSB7XG4gICAgICBvYmpbIG5hbWUgXSA9IHJhbXBcbiAgICB9IGVsc2Uge1xuICAgICAgZnV0dXJlKCAob2JqLG5hbWUscmFtcCkgPT4geyBcbiAgICAgICAgb2JqWyBuYW1lIF0gPSByYW1wIFxuICAgICAgfSwgZGVsYXksIHsgb2JqLCBuYW1lLCByYW1wOnJhbXAuX193cmFwcGVkX18gfSApXG4gICAgfVxuXG4gICAgaWYoIHJhbXAuX193cmFwcGVkX18gPT09IHVuZGVmaW5lZCApIHJhbXAuX193cmFwcGVkX18gPSB7fVxuICAgIHJhbXAuX193cmFwcGVkX18udmFsdWVzID0gW11cblxuICAgIHJhbXAuX193cmFwcGVkX18ub3V0cHV0ID0gdiA9PiB7XG4gICAgICBpZiggcmFtcC5fX3dyYXBwZWRfXyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICByYW1wLl9fd3JhcHBlZF9fLnZhbHVlcy51bnNoaWZ0KCB2IClcbiAgICAgICAgd2hpbGUoIHJhbXAuX193cmFwcGVkX18udmFsdWVzLmxlbmd0aCA+IDYwICkgcmFtcC5fX3dyYXBwZWRfXy52YWx1ZXMucG9wKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYW1wLl9fd3JhcHBlZF9fLmZpbmFsaXplID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSByYW1wLl9fd3JhcHBlZF9fXG5cbiAgICAgIC8vIFhYWCBJIGNhbid0IHF1aXRlIGZpZ3VyZSBvdXQgd2h5IEkgaGF2ZSB0byB3YWl0IHRvIHJlc2V0IHRoZSBwcm9wZXJ0eSBcbiAgICAgIC8vIHZhbHVlIGhlcmUuLi4gaWYgSSBkb24ndCwgdGhlbiB0aGUgZmFkZSB1Z2VuIHN0YXlzIGFzc2lnbmVkIGluIHRoZSB3b3JrbGV0IHByb2Nlc3Nvci5cbiAgICAgIC8vIGFuZCAwIGRvZXNuJ3Qgd29yayFcbiAgICAgIHNldFRpbWVvdXQoICgpPT4gb2JqWyBuYW1lIF0gPSBzdG9yZS50byA9PT0gMCA/IC4wMDAwMDEgOiBzdG9yZS50bywgMCApXG4gICAgICBzdG9yZS53aWRnZXQuY2xlYXIoKVxuICAgIH1cblxuICAgIHJhbXAuX193cmFwcGVkX18uZnJvbSA9IGZyb21cbiAgICByYW1wLl9fd3JhcHBlZF9fLnRvID0gdG9cblxuICAgIHJldHVybiBvYmpcbiAgfSxcblxuICAvLyB3aGF0IHByb3BlcnRpZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgKGF1dG9tYWdpY2thbGx5PylcbiAgLy8gZmlsdGVyZWQgdGhyb3VnaCBBdWRpby5DbG9jay50aW1lKCk/XG4gIHRpbWVQcm9wcyA6IHtcbiAgICBTeW50aDpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIFBvbHlTeW50aDpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIENvbXBsZXg6WyAnYXR0YWNrJywgJ2RlY2F5JywgJ3N1c3RhaW4nLCAncmVsZWFzZScgXSxcbiAgICBQb2x5Q29tcGxleDpbICdhdHRhY2snLCAnZGVjYXknLCAnc3VzdGFpbicsICdyZWxlYXNlJyBdLFxuICAgIEZNOlsgJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnIF0sXG4gICAgUG9seUZNOlsgJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnIF0sXG4gICAgTW9ub3N5bnRoOlsgJ2F0dGFjaycsICdkZWNheScsICdzdXN0YWluJywgJ3JlbGVhc2UnIF0sXG4gICAgUG9seU1vbm86WyAnYXR0YWNrJywgJ2RlY2F5JywgJ3N1c3RhaW4nLCAncmVsZWFzZScgXSxcbiAgICBEZWxheTpbICd0aW1lJyBdLCBcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1ZGlvXG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuXG5jb25zdCBCaW5vcHMgPSB7XG4gIGNyZWF0ZSggQXVkaW8gKSB7XG4gICAgY29uc3QgYmlub3BzID0ge31cblxuICAgIGZvciggbGV0IGJpbm9wTmFtZSBpbiBHaWJiZXJpc2guYmlub3BzICkge1xuICAgICAgY29uc3QgZ2liYmVyaXNoQ29uc3RydWN0b3IgPSBHaWJiZXJpc2guYmlub3BzWyBiaW5vcE5hbWUgXVxuXG4gICAgICBjb25zdCBtZXRob2RzID0gQmlub3BzLmRlc2NyaXB0aW9uc1sgYmlub3BOYW1lIF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBCaW5vcHMuZGVzY3JpcHRpb25zWyBiaW5vcE5hbWUgXS5tZXRob2RzXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHsgXG4gICAgICAgIHByb3BlcnRpZXM6Z2liYmVyaXNoQ29uc3RydWN0b3IuZGVmYXVsdHMsXG4gICAgICAgIG1ldGhvZHM6bWV0aG9kcyxcbiAgICAgICAgbmFtZTpiaW5vcE5hbWUsXG4gICAgICAgIGNhdGVnb3J5OidiaW5vcHMnXG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbi5wcm9wZXJ0aWVzLnR5cGUgPSAnYmlub3AnXG5cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gVWdlbiggZ2liYmVyaXNoQ29uc3RydWN0b3IsIGRlc2NyaXB0aW9uLCBBdWRpbywgZmFsc2UsIHRydWUgKVxuICAgICAgYmlub3BzWyBiaW5vcE5hbWUgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICBjb25zdCB1Z2VuID0gY29uc3RydWN0b3IoIC4uLmFyZ3MgKVxuICAgICAgICB1Z2VuWzBdID0gdWdlbi5fX3dyYXBwZWRfX1swXVxuICAgICAgICB1Z2VuWzFdID0gdWdlbi5fX3dyYXBwZWRfX1sxXVxuXG4gICAgICAgIHJldHVybiB1Z2VuXG4gICAgICB9IFxuICAgIH1cbiAgICByZXR1cm4gYmlub3BzXG4gIH0sXG5cbiAgZGVzY3JpcHRpb25zOiB7XG4gICAgLy9DaG9ydXM6eyBtZXRob2RzOltdIH0sXG4gIH0sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpbm9wc1xuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgQnVzc2VzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGJ1c3NlcyA9IHt9XG5cbiAgICBjb25zdCBidXNEZXNjcmlwdGlvbiA9IHsgXG4gICAgICBwcm9wZXJ0aWVzOkdpYmJlcmlzaC5CdXMuZGVmYXVsdHMsXG4gICAgICBtZXRob2RzOm51bGwsXG4gICAgICBuYW1lOidCdXMnLFxuICAgICAgY2F0ZWdvcnk6J21pc2MnXG4gICAgfVxuXG4gICAgYnVzc2VzLkJ1cyA9IFVnZW4oIEdpYmJlcmlzaC5CdXMsIGJ1c0Rlc2NyaXB0aW9uLCBBdWRpbyApXG4gICAgYnVzc2VzLl9fQnVzID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBsZXQgcHJvcHNcbiAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDEgfHwgYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnICkge1xuICAgICAgICBwcm9wcyA9IHsgaW5wdXRzOmFyZ3MgfVxuICAgICAgfWVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICkge1xuICAgICAgICBwcm9wcyA9IGFyZ3NbMF1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHByb3BzICE9PSB1bmRlZmluZWQgPyBidXNzZXMuX19CdXMoIHByb3BzICkgOiBidXNzZXMuX19CdXMoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1czJEZXNjcmlwdGlvbiA9IHsgXG4gICAgICBwcm9wZXJ0aWVzOkdpYmJlcmlzaC5CdXMyLmRlZmF1bHRzLFxuICAgICAgbWV0aG9kczpudWxsLFxuICAgICAgbmFtZTonQnVzMicsXG4gICAgICBjYXRlZ29yeTonbWlzYydcbiAgICB9XG5cbiAgICBidXNzZXMuQnVzMiA9IFVnZW4oIEdpYmJlcmlzaC5CdXMyLCBidXMyRGVzY3JpcHRpb24sIEF1ZGlvIClcbiAgICBidXNzZXMuX19CdXMyID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBsZXQgcHJvcHNcbiAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDEgfHwgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJyAmJiBhcmdzWzBdLnR5cGUgIT09ICdlbnNlbWJsZScgKSkge1xuICAgICAgICBwcm9wcyA9IHsgaW5wdXRzOmFyZ3MgfVxuICAgICAgfWVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICkge1xuICAgICAgICBwcm9wcyA9IGFyZ3NbMF1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHByb3BzICE9PSB1bmRlZmluZWQgPyBidXNzZXMuX19CdXMyKCBwcm9wcyApIDogYnVzc2VzLl9fQnVzMigpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1c3Nlc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVzc2VzXG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3Qgc2VyaWFsaXplID0gcmVxdWlyZSggJ3NlcmlhbGl6ZS1qYXZhc2NyaXB0JyApXG5cbi8vIFhYWCBtdXN0IHVzZSBmb3JtIGtleTpmdW5jdGlvbigpIHt9IGR1ZSB0byBzZXJpYWxpemF0aW9uXG5jb25zdCBDbG9jayA9IHtcbiAgX19iZWF0Q291bnQ6MCxcbiAgaWQ6bnVsbCxcbiAgbm9naWJiZXJpc2g6dHJ1ZSxcbiAgYnBtOjE0MCxcbiAgX19sYXN0QlBNOjE0MCxcbiAgc2VxOm51bGwsXG5cbiAgZXhwb3J0OmZ1bmN0aW9uKCBvYmogKSB7XG4gICAgb2JqLmJ0b3MgPSBDbG9jay5idG9zLmJpbmQoIENsb2NrIClcbiAgICBvYmouYnRvbXMgPSBDbG9jay5idG9tcy5iaW5kKCBDbG9jayApXG4gICAgb2JqLnN0b2IgPSBDbG9jay5zdG9iLmJpbmQoIENsb2NrIClcbiAgfSxcblxuICBzdG9yZTpmdW5jdGlvbigpIHsgXG4gICAgR2liYmVyaXNoLkNsb2NrID0gdGhpc1xuICAgIHRoaXMuYmVhdENvdW50ID0gMFxuICAgIHRoaXMucXVldWUgPSBbXVxuICAgIHRoaXMuaW5pdCgpXG4gIH0sXG5cbiAgYWRkVG9RdWV1ZTpmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgYXJncyA9IGFyZ3NbMF1cbiAgICAgIGFyZ3MuZm9yRWFjaCggdiA9PiBHaWJiZXJpc2guQ2xvY2sucXVldWUucHVzaCggdiApIClcbiAgICB9ZWxzZXtcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOiAnbWV0aG9kJyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLmlkLFxuICAgICAgICBuYW1lOiAnYWRkVG9RdWV1ZScsXG4gICAgICAgIGFyZ3M6IHNlcmlhbGl6ZSggYXJncyApLFxuICAgICAgICBmdW5jdGlvbnM6IHRydWVcbiAgICAgIH0pIFxuICAgIH1cbiAgfSxcblxuICBpbml0OmZ1bmN0aW9uKCBHZW4sIEF1ZGlvICkge1xuICAgIC8vIG5lZWRlZCBzbyB0aGF0IHdoZW4gdGhlIGNsb2NrIGlzIHJlLWluaXRpYWxpemVkIChmb3IgZXhhbXBsZSwgYWZ0ZXIgY2xlYXJpbmcpXG4gICAgLy8gZ2liYmVyIHdvbid0IHRyeSBhbmQgc2VyaWFsaXplZCBpdHMgc2VxdWVuY2VyXG4gICAgdGhpcy5zZXEgPSBudWxsXG5cbiAgICBjb25zdCBjbG9ja0Z1bmMgPSAoKT0+IHtcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOiAnYmVhdCcsXG4gICAgICAgIHZhbHVlOiB0aGlzLmJlYXRDb3VudFxuICAgICAgfSkgXG5cbiAgICAgIGlmKCB0aGlzLmJlYXRDb3VudCsrICUgNCA9PT0gMCApIHtcbiAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5wbGF5UXVldWUoKS8vLmZvckVhY2goIGYgPT4geyBmKCkgfSApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICB0aGlzLmlkID0gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuICAgICAgdGhpcy5hdWRpb0Nsb2NrID0gbnVsbFxuICAgICAgdGhpcy5fX3JhdGUgPSBudWxsXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOidhZGQnLFxuICAgICAgICBwcm9wZXJ0aWVzOnNlcmlhbGl6ZSggQ2xvY2sgKSxcbiAgICAgICAgaWQ6dGhpcy5pZCxcbiAgICAgICAgcG9zdDogJ3N0b3JlJyAgICBcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGxldCBicG0gPSB0aGlzLl9fbGFzdEJQTVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnYnBtJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBicG0gfSxcbiAgICAgICAgc2V0KHYpeyBcbiAgICAgICAgICBicG0gPSB2XG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdEJQTSA9IHZcbiAgICAgICAgICAgIGlmKCBBdWRpby5HaWJiZXIuVGlkYWwgIT09IHVuZGVmaW5lZCApIEF1ZGlvLkdpYmJlci5UaWRhbC5jcHMgPSBicG0vMTIwLzJcbiAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBhZGRyZXNzOidzZXQnLFxuICAgICAgICAgICAgICBvYmplY3Q6dGhpcy5pZCxcbiAgICAgICAgICAgICAgbmFtZTonYnBtJyxcbiAgICAgICAgICAgICAgdmFsdWU6YnBtIFxuICAgICAgICAgICAgfSkgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLmF1ZGlvQ2xvY2sgPSBHZW4ubWFrZSggR2VuLnVnZW5zLmFicygxKSApXG4gICAgICAvL3RoaXMuX19yYXRlID0gdGhpcy5hdWRpb0Nsb2NrLl9fcDAgXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3JhdGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLmF1ZGlvQ2xvY2sgfSxcbiAgICAgICAgc2V0KHYpe1xuICAgICAgICAgIHRoaXMuYXVkaW9DbG9jay5wMCA9IHZcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy9HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIC8vICBhZGRyZXNzOidzZXQnLFxuICAgICAgLy8gIHZhbHVlOiBHZW4ubWFrZSggR2VuLnVnZW5zLmFicygxKSApLFxuICAgICAgLy8gIG9iamVjdDp0aGlzLmlkLFxuICAgICAgLy8gIG5hbWU6J2F1ZGlvQ2xvY2snXG4gICAgICAvL30pXG5cbiAgICAgIHRoaXMuYnBtID0gdGhpcy5fX2xhc3RCUE1cbiAgICB9XG5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InIClcbiAgICAgIHRoaXMuc2VxID0gR2liYmVyaXNoLlNlcXVlbmNlci5tYWtlKCBbIGNsb2NrRnVuYyBdLCBbICgpPT5HaWJiZXJpc2guQ2xvY2sudGltZSggMS80ICkgXSApLnN0YXJ0KClcblxuICB9LFxuXG4gIGNvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCB0aGlzLmF1ZGlvQ2xvY2sgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggdGhpcy5hdWRpb0Nsb2NrIClcbiAgICAgIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG4gICAgICBjb25zb2xlLmxvZyggJ2Nsb2NrIGNvbm5lY3RlZCcgKVxuICAgIH1cbiAgfSxcblxuICAvLyB0aW1lIGFjY2VwdHMgYW4gaW5wdXQgdmFsdWUgYW5kIGNvbnZlcnRzIGl0IGludG8gc2FtcGxlcy4gdGhlIGlucHV0IHZhbHVlXG4gIC8vIG1heSBiZSBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMsIGJlYXRzIG9yIHNhbXBsZXMuXG4gIHRpbWU6IGZ1bmN0aW9uKCBpbnB1dFRpbWUgPSAwICkge1xuICAgIGxldCBvdXRwdXRUaW1lID0gaW5wdXRUaW1lXG5cbiAgICAvLyBpZiBpbnB1dCBpcyBhbiBhbm5vdGF0ZWQgdGltZSB2YWx1ZSBzdWNoIGFzIHdoYXQgaXMgcmV0dXJuZWRcbiAgICAvLyBieSBzYW1wbGVzKCkgb3IgbXMoKS4uLlxuICAgIC8vIGNvbnNvbGUubG9nKCAnaW5wdXQgdGltZTonICwgaW5wdXRUaW1lIClcbiAgICBpZiggaXNOYU4oIGlucHV0VGltZSApICkge1xuICAgICAgaWYoIHR5cGVvZiBpbnB1dFRpbWUgPT09ICdvYmplY3QnICkgeyBcbiAgICAgICAgaWYoIGlucHV0VGltZS50eXBlID09PSAnc2FtcGxlcycgKSB7XG4gICAgICAgICAgb3V0cHV0VGltZSA9IGlucHV0VGltZS52YWx1ZVxuICAgICAgICB9ZWxzZSBpZiggaW5wdXRUaW1lLnR5cGUgPT09ICdtcycgKSB7XG4gICAgICAgICAgb3V0cHV0VGltZSA9IHRoaXMubXN0b3MoIGlucHV0VGltZS52YWx1ZSApIFxuICAgICAgICB9XG4gICAgICB9IFxuICAgIH1lbHNle1xuICAgICAgLy8gWFhYIDQgaXMgYSBtYWdpYyBudW1iZXIsIG5lZWRzIHRvIGFjY291bnQgZm9yIHRoZSBjdXJyZW50IHRpbWUgc2lnbmF0dXJlXG4gICAgICBvdXRwdXRUaW1lID0gdGhpcy5idG9zKCBpbnB1dFRpbWUgKiA0IClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dHB1dFRpbWVcbiAgfSxcblxuICAvLyBkb2VzIG5vdCB3b3JrLi4uIHNheXMgR2liYmVyaXNoIGNhbid0IGJlIGZvdW5kPyBJIGd1ZXNzIEdpYmJlcmlzaCBpc24ndCBpbiB0aGVcbiAgLy8gZ2xvYmFsIHNjb3BlIG9mIHRoZSB3b3JrbGV0P1xuICBUaW1lOiBmdW5jdGlvbiggaW5wdXRUaW1lICkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oIGByZXR1cm4gR2liYmVyaXNoLkNsb2NrLnRpbWUoICR7aW5wdXRUaW1lfSApYCApXG4gIH0sXG5cbiAgbXN0b3M6IGZ1bmN0aW9uKCBtcyApIHtcbiAgICByZXR1cm4gKCBtcyAvIDEwMDAgKSAqIEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZVxuICB9LFxuXG4gIC8vIGNvbnZlcnQgYmVhdHMgdG8gc2FtcGxlc1xuICBidG9zOiBmdW5jdGlvbiggYmVhdHMgKSB7XG4gICAgY29uc3Qgc2FtcGxlc1BlckJlYXQgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyAodGhpcy5icG0gLyA2MCApXG4gICAgcmV0dXJuIHNhbXBsZXNQZXJCZWF0ICogYmVhdHMgXG4gIH0sXG5cbiAgLy8gY29udmVydCBzYW1wbGVzIHRvIGJlYXRzIChmb3IgcGF0dGVybiB2aXN1YWxpemF0aW9ucylcbiAgc3RvYjogZnVuY3Rpb24oIHNhbXBsZXMgKSB7XG4gICAgY29uc3Qgc2FtcGxlc1BlckJlYXQgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyAodGhpcy5icG0gLyA2MCApXG4gICAgcmV0dXJuIChzYW1wbGVzIC8gc2FtcGxlc1BlckJlYXQpICogLjI1IC8vIFhYWCBtYWdpYyBudW1iZXIgc2hvdWxkIGJlIGRlbm9taW5hdG9yIG9mIHRpbWUgc2lnbmF0dXJlIFxuICB9LFxuICAvLyBjb252ZXJ0IGJlYXRzIHRvIG1pbGxpc2Vjb25kc1xuICBidG9tczogZnVuY3Rpb24oIGJlYXRzICkge1xuICAgIGNvbnN0IHNhbXBsZXNQZXJNcyA9IEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZSAvIDEwMDBcbiAgICByZXR1cm4gYmVhdHMgKiBzYW1wbGVzUGVyTXNcbiAgfSxcblxuICBtczogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgIHJldHVybiB7IHR5cGU6J21zJywgdmFsdWUgfVxuICB9LFxuXG4gIHNhbXBsZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICByZXR1cm4geyB0eXBlOidzYW1wbGVzJywgdmFsdWUgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvY2tcbiIsImNvbnN0IFVnZW4gPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5jb25zdCBQcmVzZXRzID0gcmVxdWlyZSggJy4vcHJlc2V0cy5qcycgKVxuXG5sZXQgQXVkaW8gPSBudWxsXG5cbmNvbnN0IGFkZE1ldGhvZCA9ICggb2JqLCBuYW1lLCBfX3ZhbHVlID0gMSwgcHJvcE92ZXJyaWRlTmFtZSApID0+IHtcbiAgaWYoIHByb3BPdmVycmlkZU5hbWUgPT09IHVuZGVmaW5lZCApIHByb3BPdmVycmlkZU5hbWUgPSBuYW1lXG5cbiAgb2JqWyAnX18nICsgbmFtZSBdID0geyBcbiAgICB2YWx1ZTogX192YWx1ZSxcbiAgICBpc1Byb3BlcnR5OnRydWUsXG4gICAgc2VxdWVuY2VyczpbXSxcbiAgICBtb2RzOltdLFxuICAgIG5hbWUsXG5cbiAgICBzZXEoIHZhbHVlcywgdGltaW5ncywgbnVtYmVyID0gMCwgZGVsYXkgPSAwICkge1xuICAgICAgbGV0IHByZXZTZXEgPSBvYmpbJ19fJytuYW1lXS5zZXF1ZW5jZXJzWyBudW1iZXIgXSBcbiAgICAgIGlmKCBwcmV2U2VxICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICBwcmV2U2VxLnN0b3AoKTsgcHJldlNlcS5jbGVhcigpOyBcbiAgICAgICAgbGV0IGlkeCA9IG9iai5fX3NlcXVlbmNlcnMuaW5kZXhPZiggcHJldlNlcSApXG4gICAgICAgIG9iai5fX3NlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgfVxuXG4gICAgICAvLyBYWFggeW91IGhhdmUgdG8gYWRkIGEgbWV0aG9kIHRoYXQgZG9lcyBhbGwgdGhpcyBzaGl0IG9uIHRoZSB3b3JrbGV0LiBjcmFwLlxuICAgICAgb2JqWydfXycrbmFtZV0uc2VxdWVuY2Vyc1sgbnVtYmVyIF0gPSBvYmpbJ19fJytuYW1lXVsgbnVtYmVyIF0gPSBBdWRpby5Db3JlLlNlcSh7IFxuICAgICAgICB2YWx1ZXMsIFxuICAgICAgICB0aW1pbmdzLCBcbiAgICAgICAgdGFyZ2V0Om9iai5fX3dyYXBwZWRfXywgXG4gICAgICAgIGtleTpuYW1lLFxuICAgICAgICByYXRlOkF1ZGlvLkNsb2NrLmF1ZGlvQ2xvY2tcbiAgICAgIH0pXG4gICAgICAuc3RhcnQoIEF1ZGlvLkNsb2NrLnRpbWUoIGRlbGF5ICkgKVxuXG4gICAgICBvYmouX19zZXF1ZW5jZXJzLnB1c2goIG9ialsnX18nK25hbWVdWyBudW1iZXIgXSApXG5cbiAgICAgIC8vIHJldHVybiBvYmplY3QgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gIH1cblxuICBBdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICBhZGRyZXNzOidhZGRNZXRob2QnLFxuICAgIGtleTpuYW1lLFxuICAgIGZ1bmN0aW9uOmBmdW5jdGlvbiggJHtuYW1lfSApIHtcbiAgICAgICAgZm9yKCBsZXQgaW5wdXQgb2YgdGhpcy5pbnB1dHMgKSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgKSBpbnB1dFsgJyR7cHJvcE92ZXJyaWRlTmFtZX0nIF0gPSAke25hbWV9XG4gICAgICAgIH1cbiAgICAgIH1gLFxuICAgIGlkOm9iai5pZCxcbiAgICBkZWxheTpBdWRpby5zaG91bGREZWxheVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgZ2V0KCkgeyByZXR1cm4gdGhpc1sgJ19fJyArIG5hbWUgXSB9LFxuICAgIHNldCh2KXsgXG4gICAgICB0aGlzWyAnX18nICsgbmFtZSBdLnZhbHVlID0gdlxuICAgICAgZm9yKCBsZXQgc2FtcGxlciBvZiB0aGlzLnNhbXBsZXJzICkgc2FtcGxlclsgcHJvcE92ZXJyaWRlTmFtZSBdID0gdGhpc1sgJ19fJyArIG5hbWUgXS52YWx1ZSBcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIF9fQXVkaW8gKSB7XG4gIEF1ZGlvID0gX19BdWRpb1xuXG4gIGNvbnN0IERydW1zID0gZnVuY3Rpb24oIHNjb3JlLCB0aW1lLCAuLi5hcmdzICkgeyBcbiAgICAvLyBYWFggd2hhdCB1cmwgcHJlZml4IHNob3VsZCBJIGJlIHVzaW5nP1xuXG4gICAgY29uc3QgdGVtcCA9IEF1ZGlvLmF1dG9Db25uZWN0XG4gICAgQXVkaW8uYXV0b0Nvbm5lY3QgPSBmYWxzZVxuICAgIGNvbnN0IGsgID0gQXVkaW8uaW5zdHJ1bWVudHMuU2FtcGxlcih7IGZpbGVuYW1lOicuL3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2sud2F2JyB9KVxuICAgIGNvbnN0IHMgID0gQXVkaW8uaW5zdHJ1bWVudHMuU2FtcGxlcih7IGZpbGVuYW1lOicuL3Jlc291cmNlcy9hdWRpb2ZpbGVzL3NuYXJlLndhdicgfSlcbiAgICBjb25zdCBjaCA9IEF1ZGlvLmluc3RydW1lbnRzLlNhbXBsZXIoeyBmaWxlbmFtZTonLi9yZXNvdXJjZXMvYXVkaW9maWxlcy9oYXQud2F2JyB9KVxuICAgIGNvbnN0IG9oID0gQXVkaW8uaW5zdHJ1bWVudHMuU2FtcGxlcih7IGZpbGVuYW1lOicuL3Jlc291cmNlcy9hdWRpb2ZpbGVzL29wZW5oYXQud2F2JyB9KVxuICAgIEF1ZGlvLmF1dG9Db25uZWN0ID0gdGVtcFxuXG4gICAgY29uc3QgZHJ1bXMgPSBBdWRpby5FbnNlbWJsZSh7XG4gICAgICAna2QnOiB7IHRhcmdldDprLCAgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J2tpY2snIH0sXG4gICAgICBbMF06IHsgdGFyZ2V0OmssICBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTona2ljaycgfSxcbiAgICAgICdzZCc6IHsgdGFyZ2V0OnMsICBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTonc25hcmUnIH0sXG4gICAgICAnc24nOiB7IHRhcmdldDpzLCAgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J3NuYXJlJyB9LFxuICAgICAgWzFdOiB7IHRhcmdldDpzLCAgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J3NuYXJlJyB9LFxuICAgICAgJ2NoJzogeyB0YXJnZXQ6Y2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidjbG9zZWRIYXQnIH0sXG4gICAgICBbMl06IHsgdGFyZ2V0OmNoLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTonY2xvc2VkSGF0JyB9LFxuICAgICAgJ29oJzogeyB0YXJnZXQ6b2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidvcGVuSGF0JyB9LFxuICAgICAgWzNdOiB7IHRhcmdldDpvaCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J29wZW5IYXQnIH0sXG4gICAgfSlcblxuICAgIGlmKCBBdWRpby5hdXRvQ29ubmVjdCA9PT0gdHJ1ZSApIGRydW1zLmNvbm5lY3QoKVxuXG4gICAgZHJ1bXMuX19zZXF1ZW5jZXJzID0gWyBdXG4gICAgLy9pZiggdHlwZW9mIHNjb3JlID09PSAnc3RyaW5nJyApIHtcbiAgICAvLyAgZHJ1bXMuc2VxID0gQXVkaW8uU2VxKHtcbiAgICAvLyAgICB0YXJnZXQ6ZHJ1bXMsXG4gICAgLy8gICAga2V5OidwbGF5JyxcbiAgICAvLyAgICB2YWx1ZXM6c2NvcmUuc3BsaXQoJycpLFxuICAgIC8vICAgIHRpbWluZ3M6dGltZSA9PT0gdW5kZWZpbmVkID8gMSAvIHNjb3JlLmxlbmd0aCA6IHRpbWVcbiAgICAvLyAgfSkuc3RhcnQoKVxuICAgIFxuXG4gICAgLy8gIGRydW1zLnZhbHVlcyA9IGRydW1zLnNlcS52YWx1ZXNcbiAgICAvLyAgZHJ1bXMudGltaW5ncyA9IGRydW1zLnNlcS50aW1pbmdzXG5cbiAgICAvLyAgZHJ1bXMuX19zZXF1ZW5jZXJzLnB1c2goIGRydW1zLnNlcSApXG4gICAgLy99ZWxzZXtcbiAgICAvLyAgR2liYmVyLmFkZFNlcXVlbmNpbmcoIGRydW1zLCAncGxheScsIDAgKVxuICAgIC8vfVxuXG4gICAgZHJ1bXMuc2FtcGxlcnMgPSBbIGsscyxjaCxvaCBdXG5cbiAgICBhZGRNZXRob2QoIGRydW1zLCAncGl0Y2gnLCAxLCAncmF0ZScgKVxuICAgIGFkZE1ldGhvZCggZHJ1bXMsICdzdGFydCcsIDAgKVxuICAgIGFkZE1ldGhvZCggZHJ1bXMsICdlbmQnLCAxIClcblxuICAgIHByb3BzID0gUHJlc2V0cy5wcm9jZXNzKCB7IG5hbWU6J0RydW1zJywgY2F0ZWdvcnk6J2luc3RydW1lbnRzJyB9LCBhcmdzLCBBdWRpbyApXG4gICAgaWYoIHByb3BzICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuX19wcmVzZXRJbml0X18gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oIGRydW1zLCBwcm9wcyApXG4gICAgICBpZiggcHJvcHMuX19wcmVzZXRJbml0X18gIT09IHVuZGVmaW5lZCApIHByb3BzLl9fcHJlc2V0SW5pdF9fLmNhbGwoIGRydW1zLCBBdWRpbyApXG4gICAgfVxuXG4gICAgZHJ1bXMubmFtZSA9ICdEcnVtcydcbiAgICByZXR1cm4gZHJ1bXNcbiAgfVxuXG4gIGNvbnN0IEVEcnVtcyA9IGZ1bmN0aW9uKCAgLi4uYXJncyApIHtcbiAgICBjb25zdCB0ZW1wID0gQXVkaW8uYXV0b0Nvbm5lY3RcbiAgICBBdWRpby5hdXRvQ29ubmVjdCA9IGZhbHNlXG4gICAgXG4gICAgY29uc3Qga2QgPSBBdWRpby5pbnN0cnVtZW50cy5LaWNrKClcbiAgICBjb25zdCBzZCA9IEF1ZGlvLmluc3RydW1lbnRzLlNuYXJlKClcbiAgICBjb25zdCBjaCA9IEF1ZGlvLmluc3RydW1lbnRzLkhhdCh7IGRlY2F5Oi4xLCBnYWluOi4zIH0pXG4gICAgY29uc3Qgb2ggPSBBdWRpby5pbnN0cnVtZW50cy5IYXQoeyBkZWNheTouNSwgZ2FpbjouMyB9KVxuICAgIGNvbnN0IGNwID0gQXVkaW8uaW5zdHJ1bWVudHMuQ2xhcCgpXG4gICAgY29uc3QgY2IgPSBBdWRpby5pbnN0cnVtZW50cy5Db3diZWxsKHsgZ2FpbjouNjUgfSlcbiAgICBcbiAgICBBdWRpby5hdXRvQ29ubmVjdCA9IHRlbXBcbiAgICBcbiAgICBjb25zdCBkcnVtcyA9IEF1ZGlvLkVuc2VtYmxlKHtcbiAgICAgICdrZCc6IHsgdGFyZ2V0OmtkLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsxXSwgbmFtZTona2ljaycgfSxcbiAgICAgIFswXTogeyB0YXJnZXQ6a2QsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidraWNrJyB9LFxuICAgICAgWzFdOiB7IHRhcmdldDpzZCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbMV0sIG5hbWU6J3NuYXJlJyB9LFxuICAgICAgJ3NkJzogeyB0YXJnZXQ6c2QsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6WzFdLCBuYW1lOidzbmFyZScgfSxcbiAgICAgIFsyXTogeyB0YXJnZXQ6Y2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy4yXSwgbmFtZTonY2xvc2VkSGF0JyB9LFxuICAgICAgJ2NoJzogeyB0YXJnZXQ6Y2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy4yXSwgbmFtZTonY2xvc2VkSGF0JyB9LFxuICAgICAgWzNdOiB7IHRhcmdldDpvaCwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbLjJdLCBuYW1lOidvcGVuSGF0JyB9LFxuICAgICAgJ29oJzogeyB0YXJnZXQ6b2gsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy4yXSwgbmFtZTonb3BlbkhhdCcgfSxcbiAgICAgIFs0XTogeyB0YXJnZXQ6Y3AsIG1ldGhvZDondHJpZ2dlcicsIGFyZ3M6Wy41XSwgbmFtZTonY2xhcCcgfSxcbiAgICAgICdjcCc6IHsgdGFyZ2V0OmNwLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuNV0sIG5hbWU6J2NsYXAnIH0sXG4gICAgICBbNV06IHsgdGFyZ2V0OmNiLCBtZXRob2Q6J3RyaWdnZXInLCBhcmdzOlsuNV0sIG5hbWU6J2Nvd2JlbGwnIH0sXG4gICAgICAnY2InOiB7IHRhcmdldDpjYiwgbWV0aG9kOid0cmlnZ2VyJywgYXJnczpbLjVdLCBuYW1lOidjb3diZWxsJyB9LFxuICAgIH0pXG5cbiAgICAvL2lmKCB0eXBlb2Ygc2NvcmUgPT09ICdzdHJpbmcnICkge1xuICAgIC8vICBkcnVtcy5zZXEgPSBBdWRpby5TZXEoe1xuICAgIC8vICAgIHRhcmdldDpkcnVtcyxcbiAgICAvLyAgICBrZXk6J3BsYXknLFxuICAgIC8vICAgIHZhbHVlczpzY29yZS5zcGxpdCgnJyksXG4gICAgLy8gICAgdGltaW5nczp0aW1lID09PSB1bmRlZmluZWQgPyAxIC8gc2NvcmUubGVuZ3RoIDogdGltZSxcbiAgICAvLyAgICByYXRlOkF1ZGlvLkNsb2NrLmF1ZGlvQ2xvY2tcbiAgICAvLyAgfSkuc3RhcnQoKVxuXG4gICAgLy8gIGRydW1zLnZhbHVlcyA9IGRydW1zLnNlcS52YWx1ZXNcbiAgICAvLyAgZHJ1bXMudGltaW5ncyA9IGRydW1zLnNlcS50aW1pbmdzXG4gICAgLy99XG5cbiAgICBpZiggQXVkaW8uYXV0b0Nvbm5lY3QgPT09IHRydWUgKSBkcnVtcy5jb25uZWN0KClcblxuICAgIHByb3BzID0gUHJlc2V0cy5wcm9jZXNzKCB7IG5hbWU6J0VEcnVtcycsIGNhdGVnb3J5OidpbnN0cnVtZW50cycgfSwgYXJncywgQXVkaW8gKVxuICAgIGlmKCBwcm9wcyAhPT0gdW5kZWZpbmVkICYmIHByb3BzLl9fcHJlc2V0SW5pdF9fICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBwcm9wcy5fX3ByZXNldEluaXRfXy5jYWxsKCBkcnVtcywgQXVkaW8gKVxuICAgIH1cblxuICAgIC8vZHJ1bXMudGlkYWwgPSBwYXR0ZXJuID0+IHtcbiAgICAvLyAgaWYoIGRydW1zLl9fdGlkYWwgIT09IHVuZGVmaW5lZCApIGRydW1zLl9fdGlkYWwuc3RvcCgpXG5cbiAgICAvLyAgZHJ1bXMuX190aWRhbCA9IEF1ZGlvLlRpZGFsKHtcbiAgICAvLyAgICB0YXJnZXQ6ZHJ1bXMsXG4gICAgLy8gICAga2V5OidwbGF5JyxcbiAgICAvLyAgICBwYXR0ZXJuXG4gICAgLy8gIH0pLnN0YXJ0KClcblxuICAgIC8vICByZXR1cm4gZHJ1bXNcbiAgICAvL31cblxuICAgIGRydW1zLm5hbWUgPSAnRURydW1zJ1xuICAgIHJldHVybiBkcnVtc1xuICB9XG5cbiAgcmV0dXJuIHsgRHJ1bXMsIEVEcnVtcyB9XG59XG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuXG5jb25zdCBFZmZlY3RzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGVmZmVjdHMgPSB7fVxuICAgIGNvbnN0IHBvb2xFZmZlY3RzID0gWydGcmVldmVyYicsICdQbGF0ZScsICdCdWZmZXJTaHVmZmxlciddXG4gICAgR2liYmVyaXNoLmVmZmVjdHMgPSBHaWJiZXJpc2guZnhcblxuICAgIGZvciggbGV0IGVmZmVjdE5hbWUgaW4gR2liYmVyaXNoLmVmZmVjdHMgKSB7XG4gICAgICBjb25zdCBnaWJiZXJpc2hDb25zdHJ1Y3RvciA9IEdpYmJlcmlzaC5lZmZlY3RzWyBlZmZlY3ROYW1lIF1cblxuICAgICAgY29uc3QgbWV0aG9kcyA9IEVmZmVjdHMuZGVzY3JpcHRpb25zWyBlZmZlY3ROYW1lIF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBFZmZlY3RzLmRlc2NyaXB0aW9uc1sgZWZmZWN0TmFtZSBdLm1ldGhvZHNcblxuICAgICAgLy8gWFhYIGhvdyBkbyB3ZSBtYWtlIHRoaXMgbW9yZSBnZW5lcmljIGZvciBhbnkgbW9kZWwgb2YgcmV2ZXJiIC8gYW55IHR5cGUgb2YgZGlzdG9ydGlvbiBldGMuXG4gICAgICBjb25zdCByZXBsYWNlTmFtZSA9IGVmZmVjdE5hbWUgPT09ICdGcmVldmVyYicgPyAnUmV2ZXJiJyA6IGVmZmVjdE5hbWUgXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHsgXG4gICAgICAgIHByb3BlcnRpZXM6Z2liYmVyaXNoQ29uc3RydWN0b3IuZGVmYXVsdHMgfHwge30sIFxuICAgICAgICBtZXRob2RzOm1ldGhvZHMsXG4gICAgICAgIG5hbWU6cmVwbGFjZU5hbWUsXG4gICAgICAgIGNhdGVnb3J5OidlZmZlY3RzJ1xuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24ucHJvcGVydGllcy50eXBlID0gJ2Z4J1xuXG4gICAgICBjb25zdCBzaG91bGRVc2VQb29sID0gcG9vbEVmZmVjdHMuaW5kZXhPZiggZWZmZWN0TmFtZSApID4gLTEgXG5cbiAgICAgIGVmZmVjdHNbIGVmZmVjdE5hbWUgXSA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8sIHNob3VsZFVzZVBvb2wgKVxuICAgICAgXG4gICAgICBlZmZlY3RzWyBlZmZlY3ROYW1lIF0ucHJlc2V0cyA9IEF1ZGlvLlByZXNldHMuZWZmZWN0c1sgZWZmZWN0TmFtZSBdIFxuICAgICAgaWYoIGVmZmVjdHNbIGVmZmVjdE5hbWUgXS5wcmVzZXRzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGVmZmVjdHNbIGVmZmVjdE5hbWUgXS5wcmVzZXRzLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLnRhYmxlKCB0aGlzIClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGVmZmVjdHNbIGVmZmVjdE5hbWUgXS5wcmVzZXRzID0geyBpbnNwZWN0KCkgeyBjb25zb2xlLmxvZyggYCR7ZWZmZWN0TmFtZX0gaGFzIG5vIHByZXNldHMuYCApIH0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVmZmVjdHMuUmV2ZXJiID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBsZXQgYXJncHJvcHMgPSBudWxsXG4gICAgICBpZiggYXJncy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgKSBhcmdwcm9wcyA9IGFyZ3NbMF1cbiAgICAgIH1lbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMiApIHtcbiAgICAgICAgYXJncHJvcHMgPSBhcmdzWzFdXG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCB7IG1vZGVsOjAgfSwgYXJncHJvcHMgKVxuXG4gICAgICBsZXQgdWdlbiA9IG51bGxcbiAgICAgIHN3aXRjaCggcHJvcHMubW9kZWwgKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB1Z2VuID0gZWZmZWN0cy5GcmVldmVyYiguLi5hcmdzIClcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVnZW5cbiAgICB9XG5cbiAgICByZXR1cm4gZWZmZWN0c1xuICB9LFxuXG4gIGRlc2NyaXB0aW9uczoge1xuICAgIC8vQ2hvcnVzOnsgbWV0aG9kczpbXSB9LFxuICB9LFxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RzXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBBdWRpbyApIHtcbiAgY29uc3QgR2liYmVyaXNoID0gQXVkaW8uR2liYmVyaXNoXG4gIGNvbnN0IEVuc2VtYmxlID0gZnVuY3Rpb24oIHByb3BzICkge1xuICAgIGNvbnN0IGNwID0ge1xuICAgICAgc2hvdWxkQWRkVG9VZ2VuOnRydWVcbiAgICB9XG5cbiAgICBmb3IoIGxldCBrZXkgaW4gcHJvcHMgKSB7XG4gICAgICBjb25zdCBkaWN0ID0gcHJvcHNbIGtleSBdXG4gICAgICBjb25zdCB0YXJnZXQgPSBkaWN0LnRhcmdldFxuICAgICAgY29uc3QgbWV0aG9kID0gZGljdC5tZXRob2RcbiAgICAgIGNvbnN0IGFyZ3MgPSBkaWN0LmFyZ3NcbiAgICAgIGNwWyBrZXkgXSA9IHtcbiAgICAgICAgcGxheTogZnVuY3Rpb24oIC4uLmFyZ3MgKSB7IFxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLmdldCggdGhpcy50YXJnZXQgKVsgdGhpcy5tZXRob2QgXSggLi4uYXJncyApIFxuICAgICAgICB9LFxuICAgICAgICB0YXJnZXQ6dGFyZ2V0LmlkLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG5hbWU6ZGljdC5uYW1lXG4gICAgICB9XG5cbiAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KCBjcFsga2V5IF0sICdsb3VkbmVzcycsIHtcbiAgICAgIC8vICBzZXQodikge1xuICAgICAgLy8gICAgY29uc29sZS5sb2coICdsb3VkbmVzczonLCB2LCBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5nZXQoIHRoaXMudGFyZ2V0ICkpXG4gICAgICAvLyAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5nZXQoIHRoaXMudGFyZ2V0ICkubG91ZG5lc3MgPSB2XG4gICAgICAvLyAgfVxuICAgICAgLy99KVxuICAgICAgY3BbIGRpY3QubmFtZSBdID0gdGFyZ2V0XG4gICAgfVxuXG4gICAgY3AucGxheSA9IGZ1bmN0aW9uKCBfX2tleSApIHtcbiAgICAgIGNvbnN0IGtleSA9IGlzTmFOKF9fa2V5KSA/IF9fa2V5IDogcGFyc2VJbnQoIF9fa2V5ICkgXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5nZXQoIHRoaXNbIGtleSBdLnRhcmdldCApWyB0aGlzWyBrZXkgXS5tZXRob2QgXSggLi4udGhpc1sga2V5IF0uYXJncyApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgcHJvcHNbIGtleSBdLnRhcmdldFsgdGhpc1sga2V5IF0ubWV0aG9kIF0oIC4uLnRoaXNbIGtleSBdLmFyZ3MgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVucyA9IEF1ZGlvLmJ1c3Nlcy5CdXMyKCBjcCApXG4gICAgZW5zLl9faXNFbnNlbWJsZSA9IHRydWVcblxuICAgIGZvciggbGV0IGtleSBpbiBwcm9wcyApIHtcbiAgICAgIHByb3BzWyBrZXkgXS50YXJnZXQuY29ubmVjdCggZW5zIClcbiAgICB9XG4gICAgXG4gICAgZW5zLnRpZGFscyA9IFtdXG5cbiAgICBlbnMuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZW5zLnRpZGFscy5mb3JFYWNoKCB0ID0+IHQuc3RvcCgpIClcbiAgICAgIGVucy5fX3NlcXVlbmNlcnMuZm9yRWFjaCggdCA9PiB0LnN0b3AoKSApXG4gICAgfVxuICAgIGVucy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZW5zLnRpZGFscy5mb3JFYWNoKCB0ID0+IHQuc3RhcnQoKSApXG4gICAgICBlbnMuX19zZXF1ZW5jZXJzLmZvckVhY2goIHQgPT4gdC5zdGFydCgpIClcbiAgICB9XG5cbiAgICBlbnMudGlkYWwgPSAocGF0dGVybixudW09MCkgPT4ge1xuICAgICAgY29uc3QgdCA9ICBBdWRpby5HaWJiZXIuVGlkYWwoe1xuICAgICAgICB0YXJnZXQ6ZW5zLFxuICAgICAgICBrZXk6J3BsYXknLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9KVxuXG4gICAgICBpZiggdCAhPT0gbnVsbCApIHtcbiAgICAgICAgaWYoIGVucy50aWRhbHNbIG51bSBdICE9PSB1bmRlZmluZWQgKSBlbnMudGlkYWxzWyBudW0gXS5zdG9wKClcblxuICAgICAgICBlbnMudGlkYWxzWyBudW0gXSA9IHRcbiAgICAgICAgdC5zdGFydCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnNcbiAgICB9XG4gICAgZW5zLl9fc2VxdWVuY2VycyA9IFtdXG5cbiAgICBlbnMuc2VxID0gKHZhbHVlcyx0aW1pbmdzLG51bT0wLG9mZnNldD0wKSA9PiB7XG4gICAgICBpZiggZW5zLl9fc2VxdWVuY2Vyc1sgbnVtIF0gIT09IHVuZGVmaW5lZCApIGVucy5fX3NlcXVlbmNlcnNbIG51bSBdLnN0b3AoKVxuXG4gICAgICBlbnMuX19zZXF1ZW5jZXJzWyBudW0gXSA9IEF1ZGlvLkdpYmJlci5TZXEoe1xuICAgICAgICB0YXJnZXQ6ZW5zLFxuICAgICAgICBrZXk6J3BsYXknLFxuICAgICAgICB2YWx1ZXMsdGltaW5ncyxvZmZzZXRcbiAgICAgIH0pLnN0YXJ0KClcblxuICAgICAgcmV0dXJuIGVuc1xuICAgIH1cblxuICAgIHJldHVybiBlbnNcbiAgfVxuXG4gIHJldHVybiBFbnNlbWJsZVxufVxuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgRW52ZWxvcGVzID0ge1xuICBjcmVhdGUoIEF1ZGlvICkge1xuICAgIGNvbnN0IGVudmVsb3BlcyA9IHt9XG5cbiAgICBmb3IoIGxldCBlbnZlbG9wZU5hbWUgaW4gR2liYmVyaXNoLmVudmVsb3BlcyApIHtcbiAgICAgIGNvbnN0IGdpYmJlcmlzaENvbnN0cnVjdG9yID0gR2liYmVyaXNoLmVudmVsb3Blc1sgZW52ZWxvcGVOYW1lIF1cblxuICAgICAgY29uc3QgbWV0aG9kcyA9IEVudmVsb3Blcy5kZXNjcmlwdGlvbnNbIGVudmVsb3BlTmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogRW52ZWxvcGVzLmRlc2NyaXB0aW9uc1sgZW52ZWxvcGVOYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzIHx8IHt9LCBcbiAgICAgICAgbWV0aG9kczptZXRob2RzLFxuICAgICAgICBuYW1lOmVudmVsb3BlTmFtZSxcbiAgICAgICAgY2F0ZWdvcnk6J2VudmVsb3BlcydcbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9uLnByb3BlcnRpZXMudHlwZSA9ICdlbnZlbG9wZSdcblxuICAgICAgZW52ZWxvcGVzWyBlbnZlbG9wZU5hbWUgXSA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8gKVxuICAgIH1cbiAgICByZXR1cm4gZW52ZWxvcGVzXG4gIH0sXG5cbiAgZGVzY3JpcHRpb25zOiB7XG4gICAgLy9DaG9ydXM6eyBtZXRob2RzOltdIH0sXG4gIH0sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVudmVsb3Blc1xuIiwiXG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90XG4gKiB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyXG4gKiB0aGUgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJlYWxtIChzY29wZSwgcGFyZW50RWxlbWVudCkge1xuICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBmcmFtZS5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6LTk5OXB4O3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuICBjb25zdCB3aW4gPSBmcmFtZS5jb250ZW50V2luZG93O1xuICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIGxldCB2YXJzID0gJ3ZhciB3aW5kb3csJGhvb2snO1xuICBmb3IgKGNvbnN0IGkgaW4gd2luKSB7XG4gICAgaWYgKCEoaSBpbiBzY29wZSkgJiYgaSAhPT0gJ2V2YWwnKSB7XG4gICAgICB2YXJzICs9ICcsJztcbiAgICAgIHZhcnMgKz0gaTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpIGluIHNjb3BlKSB7XG4gICAgdmFycyArPSAnLCc7XG4gICAgdmFycyArPSBpO1xuICAgIHZhcnMgKz0gJz1zZWxmLic7XG4gICAgdmFycyArPSBpO1xuICB9XG4gIGNvbnN0IHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShcbiAgICBgZnVuY3Rpb24gJGhvb2soc2VsZixjb25zb2xlKSB7XCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICR7dmFyc307cmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBldmFsKGFyZ3VtZW50c1swXSl9fWBcbiAgKSk7XG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHRoaXMuZXhlYyA9IHdpbi4kaG9vay5jYWxsKHNjb3BlLCBzY29wZSwgY29uc29sZSk7XG59XG4iLCJcbi8vIFNlZSBhbGwgc2NhbGVzIGF0OiBodHRwOi8vYWJiZXJuaWUuZ2l0aHViLmlvL3R1bmUvc2NhbGVzLmh0bWxcblxuXG5jb25zdCBUdW5lID0gZnVuY3Rpb24oKXtcblxuXHQvLyB0aGUgc2NhbGUgYXMgcmF0aW9zXG5cdHRoaXMuc2NhbGUgPSBbXVxuXG5cdC8vIGkvbyBtb2Rlc1xuXHR0aGlzLm1vZGUgPSB7XG5cdFx0b3V0cHV0OiBcImZyZXF1ZW5jeVwiLFxuXHRcdGlucHV0OiBcInN0ZXBcIlxuXHR9XG5cblx0Ly8gRVQgbWFqb3IsIGZvciByZWZlcmVuY2Vcblx0dGhpcy5ldG1ham9yPSBbIDI2MS42MjU1OCxcblx0XHQyOTMuNjY0NzY0LFxuXHRcdDMyOS42Mjc1NjMsXG5cdFx0MzQ5LjIyODI0MSxcblx0XHQzOTEuOTk1NDIyLFxuXHRcdDQ0MCxcblx0XHQ0OTMuODgzMzAxLFxuXHRcdDUyMy4yNTExNlxuXHRdXG5cbiAgXG4gIHRoaXMuVHVuaW5nTGlzdCA9IG51bGxcblx0Ly8gUm9vdCBmcmVxdWVuY3kuXG5cdHRoaXMudG9uaWMgPSA0NDBcblxuXHRjb25zb2xlLmxvZyhcInt7e3sgVHVuZS5qcyB2MC4xIExvYWRlZCB9fX19XCIpO1xuXG59XG5cbi8qIFNldCB0aGUgdG9uaWMgZnJlcXVlbmN5ICovXG5cblR1bmUucHJvdG90eXBlLnRvbmljaXplID0gZnVuY3Rpb24obmV3VG9uaWMpIHtcblx0dGhpcy50b25pYyA9IG5ld1RvbmljXG59XG5cbi8qIFJldHVybiBkYXRhIGluIHRoZSBtb2RlIHlvdSBhcmUgaW4gKGZyZXEsIHJhdGlvLCBvciBtaWRpKSAqL1xuXG5UdW5lLnByb3RvdHlwZS5ub3RlID0gZnVuY3Rpb24oaW5wdXQsb2N0YXZlKXtcblxuXHR2YXIgbmV3dmFsdWU7XG5cblx0aWYgKHRoaXMubW9kZS5vdXRwdXQgPT0gXCJmcmVxdWVuY3lcIikgeyBcblx0XHRuZXd2YWx1ZSA9IHRoaXMuZnJlcXVlbmN5KGlucHV0LG9jdGF2ZSlcblx0fSBlbHNlIGlmICh0aGlzLm1vZGUub3V0cHV0ID09IFwicmF0aW9cIikgeyBcblx0XHRuZXd2YWx1ZSA9IHRoaXMucmF0aW8oaW5wdXQsb2N0YXZlKVxuXHR9IGVsc2UgaWYgKHRoaXMubW9kZS5vdXRwdXQgPT0gXCJNSURJXCIpIHsgXG5cdFx0bmV3dmFsdWUgPSB0aGlzLk1JREkoaW5wdXQsb2N0YXZlKVxuXHR9IGVsc2Uge1xuXHRcdG5ld3ZhbHVlID0gdGhpcy5mcmVxdWVuY3koaW5wdXQsb2N0YXZlKVxuXHR9XG5cblx0XG5cdHJldHVybiBuZXd2YWx1ZTtcblxufVxuXG5cbi8qIFJldHVybiBmcmVxIGRhdGEgKi9cblxuVHVuZS5wcm90b3R5cGUuZnJlcXVlbmN5ID0gZnVuY3Rpb24oc3RlcEluLCBvY3RhdmVJbikge1xuXG5cdGlmICh0aGlzLm1vZGUuaW5wdXQgPT0gXCJtaWRpXCIgfHwgdGhpcy5tb2RlLmlucHV0ID09IFwiTUlESVwiICkge1xuXHRcdHRoaXMuc3RlcEluICs9IDYwXG5cdH1cblx0XG5cdC8vIHdoYXQgb2N0YXZlIGlzIG91ciBpbnB1dFxuXHR2YXIgb2N0YXZlID0gTWF0aC5mbG9vcihzdGVwSW4vdGhpcy5zY2FsZS5sZW5ndGgpXG5cblx0aWYgKG9jdGF2ZUluKSB7IFxuXHRcdG9jdGF2ZSArPSBvY3RhdmVJblxuXHR9XG5cdFxuXHQvLyB3aGljaCBzY2FsZSBkZWdyZWUgKDAgLSBzY2FsZSBsZW5ndGgpIGlzIG91ciBpbnB1dFxuXHR2YXIgc2NhbGVEZWdyZWUgPSBzdGVwSW4gJSB0aGlzLnNjYWxlLmxlbmd0aFxuXG5cdHdoaWxlIChzY2FsZURlZ3JlZSA8IDApIHtcblx0XHRzY2FsZURlZ3JlZSArPSB0aGlzLnNjYWxlLmxlbmd0aFxuXHR9XG5cdFxuXHR2YXIgZnJlcSA9IHRoaXMudG9uaWMqdGhpcy5zY2FsZVtzY2FsZURlZ3JlZV1cblx0XG5cdGZyZXEgPSBmcmVxKihNYXRoLnBvdygyLG9jdGF2ZSkpXG5cdFxuXHQvLyB0cnVuY2F0ZSBpcnJhdGlvbmFsIG51bWJlcnNcblx0ZnJlcSA9IE1hdGguZmxvb3IoZnJlcSoxMDAwMDAwMDAwMDApLzEwMDAwMDAwMDAwMFxuXHRcblx0cmV0dXJuIGZyZXFcblxufVxuXG4vKiBGb3JjZSByZXR1cm4gcmF0aW8gZGF0YSAqL1xuXG5UdW5lLnByb3RvdHlwZS5yYXRpbyA9IGZ1bmN0aW9uKHN0ZXBJbiwgb2N0YXZlSW4pIHtcblxuXHRpZiAodGhpcy5tb2RlLmlucHV0ID09IFwibWlkaVwiIHx8IHRoaXMubW9kZS5pbnB1dCA9PSBcIk1JRElcIiApIHtcblx0XHR0aGlzLnN0ZXBJbiArPSA2MFxuXHR9XG5cdFxuXHQvLyB3aGF0IG9jdGF2ZSBpcyBvdXIgaW5wdXRcblx0dmFyIG9jdGF2ZSA9IE1hdGguZmxvb3Ioc3RlcEluL3RoaXMuc2NhbGUubGVuZ3RoKVxuXG5cdGlmIChvY3RhdmVJbikgeyBcblx0XHRvY3RhdmUgKz0gb2N0YXZlSW5cblx0fVxuXHRcblx0Ly8gd2hpY2ggc2NhbGUgZGVncmVlICgwIC0gc2NhbGUgbGVuZ3RoKSBpcyBvdXIgaW5wdXRcblx0dmFyIHNjYWxlRGVncmVlID0gc3RlcEluICUgdGhpcy5zY2FsZS5sZW5ndGhcblxuXHQvLyB3aGF0IHJhdGlvIGlzIG91ciBpbnB1dCB0byBvdXIga2V5XG5cdHZhciByYXRpbyA9IE1hdGgucG93KDIsb2N0YXZlKSp0aGlzLnNjYWxlW3NjYWxlRGVncmVlXVxuXG5cdHJhdGlvID0gTWF0aC5mbG9vcihyYXRpbyoxMDAwMDAwMDAwMDApLzEwMDAwMDAwMDAwMFxuXG5cdHJldHVybiByYXRpb1xuXG59XG5cbi8qIEZvcmNlIHJldHVybiBhZGp1c3RlZCBNSURJIGRhdGEgKi9cblxuVHVuZS5wcm90b3R5cGUuTUlESSA9IGZ1bmN0aW9uKHN0ZXBJbixvY3RhdmVJbikge1xuXG5cdHZhciBuZXd2YWx1ZSA9IHRoaXMuZnJlcXVlbmN5KHN0ZXBJbixvY3RhdmVJbilcblxuXHR2YXIgbiA9IDY5ICsgMTIqTWF0aC5sb2cobmV3dmFsdWUvNDQwKS9NYXRoLmxvZygyKVxuXG5cdG4gPSBNYXRoLmZsb29yKG4qMTAwMDAwMDAwMCkvMTAwMDAwMDAwMFxuXG5cdHJldHVybiBuXG5cbn1cblxuLyogTG9hZCBhIG5ldyBzY2FsZSAqL1xuXG5UdW5lLnByb3RvdHlwZS5sb2FkU2NhbGUgPSBmdW5jdGlvbihuYW1lKXtcblxuXHQvKiBsb2FkIHRoZSBzY2FsZSAqL1xuXHR2YXIgZnJlcXMgPSB0aGlzLlR1bmluZ0xpc3RbbmFtZV0uZnJlcXVlbmNpZXNcblx0dGhpcy5zY2FsZSA9IFtdXG5cdGZvciAodmFyIGk9MDtpPGZyZXFzLmxlbmd0aC0xO2krKykge1xuXHRcdHRoaXMuc2NhbGUucHVzaChmcmVxc1tpXS9mcmVxc1swXSlcblx0fVxuXG5cdC8qIHZpc3VhbGl6ZSBpbiBjb25zb2xlICovXG5cdC8vY29uc29sZS5sb2coXCIgXCIpO1xuXHQvL2NvbnNvbGUubG9nKFwiTE9BREVEIFwiK25hbWUpO1xuXHQvL2NvbnNvbGUubG9nKHRoaXMuVHVuaW5nTGlzdFtuYW1lXS5kZXNjcmlwdGlvbik7XG5cdC8vY29uc29sZS5sb2codGhpcy5zY2FsZSk7XG5cdC8vdmFyIHZpcyA9IFtdO1xuXHQvL2ZvciAodmFyIGk9MDtpPDEwMDtpKyspIHtcblx0Ly8gIHZpc1tpXSA9IFwiIFwiO1xuXHQvL31cblx0Ly9mb3IgKHZhciBpPTA7aTx0aGlzLnNjYWxlLmxlbmd0aDtpKyspIHtcblx0Ly8gIHZhciBzcG90ID0gTWF0aC5yb3VuZCh0aGlzLnNjYWxlW2ldICogMTAwIC0gMTAwKTtcblx0Ly8gIGlmIChpPDEwKSB7XG5cdC8vICAgIHZpcy5zcGxpY2Uoc3BvdCwxLGkrMSk7XG5cdC8vICB9IGVsc2Uge1xuXHQvLyAgICB2aXMuc3BsaWNlKHNwb3QsNSxpKzEpO1xuXHQvLyAgfVxuXHQvL31cblx0Ly92YXIgdGV4dHZpcyA9IFwiXCI7XG5cdC8vZm9yICh2YXIgaT0wO2k8dmlzLmxlbmd0aDtpKyspIHtcblx0Ly8gIHRleHR2aXMgKz0gdmlzW2ldO1xuXHQvL31cblx0Ly9jb25zb2xlLmxvZyhuYW1lKVxuXHQvL2NvbnNvbGUubG9nKHRleHR2aXMpXG5cdC8vLy8gRVQgc2NhbGUgdmlzXG5cdC8vdmFyIHZpcyA9IFtdO1xuXHQvL2ZvciAodmFyIGk9MDtpPDEwMDtpKyspIHtcblx0Ly8gIHZpc1tpXSA9IFwiIFwiO1xuXHQvL31cblx0Ly9mb3IgKHZhciBpPTA7aTx0aGlzLmV0bWFqb3IubGVuZ3RoO2krKykge1xuXHQvLyAgdmFyIHNwb3QgPSBNYXRoLnJvdW5kKHRoaXMuZXRtYWpvcltpXS90aGlzLmV0bWFqb3JbMF0gKiAxMDAgLSAxMDApO1xuXHQvLyAgaWYgKGk8MTApIHtcblx0Ly8gICAgdmlzLnNwbGljZShzcG90LDEsaSsxKTtcblx0Ly8gIH0gZWxzZSB7XG5cdC8vICAgIHZpcy5zcGxpY2Uoc3BvdCw1LGkrMSk7XG5cdC8vICB9XG5cdFx0XG5cdC8vfVxuXHQvL3ZhciB0ZXh0dmlzID0gXCJcIjtcblx0Ly9mb3IgKHZhciBpPTA7aTx2aXMubGVuZ3RoO2krKykge1xuXHQvLyAgdGV4dHZpcyArPSB2aXNbaV07XG5cdC8vfVxuXHQvL2NvbnNvbGUubG9nKHRleHR2aXMpXG5cdC8vY29uc29sZS5sb2coXCJlcXVhbC10ZW1wZXJlZCBtYWpvciAocmVmZXJlbmNlKVwiKVxufVxuXG4vKiBTZWFyY2ggdGhlIG5hbWVzIG9mIHR1bmluZ3Ncblx0IFJldHVybnMgYW4gYXJyYXkgb2YgbmFtZXMgb2YgdHVuaW5ncyAqL1xuXG5UdW5lLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihsZXR0ZXJzKSB7XG5cdHZhciBwb3NzaWJsZSA9IFtdXG5cdGZvciAodmFyIGtleSBpbiB0aGlzLlR1bmluZ0xpc3QpIHtcblx0XHRpZiAoa2V5LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsZXR0ZXJzLnRvTG93ZXJDYXNlKCkpIT0tMSkge1xuXHRcdFx0cG9zc2libGUucHVzaChrZXkpXG5cdFx0fVxuXHR9XG5cdHJldHVybiBwb3NzaWJsZVxufVxuXG4vKiBSZXR1cm4gYSBjb2xsZWN0aW9uIG9mIG5vdGVzIGFzIGFuIGFycmF5ICovXG5cblR1bmUucHJvdG90eXBlLmNob3JkID0gZnVuY3Rpb24obWlkaXMpIHtcblx0dmFyIG91dHB1dCA9IFtdXG5cdGZvciAodmFyIGk9MDtpPG1pZGlzLmxlbmd0aDtpKyspIHtcblx0XHRvdXRwdXQucHVzaCh0aGlzLm5vdGUobWlkaXNbaV0pKVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cblxuLyogQ2hhbmdlIHRoZSB0b25pYyBmcmVxdWVuY3k/ICovXG5cblR1bmUucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbihuZXdtaWRpLCBuZXdmcmVxKSB7XG5cdHRoaXMucm9vdEZyZXEgPSBuZXdmcmVxXG5cdC8vIG5vdCB3b3JraW5nIG5vdyAuLi4gbmVlZHMgbXVjaCB3b3JrLlxuXHQvLyBzZXRLZXkgaXMgbm90IHRyYW5zcG9zaW5nIG5vdywgZWl0aGVyLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR1bmVcbiIsImNvbnN0IEdpYmJlcmlzaCA9IHJlcXVpcmUoICdnaWJiZXJpc2gtZHNwJyApXG5jb25zdCBVZ2VuICAgICAgPSByZXF1aXJlKCAnLi91Z2VuLmpzJyApXG5cbmNvbnN0IGZpbHRlck5hbWVzID0gW1xuICBcIm5vbmVcIiwgXCJGaWx0ZXIyNE1vb2dcIiwgXCJGaWx0ZXIyNFRCMzAzXCIsIFwiRmlsdGVyMTJTVkZcIiwgXCJGaWx0ZXIxMkJpcXVhZFwiLCBcIkZpbHRlcjI0Q2xhc3NpY1wiXG5dXG5cbmNvbnN0IEZpbHRlcnMgPSB7XG4gIGNyZWF0ZSggQXVkaW8gKSB7XG4gICAgY29uc3QgZmlsdGVycyA9IHt9XG5cbiAgICBmb3IoIGxldCBmaWx0ZXJOYW1lIGluIEdpYmJlcmlzaC5maWx0ZXJzICkge1xuICAgICAgY29uc3QgZ2liYmVyaXNoQ29uc3RydWN0b3IgPSBHaWJiZXJpc2guZmlsdGVyc1sgZmlsdGVyTmFtZSBdXG5cbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBGaWx0ZXJzLmRlc2NyaXB0aW9uc1sgZmlsdGVyTmFtZSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogRmlsdGVycy5kZXNjcmlwdGlvbnNbIGZpbHRlck5hbWUgXS5tZXRob2RzXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHsgXG4gICAgICAgIHByb3BlcnRpZXM6Z2liYmVyaXNoQ29uc3RydWN0b3IuZGVmYXVsdHMgfHwge30sIFxuICAgICAgICBtZXRob2RzOm1ldGhvZHMsXG4gICAgICAgIG5hbWU6ZmlsdGVyTmFtZSxcbiAgICAgICAgY2F0ZWdvcnk6J2VmZmVjdHMnXG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbi5fX2RlZmF1bHRzX18gPSB7IGlzU3RlcmVvIDogdHJ1ZSB9XG4gICAgICBkZXNjcmlwdGlvbi5wcm9wZXJ0aWVzLmlzU3RlcmVvID0gdHJ1ZVxuICAgICAgZGVzY3JpcHRpb24ucHJvcGVydGllcy50eXBlID0gJ2Z4J1xuXG4gICAgICBmaWx0ZXJzWyBmaWx0ZXJOYW1lIF0gPSBVZ2VuKCBnaWJiZXJpc2hDb25zdHJ1Y3RvciwgZGVzY3JpcHRpb24sIEF1ZGlvLCBmYWxzZSApXG4gICAgfVxuXG4gICAgZmlsdGVycy5MUEYgPSBmaWx0ZXJzLkZpbHRlcjI0TW9vZ1xuXG4gICAgZmlsdGVycy5GaWx0ZXIgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG4gICAgICBpZiggcHJvcHMgPT09IHVuZGVmaW5lZCApIHByb3BzID0geyBtb2RlbDogMSB9XG4gICAgICBpZiggcHJvcHMubW9kZWwgPT09IHVuZGVmaW5lZCApIHByb3BzLm1vZGVsID0gMVxuXG4gICAgICBjb25zdCBuYW1lID0gZmlsdGVyTmFtZXNbIHByb3BzLm1vZGVsIF1cblxuICAgICAgZGVsZXRlIHByb3BzLm1vZGVsXG5cbiAgICAgIHJldHVybiBmaWx0ZXJzWyBuYW1lIF0oIHByb3BzICkgXG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgcHJvcGVydGllczogT2JqZWN0LmFzc2lnbigge30sIEdpYmJlcmlzaC5maWx0ZXJzWyAnRmlsdGVyMTJCaXF1YWQnIF0uZGVmYXVsdHMsIHsgbW9kZToxIH0gKSxcbiAgICAgIG1ldGhvZHM6bnVsbCxcbiAgICAgIG5hbWU6J0hQRicsXG4gICAgICBjYXRlZ29yeTonZWZmZWN0cycsXG4gICAgICBfX2RlZmF1bHRzX186IHsgbW9kZToxIH1cbiAgICB9XG4gICBcbiAgICBmaWx0ZXJzLkhQRiA9IFVnZW4oIEdpYmJlcmlzaC5maWx0ZXJzWyAnRmlsdGVyMTJCaXF1YWQnIF0sIGRlc2NyaXB0aW9uLCBBdWRpbywgZmFsc2UgKVxuXG4gICAgcmV0dXJuIGZpbHRlcnNcbiAgfSxcblxuICBkZXNjcmlwdGlvbnM6IHtcbiAgICAvL0Nob3J1czp7IG1ldGhvZHM6W10gfSxcbiAgfSxcbiAgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyc1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggQXVkaW8gKSB7XG4gIGNvbnN0IHRva2VuID0gJzZhMDBmODBiYTAyYjI3NTVhMDQ0Y2M0ZWYwMDRmZWJmYzRjY2Q0NzYnXG5cbiAgY29uc3QgRnJlZXNvdW5kID0gZnVuY3Rpb24oIHF1ZXJ5LCBvcHRpb25zICkge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBjb3VudDoxLCBtYXhWb2ljZXM6MSwgcGFuVm9pY2VzOnRydWUgfSwgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyA/IHF1ZXJ5IDogb3B0aW9ucyApXG4gICAgY29uc3Qgc2FtcGxlciA9IEF1ZGlvLmluc3RydW1lbnRzLk11bHRpc2FtcGxlciggcHJvcHMgKVxuICAgIHNldFRpbWVvdXQoICgpPT5xdWVyaWVzWyB0eXBlb2YgcXVlcnkgXSggcXVlcnksIHNhbXBsZXIsIHByb3BzLmNvdW50ICksIDAgKVxuIFxuICAgIHJldHVybiBzYW1wbGVyXG4gIH1cblxuICBGcmVlc291bmQubG9hZGVkID0ge31cbiAgRnJlZXNvdW5kLnF1ZXJpZXMgPSB7fVxuXG4gIEZyZWVzb3VuZC5kZWZhdWx0cyA9IHtcbiAgICBzb3J0OiAnZG93bmxvYWRzJyxcbiAgICBzaW5nbGU6dHJ1ZSxcbiAgICBmaWxlbmFtZTpmYWxzZSxcbiAgICBtaW46IDAsXG4gICAgbWF4OiAuNSxcbiAgICByZXZlcnNlOmZhbHNlLFxuICAgIGNvdW50OjE1XG4gIH1cblxuICAvLyBhZGQgRnJlZXNvdW5kWzVdIG5vdGF0aW9uLi4uXG4gIGZvciggbGV0IGkgPSAwOyBpIDwgMjA7IGkrKyApIHtcbiAgICBGcmVlc291bmRbIGkgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgaWYoIGFyZ3MubGVuZ3RoID4gMCApIHtcbiAgICAgICAgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICBpZiggYXJncy5sZW5ndGggPiAxICkge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5tYXhWb2ljZXMgPSBpIHx8IDFcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBhcmdzWzFdID0geyBtYXhWb2ljZXM6aSB8fCAxIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgYXJnc1swXS5tYXhWb2ljZXMgPSBpIHx8IDFcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGFyZ3NbMF0gPSB7IG1heFZvaWNlczppIHx8IDEgfVxuICAgICAgfSBcblxuICAgICAgcmV0dXJuIEZyZWVzb3VuZCggLi4uYXJncyApIFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHF1ZXJpZXMgPSB7XG4gICAgbnVtYmVyKCBpZCwgc2FtcGxlciwgbnVtPTAgKSB7XG4gICAgICBpZiAodHlwZW9mIEZyZWVzb3VuZC5sb2FkZWRbIGlkIF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZldGNoKCBgaHR0cHM6Ly9mcmVlc291bmQub3JnL2FwaXYyL3NvdW5kcy8ke2lkfS8/JmZvcm1hdD1qc29uJnRva2VuPSR7dG9rZW59YCApXG4gICAgICAgICAgLnRoZW4oIHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSApXG4gICAgICAgICAgLnRoZW4oIGpzb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGpzb24ucHJldmlld3NbICdwcmV2aWV3LWhxLW1wMycgXVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzYW1wbGVyLmxvYWRTYW1wbGUoIHBhdGggKVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ2xvYWRpbmc6JywgcGF0aCApXG4gICAgICAgICAgfSkgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYoIEF1ZGlvLkdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgICAgc2FtcGxlci5zYW1wbGVyc1sgbnVtIF0ubG9hZEJ1ZmZlciggRnJlZXNvdW5kLmxvYWRlZFsgaWQgXSApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gc2VhcmNoIGZvciB0ZXh0IHF1ZXJ5LCBhbmQgdGhlbiB1c2UgcmV0dXJuZWQgaWQgdG8gXG4gICAgLy8gZmV0Y2ggYnkgbnVtYmVyIFxuICAgIHN0cmluZyggcXVlcnksIHNhbXBsZXIsIGNvdW50LCBvcmlnaW5hbFF1ZXJ5ICkge1xuICAgICAgc2FtcGxlci5sZW5ndGggPSBjb3VudFxuICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0naHR0cHM6Ly9mcmVlc291bmQub3JnL2FwaXYyL3NlYXJjaC90ZXh0Lz8nXG5cbiAgICAgIGNvbnNvbGUuZ3JvdXAoJ1F1ZXJ5aW5nIEZyZWVzb3VuZCBmb3I6ICcgKyBvcmlnaW5hbFF1ZXJ5IHx8IHF1ZXJ5IClcbiAgICAgIGlmKCBxdWVyeS5pbmRleE9mKCAncXVlcnknICkgPiAtMSApIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgKz0gcXVlcnlcbiAgICAgICAgcXVlcnlTdHJpbmcgKz0gYCZ0b2tlbj0ke3Rva2VufSZmaWVsZHM9bmFtZSxpZCxwcmV2aWV3cyx1c2VybmFtZSxsaWNlbnNlJnBhZ2Vfc2l6ZT0ke2NvdW50fSBgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgcXVlcnlTdHJpbmcgKz0gYHF1ZXJ5PSR7cXVlcnl9JnRva2VuPSR7dG9rZW59JmZpZWxkcz1uYW1lLGlkLHByZXZpZXdzLHVzZXJuYW1lLGxpY2Vuc2UmZmlsdGVyPW9yaWdpbmFsX2ZpbGVuYW1lOiR7cXVlcnkuc3BsaXQoJyAnKVswXX0gYWNfc2luZ2xlX2V2ZW50OnRydWUmc29ydD1kb3dubG9hZHNfZGVzYyZwYWdlX3NpemU9JHtjb3VudH1gXG5cbiAgICAgIH1cblxuICAgICAgZmV0Y2goIHF1ZXJ5U3RyaW5nIClcbiAgICAgICAgLnRoZW4oIGRhdGEgPT4gZGF0YS5qc29uKCkgKVxuICAgICAgICAudGhlbiggc291bmRzID0+IHtcbiAgICAgICAgICBpZiggc291bmRzLnJlc3VsdHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGlmKCBzb3VuZHMucmVzdWx0cy5sZW5ndGggPiBjb3VudCApIHNvdW5kcy5yZXN1bHRzID0gc291bmRzLnJlc3VsdHMuc2xpY2UoMCxjb3VudClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAlYyR7c291bmRzLnJlc3VsdHMubGVuZ3RofSBzb3VuZHMgZm91bmQuIFN0YXJ0aW5nIGRvd25sb2FkczpgLCBgYmFja2dyb3VuZDpibGFjaztjb2xvcjp3aGl0ZWApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJWNObyBzb3VuZHMgd2VyZSBmb3VuZCBmb3IgdGhpcyBxdWVyeSFgLCBgYmFja2dyb3VuZDpyZWQ7Y29sb3I6d2hpdGVgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzYW1wbGVyLmxlbmd0aCA9IGNvdW50IDwgc291bmRzLnJlc3VsdHMubGVuZ3RoID8gY291bnQgOiBzb3VuZHMucmVzdWx0cy5sZW5ndGhcbiAgICAgICAgICBjb25zb2xlLnRhYmxlKCBzb3VuZHMucmVzdWx0cy5tYXAoIHI9Pih7ZmlsZTpyLm5hbWUsYXV0aG9yOnIudXNlcm5hbWUsbGljZW5zZTonQ0MvJytyLmxpY2Vuc2Uuc3BsaXQoJy8nKS5zbGljZSg0KS5qb2luKCcvJyl9KSApIClcbiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHNhbXBsZXIubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzb3VuZHMucmVzdWx0c1tpXVxuICAgICAgICAgICAgaWYoIHJlc3VsdCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlc3VsdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IHJlc3VsdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gcmVzdWx0LnByZXZpZXdzWyAncHJldmlldy1ocS1tcDMnIF0gXG5cbiAgICAgICAgICAgICAgaWYoIEZyZWVzb3VuZC5sb2FkZWRbIHVybCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggYCVjJHtmaWxlbmFtZX1gLCBgY29sb3I6d2hpdGU7YmFja2dyb3VuZDojMzMzMzMzO2AgKVxuXG4gICAgICAgICAgICAgICAgc2FtcGxlci5sb2FkU2FtcGxlKCB1cmwsIChfX3NhbXBsZXIsYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBGcmVlc291bmQubG9hZGVkWyB1cmwgXSA9IGJ1ZmZlci5kYXRhLmJ1ZmZlclxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy8gWFhYIG1lbW9pbmcgdGhlIGZpbGVzIGNhdXNlcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3JldXNpbmcgZnJlZXNvdW5kIGZpbGU6JywgZmlsZW5hbWUgKVxuICAgICAgICAgICAgICAgICAgc2FtcGxlci5sb2FkU2FtcGxlKCB1cmwsIG51bGwsIEZyZWVzb3VuZC5sb2FkZWRbIHVybCBdIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIG9iamVjdCggcXVlcnlPYmosIHNhbXBsZXIgKSB7XG4gICAgICBjb25zdCBxID0gT2JqZWN0LmFzc2lnbigge30sIEZyZWVzb3VuZC5kZWZhdWx0cywgcXVlcnlPYmogKVxuIFxuICAgICAgbGV0IHF1ZXJ5ID0gYHF1ZXJ5PSR7cS5xdWVyeX0mZm9ybWF0PWpzb25gXG4gIFxuICAgICAgcXVlcnkgKz0gYCZmaWx0ZXI9ZHVyYXRpb246WyR7cS5taW59IFRPICR7cS5tYXh9XWBcbiAgICAgIGlmKCBxLnNpbmdsZSApIHF1ZXJ5ICs9IGAgYWNfc2luZ2xlX2V2ZW50OnRydWVgXG4gICAgICBpZiggcS5maWxlbmFtZSApIHF1ZXJ5ICs9IGAgb3JpZ2luYWxfZmlsZW5hbWU6JHtxLnF1ZXJ5fWBcblxuICAgICAgbGV0IHNvcnQgPSBxLnNvcnRcblxuICAgICAgLy8gdXNlciBlcnJvciBjaGVja1xuICAgICAgaWYoIHNvcnQgPT09ICdyYXRpbmdzJyApIHNvcnQgPSAncmF0aW5nJ1xuXG4gICAgICBzb3J0ICs9IHEucmV2ZXJzZSA/ICdfYXNjJyA6ICdfZGVzYydcblxuICAgICAgcXVlcnkgKz0gYCZzb3J0PSR7c29ydH1gXG5cbiAgICAgIHF1ZXJpZXMuc3RyaW5nKCBxdWVyeSwgc2FtcGxlciwgcS5jb3VudCwgcS5xdWVyeSApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEZyZWVzb3VuZFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggQXVkaW8gKSB7XG4gIFxuY29uc3QgYmlub3BzID0gWyBcbiAgJ21pbicsJ21heCcsJ2FkZCcsJ3N1YicsJ211bCcsJ2RpdicsJ3JkaXYnLCdtb2QnLFxuICAnYW5kJywnb3InLCdndCcsJ2VxJywnZXFwJywnZ3RlJywnZ3RlcCcsJ2d0cCcsJ2x0JywnbHRlJywnbHRlcCcsJ2x0cCcsJ25lcScsXG4gICdzdGVwJyBcbl1cblxuY29uc3QgbW9ub3BzID0gW1xuICAnYWJzJywnYWNvcycsJ2Fjb3NoJywnYXNpbicsJ2FzaW5oJywnYXRhbicsJ2F0YW4yJywnYXRhbmgnLCdjb3MnLCdjb3NoJyxcbiAgJ3NpbicsJ3NpbmgnLCd0YW4nLCd0YW5oJywgJ2Zsb29yJyxcbiAgJ2NlaWwnLCAncm91bmQnLCAnc2lnbicsICd0cnVuYycsICdmcmFjdCcsICdwYXJhbScsICdpbicsXG5dXG5cbmNvbnN0IG5vb3BzID0gW1xuICAnbm9pc2UnXG5dXG5cbmNvbnN0IEdlbiAgPSB7XG4gIGxhc3RDb25uZWN0ZWQ6W10sXG4gIG5hbWVzOltdLFxuICBjb25uZWN0ZWQ6IFtdLFxuXG4gIGlzR2VuOnRydWUsXG4gIGRlYnVnOmZhbHNlLFxuXG4gIHdhdmV0YWJsZSggZnJlcXVlbmN5LCBwcm9wcyApIHtcbiAgICBjb25zdCBnID0gQXVkaW8uR2liYmVyaXNoLmdlbmlzaCBcbiAgICBsZXQgZGF0YVByb3BzID0geyBpbW11dGFibGU6dHJ1ZSB9XG5cbiAgICAvLyB1c2UgZ2xvYmFsIHJlZmVyZW5jZXMgaWYgYXBwbGljYWJsZVxuICAgIGlmKCBwcm9wcy5uYW1lICE9PSB1bmRlZmluZWQgKSBkYXRhUHJvcHMuZ2xvYmFsID0gcHJvcHMubmFtZVxuXG4gICAgY29uc3QgYnVmZmVyID0gR2VuLnVnZW5zLmRhdGEoIHByb3BzLmJ1ZmZlciwgMSwgZGF0YVByb3BzIClcblxuICAgIHJldHVybiBHZW4udWdlbnMucGVlayggYnVmZmVyLCBHZW4udWdlbnMucGhhc29yKCBmcmVxdWVuY3ksIDAsIHsgbWluOjAgfSApIClcbiAgfSxcblxuICBpbml0KCkge1xuICAgIEdlbi51Z2Vucy53YXZldGFibGUgPSBHZW4uX193YXZldGFibGVcbiAgICBHZW4uY3JlYXRlQmlub3BGdW5jdGlvbnMoKVxuICAgIEdlbi5jcmVhdGVNb25vcEZ1bmN0aW9ucygpXG5cbiAgICBHZW4ubmFtZXMucHVzaCggLi4uYmlub3BzIClcbiAgICBHZW4ubmFtZXMucHVzaCggLi4ubW9ub3BzIClcbiAgICBHZW4ubmFtZXMucHVzaCggLi4uT2JqZWN0LmtleXMoIEdlbi5jb25zdGFudHMgKSApXG4gICAgR2VuLm5hbWVzLnB1c2goIC4uLk9iamVjdC5rZXlzKCBHZW4uZnVuY3Rpb25zICkgKVxuICAgIC8vR2VuLm5hbWVzLnB1c2goIC4uLk9iamVjdC5rZXlzKCBHZW4uY29tcG9zaXRlcyApIClcbiAgICBHZW4ubmFtZXMucHVzaCggJ2dlbicgKVxuICAgIEdlbi5uYW1lcy5wdXNoKCAnbGZvJyApXG4gICAgR2VuLm5hbWVzLnB1c2goICdzaW5lJyApXG4gICAgR2VuLm5hbWVzLnB1c2goICdzcXVhcmUnIClcbiAgICBHZW4ubmFtZXMucHVzaCggJ3RyaScgKVxuICAgIEdlbi5uYW1lcy5wdXNoKCAnc2F3JyApXG5cbiAgICAvL0dpYmJlci5zdWJzY3JpYmUoICdjbGVhcicsICgpPT4gR2VuLmxhc3RDb25uZWN0ZWQubGVuZ3RoID0gMCApXG4gIH0sXG5cbiAgLy8gaWYgcHJvcGVydHkgaXMgIT09IHVnZW4gKGl0J3MgYSBudW1iZXIpIGEgUGFyYW0gbXVzdCBiZSBtYWRlIHVzaW5nIGEgZGVmYXVsdFxuICBjcmVhdGUoIG5hbWUgKSB7XG4gICAgLy8gcmF0ZSBuZWVkcyBjdXN0b20gZnVuY3Rpb24gdG8gc2tpcCBzZXF1ZW5jaW5nIGlucHV0IGFuZCBvbmx5IHNlcXVlbmNlIHJhdGUgYWRqdXN0bWVudFxuXG4gICAgY29uc3QgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApXG5cbiAgICBpZiggbmFtZSA9PT0gJ3JhdGUnICkgcmV0dXJuIEdlbi5jcmVhdGVSYXRlKCBuYW1lLCAuLi5wYXJhbXMgKVxuXG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZSggdGhpcyApXG4gICAgbGV0IGNvdW50ID0gMFxuICAgIFxuICAgIG9iai5uYW1lID0gbmFtZVxuICAgIG9iai5hY3RpdmUgPSBmYWxzZVxuICAgIFxuICAgIGZvciggbGV0IGtleSBvZiBHZW4uZnVuY3Rpb25zWyBuYW1lIF0ucHJvcGVydGllcyApIHsgXG4gICAgICBsZXQgdmFsdWUgPSBwYXJhbXNbIGNvdW50KysgXSB8fCAwXG4gICAgICBvYmpbIGtleSBdID0gdiA9PiB7XG4gICAgICAgIGlmKCB2ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICAgIGlmKCBvYmouYWN0aXZlICkge1xuICAgICAgICAgICAgaWYoIG9iai5fX2NsaWVudCA9PT0gJ2xpdmUnICkge1xuICAgICAgICAgICAgICBHaWJiZXIuQ29tbXVuaWNhdGlvbi5zZW5kKCBgZ2VucCAke29iai5wYXJhbUlEfSAke29ialsga2V5IF0udWlkfSAke3Z9YCApIFxuICAgICAgICAgICAgfWVsc2UgaWYoIG9iai5fX2NsaWVudCA9PT0gJ21heCcgKSB7XG4gICAgICAgICAgICAgIEdpYmJlci5Db21tdW5pY2F0aW9uLnNlbmQoIGBzaWcgJHtvYmoucGFyYW1JRH0gcGFyYW0gJHtvYmpbIGtleSBdLnVpZH0gJHt2fWAsICdtYXgnICkgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmpbIGtleSBdLnVpZCA9IEdlbi5nZXRVSUQoKVxuIFxuICAgICAgLy8gWFhYIEdpYmJlci5hZGRTZXF1ZW5jaW5nVG9NZXRob2QoIG9iaiwga2V5IClcbiAgICB9XG5cbiAgICAvLyBhY2NvbW9kYXRlIG5vbi1hdWRpby1yYXRlIG9wdGlvbnMuIGR1cmluZyBjb2RlZ2VuIHRoZSBjb21waWxlclxuICAgIC8vIHdpbGwgY2hlY2sgZm9yIHRoZSBvcHRpb25zIHByb3BlcnR5OyBpZiBpdCBleGlzdHMgaXQgd2lsbCB3cml0ZVxuICAgIC8vIHRoZSBvcHRpb25zIGludG8gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgIGlmKCBwYXJhbXMubGVuZ3RoID4gR2VuLmZ1bmN0aW9uc1sgbmFtZSBdLnByb3BlcnRpZXMubGVuZ3RoICkge1xuICAgICAgb2JqLm9wdGlvbnMgPSBwYXJhbXNbIEdlbi5mdW5jdGlvbnNbIG5hbWUgXS5wcm9wZXJ0aWVzLmxlbmd0aCBdXG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialxuICB9LFxuXG4gIGNyZWF0ZVJhdGUoIG5hbWUgKSB7XG4gICAgbGV0IG9iaiA9IE9iamVjdC5jcmVhdGUoIHRoaXMgKSxcbiAgICAgICAgY291bnQgPSAwLFxuICAgICAgICBwYXJhbSA9IGFyZ3VtZW50c1sxXSBcbiAgICBcbiAgICBvYmoubmFtZSA9ICdyYXRlJyBcbiAgICBvYmouYWN0aXZlID0gZmFsc2VcbiAgICBcbiAgICBsZXQgdmFsdWUgPSBwYXJhbVxuICAgIC8vY29uc29sZS5sb2coICd2YWx1ZTonLCB2YWx1ZSwgJ2FyZ3M6JywgYXJndW1lbnRzIClcbiAgICBvYmpbIDAgXSA9IHYgPT4ge1xuICAgICAgaWYoIHYgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgIGlmKCBvYmouYWN0aXZlICkge1xuICAgICAgICAgIEdpYmJlci5Db21tdW5pY2F0aW9uLnNlbmQoIGBnZW5wICR7b2JqLnBhcmFtSUR9ICR7b2JqWyAwIF0udWlkfSAke3Z9YCApIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VuLmdldFVJRCgpIC8vIGxlYXZlIDAgYmVoaW5kLi4uXG4gICAgb2JqWyAwIF0udWlkID0gR2VuLmdldFVJRCgpXG5cbiAgICBHaWJiZXIuYWRkU2VxdWVuY2luZ1RvTWV0aG9kKCBvYmosICcwJyApXG5cbiAgICByZXR1cm4gb2JqXG4gIH0sXG4gXG4gIGNyZWF0ZUJpbm9wRnVuY3Rpb25zKCkge1xuICAgIGZvciggbGV0IGtleSBvZiBiaW5vcHMgKSB7XG4gICAgICBHZW4uZnVuY3Rpb25zWyBrZXkgXSA9IHtcbiAgICAgICAgcHJvcGVydGllczpbJzAnLCcxJ10sIHN0cjprZXlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlTW9ub3BGdW5jdGlvbnMoKSB7XG4gICAgZm9yKCBsZXQga2V5IG9mIG1vbm9wcyApIHtcbiAgICAgIEdlbi5mdW5jdGlvbnNbIGtleSBdID0ge1xuICAgICAgICBwcm9wZXJ0aWVzOlsnMCddLCBzdHI6a2V5XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFzc2lnblRyYWNrQW5kUGFyYW1JRDogZnVuY3Rpb24oIHRyYWNrLCBpZCApIHtcbiAgICB0aGlzLnBhcmFtSUQgPSBpZFxuICAgIHRoaXMudHJhY2sgPSB0cmFja1xuXG4gICAgbGV0IGNvdW50ID0gMCwgcGFyYW1cbiAgICB3aGlsZSggcGFyYW0gPSB0aGlzWyBjb3VudCsrIF0gKSB7XG4gICAgICBpZiggdHlwZW9mIHBhcmFtKCkgPT09ICdvYmplY3QnICkge1xuICAgICAgICBwYXJhbSgpLmFzc2lnblRyYWNrQW5kUGFyYW1JRCggdHJhY2ssIGlkIClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2xlYXIoKSB7XG4gICAgZm9yKCBsZXQgdWdlbiBvZiBHZW4uY29ubmVjdGVkICkge1xuICAgICAgR2liYmVyLkNvbW11bmljYXRpb24uc2VuZCggYHVuZ2VuICR7dWdlbi5wYXJhbUlEfWAgKVxuICAgIH1cblxuICAgIEdlbi5jb25uZWN0ZWQubGVuZ3RoID0gMFxuICB9LFxuXG4gIGNvbnN0YW50czoge1xuICAgIGRlZ3RvcmFkOiBNYXRoLlBJIC8gMTgwLFxuICAgIEUgOiAgICAgICBNYXRoLkUsXG4gICAgaGFsZnBpOiAgIE1hdGguUEkgLyAyLFxuICAgIGludnBpIDogICBNYXRoLlBJICogLSAxLFxuICAgIGxuMTAgIDogICBNYXRoLkxOMTAsXG4gICAgbG4yICAgOiAgIE1hdGguTE4yLFxuICAgIGxvZzEwZTogICBNYXRoLkxPRzEwRSxcbiAgICBsb2cyZSA6ICAgTWF0aC5MT0cyRSxcbiAgICBwaSAgICA6ICAgTWF0aC5QSSwgIFxuICAgIHNxcnQyIDogICBNYXRoLlNRUlQyLFxuICAgIHNxcnQxXzI6ICBNYXRoLlNRUlQxXzIsXG4gICAgdHdvcGkgOiAgIE1hdGguUEkgKiAyLFxuICAgIHNhbXBsZXJhdGU6ICdzYW1wbGVyYXRlJ1xuICB9LFxuXG4gIGZ1bmN0aW9uczoge1xuICAgIHBoYXNvcjogeyBwcm9wZXJ0aWVzOlsgJzAnLCcxJyBdLCAgc3RyOidwaGFzb3InIH0sXG4gICAgY3ljbGU6ICB7IHByb3BlcnRpZXM6WyAnMCcgXSwgIHN0cjonY3ljbGUnIH0sXG4gICAgcGhhc29yTjp7IHByb3BlcnRpZXM6WyAnMCcsJzEnIF0sICBzdHI6J3BoYXNvck4nIH0sXG4gICAgY3ljbGVOOiB7IHByb3BlcnRpZXM6WyAnMCcgXSwgIHN0cjonY3ljbGVOJyB9LFxuICAgIHRyYWluOiAgeyBwcm9wZXJ0aWVzOlsgJzAnLCcxJyBdLCAgc3RyOid0cmFpbicgfSxcbiAgICByYXRlOiAgIHsgcHJvcGVydGllczpbICcwJyBdLCBzdHI6J3JhdGUnIH0sXG4gICAgbm9pc2U6ICB7IHByb3BlcnRpZXM6W10sIHN0cjonbm9pc2UnIH0sXG4gICAgYWNjdW06ICB7IHByb3BlcnRpZXM6WyAnMCcsJzEnIF0sIHN0cjonYWNjdW0nIH0sXG4gICAgY291bnRlcjp7IHByb3BlcnRpZXM6WyAnMCcsJzEnIF0sIHN0cjonY291bnRlcicgfSxcbiAgICBzY2FsZTogIHsgcHJvcGVydGllczogWycwJywgJzEnLCAnMicsICczJ10sIHN0cjonc2NhbGUnIH0sXG4gICAgc2FoOiAgICB7IHByb3BlcnRpZXM6IFsnMCcsICcxJywgJzInXSwgc3RyOidzYWgnIH0sXG4gICAgY2xhbXA6ICB7IHByb3BlcnRpZXM6IFsnMCcsICcxJywgJzInXSwgc3RyOidjbGFtcCcgfSxcbiAgICB0ZXJuYXJ5OnsgcHJvcGVydGllczogWycwJywgJzEnLCAnMiddLCBzdHI6J3N3aXRjaCcgfSxcbiAgICBzZWxlY3Rvcjp7IHByb3BlcnRpZXM6IFsnMCcsICcxJywgJzInXSwgc3RyOidzZWxlY3RvcicgfSxcbiAgICBwZWVrOiAgIHsgcHJvcGVydGllczpbJzAnLCcxJ10sIHN0cjoncGVlaycgfSxcbiAgICBkYXRhOiAgIHsgcHJvcGVydGllczpbXSwgc3RyOidkYXRhJyB9XG4gIH0sXG5cbiAgX2NvdW50OiAwLFxuXG4gIGdldFVJRCgpIHtcbiAgICByZXR1cm4gJ3AnICsgR2VuLl9jb3VudCsrXG4gIH0sXG5cbiAgdGltZTogJ3RpbWUnLFxuXG4gIG91dCgpIHtcbiAgICBsZXQgcGFyYW1BcnJheSA9IFtdLFxuICAgICAgICBib2R5LCBvdXRcbiAgICBcbiAgICBib2R5ID0gdGhpcy5nZW4oIHBhcmFtQXJyYXkgKVxuXG4gICAgb3V0ID0gcGFyYW1BcnJheS5qb2luKCAnOycgKVxuXG4gICAgaWYoIHBhcmFtQXJyYXkubGVuZ3RoICkge1xuICAgICAgb3V0ICs9ICc7J1xuICAgIH1cbiAgICBcbiAgICBvdXQgKz0gJ291dDE9J1xuICAgIG91dCArPSBib2R5ICsgJzsnXG4gICAgXG4gICAgaWYoIEdlbi5kZWJ1ZyApIGNvbnNvbGUubG9nKCBvdXQgKVxuXG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG4gIGdlbk1heCggcGFyYW1BcnJheSApIHtcbiAgICBsZXQgZGVmID0gR2VuLmZ1bmN0aW9uc1sgdGhpcy5uYW1lIF0sXG4gICAgICAgIHN0ciA9IGRlZi5zdHIgKyAnKCcsXG4gICAgICAgIGNvdW50ID0gMFxuICAgIFxuICAgIC8vIHRlbGwgR2liYmVyIHRoYXQgdGhpcyBnZW4gb2JqZWN0IGlzIHBhcnQgb2YgYW4gYWN0aXZlIGdlbiBncmFwaFxuICAgIC8vIHNvIHRoYXQgY2hhbmdlcyB0byBpdCBhcmUgZm9yd2FyZGVkIHRvIG00bFxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZVxuXG4gICAgaWYoIHRoaXMubmFtZSA9PT0gJ3JhdGUnICkge1xuICAgICAgc3RyICs9ICdpbjEsICdcbiAgICAgIGxldCBwTmFtZSA9IHRoaXNbIDAgXS51aWRcbiAgICAgIHN0ciArPSBwTmFtZVxuICAgICAgcGFyYW1BcnJheS5wdXNoKCBgUGFyYW0gJHtwTmFtZX0oJHt0aGlzWzBdKCl9KWAgKVxuICAgIH1lbHNle1xuICAgICAgZm9yKCBsZXQgcHJvcGVydHkgb2YgZGVmLnByb3BlcnRpZXMgKSB7XG4gICAgICAgIGxldCBwID0gdGhpc1sgcHJvcGVydHkgXSgpLFxuICAgICAgICAgICAgdWlkID0gdGhpc1sgcHJvcGVydHkgXS51aWRcbiAgICAgICAgXG4gICAgICAgIC8vY29uc29sZS5sb2coIHRoaXMubmFtZSwgcHJvcGVydHksIGRlZi5wcm9wZXJ0aWVzLCB1aWQgKVxuICAgICAgICBpZiggR2VuLmlzUHJvdG90eXBlT2YoIHAgKSApIHtcbiAgICAgICAgICBzdHIgKz0gcC5nZW4oIHBhcmFtQXJyYXkgKVxuICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIHAgPT09ICdudW1iZXInICkge1xuICAgICAgICAgIGxldCBwTmFtZSA9IHVpZFxuICAgICAgICAgIHN0ciArPSBwTmFtZVxuICAgICAgICAgIHBhcmFtQXJyYXkucHVzaCggYFBhcmFtICR7cE5hbWV9KCR7cH0pYCApXG4gICAgICAgIH1lbHNlIGlmKCBwID09PSBHZW4udGltZSApIHtcbiAgICAgICAgICBzdHIgKz0gcFxuICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIHAgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHN0ciArPSBwXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGNvbnNvbGUubG9nKCAnQ09ERUdFTiBFUlJPUjonLCBwIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBjb3VudCsrIDwgZGVmLnByb3BlcnRpZXMubGVuZ3RoIC0gMSApIHN0ciArPSAnLCdcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc3RyICs9ICcpJ1xuXG4gICAgcmV0dXJuIHN0clxuICB9LFxuXG4gIGdlbiggcGFyYW1BcnJheSApIHtcbiAgICBsZXQgZGVmID0gR2VuLmZ1bmN0aW9uc1sgdGhpcy5uYW1lIF0sXG4gICAgICAgIHN0ciA9IGBnLiR7ZGVmLnN0cn0oYCxcbiAgICAgICAgY291bnQgPSAwXG4gICAgXG4gICAgLy8gdGVsbCBHaWJiZXIgdGhhdCB0aGlzIGdlbiBvYmplY3QgaXMgcGFydCBvZiBhbiBhY3RpdmUgZ2VuIGdyYXBoXG4gICAgLy8gc28gdGhhdCBjaGFuZ2VzIHRvIGl0IGFyZSBmb3J3YXJkZWQgdG8gbTRsXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlXG5cbiAgICBmb3IoIGxldCBwcm9wZXJ0eSBvZiBkZWYucHJvcGVydGllcyApIHtcbiAgICAgIGxldCBwID0gdGhpc1sgcHJvcGVydHkgXSgpLFxuICAgICAgICAgIHVpZCA9IHRoaXNbIHByb3BlcnR5IF0udWlkXG4gICAgICBcbiAgICAgIC8vY29uc29sZS5sb2coIHRoaXMubmFtZSwgcHJvcGVydHksIGRlZi5wcm9wZXJ0aWVzLCB1aWQgKVxuICAgICAgaWYoIEdlbi5pc1Byb3RvdHlwZU9mKCBwICkgKSB7XG4gICAgICAgIHN0ciArPSBwLmdlbiggcGFyYW1BcnJheSApXG4gICAgICB9ZWxzZSBpZiggdHlwZW9mIHAgPT09ICdudW1iZXInICkge1xuICAgICAgICBsZXQgcE5hbWUgPSAncCcrcGFyYW1BcnJheS5sZW5ndGhcbiAgICAgICAgLy9zdHIgKz0gcE5hbWVcbiAgICAgICAgcGFyYW1BcnJheS5wdXNoKCBbYCR7cE5hbWV9YCwgcCBdIClcbiAgICAgICAgc3RyICs9IGBnLmluKCcke3BOYW1lfScpYFxuICAgICAgfWVsc2UgaWYoIHAgPT09IEdlbi50aW1lICkge1xuICAgICAgICBzdHIgKz0gcFxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiBwID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgc3RyICs9IHBcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLmxvZyggJ0NPREVHRU4gRVJST1I6JywgcCApXG4gICAgICB9XG5cbiAgICAgIGlmKCBjb3VudCsrIDwgZGVmLnByb3BlcnRpZXMubGVuZ3RoIC0gMSApIHN0ciArPSAnLCdcbiAgICB9XG5cbiAgICBpZiggdGhpcy5vcHRpb25zICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBzdHIgKz0gJywnICsgSlNPTi5zdHJpbmdpZnkoIHRoaXMub3B0aW9ucyApXG4gICAgfVxuICAgIFxuICAgIHN0ciArPSAnKSdcblxuICAgIHJldHVybiBzdHJcbiAgfSxcblxuICBjb21wb3NpdGVzOiB7IFxuICAgIHNpbmUoIGZyZXF1ZW5jeT0yLCBhbXA9NCwgY2VudGVyPTAsIHNob3VsZFJvdW5kPWZhbHNlICkge1xuICAgICAgcmV0dXJuIEdlbi5jb21wb3NpdGVzLmxmbyggJ3NpbmUnLCBmcmVxdWVuY3ksIGFtcCwgY2VudGVyLCBzaG91bGRSb3VuZCApXG4gICAgfSxcbiAgICBzaW5lciggZnJlcXVlbmN5PTIsIGFtcD00LCBjZW50ZXI9MCApIHtcbiAgICAgIHJldHVybiBHZW4uY29tcG9zaXRlcy5sZm8oICdzaW5lJywgZnJlcXVlbmN5LCBhbXAsIGNlbnRlciwgdHJ1ZSApXG4gICAgfSxcbiAgICBzcXVhcmUoIGZyZXF1ZW5jeT0yLCBhbXA9NCwgY2VudGVyPTAgKSB7XG4gICAgICByZXR1cm4gR2VuLmNvbXBvc2l0ZXMubGZvKCAnc3F1YXJlJywgZnJlcXVlbmN5LCBhbXAsIGNlbnRlciApXG4gICAgfSxcbiAgICBzYXcoIGZyZXF1ZW5jeT0yLCBhbXA9NCwgY2VudGVyPTAgKSB7XG4gICAgICByZXR1cm4gR2VuLmNvbXBvc2l0ZXMubGZvKCAnc2F3JywgZnJlcXVlbmN5LCBhbXAsIGNlbnRlciApXG4gICAgfSxcbiAgICB0cmkoIGZyZXF1ZW5jeT0yLCBhbXA9NCwgY2VudGVyPTAgKSB7XG4gICAgICByZXR1cm4gR2VuLmNvbXBvc2l0ZXMubGZvKCAndHJpJywgZnJlcXVlbmN5LCBhbXAsIGNlbnRlciApXG4gICAgfSxcbiAgICBsZm8oIHR5cGUgPSAnc2luZScsIGZyZXF1ZW5jeSA9IDIsIGFtcCA9IC41LCBjZW50ZXIgPSAuNSwgc2hvdWxkUm91bmQgPSBmYWxzZSApIHtcbiAgICAgIGNvbnN0IGcgPSBHZW4udWdlbnMgXG4gICAgICBjb25zdCBnaWJiZXJpc2g9IEF1ZGlvLkdpYmJlcmlzaFxuICAgICAgbGV0IG9zY1xuXG4gICAgICBzd2l0Y2goIHR5cGUgKSB7XG4gICAgICAgIGNhc2UgJ3Nhdyc6XG4gICAgICAgICAgb3NjID0gZy5waGFzb3IoIGZyZXF1ZW5jeSApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICBvc2MgPSBnLmFkZCggZy5tdWwoIGcuZ3QoIGcucGhhc29yKCBmcmVxdWVuY3kgKSwgMCApLCAyICksIC0xIClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdub2lzZSc6XG4gICAgICAgICAgb3NjID0gZy5zdWIoIGcubXVsKCBnLm5vaXNlKCksIDIgKSwgMSApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgICBjYXNlICd0cmknOlxuICAgICAgICAgIGNvbnN0IHAgPSBnLnBoYXNvciggZnJlcXVlbmN5IClcbiAgICAgICAgICBvc2MgPSBnLnN1YihcbiAgICAgICAgICAgIDEsIFxuICAgICAgICAgICAgZy5tdWwoIFxuICAgICAgICAgICAgICA0LCBcbiAgICAgICAgICAgICAgZy5hYnMoXG4gICAgICAgICAgICAgICAgZy5zdWIoIFxuICAgICAgICAgICAgICAgICAgZy5yb3VuZCggcCApLFxuICAgICAgICAgICAgICAgICAgcFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NpbmUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG9zYyA9IGcuY3ljbGUoIGZyZXF1ZW5jeSApXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY29uc3QgX211bCAgID0gZy5tdWwoIG9zYywgYW1wICksXG4gICAgICAgICAgICBfYWRkICAgPSBnLmFkZCggY2VudGVyLCBfbXVsICkgXG5cbiAgICAgIGNvbnN0IGxmbyA9IHNob3VsZFJvdW5kID8gR2VuLm1ha2UoIGcucm91bmQoIF9hZGQgKSApIDogR2VuLm1ha2UoIF9hZGQgKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggbGZvLCB7XG4gICAgICAgIGZyZXF1ZW5jeToge1xuICAgICAgICAgIHNldCh2KSB7IGxmby5wMSA9IHYgfSxcbiAgICAgICAgICBnZXQoKSAgeyByZXR1cm4gbGZvLnAxIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2Fpbjoge1xuICAgICAgICAgIHNldCh2KSB7IGxmby5wMiA9IHYgfSxcbiAgICAgICAgICBnZXQoKSAgeyByZXR1cm4gbGZvLnAyIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmlhczoge1xuICAgICAgICAgIHNldCh2KSB7IGxmby5wMCA9IHYgfSxcbiAgICAgICAgICBnZXQoKSAgeyByZXR1cm4gbGZvLnAwIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgbGZvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEdlbi5jb21wb3NpdGVzLmxmbyggdHlwZSwgdGhpcy5mcmVxdWVuY3kudmFsdWUsIHRoaXMuZ2Fpbi52YWx1ZSwgdGhpcy5iaWFzLnZhbHVlIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxmb1xuICAgIH0sXG5cbiAgICBmYWRlKCB0aW1lID0gMSwgZnJvbSA9IDEsIHRvID0gMCApIHtcbiAgICAgIGxldCBnID0gR2VuLnVnZW5zXG4gICAgICBsZXQgZmFkZSwgYW10LCBiZWF0c0luU2Vjb25kcyA9IHRpbWUgKiAoIDYwIC8gR2liYmVyLkxpdmUuTE9NLmJwbSApXG4gICAgIFxuICAgICAgaWYoIGZyb20gPiB0byApIHtcbiAgICAgICAgYW10ID0gZnJvbSAtIHRvXG5cbiAgICAgICAgZmFkZSA9IGcuZ3RwKCBnLnN1YiggZnJvbSwgZy5hY2N1bSggZy5kaXYoIGFtdCwgZy5tdWwoYmVhdHNJblNlY29uZHMsIGcuc2FtcGxlcmF0ZSApICksIDAgKSApLCB0byApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgYW10ID0gdG8gLSBmcm9tXG4gICAgICAgIGZhZGUgPSBnLmFkZCggZnJvbSwgZy5sdHAoIGcuYWNjdW0oIGcuZGl2KCBhbXQsIGcubXVsKCBiZWF0c0luU2Vjb25kcywgZy5zYW1wbGVyYXRlICkgKSwgMCApLCB0byApIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gWFhYIHNob3VsZCB0aGlzIGJlIGF2YWlsYWJsZSBpbiBtcz8gbXNUb0JlYXRzKCk/XG4gICAgICBsZXQgbnVtYmVhdHMgPSB0aW1lIC8gNFxuICAgICAgZmFkZS5zaG91bGRLaWxsID0ge1xuICAgICAgICBhZnRlcjogbnVtYmVhdHMsIFxuICAgICAgICBmaW5hbDogdG9cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhZGVcbiAgICB9LFxuICAgIFxuICAgIC8vYmVhdHMoIG51bSApIHtcbiAgICAvLyAgcmV0dXJuIEdlbi51Z2Vucy5yYXRlKCBudW0gKVxuICAgIC8vICAvLyBiZWF0KCBuICkgPT4gcmF0ZShpbjEsIG4pXG4gICAgLy8gIC8vIGZpbmFsIHN0cmluZyBzaG91bGQgYmUgcmF0ZSggaW4xLCBudW0gKVxuICAgIC8vfVxuICAgIGJlYXRzKCBiICkge1xuICAgICAgcmV0dXJuIEdlbi51Z2Vucy5waGFzb3IoIEF1ZGlvLlV0aWxpdGllcy5idG9mKCBiICksIDAsIHsgbWluOjAgfSApXG4gICAgfSwgXG4gICAgYmVhdHMyKCBiICkge1xuICAgICAgcmV0dXJuIEdlbi51Z2Vucy5waGFzb3IoIFxuICAgICAgICBBdWRpby5VdGlsaXRpZXMuYnRvZiggYiApLCBcbiAgICAgICAgMCwgXG4gICAgICAgIHsgbWluOjAgfSApXG4gICAgfSwgXG4gIH0sXG5cbiAgdWdlbnM6e30sXG5cbiAgZXhwb3J0KCBvYmogKSB7XG4gICAgZm9yKCBsZXQga2V5IGluIEdlbi5mdW5jdGlvbnMgKSB7XG4gICAgICB0aGlzLnVnZW5zWyBrZXkgXSA9IEdlbi5jcmVhdGUuYmluZCggR2VuLCBrZXkgKVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMudWdlbnMsIEdlbi5jb25zdGFudHMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMudWdlbnMsIEdlbi5jb21wb3NpdGVzIClcblxuICAgIGNvbnN0IF9faW4gPSB0aGlzLnVnZW5zLmluXG4gICAgZGVsZXRlIHRoaXMudWdlbnMuaW5cbiAgICBPYmplY3QuYXNzaWduKCBvYmosIHRoaXMudWdlbnMgKVxuICAgIHRoaXMudWdlbnMuaW4gPSBfX2luXG4gIH0sXG5cblxuICAvLyBkZWZlciBjcmVhdGluZyBnZW5pc2ggb2JqZWN0IHVudGlsIHdlIGtub3cgd2hldGhlclxuICAvLyB0aGlzIHdpbGwgYmUgdXNlZCBieSBhbiBhdWRpbyBvciB2aXN1YWwgb2JqZWN0XG4gIG1ha2UoIGdyYXBoLCBwcm9wZXJ0eU5hbWVzICkge1xuICAgIGNvbnN0IGRlZmVyID0geyBcbiAgICAgIGdyYXBoLCBcbiAgICAgIF9fZ3JhcGg6Z3JhcGgsXG4gICAgICBwcm9wZXJ0eU5hbWVzLFxuICAgICAgdHlwZTonZ2VuJyxcbiAgICAgIGlkOiBBdWRpby5HaWJiZXJpc2gudXRpbGl0aWVzLmdldFVJRCgpLFxuICAgICAgcmVuZGVyZWQ6bnVsbCxcbiAgICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBHZW4ubWFrZSggdGhpcy5fX2dyYXBoIClcbiAgICAgIH0sXG4gICAgICByZW5kZXIoIHNhbXBsZXJhdGU9NDQxMDAsIHR5cGU9J2F1ZGlvJyApIHtcbiAgICAgICAgaWYoIHR5cGUgPT09ICdhdWRpbycgKSB7XG4gICAgICAgICAgaWYoIHRoaXMucmVuZGVyZWQgPT09IG51bGwgKSB7IFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IEdlbi5fX21ha2UoIHRoaXMuZ3JhcGgsIHRoaXMucHJvcGVydHlOYW1lcywgZGVmZXIgKVxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnJlbmRlcmVkLl9fd3JhcHBlZF9fLl9fcHJvcGVydGllc19fXG4gICAgICAgICAgICBmb3IoIGxldCBrZXkgaW4gcHJvcHMgKSB7IFxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIGtleSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMucmVuZGVyZWRbIGtleV0gfSxcbiAgICAgICAgICAgICAgICBzZXQodil7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkWyBrZXkgXSA9IHYgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQud2lkZ2V0ID0gdGhpcy53aWRnZXRcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQuX19ncmFwaCA9IGdyYXBoXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0b3JlID0gQXVkaW8uR2liYmVyaXNoLmdlbmlzaC5zYW1wbGVyYXRlXG4gICAgICAgIGNvbnN0IGcgPSBBdWRpby5HaWJiZXJpc2guZ2VuaXNoXG5cbiAgICAgICAgQXVkaW8uR2liYmVyaXNoLmdlbmlzaC5nZW4uc2FtcGxlcmF0ZSA9IHNhbXBsZXJhdGVcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW11cbiAgICAgICAgY29uc3QgX19ncmFwaCA9IGV2YWwoIGdyYXBoLmdlbiggcGFyYW1zICkgKVxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGcuZ2VuLmNyZWF0ZUNhbGxiYWNrKCBfX2dyYXBoIClcbiAgICAgICAgQXVkaW8uR2liYmVyaXNoLmdlbmlzaC5nZW4uc2FtcGxlcmF0ZSA9IHN0b3JlICAgICAgXG5cbiAgICAgICAgY29uc3Qgb3V0ID0gY2FsbGJhY2suYmluZCggbnVsbCwgLi4ucGFyYW1zLm1hcCggdiA9PiB2WzFdICksIGcubWVtb3J5IClcblxuICAgICAgICAvLyBhbm5vdGF0aW9ucyBjYW4gYmUgYWRkZWQgdG8gdGhlIG9yaWdpbmFsIGRlZmVyLCBzbyBzdG9yZSB0aGUgZGVmZXJcbiAgICAgICAgLy8gdG8gYWNjZXNzIHRoZSBhbm5vdGF0aW9ucyBsYXRlclxuICAgICAgICBvdXQucHJlID0gZGVmZXIgXG5cbiAgICAgICAgcmV0dXJuIG91dFxuICAgICAgfSxcblxuICAgICAgLy8gWFhYIGNvbm5lY3RpbmcgZ2VuIG9iamVjdHMgdG8gYXVkaW8gcHJvcGVydGllcyBubyBsb25nZXIgc2VlbXNcbiAgICAgIC8vIHRvIHdvcmsuLi4gbXVzdCBiZSBhc3NpZ25lZC4gRklYXG4gICAgICBjb25uZWN0KCB0YXJnZXQgKSB7XG4gICAgICAgIGlmKCB0YXJnZXQudHlwZSA9PT0gJ2F1ZGlvJyApIHtcbiAgICAgICAgICBpZiggdGhpcy5yZW5kZXJlZCA9PT0gbnVsbCApIHsgXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkID0gR2VuLl9fbWFrZSggdGhpcy5ncmFwaCwgdGhpcy5wcm9wZXJ0eU5hbWVzLCBkZWZlciApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVuZGVyZWQuY29ubmVjdCggdGFyZ2V0IClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWZlclxuICB9LFxuXG4gIF9fbWFrZSggZ3JhcGgsIHByb3BlcnR5TmFtZXMsIHRhcmdldCApIHtcbiAgICBjb25zdCB1Z2VuID0gQXVkaW8uR2liYmVyaXNoLnByb3RvdHlwZXMuVWdlblxuICAgIGNvbnN0IGcgPSBBdWRpby5HaWJiZXJpc2guZ2VuaXNoXG5cbiAgICAvLyBzdG9yZSBwcm9wZXJ0aWVzIG9mIG91ciBnZW4gb2JqZWN0IGluIHRoaXMgYXJyYXlcbiAgICAvLyB0aGV5IHdpbGwgdGhlbiBiZWNvbWUgcHJvcGVydGllcyBvZiBvdXIgR2liYmVyIG9iamVjdFxuICAgIGNvbnN0IHBhcmFtQXJyYXkgPSBbXVxuXG4gICAgLy8gZ2V0IGdlbmlzaC5qcyBjb2RlbGV0IGZvciBvdXIgZ3JhcGhcbiAgICBjb25zdCBnZW5Db2RlID0gZ3JhcGguZ2VuKCBwYXJhbUFycmF5IClcblxuICAgIC8vIGNyZWF0ZSBhIHByb3BlcnRpZXMgb2JqZWN0IG91dCBvZiBvdXIgcGFyYW1BcnJheVxuICAgIGNvbnN0IHBhcmFtcyA9IHt9XG4gICAgZm9yKCBsZXQgcGFyYW0gb2YgcGFyYW1BcnJheSApIHtcbiAgICAgIHBhcmFtc1sgcGFyYW1bMF0gXSA9IHBhcmFtWzFdXG4gICAgfSBcblxuICAgIGNvbnN0IGlkID0gR2VuLmdldFVJRCgpXG5cbiAgICBwYXJhbXMuaWQgPSBBdWRpby5HaWJiZXJpc2gudXRpbGl0aWVzLmdldFVJRCgpXG5cbiAgICAvLyBwYXNzIGEgY29uc3RydWN0b3IgdG8gb3VyIHdvcmtsZXQgcHJvY2Vzc29yXG4gICAgQXVkaW8uR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgYWRkcmVzczonYWRkTWV0aG9kJywgXG4gICAgICBpZDotMSxcbiAgICAgIGtleTonR2VuJyArIGlkLFxuICAgICAgZnVuY3Rpb246YGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgY29uc3QgZyA9IEdpYmJlcmlzaC5nZW5pc2g7IFxuICAgICAgICBjb25zdCBteW1vZCA9IE9iamVjdC5jcmVhdGUoIEdpYmJlcmlzaC5wcm90b3R5cGVzLlVnZW4gKTsgXG4gICAgICAgIEdpYmJlcmlzaC5mYWN0b3J5KCBteW1vZCwgJHtnZW5Db2RlfSwgJ0dlbiR7aWR9JywgJHtKU09OLnN0cmluZ2lmeShwYXJhbXMpfSwgbnVsbCwgdHJ1ZSApOyBcbiAgICAgICAgcmV0dXJuIG15bW9kOyBcbiAgICAgIH1gXG4gICAgfSlcblxuICAgIC8vIGNyZWF0ZSBhIHdvcmtsZXQtc2lkZSBHaWJiZXJpc2ggY29uc3RydWN0b3JcbiAgICBjb25zdCBtYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBteW1vZCA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuICAgICAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgZG9lc24ndCBtYXR0ZXIgaW4gdGhlIHdvcmtsZXQsIG9ubHkgaW4gdGhlIHByb2Nlc3NvclxuICAgICAgLy8gc28gd2UgY2FuIGp1c3QgaW5wdXQgemVyb2VzLiBobW1tbS4uLiBJIGd1ZXMgaXQgcHJvYmFibHkgbWF0dGVycyBmb3JcbiAgICAgIC8vIHNlcXVlbmNpbmc/XG4gICAgICBcbiAgICAgIHJldHVybiBBdWRpby5HaWJiZXJpc2guZmFjdG9yeSggbXltb2QsIGcuYWRkKDAsMCksICdHZW4nK2lkLCBwYXJhbXMgKVxuICAgIH1cblxuICAgIC8vIFhYWCBkbyBJIHJlYWxseSBoYXZlIHRvIG1ha2UgYSBHaWJiZXJpc2ggY29uc3RydWN0b3IgYW5kIGEgR2liYmVyIGNvbnN0cnVjdG9yIHRvXG4gICAgLy8gdHVybiBhIGdlbmlzaCBncmFwaCBpbnRvIGEgR2liYmVyIHVnZW4/IElzIHRoZXJlIGEgc2hvcnRjdXQgdG8gdGFrZT8gSXMgaXQgd29ydGhcbiAgICAvLyB3cml0aW5nIGN1c3RvbSBjb2RlIGZvcj9cblxuICAgIC8vIGNyZWF0ZSBhIEdpYmJlciBjb25zdHJ1Y3RvciB1c2luZyBvdXIgR2liYmVyaXNoIGNvbnN0cnVjdG9yXG4gICAgbGV0IHRlbXAgPSBwYXJhbXMuaWRcbiAgICAvL2RlbGV0ZSBwYXJhbXMuaWRcbiAgICBjb25zdCBNYWtlID0gQXVkaW8uVWdlbiggbWFrZSwgeyBuYW1lOidHZW4nK2lkLCBwcm9wZXJ0aWVzOnBhcmFtcywgbWV0aG9kczpbXX0sIEF1ZGlvIClcblxuICAgIC8vIGNyZWF0ZSBHaWJiZXIgdWdlbiBhbmQgcGFzcyBpbiBwcm9wZXJ0aWVzIGRpY3Rpb25hcnkgdG8gaW5pdGFpbGl6ZVxuICAgIGNvbnN0IG91dCA9IE1ha2UoeyBwYXJhbXMgfSlcbiAgICBvdXQuX193cmFwcGVkX18uaWQgPSB0ZW1wIFxuICAgIG91dC5fX3dyYXBwZWRfXy5jb25uZWN0ZWQgPSBbXVxuXG4gICAgbGV0IGNvdW50ID0gMFxuICAgIG91dC5fX3dyYXBwZWRfXy5vdXRwdXQgPSBvdXQub3V0cHV0ID0gZnVuY3Rpb24oIHYgKSB7XG4gICAgICAvL2lmKCBBdWRpby5HaWJiZXIuRW52aXJvbm1lbnQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgLy8gWFhYIHNob3VsZCB0aGVzZSBiZSBhdmVyYWdlZCBpbnN0ZWFkIG9mIG9ubHkgdGFraW5nIGV2ZXJ5IHNpeHRoIHNhbXBsZSAocm91Z2hseVxuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byA1OCBmcmFtZXMgYSBzZWNvbmQpXG4gICAgICAgIGlmKCBjb3VudCsrICUgNiA9PT0gMCApIHtcbiAgICAgICAgICAvLyBYWFggdGhpcyBzaG91bGRuJ3QgaGFwcGVuIGhlcmUsIHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgYW5ub3RhdGlvbiBpcyBjcmVhdGVkLlxuICAgICAgICAgIGlmKCBBdWRpby5HaWJiZXIuRW52aXJvbm1lbnQuQW5ub3RhdGlvbnMud2F2ZWZvcm0ud2lkZ2V0c1sgdGVtcCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBBdWRpby5HaWJiZXIuRW52aXJvbm1lbnQuQW5ub3RhdGlvbnMud2F2ZWZvcm0ud2lkZ2V0c1sgdGVtcCBdID0gb3V0LndpZGdldFxuICAgICAgICAgIH1cbiAgICAgICAgICBBdWRpby5HaWJiZXIuRW52aXJvbm1lbnQuQW5ub3RhdGlvbnMud2F2ZWZvcm0udXBkYXRlV2lkZ2V0KCBvdXQud2lkZ2V0LCB2LCBmYWxzZSApXG4gICAgICAgIH1cbiAgICAgIC8vfVxuXG4gICAgICBvdXQub3V0cHV0LnZhbHVlID0gdlxuICAgIH1cblxuICAgIC8vIG9wdGlvbmFsbHkgbWFwIHVzZXIgcHJvdmlkZWQgbmFtZXMgdG8gcCB2YWx1ZXMgZm9yIGJldHRlciBjb250cm9sIC8gc2VxdWVuY2luZ1xuICAgIGlmKCBBcnJheS5pc0FycmF5KCBwcm9wZXJ0eU5hbWVzICkpIHtcbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyBpIF1cbiAgICAgICAgaWYoIG91dFsgJ3AnK2kgXSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5TmFtZSAhPT0gbnVsbCAmJiBwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG91dFsgJ19fJytwcm9wZXJ0eU5hbWUgXSA9IG91dFsgJ3AnK2kgXVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIG91dFsgJ19fJyArIHByb3BlcnR5TmFtZSBdIH0sXG4gICAgICAgICAgICBzZXQodil7XG4gICAgICAgICAgICAgIGlmKCB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCApIHJldHVyblxuICAgICAgICAgICAgICBvdXRbICdfXycgKyBwcm9wZXJ0eU5hbWUgXS52YWx1ZSA9IHZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIG91dFsgJ19fJyArIHByb3BlcnR5TmFtZSBdIH0sXG4gICAgICAgICAgICBzZXQodil7XG4gICAgICAgICAgICAgIGlmKCB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCApIHJldHVyblxuICAgICAgICAgICAgICBvdXRbICdfXycgKyBwcm9wZXJ0eU5hbWUgXS52YWx1ZSA9IHZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIH0gXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBvdXQuaWQgPSB0ZW1wXG4gICAgb3V0Ll9faXNHZW4gPSBvdXQuX193cmFwcGVkX18uX19pc0dlbiA9IHRydWVcbiAgICBvdXQudHlwZSA9ICdnZW4nXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cbn1cblxuR2VuLmluaXQoKVxuXG5yZXR1cm4gR2VuIFxufVxuIiwiY29uc3QgR2liYmVyaXNoID0gcmVxdWlyZSggJ2dpYmJlcmlzaC1kc3AnIClcbmNvbnN0IFVnZW4gICAgICA9IHJlcXVpcmUoICcuL3VnZW4uanMnIClcblxuY29uc3QgSW5zdHJ1bWVudHMgPSB7XG4gIGNyZWF0ZSggQXVkaW8gKSB7XG4gICAgY29uc3QgaW5zdHJ1bWVudHMgPSB7fVxuICAgIC8vY29uc3QgcG9vbGVkSW5zdHJ1bWVudHMgPSBbJ1N5bnRoJywnTW9ub3N5bnRoJywnRk0nXVxuICAgIGZvciggbGV0IGluc3RydW1lbnROYW1lIGluIEdpYmJlcmlzaC5pbnN0cnVtZW50cyApIHtcbiAgICAgIGNvbnN0IGdpYmJlcmlzaENvbnN0cnVjdG9yID0gR2liYmVyaXNoLmluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdXG4gICAgICBpZiggdHlwZW9mIGdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzID09PSAnb2JqZWN0JyApIGdpYmJlcmlzaENvbnN0cnVjdG9yLmRlZmF1bHRzLm9jdGF2ZSA9IDBcblxuICAgICAgY29uc3QgbWV0aG9kcyA9IEluc3RydW1lbnRzLmRlc2NyaXB0aW9uc1sgaW5zdHJ1bWVudE5hbWUgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEluc3RydW1lbnRzLmRlc2NyaXB0aW9uc1sgaW5zdHJ1bWVudE5hbWUgXS5tZXRob2RzXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHsgXG4gICAgICAgIHByb3BlcnRpZXM6Z2liYmVyaXNoQ29uc3RydWN0b3IuZGVmYXVsdHMsIFxuICAgICAgICBtZXRob2RzOm1ldGhvZHMsXG4gICAgICAgIG5hbWU6aW5zdHJ1bWVudE5hbWUsXG4gICAgICAgIGNhdGVnb3J5OidpbnN0cnVtZW50cydcbiAgICAgIH1cblxuICAgICAgLy9jb25zdCBzaG91bGRQb29sID0gcG9vbGVkSW5zdHJ1bWVudHMuaW5kZXhPZiggaW5zdHJ1bWVudE5hbWUgKSA+IC0xXG4gICAgICBpbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXSA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8sIGZhbHNlICkgXG5cbiAgICAgIC8vIGZvciBwb2x5IG5vdGF0aW9uIGxpa2UgU3ludGhbM10oKVxuICAgICAgLy8gY3JlYXRlIG9yIGV4dGVuZCBkaWN0aW9uYXJ5IHdpdGggbWF4Vm9pY2VzIHByb3BlcnR5XG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IDIwOyBpKysgKSB7XG4gICAgICAgIGluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdW2ldID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICAgICAgaWYoIGFyZ3MubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgIGlmKCBhcmdzLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0ubWF4Vm9pY2VzID0gaSB8fCAxXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYXJnc1sxXSA9IHsgbWF4Vm9pY2VzOmkgfHwgMSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgIGFyZ3NbMF0ubWF4Vm9pY2VzID0gaSB8fCAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBhcmdzWzBdID0geyBtYXhWb2ljZXM6aSB8fCAxIH1cbiAgICAgICAgICB9IFxuXG4gICAgICAgICAgLy8gdXNlIG1vbm9waG9uaWMgdmVyc2lvbiBpZiB2b2ljZSBjb3VudCBpcyAxIG9yIGxlc3NcbiAgICAgICAgICBsZXQgbmFtZVxuICAgICAgICAgIGlmKCBpID4gMSApIHtcbiAgICAgICAgICAgIG5hbWUgPSBpbnN0cnVtZW50TmFtZSA9PT0gJ1NhbXBsZXInID8gJ011bHRpc2FtcGxlcicgOiAnUG9seScraW5zdHJ1bWVudE5hbWVcbiAgICAgICAgICAgIGlmKCBuYW1lID09PSAnUG9seU1vbm9zeW50aCcgKSBuYW1lID0gJ1BvbHlNb25vJyBcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG5hbWUgPSBpbnN0cnVtZW50TmFtZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50c1sgbmFtZSBdKCAuLi5hcmdzIClcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdLnByZXNldHMgPSBBdWRpby5QcmVzZXRzLmluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdIFxuICAgICAgaWYoIGluc3RydW1lbnRzWyBpbnN0cnVtZW50TmFtZSBdLnByZXNldHMgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaW5zdHJ1bWVudHNbIGluc3RydW1lbnROYW1lIF0ucHJlc2V0cy5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS50YWJsZSggdGhpcyApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBpbnN0cnVtZW50c1sgaW5zdHJ1bWVudE5hbWUgXS5wcmVzZXRzID0geyBpbnNwZWN0KCkgeyBjb25zb2xlLmxvZyggYCR7aW5zdHJ1bWVudE5hbWV9IGhhcyBubyBwcmVzZXRzLmAgKSB9IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdHJ1bWVudHMuUGx1Y2sgPSBpbnN0cnVtZW50cy5LYXJwbHVzXG4gICAgcmV0dXJuIGluc3RydW1lbnRzXG4gIH0sXG5cbiAgZGVzY3JpcHRpb25zOiB7XG4gICAgQ2xhcDp7XG4gICAgICBtZXRob2RzOlsgJ3RyaWdnZXInIF0sXG4gICAgfSwgICBcbiAgICBDb25nYTp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgQ2xhdmU6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIENvd2JlbGw6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIEZNOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBIYXQ6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIEthcnBsdXM6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIEtpY2s6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIE1vbm9zeW50aDp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgU2FtcGxlcjp7XG4gICAgICBtZXRob2RzOlsgJ25vdGUnLCAndHJpZ2dlcicsICdsb2FkRmlsZScsICdsb2FkQnVmZmVyJyBdLFxuICAgIH0sXG4gICAgTXVsdGlzYW1wbGVyOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsICd0cmlnZ2VyJywgJ3BpY2snLCAncGlja0ZpbGUnLCAncGlja3BsYXknLCAnbG9hZFNhbXBsZScsICdzZXRwYW4nLCAnc2V0cmF0ZScgXSwgXG4gICAgfSxcbiAgICBTb3VuZGZvbnQ6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywgJ3RyaWdnZXInLCAnbWlkaW5vdGUnLCAnbWlkaWNob3JkJywgJ2Nob3JkJywgJ2xvYWQnLCAnc2V0cGFuJywgJ3NldHJhdGUnIF0sIFxuICAgIH0sXG4gICAgU25hcmU6e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFN5bnRoOntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBDb21wbGV4OntcbiAgICAgIG1ldGhvZHM6WyAnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBUb206e1xuICAgICAgbWV0aG9kczpbICdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFBvbHlTeW50aDp7XG4gICAgICBtZXRob2RzOlsgJ2Nob3JkJywnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBQb2x5Q29tcGxleDp7XG4gICAgICBtZXRob2RzOlsgJ2Nob3JkJywnbm90ZScsJ3RyaWdnZXInIF0sXG4gICAgfSxcbiAgICBQb2x5Rk06e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgUG9seUthcnBsdXM6e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgUG9seU1vbm86e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gICAgUG9seUNvbmdhOntcbiAgICAgIG1ldGhvZHM6WyAnY2hvcmQnLCdub3RlJywndHJpZ2dlcicgXSxcbiAgICB9LFxuICAgIFBvbHlUb206e1xuICAgICAgbWV0aG9kczpbICdjaG9yZCcsJ25vdGUnLCd0cmlnZ2VyJyBdLFxuICAgIH0sXG4gIH0sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluc3RydW1lbnRzXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBBdWRpbyApIHtcbiAgY29uc3QgR2liYmVyaXNoID0gQXVkaW8uR2liYmVyaXNoXG5cbiAgY29uc3QgZm5jID0gZnVuY3Rpb24oIHByb3BzICl7XG4gICAgY29uc3QgbmFtZSA9IHByb3BzLm5hbWVcbiAgICBjb25zdCB0eXBlID0gcHJvcHMudHlwZVxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcm9wcy5wcm9wZXJ0aWVzIHx8IHt9XG4gICAgY29uc3QgYmxvY2sgPSBgXG4gICAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIEdpYmJlcmlzaC5wcm90b3R5cGVzWyAnJHt0eXBlfScgXSApXG4gICAgY29uc3QgZ3JhcGhmbmMgPSAke3Byb3BzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCl9XG5cbiAgICBjb25zdCBwcm94eSA9IEdpYmJlcmlzaC5mYWN0b3J5KCB1Z2VuLCBncmFwaGZuYygpLCAnJHtuYW1lfScsICR7SlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyl9IClcbiAgICByZXR1cm4gcHJveHlgXG5cbiAgICBHaWJiZXJpc2hbIG5hbWUgXSA9IG5ldyBGdW5jdGlvbiggYmxvY2sgKVxuXG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICBuYW1lLFxuICAgICAgYWRkcmVzczonYWRkQ29uc3RydWN0b3InLFxuICAgICAgY29uc3RydWN0b3JTdHJpbmc6YGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gICAgICBjb25zdCBmbmMgPSAke0dpYmJlcmlzaFsgbmFtZSBdLnRvU3RyaW5nKCl9XG5cbiAgICAgIHJldHVybiBmbmNcbiAgICB9YFxuICAgIH0pXG5cbiAgICBjb25zdCBvdXQgPSBBdWRpby5VZ2VuKCBcbiAgICAgIEdpYmJlcmlzaFsgbmFtZSAgXSxcbiAgICAgIHsgcHJvcGVydGllcywgbWV0aG9kczpbXSwgbmFtZSwgY2F0ZWdvcnk6J2luc3RydW1lbnRzJ30sXG4gICAgICBBdWRpbyBcbiAgICApXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgcmV0dXJuIGZuY1xufVxuXG4vKiBleGFtcGxlIHVzZTpcbmRlZiA9IHtcbiAgbmFtZTonTXlzaW5lJyxcbiAgdHlwZTonVWdlbicsXG4gIHByb3BlcnRpZXM6eyBmcmVxdWVuY3k6MjIwIH0sXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBnZW4gPSBHaWJiZXJpc2guZ2VuaXNoXG4gICAgY29uc3QgZ3JhcGggPSBnZW4uY3ljbGUoIGdlbi5pbignZnJlcXVlbmN5JykgKVxuICAgIHJldHVybiBncmFwaFxuICB9XG59XG4gXG5NeXNpbmUgPSBNYWtlKCBkZWYgKVxuc2luZSA9IFMoKVxuc2luZS5mcmVxdWVuY3kuc2VxKCBbMTEwLDIyMCwzMzBdLCAxLzggKVxuc2luZS5jb25uZWN0KClcbiovXG4iLCJjb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuY29uc3QgVWdlbiAgICAgID0gcmVxdWlyZSggJy4vdWdlbi5qcycgKVxuXG5jb25zdCBPc2NpbGxhdG9ycyA9IHtcbiAgY3JlYXRlKCBBdWRpbyApIHtcbiAgICBjb25zdCBvc2NpbGxhdG9ycyA9IHt9XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBmcmVxdWVuY3k6MjIwLCBnYWluOi4yNSwgcHVsc2V3aWR0aDouNVxuICAgIH1cbiAgICBmb3IoIGxldCBvc2NpbGxhdG9yTmFtZSBpbiBHaWJiZXJpc2gub3NjaWxsYXRvcnMgKSB7XG4gICAgICBjb25zdCBnaWJiZXJpc2hDb25zdHJ1Y3RvciA9IEdpYmJlcmlzaC5vc2NpbGxhdG9yc1sgb3NjaWxsYXRvck5hbWUgXVxuXG4gICAgICAvL2NvbnN0IG1ldGhvZHMgPSBPc2NpbGxhdG9ycy5kZXNjcmlwdGlvbnNbIG9zY2lsbGF0b3JOYW1lIF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBPc2NpbGxhdG9ycy5kZXNjcmlwdGlvbnNbIG9zY2lsbGF0b3JOYW1lIF0ubWV0aG9kc1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7IFxuICAgICAgICBwcm9wZXJ0aWVzOmRlZmF1bHRzLCBcbiAgICAgICAgbWV0aG9kczpbXSxcbiAgICAgICAgbmFtZTpvc2NpbGxhdG9yTmFtZSxcbiAgICAgICAgY2F0ZWdvcnk6J29zY2lsbGF0b3JzJ1xuICAgICAgfVxuXG4gICAgICBvc2NpbGxhdG9yc1sgb3NjaWxsYXRvck5hbWUgXSA9IFVnZW4oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8gKVxuXG4gICAgfVxuICAgIHJldHVybiBvc2NpbGxhdG9yc1xuICB9LFxuXG4gIGRlc2NyaXB0aW9uczoge30sXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9zY2lsbGF0b3JzXG4iLCJjb25zdCBQcmVzZXRzID0ge1xuICBwcm9jZXNzKCBkZXNjcmlwdGlvbiwgYXJncywgQXVkaW8gKSB7XG4gICAgbGV0IG91dHB1dFxuXG4gICAgLy8gaWYgdGhlIGNvbnN0cnVjdG9yIGFydWdtZW50IGlzIG5vdCBhIHN0cmluZyB0aGVuIG5vIHByZXNldCBpcyBiZWluZyB1c2VkXG4gICAgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyApIHtcbiAgICAgIG91dHB1dCA9IGFyZ3NbIDAgXSAgXG4gICAgfWVsc2UgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApe1xuICAgICAgaWYoIGFyZ3NbMF0gPT09ICdpbnNwZWN0JyApIHJldHVybiBudWxsXG4gICAgICBvdXRwdXQgPSB7fVxuICAgICAgY29uc3QgcHJlc2V0ID0gUHJlc2V0c1sgZGVzY3JpcHRpb24uY2F0ZWdvcnkgXVsgZGVzY3JpcHRpb24ubmFtZSBdWyBhcmdzWzBdIF1cblxuICAgICAgaWYoIHByZXNldCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICBmb3IoIGxldCBrZXkgaW4gcHJlc2V0ICkge1xuICAgICAgICAgIGlmKCBrZXkgPT09ICdwcmVzZXRJbml0JyApIGNvbnRpbnVlXG4gICAgICAgICAgbGV0IHZhbHVlID0gcHJlc2V0WyBrZXkgXVxuXG4gICAgICAgICAgLy8gaWYgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBydW4gdGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgbmV3IHZhbHVlLiB0aGVzZVxuICAgICAgICAgIC8vIHByZXNldCBmdW5jdGlvbnMgYXJlIHBhc3NlZCB0aGUgbWFpbiBhdWRpbyBvYmplY3QsIHdoaWNoIHRoZXkgY2FuIHR5cGljYWxseVxuICAgICAgICAgIC8vIHVzZSwgZm9yIGV4YW1wbGUsIHRvIHF1ZXJ5IHRoZSBjdXJyZW50IHNhbXBsZSByYXRlLlxuICAgICAgICAgIG91dHB1dFsga2V5IF0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSggQXVkaW8gKSA6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBwcmVzZXQucHJlc2V0SW5pdCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIG91dHB1dC5fX3ByZXNldEluaXRfXyA9IHByZXNldC5wcmVzZXRJbml0IFxuICAgICAgICB9IFxuICAgICAgfWVsc2V7XG4gICAgICAgIGNvbnNvbGUud2FybiggYFRoZSBwcmVzZXQgJHthcmdzWzBdfSBmb3IgdGhlICR7ZGVzY3JpcHRpb24uY2F0ZWdvcnkuc2xpY2UoMCwtMSl9ICR7ZGVzY3JpcHRpb24ubmFtZX0gZG9lcyBub3QgZXhpc3QuYCApXG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSBpcyBhbiBleHRyYSBhcmd1bWVudCB0byBtb2RpZnkgdGhlIHByZXNldC4uLlxuICAgICAgaWYoIGFyZ3MubGVuZ3RoID4gMSApIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggb3V0cHV0LCBhcmdzWzFdIClcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIG91dHB1dCA9IHt9XG4gICAgfVxuICAgIFxuICAgIGlmKCBkZXNjcmlwdGlvbi5fX2RlZmF1bHRzX18gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGNvbnNvbGUubG9nKCAnZGVmYXVsdHM6JywgZGVzY3JpcHRpb24uX19kZWZhdWx0c19fIClcbiAgICAgIE9iamVjdC5hc3NpZ24oIG91dHB1dCwgZGVzY3JpcHRpb24uX19kZWZhdWx0c19fIClcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0sXG5cbiAgaW5zdHJ1bWVudHM6IHtcbiAgICBDb21wbGV4OiByZXF1aXJlKCAnLi9wcmVzZXRzL2NvbXBsZXhfcHJlc2V0cy5qcycgKSxcbiAgICBTeW50aDogcmVxdWlyZSggJy4vcHJlc2V0cy9zeW50aF9wcmVzZXRzLmpzJyApLFxuICAgIEZNOiAgICByZXF1aXJlKCAnLi9wcmVzZXRzL2ZtX3ByZXNldHMuanMnICksXG4gICAgTW9ub3N5bnRoOiByZXF1aXJlKCAnLi9wcmVzZXRzL21vbm9zeW50aF9wcmVzZXRzLmpzJyApLFxuICAgIFBvbHlNb25vOiByZXF1aXJlKCAnLi9wcmVzZXRzL21vbm9zeW50aF9wcmVzZXRzLmpzJyApLFxuICAgIFNuYXJlOiByZXF1aXJlKCAnLi9wcmVzZXRzL3NuYXJlX3ByZXNldHMuanMnICksXG4gICAgS2ljazogcmVxdWlyZSggJy4vcHJlc2V0cy9raWNrX3ByZXNldHMuanMnICksXG4gICAgSGF0OiByZXF1aXJlKCAnLi9wcmVzZXRzL2hhdF9wcmVzZXRzLmpzJyApLFxuXG4gICAgRURydW1zOiByZXF1aXJlKCAnLi9wcmVzZXRzL2VkcnVtc19wcmVzZXRzLmpzJyApLFxuICAgIERydW1zOiAgcmVxdWlyZSggJy4vcHJlc2V0cy9kcnVtc19wcmVzZXRzLmpzJyApLFxuICAgIE11bHRpc2FtcGxlcjogcmVxdWlyZSggJy4vcHJlc2V0cy9tdWx0aXNhbXBsZXIuanMnICksXG4gICAgU291bmRmb250OiAgICByZXF1aXJlKCAnLi9wcmVzZXRzL3NvdW5kZm9udF9wcmVzZXRzLmpzJyApXG4gIH0sXG5cbiAgZWZmZWN0czoge1xuICAgIENob3J1czogcmVxdWlyZSggJy4vcHJlc2V0cy9jaG9ydXNfcHJlc2V0cy5qcycgKSxcbiAgICBEaXN0b3J0aW9uOiByZXF1aXJlKCAnLi9wcmVzZXRzL2Rpc3RvcnRpb25fcHJlc2V0cy5qcycgKSxcbiAgICBGbGFuZ2VyOiByZXF1aXJlKCAnLi9wcmVzZXRzL2ZsYW5nZXJfcHJlc2V0cy5qcycgKSxcbiAgICBSZXZlcmI6IHJlcXVpcmUoICcuL3ByZXNldHMvcmV2ZXJiLmpzJyApLFxuICAgIERlbGF5OiByZXF1aXJlKCAnLi9wcmVzZXRzL2RlbGF5X3ByZXNldHMuanMnICksXG4gIH0sXG5cbiAgbWlzYzoge1xuICAgIEJ1czI6IHJlcXVpcmUoICcuL3ByZXNldHMvYnVzMl9wcmVzZXRzLmpzJyApXG4gIH1cblxufVxuXG5QcmVzZXRzLmluc3RydW1lbnRzLlNhbXBsZXIgICA9IFByZXNldHMuaW5zdHJ1bWVudHMuTXVsdGlzYW1wbGVyXG5QcmVzZXRzLmluc3RydW1lbnRzLlBvbHlTeW50aCA9IFByZXNldHMuaW5zdHJ1bWVudHMuU3ludGhcblByZXNldHMuaW5zdHJ1bWVudHMuUG9seUZNID0gUHJlc2V0cy5pbnN0cnVtZW50cy5GTVxuUHJlc2V0cy5pbnN0cnVtZW50cy5Qb2x5TW9ubyA9IFByZXNldHMuaW5zdHJ1bWVudHMuTW9ub3N5bnRoXG5cbm1vZHVsZS5leHBvcnRzID0gUHJlc2V0c1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgJ3NwYWNldmVyYic6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LnZlcmIgPSBhdWRpby5lZmZlY3RzLkZyZWV2ZXJiKHsgcm9vbVNpemU6Ljk4NSwgZHJ5OjEgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmZ4LnZlcmIgKVxuICAgIH1cbiAgfSxcbiAgJ2VjaG92ZXJiLjEvMyc6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS8zLCBmZWVkYmFjazouMzUsIHdldGRyeTouNSB9KVxuICAgICAgdGhpcy5meC5yZXZlcmIgID0gYXVkaW8uZWZmZWN0cy5GcmVldmVyYih7IHJvb21TaXplOi45ODUsIGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSApXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5yZXZlcmIgKVxuICAgICAgdGhpcy5mZWVkYmFjayA9IHRoaXMuZnguZGVsYXkuZmVlZGJhY2tcbiAgICAgIHRoaXMudGltZSA9IHRoaXMuZnguZGVsYXkudGltZVxuICAgICAgdGhpcy5yb29tU2l6ZSA9IHRoaXMuZngucmV2ZXJiLnJvb21TaXplXG4gICAgfVxuICB9LFxuICAnZWNob3ZlcmIuMS82Jzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzYsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41IH0pXG4gICAgICB0aGlzLmZ4LnZlcmIgID0gYXVkaW8uZWZmZWN0cy5GcmVldmVyYih7IHJvb21TaXplOi45ODUsIGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSwgdGhpcy5meC5yZXZlcmIgKVxuICAgICAgdGhpcy5mZWVkYmFjayA9IHRoaXMuZnguZGVsYXkuZmVlZGJhY2tcbiAgICAgIHRoaXMudGltZSA9IHRoaXMuZnguZGVsYXkudGltZVxuICAgICAgdGhpcy5yb29tU2l6ZSA9IHRoaXMuZngucmV2ZXJiLnJvb21TaXplXG4gICAgfVxuICB9LFxuICAnZGVsYXkuMS82Jzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzYsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41IH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSApXG4gICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5meC5kZWxheS5mZWVkYmFja1xuICAgICAgdGhpcy50aW1lID0gdGhpcy5meC5kZWxheS50aW1lXG4gICAgfVxuICB9LFxuICAnZGVsYXkuMS8zJzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzMsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5OjEgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmZ4LmRlbGF5IClcbiAgICAgIHRoaXMuZmVlZGJhY2sgPSB0aGlzLmZ4LmRlbGF5LmZlZWRiYWNrXG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLmZ4LmRlbGF5LnRpbWVcbiAgICB9XG4gIH0sIFxuICAnZGVsYXkuMS82LmZiJzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzYsIGZlZWRiYWNrOi44MjUsIHdldGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5kZWxheSApIFxuICAgIH1cbiAgfSxcbiAgJ2RlbGF5LjEvMy5mYic6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS8zLCBmZWVkYmFjazouODI1LCB3ZXRkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZGVsYXkgKVxuICAgIH1cbiAgfSxcbiAgJ2RlbGF5LjEvNSc6IHtcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmRlbGF5ID0gYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS81LCBmZWVkYmFjazouMzUsIHdldGRyeToxIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5meC5kZWxheSApXG4gICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5meC5kZWxheS5mZWVkYmFja1xuICAgICAgdGhpcy50aW1lID0gdGhpcy5meC5kZWxheS50aW1lXG4gICAgfVxuICB9LFxuICAnZGVsYXkuMS84Jzoge1xuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzgsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5OjEgfSlcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmZ4LmRlbGF5IClcbiAgICAgIHRoaXMuZmVlZGJhY2sgPSB0aGlzLmZ4LmRlbGF5LmZlZWRiYWNrXG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLmZ4LmRlbGF5LnRpbWVcbiAgICB9XG4gIH0sXG4gICdkZWxheS4xLzknOiB7XG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5kZWxheSA9IGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyB0aW1lOjEvOSwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6MSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZnguZGVsYXkgKVxuICAgIH1cbiAgfSxcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGx1c2g6IHtcbiAgICBmYXN0RnJlcXVlbmN5OjQsXG4gICAgZmFzdEdhaW46LjQyNSxcbiAgICBzbG93R2FpbjozLjUsXG4gICAgc2xvd0ZyZXF1ZW5jeToxLFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIGNvbnN0IGdlbiA9IGF1ZGlvLkdlbi51Z2Vuc1xuICAgICAgdGhpcy5tb2QxID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5jeWNsZSguMSkgKS5jb25uZWN0KCB0aGlzLmZhc3RGcmVxdWVuY3kgKVxuICAgICAgLy90aGlzLmZhc3RHYWluID0gIGF1ZGlvLkdlbi5tYWtlKCBnZW4uYWRkKCAuNDI1LCBnZW4uY3ljbGUoLjEpICkgKVxuICAgICAgdGhpcy5tb2QyID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5jeWNsZSguMDUpICkuY29ubmVjdCggdGhpcy5zbG93R2FpbiApXG4gICAgICAvL3RoaXMuc2xvd0dhaW4gPSBhdWRpby5HZW4ubWFrZSggZ2VuLmFkZCggNC41LCBnZW4uY3ljbGUoLjA1KSApIClcbiAgICB9XG4gIH0sXG5cbiAgd2FyYmx5OiB7XG4gICAgZmFzdEZyZXF1ZW5jeTo0LFxuICAgIHNsb3dHYWluOjMsXG4gICAgc2xvd0ZyZXF1ZW5jeToxLFxuICAgIGZhc3RHYWluOjEuNSxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLm1vZDEgPSBhdWRpby5HZW4ubWFrZSggYXVkaW8uR2VuLnVnZW5zLmN5Y2xlKC4xKSApLmNvbm5lY3QoIHRoaXMuZmFzdEZyZXF1ZW5jeSApXG4gICAgICB0aGlzLm1vZDIgPSBhdWRpby5HZW4ubWFrZSggYXVkaW8uR2VuLnVnZW5zLmN5Y2xlKC4wNSkgKS5jb25uZWN0KCB0aGlzLnNsb3dHYWluIClcbiAgICB9XG4gIH1cblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICdwbHVja2VkJzoge1xuICAgIGJpYXM6LjM1LFxuICAgIGdhaW46MSxcbiAgICBkZWNheToxLzUsXG4gICAgcHJlZ2Fpbjo0LFxuICAgIGRlc2NyaXB0aW9uOidhIHNob3J0LCBjbGVhbiBzb3VuZGluZyBwcmVzZXQgd2l0aCBhIG1pbmltdW0gb2YgZGlzdG9ydGlvbi93YXZlZm9sZGluZy4nXG4gIH0sXG4gIFxuICAncGVyYyc6IHtcbiAgICBiaWFzOi4zNSxcbiAgICBnYWluOjEsXG4gICAgZGVjYXk6MS81LFxuICAgIHByZWdhaW46NSxcbiAgICBkZXNjcmlwdGlvbjonYSBzaG9ydCwgY2xlYW4gc291bmRpbmcgcHJlc2V0IHdpdGggYSBtaW5pbXVtIG9mIGRpc3RvcnRpb24vd2F2ZWZvbGRpbmcuJ1xuICB9LFxuXG4gIHN0YWI6IHtcbiAgICB3YXZlZm9ybTonc2F3JywgXG4gICAgZGVjYXk6MS80LCBcbiAgICBiaWFzOi4xLCBcbiAgICBmaWx0ZXJNdWx0OjAsIFxuICAgIGN1dG9mZjouOCwgXG4gICAgUTouMTUsIFxuICAgIHByZWdhaW46MTAsIFxuICAgIHBvc3RnYWluOi4yNSwgXG4gICAgZmlsdGVyTW9kZWw6MiwgXG4gICAgc2F0dXJhdGlvbjo1MCxcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZngucHVzaCggYXVkaW8uZWZmZWN0cy5EaXN0b3J0aW9uKCdlYXJzaHJlZCcpIClcbiAgICB9LFxuICAgIGRlc2NyaXB0aW9uOidhIHNob3J0LCBoZWF2aWx5IGRpc3RvcnRlZCBhbmQgZmlsdGVyZWQgc291bmQuIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBDb21wbGV4IHdhdmVmb2xkaW5nLCB0aGlzIHByZXNldCBhbHNvIGFkZHMgYW4gYWRkaXRpb25hbCBEaXN0b3J0aW9uIGVmZmVjdCAocHJlc2V0IGVhcnNyZWQpLidcbiAgfVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJzEvMycgOiB7XG4gICAgdGltZToxLzMsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5OjEgXG4gIH0sXG4gICcxLzYnIDoge1xuICAgIHRpbWU6MS82LCBmZWVkYmFjazouMzUsIHdldGRyeToxXG4gIH0sXG4gICcxLzgnIDoge1xuICAgIHRpbWU6MS84LCBmZWVkYmFjazouMzUsIHdldGRyeToxXG4gIH0sXG4gICcxLzknIDoge1xuICAgIHRpbWU6MS85LCBmZWVkYmFjazouMzUsIHdldGRyeToxXG4gIH0sXG4gICcxLzMuZmInIDoge1xuICAgIHRpbWU6MS8zLCBmZWVkYmFjazouODUsIHdldGRyeToxIFxuICB9LFxuICAnMS82LmZiJyA6IHtcbiAgICB0aW1lOjEvNiwgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS84LmZiJyA6IHtcbiAgICB0aW1lOjEvOCwgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS85LmZiJyA6IHtcbiAgICB0aW1lOjEvOSwgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6MVxuICB9LFxuICAnMS8zLmRyeScgOiB7XG4gICAgdGltZToxLzMsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41IFxuICB9LFxuICAnMS82LmRyeScgOiB7XG4gICAgdGltZToxLzYsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41XG4gIH0sXG4gICcxLzguZHJ5JyA6IHtcbiAgICB0aW1lOjEvOCwgZmVlZGJhY2s6LjM1LCB3ZXRkcnk6LjVcbiAgfSxcbiAgJzEvOS5kcnknIDoge1xuICAgIHRpbWU6MS85LCBmZWVkYmFjazouMzUsIHdldGRyeTouNVxuICB9LFxuICAnMS8zLmRyeS5mYicgOiB7XG4gICAgdGltZToxLzMsIGZlZWRiYWNrOi44NSwgd2V0ZHJ5Oi41IFxuICB9LFxuICAnMS82LmRyeS5mYicgOiB7XG4gICAgdGltZToxLzYsIGZlZWRiYWNrOi4zNSwgd2V0ZHJ5Oi41XG4gIH0sXG4gICcxLzguZHJ5LmZiJyA6IHtcbiAgICB0aW1lOjEvOCwgZmVlZGJhY2s6Ljg1LCB3ZXRkcnk6LjVcbiAgfSxcbiAgJzEvOS5kcnkuZmInIDoge1xuICAgIHRpbWU6MS85LCBmZWVkYmFjazouODUsIHdldGRyeTouNVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjcnVuY2g6IHtcbiAgICBwcmVnYWluOjEwLCBcbiAgICBwb3N0Z2FpbjouMzVcbiAgfSxcblxuICBlYXJzaHJlZDoge1xuICAgcHJlZ2FpbjogNTAwLFxuICAgcG9zdGdhaW46IC4wNixcbiAgIHNoYXBlMTogLjAwMSxcbiAgIHNoYXBlMjogLTNcbiAgfSxcblxuICBiYXNzOiB7XG4gICAgcHJlZ2FpbjoxMCxcbiAgICBwb3N0Z2FpbjouMzUsXG4gICAgc2hhcGUxOjMsXG4gICAgc2hhcGUyOjEwXG4gIH0sXG5cbiAgbWVkaXVtOiB7XG4gICAgcHJlZ2Fpbjo0MCxcbiAgICBwb3N0Z2FpbjouMTI1LzRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgZWFyc2hyZWQ6IHtcbiAgICAvLyB1bmZvcnR1bmF0ZWx5IHlvdSBjYW4ndCB3cml0ZSBub3JtYWwgcHJlc2V0cyBmb3JcbiAgICAvLyBEcnVtcyBhbmQgRURydW1zLCBiZWNhdXNlIHRoZXkgZG9uJ3QgZ28gdGhyb3VnaFxuICAgIC8vIHRoZSBVZ2VuIGNvbnN0cnVjdG9yIGluIHRoZSB0eXBpY2FsIHdheSAodGhleSBhcmVcbiAgICAvLyBwcm9jZXNzZWQgYXMgYnVzc2VzKS4gSXQgd291bGQgYWxzb1xuICAgIC8vIGJlIGRpZmZpY3VsdCB0byBkZWZpbmUgcHJvcGVydGllcyBmb3IgdGhlIGluZGl2aWR1YWxcbiAgICAvLyBkcnVtIGNvbXBvbmVudHMgKHNuYXJlLGtpY2sgZXRjLikgdXNpbmcgdGhlIHN0YW5kYXJkXG4gICAgLy8gcHJlc2V0IGZvcm1hdC4gRm9yIHRoZXNlIHJlYXNvbnMsIGFsbCBwcm9wZXJ0eSBhc3NpZ25tZW50XG4gICAgLy8gbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uIFxuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5hZGQoIGF1ZGlvLmVmZmVjdHMuRGlzdG9ydGlvbignZWFyc2hyZWQnKSApXG4gICAgfVxuICB9LFxuXG4gIGhwZjoge1xuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgLy8gWFhYIGhhdmUgdG8gc3BlY2lmeSBpbnB1dCBiZWNhdXNlIG9mIGZpbHRlciBlcnJvcnMuLi5cbiAgICAgIGNvbnN0IGhwZiA9IGF1ZGlvLmZpbHRlcnMuRmlsdGVyMTJCaXF1YWQoeyBpbnB1dDp0aGlzLCBtb2RlOjEsIGN1dG9mZjouMjUsIFE6LjUsIGlzU3RlcmVvOnRydWUgfSlcbiAgICAgIHRoaXMuZnguYWRkKCBocGYgKVxuICAgICAgdGhpcy5ocGYgPSBocGZcbiAgIH1cbiAgfSxcbiAgbHBmOiB7XG4gICAgcHJlc2V0SW5pdCggYXVkaW8gKSB7XG4gICAgICAvLyBYWFggaGF2ZSB0byBzcGVjaWZ5IGlucHV0IGJlY2F1c2Ugb2YgZmlsdGVyIGVycm9ycy4uLlxuICAgICAgY29uc3QgbHBmID0gYXVkaW8uZmlsdGVycy5GaWx0ZXIyNE1vb2coeyBpbnB1dDp0aGlzLCBtb2RlOjAsIGN1dG9mZjouMjUsIFE6Ljc1LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggbHBmIClcbiAgICAgIHRoaXMubHBmID0gbHBmXG4gICAgfVxuICB9XG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGVhcnNocmVkOiB7XG4gICAgLy8gdW5mb3J0dW5hdGVseSB5b3UgY2FuJ3Qgd3JpdGUgbm9ybWFsIHByZXNldHMgZm9yXG4gICAgLy8gRHJ1bXMgYW5kIEVEcnVtcywgYmVjYXVzZSB0aGV5IGRvbid0IGdvIHRocm91Z2hcbiAgICAvLyB0aGUgVWdlbiBjb25zdHJ1Y3RvciBpbiB0aGUgdHlwaWNhbCB3YXkgKHRoZXkgYXJlXG4gICAgLy8gcHJvY2Vzc2VkIGFzIGJ1c3NlcykuIEl0IHdvdWxkIGFsc29cbiAgICAvLyBiZSBkaWZmaWN1bHQgdG8gZGVmaW5lIHByb3BlcnRpZXMgZm9yIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gZHJ1bSBjb21wb25lbnRzIChzbmFyZSxraWNrIGV0Yy4pIHVzaW5nIHRoZSBzdGFuZGFyZFxuICAgIC8vIHByZXNldCBmb3JtYXQuIEZvciB0aGVzZSByZWFzb25zLCBhbGwgcHJvcGVydHkgYXNzaWdubWVudFxuICAgIC8vIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIGluaXRpYWxpemF0aW9uLiBcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMuZnguYWRkKCBhdWRpby5lZmZlY3RzLkRpc3RvcnRpb24oJ2VhcnNocmVkJykgKVxuXG4gICAgICB0aGlzLmtpY2suZnJlcXVlbmN5ID0gNTVcbiAgICAgIHRoaXMua2ljay5kZWNheSA9IC45NzVcblxuICAgICAgdGhpcy5zbmFyZS50dW5lID0gLjI1XG4gICAgICB0aGlzLnNuYXJlLnNuYXBweSA9IDEuNVxuICAgIH1cbiAgfSxcblxuICB3YXJibHk6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIGNvbnN0IGJjID0gYXVkaW8uZWZmZWN0cy5CaXRDcnVzaGVyKHsgaW5wdXQ6dGhpcywgc2FtcGxlUmF0ZTouMzUsIGJpdERlcHRoOi41LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggYmMgKVxuICAgICAgdGhpcy5iaXRjcnVzaGVyID0gYmNcbiAgICAgIGNvbnN0IGZsYW5nZXIgPSBhdWRpby5lZmZlY3RzLkZsYW5nZXIoeyBpbnB1dDp0aGlzLCBmcmVxdWVuY3k6LjgsIGZlZWRiYWNrOi45MzUsIGlzU3RlcmVvOnRydWUgfSlcbiAgICAgIHRoaXMuZnguYWRkKCBmbGFuZ2VyIClcbiAgICAgIHRoaXMuZmxhbmdlciA9IGZsYW5nZXJcbiAgICAgIHRoaXMuZ2Fpbi52YWx1ZSAqPSAxLjM1XG4gICB9XG4gIH0sXG4gIGhwZjoge1xuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgY29uc3QgaHBmID0gYXVkaW8uZmlsdGVycy5GaWx0ZXIxMkJpcXVhZCh7IGlucHV0OnRoaXMsIG1vZGU6MSwgY3V0b2ZmOi4zNSwgaXNTdGVyZW86dHJ1ZSB9KVxuICAgICAgdGhpcy5meC5hZGQoIGhwZiApXG4gICAgICB0aGlzLmhwZiA9IGhwZlxuICAgfVxuICB9LFxuICBscGY6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIGNvbnN0IGxwZiA9IGF1ZGlvLmZpbHRlcnMuRmlsdGVyMjRNb29nKHsgaW5wdXQ6dGhpcywgbW9kZToxLCBjdXRvZmY6LjM1LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggbHBmIClcbiAgICAgIHRoaXMubHBmID0gbHBmXG4gICAgfVxuICB9LFxuICBzaG9ydDoge1xuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgdGhpcy5raWNrLmRlY2F5ID0gLjhcbiAgICAgIHRoaXMuc25hcmUuZGVjYXkgPSAuMDVcbiAgICAgIHRoaXMuY2xvc2VkSGF0LmRlY2F5ID0gLjA1XG4gICAgICB0aGlzLm9wZW5IYXQuZGVjYXkgPSAuMlxuICAgICAgdGhpcy5jb3diZWxsLmRlY2F5ID0gLjFcbiAgICB9XG4gIH0sXG4gIGxvbmc6IHtcbiAgICBwcmVzZXRJbml0KCBhdWRpbyApIHtcbiAgICAgIHRoaXMua2ljay5kZWNheSA9IC45NzVcbiAgICAgIHRoaXMuc25hcmUuZGVjYXkgPSAuMVxuICAgICAgdGhpcy5jbG9zZWRIYXQuZGVjYXkgPSAuMVxuICAgICAgdGhpcy5vcGVuSGF0LmRlY2F5ID0gLjI1XG4gICAgfVxuICB9XG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBtb2RlcmF0ZToge1xuICAgIGZlZWRiYWNrOiAuMjUsXG4gICAgZnJlcXVlbmN5Oi41LFxuICAgIG9mZnNldDouMVxuICB9LFxuXG4gIGV4dHJlbWU6IHtcbiAgICBmZWVkYmFjazouODUsXG4gICAgb2Zmc2V0Oi4wNSxcbiAgICBmcmVxdWVuY3k6NFxuICB9LFxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBiYXNzIDoge1xuICAgIGNtUmF0aW86MSxcbiAgICBpbmRleDozLFxuICAgIGF0dGFjazoxLzI1NixcbiAgICBkZWNheToxLzE2LFxuICAgIG9jdGF2ZTotMlxuICB9LFxuICBkZWVwYmFzcyA6IHtcbiAgICBjbVJhdGlvOjEsXG4gICAgaW5kZXg6MyxcbiAgICBhdHRhY2s6MS8yNTYsXG4gICAgZGVjYXk6MS8yLFxuICAgIG9jdGF2ZTotMyxcbiAgICBmZWVkYmFjazouMDA1XG4gIH0sXG4gIGtpY2s6e1xuICAgIGF0dGFjayA6IDEvNDA5NixcbiAgICBpbmRleCA6IDUsXG4gICAgY21SYXRpbyA6IDQvMyxcbiAgICBkZWNheSA6IDEvNCxcbiAgICBvY3RhdmUgOiAtMyxcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnXG4gIH0sXG5cbiAgcGVyYzp7XG4gICAgYXR0YWNrIDogMS80MDk2LFxuICAgIGluZGV4IDogLjUsXG4gICAgY21SYXRpbyA6IDQvMyxcbiAgICBkZWNheSA6IDEvOCxcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnLFxuICAgIHByZXNldEluaXQ6IGZ1bmN0aW9uKCBhdWRpbyApIHtcbiAgICAgIGlmKCB0aGlzLnZvaWNlcyAmJiB0aGlzLnZvaWNlcy5sZW5ndGggPiAxICkge1xuICAgICAgICB0aGlzLnNwcmVhZCggLjk5IClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgJ2Jhc3MuZWxlY3RybycgOiB7XG4gICAgY21SYXRpbzoxLFxuICAgIGluZGV4OjMsXG4gICAgYXR0YWNrOjEvMjU2LFxuICAgIGRlY2F5OjEvMTYsXG4gICAgb2N0YXZlOi0yLFxuICAgIGZpbHRlck1vZGVsOjIsXG4gICAgc2F0dXJhdGlvbjoyMDAsXG4gICAgUTouMjUsXG4gICAgY3V0b2ZmOi42ODM1XG4gIH0sXG5cbiAgZ2xvY2tlbnNwaWVsIDoge1xuICAgIGNtUmF0aW9cdDogMy41MzA3LFxuICAgIGluZGV4IFx0OiAxLFxuICAgIGF0dGFja1x0OiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyggMSApLFxuICAgIGRlY2F5XHQ6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCAxMDAwICksXG4gIH0sXG5cbiAgJ2dsb2NrZW5zcGllbC5zaG9ydCcgOiB7XG4gICAgY21SYXRpb1x0OiAzLjUzMDcsXG4gICAgaW5kZXggXHQ6IDEsXG4gICAgYXR0YWNrXHQ6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCAxICksXG4gICAgZGVjYXlcdCAgOiAxLzEyLFxuICAgIG9jdGF2ZSAgOiAxLFxuICAgIGdhaW4gICAgOi4wNSBcbiAgfSxcblxuICBmcm9nIDogeyAvL2xqcFxuICAgIGNtUmF0aW86IDAuMSxcbiAgICBpbmRleDogMi4wLFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoIDMwMCApLCBcbiAgICBkZWNheTogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoIDUgKVxuICB9LFxuXG4gIGdvbmcgOiB7XG4gICAgY21SYXRpbzogMS40LFxuXHQgIGluZGV4OiAuOTUsXG5cdCAgYXR0YWNrOiAxLzI1Nixcblx0ICBkZWNheTogMixcblx0fSxcblxuICBkcnVtIDoge1xuXHQgIGNtUmF0aW86IDEuNDAwMDcsXG5cdCAgaW5kZXg6IDIsXG5cdCAgYXR0YWNrOiAxLzIwNDgsXG4gICAgZGVjYXk6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKDEwMDApIFxuXHR9LFxuXG5cdGRydW0yOiB7XG5cdFx0Y21SYXRpbzogMSArIE1hdGguc3FydCgyKSxcblx0XHRpbmRleDogLjIsXG5cdFx0YXR0YWNrOiAxLzI1Nixcblx0XHRkZWNheTogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoMjApIFxuICB9LFxuXG5cdGJyYXNzIDoge1xuICAgIG1heFZvaWNlczo0LFxuXHQgIGNtUmF0aW8gOiAxIC8gMS4wMDA3LFxuXHRcdGluZGV4XHQ6IDUsXG5cdFx0YXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxMDApLFxuXHRcdGRlY2F5XHQ6IDEsXG4gICAgZ2FpbjouNSxcbiAgfSxcblxuXHRjbGFyaW5ldCA6IHtcblx0XHRjbVJhdGlvXHQ6IDMgLyAyLFxuXHRcdGluZGV4XHQ6IDEuNSxcblx0XHRhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCA1MCApLCBcblx0XHRkZWNheTogIGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKCAyMDAgKVxuICB9LFxuXG4gIGZ1biA6IHtcbiAgICBkZWNheToxLzIsXG4gICAgZmVlZGJhY2s6IC4wMDE1LFxuICAgIGdhaW46LjFcbiAgfSxcblxuICBjaGlycDoge1xuXHRcdGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoIDEgKSwgXG4gICAgaW5kZXggOiAxLjE1LFxuICAgIGdsaWRlIDogMSxcbiAgICBmZWVkYmFjayA6IC41LFxuICAgIGNtUmF0aW8gOiAxLjUsXG4gICAgZGVjYXkgOiAxLzQsXG4gICAgb2N0YXZlIDogMSxcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBzaG9ydDoge1xuICAgIGRlY2F5Oi4wMVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkZWVwOiB7XG4gICAgZnJlcXVlbmN5OjU1LFxuICAgIGRlY2F5Oi45NixcbiAgfSxcblxuICB0aWdodDoge1xuICAgIGZyZXF1ZW5jeTo4MCwgXG4gICAgZGVjYXk6Ljg1LFxuICAgIHRvbmU6LjVcbiAgfSxcblxuICBsb25nOiB7XG4gICAgZnJlcXVlbmN5OjgwLFxuICAgIGRlY2F5Oi45NzUsXG4gIH0sXG5cbiAgYm9vbToge1xuICAgIGZyZXF1ZW5jeTo1NSxcbiAgICBkZWNheTouOTksXG4gICAgdG9uZTouMDVcbiAgfVxuXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICdzaG9ydC5kcnknIDogeyBcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKC4yNSksIFxuICAgIGRlY2F5OiAxLzEyLFxuICAgIGN1dG9mZjouMyxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck11bHQ6M1xuICB9LFxuXG4gIGFycHkgOiB7XG4gICAgYW50aWFsaWFzOnRydWUsXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcyguNSksXG4gICAgZGVjYXk6IDEvMTYsIFxuICAgIGdhaW46MC4yLFxuICAgIGN1dG9mZjouMTUsXG4gICAgZmlsdGVyTXVsdDoxLFxuICAgIFE6LjMsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNb2RlOjFcbiAgfSxcblxuICBsZWFkIDoge1xuICAgIHByZXNldEluaXQgOiBmdW5jdGlvbiggYXVkaW8gKSB7IHRoaXMuZngucHVzaCggYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouNjUgfSkgKSAgfSxcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKC41KSxcbiAgICBkZWNheTogMS8yLCBcbiAgICBvY3RhdmUzOjAsXG4gICAgY3V0b2ZmOjEsXG4gICAgZmlsdGVyTXVsdDoyLjUsXG4gICAgUTouOTc1LFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTW9kZToxXG4gIH0sXG4gIC8vIG5vdCBhcyBicmlnaHQgLyBsb3VkXG4gIGxlYWQyIDoge1xuICAgIHByZXNldEluaXQgOiBmdW5jdGlvbiggYXVkaW8gKSB7IHRoaXMuZngucHVzaCggYXVkaW8uZWZmZWN0cy5EZWxheSh7IHRpbWU6MS82LCBmZWVkYmFjazouNjUgfSkgKSAgfSxcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKC41KSxcbiAgICBkZWNheTogMS8yLCBcbiAgICBvY3RhdmUzOjAsXG4gICAgY3V0b2ZmOjEsXG4gICAgZmlsdGVyTXVsdDoyLjUsXG4gICAgUTouOCxcbiAgICBnYWluOi4xNzUsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNb2RlOjFcbiAgfSxcblxuICBkaXJ0eTogeyBcbiAgICBnYWluOi4zMjUsXG4gICAgZmlsdGVyTW9kZWw6MixcbiAgICBhdHRhY2s6MS8yMDQ4LCBcbiAgICBkZWNheToxLzQsIFxuICAgIGN1dG9mZjoxLjUsIFxuICAgIGZpbHRlck11bHQ6NCwgXG4gICAgc2F0dXJhdGlvbjoxMDAwMCwgXG4gICAgUTouMjI1LCBcbiAgICBkZXR1bmUyOi0uNTA1LFxuICAgIGRldHVuZTM6LS41MDc1LFxuICAgIG9jdGF2ZTotMixcbiAgICB3YXZlZm9ybToncHdtJywgXG4gICAgcHVsc2V3aWR0aDouMTUgXG4gIH0sXG5cbiAgd2luc29tZSA6IHtcbiAgICBwcmVzZXRJbml0IDogZnVuY3Rpb24oIGF1ZGlvICkgeyBcbiAgICAgIHRoaXMubGZvID0gYXVkaW8ub3NjaWxsYXRvcnMuU2luZSh7IGZyZXF1ZW5jeToyLCBnYWluOi4wNzUgfSlcbiAgICAgIHRoaXMubGZvLmNvbm5lY3QoIHRoaXMuY3V0b2ZmIClcbiAgICAgIHRoaXMubGZvLmNvbm5lY3QoIHRoaXMuZGV0dW5lMiApXG4gICAgICB0aGlzLmxmby5jb25uZWN0KCB0aGlzLmRldHVuZTMgKVxuICAgIH0sXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxKSwgXG4gICAgZGVjYXk6MSxcbiAgICBjdXRvZmY6LjIsXG4gIH0sXG5cbiAgcGx1Y2tFY2hvOiB7XG4gICAgcHJlc2V0SW5pdCA6IGZ1bmN0aW9uKCBhdWRpbyApIHsgdGhpcy5meC5wdXNoKCBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzYsIGZlZWRiYWNrOi42NSB9KSApICB9LFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoLjEpLFxuICAgIGRlY2F5OiAxLzE2LCBcbiAgICBvY3RhdmUzOjAsXG4gICAgY3V0b2ZmOi4xNSxcbiAgICBmaWx0ZXJNdWx0OjEsXG4gICAgUTouNSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck1vZGU6MSxcbiAgICBwYW5Wb2ljZXM6dHJ1ZVxuICB9LFxuXG4gIGJhc3NQYWQgOiB7IFxuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoLjEpLFxuICAgIGRlY2F5OiAyLFx0XG4gICAgb2N0YXZlOi00LFxuICAgIGN1dG9mZjogLjIyNSxcbiAgICBmaWx0ZXJNdWx0OjMuNSxcbiAgICBROi41LFxuICAgIGRldHVuZTI6MS4wMTI1LFxuICAgIGRldHVuZTM6MS0uMDEyNVxuICB9LFxuXG4gIHdhcmJsZSA6IHsgXG4gICAgYXR0YWNrOiBhdWRpbyA9PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheTogMS8yLFx0XG4gICAgb2N0YXZlOiAtMyxcbiAgICBvY3RhdmUyIDogLTEsXG4gICAgY3V0b2ZmOiAuOCxcbiAgICBmaWx0ZXJNdWx0OjMsXG4gICAgUTouNzUsXG4gICAgZGV0dW5lMjouMDI3NSxcbiAgICBkZXR1bmUzOi0uMDI3NVxuICB9LCBcbiAgZGFyazogeyBcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKDEpLFxuICAgIGRlY2F5OiAxLFx0XG4gICAgb2N0YXZlOiAtMyxcbiAgICBvY3RhdmUyIDogLTEsXG4gICAgY3V0b2ZmOiAxLjUsXG4gICAgZmlsdGVyTXVsdDozLFxuICAgIFE6Ljc1LFxuICAgIGRldHVuZTI6LjAxMjUsXG4gICAgZGV0dW5lMzotLjAxMjVcbiAgfSxcbiAgYmFzczogeyBcbiAgICBhdHRhY2s6IGF1ZGlvID0+IGF1ZGlvLkNsb2NrLm1zKDEpLFxuICAgIGRlY2F5OiAxLzQsXHRcbiAgICBvY3RhdmU6IC0zLFxuICAgIGN1dG9mZjogLjM1LFxuICAgIGZpbHRlck11bHQ6MyxcbiAgICBROi4xNSxcbiAgICBnbGlkZToxMjUwLFxuICAgIHdhdmVmb3JtOidwd20nLFxuICAgIHB1bHNld2lkdGg6LjQ1LFxuICAgIGRldHVuZTI6LjAwNSxcbiAgICBkZXR1bmUzOi0uMDA1XG4gIH0sXG4gIGJhc3MyIDoge1xuICAgIGF0dGFjazogYXVkaW8gPT4gYXVkaW8uQ2xvY2subXMoMSksIFxuICAgIGRlY2F5Olx0MS82LFxuICAgIG9jdGF2ZTogLTIsXG4gICAgb2N0YXZlMiA6IDAsXG4gICAgb2N0YXZlMyA6IDAsICAgICAgXG4gICAgY3V0b2ZmOiAuNSxcbiAgICBmaWx0ZXJNdWx0OjIsXG4gICAgUTouNSxcbiAgICBnYWluOi4zNVxuICB9LFxuICBcbiAgZWRneToge1xuICAgIGRlY2F5OjEvOCxcbiAgICBhdHRhY2s6MS8xMDI0LFxuICAgIG9jdGF2ZTogLTIsXG4gICAgb2N0YXZlMjogLTEsXG4gICAgY3V0b2ZmOiAuNSxcbiAgICBmaWx0ZXJNdWx0OjMsXG4gICAgUTouNzUsIFxuICAgIHdhdmVmb3JtOidwd20nLCBcbiAgICBwdWxzZXdpZHRoOi4yLFxuICAgIGRldHVuZTI6MCxcbiAgICBnYWluOi4yXG4gIH0sXG5cbiAgZWFzeSA6IHtcbiAgICBhdHRhY2s6IGF1ZGlvPT4gYXVkaW8uQ2xvY2subXMoMSksXG4gICAgZGVjYXk6MixcbiAgICBjdXRvZmY6LjMsXG4gICAgZ2xpZGU6Ljk5OTUsXG4gIH0sXG4gIFxuICBlYXN5ZnggOiB7XG4gICAgYXR0YWNrOiBhdWRpbz0+IGF1ZGlvLkNsb2NrLm1zKDEpLFxuICAgIGRlY2F5OjIsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5hZGQoIGF1ZGlvLmVmZmVjdHMuRGVsYXkoIENsb2NrLnRpbWUoMS82KSwgLjMpIClcbiAgICB9LFxuICAgIGN1dG9mZjouMTI1LFxuICAgIGdsaWRlOjEwMDAsXG4gICAgZGV0dW5lMjouMDAxLFxuICAgIGRldHVuZTM6LS4wMDEsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNdWx0OjQsXG4gICAgUTouNSxcbiAgfSxcbiAgY2hvcmRzOiB7XG4gICAgYXR0YWNrOiBhdWRpbz0+IGF1ZGlvLkNsb2NrLm1zKDEpLFxuICAgIGRlY2F5OjEvMixcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmFkZCggYXVkaW8uZWZmZWN0cy5EZWxheSggQ2xvY2sudGltZSgxLzYpLCAuNSkgKVxuICAgIH0sXG4gICAgYW1wOi4zLFxuICAgIG9jdGF2ZTI6MCxcbiAgICBvY3RhdmUzOjAsXG4gICAgY3V0b2ZmOi41LFxuICAgIGdsaWRlOi45OTk1LFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgZmlsdGVyTXVsdDozLFxuICAgIFE6Ljc1LFxuICB9LFxuXG4gIHdhbmRlcjoge1xuICAgIGF0dGFjazogMS8yLFxuICAgIGRlY2F5OiAgMixcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7fSxcbiAgICBhbXA6LjIsXG4gICAgZGV0dW5lMjouNTAxLFxuICAgIGRldHVuZTM6LS41MDEsXG4gICAgY3V0b2ZmOi4yLFxuICAgIGdsaWRlOjUwMDAsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBmaWx0ZXJNdWx0OjEuNSxcbiAgICBROi4yNSxcbiAgfSxcblxuICAnY2hvcmRzLnNob3J0Jzoge1xuICAgIGF0dGFjazogYXVkaW89PiBhdWRpby5DbG9jay5tcygxKSxcbiAgICBkZWNheToxLzgsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5kZWxheSA9IGF1ZGlvLmVmZmVjdHMuRGVsYXkoeyBkZWxheTphdWRpby5DbG9jay50aW1lKDEvOCksIGZlZWRiYWNrOi41LCB3ZXRkcnk6LjI1IH0pIFxuICAgICAgdGhpcy5meC5wdXNoKCB0aGlzLmRlbGF5IClcbiAgICB9LFxuICAgIGFtcDouMyxcbiAgICBvY3RhdmUyOjAsXG4gICAgb2N0YXZlMzowLFxuICAgIGN1dG9mZjouMzUsXG4gICAgZ2xpZGU6MSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck11bHQ6MyxcbiAgICBROi41LFxuICB9LFxuXG4gIGp1bXA6IHsgXG4gICAgZGVjYXk6MS8yMDQ4LCBcbiAgICB1c2VBRFNSOnRydWUsIFxuICAgIHN1c3RhaW46MS80LCBcbiAgICByZWxlYXNlOjEvMTAyNCwgIFxuICAgIG1heFZvaWNlczozLCBcbiAgICBjdXRvZmY6MzUsIFxuICAgIGZpbHRlck11bHQ6MCxcbiAgICBkZXR1bmUyOi4wMSxcbiAgICBkZXR1bmUzOi0uMDEgXG4gIH0sXG5cbiAgc2hpbnliYXNzMjoge1xuICAgIFE6LjEyNSxcbiAgICBjdXRvZmY6MzUsXG4gICAgdXNlQURTUjp0cnVlLFxuICAgIGRlY2F5OjEvMTAsXG4gICAgc3VzdGFpbjoxLzQsXG4gICAgZmlsdGVyTXVsdDowLFxuICAgIHJlbGVhc2U6MS8xMDI0LFxuICAgIG9jdGF2ZTotMyxcbiAgICBwYW5Wb2ljZXM6dHJ1ZVxuICB9LFxuICBzaGlueWJhc3M6IHtcbiAgICBROi4xMjUsXG4gICAgY3V0b2ZmOjUsXG4gICAgdXNlQURTUjpmYWxzZSxcbiAgICBhdHRhY2s6MS8xMDI0LFxuICAgIGRlY2F5OjEvMTAsXG4gICAgZmlsdGVyTXVsdDowLFxuICAgIG9jdGF2ZTotMyxcbiAgICBwYW5Wb2ljZXM6dHJ1ZVxuICB9LFxuXG4gICdiYXNzLm11dGVkJzoge1xuICAgIFE6LjQ1LFxuICAgIGN1dG9mZjouNSxcbiAgICB1c2VBRFNSOnRydWUsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJyxcbiAgICBkZWNheToxLzgsXG4gICAgc3VzdGFpbjoxLzQsXG4gICAgcmVsZWFzZToxLzEwMjQsXG4gICAgb2N0YXZlOi0zLFxuICAgIHBhblZvaWNlczp0cnVlLFxuICAgIGZpbHRlck11bHQ6LjVcbiAgfSxcbiAgJ2Jhc3Muc3RhYic6IHtcbiAgICBROi4zNSxcbiAgICBkZXR1bmUyOjEuNSxcbiAgICBkZXR1bmUzOi41LFxuICAgIGN1dG9mZjouNSxcbiAgICB1c2VBRFNSOnRydWUsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJyxcbiAgICBkZWNheToxLzEwLFxuICAgIHN1c3RhaW46MS80LFxuICAgIHJlbGVhc2U6MS8xMDI0LFxuICAgIG9jdGF2ZTotMyxcbiAgICBmaWx0ZXJNdWx0OjEuODUsXG4gICAgZ2FpbjouNzVcbiAgfSxcbiAgc2hvcnQ6IHsgXG4gICAgYXR0YWNrOjEvNDA5NixcbiAgICBkZWNheToxLzE2LCBcbiAgICBtYXhWb2ljZXM6MywgXG4gICAgY3V0b2ZmOjEuNSwgXG4gICAgZmlsdGVyTXVsdDowLFxuICAgIHVzZUFEU1I6ZmFsc2UsXG4gICAgZ2FpbjouNVxuICB9LFxuXG4gIG5vaXNlOiB7XG4gICAgZGVjYXk6MS8yLFxuICAgIGN1dG9mZjouMyxcbiAgICBnbGlkZToxMDAwMCxcbiAgICBkZXR1bmUzOjAsXG4gICAgZGV0dW5lMjowLFxuICAgIGZpbHRlck11bHQ6MCxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7IHRoaXMuZnguYWRkKCBhdWRpby5lZmZlY3RzLkdhaW4oLjEpLCBhdWRpby5lZmZlY3RzLkRlbGF5KDEvNiwuNzUpICkgfVxuICB9LFxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBkcnVtczogeyBcbiAgICBmaWxlczpbXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2ljay53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2hhdC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL3NuYXJlLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvb3BlbmhhdC53YXYnXG4gICAgXSxcbiAgICBwcmVzZXRJbml0KCkge1xuICAgICAgdGhpcy5sZW5ndGggPSA0XG4gICAgfVxuICB9LFxuICB0ZXN0OiB7XG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2sud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9vcGVuaGF0LndhdidcbiAgICBdLFxuICAgIHByZXNldEluaXQoKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDJcbiAgICB9XG4gIH0sXG4gIGJlYXRib3g6IHtcbiAgICBmaWxlczpbXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9eay53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvXnAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L150c3Mud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94Lzgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L2Eud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L2Iud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L2Qud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZWF0Ym94L2RvdC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlYXRib3gvZHVmLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9mLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9rLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9oLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9tLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVhdGJveC9uLndhdicsXG4gICAgXSxcbiAgICBwcmVzZXRJbml0KCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAxNFxuICAgIH1cbiAgfSxcbiAgYmxlZXBzOiB7XG4gICAgZmlsZXM6W1xuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDYzX19zdGFtcGVyYWRhbV9fYmxlZXAxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjRfX3N0YW1wZXJhZGFtX19ibGVlcDIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA2NV9fc3RhbXBlcmFkYW1fX2NsYXAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA2Nl9fc3RhbXBlcmFkYW1fX2NsaWNrLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjdfX3N0YW1wZXJhZGFtX19jbGljazEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA2OF9fc3RhbXBlcmFkYW1fX2cxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNjlfX3N0YW1wZXJhZGFtX19nMi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDcwX19zdGFtcGVyYWRhbV9fZzMud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3MV9fc3RhbXBlcmFkYW1fX2c0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNzJfX3N0YW1wZXJhZGFtX19nNS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDczX19zdGFtcGVyYWRhbV9fZzYud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3NF9fc3RhbXBlcmFkYW1fX2c3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwNzVfX3N0YW1wZXJhZGFtX19nOC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDc2X19zdGFtcGVyYWRhbV9fZzkud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA3N19fc3RhbXBlcmFkYW1fX2dsaXRjaC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDc4X19zdGFtcGVyYWRhbV9faGF0dC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDc5X19zdGFtcGVyYWRhbV9faGl0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwODBfX3N0YW1wZXJhZGFtX19oaXR0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvYmVudC1ibGVlcHMvNTEwODFfX3N0YW1wZXJhZGFtX19odW0ud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9iZW50LWJsZWVwcy81MTA4Ml9fc3RhbXBlcmFkYW1fX2tpay53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDgzX19zdGFtcGVyYWRhbV9fc25hci53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2JlbnQtYmxlZXBzLzUxMDg0X19zdGFtcGVyYWRhbV9fd2Eud2F2JyxcbiAgICBdLFxuICAgIHByZXNldEluaXQoKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDIyXG4gICAgfVxuICB9LFxuICBjcjcwMzA6IHtcbiAgICBmaWxlczpbXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvY3I3MDMwLzY4NjAyX19iaXJkZmx1X19ib25nbzcwMzAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9jcjcwMzAvNjg2MDNfX2JpcmRmbHVfX2NsYXZlNzAzMC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2NyNzAzMC82ODYwNl9fYmlyZGZsdV9faGF0Y2xvc2VkNzAzMC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2NyNzAzMC82ODYwN19fYmlyZGZsdV9faGF0b3BlbjcwMzAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9jcjcwMzAvNjg2MDhfX2JpcmRmbHVfX2tpY2s3MDMwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMvY3I3MDMwLzY4NjA5X19iaXJkZmx1X19zbmFyZTcwMzAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9jcjcwMzAvNjg2MTBfX2JpcmRmbHVfX3RvbTcwMzAud2F2JyxcbiAgICBdLFxuICAgIHByZXNldEluaXQoKXtcbiAgICAgIHRoaXMubGVuZ3RoID0gN1xuICAgIH1cbiAgfSxcbiAga2lja3M6IHtcbiAgICBmaWxlczpbXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjAwX19uZXRyLXNpX19raWNrLTMyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjAxX19uZXRyLXNpX19raWNrLTMzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjAyX19uZXRyLXNpX19raWNrLTI3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjAzX19uZXRyLXNpX19raWNrLTI4LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA0X19uZXRyLXNpX19raWNrLTI1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA1X19uZXRyLXNpX19raWNrLTI2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA2X19uZXRyLXNpX19raWNrLTMwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA3X19uZXRyLXNpX19raWNrLTMxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA4X19uZXRyLXNpX19raWNrLTI5LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjA5X19uZXRyLXNpX19raWNrLTMud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTFfX25ldHItc2lfX2tpY2stNDIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTJfX25ldHItc2lfX2tpY2stNDEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTNfX25ldHItc2lfX2tpY2stMzUud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTRfX25ldHItc2lfX2tpY2stMzQud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTVfX25ldHItc2lfX2tpY2stMzcud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTZfX25ldHItc2lfX2tpY2stMzYud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTdfX25ldHItc2lfX2tpY2stMzkud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMThfX25ldHItc2lfX2tpY2stMzgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMTlfX25ldHItc2lfX2tpY2stNDAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMjBfX25ldHItc2lfX2tpY2stNC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyMl9fbmV0ci1zaV9fa2ljay04Ny53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIyM19fbmV0ci1zaV9fa2ljay05LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI0X19uZXRyLXNpX19raWNrLTgzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI1X19uZXRyLXNpX19raWNrLTg0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI2X19uZXRyLXNpX19raWNrLTg1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI3X19uZXRyLXNpX19raWNrLTg2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjI4X19uZXRyLXNpX19raWNrLTgud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMjlfX25ldHItc2lfX2tpY2stODAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzBfX25ldHItc2lfX2tpY2stODEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzFfX25ldHItc2lfX2tpY2stODIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzJfX25ldHItc2lfX2tpY2stMjAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyMzNfX25ldHItc2lfX2tpY2stMi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzNF9fbmV0ci1zaV9fa2ljay0xOS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzNV9fbmV0ci1zaV9fa2ljay0xOC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzNl9fbmV0ci1zaV9fa2ljay0yNC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzN19fbmV0ci1zaV9fa2ljay0yMy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzOF9fbmV0ci1zaV9fa2ljay0yMi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTIzOV9fbmV0ci1zaV9fa2ljay0yMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0MF9fbmV0ci1zaV9fa2ljay0yNS0yLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQxX19uZXRyLXNpX19raWNrLTI1LTEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDJfX25ldHItc2lfX2tpY2stMTIud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDNfX25ldHItc2lfX2tpY2stMTEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDRfX25ldHItc2lfX2tpY2stMTAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyNDVfX25ldHItc2lfX2tpY2stMS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0Nl9fbmV0ci1zaV9fa2ljay0xNS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0N19fbmV0ci1zaV9fa2ljay0xNC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI0OF9fbmV0ci1zaV9fa2ljay0xNC0xLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjQ5X19uZXRyLXNpX19raWNrLTEzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjUwX19uZXRyLXNpX19raWNrLTE3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjUxX19uZXRyLXNpX19raWNrLTE2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjUyX19uZXRyLXNpX19raWNrLTY3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjUzX19uZXRyLXNpX19raWNrLTY4LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU0X19uZXRyLXNpX19raWNrLTY1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU1X19uZXRyLXNpX19raWNrLTY2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU2X19uZXRyLXNpX19raWNrLTYzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU3X19uZXRyLXNpX19raWNrLTY0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU4X19uZXRyLXNpX19raWNrLTYxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjU5X19uZXRyLXNpX19raWNrLTYycy53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2MF9fbmV0ci1zaV9fa2ljay02OS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI2MV9fbmV0ci1zaV9fa2ljay03LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjYyX19uZXRyLXNpX19raWNrLTc1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjYzX19uZXRyLXNpX19raWNrLTc0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY0X19uZXRyLXNpX19raWNrLTc3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY1X19uZXRyLXNpX19raWNrLTc2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY2X19uZXRyLXNpX19raWNrLTcxLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY3X19uZXRyLXNpX19raWNrLTcwLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY4X19uZXRyLXNpX19raWNrLTczLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjY5X19uZXRyLXNpX19raWNrLTcyLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjcwX19uZXRyLXNpX19raWNrLTc5LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjcxX19uZXRyLXNpX19raWNrLTc4LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjcyX19uZXRyLXNpX19raWNrLTQzLndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5MjczX19uZXRyLXNpX19raWNrLTQ0LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc0X19uZXRyLXNpX19raWNrLTQ1LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc1X19uZXRyLXNpX19raWNrLTQ2LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc2X19uZXRyLXNpX19raWNrLTQ3LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc3X19uZXRyLXNpX19raWNrLTQ4LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc4X19uZXRyLXNpX19raWNrLTQ5LndhdicsXG4gICAgICAncmVzb3VyY2VzL2F1ZGlvZmlsZXMva2lja3MvMjQ5Mjc5X19uZXRyLXNpX19raWNrLTUud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODBfX25ldHItc2lfX2tpY2stNTAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODFfX25ldHItc2lfX2tpY2stNTEud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODJfX25ldHItc2lfX2tpY2stNjAud2F2JyxcbiAgICAgICdyZXNvdXJjZXMvYXVkaW9maWxlcy9raWNrcy8yNDkyODNfX25ldHItc2lfX2tpY2stNi53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4NF9fbmV0ci1zaV9fa2ljay01OS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4NV9fbmV0ci1zaV9fa2ljay01OC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4Nl9fbmV0ci1zaV9fa2ljay01Ny53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4N19fbmV0ci1zaV9fa2ljay01Ni53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4OF9fbmV0ci1zaV9fa2ljay01NS53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI4OV9fbmV0ci1zaV9fa2ljay01NC53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI5MF9fbmV0ci1zaV9fa2ljay01My53YXYnLFxuICAgICAgJ3Jlc291cmNlcy9hdWRpb2ZpbGVzL2tpY2tzLzI0OTI5MV9fbmV0ci1zaV9fa2ljay01Mi53YXYnLFxuICAgIF0sXG4gICAgcHJlc2V0SW5pdCgpIHsgdGhpcy5sZW5ndGggPSA5MCB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICdzcGFjZSc6IHtcbiAgICByb29tU2l6ZTouOTg1LCBcbiAgICBkcnk6MSBcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgc25hcHB5OiB7XG4gICAgZGVjYXk6LjEyNSxcbiAgICBzbmFwcHk6MS41LFxuICAgIHR1bmU6LjFcbiAgfSxcblxuICBkdWxsOiB7XG4gICAgc25hcHB5Oi4xNSxcbiAgICBkZWNheTouMTUsXG4gICAgdHVuZTotLjFcbiAgfVxuXG59XG4iLCIgY29uc3QgbmFtZXMgPSBbXG4gICAgXCJBY291c3RpYyBHcmFuZCBQaWFub1wiLFxuICAgIFwiQnJpZ2h0IEFjb3VzdGljIFBpYW5vXCIsXG4gICAgXCJFbGVjdHJpYyBHcmFuZCBQaWFub1wiLFxuICAgIFwiSG9ua3ktdG9uayBQaWFub1wiLFxuICAgIFwiRWxlY3RyaWMgUGlhbm8gMVwiLFxuICAgIFwiRWxlY3RyaWMgUGlhbm8gMlwiLFxuICAgIFwiSGFycHNpY2hvcmRcIixcbiAgICBcIkNsYXZpXCIsXG4gICAgXCJDZWxlc3RhXCIsXG4gICAgXCJHbG9ja2Vuc3BpZWxcIixcbiAgICBcIk11c2ljIEJveFwiLFxuICAgIFwiVmlicmFwaG9uZVwiLFxuICAgIFwiTWFyaW1iYVwiLFxuICAgIFwiWHlsb3Bob25lXCIsXG4gICAgXCJUdWJ1bGFyIEJlbGxzXCIsXG4gICAgXCJEdWxjaW1lclwiLFxuICAgIFwiRHJhd2JhciBPcmdhblwiLFxuICAgIFwiUGVyY3Vzc2l2ZSBPcmdhblwiLFxuICAgIFwiUm9jayBPcmdhblwiLFxuICAgIFwiQ2h1cmNoIE9yZ2FuXCIsXG4gICAgXCJSZWVkIE9yZ2FuXCIsXG4gICAgXCJBY2NvcmRpb25cIixcbiAgICBcIkhhcm1vbmljYVwiLFxuICAgIFwiVGFuZ28gQWNjb3JkaW9uXCIsXG4gICAgXCJBY291c3RpYyBHdWl0YXIgKG55bG9uKVwiLFxuICAgIFwiQWNvdXN0aWMgR3VpdGFyIChzdGVlbClcIixcbiAgICBcIkVsZWN0cmljIEd1aXRhciAoamF6eilcIixcbiAgICBcIkVsZWN0cmljIEd1aXRhciAoY2xlYW4pXCIsXG4gICAgXCJFbGVjdHJpYyBHdWl0YXIgKG11dGVkKVwiLFxuICAgIFwiT3ZlcmRyaXZlbiBHdWl0YXJcIixcbiAgICBcIkRpc3RvcnRpb24gR3VpdGFyXCIsXG4gICAgXCJHdWl0YXIgaGFybW9uaWNzXCIsXG4gICAgXCJBY291c3RpYyBCYXNzXCIsXG4gICAgXCJFbGVjdHJpYyBCYXNzIChmaW5nZXIpXCIsXG4gICAgXCJFbGVjdHJpYyBCYXNzIChwaWNrKVwiLFxuICAgIFwiRnJldGxlc3MgQmFzc1wiLFxuICAgIFwiU2xhcCBCYXNzIDFcIixcbiAgICBcIlNsYXAgQmFzcyAyXCIsXG4gICAgXCJTeW50aCBCYXNzIDFcIixcbiAgICBcIlN5bnRoIEJhc3MgMlwiLFxuICAgIFwiVmlvbGluXCIsXG4gICAgXCJWaW9sYVwiLFxuICAgIFwiQ2VsbG9cIixcbiAgICBcIkNvbnRyYWJhc3NcIixcbiAgICBcIlRyZW1vbG8gU3RyaW5nc1wiLFxuICAgIFwiUGl6emljYXRvIFN0cmluZ3NcIixcbiAgICBcIk9yY2hlc3RyYWwgSGFycFwiLFxuICAgIFwiVGltcGFuaVwiLFxuICAgIFwiU3RyaW5nIEVuc2VtYmxlIDFcIixcbiAgICBcIlN0cmluZyBFbnNlbWJsZSAyXCIsXG4gICAgXCJTeW50aFN0cmluZ3MgMVwiLFxuICAgIFwiU3ludGhTdHJpbmdzIDJcIixcbiAgICBcIkNob2lyIEFhaHNcIixcbiAgICBcIlZvaWNlIE9vaHNcIixcbiAgICBcIlN5bnRoIFZvaWNlXCIsXG4gICAgXCJPcmNoZXN0cmEgSGl0XCIsXG4gICAgXCJUcnVtcGV0XCIsXG4gICAgXCJUcm9tYm9uZVwiLFxuICAgIFwiVHViYVwiLFxuICAgIFwiTXV0ZWQgVHJ1bXBldFwiLFxuICAgIFwiRnJlbmNoIEhvcm5cIixcbiAgICBcIkJyYXNzIFNlY3Rpb25cIixcbiAgICBcIlN5bnRoQnJhc3MgMVwiLFxuICAgIFwiU3ludGhCcmFzcyAyXCIsXG4gICAgXCJTb3ByYW5vIFNheFwiLFxuICAgIFwiQWx0byBTYXhcIixcbiAgICBcIlRlbm9yIFNheFwiLFxuICAgIFwiQmFyaXRvbmUgU2F4XCIsXG4gICAgXCJPYm9lXCIsXG4gICAgXCJFbmdsaXNoIEhvcm5cIixcbiAgICBcIkJhc3Nvb25cIixcbiAgICBcIkNsYXJpbmV0XCIsXG4gICAgXCJQaWNjb2xvXCIsXG4gICAgXCJGbHV0ZVwiLFxuICAgIFwiUmVjb3JkZXJcIixcbiAgICBcIlBhbiBGbHV0ZVwiLFxuICAgIFwiQmxvd24gQm90dGxlXCIsXG4gICAgXCJTaGFrdWhhY2hpXCIsXG4gICAgXCJXaGlzdGxlXCIsXG4gICAgXCJPY2FyaW5hXCIsXG4gICAgXCJMZWFkIDEgKHNxdWFyZSlcIixcbiAgICBcIkxlYWQgMiAoc2F3dG9vdGgpXCIsXG4gICAgXCJMZWFkIDMgKGNhbGxpb3BlKVwiLFxuICAgIFwiTGVhZCA0IChjaGlmZilcIixcbiAgICBcIkxlYWQgNSAoY2hhcmFuZylcIixcbiAgICBcIkxlYWQgNiAodm9pY2UpXCIsXG4gICAgXCJMZWFkIDcgKGZpZnRocylcIixcbiAgICBcIkxlYWQgOCAoYmFzcyArIGxlYWQpXCIsXG4gICAgXCJQYWQgMSAobmV3IGFnZSlcIixcbiAgICBcIlBhZCAyICh3YXJtKVwiLFxuICAgIFwiUGFkIDMgKHBvbHlzeW50aClcIixcbiAgICBcIlBhZCA0IChjaG9pcilcIixcbiAgICBcIlBhZCA1IChib3dlZClcIixcbiAgICBcIlBhZCA2IChtZXRhbGxpYylcIixcbiAgICBcIlBhZCA3IChoYWxvKVwiLFxuICAgIFwiUGFkIDggKHN3ZWVwKVwiLFxuICAgIFwiRlggMSAocmFpbilcIixcbiAgICBcIkZYIDIgKHNvdW5kdHJhY2spXCIsXG4gICAgXCJGWCAzIChjcnlzdGFsKVwiLFxuICAgIFwiRlggNCAoYXRtb3NwaGVyZSlcIixcbiAgICBcIkZYIDUgKGJyaWdodG5lc3MpXCIsXG4gICAgXCJGWCA2IChnb2JsaW5zKVwiLFxuICAgIFwiRlggNyAoZWNob2VzKVwiLFxuICAgIFwiRlggOCAoc2NpLWZpKVwiLFxuICAgIFwiU2l0YXJcIixcbiAgICBcIkJhbmpvXCIsXG4gICAgXCJTaGFtaXNlblwiLFxuICAgIFwiS290b1wiLFxuICAgIFwiS2FsaW1iYVwiLFxuICAgIFwiQmFnIHBpcGVcIixcbiAgICBcIkZpZGRsZVwiLFxuICAgIFwiU2hhbmFpXCIsXG4gICAgXCJUaW5rbGUgQmVsbFwiLFxuICAgIFwiQWdvZ29cIixcbiAgICBcIlN0ZWVsIERydW1zXCIsXG4gICAgXCJXb29kYmxvY2tcIixcbiAgICBcIlRhaWtvIERydW1cIixcbiAgICBcIk1lbG9kaWMgVG9tXCIsXG4gICAgXCJTeW50aCBEcnVtXCIsXG4gICAgXCJSZXZlcnNlIEN5bWJhbFwiLFxuICAgIFwiR3VpdGFyIEZyZXQgTm9pc2VcIixcbiAgICBcIkJyZWF0aCBOb2lzZVwiLFxuICAgIFwiU2Vhc2hvcmVcIixcbiAgICBcIkJpcmQgVHdlZXRcIixcbiAgICBcIlRlbGVwaG9uZSBSaW5nXCIsXG4gICAgXCJIZWxpY29wdGVyXCIsXG4gICAgXCJBcHBsYXVzZVwiLFxuICAgIFwiR3Vuc2hvdFwiXG4gIF1cblxubW9kdWxlLmV4cG9ydHMgPSB7fVxuXG5mb3IoIGxldCBuYW1lIG9mIG5hbWVzICkge1xuICBtb2R1bGUuZXhwb3J0c1sgbmFtZSBdID0ge1xuICAgIHByZXNldEluaXQoIGF1ZGlvLCBwcm9wcyApIHtcbiAgICAgIHRoaXMubG9hZCggbmFtZXMuaW5kZXhPZiggbmFtZSApLCBwcm9wcyA9PT0gdW5kZWZpbmVkID8gMCA6IHByb3BzLmJhbmsgfHwgMCApXG4gICAgfVxuICB9XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGFjaWRCYXNzOiB7XG4gICAgUTouOSxcbiAgICBmaWx0ZXJNb2RlbDoyLFxuICAgIGZpbHRlck11bHQ6NCxcbiAgICBjdXRvZmY6MS4yNSxcbiAgICBzYXR1cmF0aW9uOjMuNSxcbiAgICBhdHRhY2s6MS84MTkyLFxuICAgIGRlY2F5OjEvMTAsXG4gICAgb2N0YXZlOi0zLFxuICAgIGdsaWRlOjIwMDAsXG4gICAgZGVzY3JpcHRpb246YEEgc2F3dG9vdGggZmVlZGluZyBhIFRCMzAzLXN0eWxlIGxvd3Bhc3MgZmlsdGVyLCB3aXRoIGhpZ2ggUSBzZXR0aW5ncyBhbmQgYSBzaG9ydCBlbnZlbG9wZS5gXG4gIH0sXG5cbiAgYWNpZEJhc3MyOiB7XG4gICAgUTouNyxcbiAgICBmaWx0ZXJNb2RlbDoyLFxuICAgIGZpbHRlck11bHQ6My41LFxuICAgIGN1dG9mZjouNSxcbiAgICBzYXR1cmF0aW9uOjEwLFxuICAgIGF0dGFjazoxLzgxOTIsXG4gICAgZGVjYXk6MS8xMCxcbiAgICBvY3RhdmU6LTIsXG4gICAgZ2xpZGU6MTAwXG4gIH0sXG5cbiAgJ2Jhc3MuaG9sbG93Jzoge1xuICAgIFE6LjIsXG4gICAgZmlsdGVyTW9kZWw6MixcbiAgICBmaWx0ZXJNdWx0OjQsXG4gICAgY3V0b2ZmOjEuMjUsXG4gICAgc2F0dXJhdGlvbjoyMCxcbiAgICBhdHRhY2s6MS84MTkyLFxuICAgIGRlY2F5OjEvNCxcbiAgICBvY3RhdmU6LTMsXG4gICAgZ2xpZGU6MTAwMFxuICB9LFxuXG4gICdibGVlcC5kcnknOiB7IFxuICAgIGF0dGFjazoxLzI1NiwgZGVjYXk6MS8zMiwgXG4gICAgd2F2ZWZvcm06J3NpbmUnIFxuICB9LFxuICAnYmxlZXAnOiB7IFxuICAgIGF0dGFjazoxLzI1NiwgZGVjYXk6MS8zMiwgXG4gICAgd2F2ZWZvcm06J3NpbmUnIFxuICB9LFxuXG4gICdibGVlcC5lY2hvJzogeyBcbiAgICB3YXZlZm9ybTonc2luZScsIFxuICAgIGF0dGFjazoxLzI1NiwgZGVjYXk6MS8zMiwgXG4gICAgZ2FpbjouMjUsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5wdXNoKCBhdWRpby5lZmZlY3RzLkRlbGF5KHsgZmVlZGJhY2s6LjUsIHRpbWU6MS8xMiB9KSApXG4gICAgfVxuICB9LFxuXG4gIHNoaW1tZXI6IHtcbiAgICBhdHRhY2s6MS8xMjgsIGRlY2F5OjIsXG4gICAgd2F2ZWZvcm06J3B3bScsXG4gICAgZmlsdGVyTW9kZWw6MSxcbiAgICBjdXRvZmY6MSxcbiAgICBmaWx0ZXJNdWx0OjEsXG4gICAgUTouNixcbiAgICBtYXhWb2ljZXM6MyxcbiAgICBnYWluOi4xLFxuICAgIGFudGlhbGlhczpmYWxzZSxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmFkZCggYXVkaW8uZWZmZWN0cy5DaG9ydXMoJ3dhcmJseScpIClcbiAgICAgIHRoaXMucHdtb2QgPSBhdWRpby5HZW4ubWFrZSggYXVkaW8uR2VuLnVnZW5zLm11bCggYXVkaW8uR2VuLnVnZW5zLmN5Y2xlKDgpLCAuMjc1ICkgKVxuICAgICAgdGhpcy5wd21vZC5jb25uZWN0KCB0aGlzLnB1bHNld2lkdGggKVxuICAgIH1cbiAgfSxcblxuICBzdHJpbmdQYWQ6IHtcbiAgICBhdHRhY2s6MS8yLCBkZWNheToxLjUsIGdhaW46LjAxNSxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmZ4LmNob3J1cyA9IGF1ZGlvLmVmZmVjdHMuQ2hvcnVzKCdsdXNoJylcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLmZ4LmNob3J1cyAgKVxuICAgIH1cbiAgfSxcblxuICBjcnk6IHtcbiAgICBhdHRhY2s6MS8yLCBkZWNheToxLjUsIGdhaW46LjA0NSxcbiAgICBwYW5Wb2ljZXM6dHJ1ZSxcbiAgICBwcmVzZXRJbml0OiBmdW5jdGlvbiggYXVkaW8gKSB7XG4gICAgICB0aGlzLmNob3J1cyA9IGF1ZGlvLmVmZmVjdHMuQ2hvcnVzKCdsdXNoJywgeyBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5jaG9ydXMgIClcbiAgICAgIHRoaXMuYml0Q3J1c2hlciA9IGF1ZGlvLmVmZmVjdHMuQml0Q3J1c2hlcih7IGJpdERlcHRoOi41LCBpc1N0ZXJlbzp0cnVlIH0pXG4gICAgICB0aGlzLmZ4LmFkZCggdGhpcy5iaXRDcnVzaGVyIClcbiAgICAgIC8vLy8gZ2VuKCAuNSArIGN5Y2xlKCBidG9mKDE2KSApICogLjM1XG4gICAgICB0aGlzLnNybW9kID0gYXVkaW8uR2VuLm1ha2UoIGF1ZGlvLkdlbi51Z2Vucy5hZGQoIC41LCBhdWRpby5HZW4udWdlbnMubXVsKCBhdWRpby5HZW4udWdlbnMuY3ljbGUoLjEyNS8yKSwgLjM1ICkgKSApXG4gICAgICB0aGlzLmJpdENydXNoZXIuc2FtcGxlUmF0ZSA9IHRoaXMuc3Jtb2RcbiAgICAgIHRoaXMuZGVsYXkgPSBhdWRpby5lZmZlY3RzLkRlbGF5KHsgdGltZToxLzYsIGZlZWRiYWNrOi43NSB9KVxuICAgICAgdGhpcy5meC5hZGQoIHRoaXMuZGVsYXkgKVxuICAgIH1cbiAgfSxcblxuICBicmFzczoge1xuICAgIGF0dGFjazoxLzYsIGRlY2F5OjEuNSwgZ2FpbjouMDUsXG4gICAgZmlsdGVyTW9kZWw6MSwgUTouNTU3NSwgY3V0b2ZmOjIsXG4gICAgcHJlc2V0SW5pdDogZnVuY3Rpb24oIGF1ZGlvICkge1xuICAgICAgdGhpcy5meC5hZGQoIGF1ZGlvLmVmZmVjdHMuQ2hvcnVzKCdsdXNoJykgKVxuICAgICAgdGhpcy5jaG9ydXMgPSB0aGlzLmZ4WzBdXG4gICAgfVxuICB9LFxuXG4gICdicmFzcy5zaG9ydCc6e1xuICAgIGdhaW46Ljc1LFxuICAgIGZpbHRlck1vZGVsOjEsXG4gICAgYW50aWFsaWFzOnRydWUsXG4gICAgYXR0YWNrOjEvMzIsXG4gICAgZGVjYXk6MS8xNixcbiAgICBmaWx0ZXJNdWx0OjMsXG4gICAgY3V0b2ZmOi4xNzUsXG4gICAgUTouNlxuICB9LFxuXG4gICdwd20uc3F1ZWFrJzp7XG4gICAgd2F2ZWZvcm06J3B3bScsXG4gICAgYXR0YWNrOjEvNDA5NixcbiAgICBkZWNheToxLzE2LFxuICAgIFE6LjgsXG4gICAgY3V0b2ZmOi42NSxcbiAgICBzYXR1cmF0aW9uOjUsXG4gICAgZmlsdGVyTW9kZWw6MixcbiAgICBnbGlkZTo1MDBcbiAgfSxcblxuICAncHdtLnNob3J0Jzp7XG4gICAgYXR0YWNrOjEvMTAyNCxcbiAgICBkZWNheToxLzgsXG4gICAgYW50aWFsaWFzOnRydWUsXG4gICAgd2F2ZWZvcm06J3B3bSdcbiAgfSxcblxuICBjaGlycDogeyBmaWx0ZXJNb2RlbDoyLCBjdXRvZmY6LjMyNSwgZGVjYXk6MS8xNiB9LCBcblxuICAnc3F1YXJlLnBlcmMnOiB7IFxuICAgIHdhdmVmb3JtOidzcXVhcmUnLCBcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnLCBcbiAgICBhbnRpYWxpYXM6dHJ1ZSwgXG4gICAgZmlsdGVyTW9kZWw6MiwgXG4gICAgY3V0b2ZmOi4yNSwgXG4gICAgZGVjYXk6MS84LFxuICAgIHBhblZvaWNlczp0cnVlXG4gIH0sXG5cbiAgJ3NxdWFyZS5wZXJjLmxvbmcnOiB7IFxuICAgIHdhdmVmb3JtOidzcXVhcmUnLCBcbiAgICBzaGFwZTonZXhwb25lbnRpYWwnLCBcbiAgICBhbnRpYWxpYXM6dHJ1ZSwgXG4gICAgZmlsdGVyTW9kZWw6MiwgXG4gICAgY3V0b2ZmOi4yNSwgXG4gICAgZGVjYXk6MixcbiAgICBwYW5Wb2ljZXM6dHJ1ZVxuICB9LFxuXG4gIHJob2Rlczp7XG4gICAgd2F2ZWZvcm06J3NpbmUnLFxuICAgIHByZXNldEluaXQoIGF1ZGlvICkge1xuICAgICAgdGhpcy50cmVtb2xvID0gYXVkaW8uZWZmZWN0cy5UcmVtb2xvKClcbiAgICAgIHRoaXMuZnguYWRkKCB0aGlzLnRyZW1vbG8gKVxuICAgIH0sXG4gICAgZGVjYXk6NCxcbiAgICBnYWluOi4xMjUsXG4gICAgc2hhcGU6J2V4cG9uZW50aWFsJ1xuICB9LFxuXG4gIGJsYW5rOiB7XG4gICAgZmlsdGVyTW9kZWw6MCxcbiAgICB3YXZlZm9ybTonc2luZScsXG4gICAgYW50aWFsaWFzOmZhbHNlXG4gIH1cbn1cbiIsImNvbnN0IEdpYmJlcmlzaCA9IHJlcXVpcmUoICdnaWJiZXJpc2gtZHNwJyApXG5jb25zdCBzZXJpYWxpemUgPSByZXF1aXJlKCAnc2VyaWFsaXplLWphdmFzY3JpcHQnIClcbmNvbnN0IFR1bmUgICAgICA9IHJlcXVpcmUoICcuL2V4dGVybmFsL3R1bmUtYXBpLW9ubHkuanMnIClcblxubGV0IEdpYmJlciA9IG51bGxcblxuY29uc3QgVGhlb3J5ID0ge1xuICAvLyBuZWVkZWQgdG8gZm9yY2UgbGlicmFyeSB0byBiZSBzZXJpYWxpemVkIGZvciB0cmFuc3BvcnQgdG8gXG4gIC8vIHdvcmtsZXQgcHJvY2Vzc29yLCBtdXN0IHVzZSBrZXk6ZnVuY3Rpb24oKSB7fSBmb3JtYXRcbiAgLy8gZm9yIG1ldGhvZHMgZm9yIHNlcmlhbGl6ZSB0byB3b3JrXG4gIF9fVHVuZTpUdW5lLFxuXG4gIFR1bmU6bnVsbCxcbiAgaWQ6bnVsbCxcbiAgdHlwZTogJ0F1ZGlvJyxcbiAgbm9naWJiZXJpc2g6dHJ1ZSxcbiAgcXVhbGl0eTonbWlub3InLFxuICBiYXNlTnVtYmVyOjYwLFxuICBfX3R1bmluZzonZXQnLFxuICBfX21vZGU6ICdhZW9saWFuJyxcbiAgX19yb290OjQ0MCxcbiAgX19vZmZzZXQ6MCxcbiAgX19kZWdyZWU6J2knLFxuICBfX2xvYWRpbmdQcmVmaXg6J2pzL2V4dGVybmFsL3R1bmUuanNvbi8nLCBcbiAgX190dW5pbmdzOntcbiAgICBldDoge1xuICAgICAgcm9vdDonNjAnLFxuICAgICAgbW9kZTonYWJzb2x1dGUnLFxuICAgICAgZnJlcXVlbmNpZXM6W1xuICAgICAgICAyNjEuNjI1NTgsXG4gICAgICAgIDI3Ny4xODI2MTcsXG4gICAgICAgIDI5My42NjQ3NjQsXG4gICAgICAgIDMxMS4xMjY5ODQsXG4gICAgICAgIDMyOS42Mjc1NjMsXG4gICAgICAgIDM0OS4yMjgyNDEsXG4gICAgICAgIDM2OS45OTQ0MTUsXG4gICAgICAgIDM5MS45OTU0MjIsXG4gICAgICAgIDQxNS4zMDQ2ODgsXG4gICAgICAgIDQ0MCxcbiAgICAgICAgNDY2LjE2Mzc1NyxcbiAgICAgICAgNDkzLjg4MzMwMSxcbiAgICAgICAgNTIzLjI1MTA4MzcyNzM2M1xuICAgICAgXSxcbiAgICAgIGRlc2NyaXB0aW9uOidlcXVhbCB0ZW1wZXJlZCAoZWRvKSdcbiAgICB9XG4gIH0sICBcblxuICBtb2Rlczoge1xuICAgIGlvbmlhbjogICAgIFswLDIsNCw1LDcsOSwxMV0sXG4gICAgZG9yaWFuOiAgICAgWzAsMiwzLDUsNyw5LDEwXSxcbiAgICBwaHJ5Z2lhbjogICBbMCwxLDMsNSw3LDgsMTBdLFxuICAgIGx5ZGlhbjogICAgIFswLDIsNCw2LDcsOSwxMV0sXG4gICAgbWl4b2x5ZGlhbjogWzAsMiw0LDUsNyw5LDEwXSxcbiAgICBhZW9saWFuOiAgICBbMCwyLDMsNSw3LDgsMTBdLFxuICAgIGxvY3JpYW46ICAgIFswLDEsMyw1LDYsOCwxMF0sXG4gICAgbWVsb2RpY21pbm9yOlswLDIsMyw1LDcsOCwxMV0sXG4gICAgd2hvbGVIYWxmOiAgWzAsMiwzLDUsNiw4LDksMTFdLFxuICAgIGhhbGZXaG9sZTogIFswLDEsMyw0LDYsNyw5LDEwXSxcbiAgICBjaHJvbWF0aWM6ICBbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV0sXG4gIH0sXG5cbiAgc3RvcmU6ZnVuY3Rpb24oKSB7IFxuICAgIEdpYmJlcmlzaC5UaGVvcnkgPSB0aGlzXG5cbiAgICB0aGlzLlR1bmUuVHVuaW5nTGlzdCA9IHRoaXMuX190dW5pbmdzXG5cbiAgICB0aGlzLmluaXRQcm9wZXJ0aWVzKClcbiAgfSxcblxuICBzZXR1cCggdHVuaW5nPSdldCcsIG1vZGU9J2Flb2xpYW4nICkge1xuICAgIHRoaXMudHVuaW5nID0gdHVuaW5nXG4gICAgdGhpcy5tb2RlID0gbW9kZVxuICB9LCBcblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3R1YXJ0bWVtby8zNzY2NDQ5XG4gIF9fbm90ZVRvRnJlcSggbm90ZSApIHtcbiAgICBub3RlID0gbm90ZS50b1VwcGVyQ2FzZSgpIFxuXG4gICAgbGV0IG5vdGVzID0gWydBJywgJ0EjJywgJ0InLCAnQycsICdDIycsICdEJywgJ0QjJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0cjJ10sXG4gICAgICAgIG9jdGF2ZSxcbiAgICAgICAga2V5TnVtYmVyXG5cbiAgICBpZiAobm90ZS5sZW5ndGggPT09IDMpIHtcbiAgICAgIG9jdGF2ZSA9IG5vdGUuY2hhckF0KDIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9jdGF2ZSA9IG5vdGUuY2hhckF0KDEpXG4gICAgfVxuICAgIGtleU51bWJlciA9IG5vdGVzLmluZGV4T2Yobm90ZS5zbGljZSgwLCAtMSkpXG4gICAgaWYgKGtleU51bWJlciA8IDMpIHtcbiAgICAgIGtleU51bWJlciA9IGtleU51bWJlciArIDEyICsgKChvY3RhdmUgLSAxKSAqIDEyKSArIDFcbiAgICB9IGVsc2Uge1xuICAgICAga2V5TnVtYmVyID0ga2V5TnVtYmVyICsgKChvY3RhdmUgLSAxKSAqIDEyKSArIDFcbiAgICB9XG5cbiAgICByZXR1cm4gNDQwICogTWF0aC5wb3coMiwgKGtleU51bWJlci0gNDkpIC8gMTIpXG4gIH0sXG5cbiAgZGVsZXRlUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICBkZWxldGUgdGhpcy5fX3Jvb3RcbiAgICAgIGRlbGV0ZSB0aGlzLl9fdHVuaW5nXG4gICAgICBkZWxldGUgdGhpcy5fX21vZGVcbiAgICAgIGRlbGV0ZSB0aGlzLl9fb2Zmc2V0XG4gICAgICBkZWxldGUgdGhpcy5fX2RlZ3JlZVxuXG4gICAgICBUaGVvcnkubWFya3VwID0ge1xuICAgICAgICB0ZXh0TWFya2VycyA6IHt9LFxuICAgICAgICBjc3NDbGFzc2VzOiB7fVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fcm9vdCA9IDQ0MFxuICAgICAgdGhpcy5fX3R1bmluZyA9ICdldCdcbiAgICAgIHRoaXMuX19vZmZzZXQgPSAwXG4gICAgICB0aGlzLl9fZGVncmVlID0gJ2knXG4gICAgICB0aGlzLl9fbW9kZSA9ICdhZW9saWFuJ1xuICAgIH1cbiAgfSxcblxuICBpbml0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICBHaWJiZXIuY3JlYXRlUHJvcGVydHkoIFxuICAgICAgICB0aGlzLCAncm9vdCcsIDQ0MCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiBUaGVvcnkuX19yb290LnZhbHVlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIFRoZW9yeS5yb290ID0gVGhlb3J5Ll9fbm90ZVRvRnJlcSggVGhlb3J5Ll9fcm9vdC52YWx1ZSApXG4gICAgICAgICAgfSBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIDFcbiAgICAgIClcblxuICAgICAgR2liYmVyLmNyZWF0ZVByb3BlcnR5KCBcbiAgICAgICAgdGhpcywgJ3R1bmluZycsICdldCcsIFxuICAgICAgICBmdW5jdGlvbigpIHsgLy8gWFhYIHdoeSBkb2Vzbid0IHRoaXMgd29yaz8/PyBkdXBsaWNhdGVkIGJlbG93Li4uIFxuICAgICAgICAgIHRoaXMubG9hZFNjYWxlKCB0aGlzLl9fdHVuaW5nLnZhbHVlICkgXG4gICAgICAgIH0sXG4gICAgICAgIDFcbiAgICAgIClcblxuICAgICAgR2liYmVyLmNyZWF0ZVByb3BlcnR5KCB0aGlzLCAnbW9kZScsICdhZW9saWFuJywgbnVsbCwgMCApXG4gICAgICBHaWJiZXIuY3JlYXRlUHJvcGVydHkoIHRoaXMsICdvZmZzZXQnLCAwLCBudWxsLCAwIClcbiAgICAgIEdpYmJlci5jcmVhdGVQcm9wZXJ0eSggdGhpcywgJ2RlZ3JlZScsICdpJywgbnVsbCwgMCApXG5cbiAgICAgIC8vc2V0VGltZW91dCggKCk9PiBUaGVvcnkudHVuaW5nID0gJ2V0JywgMjUwIClcbiAgICAgIHRoaXMudHVuaW5nID0gJ2V0J1xuICAgICAgLy90aGlzLmxvYWRTY2FsZSgnZXQnKVxuICAgIH1lbHNle1xuICAgICAgdGhpcy5fX2luaXREZWdyZWVzKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncm9vdCcsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5fX3Jvb3QgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHY9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX25vdGVUb0ZyZXEoIHYgKVxuICAgICAgICAgIH0gXG4gICAgICAgICAgdGhpcy5fX3Jvb3QgPSB2XG4gICAgICAgICAgdGhpcy5UdW5lLnRvbmljaXplKCB0aGlzLl9fcm9vdCApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3R1bmluZycsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5fX3R1bmluZyB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIHRoaXMuX190dW5pbmcgPSB2XG4gICAgICAgICAgLy90aGlzLmxvYWRTY2FsZSggdiApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ21vZGUnLCB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiB0aGlzLl9fbW9kZSB9LFxuICAgICAgICBzZXQodikgeyBcbiAgICAgICAgICBpZiggdGhpcy5tb2Rlc1sgdiBdICE9PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgIHRoaXMuX19tb2RlID0gdiBcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGBUaGUgbW9kZSBcIiR7dn1cIiBpcyBub3QgdmFsaWQuIFZhbGlkIG1vZGVzIGluY2x1ZGUgJHtPYmplY3Qua2V5cyh0aGlzLm1vZGVzKS50b1N0cmluZygpfSwgYW5kIG51bGwuIE5vIGNoYW5nZSB0byBUaGVvcnkubW9kZSB3YXMgYXBwbGllZC5gIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ29mZnNldCcsIHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIHRoaXMuX19vZmZzZXQgfSxcbiAgICAgICAgc2V0KHYpIHsgdGhpcy5fX29mZnNldCA9IHYgfVxuICAgICAgfSlcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnZGVncmVlJywgeyBcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5fX2RlZ3JlZSB9LFxuICAgICAgICBzZXQoIF9fZGVncmVlICkge1xuICAgICAgICAgIGlmKCB0eXBlb2YgX19kZWdyZWUgID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9IHRoaXMuX19kZWdyZWVzWyB0aGlzLnF1YWxpdHkgXVsgX19kZWdyZWUgXVxuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX19kZWdyZWUgPSBkZWdyZWVcbiAgICAgICAgICAgIC8vdGhpcy5yb290TnVtYmVyID0gZGVncmVlLm9mZnNldCArIHRoaXMuYmFzZU51bWJlclxuICAgICAgICAgICAgdGhpcy5tb2RlID0gZGVncmVlLm1vZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuZGVncmVlID0gJ2knXG4gICAgfVxuICB9LFxuXG4gIF9fZGVncmVlczogeyBtYWpvcjp7fSwgbWlub3I6e30gfSxcblxuICBfX2luaXREZWdyZWVzOmZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGJhc2UgPSBbICdpJywgJ2lpJywgJ2lpaScsICdpdicsICd2JywgJ3ZpJywgJ3ZpaScgXVxuXG4gICAgY29uc3Qgc2NhbGVzID0gWyB7IG5hbWU6J21pbm9yJywgdmFsdWVzOnRoaXMubW9kZXMuYWVvbGlhbiB9LCB7IG5hbWU6J21ham9yJywgdmFsdWVzOnRoaXMubW9kZXMuaW9uaWFuIH0gXVxuXG4gICAgZm9yKCBsZXQgc2NhbGUgb2Ygc2NhbGVzICkge1xuICAgICAgbGV0IG5hbWUgPSBzY2FsZS5uYW1lXG4gICAgICBsZXQgdmFsdWVzID0gc2NhbGUudmFsdWVzXG5cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY29uc3QgY2hvcmQgPSBiYXNlWyBpIF1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgY2hvcmQgXSA9IHsgbW9kZTonYWVvbGlhbicsIG9mZnNldDogdmFsdWVzW2ldIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0nK2Nob3JkIF0gPSB7IG1vZGU6J2Flb2xpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSAtIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0tJytjaG9yZCBdID0geyBtb2RlOidhZW9saWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAyNCB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrJytjaG9yZCBdID0geyBtb2RlOidhZW9saWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrKycrY2hvcmQgXSA9IHsgbW9kZTonYWVvbGlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMjQgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNvbnN0IGNob3JkID0gYmFzZVsgaSBdLnRvVXBwZXJDYXNlKClcbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgY2hvcmQgXSA9IHsgbW9kZTonaW9uaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLScrY2hvcmQgXSA9IHsgbW9kZTonaW9uaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonaW9uaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAyNCB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrJytjaG9yZCBdID0geyBtb2RlOidpb25pYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysrJytjaG9yZCBdID0geyBtb2RlOidpb25pYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGJhc2VbIGkgXSArICc3J1xuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyBjaG9yZCBdID0geyBtb2RlOidkb3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctJytjaG9yZCBdID0geyBtb2RlOidkb3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSAtIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0tJytjaG9yZCBdID0geyBtb2RlOidkb3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSAtIDI0IH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysnK2Nob3JkIF0gPSB7IG1vZGU6J2RvcmlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKysnK2Nob3JkIF0gPSB7IG1vZGU6J2RvcmlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMjQgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNvbnN0IGNob3JkID0gYmFzZVsgaSBdLnRvVXBwZXJDYXNlKCkgKyAnNydcbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgY2hvcmQgXSA9IHsgbW9kZTonbWl4b2x5ZGlhbicsIG9mZnNldDogdmFsdWVzW2ldIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0nK2Nob3JkIF0gPSB7IG1vZGU6J21peG9seWRpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSAtIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJy0tJytjaG9yZCBdID0geyBtb2RlOidtaXhvbHlkaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAyNCB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrJytjaG9yZCBdID0geyBtb2RlOidtaXhvbHlkaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gKyAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrKycrY2hvcmQgXSA9IHsgbW9kZTonbWl4b2x5ZGlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMjQgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNvbnN0IGNob3JkID0gYmFzZVsgaSBdICsgJ28nXG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bIGNob3JkIF0gPSB7IG1vZGU6J2xvY3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctJytjaG9yZCBdID0geyBtb2RlOidsb2NyaWFuJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonbG9jcmlhbicsIG9mZnNldDogdmFsdWVzW2ldIC0gMjQgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKycrY2hvcmQgXSA9IHsgbW9kZTonbG9jcmlhbicsIG9mZnNldDogdmFsdWVzW2ldICsgMTIgfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnKysnK2Nob3JkIF0gPSB7IG1vZGU6J2xvY3JpYW4nLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cblxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjb25zdCBjaG9yZCA9IGJhc2VbIGkgXSArICdNNydcbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgY2hvcmQgXSA9IHsgbW9kZTonbWVsb2RpY21pbm9yJywgb2Zmc2V0OiB2YWx1ZXNbaV0gfVxuICAgICAgICB0aGlzLl9fZGVncmVlc1sgbmFtZSBdWyAnLScrY2hvcmQgXSA9IHsgbW9kZTonbWVsb2RpY21pbm9yJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAxMiB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICctLScrY2hvcmQgXSA9IHsgbW9kZTonbWVsb2RpY21pbm9yJywgb2Zmc2V0OiB2YWx1ZXNbaV0gLSAyNCB9XG4gICAgICAgIHRoaXMuX19kZWdyZWVzWyBuYW1lIF1bICcrJytjaG9yZCBdID0geyBtb2RlOidtZWxvZGljbWlub3InLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDEyIH1cbiAgICAgICAgdGhpcy5fX2RlZ3JlZXNbIG5hbWUgXVsgJysrJytjaG9yZCBdID0geyBtb2RlOidtZWxvZGljbWlub3InLCBvZmZzZXQ6IHZhbHVlc1tpXSArIDI0IH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW5pdDpmdW5jdGlvbiggX19HaWJiZXIgKSB7XG4gICAgR2liYmVyID0gX19HaWJiZXJcblxuICAgIHRoaXMuVHVuZSA9IG5ldyB0aGlzLl9fVHVuZSgpXG4gICAgdGhpcy5UdW5lLlR1bmluZ0xpc3QgPSB0aGlzLl9fdHVuaW5nc1xuXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICB0aGlzLmlkID0gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgICAvLyBjYW4ndCBzZW5kIHByb3RvdHlwZSBtZXRob2RzIG9mIFR1bmUgb3ZlciBwcm9jZXNzb3JcbiAgICAgIC8vIHNvIHRoZXkgbmVlZCB0byBiZSBleHBsaWNpdGx5IGFzc2lnbmVkXG4gICAgICB0aGlzLlR1bmUubG9hZFNjYWxlID0gdGhpcy5UdW5lLl9fcHJvdG9fXy5sb2FkU2NhbGVcbiAgICAgIHRoaXMuVHVuZS5ub3RlID0gdGhpcy5UdW5lLl9fcHJvdG9fXy5ub3RlXG4gICAgICB0aGlzLlR1bmUuZnJlcXVlbmN5ID0gdGhpcy5UdW5lLl9fcHJvdG9fXy5mcmVxdWVuY3lcbiAgICAgIHRoaXMuVHVuZS50b25pY2l6ZSA9IHRoaXMuVHVuZS5fX3Byb3RvX18udG9uaWNpemVcbiAgICAgIHRoaXMuVHVuZS5yYXRpbyA9IHRoaXMuVHVuZS5fX3Byb3RvX18ucmF0aW9cbiAgICAgIHRoaXMuVHVuZS5NSURJID0gdGhpcy5UdW5lLl9fcHJvdG9fXy5NSURJXG4gICAgICBcbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzOidhZGQnLFxuICAgICAgICBwcm9wZXJ0aWVzOnNlcmlhbGl6ZSggVGhlb3J5ICksXG4gICAgICAgIGlkOnRoaXMuaWQsXG4gICAgICAgIHBvc3Q6J3N0b3JlJ1xuICAgICAgfSlcblxuICAgICAgR2liYmVyLnN1YnNjcmliZSggJ2NsZWFyJywgKCkgPT4gdGhpcy5yZXNldCgpIClcbiAgICAgIHRoaXMuaW5pdFByb3BlcnRpZXMoKVxuICAgIH1cblxuICAgIHRoaXMuX19pbml0RGVncmVlcygpXG4gIH0sXG5cbiAgcmVzZXQ6ZnVuY3Rpb24oKSB7XG4gICAgVGhlb3J5LnJvb3QgPSA0NDBcbiAgICBUaGVvcnkubW9kZSA9ICdhZW9saWFuJ1xuICAgIFRoZW9yeS50dW5pbmcgPSAnZXQnXG4gICAgVGhlb3J5LmRlZ3JlZSA9ICdpJ1xuICAgIFRoZW9yeS5vZmZzZXQgPSAwXG4gIH0sXG5cbiAgZnJlZXplOmZ1bmN0aW9uKCkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgR2liYmVyLlRoZW9yeS5kZWdyZWUuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RvcCgpICkgIFxuICAgICAgR2liYmVyLlRoZW9yeS5vZmZzZXQuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RvcCgpICkgIFxuICAgICAgR2liYmVyLlRoZW9yeS5tb2RlLnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0b3AoKSApICBcbiAgICAgIEdpYmJlci5UaGVvcnkucm9vdC5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdG9wKCkgKSAgXG4gICAgfVxuICB9LFxuXG4gIHRoYXc6ZnVuY3Rpb24oKSB7XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICB0aGlzLmRlZ3JlZS5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdGFydCgpICkgIFxuICAgICAgdGhpcy5vZmZzZXQuc2VxdWVuY2Vycy5mb3JFYWNoKCBzID0+IHMuc3RhcnQoKSApICBcbiAgICAgIHRoaXMubW9kZS5zZXF1ZW5jZXJzLmZvckVhY2goIHMgPT4gcy5zdGFydCgpICkgIFxuICAgICAgdGhpcy5yb290LnNlcXVlbmNlcnMuZm9yRWFjaCggcyA9PiBzLnN0YXJ0KCkgKSAgXG4gICAgfVxuICB9LFxuXG4gIGxvYWRTY2FsZTogZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAvLyBpZiB0aGUgc2NhbGUgaXMgYWxyZWFkeSBsb2FkZWQuLi5cbiAgICAgIGlmKCB0aGlzLl9fdHVuaW5nc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHRoaXMuX190dW5pbmcudmFsdWUgPSBuYW1lXG4gICAgICAgIHRoaXMuVHVuZS5sb2FkU2NhbGUoIG5hbWUgKVxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFkZHJlc3M6J21ldGhvZCcsXG4gICAgICAgICAgb2JqZWN0OnRoaXMuaWQsXG4gICAgICAgICAgbmFtZTonbG9hZFNjYWxlJyxcbiAgICAgICAgICBhcmdzOltuYW1lXVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX19sb2FkaW5nUHJlZml4ICsgbmFtZSArICcuanMnIFxuICAgICAgZmV0Y2goIHBhdGggKVxuICAgICAgICAuY2F0Y2goIGNvbnNvbGUuZXJyIClcbiAgICAgICAgLnRoZW4oIGRhdGEgPT4ge1xuICAgICAgICAgIGlmKCBkYXRhLm9rICkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuanNvbigpXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCBgVGhlIHR1bmluZyAke25hbWV9IHdhc24ndCBmb3VuZC4gUGxlYXNlIHZpc2l0IGh0dHA6Ly9hYmJlcm5pZS5naXRodWIuaW8vdHVuZS9zY2FsZXMuaHRtbCB0byBmaW5kIHRoZSBuYW1lcyBvZiB2YWxpZCB0dW5pbmdzLmApIFxuICAgICAgICAgIH0gXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCBqc29uID0+IHtcbiAgICAgICAgICB0aGlzLl9fdHVuaW5nLnZhbHVlID0gbmFtZVxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczonYWRkVG9Qcm9wZXJ0eScsXG4gICAgICAgICAgICBvYmplY3Q6dGhpcy5pZCxcbiAgICAgICAgICAgIG5hbWU6J19fdHVuaW5ncycsXG4gICAgICAgICAgICBrZXk6bmFtZSxcbiAgICAgICAgICAgIHZhbHVlOmpzb25cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidtZXRob2QnLFxuICAgICAgICAgICAgb2JqZWN0OnRoaXMuaWQsXG4gICAgICAgICAgICBuYW1lOidsb2FkU2NhbGUnLFxuICAgICAgICAgICAgYXJnczpbbmFtZV1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdGhpcy5fX3R1bmluZ3NbIG5hbWUgXSA9IGpzb25cbiAgICAgICAgICB0aGlzLlR1bmUubG9hZFNjYWxlKCBuYW1lIClcbiAgICAgICAgfSlcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuVHVuZS5sb2FkU2NhbGUoIG5hbWUgKVxuICAgIH1cbiAgfSxcblxuICAvLyBSRU1FTUJFUiBUSEFUIFRIRSAubm90ZSBNRVRIT0QgSVMgQUxTTyBNT05LRVktUEFUQ0hFRFxuICAvLyBJTiB1Z2VuLmpzLCBUSElTIElTIFdIRVJFIE1PU1QgT0YgVEhFIEFXUFJPQ0VTU09SIE5PVEVcbiAgLy8gTUVUSE9EIElTIElNUExFTUVOVEVELlxuICBub3RlOiBmdW5jdGlvbiggX19pZHgsIG9jdGF2ZT0wLCByb3VuZD10cnVlICkge1xuICAgIGxldCBmaW5hbElkeCwgbW9kZSA9IG51bGwsIF9fZmxvYXQgPSBfX2lkeCAlIDEsIGJhc2VPY3RhdmUsIG5leHRPY3RhdmVcblxuICAgIGxldCBpc0ludCA9IF9fZmxvYXQgPT09IDBcbiAgICBpZiggIWlzSW50ICYmIHJvdW5kPT09dHJ1ZSApIHtcbiAgICAgIF9faWR4ID0gTWF0aC5yb3VuZCggX19pZHggKVxuICAgICAgaXNJbnQgPSB0cnVlXG4gICAgfVxuICAgIFxuICAgIGxldCBiYXNlSW5kZXggPSBfX2lkeCA8IDAgPyBNYXRoLmNlaWwoIF9faWR4ICkgOiBNYXRoLmZsb29yKCBfX2lkeCApLFxuICAgICAgICBuZXh0SW5kZXggPSBfX2lkeCA+PSAwID8gYmFzZUluZGV4ICsgMSA6IGJhc2VJbmRleCAtIDFcblxuICAgIGJhc2VJbmRleCArPSBHaWJiZXJpc2guVGhlb3J5Ll9fb2Zmc2V0XG4gICAgbmV4dEluZGV4ICs9IEdpYmJlcmlzaC5UaGVvcnkuX19vZmZzZXRcblxuICAgIGlmKCBHaWJiZXJpc2guVGhlb3J5Lm1vZGUgIT09ICdjaHJvbWF0aWMnICYmIEdpYmJlcmlzaC5UaGVvcnkubW9kZSAhPT0gbnVsbCApIHtcbiAgICAgIG1vZGUgPSBHaWJiZXJpc2guVGhlb3J5Lm1vZGVzWyBHaWJiZXJpc2guVGhlb3J5Lm1vZGUgXVxuICAgICAgYmFzZU9jdGF2ZSA9IE1hdGguZmxvb3IoIGJhc2VJbmRleCAvIG1vZGUubGVuZ3RoIClcbiAgICAgIG5leHRPY3RhdmUgPSBNYXRoLmZsb29yKCBuZXh0SW5kZXggLyBtb2RlLmxlbmd0aCApXG4gICAgICBcbiAgICAgIC8vIFhYWCB0aGlzIGxvb2tzIGNyYXp5IHVnbHkgYnV0IHdvcmtzIHdpdGggbmVnYXRpdmUgbm90ZSBudW1iZXJzLi4uXG4gICAgICBiYXNlSW5kZXggPSBiYXNlSW5kZXggPCAwIFxuICAgICAgICA/IG1vZGVbIChtb2RlLmxlbmd0aCAtIChNYXRoLmFicyggYmFzZUluZGV4ICkgJSBtb2RlLmxlbmd0aCkpICUgbW9kZS5sZW5ndGggXSBcbiAgICAgICAgOiBtb2RlWyBNYXRoLmFicyggYmFzZUluZGV4ICkgJSBtb2RlLmxlbmd0aCBdXG5cbiAgICAgIGlmKCAhaXNJbnQgKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG5leHRJbmRleCA8IDAgXG4gICAgICAgICAgPyBtb2RlWyAobW9kZS5sZW5ndGggLSAoTWF0aC5hYnMoIG5leHRJbmRleCApICUgbW9kZS5sZW5ndGgpKSAlIG1vZGUubGVuZ3RoIF0gXG4gICAgICAgICAgOiBtb2RlWyBNYXRoLmFicyggbmV4dEluZGV4ICkgJSBtb2RlLmxlbmd0aCBdXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAvLyBudWxsIG1vZGUgYWxzbyBtZWFucyB0byB1c2UgJ2Nocm9tYXRpYycgbW9kZVxuICAgICAgbW9kZSA9IEdpYmJlcmlzaC5UaGVvcnkubW9kZXNbICdjaHJvbWF0aWMnIF1cbiAgICAgIGNvbnN0IGwgPSBHaWJiZXJpc2guVGhlb3J5LlR1bmUuc2NhbGUubGVuZ3RoIFxuICAgICAgYmFzZU9jdGF2ZSA9IE1hdGguZmxvb3IoIGJhc2VJbmRleCAvIGwgKVxuICAgICAgbmV4dE9jdGF2ZSA9IE1hdGguZmxvb3IoIGJhc2VJbmRleCAvIGwgKVxuXG4gICAgICBiYXNlSW5kZXggPSBiYXNlSW5kZXggPCAwIFxuICAgICAgICA/IG1vZGVbIChsIC0gKE1hdGguYWJzKCBiYXNlSW5kZXggKSAlIGwpKSAlIGwgXSBcbiAgICAgICAgOiBtb2RlWyBNYXRoLmFicyggYmFzZUluZGV4ICkgJSBsIF1cblxuICAgICAgaWYoICFpc0ludCApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbmV4dEluZGV4IDwgMCBcbiAgICAgICAgICA/IG1vZGVbIChsIC0gKE1hdGguYWJzKCBuZXh0SW5kZXggKSAlIGwpKSAlIGwgXSBcbiAgICAgICAgICA6IG1vZGVbIE1hdGguYWJzKCBuZXh0SW5kZXggKSAlIGwgXVxuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2VJbmRleCArPSB0aGlzLl9fZGVncmVlLm9mZnNldFxuICAgIG5leHRJbmRleCArPSB0aGlzLl9fZGVncmVlLm9mZnNldFxuXG4gICAgbGV0IG91dHB1dEZyZXEgPSAwXG4gICAgaWYoICFpc0ludCApIHtcbiAgICAgIGNvbnN0IGZyZXEwID0gR2liYmVyaXNoLlRoZW9yeS5UdW5lLm5vdGUoIGJhc2VJbmRleCwgYmFzZU9jdGF2ZSApXG4gICAgICBjb25zdCBmcmVxMSA9IEdpYmJlcmlzaC5UaGVvcnkuVHVuZS5ub3RlKCBuZXh0SW5kZXgsIG5leHRPY3RhdmUgKVxuICAgICAgbGV0ICAgZGlmZiAgPSBmcmVxMSAtIGZyZXEwXG4gICAgICBpZiggX19pZHggPCAwICkgZGlmZiAqPSAtMVxuICAgICAgb3V0cHV0RnJlcSA9IGZyZXEwICsgKGRpZmYqX19mbG9hdClcbiAgICB9ZWxzZXtcbiAgICAgIG91dHB1dEZyZXEgPSBHaWJiZXJpc2guVGhlb3J5LlR1bmUubm90ZSggYmFzZUluZGV4LCBiYXNlT2N0YXZlIClcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RnJlcSBcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaGVvcnlcbiIsImNvbnN0IFByZXNldHMgPSByZXF1aXJlKCAnLi9wcmVzZXRzLmpzJyApXG5jb25zdCBUaGVvcnkgID0gcmVxdWlyZSggJy4vdGhlb3J5LmpzJyApXG5jb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnZ2liYmVyaXNoLWRzcCcgKVxuXG4vLyBHaWJiZXIgdWdlbnMgYXJlIGVzc2VudGlhbGx5IHdyYXBwZXJzIGFyb3VuZCB1bmRlcmx5aW5nIGdpYmJlcmlzaCBcbi8vIHVnZW5zLCBwcm92aWRpbmcgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgcmFwaWRseSBzZXF1ZW5jaW5nXG4vLyBhbmQgbW9kdWxhdGluZyB0aGVtLlxuXG5jb25zdCBwb29sU2l6ZSA9IDEyXG5cbi8vIERSWSBtZXRob2QgZm9yIHJlbW92aW5nIGEgc2VxdWVuY2UgYW5kIGl0cyBhc3NvY2lhdGVkIGFubm90YXRpb25zLlxuY29uc3QgcmVtb3ZlU2VxID0gZnVuY3Rpb24oIG9iaiwgc2VxICkge1xuICBjb25zdCBpZHggPSBvYmouX19zZXF1ZW5jZXJzLmluZGV4T2YoIHNlcSApXG4gIG9iai5fX3NlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICBzZXEuc3RvcCgpXG4gIHNlcS5jbGVhcigpXG59XG5cbmNvbnN0IGNyZWF0ZU1hcHBpbmcgPSBmdW5jdGlvbiggZnJvbSwgdG8sIG5hbWUsIHdyYXBwZWRUbyApIHtcbiAgaWYoIGZyb20uX191c2VNYXBwaW5nID09PSBmYWxzZSApIHtcbiAgICB3cmFwcGVkVG9bIG5hbWUgXSA9IGZyb21cbiAgfWVsc2UgaWYoIGZyb20udHlwZSA9PT0gJ2F1ZGlvJyApIHtcbiAgICBjb25zdCBmID0gdG9bICdfXycgKyBuYW1lIF0uZm9sbG93ID0gRm9sbG93KHsgaW5wdXQ6IGZyb20gfSlcblxuICAgIGxldCBtID0gZi5tdWx0aXBsaWVyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0b1sgbmFtZSBdLCAnbXVsdGlwbGllcicsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIG0gfSxcbiAgICAgIHNldCh2KSB7IG0gPSB2OyBmLm11bHRpcGxpZXIgPSBtIH1cbiAgICB9KVxuXG4gICAgbGV0IG8gPSBmLm9mZnNldFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdG9bIG5hbWUgXSwgJ29mZnNldCcsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIG8gfSxcbiAgICAgIHNldCh2KSB7IG8gPSB2OyBmLm9mZnNldCA9IG8gfVxuICAgIH0pXG5cbiAgICB3cmFwcGVkVG9bIG5hbWUgXSA9IGZcbiAgfWVsc2UgaWYoIGZyb20udHlwZSA9PT0gJ2dlbicgKSB7XG4gICAgLy8gZ2VuIG9iamVjdHMgY2FuIGJlIHJlZmVycmVkIHRvIHdpdGhvdXQgdGhlIGdyYXBoaWNzL2F1ZGlvIGFic3RyYWN0aW9uLFxuICAgIC8vIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIGhhdmUgbm8gLnJlbmRlcigpIGZ1bmN0aW9uLCBhbmQgZG9uJ3QgbmVlZCB0byBiZSByZW5kZXJlZFxuICAgIGNvbnN0IGdlbiA9IGZyb20ucmVuZGVyICE9PSB1bmRlZmluZWQgPyBmcm9tLnJlbmRlcigpIDogZnJvbVxuXG4gICAgd3JhcHBlZFRvWyBuYW1lIF0gPSBnZW5cbiAgfVxufVxuXG5jb25zdCBVZ2VuID0gZnVuY3Rpb24oIGdpYmJlcmlzaENvbnN0cnVjdG9yLCBkZXNjcmlwdGlvbiwgQXVkaW8sIHNob3VsZFVzZVBvb2wgPSBmYWxzZSwgaXNCaW5vcCA9IGZhbHNlICkge1xuXG4gIGxldCAgIHBvb2xDb3VudCA9IHBvb2xTaXplXG4gIGNvbnN0IHBvb2wgPSBbXVxuXG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFByZXNldHMucHJvY2VzcyggZGVzY3JpcHRpb24sIGFyZ3MsIEF1ZGlvICkgXG4gICAgY29uc3QgdGltZVByb3BzID0gQXVkaW8udGltZVByb3BzWyBkZXNjcmlwdGlvbi5uYW1lIF0gPT09IHVuZGVmaW5lZCA/IFtdIDogQXVkaW8udGltZVByb3BzWyBkZXNjcmlwdGlvbi5uYW1lIF1cblxuICAgIGlmKCB0aW1lUHJvcHMubGVuZ3RoID4gMCApIHtcbiAgICAgIGZvciggbGV0IGtleSBpbiBwcm9wZXJ0aWVzICkge1xuICAgICAgICBpZiggdGltZVByb3BzLmluZGV4T2YoIGtleSApID4gLTEgKSB7XG4gICAgICAgICAgcHJvcGVydGllc1sga2V5IF0gPSBBdWRpby5DbG9jay50aW1lKCBwcm9wZXJ0aWVzWyBrZXkgXSApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBYWFggaWYgeW91IHdhbnQgdG8gdXNlIHBvb2xpbmcgeW91IG11c3QgYWxzbyB1bmNvbW1lbnQgbmVhciB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS4uLlxuICAgIC8vIFBvb2xpbmcgY291bGQgd29yayBmb3IgcmV2ZXJicyBJRjpcbiAgICAvLyAxLiBUaGVyZSB3b3VsZCBoYXZlIHRvIGJlIHNlcGFyYXRlIG1vbm8gYW5kIHN0ZXJlbyBwb29scy4yXG4gICAgLy8gMi4gUmV2ZXJicyB3b3VsZCBuZWVkIHRvIHJ1biB3aXRoIDAgaW5wdXQgZm9yIGEgd2hpbGUgc28gdGhhdCB0aGUgZnVuY3Rpb25zIGFyZSBKSVQnZFxuXG4gICAgLy9pZiggc2hvdWxkVXNlUG9vbCAmJiBwb29sQ291bnQgPCBwb29sLmxlbmd0aCApIHtcbiAgICAvLyAgcG9vbFsgcG9vbENvdW50IF0uaW5Vc2UgPSB0cnVlXG4gICAgLy8gIGNvbnN0IHBvb2xVZ2VuID0gcG9vbFsgcG9vbENvdW50IF0udWdlblxuICAgIC8vICBwb29sQ291bnQrK1xuICAgIC8vICBPYmplY3QuYXNzaWduKCBwb29sVWdlbiwgcHJvcGVydGllcywgYXJncyApXG4gICAgLy8gIGNvbnNvbGUubG9nKCAncG9vbCB1Z2VuOicsIHBvb2xVZ2VuIClcbiAgICAvLyAgcmV0dXJuIHBvb2xVZ2VuXG4gICAgLy99XG5cbiAgICBsZXQgX193cmFwcGVkT2JqZWN0XG4gICAgaWYoIGlzQmlub3AgPT09IHRydWUgKSB7XG4gICAgICBfX3dyYXBwZWRPYmplY3QgPSBnaWJiZXJpc2hDb25zdHJ1Y3RvciggLi4uYXJncyApIFxuICAgIH1lbHNle1xuICAgICAgX193cmFwcGVkT2JqZWN0ID0gZ2liYmVyaXNoQ29uc3RydWN0b3IoIHByb3BlcnRpZXMgKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBvYmogPSB7IFxuICAgICAgX193cmFwcGVkX18gOl9fd3JhcHBlZE9iamVjdCxcbiAgICAgIF9fc2VxdWVuY2VycyA6IFtdLCBcbiAgICAgIF9fdGlkYWxzOiBbXSxcbiAgICAgIG5hbWU6ZGVzY3JpcHRpb24ubmFtZSxcbiAgICAgIHR5cGU6J2F1ZGlvJyxcblxuICAgICAgc3RvcCggdGltZT1udWxsICkge1xuICAgICAgICBpZiggdGltZSA9PT0gbnVsbCApIHtcbiAgICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3NlcXVlbmNlcnMgKSBzZXEuc3RvcCgpXG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX190aWRhbHMgKSBzZXEuc3RvcCgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHRpbWUgPSBBdWRpby5DbG9jay50aW1lKCB0aW1lIClcbiAgICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3NlcXVlbmNlcnMgKSB7XG4gICAgICAgICAgICBmdXR1cmUoIHNlcSA9PiBzZXEuc3RvcCgpLCB0aW1lLCB7IHNlcSB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fdGlkYWxzICkge1xuICAgICAgICAgICAgZnV0dXJlKCBzZXEgPT4gc2VxLnN0b3AoKSwgdGltZSwgeyBzZXEgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBwbGF5KCB0aW1lPW51bGwgKSB7XG4gICAgICAgIGlmKCB0aW1lID09PSBudWxsICkge1xuICAgICAgICAgIGZvciggbGV0IHNlcSBvZiB0aGlzLl9fc2VxdWVuY2VycyApIHNlcS5zdGFydCgpXG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX190aWRhbHMgKSBzZXEuc3RhcnQoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aW1lID0gQXVkaW8uQ2xvY2sudGltZSggdGltZSApXG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX19zZXF1ZW5jZXJzICkge1xuICAgICAgICAgICAgZnV0dXJlKCBzZXEgPT4gc2VxLnN0YXJ0KCksIHRpbWUsIHsgc2VxIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKCBsZXQgc2VxIG9mIHRoaXMuX190aWRhbHMgKSB7XG4gICAgICAgICAgICBmdXR1cmUoIHNlcSA9PiBzZXEuc3RhcnQoKSwgdGltZSwgeyBzZXEgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3NlcXVlbmNlcnMgKSB7XG4gICAgICAgICAgc2VxLmNsZWFyKClcbiAgICAgICAgfVxuICAgICAgICBmb3IoIGxldCBzZXEgb2YgdGhpcy5fX3RpZGFscyApIHtcbiAgICAgICAgICBzZXEuY2xlYXIoKVxuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coIEdpYmJlcmlzaC5tb2RlLCBfX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkIClcbiAgICAgICAgaWYoIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBmb3IoIGxldCBjb25uZWN0aW9uIG9mIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWQgKSB7XG4gICAgICAgICAgICBpZiggdGhpcy5meC5pbmRleE9mKCBjb25uZWN0aW9uWyAwIF0gKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCggY29ubmVjdGlvblsgMCBdIClcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiggdGhpcy5fX29uY2xlYXIgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICB0aGlzLl9fb25jbGVhcigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcG9seSBtZXRob2RzXG4gICAgaWYoIGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignUG9seScpID4gLTEgfHwgZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdNdWx0aScpID4gLTEgfHwgZGVzY3JpcHRpb24ubmFtZS5pbmRleE9mKCdTb3VuZGZvbnQnKSA+IC0xICkge1xuICAgICAgbGV0IHVzZVByb3AgPSBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1BvbHknKSA+IC0xXG4gICAgICBvYmouc3ByZWFkID0gZnVuY3Rpb24oIGFtdD0xICkge1xuICAgICAgICBpZiggYW10ID09PSAwICkge1xuICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goIChjLGkpID0+IHsgXG4gICAgICAgICAgICBpZiggdXNlUHJvcCApIFxuICAgICAgICAgICAgICBjLnBhbiA9IC41IFxuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgaWYoIG9iai5tYXhWb2ljZXMudmFsdWUgPiAxICkgb2JqLnNldHBhbihpLC41KSBcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX193cmFwcGVkX18udm9pY2VzXG4gICAgICAgIGNvbnN0IGluY3IgPSAxLyhjaGlsZHJlbi5sZW5ndGgtMSkgKiBhbXRcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCggKGMsaSkgPT4ge1xuICAgICAgICAgIGlmKCB1c2VQcm9wICkgXG4gICAgICAgICAgICBjLnBhbiA9ICguNSAtIGFtdC8yKSArIGkgKiBpbmNyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYoIG9iai5tYXhWb2ljZXMudmFsdWUgPiAxICkgb2JqLnNldHBhbiggaSwgKC41LWFtdC8yKSArIGkgKiBpbmNyIClcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICBvYmoudm9pY2VzID0gb2JqLl9fd3JhcHBlZF9fLnZvaWNlc1xuICAgICAgb2JqLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5ncm91cCggJ0luc3BlY3RpbmcgJyArIGRlc2NyaXB0aW9uLm5hbWUgKVxuICAgICAgICBjb25zb2xlLnRhYmxlKCBPYmplY3QuYXNzaWduKHt9LCBvYmoudm9pY2VzWzBdLl9fd3JhcHBlZF9fLl9fcHJvcGVydGllc19fLCBvYmouX193cmFwcGVkX18uX19wcm9wZXJ0aWVzX18gKSApXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgfVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCAyMDsgaSsrICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iaiwgaSwgeyBnZXQoKSB7IHJldHVybiBvYmoudm9pY2VzW2ldIH0gfSlcbiAgICAgIH1cbiAgICB9XG4vL2J0b3M6IGZ1bmN0aW9uKCBiZWF0cyApIHtcbi8vICAgIGNvbnN0IHNhbXBsZXNQZXJCZWF0ID0gR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gKHRoaXMuYnBtIC8gNjAgKVxuLy8gICAgcmV0dXJuIHNhbXBsZXNQZXJCZWF0ICogYmVhdHMgXG4vLyAgfVxuICAgIC8vIHRyYW5zZm9ybSBiZWF0IHZhbHVlcyB0byBzYW1wbGVzXG4gICAgLy8gaW4gdGhlIGNhc2Ugb2YgYSBnZW4gZ3JhcGggY29udmVydCB0byBhIG5ldyBnZW4gb2JqZWN0XG4gICAgY29uc3QgdGltZXRyYW5zZm9ybSA9IGZ1bmN0aW9uKCB2ICkge1xuICAgICAgY29uc3Qgb3V0ID0gdHlwZW9mIHYgPT09ICdudW1iZXInIFxuICAgICAgICA/IEF1ZGlvLkNsb2NrLnRpbWUoIHYgKSBcbiAgICAgICAgOiB2LnR5cGUgPT09ICdnZW4nIFxuICAgICAgICAgID8gR2VuLm1ha2UoIFxuICAgICAgICAgICAgICBnZW5pc2gubXVsKCBcbiAgICAgICAgICAgICAgICBnZW5pc2guZGl2KCA0NDEwMCwgZ2VuaXNoLmRpdiggQ2xvY2suYnBtLCA2MCApICksXG4gICAgICAgICAgICAgICAgdi5ncmFwaFxuICAgICAgICAgICAgICApIFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogdlxuXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuXG4gICAgLy8gd3JhcCBwcm9wZXJ0aWVzIGFuZCBhZGQgc2VxdWVuY2luZyB0byB0aGVtXG4gICAgZm9yKCBsZXQgcHJvcGVydHlOYW1lIGluIGRlc2NyaXB0aW9uLnByb3BlcnRpZXMgKSB7XG4gICAgICBpZiggX193cmFwcGVkT2JqZWN0Ll9fcmVxdWlyZWRSZWNvbXBpbGF0aW9uICYmIF9fd3JhcHBlZE9iamVjdC5fX3JlcXVpcmVzUmVjb21waWxhdGlvbi5pbmRleE9mKCBwcm9wZXJ0eU5hbWUgKSA+IC0xICkgY29udGludWVcbiAgICAgIC8vIFhYWCB3ZSBoYXZlIHRvIHBhc3MgaWQgaW4gdGhlIHZhbHVlcyBkaWN0aW9uYXJ5IHVuZGVyIFxuICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zIGludm9sb3ZpbmcgZ2VuIHVnZW5zLCBidXQgd2UgZG9uJ3QgXG4gICAgICAvLyB3YW50IC5pZCB0byBiZSBzZXF1ZW5jYWJsZSFcbiAgICAgIGlmKCBwcm9wZXJ0eU5hbWUgIT09ICdpZCcgJiYgcHJvcGVydHlOYW1lICE9PSAndHlwZScgKXtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGltZVByb3BzLmluZGV4T2YoIHByb3BlcnR5TmFtZSApID4gLTEgXG4gICAgICAgICAgPyB0aW1ldHJhbnNmb3JtXG4gICAgICAgICAgOiBudWxsIFxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gX193cmFwcGVkT2JqZWN0WyBwcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkIFxuICAgICAgICAgID8gX193cmFwcGVkT2JqZWN0Ll9fcHJvcGVydGllc19fWyBwcm9wZXJ0eU5hbWUgXVxuICAgICAgICAgIDogX193cmFwcGVkT2JqZWN0WyBwcm9wZXJ0eU5hbWUgXVxuXG4gICAgICAgIEF1ZGlvLmNyZWF0ZVByb3BlcnR5KCBvYmosIHByb3BlcnR5TmFtZSwgdmFsdWUsIG51bGwsIDAsIHRyYW5zZm9ybSApXG5cbiAgICAgICAgLy8gY3JlYXRlIHBlci12b2ljZSB2ZXJzaW9uIG9mIHByb3BlcnR5Li4uIHdoYXQgcHJvcGVydGllcyBzaG91bGQgYmUgZXhjbHVkZWQ/XG4gICAgICAgIGlmKCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1BvbHknKSA+IC0xIHx8IGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignTXVsdGknKSA+IC0xIHx8IGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignU291bmRmb250JykgPiAtMSApIHtcbiAgICAgICAgICBBdWRpby5jcmVhdGVQcm9wZXJ0eSggb2JqLCBwcm9wZXJ0eU5hbWUrJ1YnLCB2YWx1ZSwgbnVsbCwgMCwgdHJhbnNmb3JtLCB0cnVlICkvLywgdGltZVByb3BzLCBBdWRpbywgdHJ1ZSApXG5cbiAgICAgICAgICAvL2NyZWF0ZVByb3BlcnR5KCBvYmosIHByb3BlcnR5TmFtZSwgX193cmFwcGVkT2JqZWN0LCB0aW1lUHJvcHMsIEF1ZGlvLCB0cnVlIClcbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgd2F5IHRvIGFkZCBwcm9wZXJ0aWVzIHRvIG9iamVjdHMgaW4gdGhlIHByb2Nlc3NvciB0aHJlYWRcbiAgICAgICAgICAvLyBzbyB3ZSdsbCBqdXN0IGFkZCBhIG1ldGhvZC4uLiBzZXF1ZW5jaW5nIHdpbGwgc3RpbGwgd29yayB0aGUgc2FtZS5cbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J2FkZE1ldGhvZCcsXG4gICAgICAgICAgICBpZDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICBrZXk6cHJvcGVydHlOYW1lKydWJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uOmBmdW5jdGlvbiggdiApIHt0aGlzLnZvaWNlc1sgdGhpcy52b2ljZUNvdW50ICUgdGhpcy52b2ljZXMubGVuZ3RoIF1bICcke3Byb3BlcnR5TmFtZX0nIF0gPSB2IH1gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBkZXNjcmlwdGlvbi5tZXRob2RzICE9PSBudWxsICYmIGRlc2NyaXB0aW9uLm1ldGhvZHMuaW5kZXhPZiggJ25vdGUnICkgPiAtMSApIHsgXG4gICAgICBkZXNjcmlwdGlvbi5tZXRob2RzLnB1c2goICdub3RlZicgKVxuICAgICAgZGVzY3JpcHRpb24ubWV0aG9kcy5wdXNoKCAnbm90ZWMnIClcbiAgICB9XG5cbiAgICAvLyB3cmFwIG1ldGhvZHMgYW5kIGFkZCBzZXF1ZW5jaW5nIHRvIHRoZW1cbiAgICBpZiggZGVzY3JpcHRpb24ubWV0aG9kcyAhPT0gbnVsbCApIHtcbiAgICAgIGZvciggbGV0IG1ldGhvZE5hbWUgb2YgZGVzY3JpcHRpb24ubWV0aG9kcyApIHtcbiAgICAgICAgaWYoIG1ldGhvZE5hbWUgIT09ICdub3RlJyB8fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1NhbXBsZXInKSA+IC0xIHx8IGRlc2NyaXB0aW9uLm5hbWUuaW5kZXhPZignTXVsdGlzYW1wbGVyJykgPiAtMSApIHsgLy98fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1NvdW5kZm9udCcpID4gLTEgKSB7XG4gICAgICAgICAgLy9vYmpbIG1ldGhvZE5hbWUgXSA9IF9fd3JhcHBlZE9iamVjdFsgbWV0aG9kTmFtZSBdLmJpbmQoIF9fd3JhcHBlZE9iamVjdCApXG4gICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0gPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgICAgICAgIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0WyBtZXRob2ROYW1lIF0oKVxuICAgICAgICAgICAgfWVsc2V7IC8vaWYoIGFyZ3MubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAvL2lmKCBBcnJheS5pc0FycmF5KCBhcmdzWzBdICkgKSB7XG4gICAgICAgICAgICAgIC8vICBvYmpbIG1ldGhvZE5hbWUgXS5zZXEoIGFyZ3NbMF0sIDEvYXJnc1swXS5sZW5ndGggKVxuICAgICAgICAgICAgICAvL31lbHNlIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgIC8vICBvYmpbIG1ldGhvZE5hbWUgXS50aWRhbCggYXJnc1swXSApXG4gICAgICAgICAgICAgIC8vfWVsc2V7XG4gICAgICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0WyBtZXRob2ROYW1lIF0oIC4uLmFyZ3MgKVxuICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgIH0vKmVsc2V7XG4gICAgICAgICAgICAgIC8vIGNvdWxkIGJlIGEgLnRpZGFsIG9yIGEgc2VxIFxuICAgICAgICAgICAgICBpZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICkgeyAvLyBtdXN0IGJlIHRpZGFsIHdpdGggdGlkYWwgaWQgI1xuICAgICAgICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnRpZGFsKCAuLi5hcmdzIClcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxKCAuLi5hcmdzICkgIC8vIG11c3QgYmUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyBpbiB0aGlzIGJsb2NrIHdlIGFyZSBtb25rZXkgcGF0Y2hpbmcgdGhlIG5vdGUgbWV0aG9kIG9mIEdpYmJlcmlzaCBzeW50aHMgc28gdGhhdFxuICAgICAgICAgIC8vIHRoZXkgdXNlIEdpYmJlcidzIGhhcm1vbmljIHN5c3RlbSBpbnNpZGUgdGhlIEF1ZGlvV29ya2xldFByb2Nlc3Nvci5cblxuICAgICAgICAgIG9ialsgbWV0aG9kTmFtZSBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkU2VuZE5vdGVOb3cgPSBmYWxzZVxuICAgICAgICAgICAgaWYoIGFyZ3MubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgc2hvdWxkU2VuZE5vdGVOb3cgPSB0cnVlXG4gICAgICAgICAgICB9ZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCBhcmdzWzBdICkgKSB7XG4gICAgICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxKCBhcmdzWzBdLCAxL2FyZ3NbMF0ubGVuZ3RoIClcbiAgICAgICAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXS50aWRhbCggYXJnc1swXSApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNob3VsZFNlbmROb3RlTm93ID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgLy8gY291bGQgYmUgYSAudGlkYWwgb3IgYSBzZXEgXG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgKSB7IC8vIG11c3QgYmUgdGlkYWwgd2l0aCB0aWRhbCBpZCAjXG4gICAgICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0udGlkYWwoIC4uLmFyZ3MgKVxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXS5zZXEoIC4uLmFyZ3MgKSAgLy8gbXVzdCBiZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgYmUgZm9yIGRpcmVjdCBjYWxscyBmcm9tIHRoZSBJREVcbiAgICAgICAgICAgIGlmKCBzaG91bGRTZW5kTm90ZU5vdyAmJiBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOidtZXRob2QnLFxuICAgICAgICAgICAgICAgIG9iamVjdDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICAgICAgbmFtZTptZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cblxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczonYWRkTWV0aG9kJyxcbiAgICAgICAgICAgIGlkOl9fd3JhcHBlZE9iamVjdC5pZCxcbiAgICAgICAgICAgIGtleTonbm90ZWYnLFxuICAgICAgICAgICAgZnVuY3Rpb246YGZ1bmN0aW9uKCBub3RlLCBfX2xvdWRuZXNzPW51bGwgKXtcbiAgICAgICAgICAgICAgY29uc3QgbG91ZG5lc3MgPSBfX2xvdWRuZXNzID0gbnVsbCA/IHRoaXMuX190cmlnZ2VyTG91ZG5lc3MgOiBfX2xvdWRuZXNzXG4gICAgICAgICAgICAgIHRoaXMuX19fbm90ZSggbm90ZSwgbG91ZG5lc3MgKSBcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgfSlcbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J2FkZE1ldGhvZCcsXG4gICAgICAgICAgICBpZDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICBrZXk6J25vdGVjJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uOmBmdW5jdGlvbiggbm90ZSwgX19sb3VkbmVzcz1udWxsICl7XG4gICAgICAgICAgICAgIGNvbnN0IGxvdWRuZXNzID0gX19sb3VkbmVzcyA9IG51bGwgPyB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzIDogX19sb3VkbmVzc1xuICAgICAgICAgICAgICB0aGlzLm5vdGUoIG5vdGUsIGxvdWRuZXNzLCBmYWxzZSApIFxuICAgICAgICAgICAgfWBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGF0IHRoZSBhZGRyZXNzICdtb25rZXlQYXRjaCcsXG4gICAgICAgICAgLy8gR2liYmVyaXNoIHdpbGwgY3JlYXRlIGEgY29weSBvZiB0aGUgbWV0aG9kIGlkZW50aWZpZWQgYnlcbiAgICAgICAgICAvLyB0aGUgJ2tleScgZmllbGQsIGFuZCB0aGVuIGFzc2lnbiBpdCBiYWNrIHRvIHRoZSBvYmplY3QgcHJlZmFjZWRcbiAgICAgICAgICAvLyB3aXRoIGRvdWJsZSB1bmRlcnNjb3JlcyAoZS5nLiBfX25vdGUpLiBUaGUgZnVuY3Rpb24gdGhhdCBpcyBiZWluZ1xuICAgICAgICAgIC8vIHBhdGNoZWQgaW4gY2FuIHRoZW4gY2FsbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gdXNpbmcgdGhlIHByZWZhY2VkIFxuICAgICAgICAgIC8vIG5hbWUsIGFzIGlzIGRvbmUgaW4gdGhlIGxhc3QgbGluZSBvZiB0aGUgYXJndW1lbnQgZnVuY3Rpb24gYmVsb3cuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBhZGRyZXNzOidtb25rZXlQYXRjaCcsXG4gICAgICAgICAgICBpZDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICBrZXk6J25vdGUnLFxuICAgICAgICAgICAgZnVuY3Rpb246YGZ1bmN0aW9uKCBub3RlLCBfX2xvdWRuZXNzLCByb3VuZD10cnVlICl7IFxuICAgICAgICAgICAgICBjb25zdCBvY3RhdmUgPSB0aGlzLm9jdGF2ZSB8fCAwXG4gICAgICAgICAgICAgIGxldCBub3Rlc0luT2N0YXZlID0gN1xuICAgICAgICAgICAgICBjb25zdCBtb2RlID0gR2liYmVyaXNoLlRoZW9yeS5tb2RlXG5cbiAgICAgICAgICAgICAgaWYoIG1vZGUgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgbm90ZXNJbk9jdGF2ZSA9IG1vZGUgIT09ICdjaHJvbWF0aWMnID8gR2liYmVyaXNoLlRoZW9yeS5tb2Rlc1sgbW9kZSBdLmxlbmd0aCA6IEdpYmJlcmlzaC5UaGVvcnkuVHVuZS5zY2FsZS5sZW5ndGhcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbm90ZXNJbk9jdGF2ZSA9IEdpYmJlcmlzaC5UaGVvcnkuVHVuZS5zY2FsZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG9jdGF2ZSAqIG5vdGVzSW5PY3RhdmVcbiAgICAgICAgICAgICAgbGV0IF9fbm90ZSA9IEdpYmJlcmlzaC5UaGVvcnkubm90ZSggbm90ZSArIG9mZnNldCwgMCwgcm91bmQgKVxuXG4gICAgICAgICAgICAgIGNvbnN0IGxvdWRuZXNzID0gX19sb3VkbmVzcyA9IG51bGwgPyB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzIDogX19sb3VkbmVzc1xuICAgICAgICAgICAgICB0aGlzLl9fX25vdGUoIF9fbm90ZSwgbG91ZG5lc3MgKSBcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtZXRob2ROYW1lID09PSAnbm90ZWYnICkge1xuICAgICAgICAgIG9iai5ub3RlZiA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmZyZXF1ZW5jeSA9IGFyZ3NbMF1cbiAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC50cmlnZ2VyKCBfX3dyYXBwZWRPYmplY3QuX190cmlnZ2VyTG91ZG5lc3MgKVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG1ldGhvZE5hbWUgPT09ICdub3RlYycgKSB7XG4gICAgICAgICAgb2JqLm5vdGVjID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICAgICAgICAvL19fd3JhcHBlZE9iamVjdC5mcmVxdWVuY3kgPSBhcmdzWzBdXG4gICAgICAgICAgICAvL19fd3JhcHBlZE9iamVjdC50cmlnZ2VyKCBfX3dyYXBwZWRPYmplY3QuX190cmlnZ2VyTG91ZG5lc3MgKVxuICAgICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGFkZHJlc3M6J21ldGhvZCcsXG4gICAgICAgICAgICAgIG9iamVjdDpfX3dyYXBwZWRPYmplY3QuaWQsXG4gICAgICAgICAgICAgIG5hbWU6J25vdGVjJyxcbiAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxdWVuY2VycyA9IFtdXG4gICAgICAgIG9ialsgbWV0aG9kTmFtZSBdLnRpZGFscyA9IFtdXG5cbiAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxID0gZnVuY3Rpb24oIHZhbHVlcywgdGltaW5ncywgbnVtYmVyPTAsIGRlbGF5PTAsIHByaW9yaXR5PTEwMDAwICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCAnbWV0aG9kIHNlcTonLCBtZXRob2ROYW1lLCBudW1iZXIgKVxuICAgICAgICAgIGxldCBwcmV2U2VxID0gb2JqWyBtZXRob2ROYW1lIF0uc2VxdWVuY2Vyc1sgbnVtYmVyIF0gXG4gICAgICAgICAgaWYoIHByZXZTZXEgIT09IHVuZGVmaW5lZCApIHsgXG4gICAgICAgICAgICBjb25zdCBpZHggPSBvYmouX19zZXF1ZW5jZXJzLmluZGV4T2YoIHByZXZTZXEgKVxuICAgICAgICAgICAgb2JqLl9fc2VxdWVuY2Vycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgICAvL3ByZXZTZXEuc3RvcCgpXG4gICAgICAgICAgICBwcmV2U2VxLmNsZWFyKClcbiAgICAgICAgICAgIC8vIHJlbW92ZVNlcSggb2JqLCBwcmV2U2VxIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcyA9IEF1ZGlvLkNvcmUuU2VxKHsgdmFsdWVzLCB0aW1pbmdzLCB0YXJnZXQ6b2JqLypfX3dyYXBwZWRPYmplY3QqLywga2V5Om1ldGhvZE5hbWUsIHByaW9yaXR5IH0pXG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHR5cGVvZiBkZWxheSAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHMuc3RhcnQoIEF1ZGlvLkNsb2NrLnRpbWUoIGRlbGF5ICkgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgZGVsYXkuc2Vxcy5wdXNoKCBzIClcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0uc2VxdWVuY2Vyc1sgbnVtYmVyIF0gPSBvYmpbIG1ldGhvZE5hbWUgXVsgbnVtYmVyIF0gPSBzIFxuICAgICAgICAgIG9iai5fX3NlcXVlbmNlcnMucHVzaCggcyApXG5cbiAgICAgICAgICAvLyByZXR1cm4gb2JqZWN0IGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cbiAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0udGlkYWw9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBudW1iZXI9MCwgZGVsYXk9MCApIHtcbiAgICAgICAgICBsZXQgcHJldlNlcSA9IG9ialsgbWV0aG9kTmFtZSBdLnRpZGFsc1sgbnVtYmVyIF0gXG4gICAgICAgICAgbGV0IHMgPSBBdWRpby5Db3JlLlRpZGFsKHsgcGF0dGVybiwgdGFyZ2V0Ol9fd3JhcHBlZE9iamVjdCwga2V5Om1ldGhvZE5hbWUgfSlcbiAgICAgICAgICBpZiggcyAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIGlmKCBwcmV2U2VxICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICAgICAgICBjb25zdCBpZHggPSBvYmouX190aWRhbHMuaW5kZXhPZiggcHJldlNlcSApXG4gICAgICAgICAgICAgIG9iai5fX3RpZGFscy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgICAgIHByZXZTZXEuc3RvcCgpXG4gICAgICAgICAgICAgIHByZXZTZXEuY2xlYXIoKVxuICAgICAgICAgICAgICAvLyByZW1vdmVTZXEoIG9iaiwgcHJldlNlcSApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMuc3RhcnQoIEF1ZGlvLkNsb2NrLnRpbWUoIGRlbGF5ICkgKVxuICAgICAgICAgICAgb2JqWyBtZXRob2ROYW1lIF0udGlkYWxzWyBudW1iZXIgXSA9IG9ialsgbWV0aG9kTmFtZSBdWyBudW1iZXIgXSA9IHMgXG4gICAgICAgICAgICBvYmouX190aWRhbHMucHVzaCggcyApXG5cbiAgICAgICAgICAgIC8vIFhYWCBuZWVkIHRvIGNsZWFuIHRoaXMgdXAhIHRoaXMgaXMgc29sZWx5IGhlcmUgZm9yIGFubm90YXRpb25zLCBhbmQgdG8gXG4gICAgICAgICAgICAvLyBtYXRjaCB3aGF0IEkgZGlkIGZvciBlbnNlbWJsZXMuLi4gXG4gICAgICAgICAgICBvYmpbIG1ldGhvZE5hbWUgXS5fX3RpZGFsID0gc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJldHVybiBvYmplY3QgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cblxuXG4gICAgbGV0IGlkID0gX193cmFwcGVkT2JqZWN0LmlkXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBfX3dyYXBwZWRPYmplY3QsICdpZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTpmYWxzZSxcbiAgICAgIGdldCgpIHsgcmV0dXJuIGlkIH0sXG4gICAgICBzZXQodikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCAndHJpZWQgdG8gY2hhbmdlIGlkOicsIG9iaiApXG4gICAgICAgIC8vZGVidWdnZXJcbiAgICAgIH1cbiAgICB9KVxuICAgIG9iai5pZCA9IF9fd3JhcHBlZE9iamVjdC5pZFxuXG4gICAgb2JqLl9fZm9sbG93ID0gbnVsbFxuXG4gICAgY29uc3QgZm9sbG93Y2hlY2sgPSAoKT0+IHtcblxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCAnX19vdXQnLCB7XG4gICAgICBjb25maWd1cmFibGU6ZmFsc2UsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmKCBvYmouX19mb2xsb3cgPT09IG51bGwgKSB7XG4gICAgICAgICAgb2JqLl9fZm9sbG93ID0gQXVkaW8uYW5hbHlzaXMuRm9sbG93KHsgaW5wdXQ6b2JqIH0pIFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb2JqLl9fZm9sbG93Lm91dHB1dFxuICAgICAgICAgXG4gICAgICAgIC8vIHdpbGwgdGFrZSBhIGZldyBidWZmZXJzIHRvIGluaXRpYWxpemUuLi5cbiAgICAgICAgaWYoIG91dHB1dCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIDBcblxuICAgICAgICByZXR1cm4gb3V0cHV0WzFdID09PSB1bmRlZmluZWQgPyBvdXRwdXRbMF0gOiBvdXRwdXRbMF0gKyBvdXRwdXRbMV0gXG4gICAgICB9LFxuICAgICAgc2V0KHYpIHt9XG4gICAgfSlcblxuICAgIG9iai5pbnNwZWN0ID0gKCk9PiB7XG4gICAgICBjb25zb2xlLmdyb3VwKCAnSW5zcGVjdGluZyAnICsgZGVzY3JpcHRpb24ubmFtZSApXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIG9iai5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfXyApXG4gICAgICBjb25zdCBwcm9wcyA9IHt9XG4gICAgICBrZXlzLmZvckVhY2goIGtleSA9PiB7XG4gICAgICAgIGlmKCBrZXlbMF0gIT09ICdfJyApIHtcbiAgICAgICAgICBpZiggb2JqWyBrZXkgXSAhPT0gbnVsbCAmJiBvYmpbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBwcm9wc1sga2V5IF0gPSBvYmpbIGtleSBdLnZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgY29uc29sZS50YWJsZSggcHJvcHMgKSBcbiAgICAgIC8vY29uc29sZS50YWJsZSggb2JqLl9fd3JhcHBlZF9fLl9fcHJvcGVydGllc19fIClcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgIH1cblxuICAgIG9iai5vdXQgPSBmdW5jdGlvbiggc2NhbGU9MSwgb2Zmc2V0PTAsIGJ1ZmZlclNpemU9bnVsbCApIHtcbiAgICAgIC8vIGlmIHRoZSBidWZmZXIgc2l6ZSBjaGFuZ2VzLi4uXG4gICAgICBpZiggYnVmZmVyU2l6ZSAhPT0gbnVsbCApIHtcbiAgICAgICAgaWYoIG9iai5fX2ZvbGxvdyAhPT0gbnVsbCApIHtcbiAgICAgICAgICBpZiggYnVmZmVyU2l6ZSAhPT0gb2JqLl9fZm9sbG93Ll9fd3JhcHBlZF9fLmJ1ZmZlclNpemUgKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAncHJldiBmb2xsb3cnLCBidWZmZXJTaXplLCBvYmouX19mb2xsb3cuX193cmFwcGVkX18uYnVmZmVyU2l6ZSwgb2JqLl9fZm9sbG93IClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdG1wID0gb2JqLl9fZm9sbG93XG4gICAgICAgICAgICAvLyBYWFggbmVlZCB0byByZW1vdmUgdGhlIHByZXZpb3VzIGZvbGxvdyBmcm9tIHRoZSBncmFwaC4uLlxuICAgICAgICAgICAgb2JqLl9fZm9sbG93ID0gQXVkaW8uYW5hbHlzaXMuRm9sbG93KHsgaW5wdXQ6QXVkaW8uR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCBvYmouX19mb2xsb3cuX193cmFwcGVkX18uaW5wdXQuaWQgKSwgYnVmZmVyU2l6ZSB9KVxuXG4gICAgICAgICAgICBBdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgYWRkcmVzczonZXZhbCcsXG4gICAgICAgICAgICAgIGNvZGU6YGNvbnN0IGlkeCA9IEdpYmJlcmlzaC5hbmFseXplcnMuZmluZEluZGV4KCB1Z2VuID0+IHVnZW4uaWQgPT09ICR7dG1wLmlkfSApXG4gICAgICAgICAgICAgICAgICAgIGlmKCBpZHggPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnNwbGljZShpZHgsMSlcbiAgICAgICAgICAgICAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIFVnZW4uT1VUUFVUID09PSBVZ2VuLk9VVFBVVF9GVU5DVElPTiApXG4gICAgICAgIHJldHVybiAoKT0+IG9iai5fX291dCAqIHNjYWxlICsgb2Zmc2V0XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBNYXRoLmFicyggb2JqLl9fb3V0ICogc2NhbGUgKSArIG9mZnNldCBcbiAgICB9XG5cbiAgICAvLyBYWFggd2hlcmUgZG9lcyBzaG91bGRBZGRUb1VnZW4gY29tZSBmcm9tPyBOb3QgZnJvbSBwcmVzZXRzLmpzLi4uXG4gICAgaWYoIHByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLnNob3VsZEFkZFRvVWdlbiApIE9iamVjdC5hc3NpZ24oIG9iaiwgcHJvcGVydGllcyApXG5cbiAgICAvLyBjcmVhdGUgZnggY2hhaW5pbmcgYXBpLiBlLmcuIHN5bnRoLmZ4LmFkZCggQ2hvcnVzKCksIEZyZWV2ZXJiKCkgKVxuICAgIC8vIHdlIHVzZSB0aGUgJ2FkZCcgbWV0aG9kIHRvIGVuYWJsZSBtZXRob2QgY2hhaW5pbmcgYWxvbmdzaWRlIGluc3RydW1lbnQgY2FsbHMgdG9cbiAgICAvLyAuY29ubmVjdCgpIGFuZCAuc2VxKClcblxuICAgIGNvbnN0IF9fZnggPSBbXVxuICAgIF9fZnguX19wdXNoID0gX19meC5wdXNoLmJpbmQoIF9fZnggKVxuICAgIF9fZnguYWRkID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBhcmdzLmZvckVhY2goIGZ4ID0+IG9iai5fX2Z4LnB1c2goIGZ4ICkgKVxuICAgICAgY29uc29sZS5sb2coIGBhZGRlZCAke2FyZ3MubGVuZ3RofSBlZmZlY3QocykgdG8gJHtvYmoubmFtZX1gIClcbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gICAgX19meC5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiggX19meC5sZW5ndGggPiAwIClcbiAgICAgICAgY29uc29sZS50YWJsZSggX19meC5tYXAoIGZ4PT5meC5uYW1lICkgKVxuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLmxvZyggYHRoZXJlIGFyZSBubyBlZmZlY3RzIG9uICR7b2JqLm5hbWV9IHRvIGluc3BlY3QuYCApXG4gICAgfVxuICAgIF9fZngucmVtb3ZlID0gZnVuY3Rpb24oIGVmZmVjdD1udWxsICkge1xuICAgICAgaWYoIGVmZmVjdCA9PT0gbnVsbCApIHtcbiAgICAgICAgb2JqLl9fZngubGVuZ3RoID0gMFxuICAgICAgICBjb25zb2xlLmxvZyggYGFsbCBlZmZlY3RzIGZyb20gJHtvYmoubmFtZX0gd2VyZSByZW1vdmVkLmAgKVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiBlZmZlY3QgPT09ICdudW1iZXInICkge1xuICAgICAgICAvLyBYWFggYnJva2VuIGZvciBpbmRpY2VzIHRoYXQgIT09IDBcbiAgICAgICAgY29uc3QgZGVsID0gb2JqLl9fZnguc3BsaWNlKCBlZmZlY3QsIDEgKVxuICAgICAgICBjb25zb2xlLmxvZyggYCR7ZGVsWzBdLm5hbWV9IGF0IGZ4IHNsb3QgJHtlZmZlY3R9IHdhcyByZW1vdmVkIGZyb20gJHtvYmoubmFtZX0uYCApIFxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiBlZmZlY3QgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBjb25zdCBpbmRleGVzVG9FcmFzZSA9IFtdXG4gICAgICAgIF9fZnguZm9yRWFjaCggKF9fZWZmZWN0LGkpID0+IHsgaWYoIGVmZmVjdCA9PT0gX19lZmZlY3QubmFtZSApIGluZGV4ZXNUb0VyYXNlLnB1c2goIGkgKSB9KVxuICAgICAgICBjb25zb2xlLmxvZyggYCR7aW5kZXhlc1RvRXJhc2UubGVuZ3RofSBlZmZlY3Qocykgd2VyZSByZW1vdmVkIGZyb20gJHtvYmoubmFtZX0uYCApIFxuICAgICAgICBmb3IoIGxldCBpID0gX19meC5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICBpZiggaW5kZXhlc1RvRXJhc2UuaW5jbHVkZXMoIGkgKSApIF9fZnguc3BsaWNlKCBpLCAxIClcbiAgICAgICAgfSAgIFxuICAgICAgfSBlbHNlIGlmKCB0eXBlb2YgZWZmZWN0ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gX19meC5pbmRleE9mKCBlZmZlY3QgKVxuICAgICAgICBfX2Z4LnNwbGljZSggaWR4LCAxIClcbiAgICAgICAgY29uc29sZS5sb2coIGBlZmZlY3QgJHtlZmZlY3QubmFtZX0gd2FzIHJlbW92ZWQgZnJvbSAke29iai5uYW1lfS5gICkgXG4gICAgICB9XG4gICAgfVxuICAgIG9iai5fX2Z4ID0gbmV3IFByb3h5KCBfX2Z4LCB7XG4gICAgICBzZXQoIHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciApIHtcblxuICAgICAgICBjb25zdCBsZW5ndGhDaGVjayA9IHRhcmdldC5sZW5ndGhcbiAgICAgICAgY29uc3Qgb2xkID0gdGFyZ2V0LnNsaWNlKDApXG4gICAgICAgIHRhcmdldFsgcHJvcGVydHkgXSA9IHZhbHVlXG4gICAgICAgIFxuICAgICAgICBpZiggcHJvcGVydHkgPT09ICdsZW5ndGgnICkgeyBcbiAgICAgICAgICBpZiggdGFyZ2V0Lmxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAvLyBYWFggbmVlZCB0byBzdG9yZSBhbmQgcmVhc3NpZ24gdG8gZW5kIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRhcmdldFsgdGFyZ2V0Lmxlbmd0aCAtIDIgXS5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIHRhcmdldFsgdGFyZ2V0Lmxlbmd0aCAtIDIgXS5jb25uZWN0KCB0YXJnZXRbIHRhcmdldC5sZW5ndGggLSAxIF0gKVxuICAgICAgICAgICAgdGFyZ2V0WyB0YXJnZXQubGVuZ3RoIC0gMSBdLmNvbm5lY3QoKVxuICAgICAgICAgIH1lbHNlIGlmKCB0YXJnZXQubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkID0gX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZCAhPT0gdW5kZWZpbmVkID9fX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkLnNsaWNlKDApIDogbnVsbFxuICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmRpc2Nvbm5lY3QoKVxuICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmNvbm5lY3QoIHRhcmdldFsgMCBdIClcblxuICAgICAgICAgICAgaWYoIGNvbm5lY3RlZCAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgZm9yKCBsZXQgY29ubmVjdGlvbiBvZiBjb25uZWN0ZWQgKSB7XG4gICAgICAgICAgICAgICAgLy8gMCBpcyBidXMsIDEgaXMgdWdlbiBhZGRpbmcgdGhlIGZ4LCAyIGlzIHNlbmQgYW1vdW50XG4gICAgICAgICAgICAgICAgdGFyZ2V0WzBdLmNvbm5lY3QoIGNvbm5lY3Rpb25bMF0sIGNvbm5lY3Rpb25bMl0gKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGFyZ2V0WzBdLmNvbm5lY3QoIEF1ZGlvLk1hc3RlciApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2UgaWYoIHZhbHVlID09PSAwICYmIGxlbmd0aENoZWNrICE9PSAwICkge1xuICAgICAgICAgICAgLy8gdWdoLi4uXG4gICAgICAgICAgICBpZiggX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBpZiggX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZFswXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0KCBcbiAgICAgICAgICAgICAgICAgIF9fd3JhcHBlZE9iamVjdC5jb25uZWN0ZWRbIDAgXVsgMCBdLl9fd3JhcHBlZF9fLmNvbm5lY3RlZFsgMCBdWyAwIF0sIFxuICAgICAgICAgICAgICAgICAgX193cmFwcGVkT2JqZWN0LmNvbm5lY3RlZFsgMCBdWyAwIF0uX193cmFwcGVkX18uY29ubmVjdGVkWyAwIF1bIDIgXSBcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICBfX3dyYXBwZWRPYmplY3QuY29ubmVjdGVkWyAwIF1bIDAgXS5kaXNjb25uZWN0KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosICdmeCcsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIG9iai5fX2Z4IH0sXG4gICAgICBzZXQodikge1xuICAgICAgICBjb25zdCB0bXBMZW5ndGggPSBvYmouX19meC5sZW5ndGhcbiAgICAgICAgb2JqLl9fZngubGVuZ3RoID0gMFxuICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdiApICkge1xuICAgICAgICAgIHYuZm9yRWFjaCggZWZmZWN0ID0+IG9iai5fX2Z4LnB1c2goIGVmZmVjdCApICkgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG9iai5fX2Z4LnB1c2goIHYgKSBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0bXBMZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggYCR7dG1wTGVuZ3RofSBlZmZlY3Qocykgd2VyZSByZXBsYWNlZCB3aXRoICR7b2JqLl9fZngubGVuZ3RofSBlZmZlY3Qocykgb24gJHtvYmoubmFtZX1gIClcbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICBpZiggQXJyYXkuaXNBcnJheSggdiApICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coIGAke3YubGVuZ3RofSBlZmZlY3Qocykgd2VyZSBhZGRlZCB0byB0aGUgZnggY2hhaW4gb2YgJHtvYmoubmFtZX1gIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBgYSAke3YubmFtZX0gd2FzIGFkZGVkIHRvIHRoZSBmeCBjaGFpbiAgb2YgJHtvYmoubmFtZX1gIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgb2JqLmNvbm5lY3QgPSAoZGVzdCxsZXZlbD0xKSA9PiB7XG4gICAgICBpZiggdHlwZW9mIGRlc3QgIT09ICdudW1iZXInICkge1xuICAgICAgICBpZiggZGVzdCAhPT0gdW5kZWZpbmVkICYmIGRlc3QuaXNQcm9wZXJ0eSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAvLyBpZiBmaXJzdCBtb2R1bGF0aW9uIGZvciBwcm9wZXJ0eSwgc3RvcmUgaXQncyBpbml0aWFsXG4gICAgICAgICAgLy8gdmFsdWUgYmVmb3JlIG1vZHVsYXRpbmcgaXQuXG4gICAgICAgICAgaWYoIGRlc3QucHJlTW9kVmFsdWUgPT09IHVuZGVmaW5lZCApIHsgXG4gICAgICAgICAgICBkZXN0LnByZU1vZFZhbHVlID0gZGVzdC52YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QubW9kcy5wdXNoKCBvYmogKVxuXG4gICAgICAgICAgY29uc3Qgc3VtID0gZGVzdC5tb2RzLmNvbmNhdCggZGVzdC5wcmVNb2RWYWx1ZSApXG4gICAgICAgICAgY29uc3QgYWRkID0gQXVkaW8uYmlub3BzLkFkZCggLi4uc3VtICkgXG4gICAgICAgICAgLy8gYmVsb3cgd29ya3MgZm9yIG9zY2lsbGF0b3JzLCBhYm92ZSB3b3JrcyBmb3IgaW5zdHJ1bWVudHMuLi5cbiAgICAgICAgICAvL2NvbnN0IGFkZCA9IEdpYmJlci5HaWJiZXJpc2guYmlub3BzLkFkZCggLi4uc3VtICkgXG4gICAgICAgICAgYWRkLl9fdXNlTWFwcGluZyA9IGZhbHNlXG4gICAgICAgICAgZGVzdC5fX293bmVyWyBkZXN0Lm5hbWUgXSA9IGFkZFxuXG4gICAgICAgICAgb2JqLl9fd3JhcHBlZF9fLmNvbm5lY3RlZC5wdXNoKCBbIGRlc3QuX19vd25lclsgZGVzdC5uYW1lIF0sIG9iaiBdIClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gaWYgbm8gZnggY2hhaW4sIGNvbm5lY3QgZGlyZWN0bHkgdG8gb3V0cHV0XG4gICAgICAgICAgaWYoIG9iai5meC5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICBfX3dyYXBwZWRPYmplY3QuY29ubmVjdCggZGVzdCwgbGV2ZWwgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb25uZWN0IGxhc3QgZWZmZWN0IGluIGNoYWluIHRvIG91dHB1dFxuICAgICAgICAgICAgb2JqLmZ4WyBvYmouZngubGVuZ3RoIC0gMSBdLl9fd3JhcHBlZF9fLmNvbm5lY3QoIGRlc3QsIGxldmVsIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLmxvZyggJyVjWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbnVtYmVyOyBwZXJoYXBzIHlvdSBtZWFudCB0aGlzIHRvIGJlIHRoZSBsZXZlbCBmb3IgeW91ciBjb25uZWN0aW9uPycsICdjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kOiM5MDAnIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iaiBcbiAgICB9IFxuXG4gICAgb2JqLmRpc2Nvbm5lY3QgPSBkZXN0ID0+IHsgXG4gICAgICAvLyBpZiB0aGVyZSdzIGFuIGVmZmVjdCBjaGFpbiwgd2UgZGlzY29ubmVjdCB0aGF0IGluIGFkZGl0aW9uXG4gICAgICAvLyB0byBkaXNjb25uZWN0aW5nIHRoZSB1Z2VuIGl0c2VsZi5cbiAgICAgIGlmKCBkZXN0ID09PSB1bmRlZmluZWQgJiYgb2JqLmZ4Lmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIG9iai5meFsgb2JqLmZ4Lmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KClcbiAgICAgIH1cblxuICAgICAgX193cmFwcGVkT2JqZWN0LmRpc2Nvbm5lY3QoKTsgXG4gICAgICBcbiAgICAgIHJldHVybiBvYmogXG4gICAgfSBcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCAnXycsIHsgZ2V0KCkgeyBvYmouZGlzY29ubmVjdCgpOyByZXR1cm4gb2JqIH0gfSlcblxuICAgIC8vIHByZXNldEluaXQgaXMgYSBmdW5jdGlvbiBpbiBwcmVzZXRzIHRoYXQgdHJpZ2dlcnMgYWN0aW9ucyBhZnRlciB0aGUgdWdlblxuICAgIC8vIGhhcyBiZWVuIGluc3RhbnRpYXRlZC4uLiBpdCBpcyBwcmltYXJpbHkgdXNlZCB0byBhZGQgZWZmZWN0cyBhbmQgbW9kdWxhdGlvbnNcbiAgICAvLyB0byBhIHByZXNldC5cbiAgICBpZiggcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuX19wcmVzZXRJbml0X18gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHByb3BlcnRpZXMuX19wcmVzZXRJbml0X18uY2FsbCggb2JqLCBBdWRpbywgYXJnc1sxXSApXG4gICAgfVxuXG4gICAgLy8gb25seSBjb25uZWN0IGlmIHNob3VsZE5vdENvbm5lZWN0IGRvZXMgbm90IGVxdWFsIHRydWUgKGZvciBMRk9zIGFuZCBvdGhlciBtb2R1bGF0aW9uIHNvdXJjZXMpXG4gICAgaWYoIG9iai5fX3dyYXBwZWRfXy50eXBlID09PSAnaW5zdHJ1bWVudCcgfHwgb2JqLl9fd3JhcHBlZF9fLnR5cGUgPT09ICdvc2NpbGxhdG9yJyB8fCBkZXNjcmlwdGlvbi5uYW1lLmluZGV4T2YoJ1BvbHknKSA+IC0xICkge1xuICAgICAgaWYoIHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAnb2JqZWN0JyB8fCBwcm9wZXJ0aWVzLnNob3VsZE5vdENvbm5lY3QgIT09IHRydWUgKSB7XG4gICAgICAgIFxuICAgICAgICBpZiggQXVkaW8uYXV0b0Nvbm5lY3QgPT09IHRydWUgKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHVnZW4gaGFzbid0IGFscmVhZHkgYmVlbiBjb25uZWN0ZWQgdGhyb3VnaCB0aGUgZnggY2hhaW4sXG4gICAgICAgICAgLy8gcG9zc2libHkgdGhyb3VnaCBpbml0aWFsaXphdGlvbiBvZiBhIHByZXNldFxuICAgICAgICAgIGlmKCBvYmouZngubGVuZ3RoID09PSAwICkgb2JqLmNvbm5lY3QoIEF1ZGlvLk1hc3RlciApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1lbHNlIGlmKCBvYmouX193cmFwcGVkX18udHlwZSA9PT0gJ2VmZmVjdCcgKSB7XG4gICAgICBvYmouYnVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGIgPSBBdWRpby5idXNzZXMuQnVzMigpXG4gICAgICAgIGIuZnguYWRkKCBvYmogKVxuXG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUHJveHkoIGIsIHtcbiAgICAgICAgICBzZXQoIHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnc2V0OicsIHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciApXG4gICAgICAgICAgICBpZiggYlsgcHJvcGVydHkgXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5ICE9PSAnaW5wdXQnICkge1xuICAgICAgICAgICAgICBvYmpbIHByb3BlcnR5IF0gPSB2YWx1ZVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGJbIHByb3BlcnR5IF0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0KCB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgKSB7XG4gICAgICAgICAgICBpZiggYlsgcHJvcGVydHkgXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5ICE9PSAnaW5wdXQnICkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqWyBwcm9wZXJ0eSBdXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgcmV0dXJuIGJbIHByb3BlcnR5IF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcC5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5ncm91cCggJ0luc3BlY3RpbmcgJyArIGRlc2NyaXB0aW9uLm5hbWUgKyAnICcgKyAnQnVzJyApXG5cbiAgICAgICAgICBjb25zdCBvYmpLZXlzID0gT2JqZWN0LmtleXMoIG9iai5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfXyApXG4gICAgICAgICAgY29uc3QgX19vYmogPSB7fVxuICAgICAgICAgIG9iaktleXMuZm9yRWFjaCgga2V5ID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdrZXk6Jywga2V5LCBvYmouX193cmFwcGVkX18gKVxuICAgICAgICAgICAgaWYoIGtleVswXSAhPT0gJ18nICYmIGtleSAhPT0gJ2J5cGFzcycgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgX19vYmpbIGtleSBdID0gb2JqWyBrZXkgXS52YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvYmpbIGtleSBdLnZhbHVlXG4gICAgICAgICAgICAgICAgOiBvYmouX193cmFwcGVkX18uX19wcm9wZXJ0aWVzX19bIGtleSBdLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zb2xlLmdyb3VwKCBkZXNjcmlwdGlvbi5uYW1lLnRvTG93ZXJDYXNlKCkgKVxuICAgICAgICAgIGNvbnNvbGUudGFibGUoIF9fb2JqIClcbiAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcblxuICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoJ2J1cycpXG4gICAgICAgICAgY29uc29sZS50YWJsZSggYi5fX3dyYXBwZWRfXy5fX3Byb3BlcnRpZXNfXyApXG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG5cbiAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwXG4gICAgICB9XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coIGAlYyR7ZGVzY3JpcHRpb24ubmFtZX0gY3JlYXRlZC5gLCAnY29sb3I6d2hpdGU7YmFja2dyb3VuZDojMDA5JyApXG4gICAgQXVkaW8ucHVibGlzaCggJ25ldyB1Z2VuJywgZGVzY3JpcHRpb24ubmFtZSArICcgY3JlYXRlZCcgIClcblxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIC8vaWYoIHNob3VsZFVzZVBvb2wgKSB7XG4gIC8vICBmb3IoIGxldCBpPTA7IGkgPCBwb29sU2l6ZTsgaSsrICkge1xuICAvLyAgICBwb29sWyBpIF0gPSB7XG4gIC8vICAgICAgaW5Vc2U6ZmFsc2UsXG4gIC8vICAgICAgdWdlbjogY29uc3RydWN0b3IoKVxuICAvLyAgICB9XG4gIC8vICB9IFxuXG4gIC8vICBwb29sQ291bnQgPSAwXG4gIC8vfVxuICBcbiAgLy9VZ2VuLmNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHlcblxuICByZXR1cm4gY29uc3RydWN0b3Jcbn1cblxuVWdlbi5PVVRQVVRfRlVOQ1RJT04gPSAwXG5VZ2VuLk9VVFBVVF9TQ0FMQVIgPSAxXG5VZ2VuLk9VVFBVVCA9IDFcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFVnZW5cbiIsImNvbnN0IFV0aWxpdHkgPSB7XG4gIHJuZGYoIG1pbj0wLCBtYXg9MSwgbnVtYmVyLCBjYW5SZXBlYXQ9dHJ1ZSApIHtcbiAgICBsZXQgb3V0ID0gMFxuICBcdGlmKCBudW1iZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdGxldCBkaWZmID0gbWF4IC0gbWluLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJhbmRvbSgpLFxuICBcdFx0ICAgIHJyID0gZGlmZiAqIHJcblxuICBcdFx0b3V0ID0gIG1pbiArIHJyO1xuICBcdH1lbHNle1xuICAgICAgbGV0IG91dHB1dCA9IFtdLFxuICBcdFx0ICAgIHRtcCA9IFtdXG5cbiAgXHRcdGZvciggbGV0IGkgPSAwOyBpIDwgbnVtYmVyOyBpKysgKSB7XG4gIFx0XHRcdGxldCBudW1cbiAgICAgICAgaWYoIGNhblJlcGVhdCApIHtcbiAgICAgICAgICBudW0gPSBVdGlsaXR5LnJuZGYobWluLCBtYXgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG51bSA9IFV0aWxpdHkucm5kZiggbWluLCBtYXggKVxuICAgICAgICAgIHdoaWxlKCB0bXAuaW5kZXhPZiggbnVtICkgPiAtMSkge1xuICAgICAgICAgICAgbnVtID0gVXRpbGl0eS5ybmRmKCBtaW4sIG1heCApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRtcC5wdXNoKCBudW0gKVxuICAgICAgICB9XG4gIFx0XHRcdG91dHB1dC5wdXNoKCBudW0gKVxuICBcdFx0fVxuXG4gIFx0XHRvdXQgPSBvdXRwdXRcbiAgXHR9XG5cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cbiAgUm5kZiggX21pbiA9IDAsIF9tYXggPSAxLCBxdWFudGl0eSwgY2FuUmVwZWF0PXRydWUgKSB7XG4gICAgLy8gaGF2ZSB0byBjb2RlIGdlbiBmdW5jdGlvbiB0byBoYXJkIGNvZGUgbWluIC8gbWF4IHZhbHVlcyBpbnNpZGUsIGFzIGNsb3N1cmVzXG4gICAgLy8gb3IgYm91bmQgdmFsdWVzIHdvbid0IGJlIHBhc3NlZCB0aHJvdWdoIHRoZSB3b3JrbGV0IHBvcnQuWFhYIHBlcmhhcHMgdGhlcmUgc2hvdWxkXG4gICAgLy8gYmUgYSB3YXkgdG8gdHJhbnNmZXIgYSBmdW5jdGlvbiBhbmQgaXRzIHVwdmFsdWVzIHRocm91Z2ggdGhlIHdvcmtsZXQ/IE9UT0gsXG4gICAgLy8gY29kZWdlbiB3b3JrcyBmaW5lLlxuXG4gICAgY29uc3QgZm5jU3RyaW5nID0gYGNvbnN0IG1pbiA9ICR7X21pbn1cbiAgICBjb25zdCBtYXggPSAke19tYXh9IFxuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluXG4gICAgY29uc3QgY2FuUmVwZWF0ID0gJHtxdWFudGl0eX0gPiByYW5nZSA/IHRydWUgOiAkeyBjYW5SZXBlYXQgfVxuXG4gICAgbGV0IG91dFxuXG4gICAgaWYoICR7cXVhbnRpdHl9ID4gMSApIHsgXG4gICAgICBvdXQgPSBbXVxuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCAke3F1YW50aXR5fTsgaSsrICkge1xuICAgICAgICBsZXQgbnVtID0gbWluICsgTWF0aC5yYW5kb20oKSAqIHJhbmdlXG5cbiAgICAgICAgaWYoIGNhblJlcGVhdCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgd2hpbGUoIG91dC5pbmRleE9mKCBudW0gKSA+IC0xICkge1xuICAgICAgICAgICAgbnVtID0gbWluICsgTWF0aC5yYW5kb20oKSAqIHJhbmdlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dFsgaSBdID0gbnVtXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBvdXQgPSBtaW4gKyBNYXRoLnJhbmRvbSgpICogcmFuZ2UgXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtgXG4gICAgXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbiggZm5jU3RyaW5nIClcbiAgfSxcblxuICBybmRpKCBtaW4gPSAwLCBtYXggPSAxLCBudW1iZXIsIGNhblJlcGVhdCA9IHRydWUgKSB7XG4gICAgbGV0IHJhbmdlID0gbWF4IC0gbWluLFxuICAgICAgICBvdXRcbiAgICBcbiAgICBpZiggcmFuZ2UgPCBudW1iZXIgKSBjYW5SZXBlYXQgPSB0cnVlXG5cbiAgICBpZiggdHlwZW9mIG51bWJlciA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICByYW5nZSA9IG1heCAtIG1pblxuICAgICAgb3V0ID0gTWF0aC5yb3VuZCggbWluICsgTWF0aC5yYW5kb20oKSAqIHJhbmdlIClcbiAgICB9ZWxzZXtcbiAgXHRcdGxldCBvdXRwdXQgPSBbXSxcbiAgXHRcdCAgICB0bXAgPSBbXVxuXG4gIFx0XHRmb3IoIGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrICkge1xuICBcdFx0XHRsZXQgbnVtXG4gIFx0XHRcdGlmKCBjYW5SZXBlYXQgKSB7XG4gIFx0XHRcdFx0bnVtID0gVXRpbGl0eS5ybmRpKCBtaW4sIG1heCApXG4gIFx0XHRcdH1lbHNle1xuICBcdFx0XHRcdG51bSA9IFV0aWxpdHkucm5kaSggbWluLCBtYXggKVxuICBcdFx0XHRcdHdoaWxlKCB0bXAuaW5kZXhPZiggbnVtICkgPiAtMSApIHtcbiAgXHRcdFx0XHRcdG51bSA9IFV0aWxpdHkucm5kaSggbWluLCBtYXggKVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR0bXAucHVzaCggbnVtIClcbiAgXHRcdFx0fVxuICBcdFx0XHRvdXRwdXQucHVzaCggbnVtIClcbiAgXHRcdH1cbiAgXHRcdG91dCA9IG91dHB1dFxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cbiAgUm5kaSggX21pbiA9IDAsIF9tYXggPSAxLCBxdWFudGl0eT0xLCBjYW5SZXBlYXQgPSBmYWxzZSApIHtcbiAgICAvLyBoYXZlIHRvIGNvZGUgZ2VuIGZ1bmN0aW9uIHRvIGhhcmQgY29kZSBtaW4gLyBtYXggdmFsdWVzIGluc2lkZSwgYXMgY2xvc3VyZXNcbiAgICAvLyBvciBib3VuZCB2YWx1ZXMgd29uJ3QgYmUgcGFzc2VkIHRocm91Z2ggdGhlIHdvcmtsZXQgcG9ydC5YWFggcGVyaGFwcyB0aGVyZSBzaG91bGRcbiAgICAvLyBiZSBhIHdheSB0byB0cmFuc2ZlciBhIGZ1bmN0aW9uIGFuZCBpdHMgdXB2YWx1ZXMgdGhyb3VnaCB0aGUgd29ya2xldD8gT1RPSCxcbiAgICAvLyBjb2RlZ2VuIHdvcmtzIGZpbmUuXG5cbiAgICBjb25zdCBmbmNTdHJpbmcgPSBgY29uc3QgbWluID0gJHtfbWlufVxuICAgIGNvbnN0IG1heCA9ICR7X21heH0gXG4gICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW5cbiAgICBjb25zdCBjYW5SZXBlYXQgPSAke3F1YW50aXR5fSA+IHJhbmdlID8gdHJ1ZSA6ICR7IGNhblJlcGVhdCB9XG5cbiAgICBsZXQgb3V0XG5cbiAgICBpZiggJHtxdWFudGl0eX0gPiAxICkgeyBcbiAgICAgIG91dCA9IFtdXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8ICR7cXVhbnRpdHl9OyBpKysgKSB7XG4gICAgICAgIGxldCBudW0gPSBtaW4gKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogcmFuZ2UgKTtcblxuICAgICAgICBpZiggY2FuUmVwZWF0ID09PSBmYWxzZSApIHtcbiAgICAgICAgICB3aGlsZSggb3V0LmluZGV4T2YoIG51bSApID4gLTEgKSB7XG4gICAgICAgICAgICBudW0gPSBtaW4gKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogcmFuZ2UgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0WyBpIF0gPSBudW1cbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIG91dCA9IG1pbiArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiByYW5nZSApOyBcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O2BcbiAgICBcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCBmbmNTdHJpbmcgKVxuICB9LFxuXG4gIHRpbWUoIHYgKSB7IHJldHVybiBHaWJiZXIuQXVkaW8uQ2xvY2sudGltZSggdiApIH0sXG4gIGJ0b2YoIGJlYXRzICkgeyByZXR1cm4gMSAvIChiZWF0cyAqICggNjAgLyBHaWJiZXIuQXVkaW8uQ2xvY2suYnBtICkpIH0sXG5cbiAgcmFuZG9tKCkge1xuICAgIHRoaXMucmFuZG9tRmxhZyA9IHRydWVcbiAgICB0aGlzLnJhbmRvbUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwIClcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgZWxlbWVudEFycmF5OiBmdW5jdGlvbiggbGlzdCApIHtcbiAgICBsZXQgb3V0ID0gW11cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyApIHtcbiAgICAgIG91dC5wdXNoKCBsaXN0Lml0ZW0oIGkgKSApXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFxuICB9LFxuICBcbiAgX19jbGFzc0xpc3RNZXRob2RzOiBbICd0b2dnbGUnLCAnYWRkJywgJ3JlbW92ZScgXSxcblxuICBjcmVhdGUoIHF1ZXJ5ICkge1xuICAgIGxldCBlbGVtZW50TGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIHF1ZXJ5ICksXG4gICAgICAgIGFyciA9IFV0aWxpdHkuZWxlbWVudEFycmF5KCBlbGVtZW50TGlzdCApXG4gICAgXG4gICAgZm9yKCBsZXQgbWV0aG9kIG9mIFV0aWxpdHkuX19jbGFzc0xpc3RNZXRob2RzICkgeyBcbiAgICAgIGFyclsgbWV0aG9kIF0gPSBzdHlsZSA9PiB7XG4gICAgICAgIGZvciggbGV0IGVsZW1lbnQgb2YgYXJyICkgeyBcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdFsgbWV0aG9kIF0oIHN0eWxlIClcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyXG4gIH0sXG5cbiAgY2hvcmQoIHB0cm4sIG9mZnNldHMgKSB7XG4gICAgLy8gZ290dGEgY29kZWdlbiBmdW5jdGlvbiBmb3Igd29ya2xldCBwcm9jZXNzb3IuLi4gc2ltaWxhciB0byBSbmRpIGV0Yy5cbiAgICBsZXQgZm5jc3RyID0gYGFyZ3Mub3ZlcnJpZGUgPSBhcmdzWzBdXG4gICAgY29uc3QgdmFsdWVzID0gW11cXG5gXG5cbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBmbmNzdHIgKz0gYHZhbHVlc1ske2l9XSA9IGFyZ3NbMF0gKyAke29mZnNldHNbaV19XFxuYFxuICAgIH1cblxuICAgIGZuY3N0ciArPSBgYXJnc1swXSA9IHZhbHVlc1xcbiAgcmV0dXJuIGFyZ3NgXG5cbiAgICBjb25zdCBmbmMgPSBuZXcgRnVuY3Rpb24oICdhcmdzJywgZm5jc3RyIClcblxuICAgIHB0cm4uYWRkRmlsdGVyKCBmbmMgKVxuXG4gICAgcmV0dXJuIHB0cm5cbiAgfSxcblxuICBleHBvcnQoIG9iaiApIHtcbiAgICBvYmoucm5kaSA9IHRoaXMucm5kaVxuICAgIG9iai5ybmRmID0gdGhpcy5ybmRmXG4gICAgb2JqLlJuZGkgPSB0aGlzLlJuZGlcbiAgICBvYmouUm5kZiA9IHRoaXMuUm5kZlxuICAgIG9iai5idG9mID0gdGhpcy5idG9mXG4gICAgb2JqLmNob3JkID0gdGhpcy5jaG9yZFxuICAgIG9iai50aW1lID0gdGhpcy50aW1lXG5cbiAgICBBcnJheS5wcm90b3R5cGUucm5kID0gdGhpcy5yYW5kb21cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxpdHlcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcbiAgIGNvbnN0IGdlbiA9IEdpYmJlci5HZW4ubWFrZSAgXG5cbiAgIC8vIHdpbGwgdXNlIHRoaXMgaW4gYSBmZXcgcGxhY2VzLi4uXG4gICBjb25zdCBiZWF0cyA9IGIgPT4ge1xuICAgICByZXR1cm4gcGhhc29yKCBHaWJiZXIuVXRpbGl0aWVzLmJ0b2YoIGIgKSwgMCwgeyBtaW46MCB9IClcbiAgIH1cblxuICAgLy8gbmVlZHMgdG8gc3VwcG9ydCBjaGFuZ2luZyB2YWx1ZXMgaW4gbW9yZSB0aGFuIG9uZSBwbGFjZVxuICAgLy8gaW4gdGhlIGdyYXBoLCBoZW5jZSB0aGUgYXJyYXkgb2YgX19wYXJhbXMuXG4gICBjb25zdCBhZGRQcm9wID0gKCBvYmosIHByb3AsIF9fcGFyYW1zLCBfX3ZhbHVlICkgPT4ge1xuICAgICBsZXQgdmFsdWUgPSBfX3ZhbHVlXG4gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCB7XG4gICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgZ2V0KCkgeyByZXR1cm4gdmFsdWUgfSxcbiAgICAgICBzZXQodikge1xuICAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgICBmb3IoIGxldCBfX3BhcmFtIG9mIF9fcGFyYW1zICkge1xuICAgICAgICAgICBfX3BhcmFtLnZhbHVlID0gdmFsdWVcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0pXG4gICB9XG5cbiAgIGNvbnN0IFdhdmVQYXR0ZXJucyA9IHtcbiAgICAgQmVhdHMoIG51bUJlYXRzICkge1xuICAgICAgIGNvbnN0IHVnZW4gPSBnZW4oIGJlYXRzKCBudW1CZWF0cyApIClcbiAgICAgICB1Z2VuLmlzR2VuID0gdWdlbi5fX3dyYXBwZWRfXy5pc0dlbiA9IHRydWVcbiAgICAgICBcbiAgICAgICByZXR1cm4gdWdlbiBcbiAgICAgfSxcblxuICAgICBTaW5lUiggcGVyaW9kLCBnYWluLCBiaWFzPTAgKSB7XG4gICAgICAgY29uc3QgdWdlbiA9ICBnZW4oIGZsb29yKCBhZGQoIGJpYXMsIG11bCggY3ljbGUoIEdpYmJlci5VdGlsaXRpZXMuYnRvZiggcGVyaW9kICkgKSwgZ2FpbiApICkgKSwgWydiaWFzJywgJ3BlcmlvZCcsICdnYWluJ10gKVxuICAgICAgIHVnZW4uaXNHZW4gPSB1Z2VuLl9fd3JhcHBlZF9fLmlzR2VuID0gdHJ1ZVxuXG4gICAgICAgcmV0dXJuIHVnZW5cbiAgICAgfSxcblxuICAgICBMaW5lUiggcGVyaW9kLCBmcm9tPTAsIHRvPTEgKSB7XG4gICAgICAgY29uc3QgYiA9IGJlYXRzKCBwZXJpb2QgKVxuXG4gICAgICAgY29uc3QgZGlmZiA9IHN1YiggdG8sIGZyb20gKVxuICAgICAgIGNvbnN0IG11bHQgPSBtdWwoIGIsIGRpZmYgKVxuICAgICAgIGNvbnN0IGFkZGVyID0gYWRkKCBmcm9tLCBtdWx0IClcbiAgICAgICBjb25zdCB1Z2VuID0gZ2VuKCByb3VuZCggYWRkZXIgKSApXG4gICAgICAgXG4gICAgICAgYWRkUHJvcCggdWdlbiwgJ2Zyb20nLCBbIHVnZW4ucDAsIHVnZW4ucDQgXSwgZnJvbSApXG4gICAgICAgYWRkUHJvcCggdWdlbiwgJ3RvJywgWyB1Z2VuLnAzIF0sIHRvIClcbiAgICAgICBhZGRQcm9wKCB1Z2VuLCAncGVyaW9kJywgWyB1Z2VuLnAxIF0sIHBlcmlvZCApXG5cbiAgICAgICBjb25zdCBvbGRTZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB1Z2VuLCAncGVyaW9kJyApLnNldFxuICAgICAgIGNvbnN0IG9sZEdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHVnZW4sICdwZXJpb2QnICkuZ2V0XG5cbiAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sICdwZXJpb2QnLCB7XG4gICAgICAgICBnZXQoKSB7IHJldHVybiBvbGRHZXR0ZXIoKSB9LFxuICAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgb2xkU2V0dGVyKCBidG9mKHYpIClcbiAgICAgICAgIH1cblxuICAgICAgIH0pXG4gICAgICAgXG4gICAgICAgdWdlbi5pc0dlbiA9IHVnZW4uX193cmFwcGVkX18uaXNHZW4gPSB0cnVlXG5cbiAgICAgICByZXR1cm4gdWdlblxuICAgICB9LFxuXG4gICAgIExpbmUoIHBlcmlvZCwgZnJvbT0wLCB0bz0xICkge1xuICAgICAgIGNvbnN0IGIgPSBiZWF0cyggcGVyaW9kIClcblxuICAgICAgIGNvbnN0IGRpZmYgPSBzdWIoIHRvLCBmcm9tIClcbiAgICAgICBjb25zdCBtdWx0ID0gbXVsKCBiLCBkaWZmIClcbiAgICAgICBjb25zdCBhZGRlciA9IGFkZCggZnJvbSwgbXVsdCApXG4gICAgICAgY29uc3QgdWdlbiA9IGdlbiggYWRkZXIgKVxuICAgICAgIFxuICAgICAgIGFkZFByb3AoIHVnZW4sICdmcm9tJywgWyB1Z2VuLnAwLCB1Z2VuLnA0IF0sIGZyb20gKVxuICAgICAgIGFkZFByb3AoIHVnZW4sICd0bycsIFsgdWdlbi5wMyBdLCB0byApXG4gICAgICAgYWRkUHJvcCggdWdlbiwgJ3BlcmlvZCcsIFsgdWdlbi5wMSBdLCBwZXJpb2QgKVxuXG4gICAgICAgY29uc3Qgb2xkU2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdWdlbiwgJ3BlcmlvZCcgKS5zZXRcbiAgICAgICBjb25zdCBvbGRHZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB1Z2VuLCAncGVyaW9kJyApLmdldFxuXG4gICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB1Z2VuLCAncGVyaW9kJywge1xuICAgICAgICAgZ2V0KCkgeyByZXR1cm4gb2xkR2V0dGVyKCkgfSxcbiAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICBvbGRTZXR0ZXIoIGJ0b2YodikgKVxuICAgICAgICAgfVxuXG4gICAgICAgfSlcblxuICAgICAgIHVnZW4uaXNHZW4gPSB1Z2VuLl9fd3JhcHBlZF9fLmlzR2VuID0gdHJ1ZVxuXG4gICAgICAgcmV0dXJuIHVnZW5cbiAgICAgfVxuICAgfVxuXG4gICAvLyBzdG9yZXMgbmFtZXMgc28gdGhhdCBhbm5vdGF0aW9ucyB3aWxsIGNvcnJlY3RseSBpbnRlcnByZXQgdGhpcyBhcyBhIGdlbiBvYmplY3RcbiAgIGZvciggbGV0IGtleSBpbiBXYXZlUGF0dGVybnMgKSB7XG4gICAgIEdpYmJlci5HZW4ubmFtZXMucHVzaCgga2V5IClcbiAgIH1cblxuICByZXR1cm4gV2F2ZVBhdHRlcm5zXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG5cbiAgY29uc3QgV2F2ZVBhdHRlcm4gPSBmdW5jdGlvbiggdWdlbiApIHtcbiAgICBcbiAgICBjb25zdCBmbmMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmbmMudWdlbi5fX3dyYXBwZWRfXy5jYWxsYmFjay5vdXRbMF0gXG4gICAgfVxuXG4gICAgZm5jLnVnZW4gPSB1Z2VuXG5cbiAgICByZXR1cm4gR2liYmVyLlBhdHRlcm4oIGZuYyApXG4gIH1cblxuICByZXR1cm4gV2F2ZVBhdHRlcm5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcblxubGV0IFBhdHRlcm4gPSBHaWJiZXIuUGF0dGVyblxuXG5sZXQgZmxhdHRlbiA9IGZ1bmN0aW9uKCl7XG4gICBsZXQgZmxhdCA9IFtdXG4gICBmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICBsZXQgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggdGhpc1sgaSBdKS5zcGxpdCgnICcpLnBvcCgpLnNwbGl0KCAnXScgKS5zaGlmdCgpLnRvTG93ZXJDYXNlKClcblxuICAgICBpZiAodHlwZSkgeyBcbiAgICAgICBmbGF0ID0gZmxhdC5jb25jYXQoIC9eKGFycmF5fGNvbGxlY3Rpb258YXJndW1lbnRzfG9iamVjdCkkLy50ZXN0KCB0eXBlICkgPyBmbGF0dGVuLmNhbGwoIHRoaXNbaV0gKSA6IHRoaXNbaV0pIFxuICAgICB9XG4gICB9XG4gICByZXR1cm4gZmxhdFxufVxuXG5sZXQgY3JlYXRlU3RhcnRpbmdBcnJheSA9IGZ1bmN0aW9uKCBsZW5ndGgsIG9uZXMgKSB7XG4gIGxldCBvdXQgPSBbXVxuICBmb3IoIGxldCBpID0gMDsgaSA8IG9uZXM7IGkrKyApIHtcbiAgICBvdXQucHVzaCggWzFdIClcbiAgfVxuICBmb3IoIGxldCBqID0gb25lczsgaiA8IGxlbmd0aDsgaisrICkge1xuICAgIG91dC5wdXNoKCAwIClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmxldCBwcmludEFycmF5ID0gZnVuY3Rpb24oIGFycmF5ICkge1xuICBsZXQgc3RyID0gJydcbiAgZm9yKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKyApIHtcbiAgICBsZXQgb3V0ZXJFbGVtZW50ID0gYXJyYXlbIGkgXVxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBvdXRlckVsZW1lbnQgKSApIHtcbiAgICAgIHN0ciArPSAnWydcbiAgICAgIGZvciggbGV0IGogPSAwOyBqIDwgb3V0ZXJFbGVtZW50Lmxlbmd0aDsgaisrICkge1xuICAgICAgICBzdHIgKz0gb3V0ZXJFbGVtZW50WyBqIF1cbiAgICAgIH1cbiAgICAgIHN0ciArPSAnXSAnXG4gICAgfWVsc2V7XG4gICAgICBzdHIgKz0gb3V0ZXJFbGVtZW50ICsgJydcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyXG59XG5cbmxldCBhcnJheXNFcXVhbCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuICBpZiAoIGEgPT09IGIgKSByZXR1cm4gdHJ1ZVxuICBpZiAoIGEgPT0gbnVsbCB8fCBiID09IG51bGwgKSByZXR1cm4gZmFsc2VcbiAgaWYgKCBhLmxlbmd0aCAhPSBiLmxlbmd0aCApIHJldHVybiBmYWxzZVxuXG4gIGZvciAoIGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kgKSB7XG4gICAgaWYgKCBhWyBpIF0gIT09IGJbIGkgXSApIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxubGV0IGdldExhcmdlc3RBcnJheUNvdW50ID0gZnVuY3Rpb24oIGlucHV0ICkge1xuICBsZXQgbGVuZ3RoID0gMCwgY291bnQgPSAwXG5cbiAgZm9yKCBsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKyApIHtcbiAgICBpZiggQXJyYXkuaXNBcnJheSggaW5wdXRbIGkgXSApICkgeyBcbiAgICAgIGlmKCBpbnB1dFsgaSBdLmxlbmd0aCA+IGxlbmd0aCApIHtcbiAgICAgICAgbGVuZ3RoID0gaW5wdXRbIGkgXS5sZW5ndGhcbiAgICAgICAgY291bnQgPSAxXG4gICAgICB9ZWxzZSBpZiggaW5wdXRbIGkgXS5sZW5ndGggPT09IGxlbmd0aCApIHtcbiAgICAgICAgY291bnQrK1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudFxufVxuXG5sZXQgRXVjbGlkID0gZnVuY3Rpb24oIG9uZXMsIGxlbmd0aCwgdGltZSwgcm90YXRpb24gKSB7XG4gIGxldCBjb3VudCA9IDAsXG4gICAgICBvdXQgPSBjcmVhdGVTdGFydGluZ0FycmF5KCBsZW5ndGgsIG9uZXMgKSxcbiAgICAgIG9uZXNBbmRaZXJvc1xuXG4gXHRmdW5jdGlvbiBJbm5lciggbixrICkge1xuICAgIGxldCBvcGVyYXRpb25Db3VudCA9IGNvdW50KysgPT09IDAgPyBrIDogZ2V0TGFyZ2VzdEFycmF5Q291bnQoIG91dCApLFxuICAgICAgICBtb3ZlQ2FuZGlkYXRlQ291bnQgPSBvdXQubGVuZ3RoIC0gb3BlcmF0aW9uQ291bnQsXG4gICAgICAgIG51bWJlck9mTW92ZXMgPSBvcGVyYXRpb25Db3VudCA+PSBtb3ZlQ2FuZGlkYXRlQ291bnQgPyBtb3ZlQ2FuZGlkYXRlQ291bnQgOiBvcGVyYXRpb25Db3VudFxuXG4gICAgaWYoIG51bWJlck9mTW92ZXMgPiAxIHx8IGNvdW50ID09PSAxICkge1xuICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBudW1iZXJPZk1vdmVzOyBpKysgKSB7XG4gICAgICAgIGxldCB3aWxsQmVNb3ZlZCA9IG91dC5wb3AoKSwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIHdpbGxCZU1vdmVkIClcbiAgICAgICAgb3V0WyBpIF0ucHVzaCggd2lsbEJlTW92ZWQgKVxuICAgICAgICBpZiggaXNBcnJheSApIHsgXG4gICAgICAgICAgZmxhdHRlbi5jYWxsKCBvdXRbIGkgXSApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggbiAlIGsgIT09IDAgKSB7XG4gICAgICByZXR1cm4gSW5uZXIoIGssIG4gJSBrIClcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gZmxhdHRlbi5jYWxsKCBvdXQgKVxuICAgIH1cbiAgfVxuICBcbiAgb25lc0FuZFplcm9zID0gSW5uZXIoIGxlbmd0aCwgb25lcyApXG5cbiAgbGV0IHBhdHRlcm4gPSBHaWJiZXIuUGF0dGVybiggLi4ub25lc0FuZFplcm9zIClcblxuICBpZiggaXNOYU4oIHRpbWUgKSB8fCB0aW1lID09PSBudWxsICkgdGltZSA9IDEgLyBvbmVzQW5kWmVyb3MubGVuZ3RoXG5cbiAgcGF0dGVybi5vbnJlbmRlciA9IGZ1bmN0aW9uKCByZW5kZXJlZCApIHtcbiAgICByZW5kZXJlZC50eXBlID0gJ0V1Y2xpZCdcblxuICAgIHJlbmRlcmVkLnRpbWUgPSB0aW1lXG5cbiAgICByZW5kZXJlZC5vdXRwdXQgPSB7IHRpbWUsIHNob3VsZEV4ZWN1dGU6IDAgfVxuXG4gICAgcmVuZGVyZWQuYWRkRmlsdGVyKCAoIGFyZ3MsIHB0cm4gKSA9PiB7XG4gICAgICBsZXQgdmFsID0gYXJnc1sgMCBdXG5cbiAgICAgIHB0cm4ub3V0cHV0LnRpbWUgPSBHaWJiZXJpc2guQ2xvY2sudGltZSggcHRybi50aW1lIClcbiAgICAgIHB0cm4ub3V0cHV0LnNob3VsZEV4ZWN1dGUgPSB2YWwgXG5cbiAgICAgIGFyZ3NbIDAgXSA9IHB0cm4ub3V0cHV0IFxuXG4gICAgICByZXR1cm4gYXJnc1xuICAgIH0pXG4gIH1cblxuICBwYXR0ZXJuLnJlc2VlZCA9ICggLi4uYXJncyApPT4ge1xuICAgIGxldCBuLCBrXG4gICAgXG4gICAgaWYoIEFycmF5LmlzQXJyYXkoIGFyZ3NbMF0gKSApIHtcbiAgICAgIGsgPSBhcmdzWzBdWzBdXG4gICAgICBuID0gYXJnc1swXVsxXVxuICAgIH1lbHNle1xuICAgICAgayA9IGFyZ3NbMF1cbiAgICAgIG4gPSBhcmdzWzFdXG4gICAgfVxuXG4gICAgaWYoIG4gPT09IHVuZGVmaW5lZCApIG4gPSAxNlxuICAgIFxuICAgIG91dCA9IGNyZWF0ZVN0YXJ0aW5nQXJyYXkoIG4sayApXG4gICAgbGV0IF9vbmVzQW5kWmVyb3MgPSBJbm5lciggbixrIClcbiAgICBcbiAgICBwYXR0ZXJuLnNldCggX29uZXNBbmRaZXJvcyApXG4gICAgcGF0dGVybi50aW1lID0gMSAvIG5cblxuICAgIC8vIHRoaXMuY2hlY2tGb3JVcGRhdGVGdW5jdGlvbiggJ3Jlc2VlZCcsIHBhdHRlcm4gKVxuXG4gICAgcmV0dXJuIHBhdHRlcm5cbiAgfVxuXG4gIC8vR2liYmVyLmFkZFNlcXVlbmNpbmdUb01ldGhvZCggcGF0dGVybiwgJ3Jlc2VlZCcgKVxuXG4gIC8vIG91dCA9IGNhbGN1bGF0ZVJoeXRobXMoIG9uZXNBbmRaZXJvcywgZHVyIClcbiAgLy8gb3V0LmluaXRpYWwgPSBvbmVzQW5kWmVyb3NcbiAgaWYoIHR5cGVvZiByb3RhdGlvbiA9PT0gJ251bWJlcicgKSBwYXR0ZXJuLnJvdGF0ZSggcm90YXRpb24gKVxuICByZXR1cm4gcGF0dGVybiAvL291dFxufVxuLy8gRSg1LDgpID0gWyAuMjUsIC4xMjUsIC4yNSwgLjEyNSwgLjI1IF1cbmxldCBjYWxjdWxhdGVSaHl0aG1zID0gZnVuY3Rpb24oIHZhbHVlcywgZHVyICkge1xuICBsZXQgb3V0ID0gW11cbiAgXG4gIGlmKCB0eXBlb2YgZHVyID09PSAndW5kZWZpbmVkJyApIGR1ciA9IDEgLyB2YWx1ZXMubGVuZ3RoXG5cbiAgbGV0IGlkeCA9IDAsXG4gICAgICBjdXJyZW50RHVyID0gMFxuICBcbiAgd2hpbGUoIGlkeCA8IHZhbHVlcy5sZW5ndGggKSB7XG4gICAgaWR4KytcbiAgICBjdXJyZW50RHVyICs9IGR1clxuICAgIFxuICAgIGlmKCB2YWx1ZXNbIGlkeCBdID09IDEgfHwgaWR4ID09PSB2YWx1ZXMubGVuZ3RoICkge1xuICAgICAgb3V0LnB1c2goIGN1cnJlbnREdXIgKVxuICAgICAgY3VycmVudER1ciA9IDBcbiAgICB9IFxuICB9XG4gIFxuICByZXR1cm4gb3V0XG59XG5cbmxldCBhbnN3ZXJzID0ge1xuICAnMSw0JyA6ICcxMDAwJyxcbiAgJzIsMycgOiAnMTAxJyxcbiAgJzIsNScgOiAnMTAxMDAnLFxuICAnMyw0JyA6ICcxMDExJyxcbiAgJzMsNScgOiAnMTAxMDEnLFxuICAnMyw3JyA6ICcxMDEwMTAwJyxcbiAgJzMsOCcgOiAnMTAwMTAwMTAnLFxuICAnNCw3JyA6ICcxMDEwMTAxJyxcbiAgJzQsOScgOiAnMTAxMDEwMTAwJyxcbiAgJzQsMTEnOiAnMTAwMTAwMTAwMTAnLFxuICAnNSw2JyA6ICcxMDExMTEnLFxuICAnNSw3JyA6ICcxMDExMDExJyxcbiAgJzUsOCcgOiAnMTAxMTAxMTAnLFxuICAnNSw5JyA6ICcxMDEwMTAxMDEnLFxuICAnNSwxMSc6ICcxMDEwMTAxMDEwMCcsXG4gICc1LDEyJzogJzEwMDEwMTAwMTAxMCcsXG4gICc1LDE2JzogJzEwMDEwMDEwMDEwMDEwMDAnLFxuICAnNyw4JyA6ICcxMDExMTExMScsXG4gICcxMSwyNCc6ICcxMDAxMDEwMTAxMDEwMDEwMTAxMDEwMTAnXG59XG5cbkV1Y2xpZC50ZXN0ID0gZnVuY3Rpb24oIHRlc3RLZXkgKSB7XG4gIGxldCBmYWlsZWQgPSAwLCBwYXNzZWQgPSAwXG5cbiAgaWYoIHR5cGVvZiB0ZXN0S2V5ICE9PSAnc3RyaW5nJyApIHtcbiAgICBmb3IoIGxldCBrZXkgaW4gYW5zd2VycyApIHtcbiAgICAgIGxldCBleHBlY3RlZFJlc3VsdCA9IGFuc3dlcnNbIGtleSBdLFxuICAgICAgICAgIHJlc3VsdCA9IGZsYXR0ZW4uY2FsbCggRXVjbGlkLmFwcGx5KCBudWxsLCBrZXkuc3BsaXQoJywnKSApICkuam9pbignJylcblxuICAgICAgY29uc29sZS5sb2coIHJlc3VsdCwgZXhwZWN0ZWRSZXN1bHQgKVxuXG4gICAgICBpZiggcmVzdWx0ID09PSBleHBlY3RlZFJlc3VsdCApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJURVNUIFBBU1NFRFwiLCBrZXkgKVxuICAgICAgICBwYXNzZWQrK1xuICAgICAgfWVsc2V7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVCBGQUlMRURcIiwga2V5IClcbiAgICAgICAgZmFpbGVkKytcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlRFU1QgUkVTVUxUUyAtIFBhc3NlZDogXCIgKyBwYXNzZWQgKyBcIiwgRmFpbGVkOiBcIiArIGZhaWxlZCApXG4gIH1lbHNle1xuICAgIGxldCBleHBlY3RlZFJlc3VsdCA9IGFuc3dlcnNbdGVzdEtleV0sXG5cdFx0XHRcdHJlc3VsdCA9IGZsYXR0ZW4uY2FsbCggRXVjbGlkLmFwcGx5KCBudWxsLCB0ZXN0S2V5LnNwbGl0KCcsJykgKSApLmpvaW4oJycpXG5cbiAgICBjb25zb2xlLmxvZyggcmVzdWx0LCBleHBlY3RlZFJlc3VsdCApXG5cbiAgICBpZiggcmVzdWx0ID09IGV4cGVjdGVkUmVzdWx0ICkge1xuICAgICAgY29uc29sZS5sb2coXCJURVNUIFBBU1NFRCBGT1JcIiwgdGVzdEtleSlcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnNvbGUubG9nKFwiVEVTVCBGQUlMRUQgRk9SXCIsIHRlc3RLZXkpXG4gICAgfVxuICB9XG59XG5cbnJldHVybiBFdWNsaWRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcblxuY29uc3QgUGF0dGVybiA9IEdpYmJlci5QYXR0ZXJuXG5cbmNvbnN0IEhleCA9IGZ1bmN0aW9uKCBoZXhTdHJpbmcsIHRpbWUgPSAxLzE2LCByb3RhdGlvbiApIHtcbiAgbGV0IGNvdW50ID0gMCxcbiAgICAgIG9uZXNBbmRaZXJvcyA9ICcnXG5cbiAgaWYoIHR5cGVvZiBoZXhTdHJpbmcgPT09ICdzdHJpbmcnICkge1xuICAgIGZvciggbGV0IGNociBvZiBoZXhTdHJpbmcgKSB7XG4gICAgICBsZXQgbnVtID0gTnVtYmVyKCAnMHgnK2NociApXG5cbiAgICAgIG9uZXNBbmRaZXJvcyArPSAobnVtICYgOCkgPiAwID8gMSA6IDBcbiAgICAgIG9uZXNBbmRaZXJvcyArPSAobnVtICYgNCkgPiAwID8gMSA6IDBcbiAgICAgIG9uZXNBbmRaZXJvcyArPSAobnVtICYgMikgPiAwID8gMSA6IDBcbiAgICAgIG9uZXNBbmRaZXJvcyArPSAobnVtICYgMSkgPiAwID8gMSA6IDBcbiAgICB9XG4gIH1lbHNle1xuICAgIG9uZXNBbmRaZXJvcyA9IGhleFN0cmluZy50b1N0cmluZygyKVxuICAgIHdoaWxlKCBvbmVzQW5kWmVyb3MubGVuZ3RoIDwgMTYgKSB7XG4gICAgICBvbmVzQW5kWmVyb3MgPSAnMCcrb25lc0FuZFplcm9zXG4gICAgfVxuICB9XG5cbiAgbGV0IF9fb25lc0FuZFplcm9zID0gb25lc0FuZFplcm9zLnNwbGl0KCcnKSBcblxuICBjb25zdCBwYXR0ZXJuID0gR2liYmVyLlBhdHRlcm4oIC4uLl9fb25lc0FuZFplcm9zICkgXG4gIFxuICBwYXR0ZXJuLm9ucmVuZGVyID0gZnVuY3Rpb24oIHJlbmRlcmVkICkge1xuICAgIHJlbmRlcmVkLnR5cGUgPSAnSGV4J1xuXG4gICAgcmVuZGVyZWQudGltZSA9IHRpbWVcblxuICAgIHJlbmRlcmVkLm91dHB1dCA9IHsgdGltZSwgc2hvdWxkRXhlY3V0ZTogMCB9XG5cbiAgICByZW5kZXJlZC5hZGRGaWx0ZXIoICggYXJncywgcHRybiApID0+IHtcbiAgICAgIGxldCB2YWwgPSBhcmdzWyAwIF1cblxuICAgICAgcHRybi5vdXRwdXQudGltZSA9IEdpYmJlcmlzaC5DbG9jay50aW1lKCBwdHJuLnRpbWUgKVxuICAgICAgcHRybi5vdXRwdXQuc2hvdWxkRXhlY3V0ZSA9IHBhcnNlSW50KHZhbCkgXG5cbiAgICAgIGFyZ3NbIDAgXSA9IHB0cm4ub3V0cHV0IFxuXG4gICAgICByZXR1cm4gYXJnc1xuICAgIH0pXG4gIH1cblxuICBwYXR0ZXJuLnJlc2VlZCA9ICggLi4uYXJncyApPT4ge1xuICAgIGxldCBuLCBrXG4gICAgXG4gICAgaWYoIEFycmF5LmlzQXJyYXkoIGFyZ3NbMF0gKSApIHtcbiAgICAgIGsgPSBhcmdzWzBdWzBdXG4gICAgICBuID0gYXJnc1swXVsxXVxuICAgIH1lbHNle1xuICAgICAgayA9IGFyZ3NbMF1cbiAgICAgIG4gPSBhcmdzWzFdXG4gICAgfVxuXG4gICAgaWYoIG4gPT09IHVuZGVmaW5lZCApIG4gPSAxNlxuICAgIFxuICAgIG91dCA9IGNyZWF0ZVN0YXJ0aW5nQXJyYXkoIG4sayApXG4gICAgbGV0IF9vbmVzQW5kWmVyb3MgPSBJbm5lciggbixrIClcbiAgICBcbiAgICBwYXR0ZXJuLnNldCggX29uZXNBbmRaZXJvcyApXG4gICAgcGF0dGVybi50aW1lID0gMSAvIG5cblxuICAgIC8vIHRoaXMuY2hlY2tGb3JVcGRhdGVGdW5jdGlvbiggJ3Jlc2VlZCcsIHBhdHRlcm4gKVxuXG4gICAgcmV0dXJuIHBhdHRlcm5cbiAgfVxuXG4gIC8vR2liYmVyLmFkZFNlcXVlbmNpbmdUb01ldGhvZCggcGF0dGVybiwgJ3Jlc2VlZCcgKVxuXG4gIGlmKCB0eXBlb2Ygcm90YXRpb24gPT09ICdudW1iZXInICkgcGF0dGVybi5yb3RhdGUoIHJvdGF0aW9uIClcblxuICByZXR1cm4gcGF0dGVyblxufVxuXG5yZXR1cm4gSGV4XG5cbn1cbiIsImNvbnN0IEdpYmJlciA9IHtcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBleHBvcnRUYXJnZXQ6IG51bGwsXG4gIHBsdWdpbnM6IFtdLFxuICAvLyBuZWVkZWQgc28gYXVkaW8gcGx1Z2luIGNhbiB0cmFuc2ZlciBwYXR0ZXJuIGZ1bmN0aW9uIHN0cmluZyB0byB3b3JrbGV0XG4gIF9fUGF0dGVybjogcmVxdWlyZSggJy4vcGF0dGVybi5qcycgKSxcblxuICAvKiBcbiAgICogY29uc3QgcHJvbWlzZXMgPSBHaWJiZXIuaW5pdChbXG4gICAqICAge1xuICAgKiAgICAgcGx1Z2luOkF1ZGlvLCAvLyBBdWRpbyBpcyByZXF1aXJlZCwgaW1wb3J0ZWQsIG9yIGdyYWJiZWQgdmlhIDxzY3JpcHQ+XG4gICAqICAgICBvcHRpb25zOiB7IHdvcmtsZXRQYXRoOicuLi9kaXN0L2dpYmJlcmlzaF93b3JrbGV0LmpzJyB9XG4gICAqICAgfSxcbiAgICogICB7XG4gICAqICAgICBwbHVnaW46R3JhcGhpY3MsXG4gICAqICAgICBvcHRpb25zOnsgY2FudmFzOmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycgKSB9XG4gICAqICAgfVxuICAgKiBdKVxuICAqL1xuXG4gIGluaXQoIHBsdWdpbnMgKSB7IFxuICAgIHRoaXMuY3JlYXRlUHViU3ViKCB0aGlzIClcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zXG5cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdXG5cbiAgICAvLyBpbml0IGVhY2ggcGx1Z2luIGFuZCBjb2xsZWN0IHByb21pc2VzXG4gICAgZm9yKCBsZXQgcGx1Z2luIG9mIHBsdWdpbnMgKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKCBcbiAgICAgICAgcGx1Z2luLnBsdWdpbi5pbml0KCBwbHVnaW4ub3B0aW9ucywgdGhpcyApIFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2hlZEluaXRQcm9taXNlID0gUHJvbWlzZS5hbGwoIHByb21pc2VzICkudGhlbiggdmFsdWVzID0+IHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuUGF0dGVybiA9IHRoaXMuX19QYXR0ZXJuKCB0aGlzIClcbiAgICAgICAgdGhpcy5TZXEgICAgICA9IHJlcXVpcmUoICcuL3NlcS5qcycgICAgICApKCB0aGlzIClcbiAgICAgICAgdGhpcy5UaWRhbCAgICA9IHJlcXVpcmUoICcuL3RpZGFsLmpzJyAgICApKCB0aGlzIClcbiAgICAgICAgdGhpcy5FdWNsaWQgICA9IHJlcXVpcmUoICcuL2V1Y2xpZC5qcycgICApKCB0aGlzIClcbiAgICAgICAgdGhpcy5IZXggICAgICA9IHJlcXVpcmUoICcuL2hleC5qcycgICAgICApKCB0aGlzICkgXG4gICAgICAgIHRoaXMuVHJpZ2dlcnMgPSByZXF1aXJlKCAnLi90cmlnZ2Vycy5qcycgKSggdGhpcyApXG4gICAgICAgIHRoaXMuU3RlcHMgICAgPSByZXF1aXJlKCAnLi9zdGVwcy5qcycgICAgKSggdGhpcyApXG5cbiAgICAgICAgdmFsdWVzLmZvckVhY2goIHYgPT4ge1xuICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB2ICkgKSBcbiAgICAgICAgICAgIHRoaXNbIHZbMV0gXSA9IHZbMF1cbiAgICAgICAgfSlcblxuICAgICAgICBHaWJiZXIucHVibGlzaCggJ2luaXQnIClcbiAgICAgICAgXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuICBcbiAgICByZXR1cm4gcFxuICB9LFxuXG4gIGxvZyggLi4uYXJncyApIHtcbiAgICBpZiggR2liYmVyLkVudmlyb25tZW50ICkge1xuICAgICAgR2liYmVyLkVudmlyb25tZW50LmxvZyggLi4uYXJncyApXG4gICAgfWVsc2V7XG4gICAgICBjb25zb2xlLmxvZyggLi4uYXJncyApXG4gICAgfVxuICB9LFxuXG4gIGVycm9yKCAuLi5hcmdzICkge1xuICAgIGlmKCBHaWJiZXIuRW52aXJvbm1lbnQgKSB7XG4gICAgICBHaWJiZXIuRW52aXJvbm1lbnQuZXJyb3IoIC4uLmFyZ3MgKVxuICAgIH1lbHNle1xuICAgICAgY29uc29sZS5lcnJvciggLi4uYXJncyApXG4gICAgfVxuICB9LFxuXG4gIGV4cG9ydCggb2JqICkge1xuICAgIC8vIFhYWCBtdXN0IGtlZXAgcmVmZXJlbmNlIHRvIG1haW4gcGF0dGVybiBmdW5jdGlvblxuICAgIC8vIHNvIGl0IGNhbiBiZSBzZXJpYWxpemVkIGFuZCB0cmFuc2ZlcnJlZCB0byBhdWRpb3dvcmtsZXQgIFxuICAgIG9iai5QYXR0ZXJuICA9IHRoaXMuUGF0dGVyblxuICAgIG9iai5TZXEgPSB0aGlzLlNlcVxuICAgIG9iai5UaWRhbCA9IHRoaXMuVGlkYWxcbiAgICBvYmouRXVjbGlkID0gdGhpcy5FdWNsaWRcbiAgICBvYmouSGV4ID0gdGhpcy5IZXhcbiAgICBvYmouVHJpZ2dlcnMgPSB0aGlzLlRyaWdnZXJzXG4gICAgb2JqLlN0ZXBzID0gdGhpcy5TdGVwc1xuXG4gICAgdGhpcy5wbHVnaW5zLmZvckVhY2goIHAgPT4ge1xuICAgICAgcC5wbHVnaW4uZXhwb3J0KCBvYmosIEdpYmJlciApIFxuICAgIH0pXG5cbiAgICAvL29iai5DbG9jayA9IHRoaXMuQ2xvY2tcbiAgICAvL29iai5XYXZlUGF0dGVybiA9IHRoaXMuV2F2ZVBhdHRlcm5cbiAgfSxcblxuICAvLyBYWFggc3RvcCBjbG9jayBmcm9tIGJlaW5nIGNsZWFyZWQuXG4gIGNsZWFyKCkgeyBcbiAgICBmb3IoIGxldCBwbHVnaW4gb2YgR2liYmVyLnBsdWdpbnMgKSB7XG4gICAgICBwbHVnaW4ucGx1Z2luLmNsZWFyKClcbiAgICB9XG5cbiAgICB0aGlzLlNlcS5jbGVhcigpXG4gICAgdGhpcy5UaWRhbC5jbGVhcigpXG5cbiAgICB0aGlzLnB1Ymxpc2goICdjbGVhcicgKVxuICB9LFxuXG4gIG9ubG9hZCgpIHt9LFxuXG4gIGNyZWF0ZVB1YlN1Yiggb2JqICkge1xuICAgIGNvbnN0IGV2ZW50cyA9IHt9XG4gICAgb2JqLnN1YnNjcmliZSA9IGZ1bmN0aW9uKCBrZXksIGZjbiApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGV2ZW50c1sga2V5IF0gPSBbXVxuICAgICAgfVxuICAgICAgZXZlbnRzWyBrZXkgXS5wdXNoKCBmY24gKVxuICAgIH1cblxuICAgIG9iai51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCBrZXksIGZjbiApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGV2ZW50c1sga2V5IF1cblxuICAgICAgICBhcnIuc3BsaWNlKCBhcnIuaW5kZXhPZiggZmNuICksIDEgKVxuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5wdWJsaXNoID0gZnVuY3Rpb24oIGtleSwgZGF0YSApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGV2ZW50c1sga2V5IF1cblxuICAgICAgICBhcnIuZm9yRWFjaCggdiA9PiB2KCBkYXRhICkgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBXaGVuIGEgcHJvcGVydHkgaXMgY3JlYXRlZCwgYSBwcm94eS1pc2ggb2JqZWN0IGlzIG1hZGUgdGhhdCBpc1xuICAvLyBwcmVmYWNlZCBieSBhIGRvdWJsZSB1bmRlcnNjb3JlLiBUaGlzIG9iamVjdCBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIFxuICAvLyBwcm9wZXJ0eSwgc2VxdWVuY2VycyBmb3IgdGhlIHByb3BlcnR5LCBhbmQgbW9kdWxhdGlvbnMgZm9yIHRoZSBwcm9wZXJ0eS5cbiAgLy8gQWx0ZXJuYXRpdmUgZ2V0dGVyL3NldHRlciBtZXRob2RzIGNhbiBiZSBwYXNzZWQgYXMgYXJndW1lbnRzLlxuICBjcmVhdGVQcm9wZXJ0eSggb2JqLCBuYW1lLCB2YWx1ZSwgcG9zdD1udWxsLCBwcmlvcml0eT0wLCB0cmFuc2Zvcm09bnVsbCwgaXNQb2x5PWZhbHNlICkge1xuICAgIG9ialsgJ19fJyArIG5hbWUgXSA9IHsgXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzUHJvcGVydHk6dHJ1ZSxcbiAgICAgIHNlcXVlbmNlcnM6W10sXG4gICAgICB0aWRhbHM6W10sXG4gICAgICBtb2RzOltdLFxuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6b2JqLnR5cGUsXG4gICAgICBfX293bmVyOm9iaixcblxuICAgICAgZmFkZSggZnJvbT0wLCB0bz0xLCB0aW1lPTQsIGRlbGF5PTAgKSB7XG4gICAgICAgIEdpYmJlclsgb2JqLnR5cGUgXS5jcmVhdGVGYWRlKCBmcm9tLCB0bywgdGltZSwgb2JqLCBuYW1lLCBkZWxheSApXG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHaWJiZXIuYWRkU2VxdWVuY2luZyggb2JqLCBuYW1lLCBwcmlvcml0eSwgdmFsdWUsICdfXycgKVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgZ2V0OiBHaWJiZXJbIG9iai50eXBlIF0uY3JlYXRlR2V0dGVyKCBvYmosIG5hbWUgKSxcbiAgICAgIHNldDogR2liYmVyWyBvYmoudHlwZSBdLmNyZWF0ZVNldHRlciggb2JqLCBuYW1lLCBwb3N0LCB0cmFuc2Zvcm0sIGlzUG9seSApXG4gICAgfSlcbiAgfSxcblxuICBnZXRUeXBlKCBvYmogKSB7XG4gICAgbGV0IHR5cGVcbiAgICBzd2l0Y2goIGZyb20udHlwZSApIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ0F1ZGlvJzpcbiAgICAgICAgdHlwZSA9IEdpYmJlci5BdWRpb1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZ3JhcGhpY3MnOlxuICAgICAgY2FzZSAnR3JhcGhpY3MnOlxuICAgICAgICB0eXBlID0gR2liYmVyLkdyYXBoaWNzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdnZW4nOlxuICAgICAgICB0eXBlID0gJ2dlbidcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVxuICB9LFxuXG4gIG1hcHBpbmdzOiB7fSxcbiAgXG4gIGNyZWF0ZU1hcHBpbmcoIGZyb20sIHRvLCBuYW1lLCB3cmFwcGVkVG8gKSB7XG4gICAgY29uc3QgZnJvbWxpYiA9IHRoaXMuZ2V0VHlwZSggZnJvbSApLFxuICAgICAgICAgIHRvbGliICAgPSB0aGlzLmdldFR5cGUoIHRvIClcblxuXG4gICAgaWYoIG1hcHBpbmdzWyB0b2xpYiBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG1hcHBpbmdzWyB0b2xpYiBdWyBmcm9tbGliIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIFxuICAgICAgY29uc3QgbWFwcGVyID0gbWFwcGluZ3NbIHRvbGliIF1bIGZyb21saWIgXVxuXG4gICAgICBtYXBwZXIoIG5hbWUsIHRvLCBmcm9tIClcbiAgICB9XG5cbiAgXG4gICAgLy9pZiggZnJvbS50eXBlID09PSAnYXVkaW8nICkge1xuICAgIC8vICBjb25zdCBmID0gdG9bICdfXycgKyBuYW1lIF0uZm9sbG93ID0gRm9sbG93KHsgaW5wdXQ6IGZyb20sIGJ1ZmZlclNpemU6NDA5NiB9KVxuXG4gICAgLy8gIE1hcmNoaW5nLmNhbGxiYWNrcy5wdXNoKCB0aW1lID0+IHtcbiAgICAvLyAgICBpZiggZi5vdXRwdXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAvLyAgICAgIHRvWyBuYW1lIF0gPSBmLm91dHB1dFxuICAgIC8vICAgIH1cbiAgICAvLyAgfSlcblxuICAgIC8vICBsZXQgbSA9IGYubXVsdGlwbGllclxuICAgIC8vICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRvWyBuYW1lIF0sICdtdWx0aXBsaWVyJywge1xuICAgIC8vICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgIC8vICAgIGdldCgpIHsgcmV0dXJuIG0gfSxcbiAgICAvLyAgICBzZXQodikgeyBtID0gdjsgZi5tdWx0aXBsaWVyID0gbSB9XG4gICAgLy8gIH0pXG5cbiAgICAvLyAgbGV0IG8gPSBmLm9mZnNldFxuICAgIC8vICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRvWyBuYW1lIF0sICdvZmZzZXQnLCB7XG4gICAgLy8gICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgLy8gICAgZ2V0KCkgeyByZXR1cm4gbyB9LFxuICAgIC8vICAgIHNldCh2KSB7IG8gPSB2OyBmLm9mZnNldCA9IG8gfVxuICAgIC8vICB9KVxuICAgIC8vfWVsc2UgaWYoIGZyb20udHlwZSA9PT0gJ2dlbicgKSB7XG4gICAgLy8gIGNvbnN0IGdlbiA9IGZyb20ucmVuZGVyKCA2MCwgJ2dyYXBoaWNzJyApXG5cbiAgICAvLyAgLy8gbmVlZGVkIGZvciBhbm5vdGF0aW9uc1xuICAgIC8vICB0b1sgbmFtZSBdLnZhbHVlLmlkID0gdG9bIG5hbWUgXS52YWx1ZS52YXJOYW1lXG5cbiAgICAvLyAgLy8gWFhYIGZpeCB0aGUgdHdvIHBvc3NpYmxlIGxvY2F0aW9ucyBmb3IgdGhlIGNhbGxiYWNrXG4gICAgLy8gIGlmKCB0b1sgbmFtZSBdLnZhbHVlLmNhbGxiYWNrICE9PSB1bmRlZmluZWQgKSB7XG4gICAgLy8gICAgY29uc3QgaWR4ID0gTWFyY2hpbmcuY2FsbGJhY2tzLmluZGV4T2YoIHRvWyBuYW1lIF0udmFsdWUuY2FsbGJhY2sgKVxuICAgIC8vICAgIE1hcmNoaW5nLmNhbGxiYWNrcy5zcGxpY2UoIGlkeCwgMSApXG4gICAgLy8gIH1lbHNlIGlmKCB0b1sgJ19fJytuYW1lIF0uY2FsbGJhY2sgIT09IHVuZGVmaW5lZCApIHtcbiAgICAvLyAgICBjb25zdCBpZHggPSBNYXJjaGluZy5jYWxsYmFja3MuaW5kZXhPZiggdG9bICdfXycrbmFtZSBdLmNhbGxiYWNrIClcbiAgICAvLyAgICBNYXJjaGluZy5jYWxsYmFja3Muc3BsaWNlKCBpZHgsIDEgKVxuICAgIC8vICB9XG5cbiAgICAvLyAgLy8gWFhYIGZpeCB0aGUgdHdvIHBvc3NpYmxlIGxvY2F0aW9ucyBmb3IgdGhlIGNhbGxiYWNrXG4gICAgLy8gIGlmKCB0eXBlb2YgdG9bIG5hbWUgXS52YWx1ZSA9PT0gJ29iamVjdCcgKSB7XG4gICAgLy8gICAgdG9bIG5hbWUgXS52YWx1ZS5jYWxsYmFjayA9IHQgPT4ge1xuICAgIC8vICAgICAgY29uc3QgdmFsID0gZ2VuKClcbiAgICAvLyAgICAgIHRvWyBuYW1lIF0gPSB2YWxcbiAgICAvLyAgICAgIC8vY29uc29sZS5sb2coICd2YWw6JywgdmFsLCB0b1sgbmFtZSBdLnZhbHVlLndpZGdldCAhPT0gdW5kZWZpbmVkIClcbiAgICAvLyAgICAgIGxldCB0YXJnZXQgPSB0b1sgbmFtZSBdLnZhbHVlLndpZGdldCAhPT0gdW5kZWZpbmVkID8gdG9bIG5hbWUgXS52YWx1ZS53aWRnZXQgOiBmcm9tLndpZGdldFxuXG4gICAgLy8gICAgICBpZiggdGFyZ2V0ID09PSB1bmRlZmluZWQgJiYgdG9bIG5hbWUgXS52YWx1ZS5tYXJrICE9PSB1bmRlZmluZWQgKSBcbiAgICAvLyAgICAgICAgdGFyZ2V0ID0gdG9bIG5hbWUgXS52YWx1ZS5tYXJrLnJlcGxhY2VkV2l0aFxuXG4gICAgLy8gICAgICBHaWJiZXIuRW52aXJvbm1lbnQuY29kZU1hcmt1cC53YXZlZm9ybS51cGRhdGVXaWRnZXQoIHRhcmdldCwgdmFsLCBmYWxzZSApXG4gICAgLy8gICAgfVxuICAgIC8vICB9ZWxzZXtcbiAgICAvLyAgICAvLyBhc3NpZ25tZW50IGhhY2sgd2hpbGUgRE9NIGNyZWF0aW9uIGlzIHRha2luZyBwbGFjZSxcbiAgICAvLyAgICAvLyBvbmx5IG5lZWRlZCBmb3IgbWFwcGluZ3MgdG8gaW5kaXZpZHVhbCB2ZWN0b3IgZWxlbWVudHMuXG4gICAgLy8gICAgaWYoIHRvWyAnX18nK25hbWUgXS53aWRnZXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAvLyAgICAgIHNldFRpbWVvdXQoICgpPT4gdG9bICdfXycrbmFtZSBdLndpZGdldCA9IGdlbi5wcmUud2lkZ2V0LCAxNTAgKVxuICAgIC8vICAgIH1cblxuICAgIC8vICAgIHRvWyAnX18nK25hbWUgXS5jYWxsYmFjayA9IHQgPT4ge1xuICAgIC8vICAgICAgY29uc3QgdmFsID0gZ2VuKClcbiAgICAvLyAgICAgIHRvWyBuYW1lIF0gPSB2YWxcbiAgICAvLyAgICAgIEdpYmJlci5FbnZpcm9ubWVudC5jb2RlTWFya3VwLndhdmVmb3JtLnVwZGF0ZVdpZGdldCggdG9bICdfXycrbmFtZSBdLndpZGdldCwgdmFsLCBmYWxzZSApXG4gICAgLy8gICAgfVxuICAgIC8vICB9XG5cbiAgICAvLyAgaWYoIHR5cGVvZiB0b1sgbmFtZSBdLnZhbHVlICE9PSAnb2JqZWN0JyApIHtcbiAgICAvLyAgICBNYXJjaGluZy5jYWxsYmFja3MucHVzaCggdG9bICdfXycrbmFtZSBdLmNhbGxiYWNrIClcbiAgICAvLyAgfWVsc2V7XG4gICAgLy8gICAgTWFyY2hpbmcuY2FsbGJhY2tzLnB1c2goIHRvWyBuYW1lIF0udmFsdWUuY2FsbGJhY2sgKVxuICAgIC8vICB9XG4gICAgLy99XG4gIH0sXG5cbiAgYWRkU2VxdWVuY2luZyggb2JqLCBuYW1lLCBwcmlvcml0eSwgdmFsdWUsIHByZWZpeD0nJyApIHtcbiAgICBpZiggb2JqWyBwcmVmaXgrbmFtZSBdID09PSB1bmRlZmluZWQgKSBvYmpbIHByZWZpeCtuYW1lIF0gPSB7fVxuXG4gICAgb2JqWyBwcmVmaXgrbmFtZSBdLnNlcXVlbmNlcnMgPSBbXVxuICAgIG9ialsgcHJlZml4K25hbWUgXS5zZXEgPSBmdW5jdGlvbiAoIHZhbHVlcywgdGltaW5ncywgbnVtYmVyID0gMCwgZGVsYXkgPSAwICkge1xuICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyApIHZhbHVlLm5hbWUgPSBvYmoubmFtZVxuICAgICAgY29uc3QgdHlwZSA9IG9iai50eXBlID09PSAnZ2VuJyA/ICdhdWRpbycgOiBvYmoudHlwZVxuICAgICAgR2liYmVyLlNlcSh7IFxuICAgICAgICB2YWx1ZXMsIFxuICAgICAgICB0aW1pbmdzLCBcbiAgICAgICAgdGFyZ2V0Om9iaixcbiAgICAgICAga2V5Om5hbWUsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBkZWxheSxcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBzdGFuZGFsb25lOmZhbHNlLFxuICAgICAgICBuYW1lOm9iai5uYW1lXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgb2JqWyBwcmVmaXgrbmFtZSBdLnRpZGFsID0gZnVuY3Rpb24oIHBhdHRlcm4sICBudW1iZXIgPSAwLCBkZWxheSA9IDAgKSB7XG4gICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApIHZhbHVlLm5hbWUgPSBvYmoubmFtZVxuICAgICAgY29uc3QgdHlwZSA9IG9iai50eXBlID09PSAnZ2VuJyA/ICdhdWRpbycgOiBvYmoudHlwZVxuICAgICAgY29uc3QgcyA9IEdpYmJlci5UaWRhbCh7IFxuICAgICAgICBwYXR0ZXJuLCBcbiAgICAgICAgdGFyZ2V0Om9iaiwgXG4gICAgICAgIGtleTpuYW1lLFxuICAgICAgICBudW1iZXIsXG4gICAgICAgIGRlbGF5LFxuICAgICAgICBzdGFuZGFsb25lOmZhbHNlXG4gICAgICB9KVxuXG4gICAgICAvLyByZXR1cm4gb2JqZWN0IGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gIH1cbiAgXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2liYmVyIFxuIiwiY29uc3QgcGF0dGVybldyYXBwZXIgPSBmdW5jdGlvbiggR2liYmVyICkge1xuICBcInVzZSBzdHJpY3RcIlxuXG4gIC8vIGhhY2sgdG8gcGFzcyBHaWJiZXJpc2ggdG8gcGF0dGVybiBnZW5lcmF0b3IgZnJvbSB3aXRoaW4gd29ya2xldCBwcm9jZXNzb3JcbiAgbGV0IEdpYmJlcmlzaFxuICBpZiggR2liYmVyLkdpYmJlcmlzaCA9PT0gdW5kZWZpbmVkICkge1xuICAgIEdpYmJlcmlzaCA9IEdpYmJlci5BdWRpbyAhPT0gdW5kZWZpbmVkID8gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaCA6IEdpYmJlciBcbiAgfWVsc2V7XG4gICAgR2liYmVyaXNoID0gR2liYmVyLkdpYmJlcmlzaFxuICB9XG5cbiAgbGV0IFBhdHRlcm5Qcm90byA9IE9iamVjdC5jcmVhdGUoIGZ1bmN0aW9uKCl7fSApXG5cbiAgLy8gdGhpcyBwcm90b3R5cGUgaXMgc29tZXdoYXQgbGltaXRlZCwgYXMgd2Ugd2FudCB0byBiZSBhYmxlIHRvIGFkZFxuICAvLyAuc2VxKCkgbWV0aG9kcyB0byBldmVyeXRoaW5nLiBUaGlzIG1lYW5zIHRoYXQgZXZlcnkgcGF0dGVybiBuZWVkcyBpdHMgb3duXG4gIC8vIGNvcHkgb2YgZWFjaCBtZXRob2QuIE9uZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byB1c2UgYSBtb3JlIGNvbXByZWhlbnNpdmVcbiAgLy8gcHJvdG90eXBlIGFuZCB0aGVuIHBsYWNlIHByb3hpZXMgb24gZWFjaCBtZXRob2Qgb2YgZWFjaCBwYXR0ZXJuIHRoYXQgYWNjZXNzXG4gIC8vIG9iamVjdC1zcGVjaWZpYyBzZXF1ZW5jZXJzLi4uIGJ1dCBqdXN0IG1ha2luZyBjb3BpZXMgb2YgYWxsIGZ1bmN0aW9ucyBpcyBjZXJ0YWlubHlcbiAgLy8gc2ltcGxlci5cbiAgT2JqZWN0LmFzc2lnbiggUGF0dGVyblByb3RvLCB7XG4gICAgdHlwZToncGF0dGVybicsXG4gICAgRE5SOiAtOTg3NjU0MzIxLFxuICAgIGNvbmNhdCggX3BhdHRlcm4gKSB7IHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuY29uY2F0KCBfcGF0dGVybi52YWx1ZXMgKSB9LCAgXG4gICAgLy90b1N0cmluZygpIHsgcmV0dXJuIHRoaXMudmFsdWVzLnRvU3RyaW5nKCkgfSxcbiAgICAvL3ZhbHVlT2YoKSB7IHJldHVybiB0aGlzLnZhbHVlcyB9LFxuXG4gICAgX19tZXNzYWdlKCAga2V5LCBhcmdzICkge1xuICAgICAgaWYoIHRoaXMuY2F0ZWdvcnkgPT09ICdhdWRpbycgKSB7XG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKVxuICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggdGhpcy5pZCwga2V5LCBhcmdzIClcbiAgICAgIH0gXG4gICAgfSxcblxuICAgIGdldExlbmd0aCgpIHtcbiAgICAgIGxldCBsXG4gICAgICBpZiggdGhpcy5zdGFydCA8PSB0aGlzLmVuZCApIHtcbiAgICAgICAgbCA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydCArIDFcbiAgICAgIH1lbHNle1xuICAgICAgICBsID0gdGhpcy52YWx1ZXMubGVuZ3RoICsgdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICsgMVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxcbiAgICB9LFxuXG4gICAgcnVuRmlsdGVycyggdmFsLCBpZHggKSB7XG4gICAgICBsZXQgYXJncyA9IFsgdmFsLCAxLCBpZHggXSAvLyAxIGlzIHBoYXNlTW9kaWZpZXJcblxuICAgICAgZm9yKCBsZXQgZmlsdGVyIG9mIHRoaXMuZmlsdGVycyApIHtcbiAgICAgICAgY29uc3QgX19hcmdzID0gYXJnc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFyZ3MgPSBmaWx0ZXIoIGFyZ3MsIHRoaXMgKSBcbiAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCBlIClcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ2ZpbHRlciBwcm9ibGVtPycgKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCBgcmVtb3ZpbmcgYmFkIGZpbHRlciBmcm9tIHBhdHRlcm46ICR7ZmlsdGVyLnRvU3RyaW5nKCl9YCApIFxuICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZmlsdGVycy5pbmRleE9mKCBmaWx0ZXIgKVxuICAgICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgYXJncyA9IF9fYXJnc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFhYWCB3aHkgaXMgdGhpcyBvbmUgb2ZmIGZyb20gdGhlIHdvcmtsZXQtc2lkZSBwYXR0ZXJuIGlkP1xuICAgICAgdGhpcy5fX21lc3NhZ2UoICd1cGRhdGUudmFsdWUnLCBhcmdzLm92ZXJyaWRlID09PSB1bmRlZmluZWQgPyBhcmdzWzBdIDogYXJncy5vdmVycmlkZSApIFxuICAgICAgdGhpcy5fX21lc3NhZ2UoICd1cGRhdGUuY3VycmVudEluZGV4JywgYXJnc1syXSApIFxuICAgICAgaWYoIHRoaXMuaXNHZW4gPT09IHRydWUgKSB7XG4gICAgICAgIHRoaXMuX19tZXNzYWdlKCAnd2F2ZWZvcm1Qb2ludCcsIGFyZ3Mub3ZlcnJpZGUgPT09IHVuZGVmaW5lZCA/IGFyZ3NbMF0gOiBhcmdzLm92ZXJyaWRlICkgXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmdzXG4gICAgfSxcblxuICAgIGNoZWNrRm9yVXBkYXRlRnVuY3Rpb24oIG5hbWUsIC4uLmFyZ3MgKSB7XG4gICAgICBpZiggdGhpcy5fX2RlbGF5QW5ub3RhdGlvbnMgPT09IHRydWUgKSB7XG4gICAgICAgIHNldFRpbWVvdXQoICgpPT4ge1xuICAgICAgICAgIGlmKCB0aGlzLmxpc3RlbmVyc1sgbmFtZSBdICkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbIG5hbWUgXS5hcHBseSggdGhpcywgYXJncyApXG4gICAgICAgICAgfWVsc2UgaWYoIFBhdHRlcm4ubGlzdGVuZXJzWyBuYW1lIF0gKSB7XG4gICAgICAgICAgICBQYXR0ZXJuLmxpc3RlbmVyc1sgbmFtZSBdLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCB0aGlzLmxpc3RlbmVyc1sgbmFtZSBdICkge1xuICAgICAgICAgIHRoaXMubGlzdGVuZXJzWyBuYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICAgICAgICB9ZWxzZSBpZiggUGF0dGVybi5saXN0ZW5lcnNbIG5hbWUgXSApIHtcbiAgICAgICAgICBQYXR0ZXJuLmxpc3RlbmVyc1sgbmFtZSBdLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyB1c2VkIHdoZW4gX29uY2hhbmdlIGhhcyBub3QgYmVlbiBhc3NpZ25lZCB0byBpbmRpdmlkdWFsIHBhdHRlcm5zXG4gICAgX29uY2hhbmdlKCkge30sXG5cbiAgICAvLyBYWFggaXQgd291bGQgYmUgbmljZSBpZiBmaWx0ZXJzIHVzZWQgYSBzaW1pbGFyIHN0eWxlIHRvIGZ4IGNoYWlucy4uLlxuICAgIC8vIHBhdHRlcm4uZmlsdGVycy5hZGQoICkgZXRjLlxuICAgIGFkZEZpbHRlciggZmlsdGVyLCBuYW1lPW51bGwgKSB7XG4gICAgICBpZiggbmFtZSAhPT0gbnVsbCApIHtcbiAgICAgICAgZmlsdGVyLl9fbmFtZSA9IG5hbWVcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJzLmZpbmRJbmRleCggZiA9PiBmLl9fbmFtZSA9PT0gbmFtZSApXG4gICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoIGlkeCwgMSApICBcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVycy5wdXNoKCBmaWx0ZXIgKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgcmVtb3ZlRmlsdGVyKCBpZHg9bnVsbCApIHtcbiAgICAgIGlmKCBpZHggIT09IG51bGwgKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoIGlkeCwgMSApICBcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLmZpbHRlcnMubGVuZ3RoID0gMFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBpbnNwZWN0KCkge1xuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIFxuICAgICAgICBjb25zb2xlLnRhYmxlKHsgdmFsdWVzOnRoaXMudmFsdWVzLnRvU3RyaW5nKCksICdudW1iZXIgb2YgZmlsdGVycyc6dGhpcy5maWx0ZXJzLmxlbmd0aCwgcGhhc2U6dGhpcy5waGFzZSB9KVxuICAgIH0sXG5cbiAgICByZW5kZXIoIGNhdD0nQXVkaW8nICkge1xuICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdFxuICAgICAgaWYoIHR5cGVvZiBHaWJiZXJbIGNhdCBdID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgR2liYmVyWyBjYXQgXS5wYXR0ZXJuUmVuZGVyID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBHaWJiZXJbIGNhdCBdLnBhdHRlcm5SZW5kZXIoIHRoaXMgKVxuICAgICAgfVxuICAgICAgaWYoIHR5cGVvZiB0aGlzLm9ucmVuZGVyID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICB0aGlzLm9ucmVuZGVyKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weSgpIHtcbiAgICAgIGNvbnN0IHAgPSBQYXR0ZXJuKCAuLi50aGlzLnZhbHVlcyApXG4gICAgICAvL3RoaXMuZmlsdGVycy5mb3JFYWNoKCBmID0+IHAuYWRkRmlsdGVyKCBmICkgKVxuICAgICAgcC5zdGFydCA9IHRoaXMuc3RhcnRcbiAgICAgIHAuZW5kICAgPSB0aGlzLmVuZFxuICAgICAgcC5waGFzZSA9IHRoaXMucGhhc2VcblxuICAgICAgcmV0dXJuIHBcbiAgICB9LFxuXG4gICAgX19tZXRob2ROYW1lczogIFtcbiAgICAgICdyb3RhdGUnLCdzd2l0Y2gnLCdpbnZlcnQnLCdmbGlwJyxcbiAgICAgICd0cmFuc3Bvc2UnLCdyZXZlcnNlJywnc2h1ZmZsZScsJ3NjYWxlJyxcbiAgICAgICdzdG9yZScsICdyYW5nZScsICdzZXQnLCAnZnJlZXplJywgJ3RoYXcnLCAnZG91YmxlJ1xuICAgIF1cblxuICB9KVxuXG4gIGNvbnN0IFBhdHRlcm4gPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAvL2NvbnNvbGUubG9nKCAnYXJnc1swXTonLCBhcmdzWzBdLmlzUGF0dGVybiwgYXJnc1swXSApXG4gICAgLy9pZiggdHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicgJiYgYXJnc1swXSAhPT0gbnVsbCAmJiBhcmdzWzBdLmlzUGF0dGVybiA9PT0gdHJ1ZSApIHtcbiAgICAvLyAgY29uc29sZS5sb2coICdnb3QgcGF0dGVybicgKVxuICAgIC8vICByZXR1cm4gYXJnc1swXVxuICAgIC8vfVxuXG4gICAgY29uc3QgaXNGdW5jdGlvbiA9IGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzR2VuID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmIGFyZ3NbMF0uX19pc0dlblxuXG4gICAgLy9pZiggaXNHZW4gPT09IHRydWUgKSB7IFxuICAgIC8vICAvLyBtdXN0IGhhdmUgYSBwcmlvcml0eSBvciBpdCBzY3Jld3MgdXMgY29kZWdlbiBmb3IgYW5hbHlzaXNcbiAgICAvLyAgYXJnc1swXS5wcmlvcml0eSA9IDBcbiAgICAvLyAgR2liYmVyaXNoLmFuYWx5emVycy5wdXNoKCBhcmdzWzBdIClcbiAgICAvLyAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAvL31cblxuXG4gICAgY29uc3QgZm5jID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbGVuID0gZm5jLmdldExlbmd0aCgpLFxuICAgICAgICAgIGlkeCwgdmFsLCBhcmdzXG5cbiAgICAgIGlmKCBsZW4gPT09IDEgKSB7IFxuICAgICAgICBpZHggPSAwIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlkeCA9IGZuYy5waGFzZSA+IC0xID8gTWF0aC5mbG9vciggZm5jLnN0YXJ0ICsgKGZuYy5waGFzZSAlIGxlbiApICkgOiBNYXRoLmZsb29yKCBmbmMuZW5kICsgKGZuYy5waGFzZSAlIGxlbiApIClcbiAgICAgIH1cblxuICAgICAgaWYoIGlzRnVuY3Rpb24gKSB7XG4gICAgICAgIHZhbCA9IGZuYy52YWx1ZXNbIDAgXSgpXG4gICAgICAgIGFyZ3MgPSBmbmMucnVuRmlsdGVycyggdmFsLCBpZHggKVxuICAgICAgICB2YWwgPSBhcmdzWzBdXG4gICAgICB9IGVsc2UgaWYoIGlzR2VuID09PSB0cnVlICkge1xuICAgICAgICB2YWwgPSBmbmMudmFsdWVzWyAwIF0uY2FsbGJhY2sub3V0WzBdXG5cbiAgICAgICAgYXJncyA9IGZuYy5ydW5GaWx0ZXJzKCB2YWwsIGlkeCApXG4gICAgICAgIHZhbCA9IGFyZ3NbMF1cbiAgICAgIH1lbHNle1xuICAgICAgICB2YWwgPSBmbmMudmFsdWVzWyBNYXRoLmZsb29yKCBpZHggJSBmbmMudmFsdWVzLmxlbmd0aCApIF1cbiAgICAgICAgYXJncyA9IGZuYy5ydW5GaWx0ZXJzKCB2YWwsIGlkeCApXG4gICAgICBcbiAgICAgICAgZm5jLnBoYXNlICs9IGZuYy5zdGVwU2l6ZSAqIGFyZ3NbIDEgXVxuXG5cbiAgICAgICAgdmFsID0gYXJnc1sgMCBdXG4gICAgICB9XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgYW5kIGlmIHNvIGV2YWx1YXRlIGl0XG4gICAgICAvL2lmKCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAvL3ZhbCA9IHZhbCgpXG4gICAgICAvL31cbiAgICAgIC8qZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuICAgICAgICAvLyBpZiB2YWwgaXMgYW4gQXJyYXksIGxvb3AgdGhyb3VnaCBhcnJheSBhbmQgZXZhbHVhdGUgYW55IGZ1bmN0aW9ucyBmb3VuZCB0aGVyZS4gVE9ETzogSVMgVEhJUyBTTUFSVD9cblxuICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIGlmKCB0eXBlb2YgdmFsWyBpIF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICB2YWxbIGkgXSA9IHZhbFsgaSBdKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICovXG5cbiAgICAgIC8vWFhYIGlzIHRoaXMgbmVlZGVkPyBBZGRpbmcgaXQgaW50ZXJmZXJlcyB3aXRoIFN0ZXBzXG4gICAgICAvL2lmKCB2YWwgPT09IGZuYy5ETlIgKSB2YWwgPSBudWxsXG5cbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cblxuXG4gICAgbGV0IG91dCBcbiAgICBPYmplY3QuYXNzaWduKCBmbmMsIHtcbiAgICAgIGNhdGVnb3J5OidhdWRpbycsXG4gICAgICBzdGFydCA6IDAsXG4gICAgICBlbmQgICA6IDAsXG4gICAgICBwaGFzZSA6IDAsXG4gICAgICB2YWx1ZXMgOiBhcmdzLCBcbiAgICAgIGlzUGF0dGVybjogdHJ1ZSxcbiAgICAgIF9fZnJvemVuOmZhbHNlLFxuICAgICAgLy8gd3JhcCBhbm5vdGF0aW9uIHVwZGF0ZSBpbiBzZXRUaW1lb3V0KCBmdW5jLCAwIClcbiAgICAgIF9fZGVsYXlBbm5vdGF0aW9uczpmYWxzZSxcbiAgICAgIC8vdmFsdWVzIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ3N0cmluZycgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICkgOiBhcmd1bWVudHNbMF0uc3BsaXQoJycpLCAgICBcbiAgICAgIG9yaWdpbmFsIDogbnVsbCxcbiAgICAgIHN0b3JhZ2UgOiBbXSxcbiAgICAgIHN0ZXBTaXplIDogMSxcbiAgICAgIGludGVnZXJzT25seSA6IGZhbHNlLFxuICAgICAgZmlsdGVycyA6IFtdLFxuICAgICAgX19saXN0ZW5lcnM6IFtdLFxuICAgICAgb25jaGFuZ2UgOiBudWxsLFxuICAgICAgaXNvcDp0cnVlLFxuICAgICAgaXNHZW4sXG5cbiAgICAgIGZyZWV6ZSggc2hvdWxkRnJlZXplVGhlb3J5ID0gdHJ1ZSApIHtcbiAgICAgICAgZm5jLl9fZnJvemVuID0gdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRoYXcoKSB7XG4gICAgICAgIGZuYy5fX2Zyb3plbiA9IGZhbHNlXG4gICAgICAgIEdpYmJlci5UaGVvcnkudGhhdygpXG4gICAgICB9LFxuXG4gICAgICBzZXRTZXEoIHNlcSApIHtcbiAgICAgICAgdGhpcy5zZXEgPSBzZXFcbiAgICAgIH0sXG5cbiAgICAgIHJhbmdlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQucmFuZ2UoIC4uLmFyZ3MgKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBsZXQgc3RhcnQsIGVuZFxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCBhcmd1bWVudHNbMF0gKSApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gYXJndW1lbnRzWzBdWzBdXG4gICAgICAgICAgICBlbmQgICA9IGFyZ3VtZW50c1swXVsxXVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc3RhcnQgPSBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgIGVuZCAgID0gYXJndW1lbnRzWzFdXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBzdGFydCA8IGVuZCApIHtcbiAgICAgICAgICAgIGZuYy5zdGFydCA9IHN0YXJ0XG4gICAgICAgICAgICBmbmMuZW5kID0gZW5kXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBmbmMuc3RhcnQgPSBlbmRcbiAgICAgICAgICAgIGZuYy5lbmQgPSBzdGFydFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2hlY2tGb3JVcGRhdGVGdW5jdGlvbiggJ3JhbmdlJywgZm5jIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgICBkb3VibGUoLi4uYXJncykge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5kb3VibGUoLi4uYXJncylcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuXG4gICAgICAgICAgZm5jLnZhbHVlcy5wdXNoKCAuLi5mbmMudmFsdWVzICkgXG4gICAgICAgICAgXG4gICAgICAgICAgZm5jLmVuZCA9IGZuYy52YWx1ZXMubGVuZ3RoIC0gMVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmKCBmbmMuZW5kID4gZm5jLnZhbHVlcy5sZW5ndGggLSAxICkge1xuICAgICAgICAgIC8vICAgZm5jLmVuZCA9IGZuYy52YWx1ZXMubGVuZ3RoIC0gMVxuICAgICAgICAgIC8vIH1lbHNlIGlmKCBmbmMuZW5kIDwgKVxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9XG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSgpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sICAgXG5cbiAgICAgIHNldCguLi5hcmdzKSB7XG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnNldCguLi5hcmdzKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgbGV0IGFyZ3MgPSBBcnJheS5pc0FycmF5KCBhcmd1bWVudHNbIDAgXSApID8gYXJndW1lbnRzWyAwIF0gOiBhcmd1bWVudHNcbiAgICAgICAgICBcbiAgICAgICAgICBmbmMudmFsdWVzLmxlbmd0aCA9IDBcblxuICAgICAgICAgIGNvbnN0IHRtcCA9IFtdIFxuICAgICAgICAgIFxuICAgICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGFyZ3NbaV0uaXNQYXR0ZXJuID09PSB0cnVlID8gYXJnc1sgaSBdLm9yaWdpbmFsLnNsaWNlKDApIDogYXJnc1sgaSBdIFxuICAgICAgICAgICAgdG1wLnB1c2goIHZhbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGZuYy52YWx1ZXMgPSB0bXBcbiAgICAgICAgICBcbiAgICAgICAgICBmbmMuZW5kID0gZm5jLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gaWYoIGZuYy5lbmQgPiBmbmMudmFsdWVzLmxlbmd0aCAtIDEgKSB7XG4gICAgICAgICAgLy8gICBmbmMuZW5kID0gZm5jLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgICAgLy8gfWVsc2UgaWYoIGZuYy5lbmQgPCApXG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICd2YWx1ZXMnLCBmbmMudmFsdWVzICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgdHJ1ZSApIFxuICAgICAgICAgIH1cbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAnc2V0JywgZm5jLnZhbHVlcyApIC8vYXJncyApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgICAgXG4gICAgICByZXZlcnNlKCkge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5yZXZlcnNlKClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIGxldCBhcnJheSA9IGZuYy52YWx1ZXMsXG4gICAgICAgICAgICAgIGxlZnQgPSBudWxsLFxuICAgICAgICAgICAgICByaWdodCA9IG51bGwsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgdGVtcG9yYXJ5O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICBmb3IgKCBsZWZ0ID0gMCwgcmlnaHQgPSBsZW5ndGggLSAxOyBsZWZ0IDwgcmlnaHQ7IGxlZnQgKz0gMSwgcmlnaHQgLT0gMSApIHtcbiAgICAgICAgICAgIHRlbXBvcmFyeSA9IGFycmF5WyBsZWZ0IF1cbiAgICAgICAgICAgIGFycmF5WyBsZWZ0IF0gPSBhcnJheVsgcmlnaHQgXVxuICAgICAgICAgICAgYXJyYXlbIHJpZ2h0IF0gPSB0ZW1wb3Jhcnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgYXJyYXkgKSBcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICdfb25jaGFuZ2UnLCB0cnVlICkgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3JldmVyc2UnLCBudWxsIClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcbiAgICAgIC8vIGh1bWFuaXplOiBmdW5jdGlvbiggcmFuZG9tTWluLCByYW5kb21NYXggKSB7XG4gICAvLyAgICAgIGxldCBsYXN0QW10ID0gMFxuICAgLy9cbiAgIC8vICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKysgKSB7XG4gICAvLyAgICAgICAgaWYoIHRoaXMuZmlsdGVyc1sgaSBdLmh1bWFuaXplICkge1xuICAgLy8gICAgICAgICAgbGFzdEFtdCA9IHRoaXMuZmlsdGVyc1sgaSBdLmxhc3RBbXRcbiAgIC8vICAgICAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoIGksIDEgKVxuICAgLy8gICAgICAgICAgYnJlYWs7XG4gICAvLyAgICAgICAgfVxuICAgLy8gICAgICB9XG4gICAvL1xuICAgLy8gICAgICBsZXQgZmlsdGVyID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gICAvLyAgICAgICAgY29uc29sZS5sb2coIGZpbHRlci5sYXN0QW10LCBhcmdzWzBdKVxuICAgLy8gICAgICAgIGFyZ3NbIDAgXSAtPSBmaWx0ZXIubGFzdEFtdFxuICAgLy8gICAgICAgIGZpbHRlci5sYXN0QW10ID0gR2liYmVyLkNsb2NrLnRpbWUoIEdpYmJlci5VdGlsaXRpZXMucm5kaSggcmFuZG9tTWluLCByYW5kb21NYXggKSApXG4gICAvL1xuICAgLy8gICAgICAgIGNvbnNvbGUubG9nKCBcIkxBXCIsIGZpbHRlci5sYXN0QW10IClcbiAgIC8vICAgICAgICBhcmdzWzBdICs9IGZpbHRlci5sYXN0QW10XG4gICAvL1xuICAgLy8gICAgICAgIHJldHVybiBhcmdzXG4gICAvLyAgICAgIH1cbiAgIC8vICAgICAgZmlsdGVyLmxhc3RBbXQgPSBsYXN0QW10XG4gICAvLyAgICAgIGZpbHRlci5odW1hbml6ZSA9IHRydWVcbiAgIC8vXG4gICAvLyAgICAgIHRoaXMuZmlsdGVycy5wdXNoKCBmaWx0ZXIgKVxuICAgLy9cbiAgIC8vICAgICAgcmV0dXJuIHRoaXNcbiAgIC8vICAgIH0sXG4gICAgICByZXBlYXQoKSB7XG4gICAgICAgIGxldCBjb3VudHMgPSB7fVxuICAgICAgXG4gICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPTIgKSB7XG4gICAgICAgICAgY291bnRzWyBhcmd1bWVudHNbIGkgXSBdID0ge1xuICAgICAgICAgICAgcGhhc2U6IDAsXG4gICAgICAgICAgICB0YXJnZXQ6IGFyZ3VtZW50c1sgaSArIDEgXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IHJlcGVhdGluZyA9IGZhbHNlLCByZXBlYXRWYWx1ZSA9IG51bGwsIHJlcGVhdEluZGV4ID0gbnVsbFxuICAgICAgICBsZXQgZmlsdGVyID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gYXJnc1sgMCBdLCBwaGFzZU1vZGlmaWVyID0gYXJnc1sgMSBdLCBvdXRwdXQgPSBhcmdzXG4gICAgICAgICAgXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyggYXJncywgY291bnRzIClcbiAgICAgICAgICBpZiggcmVwZWF0aW5nID09PSBmYWxzZSAmJiBjb3VudHNbIHZhbHVlIF0gKSB7XG4gICAgICAgICAgICByZXBlYXRpbmcgPSB0cnVlXG4gICAgICAgICAgICByZXBlYXRWYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICByZXBlYXRJbmRleCA9IGFyZ3NbMl1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHJlcGVhdGluZyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIGlmKCBjb3VudHNbIHJlcGVhdFZhbHVlIF0ucGhhc2UgIT09IGNvdW50c1sgcmVwZWF0VmFsdWUgXS50YXJnZXQgKSB7XG4gICAgICAgICAgICAgIG91dHB1dFsgMCBdID0gcmVwZWF0VmFsdWUgICAgICAgICAgICBcbiAgICAgICAgICAgICAgb3V0cHV0WyAxIF0gPSAwXG4gICAgICAgICAgICAgIG91dHB1dFsgMiBdID0gcmVwZWF0SW5kZXhcbiAgICAgICAgICAgICAgLy9bIHZhbCwgMSwgaWR4IF1cbiAgICAgICAgICAgICAgY291bnRzWyByZXBlYXRWYWx1ZSBdLnBoYXNlKytcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBjb3VudHNbIHJlcGVhdFZhbHVlIF0ucGhhc2UgPSAwXG4gICAgICAgICAgICAgIG91dHB1dFsgMSBdID0gMVxuICAgICAgICAgICAgICBpZiggdmFsdWUgIT09IHJlcGVhdFZhbHVlICkgeyBcbiAgICAgICAgICAgICAgICByZXBlYXRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBjb3VudHNbIHJlcGVhdFZhbHVlIF0ucGhhc2UrK1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBmbmMuZmlsdGVycy5wdXNoKCBmaWx0ZXIgKVxuICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgXG4gICAgICByZXNldCgpIHsgXG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnJlc2V0KClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIC8vIFhYWCByZXBsYWNlIHdpdGggc29tZSB0eXBlIG9mIHN0YW5kYXJkIGRlZXAgY29weVxuICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCBmbmMub3JpZ2luYWxbMF0gKSApIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdXG4gICAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGZuYy5vcmlnaW5hbC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgY29uc3QgY2hvcmQgPSBmbmMub3JpZ2luYWxbIGkgXVxuICAgICAgICAgICAgICBhcnJbIGkgXSA9IFtdXG4gICAgICAgICAgICAgIGZvciggbGV0IGogPSAwOyBqIDwgY2hvcmQubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgYXJyWyBpIF1bIGogXSA9IGNob3JkWyBqIF0gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuYy52YWx1ZXMgPSBhcnJcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGZuYy52YWx1ZXMgPSBmbmMub3JpZ2luYWwuc2xpY2UoMClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9mbmMuc2V0KCBmbmMub3JpZ2luYWwuc2xpY2UoIDAgKSApO1xuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9ICBcbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAncmVzZXQnLCBudWxsIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbmMgXG4gICAgICB9LFxuXG4gICAgICBzdG9yZSggcG9zICkgeyBmbmMuc3RvcmFnZVsgcG9zIHx8IGZuYy5zdG9yYWdlLmxlbmd0aCBdID0gZm5jLnZhbHVlcy5zbGljZSggMCApOyByZXR1cm4gZm5jOyB9LFxuXG4gICAgICB0cmFuc3Bvc2UoIGFtdCApIHsgXG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnRyYW5zcG9zZSggYW10IClcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhZm5jLl9fZnJvemVuICkge1xuICAgICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgZm5jLnZhbHVlcy5sZW5ndGg7IGkrKyApIHsgXG4gICAgICAgICAgICBsZXQgdmFsID0gZm5jLnZhbHVlc1sgaSBdXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcbiAgICAgICAgICAgICAgZm9yKCBsZXQgaiA9IDA7IGogPCB2YWwubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2YWxbIGogXSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgICB2YWxbIGogXSA9IGZuYy5pbnRlZ2Vyc09ubHkgPyBNYXRoLnJvdW5kKCB2YWxbIGogXSArIGFtdCApIDogdmFsWyBqIF0gKyBhbXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgZm5jLnZhbHVlc1sgaSBdID0gZm5jLmludGVnZXJzT25seSA/IE1hdGgucm91bmQoIGZuYy52YWx1ZXNbIGkgXSArIGFtdCApIDogZm5jLnZhbHVlc1sgaSBdICsgYW10XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICd2YWx1ZXMnLCBmbmMudmFsdWVzICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgWyd0cmFuc3Bvc2UnLCBhbXRdICkgXG4gICAgICAgICAgfSAgICAgIFxuICAgICAgICAgIC8vZm5jLl9vbmNoYW5nZSggJ3RyYW5zcG9zZScsIGFtdCApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG5cbiAgICAgIHNodWZmbGUoKSB7IFxuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5zaHVmZmxlKCApXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBHaWJiZXIuVXRpbGl0eS5zaHVmZmxlKCBmbmMudmFsdWVzIClcbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAnc2h1ZmZ1bGUnLCBudWxsIClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcblxuICAgICAgc2NhbGUoIGFtdCApIHsgXG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnNjYWxlKCBhbXQgKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgZm5jLnZhbHVlcy5tYXAoICh2YWwsIGlkeCwgYXJyYXkpID0+IHtcbiAgICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcbiAgICAgICAgICAgICAgYXJyYXlbIGlkeCBdID0gdmFsLm1hcCggaW5zaWRlICA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBpbnNpZGUgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuYy5pbnRlZ2Vyc09ubHkgPyBNYXRoLnJvdW5kKCBpbnNpZGUgKiBhbXQgKSA6IGluc2lkZSAqIGFtdFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5zaWRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgICBhcnJheVsgaWR4IF0gPSBmbmMuaW50ZWdlcnNPbmx5ID8gTWF0aC5yb3VuZCggdmFsICogYW10ICkgOiB2YWwgKiBhbXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICd2YWx1ZXMnLCBmbmMudmFsdWVzICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgdHJ1ZSApIFxuICAgICAgICAgIH1cbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAnc2NhbGUnLCBhbXQgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm5jXG4gICAgICB9LFxuXG4gICAgICBmbGlwKCkge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5mbGlwKCApXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBsZXQgc3RhcnQgPSBbXSxcbiAgICAgICAgICAgICAgb3JkZXJlZCA9IG51bGxcbiAgICAgICAgXG4gICAgICAgICAgb3JkZXJlZCA9IGZuYy52YWx1ZXMuZmlsdGVyKCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUHVzaCA9IHN0YXJ0LmluZGV4T2YoIGVsZW0gKSA9PT0gLTFcbiAgICAgICAgICAgIGlmKCBzaG91bGRQdXNoICkgc3RhcnQucHVzaCggZWxlbSApXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkUHVzaFxuICAgICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAgIG9yZGVyZWQgPSBvcmRlcmVkLnNvcnQoIGZ1bmN0aW9uKCBhLGIgKXsgcmV0dXJuIGEgLSBiIH0gKVxuICAgICAgICBcbiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGZuYy52YWx1ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gb3JkZXJlZC5pbmRleE9mKCBmbmMudmFsdWVzWyBpIF0gKVxuICAgICAgICAgICAgZm5jLnZhbHVlc1sgaSBdID0gb3JkZXJlZFsgb3JkZXJlZC5sZW5ndGggLSBwb3MgLSAxIF1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICd2YWx1ZXMnLCBmbmMudmFsdWVzICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgdHJ1ZSApIFxuICAgICAgICAgIH0gICAgICAgXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ2ZsaXAnLCBudWxsIClcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIHJldHVybiBmbmNcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGludmVydCgpIHtcbiAgICAgICAgaWYoIHRoaXMuX19yZW5kZXJlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX19yZW5kZXJlZCAhPT0gdGhpcyApIHtcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyZWQuaW52ZXJ0KCApXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBsZXQgcHJpbWUwID0gZm5jLnZhbHVlc1sgMCBdXG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCBsZXQgaSA9IDE7IGkgPCBmbmMudmFsdWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBmbmMudmFsdWVzWyBpIF0gPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICBsZXQgaW52ZXJzZSA9IHByaW1lMCArIChwcmltZTAgLSBmbmMudmFsdWVzWyBpIF0pXG4gICAgICAgICAgICAgIGZuYy52YWx1ZXNbIGkgXSA9IGludmVyc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICAgIGZuYy5fX21lc3NhZ2UoICd2YWx1ZXMnLCBmbmMudmFsdWVzICkgXG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAnX29uY2hhbmdlJywgdHJ1ZSApIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZuYy5fb25jaGFuZ2UoICdpbnZlcnQnLCBudWxsIClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcbiAgICBcbiAgICAgIHN3aXRjaCggdG8gKSB7XG4gICAgICAgIGlmKCB0aGlzLl9fcmVuZGVyZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVuZGVyZWQgIT09IHRoaXMgKSB7XG4gICAgICAgICAgdGhpcy5fX3JlbmRlcmVkLnN3aXRjaCggdG8gKVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgaWYoICFmbmMuX19mcm96ZW4gKSB7XG4gICAgICAgICAgaWYoIGZuYy5zdG9yYWdlWyB0byBdICkge1xuICAgICAgICAgICAgZm5jLnZhbHVlcyA9IGZuYy5zdG9yYWdlWyB0byBdLnNsaWNlKCAwIClcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgZm5jLl9vbmNoYW5nZSggJ3N3aXRjaCcsIHRvIClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcbiAgICBcbiAgICAgIHJvdGF0ZSggYW10ICkge1xuICAgICAgICBpZiggdGhpcy5fX3JlbmRlcmVkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fX3JlbmRlcmVkICE9PSB0aGlzICkge1xuICAgICAgICAgIHRoaXMuX19yZW5kZXJlZC5yb3RhdGUoIGFtdCApXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgICBpZiggIWZuYy5fX2Zyb3plbiApIHtcbiAgICAgICAgICBpZiggYW10ID4gMCApIHtcbiAgICAgICAgICAgIHdoaWxlKCBhbXQgPiAwICkge1xuICAgICAgICAgICAgICBsZXQgZW5kID0gZm5jLnZhbHVlcy5wb3AoKVxuICAgICAgICAgICAgICBmbmMudmFsdWVzLnVuc2hpZnQoIGVuZCApXG4gICAgICAgICAgICAgIGFtdC0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2UgaWYoIGFtdCA8IDAgKSB7XG4gICAgICAgICAgICB3aGlsZSggYW10IDwgMCApIHtcbiAgICAgICAgICAgICAgbGV0IGJlZ2luID0gZm5jLnZhbHVlcy5zaGlmdCgpXG4gICAgICAgICAgICAgIGZuYy52YWx1ZXMucHVzaCggYmVnaW4gKVxuICAgICAgICAgICAgICBhbXQrK1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgICBmbmMuX19tZXNzYWdlKCAndmFsdWVzJywgZm5jLnZhbHVlcyApIFxuICAgICAgICAgICAgZm5jLl9fbWVzc2FnZSggJ19vbmNoYW5nZScsIHRydWUgKSBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbmMuX29uY2hhbmdlKCAncm90YXRlJywgYW10IClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZuY1xuICAgICAgfSxcblxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgIGZvciggbGV0IGtleSBvZiBQYXR0ZXJuUHJvdG8uX19tZXRob2ROYW1lcyApIHtcbiAgICAgICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgb3V0WyBrZXkgXS5zZXF1ZW5jZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBtb3N0IGNlcnRhaW5seSBiZSBvcHRpbWl6ZWQsIGJ1dCBJIGhhZCByZWFsIHByb2JsZW1zXG4gICAgICAgICAgICAgIC8vIGdldHRpbmcgdGhpcyBjbGVhcmluZyB0byB3b3JrLCBwZXJoYXBzIHJlbGF0ZWQgdG8gcHJveHkgYmVoYXZpb3JzP1xuICAgICAgICAgICAgICBjb25zdCBfX3NlcSA9IEdpYmJlci5TZXEuc2VxdWVuY2Vycy5maW5kKCBzID0+IHMuaWQgPT09IG91dFsga2V5IF1bIGkgXS5pZCApXG4gICAgICAgICAgICAgIGlmKCBfX3NlcSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIEdpYmJlci5BdWRpby5HaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgYWRkcmVzczonbWV0aG9kJywgb2JqZWN0Ol9fc2VxLmlkLCBuYW1lOidzdG9wJywgYXJnczpbXSB9KVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBfX3NlcS5zdG9wKClcbiAgICAgICAgICAgICAgICBfX3NlcS5jbGVhcigpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBHaWJiZXIuU2VxLnNlcXVlbmNlcnMuaW5kZXhPZiggX19zZXEgKVxuICAgICAgICAgICAgICAgIEdpYmJlci5TZXEuc2VxdWVuY2Vycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgICAgICAgICAgICAgX19zZXEudGFyZ2V0WyBfX3NlcS5rZXkgXVswXS5zdG9wKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIGdlbmlzaC1iYXNlZCBwYXR0ZXJucyBhcmUgY29ubmVjdGVkIGFzIGFuYWx5emVycyBzbyB0aGF0IHRoZXlcbiAgICAgICAgICAvLyBkb24ndCBoYXZlIHRvIGZlZWQgaW50byBhIGJ1cyB0byBnZXQgcmVuZGVyZWQuIHdlIG11c3QgcmVtb3ZlIHRoZW1cbiAgICAgICAgICAvLyBmcm9tIHRoZSBhbmFseXNpcyBhcnJheSB0byBmaW5hbGl6ZSBjbGVhcmluZy5cbiAgICAgICAgICBpZiggb3V0LmlzR2VuID09PSB0cnVlICkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gR2liYmVyaXNoLmFuYWx5emVycy5pbmRleE9mKCBhcmdzWzBdIClcbiAgICAgICAgICAgIGlmKCBpZHggIT09IC0xICkge1xuICAgICAgICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnNwbGljZSggaWR4LCAxIClcbiAgICAgICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgZm5jLmlkID0gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgICBpZiggaXNHZW4gPT09IHRydWUgKSB7XG4gICAgICAgIGZuYy53YXZlZm9ybVBvaW50ID0gdmFsID0+IHtcbiAgICAgICAgICAvLyBhY2NvdW50cyBmb3IgYW5ub3lpbmcgZWRnZSBjYXNlIHdoZXJlIHdhdmUgcGF0dGVybiBpc1xuICAgICAgICAgIC8vIGlubGluZWQgdG8gYSBjYWxsIHRvIC5zZXFcbiAgICAgICAgICAvLyBYWFggZml4IGluIHBhcnNpbmcgb3Igc29tZWhvdyBmaWd1cmUgb3V0IGhvdyB0byBvbmx5IGRvIHRoaXMgb25jZVxuICAgICAgICAgIGlmKCBmbmMud2lkZ2V0ICE9PSB1bmRlZmluZWQgKSBmbmMudmFsdWVzWzBdLndpZGdldCA9IGZuYy53aWRnZXRcbiAgICAgICAgICBpZiggZm5jLnZhbHVlc1swXS53aWRnZXQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgLy8gY29udmVydCBzYW1wbGVzIHRvIGJlYXRzXG4gICAgICAgICAgICBpZiggZm5jLl9fcGF0dGVyblR5cGUgPT09ICd0aW1pbmdzJyApIHtcbiAgICAgICAgICAgICAgdmFsID0gR2liYmVyLkNsb2NrLnN0b2IoIHZhbCApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbmMudmFsdWVzWzBdLndpZGdldC52YWx1ZXNbIGZuYy52YWx1ZXNbMF0ud2lkZ2V0LnZhbHVlcy5sZW5ndGggLSAxIF0gPSB7IHZhbHVlOnZhbCB9IFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvL2ZuYy5maWx0ZXJzLnBhdHRlcm4gPSBmbmNcbiAgICAvLyBjYW4gSSByZXNvdHJlIHRoaXMgd2l0aG91dCBtYWtpbmcgdGhlIG9iamVjdCBub24tc2VyaWFsaXphYmxlP1xuICAgIC8vZm5jLnJldHJvZ3JhZGUgPSBmbmMucmV2ZXJzZS5iaW5kKCBmbmMgKVxuICAgIFxuICAgIGZuYy5lbmQgPSBmbmMudmFsdWVzLmxlbmd0aCAtIDFcbiAgICBcbiAgICAvKlxuICAgIGZuYy5maWx0ZXJzLnRlc3QgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coICd0ZXN0JyApIH1cbiAgICBcbiAgICBmbmMuZmlsdGVycy5hZGQgPSBmdW5jdGlvbiggZiApIHtcbiAgICAgIHRoaXMuZmlsdGVycy5wdXNoKCBmIClcbiAgICB9LmJpbmQoZm5jKVxuICAgIGZuYy5maWx0ZXJzLnJlbW92ZSA9IGZ1bmN0aW9uKCBpZHggKSB7XG4gICAgICBjb25zb2xlLmxvZyggJ2ZpbHRlcjonLCB0aGlzIClcbiAgICAgIHRoaXMuZmlsdGVycy5zcGxpY2UoIGlkeCwgMSApXG4gICAgfS5iaW5kKCBmbmMgKVxuICAgIGZuYy5maWx0ZXJzLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKCBgdGhlcmUgYXJlIGN1cnJlbmx5ICR7dGhpcy5sZW5ndGh9IGZpbHRlcnMgb24gdGhpcyBwYXR0ZXJuYCApXG4gICAgfS5iaW5kKGZuYylcbiAgICAqL1xuXG4gICAgaWYoIEFycmF5LmlzQXJyYXkoIGZuYy52YWx1ZXNbMF0gKSApIHtcbiAgICAgIGNvbnN0IGFyciA9IFtdXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IGZuYy52YWx1ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNvbnN0IGNob3JkID0gZm5jLnZhbHVlc1sgaSBdXG4gICAgICAgIGFyclsgaSBdID0gW11cbiAgICAgICAgZm9yKCBsZXQgaiA9IDA7IGogPCBjaG9yZC5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICBhcnJbIGkgXVsgaiBdID0gY2hvcmRbIGogXSBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm5jLm9yaWdpbmFsID0gYXJyXG4gICAgfWVsc2V7XG4gICAgICBmbmMub3JpZ2luYWwgPSBmbmMudmFsdWVzLnNsaWNlKDApXG4gICAgfVxuXG4gICAgZm5jLnN0b3JhZ2VbIDAgXSA9IGZuYy5vcmlnaW5hbC5zbGljZSggMCApXG4gICAgZm5jLmludGVnZXJzT25seSA9IGZuYy52YWx1ZXMuZXZlcnkoIGZ1bmN0aW9uKCBuICkgeyByZXR1cm4gbiA9PT0gK24gJiYgbiA9PT0gKG58MCk7IH0pXG4gICAgXG4gICAgZm5jLmxpc3RlbmVycyA9IHt9XG4gICAgZm5jLnNlcXVlbmNlcyA9IHt9XG5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcblxuICAgICAgZm9yKCBsZXQga2V5IG9mIFBhdHRlcm5Qcm90by5fX21ldGhvZE5hbWVzICkgeyBcbiAgICAgICAgR2liYmVyLmFkZFNlcXVlbmNpbmcoIGZuYyxrZXksMix1bmRlZmluZWQgKVxuICAgICAgfVxuICAgICAgLy9mb3IoIGxldCBrZXkgb2YgUGF0dGVyblByb3RvLl9fbWV0aG9kTmFtZXMgKSB7IFxuICAgICAgLy8gIGZuYy5zZXF1ZW5jZXJzWyBrZXkgXSA9IEdpYmJlci5Db3JlICE9PSB1bmRlZmluZWQgXG4gICAgICAvLyAgICA/IEdpYmJlci5Db3JlLmFkZFNlcXVlbmNpbmcoIGZuYywga2V5LCAyICkgXG4gICAgICAvLyAgICA6IEdpYmJlci5hZGRTZXF1ZW5jaW5nKCBmbmMsa2V5LDIgKVxuICAgICAgLy99XG4gICAgICBmbmMuc2VxdWVuY2VzLnJlc2V0ID0gR2liYmVyLmFkZFNlcXVlbmNpbmcoIGZuYywgJ3Jlc2V0JywgMSApXG4gICAgfVxuICAgIFxuICAgIC8vIFRPRE86IEdpYmJlci5jcmVhdGVQcm94eVByb3BlcnRpZXMoIGZuYywgeyAnc3RlcFNpemUnOjAsICdzdGFydCc6MCwgJ2VuZCc6MCB9KVxuICAgIFxuICAgIGZuYy5fX3Byb3RvX18gPSBQYXR0ZXJuUHJvdG8gXG5cbiAgICBsZXQgcG4gPSAnJ1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZm5jLCAncGF0dGVybk5hbWUnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBwbiB9LFxuICAgICAgc2V0KF9fcG4pIHtcbiAgICAgICAgcG4gPSBfX3BuXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZuYy5yZW5kZXIgPSBmdW5jdGlvbiggbW9kZT0nYXVkaW8nICkge1xuICAgICAgaWYoIG1vZGUgPT09ICdhdWRpbycgKSB7XG4gICAgICAgIC8vICdpc1BhdHRlcm4nIGlzIGEgaGFjayB0byBmb3JjZSBwYXR0ZXJuIGluaXRpYWxpemF0aW9uIGFyZ3VtZW50cyB0byBiZSBzdWJtaXR0ZWQgYXNcbiAgICAgICAgLy8gYSBsaXN0LCBpbnN0ZWFkIG9mIGluIGEgcHJvcGVydHkgZGljdGlvbmFyeS4gV2hlbiAnaXNQYXR0ZXJuJyBpcyB0cnVlLCBnaWJiZXJpc2hcbiAgICAgICAgLy8gbG9va3MgZm9yIGFuICdpbnB1dHMnIHByb3BlcnR5IGFuZCB0aGVuIHBhc3NlcyBpdHMgdmFsdWUgKGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkpXG4gICAgICAgIC8vIHVzaW5nIHRoZSBzcHJlYWQgb3BlcmF0b3IgdG8gdGhlIGNvbnN0cnVjdG9yLiBcbiAgICAgICAgb3V0ID0gR2liYmVyaXNoLlByb3h5KCAncGF0dGVybicsIHsgaW5wdXRzOmZuYy52YWx1ZXMsIGlzUGF0dGVybjp0cnVlLCBmaWx0ZXJzOmZuYy5maWx0ZXJzLCBpZDpmbmMuaWQgfSwgZm5jICkgXG5cbiAgICAgICAgaWYoIGlzR2VuID09PSB0cnVlICkgeyBcbiAgICAgICAgICAvLyBtdXN0IGhhdmUgYSBwcmlvcml0eSBvciBpdCBzY3Jld3MgdXAgY29kZWdlbiBmb3IgYW5hbHlzaXNcbiAgICAgICAgICBhcmdzWzBdLnByaW9yaXR5ID0gMFxuICAgICAgICAgIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggYXJnc1swXSApXG4gICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggYXJncy5maWx0ZXJzICkge1xuICAgICAgICBhcmdzLmZpbHRlcnMuZm9yRWFjaCggZiA9PiBvdXQuYWRkRmlsdGVyKCBmICkgKVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdLmZpbHRlcnMgKSB7XG4gICAgICAgIGFyZ3NbMF0uZmlsdGVycy5mb3JFYWNoKCBmID0+IG91dC5hZGRGaWx0ZXIoIGYgKSApXG4gICAgICB9XG5cbiAgICAgIFBhdHRlcm4uY2hpbGRyZW4ucHVzaCggb3V0IClcblxuICAgICAgaWYoIGZuYy5vbnJlbmRlciApIGZuYy5vbnJlbmRlciggb3V0IClcblxuICAgICAgZm5jLl9fcmVuZGVyZWQgPSBvdXRcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkgcmV0dXJuIGZuYy5yZW5kZXIoKVxuXG4gICAgcmV0dXJuIGZuYyBcbiAgfVxuXG4gIFBhdHRlcm4ubGlzdGVuZXJzID0ge31cbiAgUGF0dGVybi5jaGlsZHJlbiA9IFtdXG4gIFBhdHRlcm4uX19pc0Zyb3plbiA9IGZhbHNlXG4gIFBhdHRlcm4uZnJlZXplID0gZnVuY3Rpb24oIHNob3VsZEZyZWV6ZVRoZW9yeSA9IHRydWUgKSB7XG4gICAgUGF0dGVybi5jaGlsZHJlbi5mb3JFYWNoKCBwID0+IHAuZnJlZXplKCkgKSBcbiAgICBpZiggc2hvdWxkRnJlZXplVGhlb3J5ID09PSB0cnVlICkge1xuICAgICAgR2liYmVyLlRoZW9yeS5mcmVlemUoKVxuICAgICAgUGF0dGVybi5fX2lzRnJvemVuID0gdHJ1ZVxuICAgIH1cbiAgfVxuICBQYXR0ZXJuLnRoYXcgPSAoKT0+IHtcbiAgICBQYXR0ZXJuLmNoaWxkcmVuLmZvckVhY2goIHAgPT4gcC50aGF3KCkgKVxuICAgIGlmKCBQYXR0ZXJuLl9faXNGcm96ZW4gPT09IHRydWUgKSB7XG4gICAgICBHaWJiZXIuVGhlb3J5LnRoYXcoKVxuICAgICAgUGF0dGVybi5fX2lzRnJvemVuID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBQYXR0ZXJuLmV4cG9ydCA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgb2JqLmZyZWV6ZSA9IFBhdHRlcm4uZnJlZXplXG4gICAgb2JqLnRoYXcgICA9IFBhdHRlcm4udGhhd1xuICB9XG5cbiAgUGF0dGVybi5saXN0ZW5lcnMucmFuZ2UgPSBmdW5jdGlvbiggZm5jICkge1xuICAgIC8vaWYoICFOb3RhdGlvbi5pc1J1bm5pbmcgKSByZXR1cm5cbiAgICBcbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkgcmV0dXJuXG5cbiAgICAvLyBUT0RPOiBkb24ndCB1c2UgR2liYmVyLmN1cnJlbnRUcmFjaywgc3RvcmUgdGhlIG9iamVjdCBpbiB0aGUgcGF0dGVyblxuICAgIGxldCByYW5nZVN0YXJ0ID0gZm5jLm1hcmtlcnNbIGZuYy5zdGFydCBdLmZpbmQoKSxcbiAgICAgICAgcmFuZ2VFbmQgICA9IGZuYy5tYXJrZXJzWyBmbmMuZW5kIF0uZmluZCgpXG5cbiAgICBpZiggIWZuYy5yYW5nZS5pbml0ICkge1xuICAgICAgZm5jLnJhbmdlLmluaXQgPSB0cnVlXG4gICAgICB2YXIgcHRyblN0YXJ0ID0gZm5jLm1hcmtlcnNbIDAgXS5maW5kKCksXG4gICAgICAgICAgcHRybkVuZCA9IGZuYy5tYXJrZXJzWyBmbmMubWFya2Vycy5sZW5ndGggLSAxIF0uZmluZCgpXG5cbiAgICAgIC8vZm5jLmNvbHVtbi5lZGl0b3IubWFya1RleHQoIHB0cm5TdGFydC5mcm9tLCBwdHJuRW5kLnRvLCB7IGNsYXNzTmFtZToncmFuZ2VPdXRzaWRlJyB9KVxuICAgICAgR2liYmVyLkVudmlyb25tZW50LmVkaXRvci5tYXJrVGV4dCggcHRyblN0YXJ0LmZyb20sIHB0cm5FbmQudG8sIHsgY2xhc3NOYW1lOidyYW5nZU91dHNpZGUnIH0pLy9jbGFzc05hbWU6J3BhdHRlcm4tdXBkYXRlLXJhbmdlLW91dHNpZGUnIH0pXG4gICAgICBpZiggIVBhdHRlcm4ubGlzdGVuZXJzLnJhbmdlLmluaXRpYWx6aWVkICkgUGF0dGVybi5saXN0ZW5lcnMucmFuZ2UuaW5pdCgpXG4gICAgfVxuXG4gICAgaWYoIGZuYy5yYW5nZS5tYXJrICkgZm5jLnJhbmdlLm1hcmsuY2xlYXIoKVxuICAgIC8vZm5jLnJhbmdlLm1hcmsgPSBmbmMuY29sdW1uLmVkaXRvci5tYXJrVGV4dCggcmFuZ2VTdGFydC5mcm9tLCByYW5nZUVuZC50bywgeyBjbGFzc05hbWU6J3JhbmdlSW5zaWRlJyB9KVxuICAgIC8vIFRPRE86IERvbnQgdXNlIEdFLmNvZGVtaXJyb3IuLi4gaG93IGVsc2UgZG8gSSBnZXQgdGhpcz8gc3RvcmVkIGluIHBhdHRlcm4gaXMgY3JlYXRlZD9cbiAgICBmbmMucmFuZ2UubWFyayA9IEdpYmJlci5FbnZpcm9ubWVudC5lZGl0b3IubWFya1RleHQoIHJhbmdlU3RhcnQuZnJvbSwgcmFuZ2VFbmQudG8sIHsgY2xhc3NOYW1lOidyYW5nZUluc2lkZScgfSlcbiAgfVxuXG4gIFBhdHRlcm4ubGlzdGVuZXJzLnJhbmdlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyQuaW5qZWN0Q1NTKHsgXG4gICAgLy8gICcucmFuZ2VPdXRzaWRlJzoge1xuICAgIC8vICAgICdjb2xvcic6JyM2NjYgIWltcG9ydGFudCdcbiAgICAvLyAgfSxcbiAgICAvLyAgJy5yYW5nZUluc2lkZSc6IHtcbiAgICAvLyAgICAnY29sb3InOidyZ2JhKDEwMiwgMTUzLCAyMjEsIDEpICFpbXBvcnRhbnQnXG4gICAgLy8gIH1cbiAgICAvL30pXG4gICAgUGF0dGVybi5saXN0ZW5lcnMucmFuZ2UuaW5pdGlhbGl6ZWQgPSB0cnVlXG4gIH1cblxuICAvL1BhdHRlcm4ucHJvdG90eXBlID0gUGF0dGVyblByb3RvKi9cblxuICByZXR1cm4gUGF0dGVyblxuXG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiB0byBwYXNzIHRoZSBwYXR0ZXJuIGNvbnN0cnVjdG9yIHRvIHRoZSBnaWJiZXJpc2ggd29ya2xldCBwcm9jZXNzb3IuXG5wYXR0ZXJuV3JhcHBlci50cmFuc2ZlciA9IGZ1bmN0aW9uKCBBdWRpbywgY29uc3RydWN0b3JTdHJpbmcgKSB7XG4gIGlmKCBBdWRpby5HaWJiZXJpc2ggIT09IHVuZGVmaW5lZCAmJiBBdWRpby5HaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgIEF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgYWRkcmVzczonYWRkQ29uc3RydWN0b3InLFxuICAgICAgbmFtZTonUGF0dGVybicsXG4gICAgICBjb25zdHJ1Y3RvclN0cmluZ1xuICAgIH0pXG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdHRlcm5XcmFwcGVyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXIgKSB7XG4gIGNvbnN0IGFkZFZhbHVlc0ZpbHRlcnMgPSAoc2VxLGtleSx0YXJnZXQpID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBzZXEudmFsdWVzXG4gICAgY29uc3QgX192YWx1ZXMgPSBzZXEudmFsdWVzXG5cbiAgICBpZiggX192YWx1ZXMucmFuZG9tRmxhZyApIHtcbiAgICAgIHZhbHVlcy5hZGRGaWx0ZXIoICggYXJncyxwdHJuICkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IHB0cm4udmFsdWVzLmxlbmd0aCAtIDFcbiAgICAgICAgY29uc3QgaWR4ID0gTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIHJhbmdlIClcbiAgICAgICAgcmV0dXJuIFsgcHRybi52YWx1ZXNbIGlkeCBdLCAxLCBpZHggXSBcbiAgICAgIH0pXG4gICAgICAvL2ZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMucmFuZG9tQXJncy5sZW5ndGg7IGkrPTIgKSB7XG4gICAgICAvLyAgdmFsdWVzUGF0dGVybi5yZXBlYXQoIHRoaXMudmFsdWVzLnJhbmRvbUFyZ3NbIGkgXSwgdGhpcy52YWx1ZXMucmFuZG9tQXJnc1sgaSArIDEgXSApXG4gICAgICAvL31cbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGF1dG90cmlnIHBhdHRlcm5zXG4gICAgaWYoIGtleSA9PT0gJ25vdGUnIHx8IGtleSA9PT0gJ2Nob3JkJyB8fCBrZXkgPT09ICd0cmlnZ2VyJyB8fCBrZXkgPT09ICdub3RlZicgfHwga2V5ID09PSAncGlja3BsYXknICkge1xuICAgICAgdmFsdWVzLmFkZEZpbHRlciggKCBhcmdzLHB0cm4gKSA9PiB7XG4gICAgICAgIGlmKCBwdHJuLnNlcS50YXJnZXQuYXV0b3RyaWcgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBmb3IoIGxldCBzIG9mIHB0cm4uc2VxLnRhcmdldC5hdXRvdHJpZyApIHtcbiAgICAgICAgICAgIHMuZmlyZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzXG4gICAgICB9KVxuICAgIH0gXG4gIH1cblxuICBjb25zdCBhZGRUaW1pbmdGaWx0ZXJzID0gZnVuY3Rpb24oIHNlcSxrZXkscmVuZGVyTW9kZSApIHtcbiAgICBjb25zdCBfX3RpbWluZ3MgPSBzZXEudGltaW5nc1xuICAgIGlmKCBfX3RpbWluZ3MucmFuZG9tRmxhZyApIHtcbiAgICAgIF9fdGltaW5ncy5hZGRGaWx0ZXIoICggYXJncyxwdHJuICkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IHB0cm4udmFsdWVzLmxlbmd0aCAtIDFcbiAgICAgICAgY29uc3QgaWR4ID0gTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIHJhbmdlIClcbiAgICAgICAgcmV0dXJuIFsgcHRybi52YWx1ZXNbIGlkeCBdLCAxLCBpZHggXSBcbiAgICAgIH0pXG4gICAgICAvL2ZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMucmFuZG9tQXJncy5sZW5ndGg7IGkrPTIgKSB7XG4gICAgICAvLyAgdmFsdWVzUGF0dGVybi5yZXBlYXQoIHRoaXMudmFsdWVzLnJhbmRvbUFyZ3NbIGkgXSwgdGhpcy52YWx1ZXMucmFuZG9tQXJnc1sgaSArIDEgXSApXG4gICAgICAvL31cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXIgPSByZW5kZXJNb2RlID09PSAnQXVkaW8nIFxuICAgICAgPyAoYXJncyxwdHJuKSA9PiB7XG4gICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgYXJnc1swXSA9IEdpYmJlcmlzaC5DbG9jay50aW1lKCBhcmdzWzBdIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgICAgfVxuICAgICAgOiAoYXJncyxwdHJuKSA9PiB7XG4gICAgICAgIGlmKCB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgYXJnc1swXSA9IEdpYmJlci5DbG9jay50aW1lKCBhcmdzWzBdIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgICAgfSAgXG5cbiAgICBzZXEudGltaW5ncy5hZGRGaWx0ZXIoIChhcmdzLHB0cm4pPT57XG4gICAgICBpZiggYXJnc1swXSA9PT0gMCApIHtcbiAgICAgICAgcHRybi5zZXEuc3RvcCgpXG4gICAgICAgIGNvbnNvbGUud2FybiggJ3NlcXVlbmNlciBhdHRlbXB0aW5nIHRvIGZpcmUgd2l0aCBhIHRpbWUgb2YgemVybzsgdGhpcyB3aWxsIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLCBzbyB0aGUgc2VxdWVuY2VyIGhhcyBiZWVuIHN0b3BwZWQuJyApXG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1xuICAgIH0pXG4gICAgc2VxLnRpbWluZ3MuYWRkRmlsdGVyKCBmaWx0ZXIgKSBcbiAgfVxuXG4gIGNvbnN0IFNlcSA9IGZ1bmN0aW9uKCBwcm9wcyApIHsgXG4gICAgbGV0ICAgX192YWx1ZXMgID0gcHJvcHMudmFsdWVzXG4gICAgY29uc3QgX190aW1pbmdzID0gcHJvcHMudGltaW5nc1xuICAgIGNvbnN0IGRlbGF5ICAgICA9IHByb3BzLmRlbGF5XG4gICAgY29uc3QgdGFyZ2V0ICAgID0gcHJvcHMudGFyZ2V0XG4gICAgY29uc3Qga2V5ICAgICAgID0gcHJvcHMua2V5XG4gICAgY29uc3QgcHJpb3JpdHkgID0gcHJvcHMucHJpb3JpdHlcbiAgICBsZXQgICByYXRlICAgICAgPSBwcm9wcy5yYXRlIHx8IDFcbiAgICBsZXQgICBkZW5zaXR5ICAgPSBwcm9wcy5kZW5zaXR5IHx8IDFcbiAgICBsZXQgICBhdXRvdHJpZyAgPSBmYWxzZVxuICAgIGNvbnN0IHJlbmRlciAgICA9IHByb3BzLnJlbmRlciB8fCAnQXVkaW8nXG5cbiAgICBjb25zdCBHaWJiZXJpc2ggPSBHaWJiZXIuQXVkaW8uR2liYmVyaXNoICE9PSB1bmRlZmluZWQgPyBHaWJiZXIuQXVkaW8uR2liYmVyaXNoIDogbnVsbFxuXG4gICAgaWYoIF9fdmFsdWVzLnR5cGUgPT09ICdnZW4nICkge1xuICAgICAgX192YWx1ZXMgPSBfX3ZhbHVlcy5yZW5kZXIoKVxuICAgIH1cblxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBfX3ZhbHVlcyApICYmIF9fdmFsdWVzLmxlbmd0aCA8PSAwICkgdGhyb3cgRXJyb3IoJ2FycmF5cyBwYXNzZWQgdG8gc2VxdWVuY2VzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgdmFsdWUgaW5zaWRlIG9mIHRoZW0nKVxuICAgIC8vIGNvbnZlcnQgdG8gcGF0dGVybiBpZiBuZWVkZWQgYW5kIHJlbmRlclxuICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoIF9fdmFsdWVzICkgXG4gICAgICA/IEdpYmJlci5QYXR0ZXJuKCAuLi5fX3ZhbHVlcyApLnJlbmRlcigpXG4gICAgICA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBfX3ZhbHVlcy5pc1BhdHRlcm4gXG4gICAgICAgID8gX192YWx1ZXMucmVuZGVyKClcbiAgICAgICAgOiBfX3ZhbHVlcy5yZXF1aXJlc1JlbmRlciBcbiAgICAgICAgICA/IF9fdmFsdWVzXG4gICAgICAgICAgOiBHaWJiZXIuUGF0dGVybiggX192YWx1ZXMgKS5yZW5kZXIoKVxuXG4gICAgLy8gaWYgYW4gYXJyYXkgb2YgdmFsdWVzIGlzIHBhc3NlZCwgbGV0IHVzZXJzIGNhbGwgcGF0dGVybiBtZXRob2Qgb24gdGhhdCBhcnJheSwgZm9yIGV4YW1wbGU6XG4gICAgLy8gYS5ub3RlLnNlcSggYj1bMCwxLDIsM10sIDEvNCApXG4gICAgLy8gYi50cmFuc3Bvc2Uuc2VxKCAxLDEgKVxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBfX3ZhbHVlcyApICkge1xuICAgICAgT2JqZWN0LmFzc2lnbiggX192YWx1ZXMsIHZhbHVlcyApXG4gICAgICBfX3ZhbHVlcy5hZGRGaWx0ZXIgPSB2YWx1ZXMuYWRkRmlsdGVyLmJpbmQoIHZhbHVlcyApXG4gICAgICBfX3ZhbHVlcy5yZW1vdmVGaWx0ZXIgPSB2YWx1ZXMucmVtb3ZlRmlsdGVyLmJpbmQoIHZhbHVlcyApXG4gICAgICBfX3ZhbHVlcy5pbnNwZWN0ID0gdmFsdWVzLmluc3BlY3QuYmluZCggdmFsdWVzIClcbiAgICB9IGVsc2UgaWYoIHR5cGVvZiBfX3ZhbHVlcyA9PT0gJ29iamVjdCcgJiYgX192YWx1ZXMudHlwZT09PSdnZW4nICkge1xuICAgICAgcHJvcHMudmFsdWVzLmFkZEZpbHRlciA9IHZhbHVlcy5hZGRGaWx0ZXIuYmluZCggdmFsdWVzIClcbiAgICAgIHByb3BzLnZhbHVlcy5yZW1vdmVGaWx0ZXIgPSB2YWx1ZXMucmVtb3ZlRmlsdGVyLmJpbmQoIHZhbHVlcyApXG4gICAgICBwcm9wcy52YWx1ZXMuaW5zcGVjdCA9IHZhbHVlcy5pbnNwZWN0LmJpbmQoIHZhbHVlcyApXG4gICAgfVxuXG4gICAgLy8gcHJvY2VzcyB0aW1lIHZhbHVlc1xuICAgIGlmKCB0YXJnZXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlmKCBHaWJiZXJbIHJlbmRlciBdLnRpbWVQcm9wc1sgdGFyZ2V0Lm5hbWUgXSAhPT0gdW5kZWZpbmVkIFxuICAgICAgICAmJiBHaWJiZXJbIHJlbmRlciBdLnRpbWVQcm9wc1sgdGFyZ2V0Lm5hbWUgXS5pbmRleE9mKCBrZXkgKSAhPT0gLTEgICkge1xuXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHJlbmRlciA9PT0gJ0F1ZGlvJyBcbiAgICAgICAgICA/IChhcmdzLHB0cm4pID0+IHtcbiAgICAgICAgICAgICAgYXJnc1swXSA9IEdpYmJlcmlzaC5DbG9jay50aW1lKCBhcmdzWzBdIClcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IChhcmdzLHB0cm4pID0+IHtcbiAgICAgICAgICAgICAgYXJnc1swXSA9IEdpYmJlci5BdWRpby5DbG9jay50aW1lKCBhcmdzWzBdIClcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMuYWRkRmlsdGVyKCBmaWx0ZXIgKVxuICAgICAgfVxuICAgIH1cbiBcbiAgICBjb25zdCB0aW1pbmdzID0gQXJyYXkuaXNBcnJheSggX190aW1pbmdzICkgXG4gICAgICA/IEdpYmJlci5QYXR0ZXJuKCAuLi5fX3RpbWluZ3MgKS5yZW5kZXIoKVxuICAgICAgOiB0eXBlb2YgX190aW1pbmdzID09PSAnZnVuY3Rpb24nICYmIF9fdGltaW5ncy5pc1BhdHRlcm4gXG4gICAgICAgID8gX190aW1pbmdzLnJlbmRlcigpXG4gICAgICAgIDogX190aW1pbmdzID09PSB1bmRlZmluZWQgfHwgX190aW1pbmdzID09PSBudWxsIFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogX190aW1pbmdzLnJlcXVpcmVzUmVuZGVyXG4gICAgICAgICAgICA/IF9fdGltaW5nc1xuICAgICAgICAgICAgOiBHaWJiZXIuUGF0dGVybiggX190aW1pbmdzICkucmVuZGVyKClcblxuXG4gICAgaWYoIHRpbWluZ3MgPT09IG51bGwgKSBhdXRvdHJpZyA9IHRydWVcblxuICAgIGlmKCBBcnJheS5pc0FycmF5KCBfX3RpbWluZ3MgKSApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oIF9fdGltaW5ncywgdGltaW5ncyApXG4gICAgICBfX3RpbWluZ3MuYWRkRmlsdGVyID0gdGltaW5ncy5hZGRGaWx0ZXIuYmluZCggdGltaW5ncyApXG4gICAgfVxuICAgIGlmKCBhdXRvdHJpZyA9PT0gZmFsc2UgKSB7XG4gICAgICB0aW1pbmdzLm91dHB1dCA9IHsgdGltZTondGltZScsIHNob3VsZEV4ZWN1dGU6MCB9XG4gICAgICB0aW1pbmdzLmRlbnNpdHkgPSAxXG5cbiAgICAgIC8vIFhYWCBkZWxheSBhbm5vdGF0aW9ucyBzbyB0aGF0IHRoZXkgb2NjdXIgYWZ0ZXIgdmFsdWVzIGFubm90YXRpb25zIGhhdmUgb2NjdXJyZWQuIFRoZXJlIG1pZ2h0XG4gICAgICAvLyBuZWVkIHRvIGJlIG1vcmUgY2hlY2tzIGZvciB0aGlzIGZsYWcgaW4gdGhlIHZhcmlvdXMgYW5ub3RhdGlvbiB1cGRhdGUgZmlsZXMuLi4gcmlnaHQgbm93XG4gICAgICAvLyB0aGUgY2hlY2sgaXMgb25seSBpbiBjcmVhdGVCb3JkZXJDeWNsZS5qcy5cbiAgICAgIHRpbWluZ3MuX19kZWxheUFubm90YXRpb25zID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGlmIGFuIGFycmF5IGlzIHBhc3NlZCB0byB0aGUgc2VxLCBlbmFibGUgdXNlcnMgdG8gY2FsbCBwYXR0ZXJuIG1ldGhvZHMgb24gYXJyYXlcbiAgICAvL2lmKCBBcnJheS5pc0FycmF5KCBfX3RpbWluZ3MgKSApIE9iamVjdC5hc3NpZ24oIF9fdGltaW5ncywgdGltaW5ncyApXG5cbiAgICBjb25zdCBjbGVhciA9IHJlbmRlciA9PT0gJ0F1ZGlvJ1xuICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB0aGlzLnZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVzLmNsZWFyICE9PSB1bmRlZmluZWQgICkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuY2xlYXIoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggdGhpcy50aW1pbmdzICE9PSB1bmRlZmluZWQgJiYgdGhpcy50aW1pbmdzICE9PSBudWxsICYmIHRoaXMudGltaW5ncy5jbGVhciAhPT0gdW5kZWZpbmVkICkgdGhpcy50aW1pbmdzLmNsZWFyKClcblxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gU2VxLnNlcXVlbmNlcnMuaW5kZXhPZiggc2VxIClcbiAgICAgICAgICAgIHNlcS5zdG9wKClcbiAgICAgICAgICAgIGNvbnN0IF9fc2VxID0gU2VxLnNlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVswXVxuICAgICAgICAgICAgaWYoIF9fc2VxICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIF9fc2VxLnN0b3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB0aGlzLnZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVzLmNsZWFyICE9PSB1bmRlZmluZWQgICkgdGhpcy52YWx1ZXMuY2xlYXIoKVxuICAgICAgICAgIGlmKCB0aGlzLnRpbWluZ3MgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRpbWluZ3MgIT09IG51bGwgJiYgdGhpcy50aW1pbmdzLmNsZWFyICE9PSB1bmRlZmluZWQgKSB0aGlzLnRpbWluZ3MuY2xlYXIoKVxuXG4gICAgICAgICAgY29uc3QgaWR4ID0gU2VxLnNlcXVlbmNlcnMuaW5kZXhPZiggc2VxIClcbiAgICAgICAgICBjb25zdCBfX3NlcSA9IFNlcS5zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClbMF1cbiAgICAgICAgICBpZiggX19zZXEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIF9fc2VxLnN0b3AoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgdmFsdWVzLl9fcGF0dGVyblR5cGUgPSAndmFsdWVzJ1xuICAgIGlmKCB0aW1pbmdzICE9PSBudWxsICkgdGltaW5ncy5fX3BhdHRlcm5UeXBlID0gJ3RpbWluZ3MnXG5cbiAgICAvL2NvbnN0IG9mZnNldFJhdGUgPSBHaWJiZXJpc2guYmlub3BzLk11bChyYXRlLCBHaWJiZXIuQ2xvY2suQXVkaW9DbG9jayApXG5cbiAgICAvLyBYWFggbmVlZCB0byBmaXggc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSBjbG9jayByYXRlIGFzIHRoZSBiYXNlXG4gICAgLy8gWFhYIG5lZWQgdG8gYWJzdHJhY3QgdGhpcyBzbyB0aGF0IGEgZ3JhcGhpY3Mgc2VxdWVuY2VyIGNvdWxkIGFsc28gYmUgY2FsbGVkLi4uXG4gICAgY29uc3Qgc2VxID0gR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5TZXF1ZW5jZXIoeyB2YWx1ZXMsIHRpbWluZ3MsIGRlbnNpdHksIHRhcmdldCwga2V5LCBwcmlvcml0eSwgcmF0ZToxLypHaWJiZXIuQ2xvY2suQXVkaW9DbG9jayovLCBjbGVhciwgYXV0b3RyaWcsIG1haW50aHJlYWRvbmx5OnByb3BzLm1haW50aHJlYWRvbmx5IH0pXG5cbiAgICBpZiggdmFsdWVzLnNldFNlcSApIHZhbHVlcy5zZXRTZXEoIHNlcSApXG5cbiAgICBhZGRWYWx1ZXNGaWx0ZXJzKCBzZXEsa2V5IClcblxuICAgIGlmKCBhdXRvdHJpZyA9PT0gZmFsc2UgKSB7XG4gICAgICBhZGRUaW1pbmdGaWx0ZXJzKCBzZXEsa2V5LHJlbmRlciApXG4gICAgICBpZiggdGltaW5ncy5zZXRTZXEgKSB0aW1pbmdzLnNldFNlcSggc2VxIClcbiAgICB9ZWxzZXtcbiAgICAgIGlmKCB0YXJnZXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaWYoIHRhcmdldC5hdXRvdHJpZyA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHRhcmdldC5hdXRvdHJpZyA9IFtdXG4gICAgICAgICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczoncHJvcGVydHknLFxuICAgICAgICAgICAgbmFtZTonYXV0b3RyaWcnLFxuICAgICAgICAgICAgdmFsdWU6W10sXG4gICAgICAgICAgICBvYmplY3Q6dGFyZ2V0LmlkXG4gICAgICAgICAgfSlcblxuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBuYW1lIGtleSB2YWx1ZVxuICAgICAgICBpZiggR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzczonYWRkT2JqZWN0VG9Qcm9wZXJ0eScsXG4gICAgICAgICAgICBuYW1lOidhdXRvdHJpZycsXG4gICAgICAgICAgICBvYmplY3Q6dGFyZ2V0LmlkLFxuICAgICAgICAgICAga2V5OnRhcmdldC5hdXRvdHJpZy5sZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZTpzZXEuaWRcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRhcmdldC5hdXRvdHJpZy5wdXNoKCBzZXEgKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3lvdSBtdXN0IGRlZmluZSB0aW1pbmdzIGZvciBhbnkgc2VxdWVuY2Ugd2l0aG91dCBhIHRhcmdldCcpXG4gICAgICB9XG4gICAgfSBcblxuICAgIC8vR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IGZhbHNlXG4gICAgLy9HaWJiZXIuVWdlbi5jcmVhdGVQcm9wZXJ0eSggc2VxLCAnZGVuc2l0eScsIHRpbWluZ3MsIFtdLCBHaWJiZXIgKVxuICAgIC8vR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IHRydWVcblxuICAgIFNlcS5zZXF1ZW5jZXJzLnB1c2goIHNlcSApXG5cbiAgICAvLyBpZiB4Lnkuc2VxKCkgZXRjLiBcbiAgICAvLyBzdGFuZGFsb25lID09PSBmYWxzZSBpcyBtb3N0IGNvbW1vbiB1c2UgY2FzZVxuICAgIGlmKCBwcm9wcy5zdGFuZGFsb25lID09PSBmYWxzZSApIHsgXG4gICAgICAvLyByZXF1aXJlZCB0ZXJuYXJ5IGJlY2F1c2UgcGF0dGVybiBtZXRob2RzIGRvbid0IGhhdmUgX18gcHJlZml4IFxuICAgICAgY29uc3QgdGFyZ2V0UHJvcCA9IHRhcmdldFsgJ19fJyArIGtleSBdID09PSB1bmRlZmluZWQgXG4gICAgICAgID8gdGFyZ2V0WyBrZXkgXSBcbiAgICAgICAgOiB0YXJnZXRbICdfXycgKyBrZXkgXVxuICAgICAgXG4gICAgICBjb25zdCBwcmV2U2VxID0gdGFyZ2V0UHJvcC5zZXF1ZW5jZXJzWyBwcm9wcy5udW1iZXIgXSBcbiAgICAgIGlmKCBwcmV2U2VxICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICBwcmV2U2VxLmNsZWFyKCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gWFhYIHlvdSBoYXZlIHRvIGFkZCBhIG1ldGhvZCB0aGF0IGRvZXMgYWxsIHRoaXMgc2hpdCBvbiB0aGUgd29ya2xldC4gY3JhcC5cbiAgICAgIHRhcmdldFByb3Auc2VxdWVuY2Vyc1sgcHJvcHMubnVtYmVyIF0gPSBzZXFcbiAgICAgIHRhcmdldFByb3BbIHByb3BzLm51bWJlciBdID0gc2VxIFxuICAgICAgLy90YXJnZXQuX19zZXF1ZW5jZXJzLnB1c2goIHNlcSApXG4gICAgICBpZiggdHlwZW9mIGRlbGF5ICE9PSAnZnVuY3Rpb24nICkgeyBcbiAgICAgICAgc2VxLnN0YXJ0KCBHaWJiZXIuQXVkaW8uQ2xvY2sudGltZSggZGVsYXkgKSApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxheS5zZXFzLnB1c2goIHNlcSApXG4gICAgICB9XG4gICAgfVxuXG4gICAgR2liYmVyLnB1Ymxpc2goICduZXcgc2VxdWVuY2UnLCBzZXEgKVxuXG4gICAgcmV0dXJuIHNlcVxuICB9XG5cbiAgU2VxLnNlcXVlbmNlcnMgPSBbXVxuICBTZXEuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBTZXEuc2VxdWVuY2Vycy5mb3JFYWNoKCBzZXEgPT4gc2VxLmNsZWFyKCkgKVxuICAgIC8vZm9yKCBsZXQgaSA9IFNlcS5zZXF1ZW5jZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgIC8vICBTZXEuc2VxdWVuY2Vyc1sgaSBdLmNsZWFyKClcbiAgICAvL31cbiAgICBTZXEuc2VxdWVuY2VycyA9IFtdXG4gIH1cbiAgU2VxLkROUiA9IC05ODc2NTQzMjFcblxuICByZXR1cm4gU2VxXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcbiBcbmNvbnN0IFN0ZXBzID0ge1xuICB0eXBlOidTdGVwcycsXG4gIGNyZWF0ZSggX3N0ZXBzLCB0YXJnZXQgKSB7XG4gICAgY29uc3Qgc3RlcHNlcSA9IE9iamVjdC5jcmVhdGUoIFN0ZXBzIClcbiAgICBcbiAgICBzdGVwc2VxLnNlcXMgPSB7fVxuXG4gICAgZm9yKCBsZXQgX2tleSBpbiBfc3RlcHMgKSB7XG4gICAgICBsZXQgdmFsdWVzID0gX3N0ZXBzWyBfa2V5IF1cbiAgICAgIGNvbnN0IHBhcnNlZEtleSA9IHBhcnNlSW50KCBfa2V5IClcbiAgICAgIGNvbnN0IGtleSA9IGlzTmFOKCBwYXJzZWRLZXkgKSA/IF9rZXkgOiBwYXJzZWRLZXlcblxuICAgICAgbGV0IHVzZXNTdHJpbmdWYWx1ZXMgPSBmYWxzZVxuICAgICAgaWYoIHZhbHVlcy5pc1BhdHRlcm4gIT09IHRydWUgKSB7XG4gICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB2YWx1ZXMgKSApIHtcbiAgICAgICAgICB2YWx1ZXMgPSBHaWJiZXIuUGF0dGVybiggLi4udmFsdWVzIClcbiAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zcGxpdCgnJylcbiAgICAgICAgICB1c2VzU3RyaW5nVmFsdWVzID0gdHJ1ZVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB2YWx1ZXMgPSBHaWJiZXIuUGF0dGVybiggdmFsdWVzIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXEgPSBHaWJiZXIuU2VxKHtcbiAgICAgICAgdmFsdWVzOiB1c2VzU3RyaW5nVmFsdWVzID8gdmFsdWVzIDoga2V5LFxuICAgICAgICB0aW1pbmdzOiB1c2VzU3RyaW5nVmFsdWVzID8gIFsgMSAgLyB2YWx1ZXMubGVuZ3RoIF0gOiB2YWx1ZXMsXG4gICAgICAgICdrZXknOiB0YXJnZXQuX19pc0Vuc2VtYmxlICE9PSB0cnVlID8gJ25vdGUnIDogJ3RyaWdnZXInLCBcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQuX19pc0Vuc2VtYmxlID8gdGFyZ2V0WyB0YXJnZXRbIGtleSBdLm5hbWUgXSA6IHRhcmdldCwgXG4gICAgICAgIHByaW9yaXR5OjBcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG9ubHlVc2VzVmVsb2NpdHkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJ1xuXG5cbiAgICAgIGlmKCB1c2VzU3RyaW5nVmFsdWVzICkge1xuICAgICAgICBzZXEudmFsdWVzLmFkZEZpbHRlciggbmV3IEZ1bmN0aW9uKCAnYXJncycsICdwdHJuJywgXG4gICAgICAgICBgbGV0IHN5bSA9IGFyZ3NbIDAgXSxcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSBwYXJzZUludCggc3ltLCAxNiApIC8gMTVcblxuICAgICAgICAgIGlmKCBpc05hTiggdmVsb2NpdHkgKSApIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gc3ltID09PSAneCcgXG4gICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICA6IHN5bSA9PT0gJ1gnXG4gICAgICAgICAgICAgICAgPyAxLjVcbiAgICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZ2V0IGFjY2VzcyB0byBiZWF0LCBiZWF0T2Zmc2V0IGFuZCBzY2hlZHVsZXI/XG4gICAgICAgICAgaWYoIHZlbG9jaXR5ICE9PSAwICkge1xuICAgICAgICAgICAgJHsgb25seVVzZXNWZWxvY2l0eSA/ICcnIDoncHRybi5zZXEudGFyZ2V0Ll9fdHJpZ2dlckxvdWRuZXNzID0gdmVsb2NpdHknIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcmdzWyAwIF0gPSBzeW0gPT09ICcuJyA/IC05ODc2NTQzMjEgOiAke3R5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gJ3ZlbG9jaXR5JyA6IGtleSB9XG5cbiAgICAgICAgICByZXR1cm4gYXJnc1xuICAgICAgICBgKSApXG4gICAgICB9XG5cbiAgICAgIHN0ZXBzZXEuc2Vxc1sgX2tleSBdID0gc2VxXG4gICAgICBzdGVwc2VxWyBfa2V5IF0gPSB1c2VzU3RyaW5nVmFsdWVzID8gc2VxLnZhbHVlcyA6IHNlcS50aW1pbmdzXG4gICAgfVxuXG4gICAgc3RlcHNlcS5zdGFydCgpXG4gICAgc3RlcHNlcS5hZGRQYXR0ZXJuTWV0aG9kcygpXG5cbiAgICByZXR1cm4gc3RlcHNlcVxuICB9LFxuICBcbiAgLyogdHdvIHBhcnRzOlxuICAgKiAxLiBUaGUgZWFzeSBwYXJ0LCBtYWtlIG1ldGhvZHMgdGhhdCBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIG1haW4gdGhyZWFkXG4gICAqICAgIGFuZCBydW4gb3ZlciBldmVyeSBzZXEgaW5zdGFuY2UgaW4gdGhlIHN0ZXAgc2VxdWVuY2VyXG4gICAqIDIuIFRoZSBoYXJkIHBhcnQsIG1ha2UgYW4gb2JqZWN0IHRoYXQgbGl2ZXMgaW4gdGhlIGF1ZGlvIHRocmVhZFxuICAgKiAgICBhbmQgY2FuIGJlIHNlcXVlbmNlZC4gSXQgbmVlZHMgcmVmZXJlbmNlcyB0byBhbGwgc2VxdWVuY2VycyBpbiB0aGUgXG4gICAqICAgIHN0ZXAgc2VxdWVuY2VyLlxuICAgKi9cbiAgYWRkUGF0dGVybk1ldGhvZHMoKSB7XG4gICAgLy8gWFhYIHNob3VsZG4ndCB1c2UgYXVkaW8gaWQgYnkgZGVmYXVsdC4uLiBzaWdoXG4gICAgY29uc3QgaWQgPSBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgLy8gc3RvcmUgaWRzIG9mIGFsbCBjb250cm9sbGVkIHNlcXVlbmNlcnNcbiAgICBjb25zdCBzZXFJZHMgPSBbXVxuICAgIGZvciggbGV0IGtleSBpbiB0aGlzLnNlcXMgKSB7XG4gICAgICBzZXFJZHMucHVzaCggdGhpcy5zZXFzWyBrZXkgXS5pZCApXG4gICAgfVxuXG4gICAgLy8gdGhpcyBvYmplY3Qgd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBhdWRpbyB0aHJlYWRcbiAgICBjb25zdCBvYmogPSB7IGlkLCBzZXFJZHMgfVxuXG4gICAgZ3JvdXBNZXRob2ROYW1lcy5mb3JFYWNoKCBuYW1lID0+IHtcbiAgICAgIC8vIEVBU1kgUEFSVCBcbiAgICAgIHRoaXNbIG5hbWUgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkgeyBcbiAgICAgICAgZm9yKCBsZXQga2V5IGluIHRoaXMuc2VxcyApIHsgXG4gICAgICAgICAgdGhpcy5zZXFzWyBrZXkgXS52YWx1ZXNbIG5hbWUgXS5hcHBseSggdGhpcywgYXJncyApIFxuICAgICAgICB9IFxuICAgICAgfVxuXG4gICAgICB0aGlzWyBuYW1lIF0uc2VxdWVuY2VycyA9IFtdXG4gICAgICB0aGlzWyBuYW1lIF0uc2VxID0gKCB2YWx1ZXMsIHRpbWluZ3MsIG51bWJlciA9IDAsIGRlbGF5ID0gMCApID0+IHtcbiAgICAgICAgY29uc3QgcyA9IEdpYmJlci5TZXEoeyBcbiAgICAgICAgICB2YWx1ZXMsIFxuICAgICAgICAgIHRpbWluZ3MsIFxuICAgICAgICAgIHRhcmdldDp0aGlzLl9fd3JhcHBlZCxcbiAgICAgICAgICBrZXk6bmFtZSxcbiAgICAgICAgICBwcmlvcml0eToxLFxuICAgICAgICB9KS5zdGFydCgpXG4gICAgICAgIFxuICAgICAgICB0aGlzWyBuYW1lIF0uc2VxdWVuY2Vycy5wdXNoKCBzIClcblxuICAgICAgICAvLyBuZWVkZWQgZm9yIGFubm90YXRpb25zXG4gICAgICAgIHRoaXNbIG5hbWUgXVsgbnVtYmVyIF0gPSBzXG5cbiAgICAgICAgcmV0dXJuIHRoaXMgXG4gICAgICB9IFxuXG4gICAgICAvLyBzdG9yZSBmdW5jdGlvbiBib2R5IHRvIGNyZWF0ZSBmdW5jdGlvbiBpbiBhdWRpbyB0aHJlYWQgcmVwcmVzZW50YXRpb24gb2Ygc3RlcHNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIG9uZSBsaW5lIGZvciBzdHJpbmdpZnkgLyBwYXJzaW5nXG4gICAgICAvLyBYWFggdWdoIGFyZ3VtZW50cz8gaXMgdGhlcmUgZXZlciBtb3JlIHRoYW4gb25lIGFyZ3VtZW50P1xuICAgICAgb2JqWyBuYW1lIF0gPSBgZm9yKCBsZXQgc2VxIG9mIHRoaXMuc2VxcyApIHsgc2VxLnZhbHVlcy4ke25hbWV9LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTsgc2VxLnRpbWluZ3MuJHtuYW1lfS5hcHBseSggdGhpcywgYXJndW1lbnRzICl9YFxuICAgIH0pXG5cbiAgICAvLyBIQVJEIFBBUlRcbiAgICAvLyBjb2RlIHRvIGJlIGV2YWx1YXRlZCBpbiBhdWRpbyB0aHJlYWRcbiAgICAvLyAxLiBjcmVhdGUgYSBuZXcgb2JqZWN0LCBzdGVwcywgYmFzc2VkIG9uIHN0cmluZ2lmeWluZyBvYmpcbiAgICAvLyAyLiBhZGQgYWxsIG9mIHRoZSB0cmFuc2Zvcm0gbWV0aG9kc1xuICAgIC8vIDMuIHN0b3JlIGFsbCBjb250cm9sbGVkIHNlcXVlbmNlcnMgaW4gc3RlcHMuc2VxcyBhZnRlciBnZXR0aW5nIHJlZmVyZW5jZXNcbiAgICAvLyAgICBmcm9tIEdpYmJlcmlzaC51Z2VucyBcbiAgICBjb25zdCBjb2RlID0gYGNvbnN0IHN0ZXBzID0gSlNPTi5wYXJzZSggXFxgJHtKU09OLnN0cmluZ2lmeShvYmopfVxcYCApXG4gICAgICBjb25zdCBtZXRob2RzID0gJHtKU09OLnN0cmluZ2lmeSggZ3JvdXBNZXRob2ROYW1lcyApIH1cbiAgICAgIHN0ZXBzLnNlcXMgPSBzdGVwcy5zZXFJZHMubWFwKCBpZCA9PiBHaWJiZXJpc2gudWdlbnMuZ2V0KCBpZCApIClcbiAgICAgIGZvciggbGV0IG1ldGhvZCBvZiBtZXRob2RzICkge1xuICAgICAgICBzdGVwc1sgbWV0aG9kIF0gPSBuZXcgRnVuY3Rpb24oIHN0ZXBzWyBtZXRob2QgXSApIFxuICAgICAgfVxuICAgICAgR2liYmVyaXNoLnVnZW5zLnNldCggc3RlcHMuaWQsIHN0ZXBzIClgXG4gXG4gICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgYWRkcmVzczonZXZhbCcsXG4gICAgICBjb2RlXG4gICAgfSkgXG5cbiAgICB0aGlzLl9fd3JhcHBlZCA9IG9ialxuICB9LFxuXG4gIHN0YXJ0KCkge1xuICAgIGZvciggbGV0IGtleSBpbiB0aGlzLnNlcXMgKSB7IFxuICAgICAgdGhpcy5zZXFzWyBrZXkgXS5zdGFydCgpXG4gICAgfVxuICB9LFxuXG4gIHN0b3AoKSB7XG4gICAgZm9yKCBsZXQga2V5IGluIHRoaXMuc2VxcyApIHsgXG4gICAgICB0aGlzLnNlcXNbIGtleSBdLnN0b3AoKVxuICAgIH1cbiAgfSxcblxuICBjbGVhcigpIHsgXG4gICAgdGhpcy5zdG9wKCkgXG5cbiAgICBmb3IoIGxldCBrZXkgaW4gdGhpcy5zZXFzICkge1xuICAgICAgdGhpcy5zZXFzWyBrZXkgXS50aW1pbmdzLmNsZWFyKClcbiAgICB9XG4gIH1cblxufVxuXG5jb25zdCBncm91cE1ldGhvZE5hbWVzID0gWyBcbiAgJ3JvdGF0ZScsICdyZXZlcnNlJywgJ3RyYW5zcG9zZScsICdyYW5nZScsXG4gICdzaHVmZmxlJywgJ3NjYWxlJywgJ3JlcGVhdCcsICdzdG9yZScsIFxuICAncmVzZXQnLCdmbGlwJywgJ2ludmVydCcsICdzZXQnLCAnZG91YmxlJ1xuXVxuXG5yZXR1cm4gU3RlcHMuY3JlYXRlXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlciApIHtcblxuICBjb25zdCBTZXEgPSBmdW5jdGlvbiggcHJvcHMgKSB7IFxuICAgIGNvbnN0IHBhdHRlcm4gICA9IHByb3BzLnBhdHRlcm5cbiAgICBjb25zdCB0YXJnZXQgICAgPSBwcm9wcy50YXJnZXRcbiAgICBjb25zdCBrZXkgICAgICAgPSBwcm9wcy5rZXlcbiAgICBjb25zdCBudW1iZXIgICAgPSBwcm9wcy5udW1iZXJcbiAgICBjb25zdCBkZWxheSAgICAgPSBwcm9wcy5kZWxheVxuICAgIGNvbnN0IHByaW9yaXR5ICA9IHByb3BzLnByaW9yaXR5IHx8IDBcbiAgICBsZXQgICByYXRlICAgICAgPSBwcm9wcy5yYXRlIHx8IDFcbiAgICBsZXQgICBkZW5zaXR5ICAgPSBwcm9wcy5kZW5zaXR5IHx8IDFcbiAgICBsZXQgICBhdXRvdHJpZyAgPSBmYWxzZVxuXG5cbiAgICBjb25zdCByZW5kZXIgICAgPSB0YXJnZXQudHlwZSAhPT0gdW5kZWZpbmVkID8gdGFyZ2V0LnR5cGUudG9Mb3dlckNhc2UoKSA6ICdhdWRpbydcbiAgICAvL2NvbnN0IEdpYmJlci5BdWRpby5HaWJiZXJpc2ggPSBHaWJiZXIuR2liYmVyLkF1ZGlvLkdpYmJlcmlzaCAhPT0gdW5kZWZpbmVkID8gR2liYmVyLkdpYmJlci5BdWRpby5HaWJiZXJpc2ggOiBudWxsXG5cbiAgICBjb25zdCBjbGVhciA9IHJlbmRlciA9PT0gJ2F1ZGlvJ1xuICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IFNlcS5zZXF1ZW5jZXJzLmluZGV4T2YoIHNlcSApXG4gICAgICAgICAgICBzZXEuc3RvcCgpXG4gICAgICAgICAgICBjb25zdCBfX3NlcSA9IFNlcS5zZXF1ZW5jZXJzLnNwbGljZSggaWR4LCAxIClbMF1cbiAgICAgICAgICAgIGlmKCBfX3NlcSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBfX3NlcS5zdG9wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBpZHggPSBTZXEuc2VxdWVuY2Vycy5pbmRleE9mKCBzZXEgKVxuICAgICAgICAgIGNvbnN0IF9fc2VxID0gU2VxLnNlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVswXVxuICAgICAgICAgIGlmKCBfX3NlcSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgX19zZXEuc3RvcCgpXG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY29uc3QgZmlsdGVycyA9IFtcbiAgICAgIC8vIHJlcG9ydCBiYWNrIHRyaWdnZXJlZCB0b2tlbnMgZm9yIGFubm90YXRpb25zXG4gICAgICBmdW5jdGlvbiggdmFsLCB0aWRhbCwgdWlkICkge1xuICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggdGlkYWwuaWQsICd1cGRhdGUudWlkJywgdWlkICkgICBcbiAgICAgICAgICBHaWJiZXJpc2gucHJvY2Vzc29yLm1lc3NhZ2VzLnB1c2goIHRpZGFsLmlkLCAndXBkYXRlLnZhbHVlJywgdmFsICkgICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsXG4gICAgICB9IFxuICAgIF1cblxuICAgIGlmKCBrZXkgPT09ICdub3RlJyB8fCBrZXkgPT09ICdjaG9yZCcgfHwga2V5ID09PSAndHJpZ2dlcicgKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goICggYXJncyx0aWRhbCApID0+IHtcbiAgICAgICAgaWYoIHRpZGFsLnRhcmdldC5hdXRvdHJpZyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIGZvciggbGV0IHMgb2YgdGlkYWwudGFyZ2V0LmF1dG90cmlnICkge1xuICAgICAgICAgICAgcy5maXJlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGV0IHBcbiAgICB0cnkge1xuICAgICAgcCA9IEdpYmJlci5BdWRpby5HaWJiZXJpc2guVGlkYWwuUGF0dGVybiggcGF0dGVybiApIFxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgR2liYmVyLnB1Ymxpc2goICdlcnJvcicsIGBcXG5Zb3VyIFRpZGFsIHBhdHRlcm4gJHtwYXR0ZXJufSB1c2VkIGludmFsaWQgc3ludGF4LlxcbmAgKVxuICAgICAgLy9jb25zb2xlLmxvZyhgJWNcXG5Zb3VyIFRpZGFsIHBhdHRlcm4gJHtwYXR0ZXJufSB1c2VkIGludmFsaWQgc3ludGF4LlxcbmAsIGBjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kOiM5MDBgIClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYoIGtleSAhPT0gJ2RlZ3JlZScgKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbLi4ucGF0dGVybi5tYXRjaEFsbCgvW2EtekEtWl0rL2cpXS5tYXAoIHY9PnZbMF0gKVxuICAgICAgbGV0IHRva2VuTm90Rm91bmQgPSBmYWxzZVxuICAgICAgdG9rZW5zLmZvckVhY2goIHQgPT4ge1xuICAgICAgICBpZiggdGFyZ2V0WyB0IF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAvL2NvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgLy8gIGAlY1xcbllvdXIgVGlkYWwgcGF0dGVybiBpcyB1c2luZyBhIHRva2VuICgke3R9KSB0aGF0IGNhbid0IGJlIGZvdW5kIG9uIHRoZSB0YXJnZXRlZCBpbnN0cnVtZW50LmAsIFxuICAgICAgICAgIC8vICBgY29sb3I6d2hpdGU7YmFja2dyb3VuZDojOTAwYCBcbiAgICAgICAgICAvLyAgKSBcbiAgICAgICAgICBcbiAgICAgICAgICBHaWJiZXIucHVibGlzaCggJ2Vycm9yJywgYFxcbllvdXIgVGlkYWwgcGF0dGVybiBpcyB1c2luZyBhIHRva2VuICgke3R9KSB0aGF0IGNhbid0IGJlIGZvdW5kIG9uIHRoZSB0YXJnZXRlZCBpbnN0cnVtZW50LlxcbmAgKVxuICAgICAgICAgIHRva2VuTm90Rm91bmQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmKCB0b2tlbk5vdEZvdW5kID09PSB0cnVlICkgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBzZXEgPSBHaWJiZXIuQXVkaW8uR2liYmVyaXNoLlRpZGFsKHsgcGF0dGVybiwgdGFyZ2V0LCBrZXksIHByaW9yaXR5LCBmaWx0ZXJzLCBtYWludGhyZWFkb25seTpwcm9wcy5tYWludGhyZWFkb25seSB9KVxuICAgIHNlcS5jbGVhciA9IGNsZWFyXG4gICAgc2VxLnVpZCA9IEdpYmJlci5BdWRpby5HaWJiZXJpc2guVGlkYWwuZ2V0VUlEKClcbiAgICBcbiAgICAvL0dpYmJlci5BdWRpby5HaWJiZXJpc2gucHJveHlFbmFibGVkID0gZmFsc2VcbiAgICAvL0F1ZGlvLlVnZW4uY3JlYXRlUHJvcGVydHkoIHNlcSwgJ2RlbnNpdHknLCB0aW1pbmdzLCBbXSwgQXVkaW8gKVxuICAgIC8vR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0cnVlXG5cbiAgICBHaWJiZXIuYWRkU2VxdWVuY2luZyggc2VxLCAncm90YXRlJywgMSApXG5cbiAgICBTZXEuc2VxdWVuY2Vycy5wdXNoKCBzZXEgKVxuXG4gICAgR2liYmVyLnN1YnNjcmliZSggJ2NsZWFyJywgKCk9PiBzZXEuY2xlYXIoKSApXG5cbiAgICAvLyBpZiB4LnkudGlkYWwoKSBldGMuIFxuICAgIC8vIHN0YW5kYWxvbmUgPT09IGZhbHNlIGlzIG1vc3QgY29tbW9uIHVzZSBjYXNlXG4gICAgaWYoIHByb3BzLnN0YW5kYWxvbmUgPT09IGZhbHNlICkge1xuICAgICAgbGV0IHByZXZTZXEgPSB0YXJnZXRbICdfXycgKyBrZXkgXS50aWRhbHNbIG51bWJlciBdIFxuICAgICAgaWYoIHByZXZTZXEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaWYoIHRhcmdldC5fX3NlcXVlbmNlcnMgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQuX19zZXF1ZW5jZXJzLmluZGV4T2YoIHByZXZTZXEgKVxuICAgICAgICAgIHRhcmdldC5fX3NlcXVlbmNlcnMuc3BsaWNlKCBpZHgsIDEgKVxuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBzdG9wKCkgZGVzdHJveXMgYW4gZXh0cmEgc2VxdWVuY2VyIGZvciBzb21lIHJlYXNvbj8/Pz9cbiAgICAgICAgcHJldlNlcS5zdG9wKClcbiAgICAgICAgcHJldlNlcS5jbGVhcigpXG4gICAgICAgIC8vcmVtb3ZlU2VxKCBvYmosIHByZXZTZXEgKVxuICAgICAgfVxuXG4gICAgICBzZXEuc3RhcnQoIEdpYmJlci5BdWRpby5DbG9jay50aW1lKCBkZWxheSApIClcblxuICAgICAgdGFyZ2V0WyAnX18nICsga2V5IF0udGlkYWxzWyBudW1iZXIgXSA9IHRhcmdldFsgJ19fJyArIGtleSBdWyBudW1iZXIgXSA9IHNlcVxuICAgIH1cblxuICAgIEdpYmJlci5wdWJsaXNoKCAnbmV3IHRpZGFsJywgc2VxIClcbiAgICByZXR1cm4gc2VxXG4gIH1cblxuICBTZXEuc2VxdWVuY2VycyA9IFtdXG4gIFNlcS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIFNlcS5zZXF1ZW5jZXJzLmZvckVhY2goIHNlcSA9PiBzZXEuY2xlYXIoKSApXG4gICAgLy9mb3IoIGxldCBpID0gU2VxLnNlcXVlbmNlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgLy8gIFNlcS5zZXF1ZW5jZXJzWyBpIF0uY2xlYXIoKVxuICAgIC8vfVxuICAgIFNlcS5zZXF1ZW5jZXJzID0gW11cbiAgfVxuICBTZXEuRE5SID0gLTk4NzY1NDMyMVxuXG4gIGxldCB2YWwgPSAxIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIFNlcSwgJ2NwcycsIHtcbiAgICBnZXQoKSB7IHJldHVybiB2YWwgfSxcbiAgICBzZXQodikge1xuICAgICAgdmFsID0gdlxuICAgICAgR2liYmVyLkF1ZGlvLkdpYmJlcmlzaC5UaWRhbC5jcHMgPSB2XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBTZXFcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyICkge1xuXG5jb25zdCBQYXR0ZXJuID0gR2liYmVyLlBhdHRlcm5cblxuY29uc3QgVHJpZ2dlcnMgPSBmdW5jdGlvbiggX192YWx1ZXMgKSB7XG4gIGNvbnN0IHZhbHVlcyA9IF9fdmFsdWVzLnNwbGl0KCcnKVxuICBjb25zdCBwYXR0ZXJuID0gUGF0dGVybiggLi4udmFsdWVzICkgXG4gIHBhdHRlcm4uaXNQYXR0ZXJuID0gdHJ1ZVxuICBwYXR0ZXJuLnR5cGUgPSAnVHJpZ2dlcnMnXG4gIC8vIG5lZWQgdG8gZGVmaW5lIGN1c3RvbSBmdW5jdGlvbiB0byB1c2Uga2V5IGFzIHZhbHVlXG4gIHBhdHRlcm4ub25yZW5kZXIgPSBmdW5jdGlvbiggcmVuZGVyZWQgKSB7XG4gICAgcmVuZGVyZWQuYWRkRmlsdGVyKCBuZXcgRnVuY3Rpb24oICdhcmdzJywgJ3B0cm4nLCBcbiAgICAgYGxldCBzeW0gPSBhcmdzWyAwIF0sXG4gICAgICAgICAgdmVsb2NpdHkgPSBwYXJzZUludCggc3ltLCAxNiApIC8gMTVcblxuICAgICAgaWYoIGlzTmFOKCB2ZWxvY2l0eSApICkge1xuICAgICAgICB2ZWxvY2l0eSA9IDBcbiAgICAgIH1cblxuICAgICAgaWYoIHZlbG9jaXR5ICE9PSAwICkge1xuICAgICAgICBwdHJuLnNlcS50YXJnZXQuX190cmlnZ2VyTG91ZG5lc3MgPSB2ZWxvY2l0eVxuICAgICAgfVxuXG4gICAgICBwdHJuLm91dHB1dCA9IHtcbiAgICAgICAgdGltZSA6IEdpYmJlcmlzaC5DbG9jay50aW1lKCAkezEvdmFsdWVzLmxlbmd0aH0gKSxcbiAgICAgICAgc2hvdWxkRXhlY3V0ZTogc3ltICE9PSAnLicgPyAxIDogMFxuICAgICAgfVxuXG4gICAgICBhcmdzWzBdID0gcHRybi5vdXRwdXRcblxuICAgICAgcmV0dXJuIGFyZ3NgXG4gICAgKSlcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuXG59XG5cbnJldHVybiBUcmlnZ2Vyc1xuXG59XG4iLCJsZXQgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApXG5cbmxldCBhbmFseXplciA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuXG5PYmplY3QuYXNzaWduKCBhbmFseXplciwge1xuICBfX3R5cGVfXzogJ2FuYWx5emVyJyxcbiAgcHJpb3JpdHk6MFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBhbmFseXplclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCB7IEluLCBPdXQsIFNTRCB9ID0gcmVxdWlyZSggJy4vc2luZ2xlc2FtcGxlZGVsYXkuanMnICApKCBHaWJiZXJpc2ggKVxuXG4gIGNvbnN0IGFuYWx5emVycyA9IHtcbiAgICBTU0QsXG4gICAgU1NEX0luOiBJbixcbiAgICBTU0RfT3V0OiBPdXQsIFxuICAgIEZvbGxvdzogcmVxdWlyZSggJy4vZm9sbG93LmRzcC5qcycgICkoIEdpYmJlcmlzaCApXG4gIH1cbiAgYW5hbHl6ZXJzLkZvbGxvd19vdXQgPSBhbmFseXplcnMuRm9sbG93Lm91dFxuICBhbmFseXplcnMuRm9sbG93X2luICA9IGFuYWx5emVycy5Gb2xsb3cuaW5cbiAgXG4gIGFuYWx5emVycy5leHBvcnQgPSB0YXJnZXQgPT4ge1xuICAgIGZvciggbGV0IGtleSBpbiBhbmFseXplcnMgKSB7XG4gICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyApIHtcbiAgICAgICAgdGFyZ2V0WyBrZXkgXSA9IGFuYWx5emVyc1sga2V5IF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYW5hbHl6ZXJzXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgYW5hbHl6ZXIgPSByZXF1aXJlKCAnLi9hbmFseXplci5qcycgKSxcbiAgICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBGb2xsb3cgPSBmdW5jdGlvbiggX19wcm9wcyApe1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIEZvbGxvdy5kZWZhdWx0cywgX19wcm9wcyApXG5cbiAgICBsZXQgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZVxuXG4gICAgbGV0IG91dCA9IHByb3BzIFxuXG4gICAgLyogaWYgd2UgYXJlIGluIHRoZSBtYWluIHRocmVhZCxcbiAgICAgKiBvbmx5IHNlbmQgYSBjb21tYW5kIHRvIG1ha2UgYSBGb2xsb3cgaW5zdGFuY2VcbiAgICAgKiB0byB0aGUgcHJvY2Vzc29yIHRocmVhZCBhbmQgaW5jbHVkZSB0aGUgaWQgI1xuICAgICAqIG9mIHRoZSBpbnB1dCB1Z2VuLlxuICAgICAqL1xuXG4gICAgLy9jb25zb2xlLmxvZyggJ2lzU3RlcmVvOicsIEdpYmJlcmlzaC5tb2RlLCBpc1N0ZXJlbywgcHJvcHMuaW5wdXQgKVxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgLy8gc2VuZCBvYmogdG8gYmUgbWFkZSBpbiBwcm9jZXNzb3IgdGhyZWFkXG4gICAgICBwcm9wcy5pbnB1dCA9IHsgaWQ6IHByb3BzLmlucHV0LmlkIH1cbiAgICAgIHByb3BzLmlzU3RlcmVvID0gaXNTdGVyZW9cblxuICAgICAgLy8gY3JlYXRlcyBjbGFzaGVzIGluIHByb2Nlc3NvciB0aHJlYWQgdW5sZXNzXG4gICAgICAvLyB3ZSBza2lwIGEgbnVtYmVyIGhlcmUuLi4gbmljZVxuICAgICAgR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgICBwcm9wcy5vdmVycmlkZWlkID0gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgICAvLyBYWFggc2VlbXMgbGlrZSB0aGlzIGlkIGdldHMgb3ZlcnJpZGRlbiBzb21ld2hlcmVcbiAgICAgIC8vIGhlbmNlIC5vdmVycmlkZWlkXG4gICAgICBwcm9wcy5pZCA9IHByb3BzLm92ZXJyaWRlaWRcblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGFkZHJlc3M6J2FkZCcsXG5cbiAgICAgICAgcHJvcGVydGllczpKU09OLnN0cmluZ2lmeSggcHJvcHMgKSxcblxuICAgICAgICBuYW1lOlsnYW5hbHlzaXMnLCdGb2xsb3cnXVxuICAgICAgfSlcblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuc2V0KCBwcm9wcy5vdmVycmlkZWlkLCBvdXQgKVxuXG4gICAgICBsZXQgbXVsdCA9IHByb3BzLm11bHRpcGxpZXJcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvdXQsICdtdWx0aXBsaWVyJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBtdWx0IH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICBtdWx0ID0gdlxuICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgIGFkZHJlc3M6J3NldCcsIFxuICAgICAgICAgICAgb2JqZWN0OnByb3BzLm92ZXJyaWRlaWQsXG4gICAgICAgICAgICBuYW1lOidtdWx0aXBsaWVyJyxcbiAgICAgICAgICAgIHZhbHVlOm11bHRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBsZXQgb2Zmc2V0ID0gcHJvcHMub2Zmc2V0XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG91dCwgJ29mZnNldCcsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gb2Zmc2V0IH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICBvZmZzZXQgPSB2XG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgICAgICAgYWRkcmVzczonc2V0JywgXG4gICAgICAgICAgICBvYmplY3Q6cHJvcHMub3ZlcnJpZGVpZCxcbiAgICAgICAgICAgIG5hbWU6J29mZnNldCcsXG4gICAgICAgICAgICB2YWx1ZTpvZmZzZXRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1lbHNle1xuICAgICAgLy9pc1N0ZXJlbyA9IHByb3BzLmlzU3RlcmVvXG5cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGcuZGF0YSggcHJvcHMuYnVmZmVyU2l6ZSwgMSApXG4gICAgICBjb25zdCBpbnB1dCAgPSBnLmluKCAnaW5wdXQnIClcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBnLmluKCAnbXVsdGlwbGllcicgKVxuICAgICAgY29uc3Qgb2Zmc2V0ICAgICA9IGcuaW4oICdvZmZzZXQnIClcbiAgICAgIFxuICAgICAgY29uc3QgZm9sbG93X291dCA9IE9iamVjdC5jcmVhdGUoIGFuYWx5emVyIClcbiAgICAgIGZvbGxvd19vdXQuaWQgPSBwcm9wcy5pZCA9IF9fcHJvcHMub3ZlcnJpZGVpZFxuXG4gICAgICBsZXQgYXZnID0gZy5kYXRhKCAxLDEsIHsgbWV0YTp0cnVlIH0gKSAvLyBvdXRwdXQ7IG1ha2UgYXZhaWxhYmxlIG91dHNpZGUganNkc3AgYmxvY2tcbiAgICAgIGNvbnN0IGlkeCA9IGF2Zy5tZW1vcnkudmFsdWVzLmlkeFxuICBcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24oIG1lbW9yeSApIHtcbiAgICAgICAgcmV0dXJuIGF2Z1swXVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXQgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBpbnB1dDpwcm9wcy5pbnB1dCxcbiAgICAgICAgaXNTdGVyZW8sXG4gICAgICAgIGRpcnR5OnRydWUsXG4gICAgICAgIGlucHV0TmFtZXM6WyAnaW5wdXQnLCAnbWVtb3J5JyBdLFxuICAgICAgICBpbnB1dHM6WyBwcm9wcy5pbnB1dCBdLFxuICAgICAgICBpZDogR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKSxcblxuICAgICAgICBfX3Byb3BlcnRpZXNfXzogeyBpbnB1dDpwcm9wcy5pbnB1dCB9LFxuICAgICAgfVxuXG4gICAgICAvLyBub25zZW5zZSB0byBtYWtlIG91ciBjdXN0b20gZnVuY3Rpb24gd29ya1xuICAgICAgb3V0LmNhbGxiYWNrLnVnZW5OYW1lID0gb3V0LnVnZW5OYW1lID0gYGZvbGxvd19vdXRfJHtmb2xsb3dfb3V0LmlkfWBcbiAgICAgIG91dC5pZCA9IF9fcHJvcHMub3ZlcnJpZGVpZFxuXG4gICAgICAvLyBiZWdpbiBpbnB1dCB0cmFja2VyXG4gICAgICBjb25zdCBmb2xsb3dfaW4gPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcblxuICAgICAgaWYoIGlzU3RlcmVvID09PSB0cnVlICkge1xuICAgICAgICBpZiggcHJvcHMub3V0cHV0U3RlcmVvID09PSBmYWxzZSApIHtcbiAgICAgICAgICB7IFxuICAgICAgICAgICAgXCJ1c2UganNkc3BcIlxuICAgICAgICAgICAgLy8gcGhhc2UgdG8gd3JpdGUgdG8gZm9sbG93IGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyUGhhc2VPdXQgPSBnLmFjY3VtKCAxLDAseyBtYXg6cHJvcHMuYnVmZmVyU2l6ZSwgbWluOjAgfSlcblxuICAgICAgICAgICAgLy8gaG9sZCBydW5uaW5nIHN1bVxuICAgICAgICAgICAgY29uc3Qgc3VtID0gZy5kYXRhKCAxLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuXG4gICAgICAgICAgICBjb25zdCBtb25vID0gcHJvcHMuYWJzID09PSB0cnVlID8gZy5hYnMoIGlucHV0WzBdICsgaW5wdXRbMV0gKSA6IGlucHV0WzBdICsgaW5wdXRbMV1cblxuICAgICAgICAgICAgc3VtWzBdID0gc3VtWzBdICsgbW9ubyAtIGcucGVlayggYnVmZmVyLCBidWZmZXJQaGFzZU91dCwgeyBtb2RlOidzaW1wbGUnIH0pXG5cbiAgICAgICAgICAgIGcucG9rZSggYnVmZmVyLCBnLmFicyggbW9ubyApLCBidWZmZXJQaGFzZU91dCApXG5cbiAgICAgICAgICAgIGF2ZyA9IChzdW1bMF0gLyBwcm9wcy5idWZmZXJTaXplKSAqIG11bHRpcGxpZXIgKyBvZmZzZXRcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlckwgPSBidWZmZXJcbiAgICAgICAgICBjb25zdCBidWZmZXJSID0gZy5kYXRhKCBwcm9wcy5idWZmZXJTaXplLCAxIClcblxuICAgICAgICAgIHsgXG4gICAgICAgICAgICBcInVzZSBqc2RzcFwiXG4gICAgICAgICAgICAvLyBwaGFzZSB0byB3cml0ZSB0byBmb2xsb3cgYnVmZmVyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJQaGFzZU91dCA9IGcuYWNjdW0oIDEsMCx7IG1heDpwcm9wcy5idWZmZXJTaXplLCBtaW46MCB9KVxuXG4gICAgICAgICAgICAvLyBob2xkIHJ1bm5pbmcgc3VtXG4gICAgICAgICAgICBjb25zdCBzdW1MID0gZy5kYXRhKCAxLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgICAgICAgICAgY29uc3Qgc3VtUiA9IGcuZGF0YSggMSwgMSwgeyBtZXRhOnRydWUgfSlcblxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHByb3BzLmFicyA9PT0gdHJ1ZSAgPyBnLmFicyggaW5wdXRbMF0gKSA6IGlucHV0WzBdXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHByb3BzLmFicyA9PT0gdHJ1ZSA/IGcuYWJzKCBpbnB1dFsxXSApIDogaW5wdXRbMV1cblxuICAgICAgICAgICAgc3VtTFswXSA9IHN1bUxbMF0gKyBsZWZ0IC0gZy5wZWVrKCBidWZmZXJMLCBidWZmZXJQaGFzZU91dCwgeyBtb2RlOidzaW1wbGUnIH0pXG4gICAgICAgICAgICBzdW1SWzBdID0gc3VtUlswXSArIHJpZ2h0LSBnLnBlZWsoIGJ1ZmZlclIsIGJ1ZmZlclBoYXNlT3V0LCB7IG1vZGU6J3NpbXBsZScgfSlcblxuICAgICAgICAgICAgZy5wb2tlKCBidWZmZXJMLCBnLmFicyggbGVmdCAgKSwgYnVmZmVyUGhhc2VPdXQgKVxuICAgICAgICAgICAgZy5wb2tlKCBidWZmZXJSLCBnLmFicyggcmlnaHQgKSwgYnVmZmVyUGhhc2VPdXQgKVxuXG4gICAgICAgICAgICBhdmcgPSBbXG4gICAgICAgICAgICAgIChzdW1MWzBdIC8gcHJvcHMuYnVmZmVyU2l6ZSkgKiBtdWx0aXBsaWVyICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAoc3VtUlswXSAvIHByb3BzLmJ1ZmZlclNpemUpICogbXVsdGlwbGllciArIG9mZnNldCxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICB7XG4gICAgICAgICAgXCJ1c2UganNkc3BcIlxuICAgICAgICAgIC8vIHBoYXNlIHRvIHdyaXRlIHRvIGZvbGxvdyBidWZmZXJcbiAgICAgICAgICBjb25zdCBidWZmZXJQaGFzZU91dCA9IGcuYWNjdW0oIDEsMCx7IG1heDpwcm9wcy5idWZmZXJTaXplLCBtaW46MCB9KVxuXG4gICAgICAgICAgLy8gaG9sZCBydW5uaW5nIHN1bVxuICAgICAgICAgIGNvbnN0IHN1bSA9IGcuZGF0YSggMSwgMSwgeyBtZXRhOnRydWUgfSlcblxuICAgICAgICAgIGNvbnN0IF9faW5wdXQgPSBwcm9wcy5hYnMgPT09IHRydWUgPyBnLmFicyggaW5wdXQgKSA6IGlucHV0XG5cbiAgICAgICAgICBzdW1bMF0gPSBzdW1bMF0gKyBfX2lucHV0IC0gZy5wZWVrKCBidWZmZXIsIGJ1ZmZlclBoYXNlT3V0LCB7IG1vZGU6J3NpbXBsZScgfSlcbiAgICAgICAgICBcbiAgICAgICAgICBnLnBva2UoIGJ1ZmZlciwgZy5hYnMoIGlucHV0ICksIGJ1ZmZlclBoYXNlT3V0IClcblxuICAgICAgICAgIGF2ZyA9IChzdW1bMF0gLyBwcm9wcy5idWZmZXJTaXplKSAqIG11bHRpcGxpZXIgKyBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG4gICAgICBwcm9wcy5pc1N0ZXJlbyA9IGZhbHNlXG4gICAgICBjb25zdCByZWNvcmQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICAgIGZvbGxvd19pbixcbiAgICAgICAgYXZnLCBcbiAgICAgICAgWydhbmFseXNpcycsICdmb2xsb3dfaW4nXSwgXG4gICAgICAgIHByb3BzXG4gICAgICApXG5cbiAgICAgIC8vIG5vbnNlbnNlIHRvIG1ha2Ugb3VyIGN1c3RvbSBmdW5jdGlvbiB3b3JrXG4gICAgICByZWNvcmQuY2FsbGJhY2sudWdlbk5hbWUgPSByZWNvcmQudWdlbk5hbWUgPSBgZm9sbG93X2luXyR7Zm9sbG93X291dC5pZH1gXG5cbiAgICAgIGlmKCBHaWJiZXJpc2guYW5hbHl6ZXJzLmluZGV4T2YoIHJlY29yZCApID09PSAtMSApIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggcmVjb3JkIClcblxuICAgICAgR2liYmVyaXNoLmRpcnR5KCBHaWJiZXJpc2guYW5hbHl6ZXJzIClcblxuICAgICAgR2liYmVyaXNoLnVnZW5zLnNldCggX19wcm9wcy5vdmVycmlkZWlkLCByZWNvcmQgKVxuXG4gICAgICBvdXQucmVjb3JkID0gcmVjb3JkXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFxuXG4gIH1cbiBcbiAgRm9sbG93LmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgYnVmZmVyU2l6ZToxMDI0LFxuICAgIG11bHRpcGxpZXI6MSxcbiAgICBhYnM6IHRydWUsXG4gICAgb3V0cHV0U3RlcmVvOmZhbHNlLFxuICAgIG9mZnNldDowXG4gIH1cblxuICByZXR1cm4gRm9sbG93XG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgYW5hbHl6ZXIgPSByZXF1aXJlKCAnLi9hbmFseXplci5qcycgKSxcbiAgICAgIHByb3h5ICAgID0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKSxcbiAgICAgIHVnZW4gICAgID0gcmVxdWlyZSggJy4uL3VnZW4uanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxuLy8gYW4gU1NEIHVnZW4gaXMgaW4gZWZmZWN0IHR3by1pbi1vbmUsXG4vLyBvbmUgZm9yIGlucHV0IGFuZCBvbmUgZm9yIG91dHB1dC4gIFxuICBcbmNvbnN0IFNTRCA9IGlucHV0UHJvcHMgPT4ge1xuICBjb25zdCBzc2QgPSBPYmplY3QuY3JlYXRlKCBhbmFseXplciApXG5cbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBTU0QuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICBjb25zdCBpc1N0ZXJlbyA9IHByb3BzLmlzU3RlcmVvIFxuICBjb25zdCBpbnB1dCAgICA9IGcuaW4oICdpbnB1dCcgKVxuICBjb25zdCBoaXN0b3J5TCA9IGcuaGlzdG9yeSgwKVxuICBjb25zdCBoaXN0b3J5UiA9IGcuaGlzdG9yeSgwKVxuXG4gIHNzZC5vdXQgPSBPdXQoIFtoaXN0b3J5TCxoaXN0b3J5Ul0sIHByb3BzIClcbiAgc3NkLmluICA9ICBJbiggW2hpc3RvcnlMLGhpc3RvcnlSXSwgcHJvcHMgKVxuXG4gIHNzZC5saXN0ZW4gPSBzc2QuaW4ubGlzdGVuXG5cbiAgcmV0dXJuIHNzZCBcbn1cblxuY29uc3QgT3V0ID0gKCBoaXN0b3JpZXMscHJvcHMgKSA9PiB7XG4gIGxldCBoaXN0b3J5XG4gIC8vIGlmIHdlIGRvbid0IGZpbmQgb3VyIGhpc3RvcnkgdWdlbiBpbiB0aGUgcHJvY2Vzc29yIHRocmVhZCxcbiAgLy8ganVzdCBnbyBhaGVhZCBhbmQgbWFrZSBhIG5ldyBvbmUsIHRoZXkncmUgY2hlYXAuLi5cbiAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICBjb25zdCBpZCA9IEFycmF5LmlzQXJyYXkoIGhpc3RvcmllcyApID8gaGlzdG9yaWVzWzBdLmlkIDogaGlzdG9yaWVzLmlkXG4gICAgaGlzdG9yeSA9IEdpYmJlcmlzaC51Z2Vucy5nZXQoIGlkIClcbiAgICBpZiggaGlzdG9yeSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaGlzdG9yeSA9IGcuaGlzdG9yeSggMCApXG4gICAgICBHaWJiZXJpc2gudWdlbnMuc2V0KCBpZCwgaGlzdG9yeSApXG4gICAgfVxuICAgIGlmKCBwcm9wcyA9PT0gdW5kZWZpbmVkICkgcHJvcHMgPSB7IGlkIH1cbiAgfWVsc2V7XG4gICAgaGlzdG9yeSA9IGhpc3Rvcmllc1swXVxuICB9XG5cbiAgcmV0dXJuIEdpYmJlcmlzaC5mYWN0b3J5KCBPYmplY3QuY3JlYXRlKCB1Z2VuICksIGhpc3Rvcnkub3V0LCBbJ2FuYWx5c2lzJywnU1NEX091dCddLCBwcm9wcywgbnVsbCApXG59XG5cbmNvbnN0IEluID0gaGlzdG9yaWVzID0+IHtcbiAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnIClcbiAgbGV0IGhpc3RvcnlMLCBoaXN0b3J5UlxuICBcbiAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gdGhlIHByb2Vzc29yIGlkIGlzIGFsd2F5cyBvbmUgb2ZmIGZyb20gdGhlIG1haW4gdGhyZWFkIGlkXG4gICAgaGlzdG9yeUwgPSBHaWJiZXJpc2gudWdlbnMuZ2V0KCBoaXN0b3JpZXMuaWQgLSAxIClcbiAgICBoaXN0b3J5UiA9IEdpYmJlcmlzaC51Z2Vucy5nZXQoIGhpc3Rvcmllcy5pZCApXG4gIH1lbHNle1xuICAgIGhpc3RvcnlMID0gaGlzdG9yaWVzWzBdXG4gICAgaGlzdG9yeVIgPSBoaXN0b3JpZXNbMV1cbiAgfVxuXG4gIC8vIGRlbGliZXJhdGUgbGV0XG4gIGxldCBzc2RpbiA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuICBcbiAgc3NkaW4ubGlzdGVuID0gZnVuY3Rpb24oIGlucHV0ICkge1xuICAgIHNzZGluLmlucHV0ID0gaW5wdXRcbiAgICAvLyBjaGFuZ2luZyB0aGUgaW5wdXQgbXVzdCB0cmlnZ2VyIGNvZGVnZW5cbiAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKSBcblxuICAgIGxldCBpc1N0ZXJlbyA9IGlucHV0LmlzU3RlcmVvXG4gICAgaWYoIGlucHV0LmlzU3RlcmVvID09PSB1bmRlZmluZWQgJiYgaW5wdXQuaXNvcCA9PT0gdHJ1ZSApIHtcbiAgICAgIGlzU3RlcmVvID0gaW5wdXQuaW5wdXRzWzBdLmlzU3RlcmVvID09PSB0cnVlIHx8IGlucHV0LmlucHV0c1sxXS5pc1N0ZXJlbyA9PT0gdHJ1ZSBcbiAgICB9XG4gICAgaWYoIGlzU3RlcmVvID09PSB0cnVlICYmIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgIGNvbnN0IGlkeCA9IGhpc3RvcnlMLmdyYXBoLm1lbW9yeS52YWx1ZS5pZHggICAgIFxuICAgICAgc3NkaW4uY2FsbGJhY2sgPSBmdW5jdGlvbiggaW5wdXQsIG1lbW9yeSApIHtcbiAgICAgICAgbWVtb3J5WyBpZHggXSA9IGlucHV0WyAwIF1cbiAgICAgICAgbWVtb3J5WyBpZHggKyAxIF0gPSBpbnB1dFsgMSBdXG4gICAgICAgIHJldHVybiAwICAgICBcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiBlYWNoIHVnZW4gY2FsbGJhY2sgaXMgcGFzc2VkIHRvIHRoZSBtYXN0ZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgIC8vIGl0IG5lZWRzIHRvIGhhdmUgYSB1Z2VuTmFtZSBwcm9wZXJ0eTsgd2UnbGwganVzdCBjb3B5IHRoaXMgb3ZlclxuICAgICAgc3NkaW4uY2FsbGJhY2sudWdlbk5hbWUgPSBzc2Rpbi51Z2VuTmFtZVxuICAgIH1cbiAgfVxuXG4gIHNzZGluID0gR2liYmVyaXNoLmZhY3RvcnkoIHNzZGluLCBpbnB1dCwgWydhbmFseXNpcycsJ1NTRF9JbiddLCB7ICdpbnB1dCc6MCB9IClcblxuICAvLyBvdmVyd3JpdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHRoZSBwcm9jZXNzb3IgdGhyZWFkLi4uXG4gIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgY29uc3QgaWR4ID0gaGlzdG9yeUwuZ3JhcGgubWVtb3J5LnZhbHVlLmlkeFxuICAgIFxuICAgIHNzZGluLmNhbGxiYWNrID0gZnVuY3Rpb24oIGlucHV0LCBtZW1vcnkgKSB7XG4gICAgICBtZW1vcnlbIGlkeCBdID0gaW5wdXRcbiAgICAgIHJldHVybiAwICAgICBcbiAgICB9XG5cbiAgICAvLyB3aGVuIGVhY2ggdWdlbiBjYWxsYmFjayBpcyBwYXNzZWQgdG8gdGhlIG1hc3RlciBjYWxsYmFjayBmdW5jdGlvblxuICAgIC8vIGl0IG5lZWRzIHRvIGhhdmUgYSB1Z2VuTmFtZSBwcm9wZXJ0eTsgd2UnbGwganVzdCBjb3B5IHRoaXMgb3ZlclxuICAgIHNzZGluLmNhbGxiYWNrLnVnZW5OYW1lID0gc3NkaW4udWdlbk5hbWVcbiAgfVxuXG4gIHNzZGluLnR5cGUgPSAnYW5hbHlzaXMnXG4gIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggc3NkaW4gKVxuXG4gIHJldHVybiBzc2RpblxufVxuXG5TU0QuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGlzU3RlcmVvOmZhbHNlXG59XG5cbnJldHVybiB7IEluLCBPdXQsIFNTRCB9XG5cbn1cbiIsImNvbnN0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSxcbiAgICAgIGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBBRCA9IGZ1bmN0aW9uKCBhcmd1bWVudFByb3BzICkge1xuICAgIGNvbnN0IGFkID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApLFxuICAgICAgICAgIGF0dGFjayAgPSBnLmluKCAnYXR0YWNrJyApLFxuICAgICAgICAgIGRlY2F5ICAgPSBnLmluKCAnZGVjYXknIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIEFELmRlZmF1bHRzLCBhcmd1bWVudFByb3BzIClcblxuICAgIGNvbnN0IGdyYXBoID0gZy5hZCggYXR0YWNrLCBkZWNheSwgeyBzaGFwZTpwcm9wcy5zaGFwZSwgYWxwaGE6cHJvcHMuYWxwaGEgfSlcblxuICAgIGFkLnRyaWdnZXIgPSBncmFwaC50cmlnZ2VyXG4gICAgXG4gICAgY29uc3QgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggYWQsIGdyYXBoLCBbJ2VudmVsb3BlcycsJ0FEJ10sIHByb3BzIClcblxuICAgIHJldHVybiBfX291dFxuICB9XG5cbiAgQUQuZGVmYXVsdHMgPSB7IGF0dGFjazo0NDEwMCwgZGVjYXk6NDQxMDAsIHNoYXBlOidleHBvbmVudGlhbCcsIGFscGhhOjUgfSBcblxuICByZXR1cm4gQURcblxufVxuIiwiY29uc3QgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApLFxuICAgICAgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IEFEU1IgPSBmdW5jdGlvbiggYXJndW1lbnRQcm9wcyApIHtcbiAgICBjb25zdCBhZHNyICA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSxcbiAgICAgICAgICBhdHRhY2sgID0gZy5pbiggJ2F0dGFjaycgKSxcbiAgICAgICAgICBkZWNheSAgID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIHN1c3RhaW4gPSBnLmluKCAnc3VzdGFpbicgKSxcbiAgICAgICAgICByZWxlYXNlID0gZy5pbiggJ3JlbGVhc2UnICksXG4gICAgICAgICAgc3VzdGFpbkxldmVsID0gZy5pbiggJ3N1c3RhaW5MZXZlbCcgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgQURTUi5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBPYmplY3QuYXNzaWduKCBhZHNyLCBwcm9wcyApXG5cbiAgICBjb25zdCBncmFwaCA9IGcuYWRzciggXG4gICAgICBhdHRhY2ssIGRlY2F5LCBzdXN0YWluLCBzdXN0YWluTGV2ZWwsIHJlbGVhc2UsIFxuICAgICAgeyB0cmlnZ2VyUmVsZWFzZTogcHJvcHMudHJpZ2dlclJlbGVhc2UsIHNoYXBlOnByb3BzLnNoYXBlLCBhbHBoYTpwcm9wcy5hbHBoYSB9IFxuICAgIClcblxuICAgIGFkc3IudHJpZ2dlciA9IGdyYXBoLnRyaWdnZXJcbiAgICBhZHNyLmFkdmFuY2UgPSBncmFwaC5yZWxlYXNlXG5cbiAgICBjb25zdCBfX291dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBhZHNyLCBncmFwaCwgWydlbnZlbG9wZXMnLCdBRFNSJ10sIHByb3BzIClcblxuICAgIHJldHVybiBfX291dCBcbiAgfVxuXG4gIEFEU1IuZGVmYXVsdHMgPSB7IFxuICAgIGF0dGFjazoyMjA1MCwgXG4gICAgZGVjYXk6MjIwNTAsIFxuICAgIHN1c3RhaW46NDQxMDAsIFxuICAgIHN1c3RhaW5MZXZlbDouNiwgXG4gICAgcmVsZWFzZTogNDQxMDAsIFxuICAgIHRyaWdnZXJSZWxlYXNlOmZhbHNlLFxuICAgIHNoYXBlOidleHBvbmVudGlhbCcsXG4gICAgYWxwaGE6NSBcbiAgfSBcblxuICByZXR1cm4gQURTUlxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IEVudmVsb3BlcyA9IHtcbiAgICBBRCAgICAgOiByZXF1aXJlKCAnLi9hZC5qcycgKSggR2liYmVyaXNoICksXG4gICAgQURTUiAgIDogcmVxdWlyZSggJy4vYWRzci5qcycgKSggR2liYmVyaXNoICksXG4gICAgUmFtcCAgIDogcmVxdWlyZSggJy4vcmFtcC5qcycgKSggR2liYmVyaXNoICksXG5cbiAgICBleHBvcnQgOiB0YXJnZXQgPT4ge1xuICAgICAgZm9yKCBsZXQga2V5IGluIEVudmVsb3BlcyApIHtcbiAgICAgICAgaWYoIGtleSAhPT0gJ2V4cG9ydCcgJiYga2V5ICE9PSAnZmFjdG9yeScgKSB7XG4gICAgICAgICAgdGFyZ2V0WyBrZXkgXSA9IEVudmVsb3Blc1sga2V5IF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmYWN0b3J5KCB1c2VBRFNSLCBzaGFwZSwgYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgc3VzdGFpbkxldmVsLCByZWxlYXNlLCB0cmlnZ2VyUmVsZWFzZT1mYWxzZSApIHtcbiAgICAgIGxldCBlbnZcblxuICAgICAgLy8gZGVsaWJlcmF0ZSB1c2Ugb2Ygc2luZ2xlID0gdG8gYWNjb21vZGF0ZSBib3RoIDEgYW5kIHRydWVcbiAgICAgIGlmKCB1c2VBRFNSICE9IHRydWUgKSB7XG4gICAgICAgIGVudiA9IGcuYWQoIGF0dGFjaywgZGVjYXksIHsgc2hhcGUgfSkgXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGVudiA9IGcuYWRzciggYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgc3VzdGFpbkxldmVsLCByZWxlYXNlLCB7IHNoYXBlLCB0cmlnZ2VyUmVsZWFzZSB9KVxuICAgICAgICBlbnYuYWR2YW5jZSA9IGVudi5yZWxlYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnZcbiAgICB9XG4gIH0gXG5cbiAgcmV0dXJuIEVudmVsb3Blc1xufVxuIiwiY29uc3QgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApLFxuICAgICAgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IFJhbXAgPSBmdW5jdGlvbiggYXJndW1lbnRQcm9wcyApIHtcbiAgICBjb25zdCByYW1wICAgPSBPYmplY3QuY3JlYXRlKCB1Z2VuICksXG4gICAgICAgICAgbGVuZ3RoID0gZy5pbiggJ2xlbmd0aCcgKSxcbiAgICAgICAgICBmcm9tICAgPSBnLmluKCAnZnJvbScgKSxcbiAgICAgICAgICB0byAgICAgPSBnLmluKCAndG8nIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgUmFtcC5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBjb25zdCByZXNldCA9IGcuYmFuZygpXG5cbiAgICBjb25zdCBwaGFzZSA9IGcuYWNjdW0oIGcuZGl2KCAxLCBsZW5ndGggKSwgcmVzZXQsIHsgc2hvdWxkV3JhcDpwcm9wcy5zaG91bGRMb29wLCBzaG91bGRDbGFtcDp0cnVlIH0pLFxuICAgICAgICAgIGRpZmYgPSBnLnN1YiggdG8sIGZyb20gKSxcbiAgICAgICAgICBncmFwaCA9IGcuYWRkKCBmcm9tLCBnLm11bCggcGhhc2UsIGRpZmYgKSApXG4gICAgICAgIFxuICAgIHJhbXAudHJpZ2dlciA9IHJlc2V0LnRyaWdnZXJcblxuICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCByYW1wLCBncmFwaCwgWydlbnZlbG9wZXMnLCdyYW1wJ10sIHByb3BzIClcblxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgUmFtcC5kZWZhdWx0cyA9IHsgZnJvbTowLCB0bzoxLCBsZW5ndGg6Zy5nZW4uc2FtcGxlcmF0ZSwgc2hvdWxkTG9vcDpmYWxzZSB9XG5cbiAgcmV0dXJuIFJhbXBcblxufVxuIiwiLypcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRpbWF0dGVyMTUvaGVhcHF1ZXVlLmpzL2Jsb2IvbWFzdGVyL2hlYXBxdWV1ZS5qc1xuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgdmVyeSBsb29zZWx5IGJhc2VkIG9mZiBqcy1wcmlvcml0eS1xdWV1ZVxuICogYnkgQWRhbSBIb29wZXIgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWRhbWhvb3Blci9qcy1wcmlvcml0eS1xdWV1ZVxuICpcbiAqIFRoZSBqcy1wcmlvcml0eS1xdWV1ZSBpbXBsZW1lbnRhdGlvbiBzZWVtZWQgYSB0ZWVuc3kgYml0IGJsb2F0ZWRcbiAqIHdpdGggaXRzIHJlcXVpcmUuanMgZGVwZW5kZW5jeSBhbmQgbXVsdGlwbGUgc3RvcmFnZSBzdHJhdGVnaWVzXG4gKiB3aGVuIGFsbCBidXQgb25lIHdlcmUgc3Ryb25nbHkgZGlzY291cmFnZWQuIFNvIGhlcmUgaXMgYSBraW5kIG9mXG4gKiBjb25kZW5zZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb25hbGl0eSB3aXRoIG9ubHkgdGhlIGZlYXR1cmVzIHRoYXRcbiAqIEkgcGFydGljdWxhcmx5IG5lZWRlZC5cbiAqXG4gKiBVc2luZyBpdCBpcyBwcmV0dHkgc2ltcGxlLCB5b3UganVzdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgSGVhcFF1ZXVlXG4gKiB3aGlsZSBvcHRpb25hbGx5IHNwZWNpZnlpbmcgYSBjb21wYXJhdG9yIGFzIHRoZSBhcmd1bWVudDpcbiAqXG4gKiB2YXIgaGVhcHEgPSBuZXcgSGVhcFF1ZXVlKCk7XG4gKlxuICogLy9JRiBORUdBVElWRSwgUkVUVVJOIEFcbiAqXG4gKiB2YXIgY3VzdG9tcSA9IG5ldyBIZWFwUXVldWUoZnVuY3Rpb24oYSwgYil7XG4gKiAgIC8vIGlmIGIgPiBhLCByZXR1cm4gbmVnYXRpdmVcbiAqICAgLy8gbWVhbnMgdGhhdCBpdCBzcGl0cyBvdXQgdGhlIHNtYWxsZXN0IGl0ZW0gZmlyc3RcbiAqICAgcmV0dXJuIGEgLSBiO1xuICogfSk7XG4gKlxuICogTm90ZSB0aGF0IGluIHRoaXMgY2FzZSwgdGhlIGRlZmF1bHQgY29tcGFyYXRvciBpcyBpZGVudGljYWwgdG9cbiAqIHRoZSBjb21wYXJhdG9yIHdoaWNoIGlzIHVzZWQgZXhwbGljaXRseSBpbiB0aGUgc2Vjb25kIHF1ZXVlLlxuICpcbiAqIE9uY2UgeW91J3ZlIGluaXRpYWxpemVkIHRoZSBoZWFwcXVldWUsIHlvdSBjYW4gcGxvcCBzb21lIG5ld1xuICogZWxlbWVudHMgaW50byB0aGUgcXVldWUgd2l0aCB0aGUgcHVzaCBtZXRob2QgKHZhZ3VlbHkgcmVtaW5pc2NlbnRcbiAqIG9mIHR5cGljYWwgamF2YXNjcmlwdCBhcmF5cylcbiAqXG4gKiBoZWFwcS5wdXNoKDQyKTtcbiAqIGhlYXBxLnB1c2goXCJraXR0ZW5cIik7XG4gKlxuICogVGhlIHB1c2ggbWV0aG9kIHJldHVybnMgdGhlIG5ldyBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIHF1ZXVlLlxuICpcbiAqIFlvdSBjYW4gcHVzaCBhbnl0aGluZyB5b3UnZCBsaWtlIG9udG8gdGhlIHF1ZXVlLCBzbyBsb25nIGFzIHlvdXJcbiAqIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgY2FwYWJsZSBvZiBoYW5kbGluZyBpdC4gVGhlIGRlZmF1bHRcbiAqIGNvbXBhcmF0b3IgaXMgcmVhbGx5IHN0dXBpZCBzbyBpdCB3b24ndCBiZSBhYmxlIHRvIGhhbmRsZSBhbnl0aGluZ1xuICogb3RoZXIgdGhhbiBhbiBudW1iZXIgYnkgZGVmYXVsdC5cbiAqXG4gKiBZb3UgY2FuIHByZXZpZXcgdGhlIHNtYWxsZXN0IGl0ZW0gYnkgdXNpbmcgcGVlay5cbiAqXG4gKiBoZWFwcS5wdXNoKC05OTk5KTtcbiAqIGhlYXBxLnBlZWsoKTsgLy8gPT0+IC05OTk5XG4gKlxuICogVGhlIHVzZWZ1bCBjb21wbGVtZW50IHRvIHRvIHRoZSBwdXNoIG1ldGhvZCBpcyB0aGUgcG9wIG1ldGhvZCxcbiAqIHdoaWNoIHJldHVybnMgdGhlIHNtYWxsZXN0IGl0ZW0gYW5kIHRoZW4gcmVtb3ZlcyBpdCBmcm9tIHRoZVxuICogcXVldWUuXG4gKlxuICogaGVhcHEucHVzaCgxKTtcbiAqIGhlYXBxLnB1c2goMik7XG4gKiBoZWFwcS5wdXNoKDMpO1xuICogaGVhcHEucG9wKCk7IC8vID09PiAxXG4gKiBoZWFwcS5wb3AoKTsgLy8gPT0+IDJcbiAqIGhlYXBxLnBvcCgpOyAvLyA9PT4gM1xuICovXG5jb25zdCBIZWFwUXVldWUgPSBmdW5jdGlvbihjbXApe1xuICB0aGlzLmNtcCA9IChjbXAgfHwgZnVuY3Rpb24oYSwgYil7IHJldHVybiBhIC0gYjsgfSk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5kYXRhID0gW107XG59XG5IZWFwUXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5kYXRhWzBdO1xufTtcbkhlYXBRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuXG4gIHZhciBwb3MgPSB0aGlzLmRhdGEubGVuZ3RoIC0gMSxcbiAgcGFyZW50LCB4O1xuXG4gIHdoaWxlKHBvcyA+IDApe1xuICAgIHBhcmVudCA9IChwb3MgLSAxKSA+Pj4gMTtcbiAgICBpZih0aGlzLmNtcCh0aGlzLmRhdGFbcG9zXSwgdGhpcy5kYXRhW3BhcmVudF0pIDwgMCl7XG4gICAgICB4ID0gdGhpcy5kYXRhW3BhcmVudF07XG4gICAgICB0aGlzLmRhdGFbcGFyZW50XSA9IHRoaXMuZGF0YVtwb3NdO1xuICAgICAgdGhpcy5kYXRhW3Bvc10gPSB4O1xuICAgICAgcG9zID0gcGFyZW50O1xuICAgIH1lbHNlIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aCsrO1xufTtcbkhlYXBRdWV1ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxhc3RfdmFsID0gdGhpcy5kYXRhLnBvcCgpLFxuICByZXQgPSB0aGlzLmRhdGFbMF07XG4gIGlmKHRoaXMuZGF0YS5sZW5ndGggPiAwKXtcbiAgICB0aGlzLmRhdGFbMF0gPSBsYXN0X3ZhbDtcbiAgICB2YXIgcG9zID0gMCxcbiAgICBsYXN0ID0gdGhpcy5kYXRhLmxlbmd0aCAtIDEsXG4gICAgbGVmdCwgcmlnaHQsIG1pbkluZGV4LCB4O1xuICAgIHdoaWxlKDEpe1xuICAgICAgbGVmdCA9IChwb3MgPDwgMSkgKyAxO1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIG1pbkluZGV4ID0gcG9zO1xuICAgICAgaWYobGVmdCA8PSBsYXN0ICYmIHRoaXMuY21wKHRoaXMuZGF0YVtsZWZ0XSwgdGhpcy5kYXRhW21pbkluZGV4XSkgPCAwKSBtaW5JbmRleCA9IGxlZnQ7XG4gICAgICBpZihyaWdodCA8PSBsYXN0ICYmIHRoaXMuY21wKHRoaXMuZGF0YVtyaWdodF0sIHRoaXMuZGF0YVttaW5JbmRleF0pIDwgMCkgbWluSW5kZXggPSByaWdodDtcbiAgICAgIGlmKG1pbkluZGV4ICE9PSBwb3Mpe1xuICAgICAgICB4ID0gdGhpcy5kYXRhW21pbkluZGV4XTtcbiAgICAgICAgdGhpcy5kYXRhW21pbkluZGV4XSA9IHRoaXMuZGF0YVtwb3NdO1xuICAgICAgICB0aGlzLmRhdGFbcG9zXSA9IHg7XG4gICAgICAgIHBvcyA9IG1pbkluZGV4O1xuICAgICAgfWVsc2UgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IGxhc3RfdmFsO1xuICB9XG4gIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYXBRdWV1ZVxuIiwiXG4vKipcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdFxuICogdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVFxuICogV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxuICogdGhlIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWFsbSAoc2NvcGUsIHBhcmVudEVsZW1lbnQpIHtcbiAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgZnJhbWUuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOi05OTlweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGZyYW1lKTtcbiAgY29uc3Qgd2luID0gZnJhbWUuY29udGVudFdpbmRvdztcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICBsZXQgdmFycyA9ICd2YXIgd2luZG93LCRob29rJztcbiAgZm9yIChjb25zdCBpIGluIHdpbikge1xuICAgIGlmICghKGkgaW4gc2NvcGUpICYmIGkgIT09ICdldmFsJykge1xuICAgICAgdmFycyArPSAnLCc7XG4gICAgICB2YXJzICs9IGk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgaSBpbiBzY29wZSkge1xuICAgIHZhcnMgKz0gJywnO1xuICAgIHZhcnMgKz0gaTtcbiAgICB2YXJzICs9ICc9c2VsZi4nO1xuICAgIHZhcnMgKz0gaTtcbiAgfVxuICBjb25zdCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXG4gICAgYGZ1bmN0aW9uICRob29rKHNlbGYsY29uc29sZSkge1widXNlIHN0cmljdFwiO1xuICAgICAgICAke3ZhcnN9O3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gZXZhbChhcmd1bWVudHNbMF0pfX1gXG4gICkpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB0aGlzLmV4ZWMgPSB3aW4uJGhvb2suY2FsbChzY29wZSwgc2NvcGUsIGNvbnNvbGUpO1xufVxuIiwiY29uc3QgX19wcm94eSA9IHJlcXVpcmUoICcuL3dvcmtsZXRQcm94eS5qcycgKVxuY29uc3QgZWZmZWN0UHJvdG8gPSByZXF1aXJlKCAnLi9meC9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG4gIFxuICBjb25zdCBmYWN0b3J5ID0gZnVuY3Rpb24oIHVnZW4sIGdyYXBoLCBfX25hbWUsIHZhbHVlcywgY2I9bnVsbCwgc2hvdWxkUHJveHkgPSB0cnVlICkge1xuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKVxuICAgICAgdWdlbi5jYWxsYmFjayA9IGNiID09PSBudWxsID8gR2liYmVyaXNoLmdlbmlzaC5nZW4uY3JlYXRlQ2FsbGJhY2soIGdyYXBoLCBHaWJiZXJpc2gubWVtb3J5LCBmYWxzZSwgdHJ1ZSApIDogY2JcbiAgICBlbHNlXG4gICAgICB1Z2VuLmNhbGxiYWNrID0geyBvdXQ6W10gfVxuXG4gICAgbGV0IG5hbWUgPSBBcnJheS5pc0FycmF5KCBfX25hbWUgKSA/IF9fbmFtZVsgX19uYW1lLmxlbmd0aCAtIDEgXSA6IF9fbmFtZVxuXG4gICAgT2JqZWN0LmFzc2lnbiggdWdlbiwge1xuICAgICAgLy90eXBlOiAndWdlbicsXG4gICAgICBpZDogdmFsdWVzLmlkIHx8IEdpYmJlcmlzaC51dGlsaXRpZXMuZ2V0VUlEKCksIFxuICAgICAgdWdlbk5hbWU6IG5hbWUgKyAnXycsXG4gICAgICBncmFwaDogZ3JhcGgsXG4gICAgICBpbnB1dE5hbWVzOiB1Z2VuLmlucHV0TmFtZXMgfHwgbmV3IFNldCggR2liYmVyaXNoLmdlbmlzaC5nZW4ucGFyYW1ldGVycyApLFxuICAgICAgaXNTdGVyZW86IEFycmF5LmlzQXJyYXkoIGdyYXBoICksXG4gICAgICBkaXJ0eTogdHJ1ZSxcbiAgICAgIF9fcHJvcGVydGllc19fOnZhbHVlcyxcbiAgICAgIF9fYWRkcmVzc2VzX186e31cbiAgICB9KVxuXG4gICAgdWdlbi51Z2VuTmFtZSArPSB1Z2VuLmlkXG4gICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgIHVnZW4uY2FsbGJhY2sudWdlbk5hbWUgPSB1Z2VuLnVnZW5OYW1lIC8vIFhYWCBoYWNreVxuICAgICAgdWdlbi5jYWxsYmFjay5pZCA9IHVnZW4uaWRcbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCAndWdlbiBuYW1lL2lkOicsIHVnZW4udWdlbk5hbWUsIHVnZW4uaWQgKVxuICAgIC8vY29uc29sZS5sb2coICdjYWxsYmFjayBuYW1lL2lkOicsIHVnZW4uY2FsbGJhY2sudWdlbk5hbWUsIHVnZW4uY2FsbGJhY2suaWQgKVxuXG4gICAgZm9yKCBsZXQgcGFyYW0gb2YgdWdlbi5pbnB1dE5hbWVzICkge1xuICAgICAgaWYoIHBhcmFtID09PSAnbWVtb3J5JyApIGNvbnRpbnVlXG5cbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1sgcGFyYW0gXSxcbiAgICAgICAgICBpc051bWJlciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgaXNOYU4oIHZhbHVlICkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgaWR4XG5cbiAgICAgIGlmKCBpc051bWJlciApIHsgXG4gICAgICAgIGlkeCA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoIDEgKVxuICAgICAgICBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGlkeCBdID0gdmFsdWVcbiAgICAgICAgdWdlbi5fX2FkZHJlc3Nlc19fWyBwYXJhbSBdID0gaWR4XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGEgc2V0dGVyP1xuICAgICAgbGV0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB1Z2VuLCBwYXJhbSApLFxuICAgICAgICAgIHNldHRlclxuXG4gICAgICBpZiggZGVzYyAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICBzZXR0ZXIgPSBkZXNjLnNldFxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHVnZW4sIHBhcmFtLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICBnZXQoKSB7IFxuICAgICAgICAgIGlmKCBpc051bWJlciApIHtcbiAgICAgICAgICAgIHJldHVybiBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGlkeCBdXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQoIHYgKSB7XG4gICAgICAgICAgLy9pZiggcGFyYW0gPT09ICdpbnB1dCcgKSBjb25zb2xlLmxvZyggJ0lOUFVUOicsIHYsIGlzTnVtYmVyIClcbiAgICAgICAgICBpZiggdmFsdWUgIT09IHYgKSB7XG4gICAgICAgICAgICBpZiggc2V0dGVyICE9PSB1bmRlZmluZWQgKSBzZXR0ZXIoIHYgKVxuICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXSA9IHZhbHVlID0gdlxuICAgICAgICAgICAgICBpZiggaXNOdW1iZXIgPT09IGZhbHNlICkgR2liYmVyaXNoLmRpcnR5KCB1Z2VuIClcbiAgICAgICAgICAgICAgaXNOdW1iZXIgPSB0cnVlXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgICAgICAgIC8qaWYoIGlzTnVtYmVyID09PSB0cnVlICkqLyBHaWJiZXJpc2guZGlydHkoIHVnZW4gKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCAnc3dpdGNoaW5nIGZyb20gbnVtYmVyOicsIHBhcmFtLCB2YWx1ZSApXG4gICAgICAgICAgICAgIGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5cGFzcyBcbiAgICBpZiggZWZmZWN0UHJvdG8uaXNQcm90b3R5cGVPZiggdWdlbiApICkge1xuICAgICAgbGV0IHZhbHVlID0gdWdlbi5ieXBhc3NcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgJ2J5cGFzcycsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHZhbHVlIH0sXG4gICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICBpZiggdmFsdWUgIT09IHYgKSB7XG4gICAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIHVnZW4gKVxuICAgICAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgfVxuXG4gICAgaWYoIHVnZW4uX19yZXF1aXJlc1JlY29tcGlsYXRpb24gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHVnZW4uX19yZXF1aXJlc1JlY29tcGlsYXRpb24uZm9yRWFjaCggcHJvcCA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1sgcHJvcCBdXG4gICAgICAgIGxldCBpc051bWJlciA9ICFpc05hTiggdmFsdWUgKVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdWdlbiwgcHJvcCwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgIGdldCgpIHsgXG4gICAgICAgICAgICBpZiggaXNOdW1iZXIgKSB7XG4gICAgICAgICAgICAgIGxldCBpZHggPSB1Z2VuLl9fYWRkcmVzc2VzX19bIHByb3AgXVxuICAgICAgICAgICAgICByZXR1cm4gR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdyZXR1cm5pbmc6JywgcHJvcCwgdmFsdWUsIEdpYmJlcmlzaC5tb2RlIClcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgICAgaWYoIHZhbHVlICE9PSB2ICkge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSB1Z2VuLl9fYWRkcmVzc2VzX19bIHByb3AgXVxuICAgICAgICAgICAgICAgIGlmKCBpZHggPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgICAgICAgaWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggMSApXG4gICAgICAgICAgICAgICAgICB1Z2VuLl9fYWRkcmVzc2VzX19bIHByb3AgXSA9IGlkeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1sgcHJvcCBdID0gR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBpZHggXSA9IHZcbiAgICAgICAgICAgICAgICBpc051bWJlciA9IHRydWVcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbIHByb3AgXSA9IHZcbiAgICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3NldHRpbmcgdWdlbicsIHZhbHVlLCBHaWJiZXJpc2gubW9kZSApXG4gICAgICAgICAgICAgICAgR2liYmVyaXNoLmRpcnR5KCB1Z2VuIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coICdTRVRUSU5HIFJFRE8gR1JBUEgnLCBwcm9wLCBHaWJiZXJpc2gubW9kZSApXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBuZWVkZWQgZm9yIGZpbHRlclR5cGUgYXQgdGhlIHZlcnkgbGVhc3QsIGJlY2F1YWUgdGhlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGFyZSByZXVzZWQgd2hlbiByZS1jcmVhdGluZyB0aGUgZ3JhcGguIFRoaXMgc2VlbXMgbGlrZSBhIGNoZWFwZXJcbiAgICAgICAgICAgICAgLy8gd2F5IHRvIHNvbHZlIHRoaXMgcHJvYmxlbS5cbiAgICAgICAgICAgICAgLy92YWx1ZXNbIHByb3AgXSA9IHZcblxuICAgICAgICAgICAgICB0aGlzLl9fcmVkb0dyYXBoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHdpbGwgb25seSBjcmVhdGUgcHJveHkgaWYgd29ya2xldHMgYXJlIGJlaW5nIHVzZWRcbiAgICAvLyBvdGhlcndpc2Ugd2lsbCByZXR1cm4gdW5hbHRlcmVkIHVnZW5cblxuICAgIGlmKCB2YWx1ZXMuc2hvdWxkQWRkVG9VZ2VuID09PSB0cnVlICkgT2JqZWN0LmFzc2lnbiggdWdlbiwgdmFsdWVzIClcblxuICAgIHJldHVybiBzaG91bGRQcm94eSA/IHByb3h5KCBfX25hbWUsIHZhbHVlcywgdWdlbiApIDogdWdlblxuICB9XG5cbiAgZmFjdG9yeS5nZXRVSUQgPSAoKSA9PiB7IHJldHVybiBHaWJiZXJpc2gudXRpbGl0aWVzLmdldFVJRCgpIH1cblxuICByZXR1cm4gZmFjdG9yeVxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG4gXG4vLyBjb25zdHJ1Y3RvciBmb3Igc2Nocm9lZGVyIGFsbHBhc3MgZmlsdGVyc1xubGV0IGFsbFBhc3MgPSBmdW5jdGlvbiggX2lucHV0LCBsZW5ndGg9NTAwLCBmZWVkYmFjaz0uNSApIHtcbiAgbGV0IGluZGV4ICA9IGcuY291bnRlciggMSwwLGxlbmd0aCApLFxuICAgICAgYnVmZmVyID0gZy5kYXRhKCBsZW5ndGggKSxcbiAgICAgIGJ1ZmZlclNhbXBsZSA9IGcucGVlayggYnVmZmVyLCBpbmRleCwgeyBpbnRlcnA6J25vbmUnLCBtb2RlOidzYW1wbGVzJyB9KSxcbiAgICAgIG91dCA9IGcubWVtbyggZy5hZGQoIGcubXVsKCAtMSwgX2lucHV0KSwgYnVmZmVyU2FtcGxlICkgKVxuICAgICAgICAgICAgICAgIFxuICBnLnBva2UoIGJ1ZmZlciwgZy5hZGQoIF9pbnB1dCwgZy5tdWwoIGJ1ZmZlclNhbXBsZSwgZmVlZGJhY2sgKSApLCBpbmRleCApXG4gXG4gIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbGxQYXNzXG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgZmlsdGVyID0gcmVxdWlyZSggJy4vZmlsdGVyLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBnZW5pc2ggPSBnXG4gIEdpYmJlcmlzaC5nZW5pc2guYmlxdWFkID0gKCBpbnB1dCwgX19jdXRvZmYsIF9fUSwgbW9kZSwgaXNTdGVyZW8gKSA9PiB7XG4gICAgJ3VzZSBqc2RzcCdcbiAgICBsZXQgaW4xYTAseDBhMSx4MWEyLHkwYjAseTFiMSxcbiAgICAgICAgaW4xYTBfcix4MGExX3IseDFhMl9yLHkwYjBfcix5MWIxX3IsXG4gICAgICAgIGNcblxuICAgIGxldCByZXR1cm5WYWx1ZVxuICAgIFxuICAgIGNvbnN0IHggPSBnZW5pc2guZGF0YShbIDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgIGNvbnN0IHkgPSBnZW5pc2guZGF0YShbIDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuICAgIGNvbnN0IGEgPSBnZW5pc2guZGF0YShbIDAsMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pXG4gICAgY29uc3QgYiA9IGdlbmlzaC5kYXRhKFsgMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pXG4gICAgXG4gICAgY29uc3QgUSA9IGcubWluKCAuNSArIF9fUSAqIDIyLCAyMi41ICkgXG4gICAgY29uc3QgY3V0b2ZmID0gZy5tYXgoIC4wMDUsIGcubWluKCBfX2N1dG9mZiwuOTk1ICkgKSAqIGcuZ2VuLnNhbXBsZXJhdGUgLyA0IFxuICAgIC8vbGV0IHcwID0gZy5tZW1vKCBnLm11bCggMiAqIE1hdGguUEksIGcuZGl2KCBnLm1heCguMDA1LCBnLm1pbihjdXRvZmYsLjk5NSkpLCAgZy5nZW4uc2FtcGxlcmF0ZSApICkgKSxcbiAgICBsZXQgdzAgPSAgKDIgKiBNYXRoLlBJKSAqIChjdXRvZmYgLyBnLmdlbi5zYW1wbGVyYXRlKSxcbiAgICAgICAgc2ludzAgPSBnLnNpbiggdzAgKSxcbiAgICAgICAgY29zdzAgPSBnLmNvcyggdzAgKSxcbiAgICAgICAgYWxwaGEgPSBzaW53MCAvICggMiAqIFEgKVxuXG4gICAgLy9sZXQgdzAgPSBnLm1lbW8oIGcubXVsKCAyICogTWF0aC5QSSwgZy5kaXYoIGN1dG9mZiwgIGcuZ2VuLnNhbXBsZXJhdGUgKSApICksXG4gICAgICBcbiAgICBsZXQgb25lTWludXNDb3NXID0gMSAtIGNvc3cwXG5cbiAgICAvKioqKioqKiogcHJvY2VzcyBjb2VmZmljaWVudHMgKioqKioqKiovXG4gICAgc3dpdGNoKCBtb2RlICkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBhWzBdID0gKDEgKyBjb3N3MCkgLyAyXG4gICAgICAgIGFbMV0gPSAoMSArIGNvc3cwKSAqIC0xXG4gICAgICAgIGFbMl0gPSBhWzBdXG4gICAgICAgIGMgICAgPSAxICsgYWxwaGFcbiAgICAgICAgYlswXSA9IC0yICogY29zdzBcbiAgICAgICAgYlsxXSA9IDEgLSBhbHBoYVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYVswXSA9IFEgKiBhbHBoYVxuICAgICAgICBhWzFdID0gMFxuICAgICAgICBhWzJdID0gYVswXSAqIC0xXG4gICAgICAgIGMgICAgPSAxICsgYWxwaGFcbiAgICAgICAgYlswXSA9IC0yICogY29zdzBcbiAgICAgICAgYlsxXSA9IDEgLSBhbHBoYVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIExQXG4gICAgICAgIGFbMF0gPSBvbmVNaW51c0Nvc1cgLyAyXG4gICAgICAgIGFbMV0gPSBvbmVNaW51c0Nvc1dcbiAgICAgICAgYVsyXSA9IGFbMF1cbiAgICAgICAgYyAgICA9IDEgKyBhbHBoYVxuICAgICAgICBiWzBdID0gLTIgKiBjb3N3MFxuICAgICAgICBiWzFdID0gMSAtIGFscGhhXG4gICAgfVxuXG4gICAgYVswXSA9IGFbMF0gLyBjOyBhWzFdID0gYVsxXSAvIGM7IGFbMl0gPSBhWzJdIC8gY1xuICAgIGJbMF0gPSBiWzBdIC8gYzsgYlsxXSA9IGJbMV0gLyBjXG5cbiAgICAvKioqKioqKiogZW5kIGNvZWZmaWNpZW50cyAqKioqKioqKi9cblxuICAgIC8qKioqKiogbGVmdCAvIG1vbm8gb3V0cHV0ICoqKioqKioqL1xuXG4gICAgbGV0IGwgPSBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGlucHV0WzBdIDogaW5wdXRcbiAgICBpbjFhMCA9IGwgKiBhWzBdXG4gICAgeDBhMSAgPSB4WzBdICogYVsxXVxuICAgIHgxYTIgID0geFsxXSAqIGFbMl1cblxuICAgIHhbMV0gPSB4WzBdIFxuICAgIHhbMF0gPSBsXG5cbiAgICBsZXQgc3VtTGVmdCA9IGluMWEwICsgeDBhMSArIHgxYTJcblxuICAgIHkwYjAgPSB5WzBdICogYlswXVxuICAgIHkxYjEgPSB5WzFdICogYlsxXVxuICAgIHlbMV0gPSB5WzBdIFxuXG4gICAgbGV0IHN1bVJpZ2h0ID0geTBiMCArIHkxYjFcblxuICAgIGxldCBkaWZmID0gc3VtTGVmdCAtIHN1bVJpZ2h0XG5cbiAgICB5WzBdID0gZGlmZlxuICAgIFxuICAgIC8qKioqKioqKiBlbmQgbGVmdC9tb25vICoqKioqKioqKiovXG5cbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICBjb25zdCB4ciA9IGdlbmlzaC5kYXRhKFsgMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pXG4gICAgICBjb25zdCB5ciA9IGdlbmlzaC5kYXRhKFsgMCwwIF0sIDEsIHsgbWV0YTp0cnVlIH0pXG4gICAgICAvL2xldCB4MV8xID0gZy5oaXN0b3J5KCksIHgyXzEgPSBnLmhpc3RvcnkoKSwgeTFfMSA9IGcuaGlzdG9yeSgpLCB5Ml8xID0gZy5oaXN0b3J5KClcblxuICAgICAgY29uc3QgciA9IGlucHV0WzFdIFxuICAgICAgaW4xYTBfciA9IHIgKiBhWzBdIC8vZy5tdWwoIHgxXzEuaW4oIGlucHV0WzFdICksIGEwIClcbiAgICAgIHgwYTFfciAgPSB4clswXSAqIGFbMV0vL2cubXVsKCB4Ml8xLmluKCB4MV8xLm91dCApLCBhMSApXG4gICAgICB4MWEyX3IgID0geHJbMV0gKiBhWzJdLy9nLm11bCggeDJfMS5vdXQsICAgICAgICAgICAgYTIgKVxuXG4gICAgICB4clsxXSAgID0geHJbMF1cbiAgICAgIHhyWzBdID0gclxuXG4gICAgICBjb25zdCBzdW1MZWZ0X3IgPSBpbjFhMF9yICsgeDBhMV9yICsgeDFhMl9yXG5cbiAgICAgIHkwYjBfciA9IHlyWzBdICogYlswXS8vZy5tdWwoIHkyXzEuaW4oIHkxXzEub3V0ICksIGIxIClcbiAgICAgIHkxYjFfciA9IHlyWzFdICogYlsxXS8vZy5tdWwoIHkyXzEub3V0LCBiMiApXG4gICAgICB5clsxXSA9IHlyWzBdXG5cbiAgICAgIGNvbnN0IHN1bVJpZ2h0X3IgPSB5MGIwX3IgKyB5MWIxX3JcblxuICAgICAgY29uc3QgZGlmZl9yID0gc3VtTGVmdF9yIC0gc3VtUmlnaHRfclxuXG4gICAgICB5clswXSA9IGRpZmZfclxuICAgICAgXG4gICAgICByZXR1cm5WYWx1ZSA9IFsgZGlmZiwgZGlmZl9yIF1cbiAgICB9ZWxzZXtcbiAgICAgIHJldHVyblZhbHVlID0gZGlmZlxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICB9XG5cbiAgbGV0IEJpcXVhZCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IGJpcXVhZCA9IE9iamVjdC5jcmVhdGUoIGZpbHRlciApXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgQmlxdWFkLmRlZmF1bHRzLCBpbnB1dFByb3BzICkgXG4gICAgbGV0IF9fb3V0XG5cbiAgICBPYmplY3QuYXNzaWduKCBiaXF1YWQsIHByb3BzIClcblxuICAgIGJpcXVhZC5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgaWYoIF9fb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlzU3RlcmVvID0gcHJvcHMuaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gdW5kZWZpbmVkID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICAgIH1lbHNle1xuICAgICAgICBpc1N0ZXJlbyA9IF9fb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICAgIF9fb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICAgIH1cbiAgICAgIGJpcXVhZC5ncmFwaCA9IEdpYmJlcmlzaC5nZW5pc2guYmlxdWFkKCBnLmluKCdpbnB1dCcpLCBnLmluKCdjdXRvZmYnKSwgIGcuaW4oJ1EnKSwgYmlxdWFkLm1vZGUsIGlzU3RlcmVvIClcbiAgICB9XG5cbiAgICBiaXF1YWQuX19jcmVhdGVHcmFwaCgpXG4gICAgYmlxdWFkLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnbW9kZScsICdpbnB1dCcgXVxuXG4gICAgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeShcbiAgICAgIGJpcXVhZCxcbiAgICAgIGJpcXVhZC5ncmFwaCxcbiAgICAgIFsnZmlsdGVycycsJ0ZpbHRlcjEyQmlxdWFkJ10sIFxuICAgICAgcHJvcHNcbiAgICApXG5cbiAgICByZXR1cm4gX19vdXRcbiAgfVxuXG4gIEJpcXVhZC5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIFE6IC4xNSxcbiAgICBjdXRvZmY6LjA1LFxuICAgIG1vZGU6MFxuICB9XG5cbiAgcmV0dXJuIEJpcXVhZFxuXG59XG5cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuXG5sZXQgY29tYkZpbHRlciA9IGZ1bmN0aW9uKCBfaW5wdXQsIGNvbWJMZW5ndGgsIGRhbXBpbmc9LjUqLjQsIGZlZWRiYWNrQ29lZmY9Ljg0ICkge1xuICBsZXQgbGFzdFNhbXBsZSAgID0gZy5oaXN0b3J5KCksXG4gIFx0ICByZWFkV3JpdGVJZHggPSBnLmNvdW50ZXIoIDEsMCxjb21iTGVuZ3RoICksXG4gICAgICBjb21iQnVmZmVyICAgPSBnLmRhdGEoIGNvbWJMZW5ndGggKSxcblx0ICAgIG91dCAgICAgICAgICA9IGcucGVlayggY29tYkJ1ZmZlciwgcmVhZFdyaXRlSWR4LCB7IGludGVycDonbm9uZScsIG1vZGU6J3NhbXBsZXMnIH0pLFxuICAgICAgc3RvcmVJbnB1dCAgID0gZy5tZW1vKCBnLmFkZCggZy5tdWwoIG91dCwgZy5zdWIoIDEsIGRhbXBpbmcpKSwgZy5tdWwoIGxhc3RTYW1wbGUub3V0LCBkYW1waW5nICkgKSApXG4gICAgICBcbiAgbGFzdFNhbXBsZS5pbiggc3RvcmVJbnB1dCApXG4gXG4gIGcucG9rZSggY29tYkJ1ZmZlciwgZy5hZGQoIF9pbnB1dCwgZy5tdWwoIHN0b3JlSW5wdXQsIGZlZWRiYWNrQ29lZmYgKSApLCByZWFkV3JpdGVJZHggKVxuIFxuICByZXR1cm4gb3V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tYkZpbHRlclxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBmaWx0ZXIgPSByZXF1aXJlKCAnLi9maWx0ZXIuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBHaWJiZXJpc2guZ2VuaXNoLmRpb2RlWkRGID0gKCBpbnB1dCwgX19RLCBfX2ZyZXEsIHNhdHVyYXRpb24sIGlzU3RlcmVvPWZhbHNlICkgPT4ge1xuICAgIGNvbnN0IGlUID0gMSAvIGcuZ2VuLnNhbXBsZXJhdGUsXG4gICAgICAgICAga3oxID0gZy5oaXN0b3J5KDApLFxuICAgICAgICAgIGt6MiA9IGcuaGlzdG9yeSgwKSxcbiAgICAgICAgICBrejMgPSBnLmhpc3RvcnkoMCksXG4gICAgICAgICAga3o0ID0gZy5oaXN0b3J5KDApXG5cbiAgICBsZXQgICBrYTEgPSAxLjAsXG4gICAgICAgICAga2EyID0gMC41LFxuICAgICAgICAgIGthMyA9IDAuNSxcbiAgICAgICAgICBrYTQgPSAwLjUsXG4gICAgICAgICAga2luZHggPSAwICAgXG5cbiAgICBjb25zdCBmcmVxID0gZy5tdWwoIGcubWF4KC4wMDUsIGcubWluKCBfX2ZyZXEsIC45OTUpKSwgIGdlbmlzaC5nZW4uc2FtcGxlcmF0ZSAvIDIgKVxuICAgIC8vY29uc3QgZnJlcSA9IGcubWF4KC4wMDUsIGcubWluKCBfX2ZyZXEsIC45OTUpKVxuXG4gICAgLy8gWFhYIHRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIG51bWJlciBoYXBlbnMgZm9yIFEuLi5cbiAgICBjb25zdCBRID0gZy5tZW1vKCBnLmFkZCggLjUsIGcubXVsKCBfX1EsIGcuYWRkKCA1LCBnLnN1YiggNSwgZy5tdWwoIGcuZGl2KCBmcmVxLCAyMDAwMCAgKSwgNSApICkgKSApICkgKVxuICAgIC8vIGt3ZCA9IDIgKiAkTV9QSSAqIGFjZltraW5keF1cbiAgICBjb25zdCBrd2QgPSBnLm1lbW8oIGcubXVsKCBNYXRoLlBJICogMiwgZnJlcSApIClcblxuICAgIC8vIGt3YSA9ICgyL2lUKSAqIHRhbihrd2QgKiBpVC8yKSBcbiAgICBjb25zdCBrd2EgPWcubWVtbyggZy5tdWwoIDIvaVQsIGcudGFuKCBnLm11bCgga3dkLCBpVC8yICkgKSApIClcblxuICAgIC8vIGtHICA9IGt3YSAqIGlULzIgXG4gICAgY29uc3Qga2cgPSBnLm1lbW8oIGcubXVsKCBrd2EsIGlULzIgKSApXG4gICAgXG4gICAgY29uc3Qga0c0ID0gZy5tZW1vKCBnLm11bCggLjUsIGcuZGl2KCBrZywgZy5hZGQoIDEsIGtnICkgKSApIClcbiAgICBjb25zdCBrRzMgPSBnLm1lbW8oIGcubXVsKCAuNSwgZy5kaXYoIGtnLCBnLnN1YiggZy5hZGQoIDEsIGtnICksIGcubXVsKCBnLm11bCggLjUsIGtnICksIGtHNCApICkgKSApIClcbiAgICBjb25zdCBrRzIgPSBnLm1lbW8oIGcubXVsKCAuNSwgZy5kaXYoIGtnLCBnLnN1YiggZy5hZGQoIDEsIGtnICksIGcubXVsKCBnLm11bCggLjUsIGtnICksIGtHMyApICkgKSApIClcbiAgICBjb25zdCBrRzEgPSBnLm1lbW8oIGcuZGl2KCBrZywgZy5zdWIoIGcuYWRkKCAxLCBrZyApLCBnLm11bCgga2csIGtHMiApICkgKSApXG5cbiAgICBjb25zdCBrR0FNTUEgPSBnLm1lbW8oIGcubXVsKCBnLm11bCgga0c0LCBrRzMgKSAsIGcubXVsKCBrRzIsIGtHMSApICkgKVxuXG4gICAgY29uc3Qga1NHMSA9IGcubWVtbyggZy5tdWwoIGcubXVsKCBrRzQsIGtHMyApLCBrRzIgKSApIFxuXG4gICAgY29uc3Qga1NHMiA9IGcubWVtbyggZy5tdWwoIGtHNCwga0czKSApICBcbiAgICBjb25zdCBrU0czID0ga0c0IFxuICAgIGxldCBrU0c0ID0gMS4wIFxuICAgIC8vIGtrID0gNC4wKihrUSAtIDAuNSkvKDI1LjAgLSAwLjUpXG4gICAgY29uc3Qga2FscGhhID0gZy5tZW1vKCBnLmRpdigga2csIGcuYWRkKDEuMCwga2cpICkgKVxuXG4gICAgY29uc3Qga2JldGExID0gZy5tZW1vKCBnLmRpdiggMS4wLCBnLnN1YiggZy5hZGQoIDEsIGtnICksIGcubXVsKCBrZywga0cyICkgKSApIClcbiAgICBjb25zdCBrYmV0YTIgPSBnLm1lbW8oIGcuZGl2KCAxLjAsIGcuc3ViKCBnLmFkZCggMSwga2cgKSwgZy5tdWwoIGcubXVsKCAuNSwga2cgKSwga0czICkgKSApIClcbiAgICBjb25zdCBrYmV0YTMgPSBnLm1lbW8oIGcuZGl2KCAxLjAsIGcuc3ViKCBnLmFkZCggMSwga2cgKSwgZy5tdWwoIGcubXVsKCAuNSwga2cgKSwga0c0ICkgKSApIClcbiAgICBjb25zdCBrYmV0YTQgPSBnLm1lbW8oIGcuZGl2KCAxLjAsIGcuYWRkKCAxLCBrZyApICkgKSBcblxuICAgIGNvbnN0IGtnYW1tYTEgPSBnLm1lbW8oIGcuYWRkKCAxLCBnLm11bCgga0cxLCBrRzIgKSApIClcbiAgICBjb25zdCBrZ2FtbWEyID0gZy5tZW1vKCBnLmFkZCggMSwgZy5tdWwoIGtHMiwga0czICkgKSApXG4gICAgY29uc3Qga2dhbW1hMyA9IGcubWVtbyggZy5hZGQoIDEsIGcubXVsKCBrRzMsIGtHNCApICkgKVxuXG4gICAgY29uc3Qga2RlbHRhMSA9IGtnXG4gICAgY29uc3Qga2RlbHRhMiA9IGcubWVtbyggZy5tdWwoIDAuNSwga2cgKSApXG4gICAgY29uc3Qga2RlbHRhMyA9IGcubWVtbyggZy5tdWwoIDAuNSwga2cgKSApXG5cbiAgICBjb25zdCBrZXBzaWxvbjEgPSBrRzJcbiAgICBjb25zdCBrZXBzaWxvbjIgPSBrRzNcbiAgICBjb25zdCBrZXBzaWxvbjMgPSBrRzRcblxuICAgIGNvbnN0IGtsYXN0Y3V0ID0gZnJlcVxuXG4gICAgLy87OyBmZWVkYmFjayBpbnB1dHMgXG4gICAgY29uc3Qga2ZiNCA9IGcubWVtbyggZy5tdWwoIGtiZXRhNCAsIGt6NC5vdXQgKSApIFxuICAgIGNvbnN0IGtmYjMgPSBnLm1lbW8oIGcubXVsKCBrYmV0YTMsIGcuYWRkKCBrejMub3V0LCBnLm11bCgga2ZiNCwga2RlbHRhMyApICkgKSApXG4gICAgY29uc3Qga2ZiMiA9IGcubWVtbyggZy5tdWwoIGtiZXRhMiwgZy5hZGQoIGt6Mi5vdXQsIGcubXVsKCBrZmIzLCBrZGVsdGEyICkgKSApIClcblxuICAgIC8vOzsgZmVlZGJhY2sgcHJvY2Vzc1xuXG4gICAgY29uc3Qga2ZibzEgPSBnLm1lbW8oIGcubXVsKCBrYmV0YTEsIGcuYWRkKCBrejEub3V0LCBnLm11bCgga2ZiMiwga2RlbHRhMSApICkgKSApIFxuICAgIGNvbnN0IGtmYm8yID0gZy5tZW1vKCBnLm11bCgga2JldGEyLCBnLmFkZCgga3oyLm91dCwgZy5tdWwoIGtmYjMsIGtkZWx0YTIgKSApICkgKSBcbiAgICBjb25zdCBrZmJvMyA9IGcubWVtbyggZy5tdWwoIGtiZXRhMywgZy5hZGQoIGt6My5vdXQsIGcubXVsKCBrZmI0LCBrZGVsdGEzICkgKSApICkgXG4gICAgY29uc3Qga2ZibzQgPSBrZmI0XG5cbiAgICBjb25zdCBrU0lHTUEgPSBnLm1lbW8oIFxuICAgICAgZy5hZGQoIFxuICAgICAgICBnLmFkZCggXG4gICAgICAgICAgZy5tdWwoIGtTRzEsIGtmYm8xICksIFxuICAgICAgICAgIGcubXVsKCBrU0cyLCBrZmJvMiApXG4gICAgICAgICksIFxuICAgICAgICBnLmFkZChcbiAgICAgICAgICBnLm11bCgga1NHMywga2ZibzMgKSwgXG4gICAgICAgICAgZy5tdWwoIGtTRzQsIGtmYm80IClcbiAgICAgICAgKSBcbiAgICAgICkgXG4gICAgKVxuXG4gICAgLy9jb25zdCBrU0lHTUEgPSAxXG4gICAgLy87OyBub24tbGluZWFyIHByb2Nlc3NpbmdcbiAgICAvL2lmIChrbmxwID09IDEpIHRoZW5cbiAgICAvLyAga2luID0gKDEuMCAvIHRhbmgoa3NhdHVyYXRpb24pKSAqIHRhbmgoa3NhdHVyYXRpb24gKiBraW4pXG4gICAgLy9lbHNlaWYgKGtubHAgPT0gMikgdGhlblxuICAgIC8vICBraW4gPSB0YW5oKGtzYXR1cmF0aW9uICoga2luKSBcbiAgICAvL2VuZGlmXG4gICAgLy9cbiAgICAvL2NvbnN0IGtpbiA9IGlucHV0IFxuICAgIGxldCBraW4gPSBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGcuYWRkKCBpbnB1dFswXSwgaW5wdXRbMV0gKSA6IGlucHV0Ly9nLm1lbW8oIGcubXVsKCBnLmRpdiggMSwgZy50YW5oKCBzYXR1cmF0aW9uICkgKSwgZy50YW5oKCBnLm11bCggc2F0dXJhdGlvbiwgaW5wdXQgKSApICkgKVxuICAgIGtpbiA9IGcudGFuaCggZy5tdWwoIHNhdHVyYXRpb24sIGtpbiApIClcblxuICAgIGNvbnN0IGt1biA9IGcuZGl2KCBnLnN1Yigga2luLCBnLm11bCggUSwga1NJR01BICkgKSwgZy5hZGQoIDEsIGcubXVsKCBRLCBrR0FNTUEgKSApIClcbiAgICAvL2NvbnN0IGt1biA9IGcuZGl2KCAxLCBnLmFkZCggMSwgZy5tdWwoIFEsIGtHQU1NQSApICkgKVxuICAgICAgICAvLyhraW4gLSBrayAqIGtTSUdNQSkgLyAoMS4wICsga2sgKiBrR0FNTUEpXG5cbiAgICAvLzs7IDFzdCBzdGFnZVxuICAgIGxldCBreGluID0gZy5tZW1vKCBnLmFkZCggZy5hZGQoIGcubXVsKCBrdW4sIGtnYW1tYTEgKSwga2ZiMiksIGcubXVsKCBrZXBzaWxvbjEsIGtmYm8xICkgKSApXG4gICAgLy8gKGt1biAqIGtnYW1tYTEgKyBrZmIyICsga2Vwc2lsb24xICoga2ZibzEpXG4gICAgbGV0IGt2ID0gZy5tZW1vKCBnLm11bCggZy5zdWIoIGcubXVsKCBrYTEsIGt4aW4gKSwga3oxLm91dCApLCBrYWxwaGEgKSApXG4gICAgLy9rdiA9IChrYTEgKiBreGluIC0ga3oxKSAqIGthbHBoYSBcbiAgICBsZXQga2xwID0gZy5hZGQoIGt2LCBrejEub3V0IClcbiAgICAvL2tscCA9IGt2ICsga3oxXG4gICAga3oxLmluKCBnLmFkZCgga2xwLCBrdiApICkgXG4gICAgLy9rejEgPSBrbHAgKyBrdlxuXG4gICAgICAgIC8vOzsgMm5kIHN0YWdlXG4gICAgLy9reGluID0gKGtscCAqIGtnYW1tYTIgKyBrZmIzICsga2Vwc2lsb24yICoga2ZibzIpXG4gICAgLy9rdiA9IChrYTIgKiBreGluIC0ga3oyKSAqIGthbHBoYSBcbiAgICAvL2tscCA9IGt2ICsga3oyXG4gICAgLy9rejIgPSBrbHAgKyBrdlxuXG4gICAga3hpbiA9IGcubWVtbyggZy5hZGQoIGcuYWRkKCBnLm11bCgga2xwLCBrZ2FtbWEyICksIGtmYjMpLCBnLm11bCgga2Vwc2lsb24yLCBrZmJvMiApICkgKVxuICAgIC8vIChrdW4gKiBrZ2FtbWExICsga2ZiMiArIGtlcHNpbG9uMSAqIGtmYm8xKVxuICAgIGt2ID0gZy5tZW1vKCBnLm11bCggZy5zdWIoIGcubXVsKCBrYTIsIGt4aW4gKSwga3oyLm91dCApLCBrYWxwaGEgKSApXG4gICAgLy9rdiA9IChrYTEgKiBreGluIC0ga3oxKSAqIGthbHBoYSBcbiAgICBrbHAgPSBnLmFkZCgga3YsIGt6Mi5vdXQgKSBcbiAgICAvL2tscCA9IGt2ICsga3oxXG4gICAga3oyLmluKCBnLmFkZCgga2xwLCBrdiApICkgXG4gICAgLy9rejEgPSBrbHAgKyBrdlxuXG4gICAgLy87OyAzcmQgc3RhZ2VcbiAgICAvL2t4aW4gPSAoa2xwICoga2dhbW1hMyArIGtmYjQgKyBrZXBzaWxvbjMgKiBrZmJvMylcbiAgICAvL2t2ID0gKGthMyAqIGt4aW4gLSBrejMpICoga2FscGhhIFxuICAgIC8va2xwID0ga3YgKyBrejNcbiAgICAvL2t6MyA9IGtscCArIGt2XG5cbiAgICBreGluID0gZy5tZW1vKCBnLmFkZCggZy5hZGQoIGcubXVsKCBrbHAsIGtnYW1tYTMgKSwga2ZiNCksIGcubXVsKCBrZXBzaWxvbjMsIGtmYm8zICkgKSApXG4gICAgLy8gKGt1biAqIGtnYW1tYTEgKyBrZmIyICsga2Vwc2lsb24xICoga2ZibzEpXG4gICAga3YgPSBnLm1lbW8oIGcubXVsKCBnLnN1YiggZy5tdWwoIGthMywga3hpbiApLCBrejMub3V0ICksIGthbHBoYSApIClcbiAgICAvL2t2ID0gKGthMSAqIGt4aW4gLSBrejEpICoga2FscGhhIFxuICAgIGtscCA9IGcuYWRkKCBrdiwga3ozLm91dCApXG4gICAgLy9rbHAgPSBrdiArIGt6MVxuICAgIGt6My5pbiggZy5hZGQoIGtscCwga3YgKSApXG4gICAgLy9rejEgPSBrbHAgKyBrdlxuXG4gICAgLy87OyA0dGggc3RhZ2VcbiAgICAvL2t2ID0gKGthNCAqIGtscCAtIGt6NCkgKiBrYWxwaGEgXG4gICAgLy9rbHAgPSBrdiArIGt6NFxuICAgIC8va3o0ID0ga2xwICsga3ZcblxuICAgIC8vIChrdW4gKiBrZ2FtbWExICsga2ZiMiArIGtlcHNpbG9uMSAqIGtmYm8xKVxuICAgIGt2ID0gZy5tZW1vKCBnLm11bCggZy5zdWIoIGcubXVsKCBrYTQsIGt4aW4gKSwga3o0Lm91dCApLCBrYWxwaGEgKSApXG4gICAgLy9rdiA9IChrYTEgKiBreGluIC0ga3oxKSAqIGthbHBoYSBcbiAgICBrbHAgPSBnLmFkZCgga3YsIGt6NC5vdXQgKVxuICAgIC8va2xwID0ga3YgKyBrejFcbiAgICBrejQuaW4oIGcuYWRkKCBrbHAsIGt2ICkgKVxuXG4gICAgLy9rejEgPSBrbHAgKyBrdlxuICAgIGlmKCBpc1N0ZXJlbyApIHtcbiAgICAgIC8vbGV0IHBvbGVzUiA9IGcuZGF0YShbIDAsMCwwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAvLyAgICByZXp6UiA9IGcuY2xhbXAoIGcubXVsKCBwb2xlc1JbM10sIHJleiApICksXG4gICAgICAvLyAgICBvdXRwdXRSID0gZy5zdWIoIGlucHV0WzFdLCByZXp6UiApICAgICAgICAgXG5cbiAgICAgIC8vcG9sZXNSWzBdID0gZy5hZGQoIHBvbGVzUlswXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzBdICksIG91dHB1dFIgICApLCBjdXRvZmYgKSlcbiAgICAgIC8vcG9sZXNSWzFdID0gZy5hZGQoIHBvbGVzUlsxXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzFdICksIHBvbGVzUlswXSApLCBjdXRvZmYgKSlcbiAgICAgIC8vcG9sZXNSWzJdID0gZy5hZGQoIHBvbGVzUlsyXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzJdICksIHBvbGVzUlsxXSApLCBjdXRvZmYgKSlcbiAgICAgIC8vcG9sZXNSWzNdID0gZy5hZGQoIHBvbGVzUlszXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzNdICksIHBvbGVzUlsyXSApLCBjdXRvZmYgKSlcblxuICAgICAgLy9sZXQgcmlnaHQgPSBnLnN3aXRjaCggaXNMb3dQYXNzLCBwb2xlc1JbM10sIGcuc3ViKCBvdXRwdXRSLCBwb2xlc1JbM10gKSApXG5cbiAgICAgIC8vcmV0dXJuVmFsdWUgPSBbbGVmdCwgcmlnaHRdXG4gICAgfWVsc2V7XG4gICAgIC8vIHJldHVyblZhbHVlID0ga2xwXG4gICAgfVxuICAgIC8vcmV0dXJuVmFsdWUgPSBrbHBcbiAgICBcbiAgICByZXR1cm4ga2xwXG4gfVxuXG4gIGNvbnN0IERpb2RlWkRGID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgY29uc3QgemRmICAgICAgPSBPYmplY3QuY3JlYXRlKCBmaWx0ZXIgKVxuICAgIGNvbnN0IHByb3BzICAgID0gT2JqZWN0LmFzc2lnbigge30sIERpb2RlWkRGLmRlZmF1bHRzLCBmaWx0ZXIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIGNvbnN0IGlzU3RlcmVvID0gcHJvcHMuaW5wdXQuaXNTdGVyZW8gXG5cbiAgICBPYmplY3QuYXNzaWduKCB6ZGYsIHByb3BzIClcblxuICAgIGNvbnN0IF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoXG4gICAgICB6ZGYsIFxuICAgICAgR2liYmVyaXNoLmdlbmlzaC5kaW9kZVpERiggZy5pbignaW5wdXQnKSwgZy5pbignUScpLCBnLmluKCdjdXRvZmYnKSwgZy5pbignc2F0dXJhdGlvbicpLCBpc1N0ZXJlbyApLCBcbiAgICAgIFsnZmlsdGVycycsJ0ZpbHRlcjI0VEIzMDMnXSxcbiAgICAgIHByb3BzXG4gICAgKVxuXG4gICAgcmV0dXJuIF9fb3V0IFxuICB9XG5cbiAgRGlvZGVaREYuZGVmYXVsdHMgPSB7XG4gICAgaW5wdXQ6MCxcbiAgICBROiAuNjUsXG4gICAgc2F0dXJhdGlvbjogMSxcbiAgICBjdXRvZmY6LjUgXG4gIH1cblxuICByZXR1cm4gRGlvZGVaREZcblxufVxuIiwibGV0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpXG5cbmxldCBmaWx0ZXIgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcblxuT2JqZWN0LmFzc2lnbiggZmlsdGVyLCB7XG4gIGRlZmF1bHRzOiB7IGJ5cGFzczpmYWxzZSB9IFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXJcbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICBmaWx0ZXIgPSByZXF1aXJlKCAnLi9maWx0ZXIuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIEdpYmJlcmlzaC5nZW5pc2guZmlsdGVyMjQgPSAoIGlucHV0LCBfcmV6LCBfY3V0b2ZmLCBpc0xvd1Bhc3MsIGlzU3RlcmVvPWZhbHNlICkgPT4ge1xuICAgIGxldCByZXR1cm5WYWx1ZSxcbiAgICAgICAgcG9sZXNMID0gZy5kYXRhKFsgMCwwLDAsMCBdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgcGVla1Byb3BzID0geyBpbnRlcnA6J25vbmUnLCBtb2RlOidzaW1wbGUnIH0sXG4gICAgICAgIHJleiA9IGcubWVtbyggZy5tdWwoIF9yZXosIDUgKSApLFxuICAgICAgICBjdXRvZmYgPSBnLm1lbW8oIGcuZGl2KCBfY3V0b2ZmLCAxMTAyNSApICksXG4gICAgICAgIHJlenpMID0gZy5jbGFtcCggZy5tdWwoIHBvbGVzTFszXSwgcmV6ICkgKSxcbiAgICAgICAgb3V0cHV0TCA9IGcuc3ViKCBpc1N0ZXJlbyA/IGlucHV0WzBdIDogaW5wdXQsIHJlenpMICkgXG5cbiAgICBwb2xlc0xbMF0gPSBnLmFkZCggcG9sZXNMWzBdLCBnLm11bCggZy5hZGQoIGcubXVsKC0xLCBwb2xlc0xbMF0gKSwgb3V0cHV0TCAgICksIGN1dG9mZiApKVxuICAgIHBvbGVzTFsxXSA9IGcuYWRkKCBwb2xlc0xbMV0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzTFsxXSApLCBwb2xlc0xbMF0gKSwgY3V0b2ZmICkpXG4gICAgcG9sZXNMWzJdID0gZy5hZGQoIHBvbGVzTFsyXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNMWzJdICksIHBvbGVzTFsxXSApLCBjdXRvZmYgKSlcbiAgICBwb2xlc0xbM10gPSBnLmFkZCggcG9sZXNMWzNdLCBnLm11bCggZy5hZGQoIGcubXVsKC0xLCBwb2xlc0xbM10gKSwgcG9sZXNMWzJdICksIGN1dG9mZiApKVxuICAgIFxuICAgIGxldCBsZWZ0ID0gZy5zd2l0Y2goIGlzTG93UGFzcywgcG9sZXNMWzNdLCBnLnN1Yiggb3V0cHV0TCwgcG9sZXNMWzNdICkgKVxuXG4gICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgbGV0IHBvbGVzUiA9IGcuZGF0YShbIDAsMCwwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgICAgcmV6elIgPSBnLmNsYW1wKCBnLm11bCggcG9sZXNSWzNdLCByZXogKSApLFxuICAgICAgICAgIG91dHB1dFIgPSBnLnN1YiggaW5wdXRbMV0sIHJlenpSICkgICAgICAgICBcblxuICAgICAgcG9sZXNSWzBdID0gZy5hZGQoIHBvbGVzUlswXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzBdICksIG91dHB1dFIgICApLCBjdXRvZmYgKSlcbiAgICAgIHBvbGVzUlsxXSA9IGcuYWRkKCBwb2xlc1JbMV0sIGcubXVsKCBnLmFkZCggZy5tdWwoLTEsIHBvbGVzUlsxXSApLCBwb2xlc1JbMF0gKSwgY3V0b2ZmICkpXG4gICAgICBwb2xlc1JbMl0gPSBnLmFkZCggcG9sZXNSWzJdLCBnLm11bCggZy5hZGQoIGcubXVsKC0xLCBwb2xlc1JbMl0gKSwgcG9sZXNSWzFdICksIGN1dG9mZiApKVxuICAgICAgcG9sZXNSWzNdID0gZy5hZGQoIHBvbGVzUlszXSwgZy5tdWwoIGcuYWRkKCBnLm11bCgtMSwgcG9sZXNSWzNdICksIHBvbGVzUlsyXSApLCBjdXRvZmYgKSlcblxuICAgICAgbGV0IHJpZ2h0ID0gZy5zd2l0Y2goIGlzTG93UGFzcywgcG9sZXNSWzNdLCBnLnN1Yiggb3V0cHV0UiwgcG9sZXNSWzNdICkgKVxuXG4gICAgICByZXR1cm5WYWx1ZSA9IFtsZWZ0LCByaWdodF1cbiAgICB9ZWxzZXtcbiAgICAgIHJldHVyblZhbHVlID0gbGVmdFxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICB9XG5cbiAgbGV0IEZpbHRlcjI0ID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgbGV0IGZpbHRlcjI0ICAgPSBPYmplY3QuY3JlYXRlKCBmaWx0ZXIgKVxuICAgIGxldCBwcm9wcyAgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBGaWx0ZXIyNC5kZWZhdWx0cywgZmlsdGVyLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBsZXQgaXNTdGVyZW8gPSBwcm9wcy5pbnB1dC5pc1N0ZXJlbyBcblxuICAgIGNvbnN0IF9fb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoXG4gICAgICBmaWx0ZXIyNCwgXG4gICAgICBHaWJiZXJpc2guZ2VuaXNoLmZpbHRlcjI0KCBnLmluKCdpbnB1dCcpLCBnLmluKCdRJyksIGcuaW4oJ2N1dG9mZicpLCBnLmluKCdpc0xvd1Bhc3MnKSwgaXNTdGVyZW8gKSwgXG4gICAgICBbJ2ZpbHRlcnMnLCdGaWx0ZXIyNENsYXNzaWMnXSxcbiAgICAgIHByb3BzXG4gICAgKVxuXG4gICAgcmV0dXJuIF9fb3V0XG4gIH1cblxuXG4gIEZpbHRlcjI0LmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgUTogLjI1LFxuICAgIGN1dG9mZjogODgwLFxuICAgIGlzTG93UGFzczoxXG4gIH1cblxuICByZXR1cm4gRmlsdGVyMjRcblxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgZyA9IEdpYmJlcmlzaC5nZW5pc2hcblxuICBjb25zdCBmaWx0ZXJzID0ge1xuICAgIEZpbHRlcjI0Q2xhc3NpYyA6IHJlcXVpcmUoICcuL2ZpbHRlcjI0LmpzJyAgKSggR2liYmVyaXNoICksXG4gICAgRmlsdGVyMjRNb29nICAgIDogcmVxdWlyZSggJy4vbGFkZGVyLmRzcC5qcycgKSggR2liYmVyaXNoICksXG4gICAgRmlsdGVyMjRUQjMwMyAgIDogcmVxdWlyZSggJy4vZGlvZGVGaWx0ZXJaREYuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIEZpbHRlcjEyQmlxdWFkICA6IHJlcXVpcmUoICcuL2JpcXVhZC5kc3AuanMnICAgICkoIEdpYmJlcmlzaCApLFxuICAgIEZpbHRlcjEyU1ZGICAgICA6IHJlcXVpcmUoICcuL3N2Zi5qcycgICAgICAgKSggR2liYmVyaXNoICksXG4gICAgXG4gICAgLy8gbm90IGZvciB1c2UgYnkgZW5kLXVzZXJzXG4gICAgZ2VuaXNoOiB7XG4gICAgICBDb21iICAgICAgICA6IHJlcXVpcmUoICcuL2NvbWJmaWx0ZXIuanMnICksXG4gICAgICBBbGxQYXNzICAgICA6IHJlcXVpcmUoICcuL2FsbHBhc3MuanMnIClcbiAgICB9LFxuXG4gICAgZmFjdG9yeSggaW5wdXQsIGN1dG9mZiwgc2F0dXJhdGlvbiwgX3Byb3BzLCBpc1N0ZXJlbyA9IGZhbHNlICkge1xuICAgICAgbGV0IGZpbHRlcmVkT3NjIFxuXG4gICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJzLmRlZmF1bHRzLCBfcHJvcHMgKVxuXG4gICAgICBzd2l0Y2goIHByb3BzLmZpbHRlck1vZGVsICkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBnLnpkMjQoIGlucHV0LCBnLm1pbiggZy5pbignUScpLCAuOTk5OSApLCBjdXRvZmYsIDAgKSAvLyBnLm1heCguMDA1LCBnLm1pbiggY3V0b2ZmLCAxICkgKSApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBmaWx0ZXJlZE9zYyA9IGcuZGlvZGVaREYoIGlucHV0LCBnLm1pbiggZy5pbignUScpLCAuOTk5OSApLCBjdXRvZmYsIHNhdHVyYXRpb24sIGlzU3RlcmVvICkgXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaWx0ZXJlZE9zYyA9IGcuc3ZmKCBpbnB1dCwgY3V0b2ZmLCBnLnN1YiggMSwgZy5pbignUScpKSwgcHJvcHMuZmlsdGVyTW9kZSwgaXNTdGVyZW8sIHRydWUgKSBcbiAgICAgICAgICBicmVhazsgXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBmaWx0ZXJlZE9zYyA9IGcuYmlxdWFkKCBpbnB1dCwgY3V0b2ZmLCAgZy5pbignUScpLCBwcm9wcy5maWx0ZXJNb2RlLCBpc1N0ZXJlbyApIFxuICAgICAgICAgIGJyZWFrOyBcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIC8vaXNMb3dQYXNzID0gZy5wYXJhbSggJ2xvd1Bhc3MnLCAxICksXG4gICAgICAgICAgZmlsdGVyZWRPc2MgPSBnLmZpbHRlcjI0KCBpbnB1dCwgZy5pbignUScpLCBjdXRvZmYsIHByb3BzLmZpbHRlck1vZGUsIGlzU3RlcmVvIClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyByZXR1cm4gdW5maWx0ZXJlZCBzaWduYWxcbiAgICAgICAgICBmaWx0ZXJlZE9zYyA9IGlucHV0IC8vZy5maWx0ZXIyNCggb3NjV2l0aEdhaW4sIGcuaW4oJ3Jlc29uYW5jZScpLCBjdXRvZmYsIGlzTG93UGFzcyApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWx0ZXJlZE9zY1xuICAgIH0sXG5cbiAgICBkZWZhdWx0czogeyBmaWx0ZXJNb2RlOiAwLCBmaWx0ZXJNb2RlbDowIH1cbiAgfVxuXG4gIGZpbHRlcnMuZXhwb3J0ID0gdGFyZ2V0ID0+IHtcbiAgICBmb3IoIGxldCBrZXkgaW4gZmlsdGVycyApIHtcbiAgICAgIGlmKCBrZXkgIT09ICdleHBvcnQnICYmIGtleSAhPT0gJ2dlbmlzaCcgKSB7XG4gICAgICAgIHRhcmdldFsga2V5IF0gPSBmaWx0ZXJzWyBrZXkgXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5yZXR1cm4gZmlsdGVyc1xuXG59XG4iLCJjb25zdCBnZW5pc2ggPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZmlsdGVyUHJvdG8gPSByZXF1aXJlKCAnLi9maWx0ZXIuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IG1ha2VDaGFubmVsID0gZnVuY3Rpb24oIGlucHV0LCBfUSwgX2ZyZXEgKSB7XG4gICAgJ3VzZSBqc2RzcCdcbiAgICBjb25zdCBpVCA9IDEgLyBnZW5pc2guZ2VuLnNhbXBsZXJhdGUsXG4gICAgICAgICAgeiAgPSBnZW5pc2guZGF0YShbIDAsMCwwLDAgXSwgMSwgeyBtZXRhOnRydWUgfSlcblxuICAgIGNvbnN0IGZyZXEgPSBnZW5pc2gubWF4KC4wMDUsIGdlbmlzaC5taW4oIF9mcmVxLCAxICkgKSBcbiAgICBjb25zdCBRID0gLjUgKyBfUSAqIDIzXG4gICAgLy8ga3dkID0gMiAqICRNX1BJICogYWNmW2tpbmR4XVxuICAgIGNvbnN0IGt3ZCA9ICggTWF0aC5QSSAqIDIgKSAqIGZyZXEgKiBnZW5pc2guZ2VuLnNhbXBsZXJhdGUgLyAyXG5cbiAgICAvLyBrd2EgPSAoMi9pVCkgKiB0YW4oa3dkICogaVQvMikgXG4gICAgY29uc3Qga3dhID0gMi9pVCAqIGdlbmlzaC50YW4oIGt3ZCAqIGlULzIgKVxuXG4gICAgLy8ga0cgID0ga3dhICogaVQvMiBcbiAgICBjb25zdCBrZyA9IGt3YSAqIGlULzJcblxuICAgIC8vIGtrID0gNC4wKihrUSAtIDAuNSkvKDI1LjAgLSAwLjUpXG4gICAgY29uc3Qga2sgPSA0ICogKFEgLSAuNSkgLyAyNC41XG5cbiAgICAvLyBrZ19wbHVzXzEgPSAoMS4wICsga2cpXG4gICAgY29uc3Qga2dfcGx1c18xID0gMSArIGtnXG5cbiAgICAvLyBrRyA9IGtnIC8ga2dfcGx1c18xIFxuICAgIGNvbnN0IGtHICAgICA9IGtnIC8ga2dfcGx1c18xLFxuICAgICAgICAgIGtHXzIgICA9IGtHICoga0csXG4gICAgICAgICAga0dfMyAgID0ga0dfMiAqIGtHLFxuICAgICAgICAgIGtHQU1NQSA9IGtHXzIgKiBrR18yXG5cbiAgICBjb25zdCBrUzEgPSB6WzBdIC8ga2dfcGx1c18xLFxuICAgICAgICAgIGtTMiA9IHpbMV0gLyBrZ19wbHVzXzEsXG4gICAgICAgICAga1MzID0gelsyXSAvIGtnX3BsdXNfMSxcbiAgICAgICAgICBrUzQgPSB6WzNdIC8ga2dfcGx1c18xXG5cbiAgICAvL2tTID0ga0dfMyAqIGtTMSAgKyBrR18yICoga1MyICsga0cgKiBrUzMgKyBrUzQgXG4gICAgY29uc3Qga1MgPSBrR18zICoga1MxICsga0dfMiAqIGtTMiArIGtHICoga1MzICsga1M0XG5cbiAgICAvL2t1ID0gKGtpbiAtIGtrICogIGtTKSAvICgxICsga2sgKiBrR0FNTUEpXG4gICAgY29uc3Qga3UgID0gKGlucHV0IC0ga2sgKiBrUykgLyAoMSArIGtrICoga0dBTU1BKVxuXG4gICAgbGV0IGt2ID0gICgga3UgLSB6WzBdICkgKiBrR1xuICAgIGxldCBrbHAgPSBrdiArIHpbMF1cbiAgICB6WzBdID0ga2xwICsga3ZcblxuICAgIGt2ICA9ICgga2xwIC0gelsxXSApICoga0dcbiAgICBrbHAgPSBrdiArIHpbMV1cbiAgICB6WzFdID0ga2xwICsga3ZcblxuICAgIGt2ICA9IChrbHAgLSB6WzJdICkgKiBrR1xuICAgIGtscCA9IGt2ICsgelsyXVxuICAgIHpbMl0gPSBrbHAgKyBrdlxuXG4gICAga3YgID0gKGtscCAtIHpbM10gKSAqIGtHXG4gICAga2xwID0ga3YgKyB6WzNdXG4gICAgelszXSA9IGtscCArIGt2XG5cbiAgICByZXR1cm4ga2xwXG4gIH1cblxuICBHaWJiZXJpc2guZ2VuaXNoLnpkMjQgPSAoIGlucHV0LCBfUSwgZnJlcSwgaXNTdGVyZW89ZmFsc2UgKSA9PiB7XG4gICAgY29uc3QgbGVmdElucHV0ID0gaXNTdGVyZW8gPT09IHRydWUgPyBpbnB1dFswXSA6IGlucHV0XG4gICAgY29uc3QgbGVmdCA9IG1ha2VDaGFubmVsKCBsZWZ0SW5wdXQsIF9RLCBmcmVxIClcblxuICAgIGxldCBvdXRcbiAgICBpZiggaXNTdGVyZW8gPT09IHRydWUgKSB7XG4gICAgICBjb25zdCByaWdodCA9IG1ha2VDaGFubmVsKCBpbnB1dFsxXSwgX1EsIGZyZXEgKVxuICAgICAgb3V0ID0gWyBsZWZ0LCByaWdodCBdXG4gICAgfWVsc2V7XG4gICAgICBvdXQgPSBsZWZ0XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgY29uc3QgWmQyNCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IGZpbHRlciAgID0gT2JqZWN0LmNyZWF0ZSggZmlsdGVyUHJvdG8gKVxuICAgIGNvbnN0IHByb3BzICAgID0gT2JqZWN0LmFzc2lnbigge30sIFpkMjQuZGVmYXVsdHMsIGZpbHRlci5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgbGV0IG91dFxuXG4gICAgZmlsdGVyLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cbiAgICBmaWx0ZXIuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaXNTdGVyZW8gPSBwcm9wcy5pbnB1dCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSB1bmRlZmluZWQgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgICB9XG5cbiAgICAgIGZpbHRlci5ncmFwaCA9IEdpYmJlcmlzaC5nZW5pc2guemQyNCggZ2VuaXNoLmluKCdpbnB1dCcpLCBnZW5pc2guaW4oJ1EnKSwgZ2VuaXNoLmluKCdjdXRvZmYnKSwgaXNTdGVyZW8gKSBcbiAgICB9IFxuXG4gICAgZmlsdGVyLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoXG4gICAgICBmaWx0ZXIsIFxuICAgICAgZmlsdGVyLmdyYXBoLCBcbiAgICAgIFsnZmlsdGVycycsJ0ZpbHRlcjI0TW9vZyddLFxuICAgICAgcHJvcHNcbiAgICApXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBaZDI0LmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgUTogLjc1LFxuICAgIGN1dG9mZjogLjI1LFxuICB9XG5cbiAgcmV0dXJuIFpkMjRcblxufVxuXG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGZpbHRlciA9IHJlcXVpcmUoICcuL2ZpbHRlci5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIEdpYmJlcmlzaC5nZW5pc2guc3ZmID0gKCBpbnB1dCwgY3V0b2ZmLCBRLCBtb2RlLCBpc1N0ZXJlbz1mYWxzZSwgc2hvdWxkQ29udmVydEZyZXFRPWZhbHNlICkgPT4ge1xuICAgIGxldCBkMSA9IGcuZGF0YShbMCwwXSwgMSwgeyBtZXRhOnRydWUgfSksIGQyID0gZy5kYXRhKFswLDBdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgcGVla1Byb3BzID0geyBtb2RlOidzaW1wbGUnLCBpbnRlcnA6J25vbmUnIH1cblxuICAgIGlmKCBzaG91bGRDb252ZXJ0RnJlcVEgPT09IHRydWUgKSB7XG4gICAgICAvL1EgPSBnLm1pbiggZy5hZGQoLjAxICwgX19RKSwgMSApIFxuICAgICAgY3V0b2ZmID0gZy5tdWwoIGcubWF4KCAuMDA1LCBnLm1pbiggY3V0b2ZmLC45OTUgKSApLCBnLmRpdiggZy5nZW4uc2FtcGxlcmF0ZSwgNCApIClcbiAgICB9XG5cbiAgICBsZXQgZjEgPSBnLm1lbW8oIGcubXVsKCAyICogTWF0aC5QSSwgZy5kaXYoIGN1dG9mZiwgZy5nZW4uc2FtcGxlcmF0ZSApICkgKVxuICAgIGxldCBvbmVPdmVyUSA9IGcubWVtbyggZy5kaXYoIDEsIFEgKSApXG4gICAgbGV0IGwgPSBnLm1lbW8oIGcuYWRkKCBkMlswXSwgZy5tdWwoIGYxLCBkMVswXSApICkgKSxcbiAgICAgICAgaCA9IGcubWVtbyggZy5zdWIoIGcuc3ViKCBpc1N0ZXJlbyA/IGlucHV0WzBdIDogaW5wdXQsIGwgKSwgZy5tdWwoIFEsIGQxWzBdICkgKSApLFxuICAgICAgICBiID0gZy5tZW1vKCBnLmFkZCggZy5tdWwoIGYxLCBoICksIGQxWzBdICkgKSxcbiAgICAgICAgbiA9IGcubWVtbyggZy5hZGQoIGgsIGwgKSApXG5cbiAgICBkMVswXSA9IGJcbiAgICBkMlswXSA9IGxcblxuICAgIGxldCBvdXQgPSBnLnNlbGVjdG9yKCBtb2RlLCBsLCBoLCBiLCBuIClcblxuICAgIGxldCByZXR1cm5WYWx1ZVxuICAgIGlmKCBpc1N0ZXJlbyApIHtcbiAgICAgIGxldCBkMTIgPSBnLmRhdGEoWzAsMF0sIDEsIHsgbWV0YTp0cnVlIH0pLCBkMjIgPSBnLmRhdGEoWzAsMF0sIDEsIHsgbWV0YTp0cnVlIH0pXG4gICAgICBsZXQgbDIgPSBnLm1lbW8oIGcuYWRkKCBkMjJbMF0sIGcubXVsKCBmMSwgZDEyWzBdICkgKSApLFxuICAgICAgICAgIGgyID0gZy5tZW1vKCBnLnN1YiggZy5zdWIoIGlucHV0WzFdLCBsMiApLCBnLm11bCggUSwgZDEyWzBdICkgKSApLFxuICAgICAgICAgIGIyID0gZy5tZW1vKCBnLmFkZCggZy5tdWwoIGYxLCBoMiApLCBkMTJbMF0gKSApLFxuICAgICAgICAgIG4yID0gZy5tZW1vKCBnLmFkZCggaDIsIGwyICkgKVxuXG4gICAgICBkMTJbMF0gPSBiMlxuICAgICAgZDIyWzBdID0gbDJcblxuICAgICAgbGV0IG91dDIgPSBnLnNlbGVjdG9yKCBtb2RlLCBsMiwgaDIsIGIyLCBuMiApXG5cbiAgICAgIHJldHVyblZhbHVlID0gWyBvdXQsIG91dDIgXVxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuVmFsdWUgPSBvdXRcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgfVxuXG4gIGxldCBTVkYgPSBpbnB1dFByb3BzID0+IHtcbiAgICBjb25zdCBzdmYgPSBPYmplY3QuY3JlYXRlKCBmaWx0ZXIgKVxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIFNWRi5kZWZhdWx0cywgZmlsdGVyLmRlZmF1bHRzLCBpbnB1dFByb3BzICkgXG5cbiAgICBjb25zdCBpc1N0ZXJlbyA9IHByb3BzLmlucHV0LmlzU3RlcmVvXG4gICAgXG4gICAgLy8gWFhYIE5FRURTIFJFRkFDVE9SSU5HXG4gICAgY29uc3QgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBzdmYsXG4gICAgICAvL0dpYmJlcmlzaC5nZW5pc2guc3ZmKCBnLmluKCdpbnB1dCcpLCBnLm11bCggZy5pbignY3V0b2ZmJyksIGcuZ2VuLnNhbXBsZXJhdGUgLyA1ICksIGcuc3ViKCAxLCBnLmluKCdRJykgKSwgZy5pbignbW9kZScpLCBpc1N0ZXJlbyApLCBcbiAgICAgIEdpYmJlcmlzaC5nZW5pc2guc3ZmKCBnLmluKCdpbnB1dCcpLCBnLm11bCggZy5pbignY3V0b2ZmJyksIGcuZ2VuLnNhbXBsZXJhdGUgLyA1ICksIGcuc3ViKCAxLCBnLmluKCdRJykgKSwgZy5pbignbW9kZScpLCBpc1N0ZXJlbywgdHJ1ZSApLCBcbiAgICAgIFsnZmlsdGVycycsJ0ZpbHRlcjEyU1ZGJ10sIFxuICAgICAgcHJvcHNcbiAgICApXG5cbiAgICByZXR1cm4gX19vdXRcbiAgfVxuXG5cbiAgU1ZGLmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgUTogLjY1LFxuICAgIGN1dG9mZjouMjUsXG4gICAgbW9kZTowXG4gIH1cblxuICByZXR1cm4gU1ZGXG5cbn1cblxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgQml0Q3J1c2hlciA9IGlucHV0UHJvcHMgPT4ge1xuICBjb25zdCAgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7IGJpdENydXNoZXJMZW5ndGg6IDQ0MTAwIH0sIEJpdENydXNoZXIuZGVmYXVsdHMsIGVmZmVjdC5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICAgYml0Q3J1c2hlciA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApXG5cbiAgbGV0IG91dFxuXG4gIGJpdENydXNoZXIuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH1cblxuICAgIGxldCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgYml0RGVwdGggPSBnLmluKCAnYml0RGVwdGgnICksXG4gICAgICAgIHNhbXBsZVJhdGUgPSBnLmluKCAnc2FtcGxlUmF0ZScgKSxcbiAgICAgICAgbGVmdElucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFsgMCBdIDogaW5wdXQsXG4gICAgICAgIHJpZ2h0SW5wdXQgPSBpc1N0ZXJlbyA/IGlucHV0WyAxIF0gOiBudWxsXG4gICAgXG4gICAgbGV0IHN0b3JlTCA9IGcuaGlzdG9yeSgwKVxuICAgIGxldCBzYW1wbGVSZWR1eENvdW50ZXIgPSBnLmNvdW50ZXIoIHNhbXBsZVJhdGUsIDAsIDEgKVxuXG4gICAgbGV0IGJpdE11bHQgPSBnLnBvdyggZy5tdWwoIGJpdERlcHRoLCAxNiApLCAyIClcbiAgICBsZXQgY3J1c2hlZEwgPSBnLmRpdiggZy5mbG9vciggZy5tdWwoIGcubXVsKCBsZWZ0SW5wdXQsIGlucHV0R2FpbiApLCBiaXRNdWx0ICkgKSwgYml0TXVsdCApXG5cbiAgICBsZXQgb3V0TCA9IGcuc3dpdGNoKFxuICAgICAgc2FtcGxlUmVkdXhDb3VudGVyLndyYXAsXG4gICAgICBjcnVzaGVkTCxcbiAgICAgIHN0b3JlTC5vdXRcbiAgICApXG5cbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICBsZXQgc3RvcmVSID0gZy5oaXN0b3J5KDApXG4gICAgICBsZXQgY3J1c2hlZFIgPSBnLmRpdiggZy5mbG9vciggZy5tdWwoIGcubXVsKCByaWdodElucHV0LCBpbnB1dEdhaW4gKSwgYml0TXVsdCApICksIGJpdE11bHQgKVxuXG4gICAgICBsZXQgb3V0UiA9IGcuc3dpdGNoKCBcbiAgICAgICAgc2FtcGxlUmVkdXhDb3VudGVyLndyYXAsXG4gICAgICAgIGNydXNoZWRSLFxuICAgICAgICBzdG9yZUwub3V0XG4gICAgICApXG5cbiAgICAgIGJpdENydXNoZXIuZ3JhcGggPSBbIG91dEwsIG91dFIgXVxuICAgIH1lbHNle1xuICAgICAgYml0Q3J1c2hlci5ncmFwaCA9IG91dExcbiAgICB9XG4gIH1cblxuICBiaXRDcnVzaGVyLl9fY3JlYXRlR3JhcGgoKVxuICBiaXRDcnVzaGVyLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgYml0Q3J1c2hlcixcbiAgICBiaXRDcnVzaGVyLmdyYXBoLFxuICAgIFsnZngnLCdiaXRDcnVzaGVyJ10sIFxuICAgIHByb3BzIFxuICApXG4gIHJldHVybiBvdXQgXG59XG5cbkJpdENydXNoZXIuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGJpdERlcHRoOi41LFxuICBzYW1wbGVSYXRlOiAuNVxufVxuXG5yZXR1cm4gQml0Q3J1c2hlclxuXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgbGV0IHByb3RvID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0IClcblxuICBsZXQgU2h1ZmZsZXIgPSBpbnB1dFByb3BzID0+IHtcbiAgICBsZXQgYnVmZmVyU2h1ZmZsZXIgPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgICBidWZmZXJTaXplID0gODgyMDBcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIFNodWZmbGVyLmRlZmF1bHRzLCBlZmZlY3QuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIFxuICAgIGxldCBvdXRcbiAgICBidWZmZXJTaHVmZmxlci5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IHRydWUgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICAgICAgLy9vdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgICAgfSAgICAgIFxuICAgICAgXG4gICAgICBjb25zdCBwaGFzZSA9IGcuYWNjdW0oIDEsMCx7IHNob3VsZFdyYXA6IGZhbHNlIH0pXG5cbiAgICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICAgIF9fbGVmdElucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFsgMCBdIDogaW5wdXQsXG4gICAgICAgICAgICBfX3JpZ2h0SW5wdXQgPSBpc1N0ZXJlbyA/IGlucHV0WyAxIF0gOiBudWxsLFxuICAgICAgICAgICAgbGVmdElucHV0ID0gZy5tdWwoIF9fbGVmdElucHV0LCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICAgIHJpZ2h0SW5wdXQgPSBnLm11bCggX19yaWdodElucHV0LCBpbnB1dEdhaW4gKSxcbiAgICAgICAgICAgIHJhdGVPZlNodWZmbGluZyA9IGcuaW4oICdyYXRlJyApLFxuICAgICAgICAgICAgY2hhbmNlT2ZTaHVmZmxpbmcgPSBnLmluKCAnY2hhbmNlJyApLFxuICAgICAgICAgICAgcmV2ZXJzZUNoYW5jZSA9IGcuaW4oICdyZXZlcnNlQ2hhbmNlJyApLFxuICAgICAgICAgICAgcmVwaXRjaENoYW5jZSA9IGcuaW4oICdyZXBpdGNoQ2hhbmNlJyApLFxuICAgICAgICAgICAgcmVwaXRjaE1pbiA9IGcuaW4oICdyZXBpdGNoTWluJyApLFxuICAgICAgICAgICAgcmVwaXRjaE1heCA9IGcuaW4oICdyZXBpdGNoTWF4JyApXG5cbiAgICAgIGxldCBwaXRjaE1lbW9yeSA9IGcuaGlzdG9yeSgxKVxuXG4gICAgICBsZXQgc2hvdWxkU2h1ZmZsZUNoZWNrID0gZy5lcSggZy5tb2QoIHBoYXNlLCByYXRlT2ZTaHVmZmxpbmcgKSwgMCApXG4gICAgICBsZXQgaXNTaHVmZmxpbmcgPSBnLm1lbW8oIGcuc2FoKCBnLmx0KCBnLm5vaXNlKCksIGNoYW5jZU9mU2h1ZmZsaW5nICksIHNob3VsZFNodWZmbGVDaGVjaywgMCApICkgXG5cbiAgICAgIC8vIGlmIHdlIGFyZSBzaHVmZmxpbmcgYW5kIG9uIGEgcmVwZWF0IGJvdW5kYXJ5Li4uXG4gICAgICBsZXQgc2h1ZmZsZUNoYW5nZWQgPSBnLm1lbW8oIGcuYW5kKCBzaG91bGRTaHVmZmxlQ2hlY2ssIGlzU2h1ZmZsaW5nICkgKVxuICAgICAgbGV0IHNob3VsZFJldmVyc2UgPSBnLmx0KCBnLm5vaXNlKCksIHJldmVyc2VDaGFuY2UgKSxcbiAgICAgICAgICByZXZlcnNlTW9kID0gZy5zd2l0Y2goIHNob3VsZFJldmVyc2UsIC0xLCAxIClcblxuICAgICAgbGV0IHBpdGNoID0gZy5pZmVsc2UoIFxuICAgICAgICBnLmFuZCggc2h1ZmZsZUNoYW5nZWQsIGcubHQoIGcubm9pc2UoKSwgcmVwaXRjaENoYW5jZSApICksXG4gICAgICAgIGcubWVtbyggZy5tdWwoIGcuYWRkKCByZXBpdGNoTWluLCBnLm11bCggZy5zdWIoIHJlcGl0Y2hNYXgsIHJlcGl0Y2hNaW4gKSwgZy5ub2lzZSgpICkgKSwgcmV2ZXJzZU1vZCApICksXG4gICAgICAgIHJldmVyc2VNb2RcbiAgICAgIClcbiAgICAgIFxuICAgICAgLy8gb25seSBzd2l0Y2ggcGl0Y2hlcyBvbiByZXBlYXQgYm91bmRhcmllc1xuICAgICAgcGl0Y2hNZW1vcnkuaW4oIGcuc3dpdGNoKCBzaHVmZmxlQ2hhbmdlZCwgcGl0Y2gsIHBpdGNoTWVtb3J5Lm91dCApIClcblxuICAgICAgbGV0IGZhZGVMZW5ndGggPSBnLm1lbW8oIGcuZGl2KCByYXRlT2ZTaHVmZmxpbmcsIDEwMCApICksXG4gICAgICAgICAgZmFkZUluY3IgPSBnLm1lbW8oIGcuZGl2KCAxLCBmYWRlTGVuZ3RoICkgKVxuXG4gICAgICBjb25zdCBidWZmZXJMID0gZy5kYXRhKCBidWZmZXJTaXplIClcbiAgICAgIGNvbnN0IGJ1ZmZlclIgPSBpc1N0ZXJlbyA/IGcuZGF0YSggYnVmZmVyU2l6ZSApIDogbnVsbFxuICAgICAgbGV0IHJlYWRQaGFzZSA9IGcuYWNjdW0oIHBpdGNoTWVtb3J5Lm91dCwgMCwgeyBzaG91bGRXcmFwOmZhbHNlIH0pIFxuICAgICAgbGV0IHN0dXR0ZXIgPSBnLndyYXAoIGcuc3ViKCBnLm1vZCggcmVhZFBoYXNlLCBidWZmZXJTaXplICksIDIyMDUwICksIDAsIGJ1ZmZlclNpemUgKVxuXG4gICAgICBsZXQgbm9ybWFsU2FtcGxlID0gZy5wZWVrKCBidWZmZXJMLCBnLmFjY3VtKCAxLCAwLCB7IG1heDo4ODIwMCB9KSwgeyBtb2RlOidzaW1wbGUnIH0pXG5cbiAgICAgIGxldCBzdHV0dGVyU2FtcGxlUGhhc2UgPSBnLnN3aXRjaCggaXNTaHVmZmxpbmcsIHN0dXR0ZXIsIGcubW9kKCByZWFkUGhhc2UsIGJ1ZmZlclNpemUgKSApXG4gICAgICBsZXQgc3R1dHRlclNhbXBsZSA9IGcubWVtbyggZy5wZWVrKCBcbiAgICAgICAgYnVmZmVyTCwgXG4gICAgICAgIHN0dXR0ZXJTYW1wbGVQaGFzZSxcbiAgICAgICAgeyBtb2RlOidzYW1wbGVzJyB9XG4gICAgICApIClcbiAgICAgIFxuICAgICAgbGV0IHN0dXR0ZXJTaG91bGRGYWRlSW4gPSBnLmFuZCggc2h1ZmZsZUNoYW5nZWQsIGlzU2h1ZmZsaW5nIClcbiAgICAgIGxldCBzdHV0dGVyUGhhc2UgPSBnLmFjY3VtKCAxLCBzaHVmZmxlQ2hhbmdlZCwgeyBzaG91bGRXcmFwOiBmYWxzZSB9KVxuXG4gICAgICBsZXQgZmFkZUluQW1vdW50ID0gZy5tZW1vKCBnLmRpdiggc3R1dHRlclBoYXNlLCBmYWRlTGVuZ3RoICkgKVxuICAgICAgbGV0IGZhZGVPdXRBbW91bnQgPSBnLmRpdiggZy5zdWIoIHJhdGVPZlNodWZmbGluZywgc3R1dHRlclBoYXNlICksIGcuc3ViKCByYXRlT2ZTaHVmZmxpbmcsIGZhZGVMZW5ndGggKSApXG4gICAgICBcbiAgICAgIGxldCBmYWRlZFN0dXR0ZXIgPSBnLmlmZWxzZShcbiAgICAgICAgZy5sdCggc3R1dHRlclBoYXNlLCBmYWRlTGVuZ3RoICksXG4gICAgICAgIGcubWVtbyggZy5tdWwoIGcuc3dpdGNoKCBnLmx0KCBmYWRlSW5BbW91bnQsIDEgKSwgZmFkZUluQW1vdW50LCAxICksIHN0dXR0ZXJTYW1wbGUgKSApLFxuICAgICAgICBnLmd0KCBzdHV0dGVyUGhhc2UsIGcuc3ViKCByYXRlT2ZTaHVmZmxpbmcsIGZhZGVMZW5ndGggKSApLFxuICAgICAgICBnLm1lbW8oIGcubXVsKCBnLmd0cCggZmFkZU91dEFtb3VudCwgMCApLCBzdHV0dGVyU2FtcGxlICkgKSxcbiAgICAgICAgc3R1dHRlclNhbXBsZVxuICAgICAgKVxuICAgICAgXG4gICAgICBsZXQgb3V0cHV0TCA9IGcubWl4KCBub3JtYWxTYW1wbGUsIGZhZGVkU3R1dHRlciwgaXNTaHVmZmxpbmcgKSBcblxuICAgICAgbGV0IHBva2VMID0gZy5wb2tlKCBidWZmZXJMLCBsZWZ0SW5wdXQsIGcubW9kKCBnLmFkZCggcGhhc2UsIDQ0MTAwICksIDg4MjAwICkgKVxuXG4gICAgICBsZXQgcGFubmVyID0gZy5wYW4oIG91dHB1dEwsIG91dHB1dEwsIGcuaW4oICdwYW4nICkgKVxuICAgICAgXG4gICAgICBidWZmZXJTaHVmZmxlci5ncmFwaCA9IFsgcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodCBdXG4gICAgfVxuXG4gICAgYnVmZmVyU2h1ZmZsZXIuX19jcmVhdGVHcmFwaCgpXG4gICAgYnVmZmVyU2h1ZmZsZXIuX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuICAgIFxuICAgIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICAgIGJ1ZmZlclNodWZmbGVyLFxuICAgICAgYnVmZmVyU2h1ZmZsZXIuZ3JhcGgsXG4gICAgICBbJ2Z4Jywnc2h1ZmZsZXInXSwgXG4gICAgICBwcm9wcyBcbiAgICApXG5cbiAgICByZXR1cm4gb3V0IFxuICB9XG4gIFxuICBTaHVmZmxlci5kZWZhdWx0cyA9IHtcbiAgICBpbnB1dDowLFxuICAgIHJhdGU6MjIwNTAsXG4gICAgY2hhbmNlOi4yNSxcbiAgICByZXZlcnNlQ2hhbmNlOi41LFxuICAgIHJlcGl0Y2hDaGFuY2U6LjUsXG4gICAgcmVwaXRjaE1pbjouNSxcbiAgICByZXBpdGNoTWF4OjIsXG4gICAgcGFuOi41LFxuICAgIG1peDouNVxuICB9XG5cbiAgcmV0dXJuIFNodWZmbGVyIFxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcbiAgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgX19DaG9ydXMgPSBpbnB1dFByb3BzID0+IHtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBfX0Nob3J1cy5kZWZhdWx0cywgZWZmZWN0LmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgbGV0IG91dFxuICBcbiAgY29uc3QgY2hvcnVzID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0IClcblxuICBjaG9ydXMuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGlucHV0ID0gZy5pbignaW5wdXQnKSxcbiAgICAgICAgICBpbnB1dEdhaW4gPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgIGZyZXExID0gZy5pbignc2xvd0ZyZXF1ZW5jeScpLFxuICAgICAgICAgIGZyZXEyID0gZy5pbignZmFzdEZyZXF1ZW5jeScpLFxuICAgICAgICAgIGFtcDEgID0gZy5pbignc2xvd0dhaW4nKSxcbiAgICAgICAgICBhbXAyICA9IGcuaW4oJ2Zhc3RHYWluJylcblxuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH1cblxuICAgIGNvbnN0IGxlZnRJbnB1dCA9IGlzU3RlcmVvID8gZy5tdWwoIGlucHV0WzBdLCBpbnB1dEdhaW4gKSA6IGcubXVsKCBpbnB1dCwgaW5wdXRHYWluIClcblxuICAgIGNvbnN0IHdpbjAgICA9IGcuZW52KCAnaW52ZXJzZXdlbGNoJywgMTAyNCApLFxuICAgICAgICAgIHdpbjEyMCA9IGcuZW52KCAnaW52ZXJzZXdlbGNoJywgMTAyNCwgMCwgLjMzMyApLFxuICAgICAgICAgIHdpbjI0MCA9IGcuZW52KCAnaW52ZXJzZXdlbGNoJywgMTAyNCwgMCwgLjY2NiApXG4gICAgXG4gICAgY29uc3Qgc2xvd1BoYXNvciA9IGcucGhhc29yKCBmcmVxMSwgMCwgeyBtaW46MCB9KSxcbiAgICAgICAgICBzbG93UGVlazEgID0gZy5tdWwoIGcucGVlayggd2luMCwgICBzbG93UGhhc29yICksIGFtcDEgKSxcbiAgICAgICAgICBzbG93UGVlazIgID0gZy5tdWwoIGcucGVlayggd2luMTIwLCBzbG93UGhhc29yICksIGFtcDEgKSxcbiAgICAgICAgICBzbG93UGVlazMgID0gZy5tdWwoIGcucGVlayggd2luMjQwLCBzbG93UGhhc29yICksIGFtcDEgKVxuICAgIFxuICAgIGNvbnN0IGZhc3RQaGFzb3IgPSBnLnBoYXNvciggZnJlcTIsIDAsIHsgbWluOjAgfSksXG4gICAgICAgICAgZmFzdFBlZWsxICA9IGcubXVsKCBnLnBlZWsoIHdpbjAsICAgZmFzdFBoYXNvciApLCBhbXAyICksXG4gICAgICAgICAgZmFzdFBlZWsyICA9IGcubXVsKCBnLnBlZWsoIHdpbjEyMCwgZmFzdFBoYXNvciApLCBhbXAyICksXG4gICAgICAgICAgZmFzdFBlZWszICA9IGcubXVsKCBnLnBlZWsoIHdpbjI0MCwgZmFzdFBoYXNvciApLCBhbXAyIClcblxuXG4gICAgbGV0IHNhbXBsZVJhdGUgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGVcbiAgICAgXG4gICAgY29uc3QgbXMgPSBzYW1wbGVSYXRlIC8gMTAwMCBcbiAgICBjb25zdCBtYXhEZWxheVRpbWUgPSAxMDAwICogbXNcblxuICAgIC8vY29uc29sZS5sb2coICdzcjonLCBzYW1wbGVSYXRlLCAnbXM6JywgbXMsICdtYXhEZWxheVRpbWU6JywgbWF4RGVsYXlUaW1lIClcblxuICAgIGNvbnN0IHRpbWUxID0gIGcubXVsKCBnLmFkZCggc2xvd1BlZWsxLCBmYXN0UGVlazEsIDUgKSwgbXMgKSxcbiAgICAgICAgICB0aW1lMiA9ICBnLm11bCggZy5hZGQoIHNsb3dQZWVrMiwgZmFzdFBlZWsyLCA1ICksIG1zICksXG4gICAgICAgICAgdGltZTMgPSAgZy5tdWwoIGcuYWRkKCBzbG93UGVlazMsIGZhc3RQZWVrMywgNSApLCBtcyApXG5cbiAgICBjb25zdCBkZWxheTFMID0gZy5kZWxheSggbGVmdElucHV0LCB0aW1lMSwgeyBzaXplOm1heERlbGF5VGltZSB9KSxcbiAgICAgICAgICBkZWxheTJMID0gZy5kZWxheSggbGVmdElucHV0LCB0aW1lMiwgeyBzaXplOm1heERlbGF5VGltZSB9KSxcbiAgICAgICAgICBkZWxheTNMID0gZy5kZWxheSggbGVmdElucHV0LCB0aW1lMywgeyBzaXplOm1heERlbGF5VGltZSB9KVxuXG4gICAgXG4gICAgY29uc3QgbGVmdE91dHB1dCA9IGcuYWRkKCBkZWxheTFMLCBkZWxheTJMLCBkZWxheTNMIClcbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICBjb25zdCByaWdodElucHV0ID0gZy5tdWwoIGlucHV0WzFdLCBpbnB1dEdhaW4gKVxuICAgICAgY29uc3QgZGVsYXkxUiA9IGcuZGVsYXkocmlnaHRJbnB1dCwgdGltZTEsIHsgc2l6ZTptYXhEZWxheVRpbWUgfSksXG4gICAgICAgICAgICBkZWxheTJSID0gZy5kZWxheShyaWdodElucHV0LCB0aW1lMiwgeyBzaXplOm1heERlbGF5VGltZSB9KSxcbiAgICAgICAgICAgIGRlbGF5M1IgPSBnLmRlbGF5KHJpZ2h0SW5wdXQsIHRpbWUzLCB7IHNpemU6bWF4RGVsYXlUaW1lIH0pXG5cbiAgICAgIC8vIGZsaXAgYSBjb3VwbGUgZGVsYXkgbGluZXMgZm9yIHN0ZXJlbyBlZmZlY3Q/XG4gICAgICBjb25zdCByaWdodE91dHB1dCA9IGcuYWRkKCBkZWxheTFSLCBkZWxheTJMLCBkZWxheTNSIClcbiAgICAgIGNob3J1cy5ncmFwaCA9IFsgZy5hZGQoIGRlbGF5MUwsIGRlbGF5MlIsIGRlbGF5M0wpLCByaWdodE91dHB1dCBdXG4gICAgfWVsc2V7XG4gICAgICBjaG9ydXMuZ3JhcGggPSBsZWZ0T3V0cHV0XG4gICAgfVxuICB9XG5cbiAgY2hvcnVzLl9fY3JlYXRlR3JhcGgoKVxuICBjaG9ydXMuX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuXG4gIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBjaG9ydXMsIGNob3J1cy5ncmFwaCwgWydmeCcsJ2Nob3J1cyddLCBwcm9wcyApXG5cbiAgcmV0dXJuIG91dCBcbn1cblxuX19DaG9ydXMuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIHNsb3dGcmVxdWVuY3k6IC4xOCxcbiAgc2xvd0dhaW46MyxcbiAgZmFzdEZyZXF1ZW5jeTo2LFxuICBmYXN0R2FpbjoxLFxuICBpbnB1dEdhaW46MVxufVxuXG5yZXR1cm4gX19DaG9ydXNcblxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgRGVsYXkgPSBpbnB1dFByb3BzID0+IHtcbiAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBkZWxheUxlbmd0aDogODgyMDAgfSwgZWZmZWN0LmRlZmF1bHRzLCBEZWxheS5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgZGVsYXkgPSBPYmplY3QuY3JlYXRlKCBlZmZlY3QgKVxuXG4gIGxldCBvdXRcbiAgZGVsYXkuX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH0gICAgXG5cbiAgICBjb25zdCBpbnB1dCAgICAgID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgIGlucHV0R2FpbiAgPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgIGRlbGF5VGltZSAgPSBnLmluKCAndGltZScgKSxcbiAgICAgICAgICB3ZXRkcnkgICAgID0gZy5pbiggJ3dldGRyeScgKSxcbiAgICAgICAgICBsZWZ0SW5wdXQgID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbIDAgXSwgaW5wdXRHYWluICkgOiBnLm11bCggaW5wdXQsIGlucHV0R2FpbiApLFxuICAgICAgICAgIHJpZ2h0SW5wdXQgPSBpc1N0ZXJlbyA/IGcubXVsKCBpbnB1dFsgMSBdLCBpbnB1dEdhaW4gKSA6IG51bGxcbiAgICAgIFxuICAgIGNvbnN0IGZlZWRiYWNrID0gZy5pbiggJ2ZlZWRiYWNrJyApXG5cbiAgICAvLyBsZWZ0IGNoYW5uZWxcbiAgICBjb25zdCBmZWVkYmFja0hpc3RvcnlMID0gZy5oaXN0b3J5KClcbiAgICBjb25zdCBlY2hvTCA9IGcuZGVsYXkoIGcuYWRkKCBsZWZ0SW5wdXQsIGcubXVsKCBmZWVkYmFja0hpc3RvcnlMLm91dCwgZmVlZGJhY2sgKSApLCBkZWxheVRpbWUsIHsgc2l6ZTpwcm9wcy5kZWxheUxlbmd0aCB9KVxuICAgIGZlZWRiYWNrSGlzdG9yeUwuaW4oIGVjaG9MIClcbiAgICBjb25zdCBsZWZ0ID0gZy5taXgoIGxlZnRJbnB1dCwgZWNob0wsIHdldGRyeSApXG5cbiAgICBpZiggaXNTdGVyZW8gKSB7XG4gICAgICAvLyByaWdodCBjaGFubmVsXG4gICAgICBjb25zdCBmZWVkYmFja0hpc3RvcnlSID0gZy5oaXN0b3J5KClcbiAgICAgIGNvbnN0IGVjaG9SID0gZy5kZWxheSggZy5hZGQoIHJpZ2h0SW5wdXQsIGcubXVsKCBmZWVkYmFja0hpc3RvcnlSLm91dCwgZmVlZGJhY2sgKSApLCBkZWxheVRpbWUsIHsgc2l6ZTpwcm9wcy5kZWxheUxlbmd0aCB9KVxuICAgICAgZmVlZGJhY2tIaXN0b3J5Ui5pbiggZWNob1IgKVxuICAgICAgY29uc3QgcmlnaHQgPSBnLm1peCggcmlnaHRJbnB1dCwgZWNob1IsIHdldGRyeSApXG5cbiAgICAgIGRlbGF5LmdyYXBoID0gWyBsZWZ0LCByaWdodCBdXG4gICAgfWVsc2V7XG4gICAgICBkZWxheS5ncmFwaCA9IGxlZnQgXG4gICAgfVxuICB9XG5cbiAgZGVsYXkuX19jcmVhdGVHcmFwaCgpXG4gIGRlbGF5Ll9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cbiAgXG4gIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICBkZWxheSxcbiAgICBkZWxheS5ncmFwaCwgXG4gICAgWydmeCcsJ2RlbGF5J10sIFxuICAgIHByb3BzIFxuICApXG5cbiAgcmV0dXJuIG91dFxufVxuXG5EZWxheS5kZWZhdWx0cyA9IHtcbiAgaW5wdXQ6MCxcbiAgZmVlZGJhY2s6LjUsXG4gIHRpbWU6IDExMDI1LFxuICB3ZXRkcnk6IC41XG59XG5cbnJldHVybiBEZWxheVxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbi8vIHRha2VuIGZyb20gY3NvdW5kOiBodHRwOi8vbWFudWFsLmZyZWVzaGVsbC5vcmcvY3NvdW5kNS9kaXN0b3J0MS5odG1sXG4vKlxuXG4gICAgICAgICBleHAoYXNpZyAqIChzaGFwZTEgKyBwcmVnYWluKSkgLSBleHAoYXNpZyAqIChzaGFwZTIgLSBwcmVnYWluKSlcbiAgYW91dCA9IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgZXhwKGFzaWcgKiBwcmVnYWluKSAgICAgICAgICAgICsgZXhwKC1hc2lnICogcHJlZ2FpbilcblxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGxldCBEaXN0b3J0aW9uID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIGVmZmVjdC5kZWZhdWx0cywgRGlzdG9ydGlvbi5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICBkaXN0b3J0aW9uPSBPYmplY3QuY3JlYXRlKCBlZmZlY3QgKSxcbiAgICAgICAgb3V0XG5cbiAgICBkaXN0b3J0aW9uLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgICAgICBpbnB1dEdhaW4gPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgICAgc2hhcGUxID0gZy5pbiggJ3NoYXBlMScgKSxcbiAgICAgICAgICAgIHNoYXBlMiA9IGcuaW4oICdzaGFwZTInICksXG4gICAgICAgICAgICBwcmVnYWluID0gZy5pbiggJ3ByZWdhaW4nICksXG4gICAgICAgICAgICBwb3N0Z2FpbiA9IGcuaW4oICdwb3N0Z2FpbicgKVxuXG4gICAgICBsZXQgbG91dFxuICAgICAge1xuICAgICAgICAndXNlIGpzZHNwJ1xuICAgICAgICBjb25zdCBsaW5wdXQgPSBpc1N0ZXJlbyA/IGcubXVsKCBpbnB1dFswXSwgaW5wdXRHYWluICkgOiBnLm11bCggaW5wdXQsIGlucHV0R2FpbiApXG4gICAgICAgIGNvbnN0IGx0b3AgPSBnLmV4cCggbGlucHV0ICogKHNoYXBlMSArIHByZWdhaW4pICkgLSBnLmV4cCggbGlucHV0ICogKHNoYXBlMiAtIHByZWdhaW4pIClcbiAgICAgICAgY29uc3QgbGJvdHRvbSA9IGcuZXhwKCBsaW5wdXQgKiBwcmVnYWluICkgKyBnLmV4cCggLTEgKiBsaW5wdXQgKiBwcmVnYWluIClcbiAgICAgICAgbG91dCA9ICggbHRvcCAvIGxib3R0b20gKSAqIHBvc3RnYWluXG4gICAgICB9XG5cbiAgICAgIGlmKCBpc1N0ZXJlbyApIHtcbiAgICAgICAgbGV0IHJvdXRcbiAgICAgICAge1xuICAgICAgICAgICd1c2UganNkc3AnXG4gICAgICAgICAgY29uc3QgcmlucHV0ID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbMV0sIGlucHV0R2FpbiApIDogZy5tdWwoIGlucHV0LCBpbnB1dEdhaW4gKVxuICAgICAgICAgIGNvbnN0IHJ0b3AgPSBnLmV4cCggcmlucHV0ICogKHNoYXBlMSArIHByZWdhaW4pICkgLSBnLmV4cCggcmlucHV0ICogKHNoYXBlMiAtIHByZWdhaW4pIClcbiAgICAgICAgICBjb25zdCByYm90dG9tID0gZy5leHAoIHJpbnB1dCAqIHByZWdhaW4gKSArIGcuZXhwKCAtMSAqIHJpbnB1dCAqIHByZWdhaW4gKVxuICAgICAgICAgIHJvdXQgPSAoIHJ0b3AgLyByYm90dG9tICkgKiBwb3N0Z2FpblxuICAgICAgICB9XG5cbiAgICAgICAgZGlzdG9ydGlvbi5ncmFwaCA9IFsgbG91dCwgcm91dCBdXG4gICAgICB9ZWxzZXtcbiAgICAgICAgZGlzdG9ydGlvbi5ncmFwaCA9IGxvdXQgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzdG9ydGlvbi5fX2NyZWF0ZUdyYXBoKClcbiAgICBkaXN0b3J0aW9uLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICAgIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICAgIGRpc3RvcnRpb24sXG4gICAgICBkaXN0b3J0aW9uLmdyYXBoLCBcbiAgICAgIFsgJ2Z4JywnZGlzdG9ydGlvbicgXSwgXG4gICAgICBwcm9wcyBcbiAgICApXG4gICAgcmV0dXJuIG91dCBcbiAgfVxuXG4gIERpc3RvcnRpb24uZGVmYXVsdHMgPSB7XG4gICAgaW5wdXQ6MCxcbiAgICBzaGFwZTE6LjEsXG4gICAgc2hhcGUyOi4xLFxuICAgIHByZWdhaW46NSxcbiAgICBwb3N0Z2FpbjouNSxcbiAgfVxuXG4gIHJldHVybiBEaXN0b3J0aW9uXG5cbn1cbiIsImxldCB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKVxuXG5sZXQgZWZmZWN0ID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbk9iamVjdC5hc3NpZ24oIGVmZmVjdCwge1xuICBkZWZhdWx0czogeyBieXBhc3M6ZmFsc2UsIGlucHV0R2FpbjoxIH0sXG4gIHR5cGU6J2VmZmVjdCdcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZWZmZWN0XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgZWZmZWN0cyA9IHtcbiAgICBGcmVldmVyYiAgICA6IHJlcXVpcmUoICcuL2ZyZWV2ZXJiLmpzJyAgKSggR2liYmVyaXNoICksXG4gICAgLy9QbGF0ZSAgICAgICA6IHJlcXVpcmUoICcuL2RhdHRvcnJvLmRzcC5qcycgKSggR2liYmVyaXNoICksXG4gICAgRmxhbmdlciAgICAgOiByZXF1aXJlKCAnLi9mbGFuZ2VyLmpzJyAgICkoIEdpYmJlcmlzaCApLFxuICAgIFZpYnJhdG8gICAgIDogcmVxdWlyZSggJy4vdmlicmF0by5qcycgICApKCBHaWJiZXJpc2ggKSxcbiAgICBEZWxheSAgICAgICA6IHJlcXVpcmUoICcuL2RlbGF5LmpzJyAgICAgKSggR2liYmVyaXNoICksXG4gICAgQml0Q3J1c2hlciAgOiByZXF1aXJlKCAnLi9iaXRDcnVzaGVyLmpzJykoIEdpYmJlcmlzaCApLFxuICAgIERpc3RvcnRpb24gIDogcmVxdWlyZSggJy4vZGlzdG9ydGlvbi5kc3AuanMnKSggR2liYmVyaXNoICksXG4gICAgUmluZ01vZCAgICAgOiByZXF1aXJlKCAnLi9yaW5nTW9kLmpzJyAgICkoIEdpYmJlcmlzaCApLFxuICAgIFRyZW1vbG8gICAgIDogcmVxdWlyZSggJy4vdHJlbW9sby5qcycgICApKCBHaWJiZXJpc2ggKSxcbiAgICBDaG9ydXMgICAgICA6IHJlcXVpcmUoICcuL2Nob3J1cy5qcycgICAgKSggR2liYmVyaXNoICksXG4gICAgV2F2ZWZvbGRlciAgOiByZXF1aXJlKCAnLi93YXZlZm9sZGVyLmRzcC5qcycpKCBHaWJiZXJpc2ggKVswXSxcbiAgICBTaHVmZmxlciAgICA6IHJlcXVpcmUoICcuL2J1ZmZlclNodWZmbGVyLmpzJyAgKSggR2liYmVyaXNoICksXG4gICAgLy9HYXRlICAgICAgICA6IHJlcXVpcmUoICcuL2dhdGUuanMnICAgICAgKSggR2liYmVyaXNoICksXG4gIH1cblxuICBlZmZlY3RzLmV4cG9ydCA9IHRhcmdldCA9PiB7XG4gICAgZm9yKCBsZXQga2V5IGluIGVmZmVjdHMgKSB7XG4gICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyApIHtcbiAgICAgICAgdGFyZ2V0WyBrZXkgXSA9IGVmZmVjdHNbIGtleSBdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbnJldHVybiBlZmZlY3RzXG5cbn1cbiIsImxldCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICBwcm90byA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5sZXQgRmxhbmdlciA9IGlucHV0UHJvcHMgPT4ge1xuICBsZXQgcHJvcHMgICA9IE9iamVjdC5hc3NpZ24oIHsgZGVsYXlMZW5ndGg6NDQxMDAgfSwgRmxhbmdlci5kZWZhdWx0cywgcHJvdG8uZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgIGZsYW5nZXIgPSBPYmplY3QuY3JlYXRlKCBwcm90byApLFxuICAgICAgb3V0XG5cbiAgZmxhbmdlci5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgIH1lbHNle1xuICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICBkZWxheUxlbmd0aCA9IHByb3BzLmRlbGF5TGVuZ3RoLFxuICAgICAgICAgIGZlZWRiYWNrQ29lZmYgPSBnLmluKCAnZmVlZGJhY2snICksXG4gICAgICAgICAgbW9kQW1vdW50ID0gZy5pbiggJ29mZnNldCcgKSxcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGRlbGF5QnVmZmVyTCA9IGcuZGF0YSggZGVsYXlMZW5ndGggKVxuXG4gICAgY29uc3Qgd3JpdGVJZHggPSBnLmFjY3VtKCAxLDAsIHsgbWluOjAsIG1heDpkZWxheUxlbmd0aCwgaW50ZXJwOidub25lJywgbW9kZTonc2FtcGxlcycgfSlcbiAgICBcbiAgICBjb25zdCBvZmZzZXQgPSBnLm11bCggbW9kQW1vdW50LCA1MDAgKVxuXG4gICAgY29uc3QgbW9kID0gcHJvcHMubW9kID09PSB1bmRlZmluZWQgPyBnLmN5Y2xlKCBmcmVxdWVuY3kgKSA6IHByb3BzLm1vZFxuICAgIFxuICAgIGNvbnN0IHJlYWRJZHggPSBnLndyYXAoIFxuICAgICAgZy5hZGQoIFxuICAgICAgICBnLnN1Yiggd3JpdGVJZHgsIG9mZnNldCApLCBcbiAgICAgICAgbW9kLy9nLm11bCggbW9kLCBnLnN1Yiggb2Zmc2V0LCAxICkgKSBcbiAgICAgICksIFxuICAgICAgMCwgXG4gICAgICBkZWxheUxlbmd0aFxuICAgIClcblxuICAgIGNvbnN0IGxlZnRJbnB1dCA9IGlzU3RlcmVvID8gaW5wdXRbMF0gOiBpbnB1dFxuXG4gICAgY29uc3QgZGVsYXllZE91dEwgPSBnLnBlZWsoIGRlbGF5QnVmZmVyTCwgcmVhZElkeCwgeyBpbnRlcnA6J2xpbmVhcicsIG1vZGU6J3NhbXBsZXMnIH0pXG4gICAgXG4gICAgZy5wb2tlKCBkZWxheUJ1ZmZlckwsIGcuYWRkKCBsZWZ0SW5wdXQsIGcubXVsKCBkZWxheWVkT3V0TCwgZmVlZGJhY2tDb2VmZiApICksIHdyaXRlSWR4IClcblxuICAgIGNvbnN0IGxlZnQgPSBnLmFkZCggbGVmdElucHV0LCBkZWxheWVkT3V0TCApXG5cbiAgICBpZiggaXNTdGVyZW8gPT09IHRydWUgKSB7XG4gICAgICBjb25zdCByaWdodElucHV0ID0gaW5wdXRbMV1cbiAgICAgIGNvbnN0IGRlbGF5QnVmZmVyUiA9IGcuZGF0YSggZGVsYXlMZW5ndGggKVxuICAgICAgXG4gICAgICBsZXQgZGVsYXllZE91dFIgPSBnLnBlZWsoIGRlbGF5QnVmZmVyUiwgcmVhZElkeCwgeyBpbnRlcnA6J2xpbmVhcicsIG1vZGU6J3NhbXBsZXMnIH0pXG5cbiAgICAgIGcucG9rZSggZGVsYXlCdWZmZXJSLCBnLmFkZCggcmlnaHRJbnB1dCwgZy5tdWwoIGRlbGF5ZWRPdXRSLCBmZWVkYmFja0NvZWZmICkgKSwgd3JpdGVJZHggKVxuICAgICAgY29uc3QgcmlnaHQgPSBnLmFkZCggcmlnaHRJbnB1dCwgZGVsYXllZE91dFIgKVxuXG4gICAgICBmbGFuZ2VyLmdyYXBoID0gWyBsZWZ0LCByaWdodCBdXG5cbiAgICB9ZWxzZXtcbiAgICAgIGZsYW5nZXIuZ3JhcGggPSBsZWZ0XG4gICAgfVxuICB9XG5cbiAgZmxhbmdlci5fX2NyZWF0ZUdyYXBoKClcbiAgZmxhbmdlci5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgIGZsYW5nZXIsXG4gICAgZmxhbmdlci5ncmFwaCwgXG4gICAgWydmeCcsJ2ZsYW5nZXInXSwgXG4gICAgcHJvcHMgXG4gICkgXG5cbiAgcmV0dXJuIG91dCBcbn1cblxuRmxhbmdlci5kZWZhdWx0cyA9IHtcbiAgaW5wdXQ6MCxcbiAgZmVlZGJhY2s6LjgxLFxuICBvZmZzZXQ6LjEyNSxcbiAgZnJlcXVlbmN5OjFcbn1cblxucmV0dXJuIEZsYW5nZXJcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBcbmNvbnN0IGFsbFBhc3MgPSBHaWJiZXJpc2guZmlsdGVycy5nZW5pc2guQWxsUGFzc1xuY29uc3QgY29tYkZpbHRlciA9IEdpYmJlcmlzaC5maWx0ZXJzLmdlbmlzaC5Db21iXG5cbmNvbnN0IHR1bmluZyA9IHtcbiAgY29tYkNvdW50Olx0ICBcdDgsXG4gIGNvbWJUdW5pbmc6IFx0XHRbIDExMTYsIDExODgsIDEyNzcsIDEzNTYsIDE0MjIsIDE0OTEsIDE1NTcsIDE2MTcgXSwgICAgICAgICAgICAgICAgICAgIFxuICBhbGxQYXNzQ291bnQ6IFx0NCxcbiAgYWxsUGFzc1R1bmluZzpcdFsgMjI1LCA1NTYsIDQ0MSwgMzQxIF0sXG4gIGFsbFBhc3NGZWVkYmFjazowLjUsXG4gIGZpeGVkR2FpbjogXHRcdCAgMC4wMTUsXG4gIHNjYWxlRGFtcGluZzogXHQwLjQsXG4gIHNjYWxlUm9vbTogXHRcdCAgMC4yOCxcbiAgb2Zmc2V0Um9vbTogXHQgIDAuNyxcbiAgc3RlcmVvU3ByZWFkOiAgIDIzXG59XG5cbmNvbnN0IEZyZWV2ZXJiID0gaW5wdXRQcm9wcyA9PiB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIGVmZmVjdC5kZWZhdWx0cywgRnJlZXZlcmIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKSxcbiAgICAgICAgcmV2ZXJiID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0ICkgXG5cbiAgbGV0IG91dCBcbiAgcmV2ZXJiLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgIH0gICAgXG5cbiAgICBjb25zdCBjb21ic0wgPSBbXSwgY29tYnNSID0gW11cblxuICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgICAgd2V0MSA9IGcuaW4oICd3ZXQxJyksXG4gICAgICAgICAgd2V0MiA9IGcuaW4oICd3ZXQyJyApLCAgXG4gICAgICAgICAgZHJ5ID0gZy5pbiggJ2RyeScgKSwgXG4gICAgICAgICAgcm9vbVNpemUgPSBnLmluKCAncm9vbVNpemUnICksIFxuICAgICAgICAgIGRhbXBpbmcgPSBnLmluKCAnZGFtcGluZycgKVxuICAgIFxuICAgIGNvbnN0IF9fc3VtbWVkSW5wdXQgPSBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGcuYWRkKCBpbnB1dFswXSwgaW5wdXRbMV0gKSA6IGlucHV0LFxuICAgICAgICAgIHN1bW1lZElucHV0ID0gZy5tdWwoIF9fc3VtbWVkSW5wdXQsIGlucHV0R2FpbiApLFxuICAgICAgICAgIGF0dGVudWF0ZWRJbnB1dCA9IGcubWVtbyggZy5tdWwoIHN1bW1lZElucHV0LCB0dW5pbmcuZml4ZWRHYWluICkgKVxuICAgIFxuICAgIC8vIGNyZWF0ZSBjb21iIGZpbHRlcnMgaW4gcGFyYWxsZWwuLi5cbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IDg7IGkrKyApIHsgXG4gICAgICBjb21ic0wucHVzaCggXG4gICAgICAgIGNvbWJGaWx0ZXIoIFxuICAgICAgICAgIGF0dGVudWF0ZWRJbnB1dCwgXG4gICAgICAgICAgdHVuaW5nLmNvbWJUdW5pbmdbaV0sIFxuICAgICAgICAgIGcubXVsKGRhbXBpbmcsLjQpLFxuICAgICAgICAgIGcubXVsKCB0dW5pbmcuc2NhbGVSb29tICsgdHVuaW5nLm9mZnNldFJvb20sIHJvb21TaXplICkgXG4gICAgICAgICkgXG4gICAgICApXG4gICAgICBjb21ic1IucHVzaCggXG4gICAgICAgIGNvbWJGaWx0ZXIoIFxuICAgICAgICAgIGF0dGVudWF0ZWRJbnB1dCwgXG4gICAgICAgICAgdHVuaW5nLmNvbWJUdW5pbmdbaV0gKyB0dW5pbmcuc3RlcmVvU3ByZWFkLCBcbiAgICAgICAgICBnLm11bChkYW1waW5nLC40KSwgXG4gICAgICAgICAgZy5tdWwoIHR1bmluZy5zY2FsZVJvb20gKyB0dW5pbmcub2Zmc2V0Um9vbSwgcm9vbVNpemUgKSBcbiAgICAgICAgKSBcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgLy8gLi4uIGFuZCBzdW0gdGhlbSB3aXRoIGF0dGVudWF0ZWQgaW5wdXQsIHVzZSBvZiBsZXQgaXMgZGVsaWJlcmF0ZSBoZXJlXG4gICAgbGV0IG91dEwgPSBnLmFkZCggYXR0ZW51YXRlZElucHV0LCAuLi5jb21ic0wgKVxuICAgIGxldCBvdXRSID0gZy5hZGQoIGF0dGVudWF0ZWRJbnB1dCwgLi4uY29tYnNSIClcbiAgICBcbiAgICAvLyBydW4gdGhyb3VnaCBhbGxwYXNzIGZpbHRlcnMgaW4gc2VyaWVzXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCA0OyBpKysgKSB7IFxuICAgICAgb3V0TCA9IGFsbFBhc3MoIG91dEwsIHR1bmluZy5hbGxQYXNzVHVuaW5nWyBpIF0gKyB0dW5pbmcuc3RlcmVvU3ByZWFkIClcbiAgICAgIG91dFIgPSBhbGxQYXNzKCBvdXRSLCB0dW5pbmcuYWxsUGFzc1R1bmluZ1sgaSBdICsgdHVuaW5nLnN0ZXJlb1NwcmVhZCApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG91dHB1dEwgPSBnLmFkZCggZy5tdWwoIG91dEwsIHdldDEgKSwgZy5tdWwoIG91dFIsIHdldDIgKSwgZy5tdWwoIGlzU3RlcmVvID09PSB0cnVlID8gaW5wdXRbMF0gOiBpbnB1dCwgZHJ5ICkgKSxcbiAgICAgICAgICBvdXRwdXRSID0gZy5hZGQoIGcubXVsKCBvdXRSLCB3ZXQxICksIGcubXVsKCBvdXRMLCB3ZXQyICksIGcubXVsKCBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGlucHV0WzFdIDogaW5wdXQsIGRyeSApIClcblxuICAgIHJldmVyYi5ncmFwaCA9IFsgb3V0cHV0TCwgb3V0cHV0UiBdXG4gIH1cblxuICByZXZlcmIuX19jcmVhdGVHcmFwaCgpXG4gIHJldmVyYi5fX3JlcXVpcmVzUmVjb21waWxhdGlvbiA9IFsgJ2lucHV0JyBdXG5cbiAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHJldmVyYiwgcmV2ZXJiLmdyYXBoLCBbJ2Z4JywnZnJlZXZlcmInXSwgcHJvcHMgKVxuXG4gIHJldHVybiBvdXRcbn1cblxuXG5GcmVldmVyYi5kZWZhdWx0cyA9IHtcbiAgaW5wdXQ6IDAsXG4gIHdldDE6IDEsXG4gIHdldDI6IDAsXG4gIGRyeTogLjUsXG4gIHJvb21TaXplOiAuOTI1LFxuICBkYW1waW5nOiAgLjUsXG59XG5cbnJldHVybiBGcmVldmVyYiBcblxufVxuXG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiBcbmxldCBSaW5nTW9kID0gaW5wdXRQcm9wcyA9PiB7XG4gIGxldCBwcm9wcyAgID0gT2JqZWN0LmFzc2lnbigge30sIFJpbmdNb2QuZGVmYXVsdHMsIGVmZmVjdC5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgcmluZ01vZCA9IE9iamVjdC5jcmVhdGUoIGVmZmVjdCApLFxuICAgICAgb3V0XG5cbiAgcmluZ01vZC5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcbiAgICBpZiggb3V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgIH1lbHNle1xuICAgICAgaXNTdGVyZW8gPSBvdXQuaW5wdXQuaXNTdGVyZW9cbiAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgfSAgICBcblxuICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgIGlucHV0R2FpbiA9IGcuaW4oICdpbnB1dEdhaW4nICksXG4gICAgICAgICAgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBnYWluID0gZy5pbiggJ2dhaW4nICksXG4gICAgICAgICAgbWl4ID0gZy5pbiggJ21peCcgKVxuICAgIFxuICAgIGNvbnN0IGxlZnRJbnB1dCA9IGlzU3RlcmVvID8gZy5tdWwoIGlucHV0WzBdLCBpbnB1dEdhaW4gKSA6IGcubXVsKCBpbnB1dCwgaW5wdXRHYWluICksXG4gICAgICAgICAgc2luZSA9IGcubXVsKCBnLmN5Y2xlKCBmcmVxdWVuY3kgKSwgZ2FpbiApXG4gICBcbiAgICBjb25zdCBsZWZ0ID0gZy5hZGQoIGcubXVsKCBsZWZ0SW5wdXQsIGcuc3ViKCAxLCBtaXggKSksIGcubXVsKCBnLm11bCggbGVmdElucHV0LCBzaW5lICksIG1peCApICkgXG4gICAgICAgIFxuICAgIGlmKCBpc1N0ZXJlbyA9PT0gdHJ1ZSApIHtcbiAgICAgIGNvbnN0IHJpZ2h0SW5wdXQgPSBnLm11bCggaW5wdXRbMV0sIGlucHV0R2FpbiApLFxuICAgICAgICAgICAgcmlnaHQgPSBnLmFkZCggZy5tdWwoIHJpZ2h0SW5wdXQsIGcuc3ViKCAxLCBtaXggKSksIGcubXVsKCBnLm11bCggcmlnaHRJbnB1dCwgc2luZSApLCBtaXggKSApIFxuICAgICAgXG4gICAgICByaW5nTW9kLmdyYXBoID0gWyBsZWZ0LCByaWdodCBdXG4gICAgfWVsc2V7XG4gICAgICByaW5nTW9kLmdyYXBoID0gbGVmdFxuICAgIH1cbiAgfVxuXG4gIHJpbmdNb2QuX19jcmVhdGVHcmFwaCgpIFxuICByaW5nTW9kLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgcmluZ01vZCxcbiAgICByaW5nTW9kLmdyYXBoLCBcbiAgICBbICdmeCcsJ3JpbmdNb2QnXSwgXG4gICAgcHJvcHMgXG4gIClcbiAgXG4gIHJldHVybiBvdXQgXG59XG5cblJpbmdNb2QuZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGZyZXF1ZW5jeToyMjAsXG4gIGdhaW46IDEsIFxuICBtaXg6MVxufVxuXG5yZXR1cm4gUmluZ01vZFxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGVmZmVjdCA9IHJlcXVpcmUoICcuL2VmZmVjdC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gXG5jb25zdCBUcmVtb2xvID0gaW5wdXRQcm9wcyA9PiB7XG4gIGNvbnN0IHByb3BzICAgPSBPYmplY3QuYXNzaWduKCB7fSwgVHJlbW9sby5kZWZhdWx0cywgZWZmZWN0LmRlZmF1bHRzLCBpbnB1dFByb3BzICksXG4gICAgICAgIHRyZW1vbG8gPSBPYmplY3QuY3JlYXRlKCBlZmZlY3QgKVxuICBcbiAgbGV0IG91dFxuICB0cmVtb2xvLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgIGlmKCBvdXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlzU3RlcmVvID0gdHlwZW9mIHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSAndW5kZWZpbmVkJyA/IHByb3BzLmlucHV0LmlzU3RlcmVvIDogZmFsc2UgXG4gICAgfWVsc2V7XG4gICAgICBpc1N0ZXJlbyA9IG91dC5pbnB1dC5pc1N0ZXJlb1xuICAgICAgb3V0LmlzU3RlcmVvID0gaXNTdGVyZW9cbiAgICB9ICAgIFxuXG4gICAgY29uc3QgaW5wdXQgPSBnLmluKCAnaW5wdXQnICksXG4gICAgICAgICAgaW5wdXRHYWluID0gZy5pbiggJ2lucHV0R2FpbicgKSxcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGFtb3VudCA9IGcuaW4oICdhbW91bnQnIClcbiAgICBcbiAgICBjb25zdCBsZWZ0SW5wdXQgPSBpc1N0ZXJlbyA/IGcubXVsKCBpbnB1dFswXSwgaW5wdXRHYWluICkgOiBnLm11bCggaW5wdXQsIGlucHV0R2FpbiApXG5cbiAgICBsZXQgb3NjXG4gICAgaWYoIHByb3BzLnNoYXBlID09PSAnc3F1YXJlJyApIHtcbiAgICAgIG9zYyA9IGcuZ3QoIGcucGhhc29yKCBmcmVxdWVuY3kgKSwgMCApXG4gICAgfWVsc2UgaWYoIHByb3BzLnNoYXBlID09PSAnc2F3JyApIHtcbiAgICAgIG9zYyA9IGcuZ3RwKCBnLnBoYXNvciggZnJlcXVlbmN5ICksIDAgKVxuICAgIH1lbHNle1xuICAgICAgb3NjID0gZy5jeWNsZSggZnJlcXVlbmN5IClcbiAgICB9XG5cbiAgICBjb25zdCBtb2QgPSBnLm11bCggb3NjLCBhbW91bnQgKVxuICAgXG4gICAgY29uc3QgbGVmdCA9IGcuc3ViKCBsZWZ0SW5wdXQsIGcubXVsKCBsZWZ0SW5wdXQsIG1vZCApIClcblxuICAgIGlmKCBpc1N0ZXJlbyA9PT0gdHJ1ZSApIHtcbiAgICAgIGNvbnN0IHJpZ2h0SW5wdXQgPSBnLm11bCggaW5wdXRbMV0sIGlucHV0R2FpbiApLFxuICAgICAgICAgICAgcmlnaHQgPSBnLm11bCggcmlnaHRJbnB1dCwgbW9kIClcblxuICAgICAgdHJlbW9sby5ncmFwaCA9IFsgbGVmdCwgcmlnaHQgXVxuICAgIH1lbHNle1xuICAgICAgdHJlbW9sby5ncmFwaCA9IGxlZnRcbiAgICB9XG4gIH1cbiAgXG4gIHRyZW1vbG8uX19jcmVhdGVHcmFwaCgpXG4gIHRyZW1vbG8uX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuXG4gIG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICB0cmVtb2xvLFxuICAgIHRyZW1vbG8uZ3JhcGgsXG4gICAgWydmeCcsJ3RyZW1vbG8nXSwgXG4gICAgcHJvcHMgXG4gICkgXG4gIHJldHVybiBvdXQgXG59XG5cblRyZW1vbG8uZGVmYXVsdHMgPSB7XG4gIGlucHV0OjAsXG4gIGZyZXF1ZW5jeToyLFxuICBhbW91bnQ6IDEsIFxuICBzaGFwZTonc2luZSdcbn1cblxucmV0dXJuIFRyZW1vbG9cblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBlZmZlY3QgPSByZXF1aXJlKCAnLi9lZmZlY3QuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuIFxuY29uc3QgVmlicmF0byA9IGlucHV0UHJvcHMgPT4ge1xuICBjb25zdCBwcm9wcyAgID0gT2JqZWN0LmFzc2lnbigge30sIFZpYnJhdG8uZGVmYXVsdHMsIGVmZmVjdC5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICB2aWJyYXRvID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0IClcblxuICBsZXQgb3V0XG4gIHZpYnJhdG8uX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpc1N0ZXJlbyA9IGZhbHNlXG4gICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgaXNTdGVyZW8gPSB0eXBlb2YgcHJvcHMuaW5wdXQuaXNTdGVyZW8gIT09ICd1bmRlZmluZWQnID8gcHJvcHMuaW5wdXQuaXNTdGVyZW8gOiBmYWxzZSBcbiAgICB9ZWxzZXtcbiAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICBvdXQuaXNTdGVyZW8gPSBpc1N0ZXJlb1xuICAgIH0gICAgXG5cbiAgICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgICBpbnB1dEdhaW4gPSBnLmluKCAnaW5wdXRHYWluJyApLFxuICAgICAgICAgIGRlbGF5TGVuZ3RoID0gNDQxMDAsXG4gICAgICAgICAgZmVlZGJhY2tDb2VmZiA9IGcuaW4oICdmZWVkYmFjaycgKSxcbiAgICAgICAgICBtb2RBbW91bnQgPSBnLmluKCAnYW1vdW50JyApLFxuICAgICAgICAgIGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgZGVsYXlCdWZmZXJMID0gZy5kYXRhKCBkZWxheUxlbmd0aCApXG5cbiAgICBjb25zdCB3cml0ZUlkeCA9IGcuYWNjdW0oIDEsMCwgeyBtaW46MCwgbWF4OmRlbGF5TGVuZ3RoLCBpbnRlcnA6J25vbmUnLCBtb2RlOidzYW1wbGVzJyB9KVxuICAgIFxuICAgIGNvbnN0IG9mZnNldCA9IGcubXVsKCBtb2RBbW91bnQsIDUwMCApXG4gICAgXG4gICAgY29uc3QgcmVhZElkeCA9IGcud3JhcCggXG4gICAgICBnLmFkZCggXG4gICAgICAgIGcuc3ViKCB3cml0ZUlkeCwgb2Zmc2V0ICksIFxuICAgICAgICBnLm11bCggZy5jeWNsZSggZnJlcXVlbmN5ICksIGcuc3ViKCBvZmZzZXQsIDEgKSApIFxuICAgICAgKSwgXG4gICAgICAwLCBcbiAgICAgIGRlbGF5TGVuZ3RoXG4gICAgKVxuXG4gICAgY29uc3QgbGVmdElucHV0ID0gaXNTdGVyZW8gPyBnLm11bCggaW5wdXRbMF0sIGlucHV0R2FpbiApIDogZy5tdWwoIGlucHV0LCBpbnB1dEdhaW4gKVxuXG4gICAgY29uc3QgZGVsYXllZE91dEwgPSBnLnBlZWsoIGRlbGF5QnVmZmVyTCwgcmVhZElkeCwgeyBpbnRlcnA6J2xpbmVhcicsIG1vZGU6J3NhbXBsZXMnIH0pXG4gICAgXG4gICAgZy5wb2tlKCBkZWxheUJ1ZmZlckwsIGcuYWRkKCBsZWZ0SW5wdXQsIGcubXVsKCBkZWxheWVkT3V0TCwgZmVlZGJhY2tDb2VmZiApICksIHdyaXRlSWR4IClcblxuICAgIGNvbnN0IGxlZnQgPSBkZWxheWVkT3V0TFxuXG4gICAgaWYoIGlzU3RlcmVvID09PSB0cnVlICkge1xuICAgICAgY29uc3QgcmlnaHRJbnB1dCA9IGcubXVsKCBpbnB1dFsxXSwgaW5wdXRHYWluIClcbiAgICAgIGNvbnN0IGRlbGF5QnVmZmVyUiA9IGcuZGF0YSggZGVsYXlMZW5ndGggKVxuICAgICAgXG4gICAgICBjb25zdCBkZWxheWVkT3V0UiA9IGcucGVlayggZGVsYXlCdWZmZXJSLCByZWFkSWR4LCB7IGludGVycDonbGluZWFyJywgbW9kZTonc2FtcGxlcycgfSlcblxuICAgICAgZy5wb2tlKCBkZWxheUJ1ZmZlclIsIGcuYWRkKCByaWdodElucHV0LCBtdWwoIGRlbGF5ZWRPdXRSLCBmZWVkYmFja0NvZWZmICkgKSwgd3JpdGVJZHggKVxuICAgICAgY29uc3QgcmlnaHQgPSBkZWxheWVkT3V0UlxuXG4gICAgICB2aWJyYXRvLmdyYXBoID0gWyBsZWZ0LCByaWdodCBdXG4gICAgfWVsc2V7XG4gICAgICB2aWJyYXRvLmdyYXBoID0gbGVmdCBcbiAgICB9XG4gIH1cblxuICB2aWJyYXRvLl9fY3JlYXRlR3JhcGgoKVxuICB2aWJyYXRvLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnaW5wdXQnIF1cblxuICBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgdmlicmF0byxcbiAgICB2aWJyYXRvLmdyYXBoLCAgICBcbiAgICBbICdmeCcsICd2aWJyYXRvJyBdLCBcbiAgICBwcm9wcyBcbiAgKSBcbiAgcmV0dXJuIG91dCBcbn1cblxuVmlicmF0by5kZWZhdWx0cyA9IHtcbiAgaW5wdXQ6MCxcbiAgZmVlZGJhY2s6LjAxLFxuICBhbW91bnQ6LjUsXG4gIGZyZXF1ZW5jeTo0XG59XG5cbnJldHVybiBWaWJyYXRvXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgZWZmZWN0ID0gcmVxdWlyZSggJy4vZWZmZWN0LmpzJyApXG5cbmNvbnN0IGdlbmlzaCA9IGdcblxuY29uc3QgUkwgPSA3LjVlMyxcbiAgICAgICBSID0gMTVlMywgXG4gICAgICBWVCA9IDI2ZS0zLFxuICAgICAgSXMgPSAxMGUtMTYsXG4gICAgICAgYSA9IDIqUkwvUixcbiAgICAgICBiID0gKFIrMipSTCkvKFZUKlIpLFxuICAgICAgIGQgPSAoUkwqSXMpL1ZUXG5cbi8vIEFudGlhbGlhc2luZyBlcnJvciB0aHJlc2hvbGRcbmNvbnN0IHRocmVzaCA9IDEwZS0xMDtcblxuY29uc3Qgd2F2ZXN0YWdlID0gaW4xID0+IHtcbiAgY29uc3QgYm9keSA9IGAgIGNvbnN0IHRocmVzaCA9IDEwZS0xMDtcblxuICBsZXQgdyA9IExuMTtcbiAgbGV0IGV4cHcsIHAsIHIsIHM7XG5cbiAgY29uc3QgZSA9IE1hdGguRVxuICBjb25zdCBwb3cgPSBNYXRoLnBvd1xuICBjb25zdCBhYnMgPSBNYXRoLmFic1xuICBmb3IobGV0IGk9MDsgaTwxMDAwOyBpKyspIHtcbiAgICBleHB3ID0gcG93KGUsdyk7XG5cbiAgICBwID0gdypleHB3IC0geDtcbiAgICByID0gKHcrMSkqZXhwdztcbiAgICBzID0gKHcrMikvKDIqKHcrMSkpOyAgICAgICAgXG4gICAgZXJyID0gKHAvKHItKHAqcykpKTtcblxuICAgIGlmIChhYnMoZXJyKTx0aHJlc2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHcgPSB3IC0gZXJyO1xuICB9XG5cbiAgcmV0dXJuIHc7YFxuXG4gIGNvbnN0IExhbWJlcnRfVyA9IGcucHJvY2VzcyggJ3gnLCdMbjEnLCBib2R5IClcblxuICBjb25zdCBMbjEgPSBnLmhpc3RvcnkoMCksXG4gICAgICAgIEZuMSA9IGcuaGlzdG9yeSgwKSxcbiAgICAgICAgeG4xID0gZy5oaXN0b3J5KDApXG5cbiAge1xuICAgICd1c2UganNkc3AnXG4gICAgLy8gQ29tcHV0ZSBBbnRpZGVyaXZhdGl2ZVxuICAgIGNvbnN0IGwgPSBnLnNpZ24oaW4xKTsgXG4gICAgbGV0IHUgPSBkICogZy5wb3coIE1hdGguRSwgbCAqIGIgKiBpbjEgKVxuICAgIGxldCBMbiA9IExhbWJlcnRfVy5jYWxsKHUsTG4xLm91dClcbiAgICBjb25zdCBGbiA9ICgwLjUgKiBWVC9iICkgKiAoTG4gKiAoTG4gKyAyKSkgLSAwLjUqYSppbjEqaW4xXG5cbiAgICBsZXQgeG4gPSAwLjUgKiAoIGluMSArIHhuMS5vdXQgKVxuICAgIHUgPSBkICogZy5wb3coIE1hdGguRSwgbCAqIGIgKiB4biApXG4gICAgTG4gPSBMYW1iZXJ0X1cuY2FsbCggdSwgTG4xLm91dCApXG5cbiAgICAvL291dDEgPSA7XG4gICAgLy8gQ2hlY2sgZm9yIGlsbC1jb25kaXRpb25pbmdcbiAgICBjb25zdCBvdXQxID0gZy5pZmVsc2UoXG4gICAgICBnLmx0KCBnLmFicyggaW4xIC0geG4xLm91dCApLCB0aHJlc2gpLCBcbiAgICAgIChsICogVlQgKiBMbikgLSAoIGEgKiB4biApLFxuICAgICAgKEZuIC0gRm4xLm91dCkgLyAoaW4xIC0geG4xLm91dClcbiAgICApXG5cbiAgICAvLyBVcGRhdGUgU3RhdGVzXG4gICAgTG4xLmluKCBMbiApXG4gICAgRm4xLmluKCBGbiApXG4gICAgeG4xLmluKCBpbjEgKVxuXG4gICAgcmV0dXJuIG91dDFcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgV2F2ZWZvbGRlciA9IGlucHV0UHJvcHMgPT4ge1xuXG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIGVmZmVjdC5kZWZhdWx0cywgV2F2ZWZvbGRlci5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICB3YXZlZm9sZGVyID0gT2JqZWN0LmNyZWF0ZSggZWZmZWN0ICksXG4gICAgICAgIG91dFxuXG4gICAgd2F2ZWZvbGRlci5fX2NyZWF0ZUdyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgaWYoIG91dCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBpc1N0ZXJlbyA9IHR5cGVvZiBwcm9wcy5pbnB1dC5pc1N0ZXJlbyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IGZhbHNlIFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlzU3RlcmVvID0gb3V0LmlucHV0LmlzU3RlcmVvXG4gICAgICAgIG91dC5pc1N0ZXJlbyA9IGlzU3RlcmVvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gZy5pbiggJ2lucHV0JyApLFxuICAgICAgICAgICAgZ2FpbiAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICAgIHBvc3RnYWluID0gZy5pbiggJ3Bvc3RnYWluJyApXG5cbiAgICAgIGxldCBsb3V0XG4gICAgICB7XG4gICAgICAgICd1c2UganNkc3AnXG5cbiAgICAgICAgY29uc3QgbGlucHV0ID0gaXNTdGVyZW8gPyBpbnB1dFswXSAqIGdhaW4gOiBpbnB1dCAqIGdhaW5cbiAgICAgICAgbG91dCA9IGxpbnB1dCAqIC4zMzNcbiAgICAgICAgbG91dCA9IHdhdmVzdGFnZSggd2F2ZXN0YWdlKCB3YXZlc3RhZ2UoIHdhdmVzdGFnZSggbG91dCApICkgKSApXG4gICAgICAgIGxvdXQgPSBsb3V0ICogLjZcbiAgICAgICAgbG91dCA9IGcudGFuaCggbG91dCApICogcG9zdGdhaW5cbiAgICAgIH1cblxuICAgICAgd2F2ZWZvbGRlci5ncmFwaCA9IGxvdXRcblxuICAgICAgaWYoIGlzU3RlcmVvICkge1xuICAgICAgICBsZXQgcm91dFxuICAgICAgICB7XG4gICAgICAgICAgJ3VzZSBqc2RzcCdcbiAgICAgICAgICBjb25zdCByaW5wdXQgPSBpc1N0ZXJlbyA/IGlucHV0WzFdICogZ2FpbiA6IGlucHV0ICogZ2FpblxuICAgICAgICAgIHJvdXQgPSByaW5wdXQgKiAuMzMzXG4gICAgICAgICAgcm91dCA9IHdhdmVzdGFnZSggd2F2ZXN0YWdlKCB3YXZlc3RhZ2UoIHdhdmVzdGFnZSggcm91dCApICkgKSApXG4gICAgICAgICAgcm91dCA9IHJvdXQgKiAuNlxuICAgICAgICAgIHJvdXQgPSBnLnRhbmgoIHJvdXQgKSAqIHBvc3RnYWluXG4gICAgICAgIH1cblxuICAgICAgICB3YXZlZm9sZGVyLmdyYXBoID0gWyBsb3V0LCByb3V0IF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXZlZm9sZGVyLl9fY3JlYXRlR3JhcGgoKVxuICAgIHdhdmVmb2xkZXIuX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdpbnB1dCcgXVxuXG4gICAgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIFxuICAgICAgd2F2ZWZvbGRlcixcbiAgICAgIHdhdmVmb2xkZXIuZ3JhcGgsIFxuICAgICAgWyAnZngnLCd3YXZlZm9sZGVyJyBdLCBcbiAgICAgIHByb3BzIFxuICAgIClcblxuICAgIHJldHVybiBvdXQgXG4gIH1cblxuICBXYXZlZm9sZGVyLmRlZmF1bHRzID0ge1xuICAgIGlucHV0OjAsXG4gICAgZ2FpbjoyLFxuICAgIHBvc3RnYWluOjFcbiAgfVxuXG4gIHJldHVybiBbIFdhdmVmb2xkZXIsIHdhdmVzdGFnZSBdXG5cbn1cbiIsImxldCBNZW1vcnlIZWxwZXIgPSByZXF1aXJlKCAnbWVtb3J5LWhlbHBlcicgKSxcbiAgICBnZW5pc2ggICAgICAgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG4gICAgXG5sZXQgR2liYmVyaXNoID0ge1xuICBibG9ja0NhbGxiYWNrczogW10sIC8vIGNhbGxlZCBldmVyeSBibG9ja1xuICBkaXJ0eVVnZW5zOiBbXSxcbiAgY2FsbGJhY2tVZ2VuczogW10sXG4gIGNhbGxiYWNrTmFtZXM6IFtdLFxuICBhbmFseXplcnM6IFtdLFxuICBncmFwaElzRGlydHk6IGZhbHNlLFxuICB1Z2Vuczoge30sXG4gIGRlYnVnOiBmYWxzZSxcbiAgaWQ6IC0xLFxuICBwcmV2ZW50UHJveHk6ZmFsc2UsXG4gIHByb3h5RW5hYmxlZDogdHJ1ZSxcblxuICBvdXRwdXQ6IG51bGwsXG5cbiAgbWVtb3J5IDogbnVsbCwgLy8gMjAgbWludXRlcyBieSBkZWZhdWx0P1xuICBmYWN0b3J5OiBudWxsLCBcbiAgZ2VuaXNoLFxuICBzY2hlZHVsZXI6IHJlcXVpcmUoICcuL3NjaGVkdWxpbmcvc2NoZWR1bGVyLmpzJyApLFxuICAvL3dvcmtsZXRQcm9jZXNzb3JMb2FkZXI6IHJlcXVpcmUoICcuL3dvcmtsZXRQcm9jZXNzb3IuanMnICksXG4gIHdvcmtsZXRQcm9jZXNzb3I6IG51bGwsXG5cbiAgbWVtb2VkOiB7fSxcbiAgbW9kZTonc2NyaXB0UHJvY2Vzc29yJyxcblxuICBwcm90b3R5cGVzOiB7XG4gICAgdWdlbjogbnVsbCwvL3JlcXVpcmUoJy4vdWdlbi5qcycpLFxuICAgIGluc3RydW1lbnQ6IHJlcXVpcmUoICcuL2luc3RydW1lbnRzL2luc3RydW1lbnQuanMnICksXG4gICAgZWZmZWN0OiByZXF1aXJlKCAnLi9meC9lZmZlY3QuanMnICksXG4gICAgYW5hbHl6ZXI6IHJlcXVpcmUoICcuL2FuYWx5c2lzL2FuYWx5emVyLmpzJyApXG4gIH0sXG5cbiAgbWl4aW5zOiB7XG4gICAgcG9seWluc3RydW1lbnQ6IHJlcXVpcmUoICcuL2luc3RydW1lbnRzL3BvbHlNaXhpbi5qcycgKVxuICB9LFxuXG4gIHdvcmtsZXRQYXRoOiAnLi9naWJiZXJpc2hfd29ya2xldC5qcycsXG5cbiAgaW5pdCggbWVtQW1vdW50LCBjdHgsIG1vZGU9J3dvcmtsZXQnICkge1xuICAgIGxldCBudW1CeXRlcyA9IGlzTmFOKCBtZW1BbW91bnQgKSA/IDIwICogNjAgKiA0NDEwMCA6IG1lbUFtb3VudFxuXG4gICAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBnaWJiZXJpc2ggaXMgdXNpbmcgd29ya2xldHMsXG4gICAgLy8gd2Ugc3RpbGwgd2FudCBnZW5pc2ggdG8gb3V0cHV0IHZhbmlsbGEganMgZnVuY3Rpb25zIGluc3RlYWRcbiAgICAvLyBvZiBhdWRpbyB3b3JrbGV0IGNsYXNzZXM7IHRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZFxuICAgIC8vIGZyb20gd2l0aGluIHRoZSBnaWJiZXJpc2ggYXVkaW93b3JrbGV0IHByb2Nlc3NvciBub2RlLlxuICAgIHRoaXMuZ2VuaXNoLmdlbi5tb2RlID0gJ3NjcmlwdFByb2Nlc3NvcidcblxuICAgIHRoaXMubWVtb3J5ID0gTWVtb3J5SGVscGVyLmNyZWF0ZSggbnVtQnl0ZXMsIEZsb2F0NjRBcnJheSApXG5cbiAgICB0aGlzLm1vZGUgPSBtb2RlXG5cbiAgICBjb25zdCBzdGFydHVwID0gdGhpcy51dGlsaXRpZXMuY3JlYXRlV29ya2xldFxuXG4gICAgdGhpcy5zY2hlZHVsZXIuaW5pdCggdGhpcyApXG4gICAgXG4gICAgdGhpcy5hbmFseXplcnMuZGlydHkgPSBmYWxzZVxuXG4gICAgaWYoIHRoaXMubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuXG4gICAgICBjb25zdCBwID0gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcHAgPSBuZXcgUHJvbWlzZSggKF9fcmVzb2x2ZSwgX19yZWplY3QgKSA9PiB7XG4gICAgICAgICAgdGhpcy51dGlsaXRpZXMuY3JlYXRlQ29udGV4dCggY3R4LCBzdGFydHVwLmJpbmQoIHRoaXMudXRpbGl0aWVzICksIF9fcmVzb2x2ZSApXG4gICAgICAgIH0pLnRoZW4oICgpPT4ge1xuICAgICAgICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSB0cnVlXG4gICAgICAgICAgR2liYmVyaXNoLmxvYWQoKVxuICAgICAgICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSBmYWxzZVxuICAgICAgICAgIEdpYmJlcmlzaC5vdXRwdXQgPSB0aGlzLkJ1czIoKVxuXG4gICAgICAgICAgLy8gR2liYmVyaXNoLm91dHB1dCBuZWVkcyB0byBiZSBhc3NpZ24gc28gdGhhdCB1Z2VucyBjYW5cbiAgICAgICAgICAvLyBjb25uZWN0IHRvIGl0IGJ5IGRlZmF1bHQuIFRoZXJlJ3Mgbm8gb3RoZXIgd2F5IHRvIGFzc2lnbiBpdFxuICAgICAgICAgIC8vIG91dHNpZGUgb2YgZXZhbGluZyBjb2RlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IFxuICAgICAgICAgICAgYWRkcmVzczonZXZhbCcsIFxuICAgICAgICAgICAgY29kZTpgR2liYmVyaXNoLm91dHB1dCA9IHRoaXMudWdlbnMuZ2V0KCR7R2liYmVyaXNoLm91dHB1dC5pZH0pO2AgXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9KVxuXG4gICAgICB9KVxuICAgICAgXG4gICAgICByZXR1cm4gcFxuXG4gICAgfWVsc2UgaWYoIHRoaXMubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICBHaWJiZXJpc2gubG9hZCgpXG4gICAgfVxuICB9LFxuXG4gIGxvYWQoKSB7XG4gICAgdGhpcy5mYWN0b3J5ICAgICAgPSByZXF1aXJlKCAnLi9mYWN0b3J5LmpzJyApKCB0aGlzIClcbiAgICBcbiAgICB0aGlzLlBhbm5lciAgICAgICA9IHJlcXVpcmUoICcuL21pc2MvcGFubmVyLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLlBvbHlUZW1wbGF0ZSA9IHJlcXVpcmUoICcuL2luc3RydW1lbnRzL3BvbHl0ZW1wbGF0ZS5qcycgKSggdGhpcyApXG4gICAgdGhpcy5vc2NpbGxhdG9ycyAgPSByZXF1aXJlKCAnLi9vc2NpbGxhdG9ycy9vc2NpbGxhdG9ycy5qcycgKSggdGhpcyApXG4gICAgdGhpcy5maWx0ZXJzICAgICAgPSByZXF1aXJlKCAnLi9maWx0ZXJzL2ZpbHRlcnMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuYmlub3BzICAgICAgID0gcmVxdWlyZSggJy4vbWlzYy9iaW5vcHMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMubW9ub3BzICAgICAgID0gcmVxdWlyZSggJy4vbWlzYy9tb25vcHMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuQnVzICAgICAgICAgID0gcmVxdWlyZSggJy4vbWlzYy9idXMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuQnVzMiAgICAgICAgID0gcmVxdWlyZSggJy4vbWlzYy9idXMyLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLmluc3RydW1lbnRzICA9IHJlcXVpcmUoICcuL2luc3RydW1lbnRzL2luc3RydW1lbnRzLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLmZ4ICAgICAgICAgICA9IHJlcXVpcmUoICcuL2Z4L2VmZmVjdHMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuU2VxdWVuY2VyICAgID0gcmVxdWlyZSggJy4vc2NoZWR1bGluZy9zZXF1ZW5jZXIuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuU2VxdWVuY2VyMiAgID0gcmVxdWlyZSggJy4vc2NoZWR1bGluZy9zZXEyLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLlRpZGFsICAgICAgICA9IHJlcXVpcmUoICcuL3NjaGVkdWxpbmcvdGlkYWwuanMnICkoIHRoaXMgKVxuICAgIHRoaXMuZW52ZWxvcGVzICAgID0gcmVxdWlyZSggJy4vZW52ZWxvcGVzL2VudmVsb3Blcy5qcycgKSggdGhpcyApXG4gICAgdGhpcy5hbmFseXNpcyAgICAgPSByZXF1aXJlKCAnLi9hbmFseXNpcy9hbmFseXplcnMuanMnICkoIHRoaXMgKVxuICAgIHRoaXMudGltZSAgICAgICAgID0gcmVxdWlyZSggJy4vbWlzYy90aW1lLmpzJyApKCB0aGlzIClcbiAgICB0aGlzLlByb3h5ICAgICAgICA9IHJlcXVpcmUoICcuL3dvcmtsZXRQcm94eS5qcycgKSggdGhpcyApXG4gIH0sXG5cbiAgZXhwb3J0KCB0YXJnZXQsIHNob3VsZEV4cG9ydEdlbmlzaD1mYWxzZSApIHtcbiAgICBpZiggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB0aHJvdyBFcnJvcignWW91IG11c3QgZGVmaW5lIGEgdGFyZ2V0IG9iamVjdCBmb3IgR2liYmVyaXNoIHRvIGV4cG9ydCB2YXJpYWJsZXMgdG8uJylcblxuICAgIGlmKCBzaG91bGRFeHBvcnRHZW5pc2ggKSB0aGlzLmdlbmlzaC5leHBvcnQoIHRhcmdldCApXG5cbiAgICB0aGlzLmluc3RydW1lbnRzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLmZ4LmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLmZpbHRlcnMuZXhwb3J0KCB0YXJnZXQgKVxuICAgIHRoaXMub3NjaWxsYXRvcnMuZXhwb3J0KCB0YXJnZXQgKVxuICAgIHRoaXMuYmlub3BzLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLm1vbm9wcy5leHBvcnQoIHRhcmdldCApXG4gICAgdGhpcy5lbnZlbG9wZXMuZXhwb3J0KCB0YXJnZXQgKVxuICAgIHRoaXMuYW5hbHlzaXMuZXhwb3J0KCB0YXJnZXQgKVxuICAgIHRhcmdldC5TZXF1ZW5jZXIgPSB0aGlzLlNlcXVlbmNlclxuICAgIHRhcmdldC5TZXF1ZW5jZXIyID0gdGhpcy5TZXF1ZW5jZXIyXG4gICAgdGFyZ2V0LkJ1cyA9IHRoaXMuQnVzXG4gICAgdGFyZ2V0LkJ1czIgPSB0aGlzLkJ1czJcbiAgICB0YXJnZXQuU2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXJcbiAgICB0YXJnZXQuVGlkYWwgPSB0aGlzLlRpZGFsXG4gICAgdGhpcy50aW1lLmV4cG9ydCggdGFyZ2V0IClcbiAgICB0aGlzLnV0aWxpdGllcy5leHBvcnQoIHRhcmdldCApXG4gIH0sXG5cbiAgcHJpbnRjYigpIHsgXG4gICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7IGFkZHJlc3M6J2NhbGxiYWNrJyB9KSBcbiAgfSxcbiAgcHJpbnRvYmooIG9iaiApIHtcbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgYWRkcmVzczoncHJpbnQnLCBvYmplY3Q6b2JqLmlkIH0pIFxuICB9LFxuICBzZW5kKCBtc2cgKXtcbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBtc2cgKVxuICB9LFxuXG4gIGRpcnR5KCB1Z2VuICkge1xuICAgIGlmKCB1Z2VuID09PSB0aGlzLmFuYWx5emVycyApIHtcbiAgICAgIHRoaXMuZ3JhcGhJc0RpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5hbmFseXplcnMuZGlydHkgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlydHlVZ2Vucy5wdXNoKCB1Z2VuIClcbiAgICAgIHRoaXMuZ3JhcGhJc0RpcnR5ID0gdHJ1ZVxuICAgICAgaWYoIHRoaXMubWVtb2VkWyB1Z2VuLnVnZW5OYW1lIF0gKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9lZFsgdWdlbi51Z2VuTmFtZSBdXG4gICAgICB9XG4gICAgfSBcbiAgfSxcblxuICBjbGVhcigpIHtcbiAgICAvLyBkbyBub3QgZGVsZXRlIHRoZSBnYWluIGFuZCB0aGUgcGFuIG9mIHRoZSBtYXN0ZXIgYnVzIFxuICAgIHRoaXMub3V0cHV0LmlucHV0cy5zcGxpY2UoIDAsIHRoaXMub3V0cHV0LmlucHV0cy5sZW5ndGggLSAyIClcbiAgICAvL3RoaXMub3V0cHV0LmlucHV0TmFtZXMubGVuZ3RoID0gMFxuICAgIHRoaXMuYW5hbHl6ZXJzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnNjaGVkdWxlci5jbGVhcigpXG4gICAgdGhpcy5kaXJ0eSggdGhpcy5vdXRwdXQgKVxuICAgIGlmKCB0aGlzLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIHRoaXMud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgIGFkZHJlc3M6J21ldGhvZCcsIFxuICAgICAgICBvYmplY3Q6dGhpcy5pZCxcbiAgICAgICAgbmFtZTonY2xlYXInLFxuICAgICAgICBhcmdzOltdXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyBjbGVhciBtZW1vcnkuLi4gWFhYIHNob3VsZCB0aGlzIGJlIGEgTWVtb3J5SGVscGVyIGZ1bmN0aW9uP1xuICAgIC8vdGhpcy5tZW1vcnkuaGVhcC5maWxsKDApXG4gICAgLy90aGlzLm1lbW9yeS5saXN0ID0ge31cblxuICAgIEdpYmJlcmlzaC5nZW5pc2guZ2VuLnJlbW92ZUFsbExpc3RlbmVycygnbWVtb3J5IGluaXQnKVxuICAgIEdpYmJlcmlzaC5nZW5pc2guZ2VuLmhpc3Rvcmllcy5jbGVhcigpXG5cbiAgICAvL0dpYmJlcmlzaC5vdXRwdXQgPSB0aGlzLkJ1czIoKVxuICAgIFxuICB9LFxuXG4gIC8vIHVzZWQgdG8gc29ydCBhbmFseXNpcyB1Z2VucyBieSBwcmlvcml0eS5cbiAgLy8gaGlnaGVyIHByaW9yaXRpZXMgbWVhbiBsb3dlciBvcmRlcmluZyBpbiB0aGUgYXJyYXksXG4gIC8vIHdoaWNoIG1lYW5zIHRoZXkgd2lsbCBydW4gZmlyc3QgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAvLyBieSBkZWZ1bHQsIGFuYWx5c2lzIHVnZW5zIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IG9mIDAgaW4gdGhlXG4gIC8vIGFuYWx5c2lzIHByb3RvdHlwZS5cbiAgYW5hbHlzaXNDb21wYXJlKCBhLGIgKSB7XG4gICAgcmV0dXJuIChpc05hTihiLnByaW9yaXR5KSA/IDAgOiBiLnByaW9yaXR5KSAtIChpc05hTihhLnByaW9yaXR5KSA/IDA6IGEucHJpb3JpdHkgKVxuICB9LFxuXG4gIGdlbmVyYXRlQ2FsbGJhY2soKSB7XG4gICAgaWYoIHRoaXMubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgR2liYmVyaXNoLmNhbGxiYWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwIH1cbiAgICAgIEdpYmJlcmlzaC5jYWxsYmFjay5vdXQgPSBbXVxuICAgICAgcmV0dXJuIEdpYmJlcmlzaC5jYWxsYmFja1xuICAgIH1cbiAgICBsZXQgdWlkID0gMCxcbiAgICAgICAgY2FsbGJhY2tCb2R5LCBsYXN0TGluZSwgYW5hbHlzaXM9JydcblxuICAgIHRoaXMubWVtb2VkID0ge31cblxuICAgIGNhbGxiYWNrQm9keSA9IHRoaXMucHJvY2Vzc0dyYXBoKCB0aGlzLm91dHB1dCApXG4gICAgbGFzdExpbmUgPSBjYWxsYmFja0JvZHlbIGNhbGxiYWNrQm9keS5sZW5ndGggLSAxXVxuICAgIGNhbGxiYWNrQm9keS51bnNoaWZ0KCBcIlxcdCd1c2Ugc3RyaWN0J1wiIClcblxuICAgIHRoaXMuYW5hbHl6ZXJzXG4gICAgICAuc29ydCggdGhpcy5hbmFseXNpc0NvbXBhcmUgKVxuICAgICAgLmZvckVhY2goIHY9PiB7XG4gICAgICAgIGNvbnN0IGFuYWx5c2lzQmxvY2sgPSBHaWJiZXJpc2gucHJvY2Vzc1VnZW4oIHYgKVxuICAgICAgICAvL2lmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIC8vICBjb25zb2xlLmxvZyggJ2FuYWx5c2lzOicsIGFuYWx5c2lzQmxvY2ssIHYgIClcbiAgICAgICAgLy99XG4gICAgICAgIGxldCBhbmFseXNpc0xpbmVcblxuICAgICAgICBpZiggdHlwZW9mIGFuYWx5c2lzQmxvY2sgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgIGFuYWx5c2lzTGluZSA9IGFuYWx5c2lzQmxvY2sucG9wKClcblxuICAgICAgICAgIGFuYWx5c2lzQmxvY2suZm9yRWFjaCggdiA9PiB7XG4gICAgICAgICAgICBjYWxsYmFja0JvZHkuc3BsaWNlKCBjYWxsYmFja0JvZHkubGVuZ3RoIC0gMSwgMCwgdiApXG4gICAgICAgICAgfSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgYW5hbHlzaXNMaW5lID0gYW5hbHlzaXNCbG9ja1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2tCb2R5LnB1c2goIGFuYWx5c2lzTGluZSApXG4gICAgICB9KVxuXG4gICAgdGhpcy5hbmFseXplcnMuZm9yRWFjaCggdiA9PiB7XG4gICAgICBpZiggdGhpcy5jYWxsYmFja1VnZW5zLmluZGV4T2YoIHYuY2FsbGJhY2sgKSA9PT0gLTEgKVxuICAgICAgICB0aGlzLmNhbGxiYWNrVWdlbnMucHVzaCggdi5jYWxsYmFjayApXG4gICAgfSlcblxuICAgIHRoaXMuY2FsbGJhY2tOYW1lcyA9IHRoaXMuY2FsbGJhY2tVZ2Vucy5tYXAoIHYgPT4gdi51Z2VuTmFtZSApXG5cbiAgICBjYWxsYmFja0JvZHkucHVzaCggJ1xcblxcdHJldHVybiAnICsgbGFzdExpbmUuc3BsaXQoICc9JyApWzBdLnNwbGl0KCAnICcgKVsxXSApXG5cbiAgICBpZiggdGhpcy5kZWJ1ZyA9PT0gdHJ1ZSApIGNvbnNvbGUubG9nKCAnY2FsbGJhY2s6XFxuJywgY2FsbGJhY2tCb2R5LmpvaW4oJ1xcbicpIClcbiAgICBcbiAgICB0aGlzLmNhbGxiYWNrTmFtZXMucHVzaCggJ21lbScgKVxuICAgIHRoaXMuY2FsbGJhY2tVZ2Vucy5wdXNoKCB0aGlzLm1lbW9yeS5oZWFwIClcbiAgICB0aGlzLmNhbGxiYWNrID0gRnVuY3Rpb24oIC4uLnRoaXMuY2FsbGJhY2tOYW1lcywgY2FsbGJhY2tCb2R5LmpvaW4oICdcXG4nICkgKS8vLmJpbmQoIG51bGwsIC4uLnRoaXMuY2FsbGJhY2tVZ2VucyApXG4gICAgdGhpcy5jYWxsYmFjay5vdXQgPSBbXVxuXG4gICAgaWYoIHRoaXMub25jYWxsYmFjayApIHRoaXMub25jYWxsYmFjayggdGhpcy5jYWxsYmFjayApXG5cbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayBcbiAgfSxcblxuICBwcm9jZXNzR3JhcGgoIG91dHB1dCApIHtcbiAgICB0aGlzLmNhbGxiYWNrVWdlbnMubGVuZ3RoID0gMFxuICAgIHRoaXMuY2FsbGJhY2tOYW1lcy5sZW5ndGggPSAwXG5cbiAgICB0aGlzLmNhbGxiYWNrVWdlbnMucHVzaCggb3V0cHV0LmNhbGxiYWNrIClcblxuICAgIGxldCBib2R5ID0gdGhpcy5wcm9jZXNzVWdlbiggb3V0cHV0IClcbiAgICBcblxuICAgIHRoaXMuZGlydHlVZ2Vucy5sZW5ndGggPSAwXG4gICAgdGhpcy5ncmFwaElzRGlydHkgPSBmYWxzZVxuXG4gICAgcmV0dXJuIGJvZHlcbiAgfSxcbiAgcHJveHlSZXBsYWNlKCBvYmogKSB7XG4gICAgaWYoIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCApIHtcbiAgICAgIGlmKCBvYmouaWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgY29uc3QgX19vYmogPSBHaWJiZXJpc2gucHJvY2Vzc29yLnVnZW5zLmdldCggb2JqLmlkIClcbiAgICAgICAgLy9jb25zb2xlLmxvZyggJ3JldHJpZXZlZDonLCBfX29iai5uYW1lIClcblxuICAgICAgICAvL2lmKCBvYmoucHJvcCAhPT0gdW5kZWZpbmVkICkgY29uc29sZS5sb2coICdnb3QgYSBzc2Qub3V0Jywgb2JqIClcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wICE9PSB1bmRlZmluZWQgPyBfX29ialsgb2JqLnByb3AgXSA6IF9fb2JqXG4gICAgICB9ZWxzZSBpZiggb2JqLmlzRnVuYyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgbGV0IGZ1bmMgPSAgZXZhbCggJygnICsgb2JqLnZhbHVlICsgJyknIClcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCAncmVwbGFjaW5nIGZ1bmN0aW9uOicsIGZ1bmMgKVxuXG4gICAgICAgIHJldHVybiBmdW5jXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialxuICB9LFxuXG4gIHByb2Nlc3NVZ2VuKCB1Z2VuLCBibG9jayApIHtcbiAgICBpZiggYmxvY2sgPT09IHVuZGVmaW5lZCApIGJsb2NrID0gW11cbiAgICBpZiggdWdlbiA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGJsb2NrXG5cblxuICAgIGxldCBkaXJ0eUlkeCA9IEdpYmJlcmlzaC5kaXJ0eVVnZW5zLmluZGV4T2YoIHVnZW4gKVxuXG4gICAgbGV0IG1lbW8gPSBHaWJiZXJpc2gubWVtb2VkWyB1Z2VuLnVnZW5OYW1lIF1cblxuICAgIGlmKCBtZW1vICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICByZXR1cm4gbWVtb1xuICAgIH0gZWxzZSBpZiggdWdlbiA9PT0gdHJ1ZSB8fCB1Z2VuID09PSBmYWxzZSApIHtcbiAgICAgIHRocm93IFwiV2h5IGlzIHVnZW4gYSBib29sZWFuPyBbdHJ1ZV0gb3IgW2ZhbHNlXVwiO1xuICAgIH0gZWxzZSBpZiggdWdlbi5ibG9jayA9PT0gdW5kZWZpbmVkIHx8IGRpcnR5SW5kZXggIT09IC0xICkge1xuICAgICAgLy8gd2VpcmQgZWRnZSBjYXNlIHdpdGggYW5hbHlzaXMgKGZvbGxvdykgdWdlblxuICAgICAgaWYoIHVnZW4uaWQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdWdlbi5pZCA9IHVnZW4uX19wcm9wZXJ0aWVzX18ub3ZlcnJpZGVpZFxuICAgICAgfVxuXG4gICAgICBsZXQgbGluZSA9IGBcXHRjb25zdCB2XyR7dWdlbi5pZH0gPSBgIFxuICAgICAgaWYoICF1Z2VuLmlzb3AgKSBsaW5lICs9IGAke3VnZW4udWdlbk5hbWV9KCBgXG5cbiAgICAgIC8vIG11c3QgZ2V0IGFycmF5IHNvIHdlIGNhbiBrZWVwIHRyYWNrIG9mIGxlbmd0aCBmb3IgY29tbWEgaW5zZXJ0aW9uXG4gICAgICBjb25zdCBrZXlzID0gdWdlbi5pc29wID09PSB0cnVlIHx8IHVnZW4udHlwZSA9PT0gJ2J1cycgIFxuICAgICAgICA/IE9iamVjdC5rZXlzKCB1Z2VuLmlucHV0cyApIFxuICAgICAgICA6IFsuLi51Z2VuLmlucHV0TmFtZXMgXSBcblxuICAgICAgbGluZSA9IHVnZW4uaXNvcCA9PT0gdHJ1ZSBcbiAgICAgICAgPyBHaWJiZXJpc2guX19wcm9jZXNzQmlub3AoIHVnZW4sIGxpbmUsIGJsb2NrLCBrZXlzICkgXG4gICAgICAgIDogR2liYmVyaXNoLl9fcHJvY2Vzc05vbkJpbm9wKCB1Z2VuLCBsaW5lLCBibG9jaywga2V5cyApXG5cbiAgICAgIGxpbmUgPSBHaWJiZXJpc2guX19hZGRMaW5lRW5kaW5nKCBsaW5lLCB1Z2VuLCBrZXlzIClcblxuICAgICAgYmxvY2sucHVzaCggbGluZSApXG4gICAgICBcbiAgICAgIEdpYmJlcmlzaC5tZW1vZWRbIHVnZW4udWdlbk5hbWUgXSA9IGB2XyR7dWdlbi5pZH1gXG5cbiAgICAgIGlmKCBkaXJ0eUlkeCAhPT0gLTEgKSB7XG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eVVnZW5zLnNwbGljZSggZGlydHlJZHgsIDEgKVxuICAgICAgfVxuXG4gICAgfWVsc2UgaWYoIHVnZW4uYmxvY2sgKSB7XG4gICAgICByZXR1cm4gdWdlbi5ibG9ja1xuICAgIH1cblxuICAgIHJldHVybiBibG9ja1xuICB9LCBcblxuICBfX3Byb2Nlc3NCaW5vcCggdWdlbiwgbGluZSwgYmxvY2ssIGtleXMgKSB7XG4gICAgLy9fX2dldElucHV0U3RyaW5nKCBsaW5lLCBpbnB1dCwgYmxvY2ssIGtleSwgdWdlbiApIHtcbiAgICBjb25zdCBpc0xlZnRTdGVyZW8gPSBHaWJiZXJpc2guX19pc1N0ZXJlbyggdWdlbi5pbnB1dHNbMF0gKSwgXG4gICAgICAgICAgaXNSaWdodFN0ZXJlbyA9IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCB1Z2VuLmlucHV0c1sxXSApLFxuICAgICAgICAgIGxlZnQgPSBHaWJiZXJpc2guX19nZXRJbnB1dFN0cmluZyggbGluZSwgdWdlbi5pbnB1dHNbMF0sIGJsb2NrLCAnMCcsIGtleXMgKSxcbiAgICAgICAgICByaWdodD0gR2liYmVyaXNoLl9fZ2V0SW5wdXRTdHJpbmcoIGxpbmUsIHVnZW4uaW5wdXRzWzFdLCBibG9jaywgJzEnLCBrZXlzICksXG4gICAgICAgICAgb3AgPSB1Z2VuLm9wXG4gICAgICAgIFxuICAgIGxldCBncmFwaCwgb3V0XG5cbiAgICBpZiggaXNMZWZ0U3RlcmVvID09PSB0cnVlICYmIGlzUmlnaHRTdGVyZW8gPT09IGZhbHNlICkge1xuICAgICAgbGluZSArPSBgWyAke2xlZnR9WzBdICR7b3B9ICR7cmlnaHR9LCAke2xlZnR9WzFdICR7b3B9ICR7cmlnaHR9IF1gXG4gICAgICAvL2dyYXBoID0gWyBnLmFkZCggYXJnc1swXS5ncmFwaFswXSwgYXJnc1sxXSApLCBnLmFkZCggYXJnc1swXS5ncmFwaFsxXSwgYXJnc1sxXSApXVxuICAgIH1lbHNlIGlmKCBpc0xlZnRTdGVyZW8gPT09IGZhbHNlICYmIGlzUmlnaHRTdGVyZW8gPT09IHRydWUgKSB7XG4gICAgICAvL2dyYXBoID0gWyBnLmFkZCggYXJnc1swXSwgYXJnc1sxXS5ncmFwaFswXSApLCBnLmFkZCggYXJnc1swXSwgYXJnc1sxXS5ncmFwaFsxXSApXVxuICAgICAgbGluZSArPSBgWyAke2xlZnR9ICR7b3B9ICR7cmlnaHR9WzBdLCAke2xlZnR9ICR7b3B9ICR7cmlnaHR9WzFdIF1gXG4gICAgfWVsc2UgaWYoIGlzTGVmdFN0ZXJlbyA9PT0gdHJ1ZSAmJiBpc1JpZ2h0U3RlcmVvID09PSB0cnVlICkge1xuICAgICAgLy9ncmFwaCA9IFsgZy5hZGQoIGFyZ3NbMF0uZ3JhcGhbMF0sIGFyZ3NbMV0uZ3JhcGhbMF0gKSwgZy5hZGQoIGFyZ3NbMF0uZ3JhcGhbMV0sIGFyZ3NbMV0uZ3JhcGhbMV0gKV1cbiAgICAgIGxpbmUgKz0gYFsgJHtsZWZ0fVswXSAke29wfSAke3JpZ2h0fVswXSwgJHtsZWZ0fVsxXSAke29wfSAke3JpZ2h0fVsxXSBdYFxuICAgIH1lbHNle1xuICAgICAgLy8gWFhYIGltcG9ydGFudCwgbXVzdCByZS1hc3NpZ24gd2hlbiBjYWxsaW5nIHByb2Nlc3NOb25CaW5vcFxuICAgICAgbGluZSA9IEdpYmJlcmlzaC5fX3Byb2Nlc3NOb25CaW5vcCggdWdlbiwgbGluZSwgYmxvY2ssIGtleXMgKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbGluZVxuICB9LFxuXG4gIF9fcHJvY2Vzc05vbkJpbm9wKCB1Z2VuLCBsaW5lLCBibG9jaywga2V5cyApIHtcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBsZXQga2V5ID0ga2V5c1sgaSBdXG4gICAgICAvLyBiaW5vcC5pbnB1dHMgaXMgYWN0dWFsIHZhbHVlcywgbm90IGp1c3QgcHJvcGVydHkgbmFtZXNcbiAgICAgIGxldCBpbnB1dCBcbiAgICAgIGlmKCB1Z2VuLmlzb3AgfHwgdWdlbi50eXBlID09PSdidXMnICkge1xuICAgICAgICBpbnB1dCA9IHVnZW4uaW5wdXRzWyBrZXkgXVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlucHV0ID0gdWdlblsga2V5IF0gXG4gICAgICB9XG5cbiAgICAgIGlmKCBpbnB1dCAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgaW5wdXQgPSBHaWJiZXJpc2guX19nZXRCeXBhc3NlZElucHV0KCBpbnB1dCApXG4gICAgICAgIGxpbmUgKz0gR2liYmVyaXNoLl9fZ2V0SW5wdXRTdHJpbmcoIGxpbmUsIGlucHV0LCBibG9jaywga2V5LCB1Z2VuIClcbiAgICAgICAgbGluZSAgPSBHaWJiZXJpc2guX19hZGRTZXBhcmF0b3IoIGxpbmUsIGlucHV0LCB1Z2VuLCBpIDwga2V5cy5sZW5ndGggLSAxIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZVxuICB9LFxuXG4gIC8vIGRldGVybWluZSBpZiBhIHVnZW4gaXMgc3RlcmVvXG4gIF9faXNTdGVyZW8oIHVnZW4gKSB7XG4gICAgbGV0IGlzU3RlcmVvID0gZmFsc2VcblxuICAgIGlmKCB1Z2VuID09PSB1bmRlZmluZWQgfHwgdWdlbiA9PT0gbnVsbCApIHJldHVybiBmYWxzZVxuXG4gICAgaWYoIHVnZW4uaXNTdGVyZW8gPT09IHRydWUgKSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYoIHVnZW4uaXNvcCA9PT0gdHJ1ZSApIHtcbiAgICAgIHJldHVybiBHaWJiZXJpc2guX19pc1N0ZXJlbyggdWdlbi5pbnB1dHNbMF0gKSB8fCBHaWJiZXJpc2guX19pc1N0ZXJlbyggdWdlbi5pbnB1dHNbMV0gKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaXNTdGVyZW9cbiAgfSxcblxuICAvLyBpZiBhbiBlZmZlY3QgaXMgYnlwYXNzZWQsIGdldCBuZXh0IG9uZSBpbiBjaGFpbiAob3Igb3V0cHV0IGRlc3RpbmF0aW9uKVxuICBfX2dldEJ5cGFzc2VkSW5wdXQoIGlucHV0ICkge1xuICAgIGlmKCBpbnB1dC5ieXBhc3MgPT09IHRydWUgKSB7XG4gICAgICAvLyBsb29wIHRocm91Z2ggaW5wdXRzIG9mIGNoYWluIHVudGlsIG9uZSBpcyBmb3VuZFxuICAgICAgLy8gdGhhdCBpcyBub3QgYmVpbmcgYnlwYXNzZWRcblxuICAgICAgbGV0IGZvdW5kID0gZmFsc2VcblxuICAgICAgd2hpbGUoIGlucHV0LmlucHV0ICE9PSAndW5kZWZpbmVkJyAmJiBmb3VuZCA9PT0gZmFsc2UgKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgaW5wdXQuaW5wdXQuYnlwYXNzICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LmlucHV0XG4gICAgICAgICAgaWYoIGlucHV0LmJ5cGFzcyA9PT0gZmFsc2UgKSBmb3VuZCA9IHRydWVcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5pbnB1dFxuICAgICAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0XG4gIH0sXG5cbiAgLy8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHVnZW4gZm9yIGluc2VydGlvbiBpbnRvIGNhbGxiYWNrLlxuICAvLyBpZiBhIHVnZW4gY29udGFpbnMgb3RoZXIgdWdlbnMsIHRyaWdnZXIgY29kZWdlbiBmb3IgdGhvc2UgdWdlbnMgYXMgd2VsbC5cbiAgX19nZXRJbnB1dFN0cmluZyggbGluZSwgaW5wdXQsIGJsb2NrLCBrZXksIHVnZW4gKSB7XG4gICAgbGV0IHZhbHVlID0gJydcbiAgICBpZiggdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyApIHtcbiAgICAgIGlmKCBpc05hTihrZXkpICkge1xuICAgICAgICB2YWx1ZSArPSBgbWVtWyR7dWdlbi5fX2FkZHJlc3Nlc19fWyBrZXkgXX1dYC8vaW5wdXRcbiAgICAgIH1lbHNle1xuICAgICAgICB2YWx1ZSArPSBpbnB1dFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICB2YWx1ZSArPSAnJyArIGlucHV0XG4gICAgfWVsc2V7XG4gICAgICAvL2NvbnNvbGUubG9nKCAna2V5OicsIGtleSwgJ2lucHV0OicsIHVnZW4uaW5wdXRzLCB1Z2VuLmlucHV0c1sga2V5IF0gKSBcbiAgICAgIC8vIFhYWCBub3Qgc3VyZSB3aHkgdGhpcyBoYXMgdG8gYmUgaGVyZSwgYnV0IHNvbWVob3cgbm9uLXByb2Nlc3NlZCBvYmplY3RzXG4gICAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBpZCBudW1iZXJzIGFyZSBiZWluZyBwYXNzZWQgaGVyZS4uLlxuXG4gICAgICBpZiggaW5wdXQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICBpZiggaW5wdXQudWdlbk5hbWUgPT09IHVuZGVmaW5lZCAmJiBpbnB1dC5pZCAhPT0gdW5kZWZpbmVkICApIHtcbiAgICAgICAgICAgIGlmKCB1Z2VuID09PSB1bmRlZmluZWQgICkge1xuICAgICAgICAgICAgICBpbnB1dCA9IEdpYmJlcmlzaC5wcm9jZXNzb3IudWdlbnMuZ2V0KCBpbnB1dC5pZCApXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoIHVnZW4udHlwZSAhPT0gJ3NlcScgKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBHaWJiZXJpc2gucHJvY2Vzc29yLnVnZW5zLmdldCggaW5wdXQuaWQgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgR2liYmVyaXNoLnByb2Nlc3NVZ2VuKCBpbnB1dCwgYmxvY2sgKVxuXG4gICAgICAgIGlmKCAhaW5wdXQuaXNvcCApIHtcbiAgICAgICAgICAvLyBjaGVjayBpcyBuZWVkZWQgc28gdGhhdCBncmFwaHMgd2l0aCBzc2RzIHRoYXQgcmVmZXIgdG8gdGhlbXNlbHZlc1xuICAgICAgICAgIC8vIGRvbid0IGFkZCB0aGUgc3NkIGluIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgaWYoIEdpYmJlcmlzaC5jYWxsYmFja1VnZW5zLmluZGV4T2YoIGlucHV0LmNhbGxiYWNrICkgPT09IC0xICkge1xuICAgICAgICAgICAgR2liYmVyaXNoLmNhbGxiYWNrVWdlbnMucHVzaCggaW5wdXQuY2FsbGJhY2sgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICs9IGB2XyR7aW5wdXQuaWR9YFxuICAgICAgICBpbnB1dC5fX3Zhcm5hbWUgPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9LFxuXG4gIC8vIGFkZCBzZXBhcmF0b3JzIGZvciBmdW5jdGlvbiBjYWxscyBhbmQgaGFuZGxlIGJpbm9wcyAobW9ubyBvbmx5KVxuICBfX2FkZFNlcGFyYXRvciggbGluZSwgaW5wdXQsIHVnZW4sIGlzTm90RW5kT2ZMaW5lICkge1xuICAgIGlmKCBpc05vdEVuZE9mTGluZSA9PT0gdHJ1ZSApIHtcbiAgICAgIGlmKCB1Z2VuLmlzb3AgPT09IHRydWUgKSB7XG4gICAgICAgIGlmKCB1Z2VuLm9wID09PSAnKicgfHwgdWdlbi5vcCA9PT0gJy8nICkge1xuICAgICAgICAgIGlmKCBpbnB1dCAhPT0gMSApIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJyAnICsgdWdlbi5vcCArICcgJ1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoIDAsIC0xICogKCcnK2lucHV0KS5sZW5ndGggKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbGluZSArPSAnICcgKyB1Z2VuLm9wICsgJyAnXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBsaW5lICs9ICcsICdcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZVxuICB9LFxuXG4gIC8vIGFkZCBtZW1vcnkgdG8gZW5kIG9mIGZ1bmN0aW9uIGNhbGxzIGFuZCBjbG9zZSBwYXJlbnRoZXNpcyBcbiAgX19hZGRMaW5lRW5kaW5nKCBsaW5lLCB1Z2VuLCBrZXlzICkge1xuICAgIGlmKCAodWdlbi50eXBlID09PSAnYnVzJyAmJiBrZXlzLmxlbmd0aCA+IDApICkgbGluZSArPSAnLCAnXG4gICAgaWYoICF1Z2VuLmlzb3AgJiYgdWdlbi50eXBlICE9PSAnc2VxJyApIGxpbmUgKz0gJ21lbSdcbiAgICBsaW5lICs9IHVnZW4uaXNvcCA/ICcnIDogJyApJ1xuXG4gICAgcmV0dXJuIGxpbmVcbiAgfSxcblxufVxuXG5HaWJiZXJpc2gucHJvdG90eXBlcy5VZ2VuID0gR2liYmVyaXNoLnByb3RvdHlwZXMudWdlbiA9IHJlcXVpcmUoICcuL3VnZW4uanMnICkoIEdpYmJlcmlzaCApXG5HaWJiZXJpc2gudXRpbGl0aWVzID0gcmVxdWlyZSggJy4vdXRpbGl0aWVzLmpzJyApKCBHaWJiZXJpc2ggKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdpYmJlcmlzaFxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG4gIFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IENsYXAgPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICAndXNlIGpzZHNwJyBcblxuICAgIGNvbnN0IGNsYXAgPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50ICksXG4gICAgICAgICAgZGVjYXkgPSBnLmluKCAnZGVjYXknICksIC8vIDAtMSBpbnB1dCB2YWx1ZVxuICAgICAgICAgIHNjYWxlZERlY2F5ID0gZGVjYXkgKiAoZy5nZW4uc2FtcGxlcmF0ZSAqIDIgKSxcbiAgICAgICAgICBnYWluICA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICAgIHNwYWNpbmcgPSBnLmluKCAnc3BhY2luZycgKSwgLy8gc3BhY2luZyBiZXR3ZWVuIGNsYXAsIGluIEh6c1xuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICBjdXRvZmYgPSBnLmluKCdjdXRvZmYnKSxcbiAgICAgICAgICBRICAgICAgPSBnLmluKCdRJylcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIENsYXAuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgY29uc3QgZWcgPSBnLmRlY2F5KCBzY2FsZWREZWNheSwgeyBpbml0VmFsdWU6MCB9ICksIFxuICAgICAgICAgIGNoZWNrID0gZy5ndCggZWcsIC4wMDA1ICksXG4gICAgICAgICAgbm9pc2UgPSAtMSArIGcubm9pc2UoKSAqIDIsXG4gICAgICAgICAgcm5kID0gbm9pc2UsLy9nLmd0cCggbm9pc2UsIDAgKSwvLyAqIGVnLFxuICAgICAgICAgIGIgICA9IGcuYmFuZygpLFxuICAgICAgICAgIHNhdyA9IGcucGhhc29yKCBzcGFjaW5nLCBiLCB7IG1pbjowIH0pLFxuICAgICAgICAgIHJzYXcgPSAxIC0gc2F3LFxuICAgICAgICAgIHNhd19lbnYgPSBnLmFkKCAwLCAuMDM1ICogZy5nZW4uc2FtcGxlcmF0ZSwgeyBzaGFwZTonbGluZWFyJyB9KSwgXG4gICAgICAgICAgYjIgPSBnLmJhbmcoKSxcbiAgICAgICAgICBjb3VudCA9IGcuYWNjdW0oIDEsYjIseyBtYXg6SW5maW5pdHksIG1pbjowLCBpbml0aWFsVmFsdWU6MCB9KSxcbiAgICAgICAgICBkZWxheWVkTm9pc2UgPSBnLnN3aXRjaCggZy5ndGUoIGNvdW50LCBnLmdlbi5zYW1wbGVyYXRlICogLjAzNSApLCBybmQsIDAgKSxcbiAgICAgICAgICBicGYxID0gZy5zdmYoIGRlbGF5ZWROb2lzZSwgMTAwMCwgLjUsIDIsIGZhbHNlICksXG5cbiAgICAgICAgICBzY2FsZWRPdXQgPSAoIGJwZjEgKiBlZyArICggcm5kICogcnNhdyAqIHNhd19lbnYgKSApICogZ2FpbiAqIGxvdWRuZXNzICogdHJpZ2dlckxvdWRuZXNzLFxuICAgICAgICAgIG91dCA9IGcuc3ZmKCBzY2FsZWRPdXQsIGN1dG9mZiwgUSwgMSwgZmFsc2UgKVxuICAgIFxuICAgIC8vIFhYWCBUT0RPIDogbWFrZSB0aGlzIHdvcmsgd2l0aCBpZmVsc2UuIHRoZSBwcm9ibGVtIGlzIHRoYXQgcG9rZSB1Z2VucyBwdXQgdGhlaXJcbiAgICAvLyBjb2RlIGF0IHRoZSBib3R0b20gb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpbnN0ZWFkIG9mIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gYXNzb2NpYXRlZCBpZi9lbHNlIGJsb2NrLlxuICAgIGNvbnN0IGlmZSA9IGcuc3dpdGNoKCBjaGVjaywgb3V0LCAwIClcbiAgICBcbiAgICBjbGFwLmVudiA9IHtcbiAgICAgIHRyaWdnZXIoIHZvbCApIHtcbiAgICAgICAgYi50cmlnZ2VyKClcbiAgICAgICAgZWcudHJpZ2dlciggdm9sIClcbiAgICAgICAgYjIudHJpZ2dlcigpXG4gICAgICAgIHNhd19lbnYudHJpZ2dlcigpXG4gICAgICB9XG4gICAgfSBcbiAgICBcbiAgICByZXR1cm4gR2liYmVyaXNoLmZhY3RvcnkoIGNsYXAsIGlmZSwgWydpbnN0cnVtZW50cycsJ2NsYXAnXSwgcHJvcHMgIClcbiAgfVxuICBcbiAgQ2xhcC5kZWZhdWx0cyA9IHtcbiAgICBnYWluOiAxLFxuICAgIHNwYWNpbmc6MTAwLFxuICAgIGRlY2F5Oi4yLFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MSxcbiAgICBjdXRvZmY6OTAwLFxuICAgIFE6Ljg1XG4gIH1cblxuICByZXR1cm4gQ2xhcFxuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApLFxuICAgICAgX193YXZlZm9sZCAgID0gcmVxdWlyZSggJy4uL2Z4L3dhdmVmb2xkZXIuZHNwLmpzJyApXG5cbmNvbnN0IGdlbmlzaCA9IGdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCB3YXZlZm9sZCA9IF9fd2F2ZWZvbGQoIEdpYmJlcmlzaCApWzFdXG5cbiAgY29uc3QgQ29tcGxleCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHN5biA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuXG4gICAgY29uc3QgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBsb3VkbmVzcyAgPSBnLmluKCAnbG91ZG5lc3MnICksIFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICBnbGlkZSAgID0gZy5tYXgoIDEsIGcuaW4oICdnbGlkZScgKSApLFxuICAgICAgICAgIHNsaWRpbmdGcmVxID0gZy5zbGlkZSggZnJlcXVlbmN5LCBnbGlkZSwgZ2xpZGUgKSxcbiAgICAgICAgICBhdHRhY2sgID0gZy5pbiggJ2F0dGFjaycgKSwgXG4gICAgICAgICAgZGVjYXkgICA9IGcuaW4oICdkZWNheScgKSxcbiAgICAgICAgICBzdXN0YWluID0gZy5pbiggJ3N1c3RhaW4nICksIFxuICAgICAgICAgIHN1c3RhaW5MZXZlbCA9IGcuaW4oICdzdXN0YWluTGV2ZWwnICksXG4gICAgICAgICAgcmVsZWFzZSA9IGcuaW4oICdyZWxlYXNlJyApLFxuICAgICAgICAgIHByZWdhaW4gPSBnLmluKCAncHJlZ2FpbicgKSxcbiAgICAgICAgICBwb3N0Z2Fpbj0gZy5pbiggJ3Bvc3RnYWluJyApLFxuICAgICAgICAgIGJpYXMgICAgPSBnLmluKCAnYmlhcycgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgQ29tcGxleC5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBzeW4uX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgb3NjID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoIHN5bi53YXZlZm9ybSwgc2xpZGluZ0ZyZXEsIHN5bi5hbnRpYWxpYXMgKVxuXG4gICAgICBjb25zdCBlbnYgPSBHaWJiZXJpc2guZW52ZWxvcGVzLmZhY3RvcnkoIFxuICAgICAgICBwcm9wcy51c2VBRFNSLCBcbiAgICAgICAgcHJvcHMuc2hhcGUsIFxuICAgICAgICBhdHRhY2ssIGRlY2F5LCBcbiAgICAgICAgc3VzdGFpbiwgc3VzdGFpbkxldmVsLCBcbiAgICAgICAgcmVsZWFzZSwgXG4gICAgICAgIHByb3BzLnRyaWdnZXJSZWxlYXNlXG4gICAgICApXG5cbiAgICAgIGNvbnN0IHNhdHVyYXRpb24gPSBnLmluKCdzYXR1cmF0aW9uJylcblxuICAgICAgLy8gYmVsb3cgZG9lc24ndCB3b3JrIGFzIGl0IGF0dGVtcHRzIHRvIGFzc2lnbiB0byByZWxlYXNlIHByb3BlcnR5IHRyaWdnZXJpbmcgY29kZWdlbi4uLlxuICAgICAgLy8gc3luLnJlbGVhc2UgPSAoKT0+IHsgc3luLmVudi5yZWxlYXNlKCkgfVxuXG4gICAgICB7XG4gICAgICAgICd1c2UganNkc3AnXG4gICAgICAgIGxldCBvc2NXaXRoRW52ID0gb3NjICogZW52ICogbG91ZG5lc3MgKiB0cmlnZ2VyTG91ZG5lc3MsXG4gICAgICAgICAgICBwYW5uZXJcblxuICAgICAgICBsZXQgZm9sZGVkT3NjID0gd2F2ZWZvbGQoIHdhdmVmb2xkKCB3YXZlZm9sZCggd2F2ZWZvbGQoIGJpYXMgKyBvc2NXaXRoRW52ICogKHByZWdhaW4gKiBlbnYpICogLjMzMyApICkgKSApXG4gICAgICAgIGZvbGRlZE9zYyA9IGcudGFuaCggZm9sZGVkT3NjICogLjYgKSAqIHBvc3RnYWluXG4gXG4gICAgICAgIC8vIDE2IGlzIGFuIHVuZm9ydHVuYXRlIGVtcGlyaWNhbGx5IGRlcml2ZWQgbWFnaWMgbnVtYmVyLi4uXG4gICAgICAgIGNvbnN0IGJhc2VDdXRvZmZGcmVxID0gZy5pbignY3V0b2ZmJykgKiAoIGZyZXF1ZW5jeSAvICAoIGcuZ2VuLnNhbXBsZXJhdGUgLyAxNiApICkgXG4gICAgICAgIGNvbnN0IGN1dG9mZiA9IGcubWluKCBiYXNlQ3V0b2ZmRnJlcSAqIGcucG93KCAyLCBnLmluKCdmaWx0ZXJNdWx0JykgKiBsb3VkbmVzcyAqIHRyaWdnZXJMb3VkbmVzcyApICogZW52LCAuOTk1ICkgXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkT3NjID0gR2liYmVyaXNoLmZpbHRlcnMuZmFjdG9yeSggZm9sZGVkT3NjLCBjdXRvZmYsIHNhdHVyYXRpb24sIHByb3BzIClcblxuICAgICAgICBsZXQgY29tcGxleFdpdGhHYWluID0gZmlsdGVyZWRPc2MgKiBnLmluKCAnZ2FpbicgKVxuICAgICAgICAvLyBYWFggdWdseSwgdWdseSBoYWNrXG4gICAgICAgIGlmKCAgcHJvcHMuZmlsdGVyTW9kZWwgIT09IDIgKSBjb21wbGV4V2l0aEdhaW4gPSBjb21wbGV4V2l0aEdhaW4gKiBzYXR1cmF0aW9uXG4gICAgXG4gICAgICAgIGlmKCBzeW4ucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgICBwYW5uZXIgPSBnLnBhbiggY29tcGxleFdpdGhHYWluLCBjb21wbGV4V2l0aEdhaW4sIGcuaW4oICdwYW4nICkgKSBcbiAgICAgICAgICBzeW4uZ3JhcGggPSBbIHBhbm5lci5sZWZ0LCBwYW5uZXIucmlnaHQgXVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzeW4uZ3JhcGggPSBjb21wbGV4V2l0aEdhaW5cbiAgICAgICAgfVxuXG4gICAgICAgIHN5bi5lbnYgPSBlbnZcbiAgICAgICAgc3luLm9zYyA9IG9zY1xuICAgICAgICBzeW4uZmlsdGVyID0gZmlsdGVyZWRPc2NcbiAgICAgIH1cblxuICAgIH1cbiAgICBcbiAgICBzeW4uX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICd3YXZlZm9ybScsICdhbnRpYWxpYXMnLCAnZmlsdGVyTW9kZWwnLCdmaWx0ZXJNb2RlJywgJ3VzZUFEU1InLCAnc2hhcGUnIF1cbiAgICBzeW4uX19jcmVhdGVHcmFwaCgpXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggc3luLCBzeW4uZ3JhcGgsIFsnaW5zdHJ1bWVudHMnLCAnY29tcGxleCddLCBwcm9wcyAgKVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIFxuICBDb21wbGV4LmRlZmF1bHRzID0ge1xuICAgIHdhdmVmb3JtOid0cmlhbmdsZScsXG4gICAgYXR0YWNrOiA0NCxcbiAgICBkZWNheTogMjIwNTAsXG4gICAgc3VzdGFpbjo0NDEwMCxcbiAgICBzdXN0YWluTGV2ZWw6LjYsXG4gICAgcmVsZWFzZToyMjA1MCxcbiAgICB1c2VBRFNSOmZhbHNlLFxuICAgIHNoYXBlOidleHBvbmVudGlhbCcsXG4gICAgdHJpZ2dlclJlbGVhc2U6ZmFsc2UsXG4gICAgZ2FpbjogLjUsXG4gICAgcHVsc2V3aWR0aDouMjUsXG4gICAgZnJlcXVlbmN5OjIyMCxcbiAgICBwYW46IC41LFxuICAgIGFudGlhbGlhczp0cnVlLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjEsXG4gICAgZ2xpZGU6MSxcbiAgICBzYXR1cmF0aW9uOjEsXG4gICAgZmlsdGVyTXVsdDoyLFxuICAgIFE6LjI1LFxuICAgIGN1dG9mZjouNSxcbiAgICAvL2ZpbHRlclR5cGU6MSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck1vZGU6MCxcbiAgICBpc1N0ZXJlbzpmYWxzZSxcbiAgICBwcmVnYWluOjQsXG4gICAgcG9zdGdhaW46MSxcbiAgICBiaWFzOjBcbiAgfVxuXG4gIC8vIGRvIG5vdCBpbmNsdWRlIHZlbG9jaXR5LCB3aGljaCBzaG91ZGwgYWx3YXlzIGJlIHBlciB2b2ljZVxuICBsZXQgUG9seUNvbXBsZXggPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBDb21wbGV4LCBbJ2ZyZXF1ZW5jeScsJ2F0dGFjaycsJ2RlY2F5JywncHVsc2V3aWR0aCcsJ3BhbicsJ2dhaW4nLCdnbGlkZScsICdzYXR1cmF0aW9uJywgJ2ZpbHRlck11bHQnLCAnUScsICdjdXRvZmYnLCAncmVzb25hbmNlJywgJ2FudGlhbGlhcycsICdmaWx0ZXJNb2RlbCcsICd3YXZlZm9ybScsICdmaWx0ZXJNb2RlJywgJ19fdHJpZ2dlckxvdWRuZXNzJywgJ2xvdWRuZXNzJywgJ3ByZWdhaW4nLCAncG9zdGdhaW4nLCAnYmlhcyddICkgXG4gIFBvbHlDb21wbGV4LmRlZmF1bHRzID0gQ29tcGxleC5kZWZhdWx0c1xuXG4gIHJldHVybiBbIENvbXBsZXgsIFBvbHlDb21wbGV4IF1cblxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBDb25nYSA9IGFyZ3VtZW50UHJvcHMgPT4ge1xuICAgIGNvbnN0IGNvbmdhID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApLFxuICAgICAgICAgIGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgZGVjYXkgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgZ2FpbiAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIENvbmdhLmRlZmF1bHRzLCBhcmd1bWVudFByb3BzIClcblxuICAgIGNvbnN0IHRyaWdnZXIgPSBnLmJhbmcoKSxcbiAgICAgICAgICBpbXB1bHNlID0gZy5tdWwoIHRyaWdnZXIsIDYwICksXG4gICAgICAgICAgX2RlY2F5ID0gIGcuc3ViKCAuMTAxLCBnLmRpdiggZGVjYXksIDEwICkgKSwgLy8gY3JlYXRlIHJhbmdlIG9mIC4wMDEgLSAuMDk5XG4gICAgICAgICAgYnBmID0gZy5zdmYoIGltcHVsc2UsIGZyZXF1ZW5jeSwgX2RlY2F5LCAyLCBmYWxzZSApLFxuICAgICAgICAgIG91dCA9IGcubXVsKCBicGYsIGcubXVsKCBnLm11bCggdHJpZ2dlckxvdWRuZXNzLGxvdWRuZXNzICksIGdhaW4gKSApXG4gICAgXG4gICAgY29uZ2EuaXNTdGVyZW8gPSBmYWxzZVxuICAgIGNvbmdhLmVudiA9IHRyaWdnZXJcbiAgICByZXR1cm4gR2liYmVyaXNoLmZhY3RvcnkoIGNvbmdhLCBvdXQsIFsnaW5zdHJ1bWVudHMnLCdjb25nYSddLCBwcm9wcyAgKVxuICB9XG4gIFxuICBDb25nYS5kZWZhdWx0cyA9IHtcbiAgICBnYWluOiAuMTI1LFxuICAgIGZyZXF1ZW5jeToxOTAsXG4gICAgZGVjYXk6IC44NSxcbiAgICBsb3VkbmVzczogMSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICBjb25zdCBQb2x5Q29uZ2EgPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBDb25nYSwgWydnYWluJywnZnJlcXVlbmN5JywnZGVjYXknLCdsb3VkbmVzcycsJ19fdHJpZ2dlckxvdWRuZXNzJyBdICkgXG4gIFBvbHlDb25nYS5kZWZhdWx0cyA9IENvbmdhLmRlZmF1bHRzXG5cbiAgcmV0dXJuIFsgQ29uZ2EsIFBvbHlDb25nYSBdXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IENvd2JlbGwgPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBsZXQgY293YmVsbCA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuICAgIFxuICAgIGNvbnN0IGRlY2F5ICAgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgZ2FpbiAgICA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgQ293YmVsbC5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBjb25zdCBicGZDdXRvZmYgPSBnLnBhcmFtKCAnYnBmYycsIDEwMDAgKSxcbiAgICAgICAgICBzMSA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCAnc3F1YXJlJywgNTYwICksXG4gICAgICAgICAgczIgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIDg0NSApLFxuICAgICAgICAgIGVnID0gZy5kZWNheSggZy5tdWwoIGRlY2F5LCBnLmdlbi5zYW1wbGVyYXRlICogMiApLCB7IGluaXRWYWx1ZTowIH0pLCBcbiAgICAgICAgICBicGYgPSBnLnN2ZiggZy5hZGQoIHMxLHMyICksIGJwZkN1dG9mZiwgMywgMiwgZmFsc2UgKSxcbiAgICAgICAgICBlbnZCcGYgPSBnLm11bCggYnBmLCBlZyApLFxuICAgICAgICAgIG91dCA9IGcubXVsKCBlbnZCcGYsIGcubXVsKCBnYWluLCBsb3VkbmVzcywgdHJpZ2dlckxvdWRuZXNzICkgKVxuXG4gICAgY293YmVsbC5lbnYgPSBlZyBcblxuICAgIGNvd2JlbGwuaXNTdGVyZW8gPSBmYWxzZVxuXG4gICAgY293YmVsbCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBjb3diZWxsLCBvdXQsIFsnaW5zdHJ1bWVudHMnLCAnY293YmVsbCddLCBwcm9wcyAgKVxuICAgIFxuICAgIHJldHVybiBjb3diZWxsXG4gIH1cbiAgXG4gIENvd2JlbGwuZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBkZWNheTouNSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcbiAgfVxuXG4gIHJldHVybiBDb3diZWxsXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxuY29uc3QgZ2VuaXNoID0gZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgRk0gPSBpbnB1dFByb3BzID0+IHtcbiAgICBsZXQgc3luID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApXG5cbiAgICBsZXQgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgZ2xpZGUgPSBnLm1heCggMSwgZy5pbiggJ2dsaWRlJyApICksXG4gICAgICAgIHNsaWRpbmdGcmVxID0gZy5zbGlkZSggZnJlcXVlbmN5LCBnbGlkZSwgZ2xpZGUgKSxcbiAgICAgICAgY21SYXRpbyA9IGcuaW4oICdjbVJhdGlvJyApLFxuICAgICAgICBpbmRleCA9IGcuaW4oICdpbmRleCcgKSxcbiAgICAgICAgZmVlZGJhY2sgPSBnLmluKCAnZmVlZGJhY2snICksXG4gICAgICAgIGF0dGFjayA9IGcuaW4oICdhdHRhY2snICksIGRlY2F5ID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICBzdXN0YWluID0gZy5pbiggJ3N1c3RhaW4nICksIHN1c3RhaW5MZXZlbCA9IGcuaW4oICdzdXN0YWluTGV2ZWwnICksXG4gICAgICAgIHJlbGVhc2UgPSBnLmluKCAncmVsZWFzZScgKSxcbiAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgc2F0dXJhdGlvbiA9IGcuaW4oICdzYXR1cmF0aW9uJyApXG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBGTS5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBzeW4uX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZW52ID0gR2liYmVyaXNoLmVudmVsb3Blcy5mYWN0b3J5KCBcbiAgICAgICAgcHJvcHMudXNlQURTUiwgXG4gICAgICAgIHByb3BzLnNoYXBlLCBcbiAgICAgICAgYXR0YWNrLCBkZWNheSwgXG4gICAgICAgIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgXG4gICAgICAgIHJlbGVhc2UsIFxuICAgICAgICBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgICAgKVxuXG4gICAgICBzeW4uYWR2YW5jZSA9ICgpPT4geyBlbnYucmVsZWFzZSgpIH1cblxuICAgICAgY29uc3QgZmVlZGJhY2tzc2QgPSBnLmhpc3RvcnkoIDAgKVxuXG4gICAgICBjb25zdCBtb2RPc2MgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggXG4gICAgICAgIHN5bi5tb2R1bGF0b3JXYXZlZm9ybSwgXG4gICAgICAgIGcuYWRkKCBnLm11bCggc2xpZGluZ0ZyZXEsIGNtUmF0aW8gKSwgZy5tdWwoIGZlZWRiYWNrc3NkLm91dCwgZmVlZGJhY2ssIGluZGV4ICkgKSwgXG4gICAgICAgIHN5bi5hbnRpYWxpYXMgXG4gICAgICApXG5cbiAgICAgIHtcbiAgICAgICAgJ3VzZSBqc2RzcCdcbiAgICAgICAgY29uc3QgTG91ZG5lc3MgPSBsb3VkbmVzcyAqIHRyaWdnZXJMb3VkbmVzc1xuICAgICAgICBjb25zdCBtb2RPc2NXaXRoSW5kZXggPSBtb2RPc2MgKiBzbGlkaW5nRnJlcSAqIGluZGV4ICogTG91ZG5lc3NcbiAgICAgICAgY29uc3QgbW9kT3NjV2l0aEVudiAgID0gbW9kT3NjV2l0aEluZGV4ICogZW52XG4gICAgICAgIFxuICAgICAgICBjb25zdCBtb2RPc2NXaXRoRW52QXZnID0gIC41ICogKCBtb2RPc2NXaXRoRW52ICsgZmVlZGJhY2tzc2Qub3V0IClcblxuICAgICAgICBmZWVkYmFja3NzZC5pbiggbW9kT3NjV2l0aEVudkF2ZyApXG5cbiAgICAgICAgY29uc3QgY2Fycmllck9zYyA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCBzeW4uY2FycmllcldhdmVmb3JtLCBnLmFkZCggc2xpZGluZ0ZyZXEsIG1vZE9zY1dpdGhFbnZBdmcgKSwgc3luLmFudGlhbGlhcyApXG5cbiAgICAgICAgLy8gWFhYIGhvcnJpYmxlIGhhY2sgYmVsb3cgdG8gXCJ1c2VcIiBzYXR1cmF0aW9uIGV2ZW4gd2hlbiBub3QgdXNpbmcgYSBkaW9kZSBmaWx0ZXIgXG4gICAgICAgIGNvbnN0IGNhcnJpZXJPc2NXaXRoRW52ID0gcHJvcHMuZmlsdGVyTW9kZWwgPT09IDIgPyBjYXJyaWVyT3NjICogZW52IDogZy5tdWwoY2Fycmllck9zYywgZy5tdWwoZW52LHNhdHVyYXRpb24pIClcblxuICAgICAgICBjb25zdCBiYXNlQ3V0b2ZmRnJlcSA9IGcuaW4oICdjdXRvZmYnICkgKiAoIGZyZXF1ZW5jeSAvICAoIGcuZ2VuLnNhbXBsZXJhdGUgLyAxNiApICkgXG4gICAgICAgIGNvbnN0IGN1dG9mZiA9IGcubWluKCBiYXNlQ3V0b2ZmRnJlcSAqIGcucG93KCAyLCBnLmluKCdmaWx0ZXJNdWx0JykgKiBMb3VkbmVzcyApICogZW52LCAuOTk1ICkgXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkT3NjID0gR2liYmVyaXNoLmZpbHRlcnMuZmFjdG9yeSggY2Fycmllck9zY1dpdGhFbnYsIGN1dG9mZiwgc2F0dXJhdGlvbiwgc3luIClcbiAgICAgICAgY29uc3Qgc3ludGhXaXRoR2FpbiA9IGZpbHRlcmVkT3NjICogZy5pbiggJ2dhaW4nICkgKiBMb3VkbmVzc1xuICAgICAgICBcbiAgICAgICAgbGV0IHBhbm5lclxuICAgICAgICBpZiggcHJvcHMucGFuVm9pY2VzID09PSB0cnVlICkgeyBcbiAgICAgICAgICBwYW5uZXIgPSBnLnBhbiggc3ludGhXaXRoR2Fpbiwgc3ludGhXaXRoR2FpbiwgZy5pbiggJ3BhbicgKSApIFxuICAgICAgICAgIHN5bi5ncmFwaCA9IFtwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgICAgICBzeW4uaXNTdGVyZW8gPSB0cnVlXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHN5bi5ncmFwaCA9IHN5bnRoV2l0aEdhaW5cbiAgICAgICAgICBzeW4uaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN5bi5lbnYgPSBlbnZcblxuICAgICAgcmV0dXJuIGVudlxuICAgIH1cbiAgICBcbiAgICBzeW4uX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICdjYXJyaWVyV2F2ZWZvcm0nLCAnbW9kdWxhdG9yV2F2ZWZvcm0nLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywgJ2ZpbHRlck1vZGUnIF1cbiAgICBjb25zdCBlbnYgPSBzeW4uX19jcmVhdGVHcmFwaCgpXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggc3luLCBzeW4uZ3JhcGggLCBbJ2luc3RydW1lbnRzJywnRk0nXSwgcHJvcHMgKVxuXG4gICAgb3V0LmVudi5hZHZhbmNlID0gb3V0LmFkdmFuY2UgXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgRk0uZGVmYXVsdHMgPSB7XG4gICAgY2FycmllcldhdmVmb3JtOidzaW5lJyxcbiAgICBtb2R1bGF0b3JXYXZlZm9ybTonc2luZScsXG4gICAgYXR0YWNrOiA0NCxcbiAgICBmZWVkYmFjazogMCxcbiAgICBkZWNheTogMjIwNTAsXG4gICAgc3VzdGFpbjo0NDEwMCxcbiAgICBzdXN0YWluTGV2ZWw6LjYsXG4gICAgcmVsZWFzZToyMjA1MCxcbiAgICB1c2VBRFNSOmZhbHNlLFxuICAgIHNoYXBlOidsaW5lYXInLFxuICAgIHRyaWdnZXJSZWxlYXNlOmZhbHNlLFxuICAgIGdhaW46IC4yNSxcbiAgICBjbVJhdGlvOjIsXG4gICAgaW5kZXg6NSxcbiAgICBwdWxzZXdpZHRoOi4yNSxcbiAgICBmcmVxdWVuY3k6MjIwLFxuICAgIHBhbjogLjUsXG4gICAgYW50aWFsaWFzOmZhbHNlLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBnbGlkZToxLFxuICAgIHNhdHVyYXRpb246MSxcbiAgICBmaWx0ZXJNdWx0OjEuNSxcbiAgICBROi4yNSxcbiAgICBjdXRvZmY6LjM1LFxuICAgIGZpbHRlck1vZGVsOjAsXG4gICAgZmlsdGVyTW9kZTowLFxuICAgIGxvdWRuZXNzOiAxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcblxuICB9XG5cbiAgY29uc3QgUG9seUZNID0gR2liYmVyaXNoLlBvbHlUZW1wbGF0ZSggRk0sIFsnZ2xpZGUnLCdmcmVxdWVuY3knLCdhdHRhY2snLCdkZWNheScsJ3B1bHNld2lkdGgnLCdwYW4nLCdnYWluJywnY21SYXRpbycsJ2luZGV4JywgJ3NhdHVyYXRpb24nLCAnZmlsdGVyTXVsdCcsICdRJywgJ2N1dG9mZicsICdhbnRpYWxpYXMnLCAnZmlsdGVyTW9kZWwnLCAnY2FycmllcldhdmVmb3JtJywgJ21vZHVsYXRvcldhdmVmb3JtJywnZmlsdGVyTW9kZScsICdmZWVkYmFjaycsICd1c2VBRFNSJywgJ3N1c3RhaW4nLCAncmVsZWFzZScsICdzdXN0YWluTGV2ZWwnLCAnX190cmlnZ2VyTG91ZG5lc3MnLCdsb3VkbmVzcycgXSApIFxuICBQb2x5Rk0uZGVmYXVsdHMgPSBGTS5kZWZhdWx0c1xuXG4gIHJldHVybiBbIEZNLCBQb2x5Rk0gXVxuXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGxldCBIYXQgPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBsZXQgaGF0ID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApLFxuICAgICAgICB0dW5lICA9IGcuaW4oICd0dW5lJyApLFxuICAgICAgICBzY2FsZWRUdW5lID0gZy5tZW1vKCBnLmFkZCggLjQsIHR1bmUgKSApLFxuICAgICAgICBkZWNheSAgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgIGdhaW4gID0gZy5pbiggJ2dhaW4nICksXG4gICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnIClcblxuICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBIYXQuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgbGV0IGJhc2VGcmVxID0gZy5tdWwoIDMyNSwgc2NhbGVkVHVuZSApLCAvLyByYW5nZSBvZiAxNjIuNSAtIDQ4Ny41XG4gICAgICAgIGJwZkN1dG9mZiA9IGcubXVsKCBnLnBhcmFtKCAnYnBmYycsIDcwMDAgKSwgc2NhbGVkVHVuZSApLFxuICAgICAgICBocGZDdXRvZmYgPSBnLm11bCggZy5wYXJhbSggJ2hwZmMnLCAxMTAwMCApLCBzY2FsZWRUdW5lICksICBcbiAgICAgICAgczEgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIGJhc2VGcmVxLCBmYWxzZSApLFxuICAgICAgICBzMiA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCAnc3F1YXJlJywgZy5tdWwoIGJhc2VGcmVxLDEuNDQ3MSApICksXG4gICAgICAgIHMzID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCBnLm11bCggYmFzZUZyZXEsMS42MTcwICkgKSxcbiAgICAgICAgczQgPSBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIGcubXVsKCBiYXNlRnJlcSwxLjkyNjUgKSApLFxuICAgICAgICBzNSA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCAnc3F1YXJlJywgZy5tdWwoIGJhc2VGcmVxLDIuNTAyOCApICksXG4gICAgICAgIHM2ID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoICdzcXVhcmUnLCBnLm11bCggYmFzZUZyZXEsMi42NjM3ICkgKSxcbiAgICAgICAgc3VtID0gZy5hZGQoIHMxLHMyLHMzLHM0LHM1LHM2ICksXG4gICAgICAgIGVnID0gZy5kZWNheSggZy5tdWwoIGRlY2F5LCBnLmdlbi5zYW1wbGVyYXRlICogMiApLCB7IGluaXRWYWx1ZTowIH0pLCBcbiAgICAgICAgYnBmID0gZy5zdmYoIHN1bSwgYnBmQ3V0b2ZmLCAuNSwgMiwgZmFsc2UgKSxcbiAgICAgICAgZW52QnBmID0gZy5tdWwoIGJwZiwgZWcgKSxcbiAgICAgICAgaHBmID0gZy5maWx0ZXIyNCggZW52QnBmLCAwLCBocGZDdXRvZmYsIDAgKSxcbiAgICAgICAgb3V0ID0gZy5tdWwoIGhwZiwgZy5tdWwoIGdhaW4sIGcubXVsKCBsb3VkbmVzcywgdHJpZ2dlckxvdWRuZXNzICkgKSApXG5cbiAgICBoYXQuZW52ID0gZWcgXG4gICAgaGF0LmlzU3RlcmVvID0gZmFsc2VcblxuICAgIGNvbnN0IF9faGF0ID0gR2liYmVyaXNoLmZhY3RvcnkoIGhhdCwgb3V0LCBbJ2luc3RydW1lbnRzJywnaGF0J10sIHByb3BzICApXG4gICAgXG5cbiAgICByZXR1cm4gX19oYXRcbiAgfVxuICBcbiAgSGF0LmRlZmF1bHRzID0ge1xuICAgIGdhaW46ICAuNSxcbiAgICB0dW5lOiAuNixcbiAgICBkZWNheTouMSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjFcbiAgfVxuXG4gIHJldHVybiBIYXRcblxufVxuIiwiY29uc3QgdWdlbiA9IHJlcXVpcmUoJy4uL3VnZW4uanMnKSgpO1xuXG5jb25zdCBpbnN0cnVtZW50ID0gT2JqZWN0LmNyZWF0ZSh1Z2VuKTtcblxuT2JqZWN0LmFzc2lnbihpbnN0cnVtZW50LCB7XG4gIHR5cGU6ICdpbnN0cnVtZW50JyxcblxuICBub3RlKGZyZXEsIGxvdWRuZXNzID0gbnVsbCkge1xuICAgIC8vIGlmIGJpbm9wIGlzIHNob3VsZCBiZSB1c2VkLi4uXG4gICAgaWYgKGlzTmFOKHRoaXMuZnJlcXVlbmN5KSkge1xuICAgICAgLy8gYW5kIGlmIHdlIGFyZSBhc3NpZ25pbmcgYmlub3AgZm9yIHRoZSBmaXJzdCB0aW1lLi4uXG4gICAgICBsZXQgb2JqID0gR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQodGhpcy5mcmVxdWVuY3kuaWQpO1xuICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBJbmNvcnJlY3Qgbm90ZSAke3RoaXMuZnJlcXVlbmN5fSBhc3NpZ25lZCB0byAke3RoaXMudWdlbk5hbWV9OyB0aGlzIHZhbHVlIHdpbGwgYmUgaWdub3JlZC5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5pc29wICE9PSB0cnVlKSB7XG4gICAgICAgIG9iai5pbnB1dHNbMF0gPSBmcmVxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLmlucHV0c1sxXSA9IGZyZXE7XG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlcXVlbmN5ID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyZXF1ZW5jeSA9IGZyZXE7XG4gICAgfVxuXG4gICAgaWYgKGxvdWRuZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzID0gbG91ZG5lc3M7XG4gICAgfVxuXG4gICAgdGhpcy5lbnYudHJpZ2dlcigpO1xuICB9LFxuXG4gIHRyaWdnZXIobG91ZG5lc3MgPSAxKSB7XG4gICAgaWYgKGlzTmFOKGxvdWRuZXNzKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEEgbm9uLW51bWJlciB3YXMgcGFzc2VkIHRvIHRyaWdnZXIoKSBvbiAke3RoaXMudWdlbk5hbWV9OyB0aGlzIHZhbHVlIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIGVudmVsb3BlIHdpbGwgbm90IGJlIHRyaWdnZXJlZC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3RyaWdnZXJMb3VkbmVzcyA9IGxvdWRuZXNzO1xuICAgICAgdGhpcy5lbnYudHJpZ2dlcigpO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0cnVtZW50XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbmNvbnN0IGluc3RydW1lbnRzID0ge1xuICBLaWNrICAgICAgICA6IHJlcXVpcmUoICcuL2tpY2suanMnICkoIEdpYmJlcmlzaCApLFxuICBDbGF2ZSAgICAgICA6IHJlcXVpcmUoICcuL2NvbmdhLmpzJyApKCBHaWJiZXJpc2ggKVswXSwgLy8gY2xhdmUgaXMgc2FtZSBhcyBjb25nYSB3aXRoIGRpZmZlcmVudCBkZWZhdWx0cywgc2VlIGJlbG93XG4gIEhhdCAgICAgICAgIDogcmVxdWlyZSggJy4vaGF0LmpzJyApKCBHaWJiZXJpc2ggKSxcbiAgU25hcmUgICAgICAgOiByZXF1aXJlKCAnLi9zbmFyZS5qcycgKSggR2liYmVyaXNoICksXG4gIENvd2JlbGwgICAgIDogcmVxdWlyZSggJy4vY293YmVsbC5qcycgKSggR2liYmVyaXNoICksXG4gIFRvbSAgICAgICAgIDogcmVxdWlyZSggJy4vdG9tLmpzJyApKCBHaWJiZXJpc2ggKSxcbiAgQ2xhcCAgICAgICAgOiByZXF1aXJlKCAnLi9jbGFwLmRzcC5qcycgKSggR2liYmVyaXNoICksXG4gIE11bHRpc2FtcGxlcjogcmVxdWlyZSggJy4vbXVsdGlzYW1wbGVyLmRzcC5qcycgKSggR2liYmVyaXNoICksXG4gIFNvdW5kZm9udCAgIDogcmVxdWlyZSggJy4vc291bmRmb250LmpzJyApKCBHaWJiZXJpc2ggKVxufVxuXG5pbnN0cnVtZW50cy5DbGF2ZS5kZWZhdWx0cy5mcmVxdWVuY3kgPSAyNTAwXG5pbnN0cnVtZW50cy5DbGF2ZS5kZWZhdWx0cy5kZWNheSA9IC41O1xuXG5bIGluc3RydW1lbnRzLlN5bnRoLCBpbnN0cnVtZW50cy5Qb2x5U3ludGggXSAgICAgPSByZXF1aXJlKCAnLi9zeW50aC5kc3AuanMnICkoIEdpYmJlcmlzaCApO1xuWyBpbnN0cnVtZW50cy5Db21wbGV4LCBpbnN0cnVtZW50cy5Qb2x5Q29tcGxleF0gID0gcmVxdWlyZSggJy4vY29tcGxleC5kc3AuanMnICkoIEdpYmJlcmlzaCApO1xuWyBpbnN0cnVtZW50cy5Nb25vc3ludGgsIGluc3RydW1lbnRzLlBvbHlNb25vIF0gID0gcmVxdWlyZSggJy4vbW9ub3N5bnRoLmRzcC5qcycgKSggR2liYmVyaXNoICk7XG5bIGluc3RydW1lbnRzLkZNLCBpbnN0cnVtZW50cy5Qb2x5Rk0gXSAgICAgICAgICAgPSByZXF1aXJlKCAnLi9mbS5kc3AuanMnICkoIEdpYmJlcmlzaCApO1xuWyBpbnN0cnVtZW50cy5TYW1wbGVyLCBpbnN0cnVtZW50cy5Qb2x5U2FtcGxlciBdID0gcmVxdWlyZSggJy4vc2FtcGxlci5qcycgKSggR2liYmVyaXNoICk7XG5bIGluc3RydW1lbnRzLkthcnBsdXMsIGluc3RydW1lbnRzLlBvbHlLYXJwbHVzIF0gPSByZXF1aXJlKCAnLi9rYXJwbHVzc3Ryb25nLmpzJyApKCBHaWJiZXJpc2ggKTtcblsgaW5zdHJ1bWVudHMuQ29uZ2EsIGluc3RydW1lbnRzLlBvbHlDb25nYSBdICAgICA9IHJlcXVpcmUoICcuL2NvbmdhLmpzJyApKCBHaWJiZXJpc2ggKVxuXG5pbnN0cnVtZW50cy5leHBvcnQgPSB0YXJnZXQgPT4ge1xuICBmb3IoIGxldCBrZXkgaW4gaW5zdHJ1bWVudHMgKSB7XG4gICAgaWYoIGtleSAhPT0gJ2V4cG9ydCcgKSB7XG4gICAgICB0YXJnZXRbIGtleSBdID0gaW5zdHJ1bWVudHNbIGtleSBdXG4gICAgfVxuICB9XG59XG5cbnJldHVybiBpbnN0cnVtZW50c1xuXG59XG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIGluc3RydW1lbnQgPSByZXF1aXJlKCAnLi9pbnN0cnVtZW50LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBLYXJwbHVzID0gaW5wdXRQcm9wcyA9PiB7XG5cbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBLYXJwbHVzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBsZXQgc3luID0gT2JqZWN0LmNyZWF0ZSggaW5zdHJ1bWVudCApXG4gICAgXG4gICAgbGV0IHNhbXBsZVJhdGUgPSBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgXG5cbiAgICBjb25zdCB0cmlnZ2VyID0gZy5iYW5nKCksXG4gICAgICAgICAgLy8gaGlnaCBpbml0aWFsVmFsdWUgc3RvcHMgdHJpZ2dlcmluZyBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgIHBoYXNlID0gZy5hY2N1bSggMSwgdHJpZ2dlciwgeyBzaG91bGRXcmFwTWF4OmZhbHNlLCBpbml0aWFsVmFsdWU6MTAwMDAwMCB9ICksXG4gICAgICAgICAgZW52ID0gZy5ndHAoIGcuc3ViKCAxLCBnLmRpdiggcGhhc2UsIDIwMCApICksIDAgKSxcbiAgICAgICAgICBpbXB1bHNlID0gZy5tdWwoIGcubm9pc2UoKSwgZW52ICksXG4gICAgICAgICAgZmVlZGJhY2sgPSBnLmhpc3RvcnkoKSxcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCdmcmVxdWVuY3knKSxcbiAgICAgICAgICBnbGlkZSA9IGcubWF4KCAxLCBnLmluKCAnZ2xpZGUnICkgKSxcbiAgICAgICAgICBzbGlkaW5nRnJlcXVlbmN5ID0gZy5zbGlkZSggZnJlcXVlbmN5LCBnbGlkZSwgZ2xpZGUgKSxcbiAgICAgICAgICBkZWxheSA9IGcuZGVsYXkoIGcuYWRkKCBpbXB1bHNlLCBmZWVkYmFjay5vdXQgKSwgZy5kaXYoIHNhbXBsZVJhdGUsIHNsaWRpbmdGcmVxdWVuY3kgKSksXG4gICAgICAgICAgZGVjYXllZCA9IGcubXVsKCBkZWxheSwgZy50NjAoIGcubXVsKCBnLmluKCdkZWNheScpLCBzbGlkaW5nRnJlcXVlbmN5ICkgKSApLFxuICAgICAgICAgIGRhbXBlZCA9ICBnLm1peCggZGVjYXllZCwgZmVlZGJhY2sub3V0LCBnLmluKCdkYW1waW5nJykgKSxcbiAgICAgICAgICBuID0gZy5ub2lzZSgpLFxuICAgICAgICAgIGJsZW5kVmFsdWUgPSBnLnN3aXRjaCggZy5ndCggbiwgZy5pbignYmxlbmQnKSApLCAtMSwgMSApLCBcbiAgICAgICAgICB3aXRoR2FpbiA9IGcubXVsKCBnLm11bCggYmxlbmRWYWx1ZSwgZGFtcGVkICksIGcubXVsKCBnLm11bCggZy5pbignbG91ZG5lc3MnKSwgZy5pbignX190cmlnZ2VyTG91ZG5lc3MnKSApLCBnIC5pbignZ2FpbicpICkgKVxuXG4gICAgZmVlZGJhY2suaW4oIGRhbXBlZCApXG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbigge30sIEthcnBsdXMuZGVmYXVsdHMsIHByb3BzIClcblxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwge1xuICAgICAgcHJvcGVydGllcyA6IHByb3BzLFxuXG4gICAgICBlbnYgOiB0cmlnZ2VyLFxuICAgICAgcGhhc2UsXG5cbiAgICAgIGdldFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gR2liYmVyaXNoLm1lbW9yeS5oZWFwWyBwaGFzZS5tZW1vcnkudmFsdWUuaWR4IF1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGlmKCBwcm9wZXJ0aWVzLnBhblZvaWNlcyApIHsgIFxuICAgICAgY29uc3QgcGFubmVyID0gZy5wYW4oIHdpdGhHYWluLCB3aXRoR2FpbiwgZy5pbiggJ3BhbicgKSApXG4gICAgICBzeW4gPSBHaWJiZXJpc2guZmFjdG9yeSggc3luLCBbcGFubmVyLmxlZnQsIHBhbm5lci5yaWdodF0sIFsnaW5zdHJ1bWVudHMnLCdrYXJwbHVzJ10sIHByb3BzICApXG4gICAgICBzeW4uaXNTdGVyZW8gPSB0cnVlXG4gICAgfWVsc2V7XG4gICAgICBzeW4gPSBHaWJiZXJpc2guZmFjdG9yeSggc3luLCB3aXRoR2FpbiwgWydpbnN0cnVtZW50cycsJ2thcnBsdXMnXSwgcHJvcHMgKVxuICAgICAgc3luLmlzU3RlcmVvID0gZmFsc2UgXG4gICAgfVxuXG4gICAgcmV0dXJuIHN5blxuICB9XG4gIFxuICBLYXJwbHVzLmRlZmF1bHRzID0ge1xuICAgIGRlY2F5OiAuOTcsXG4gICAgZGFtcGluZzouMixcbiAgICBnYWluOiAuMTUsXG4gICAgZnJlcXVlbmN5OjIyMCxcbiAgICBwYW46IC41LFxuICAgIGdsaWRlOjEsXG4gICAgcGFuVm9pY2VzOmZhbHNlLFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MSxcbiAgICBibGVuZDoxXG4gIH1cblxuICBsZXQgZW52Q2hlY2tGYWN0b3J5ID0gKCBzeW4sc3ludGggKSA9PiB7XG4gICAgbGV0IGVudkNoZWNrID0gKCk9PiB7XG4gICAgICBsZXQgcGhhc2UgPSBzeW4uZ2V0UGhhc2UoKSxcbiAgICAgICAgICBlbmRUaW1lID0gc3ludGguZGVjYXkgKiBzYW1wbGVSYXRlXG5cbiAgICAgIGlmKCBwaGFzZSA+IGVuZFRpbWUgKSB7XG4gICAgICAgIHN5bnRoLmRpc2Nvbm5lY3RVZ2VuKCBzeW4gKVxuICAgICAgICBzeW4uaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIHN5bi5waGFzZS5tZW1vcnkudmFsdWUuaWR4IF0gPSAwIC8vIHRyaWdnZXIgZG9lc24ndCBzZWVtIHRvIHJlc2V0IGZvciBzb21lIHJlYXNvblxuICAgICAgfWVsc2V7XG4gICAgICAgIEdpYmJlcmlzaC5ibG9ja0NhbGxiYWNrcy5wdXNoKCBlbnZDaGVjayApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZDaGVja1xuICB9XG5cbiAgY29uc3QgUG9seUthcnBsdXMgPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBLYXJwbHVzLCBbJ2ZyZXF1ZW5jeScsJ2RlY2F5JywnZGFtcGluZycsJ3BhbicsJ2dhaW4nLCAnZ2xpZGUnLCdsb3VkbmVzcycsICdfX3RyaWdnZXJMb3VkbmVzcyddLCBlbnZDaGVja0ZhY3RvcnkgKSBcbiAgUG9seUthcnBsdXMuZGVmYXVsdHMgPSBLYXJwbHVzLmRlZmF1bHRzXG5cbiAgcmV0dXJuIFsgS2FycGx1cywgUG9seUthcnBsdXMgXVxuXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IEtpY2sgPSBpbnB1dFByb3BzID0+IHtcbiAgICAvLyBlc3RhYmxpc2ggcHJvdG90eXBlIGNoYWluXG4gICAgY29uc3Qga2ljayA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuXG4gICAgLy8gZGVmaW5lIGlucHV0c1xuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGcuaW4oICdmcmVxdWVuY3knICksXG4gICAgICAgICAgZGVjYXkgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgdG9uZSAgPSBnLmluKCAndG9uZScgKSxcbiAgICAgICAgICBnYWluICA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICBMb3VkbmVzcyA9IGcubXVsKCBsb3VkbmVzcywgdHJpZ2dlckxvdWRuZXNzIClcbiAgICBcbiAgICAvLyBjcmVhdGUgaW5pdGlhbCBwcm9wZXJ0eSBzZXRcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBLaWNrLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICBPYmplY3QuYXNzaWduKCBraWNrLCBwcm9wcyApXG5cbiAgICAvLyBjcmVhdGUgRFNQIGdyYXBoXG4gICAgY29uc3QgdHJpZ2dlciA9IGcuYmFuZygpLFxuICAgICAgICAgIGltcHVsc2UgPSBnLm11bCggdHJpZ2dlciwgNjAgKSxcbiAgICAgICAgICBzY2FsZWREZWNheSA9IGcuc3ViKCAxLjAwNSwgZGVjYXkgKSwgLy8gLT4gcmFuZ2UgeyAuMDA1LCAxLjAwNSB9XG4gICAgICAgICAgc2NhbGVkVG9uZSA9IGcuYWRkKCA1MCwgZy5tdWwoIHRvbmUsIGcubXVsKDQwMDAsIExvdWRuZXNzICkgKSApLCAvLyAtPiByYW5nZSB7IDUwLCA0MDUwIH1cbiAgICAgICAgICBicGYgPSBnLnN2ZiggaW1wdWxzZSwgZnJlcXVlbmN5LCBzY2FsZWREZWNheSwgMiwgZmFsc2UgKSxcbiAgICAgICAgICBscGYgPSBnLnN2ZiggYnBmLCBzY2FsZWRUb25lLCAuNSwgMCwgZmFsc2UgKSxcbiAgICAgICAgICBncmFwaCA9IGcubXVsKCBscGYsIGcubXVsKCBnYWluLCBMb3VkbmVzcyApIClcbiAgICBcbiAgICBraWNrLmVudiA9IHRyaWdnZXJcbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSgga2ljaywgZ3JhcGgsIFsnaW5zdHJ1bWVudHMnLCdraWNrJ10sIHByb3BzICApXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgXG4gIEtpY2suZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBmcmVxdWVuY3k6ODUsXG4gICAgdG9uZTogLjI1LFxuICAgIGRlY2F5Oi45LFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgcmV0dXJuIEtpY2tcblxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKSxcbiAgICAgIGZlZWRiYWNrT3NjID0gcmVxdWlyZSggJy4uL29zY2lsbGF0b3JzL2ZtZmVlZGJhY2tvc2MuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IE1vbm8gPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBjb25zdCBzeW4gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50ICksXG4gICAgICAgICAgb3NjcyA9IFtdLCBcbiAgICAgICAgICBmcmVxdWVuY3kgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGdsaWRlID0gZy5tYXgoIDEsIGcuaW4oICdnbGlkZScgKSApLFxuICAgICAgICAgIHNsaWRpbmdGcmVxID0gZy5tZW1vKCBnLnNsaWRlKCBmcmVxdWVuY3ksIGdsaWRlLCBnbGlkZSApICksXG4gICAgICAgICAgYXR0YWNrID0gZy5pbiggJ2F0dGFjaycgKSwgZGVjYXkgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgc3VzdGFpbiA9IGcuaW4oICdzdXN0YWluJyApLCBzdXN0YWluTGV2ZWwgPSBnLmluKCAnc3VzdGFpbkxldmVsJyApLFxuICAgICAgICAgIHJlbGVhc2UgPSBnLmluKCAncmVsZWFzZScgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnICksXG4gICAgICAgICAgTG91ZG5lc3MgPSBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApLFxuICAgICAgICAgIHNhdHVyYXRpb24gPSBnLmluKCAnc2F0dXJhdGlvbicgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgTW9uby5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBzeW4uX19jcmVhdGVHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZW52ID0gR2liYmVyaXNoLmVudmVsb3Blcy5mYWN0b3J5KCBcbiAgICAgICAgcHJvcHMudXNlQURTUiwgXG4gICAgICAgIHByb3BzLnNoYXBlLCBcbiAgICAgICAgYXR0YWNrLCBkZWNheSwgXG4gICAgICAgIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgXG4gICAgICAgIHJlbGVhc2UsIFxuICAgICAgICBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgICAgKVxuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IDM7IGkrKyApIHtcbiAgICAgICAgbGV0IG9zYywgZnJlcVxuXG4gICAgICAgIHN3aXRjaCggaSApIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBmcmVxID0gZy5hZGQoIHNsaWRpbmdGcmVxLCBnLm11bCggc2xpZGluZ0ZyZXEsIGcuaW4oJ2RldHVuZTInKSApIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGZyZXEgPSBnLmFkZCggc2xpZGluZ0ZyZXEsIGcubXVsKCBzbGlkaW5nRnJlcSwgZy5pbignZGV0dW5lMycpICkgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGZyZXEgPSBzbGlkaW5nRnJlcVxuICAgICAgICB9XG5cbiAgICAgICAgb3NjID0gR2liYmVyaXNoLm9zY2lsbGF0b3JzLmZhY3RvcnkoIHN5bi53YXZlZm9ybSwgZnJlcSwgc3luLmFudGlhbGlhcyApXG4gICAgICAgIFxuICAgICAgICBvc2NzWyBpIF0gPSBvc2NcbiAgICAgIH1cblxuXG4gICAgICAvL2NvbnN0IGJhc2VDdXRvZmZGcmVxID0gZy5pbignY3V0b2ZmJykgKiAoZnJlcXVlbmN5IC8gIChnLmdlbi5zYW1wbGVyYXRlIC8gMTYgKSlcbiAgICAgIC8vY29uc3QgY3V0b2ZmID0gYmFzZUN1dG9mZkZyZXEgKiBnLnBvdyggMiwgZy5pbignZmlsdGVyTXVsdCcpICogbG91ZG5lc3MgKSAqIGVudiBcbiAgICAgIGNvbnN0IG9zY1N1bSA9IGcuYWRkKCAuLi5vc2NzICksXG4gICAgICAgICAgICAvLyBYWFggaG9ycmlibGUgaGFjayBiZWxvdyB0byBcInVzZVwiIHNhdHVyYXRpb24gZXZlbiB3aGVuIG5vdCB1c2luZyBhIGRpb2RlIGZpbHRlciBcbiAgICAgICAgICAgIG9zY1dpdGhFbnYgPSBwcm9wcy5maWx0ZXJNb2RlbD09PSAyID8gZy5tdWwoIG9zY1N1bSwgZW52ICkgOiBnLnN1YiggZy5hZGQoIGcubXVsKCBvc2NTdW0sIGVudiksIHNhdHVyYXRpb24gKSwgc2F0dXJhdGlvbiApLFxuICAgICAgICAgICAgYmFzZUN1dG9mZkZyZXEgPSBnLm11bCggZy5pbignY3V0b2ZmJyksIGcuZGl2KCBmcmVxdWVuY3ksIGcuZ2VuLnNhbXBsZXJhdGUgLyAxNiApICksXG4gICAgICAgICAgICBjdXRvZmYgPSBnLm11bCggZy5tdWwoIGJhc2VDdXRvZmZGcmVxLCBnLnBvdyggMiwgZy5tdWwoIGcuaW4oJ2ZpbHRlck11bHQnKSwgTG91ZG5lc3MgKSApKSwgZW52ICksXG4gICAgICAgICAgICBmaWx0ZXJlZE9zYyA9IEdpYmJlcmlzaC5maWx0ZXJzLmZhY3RvcnkoIG9zY1dpdGhFbnYsIGN1dG9mZiwgZy5pbignc2F0dXJhdGlvbicpLCBzeW4gKVxuICAgICAgICBcbiAgICAgIGlmKCBwcm9wcy5wYW5Wb2ljZXMgKSB7ICBcbiAgICAgICAgY29uc3QgcGFubmVyID0gZy5wYW4oIGZpbHRlcmVkT3NjLGZpbHRlcmVkT3NjLCBnLmluKCAncGFuJyApIClcbiAgICAgICAgc3luLmdyYXBoID0gWyBnLm11bCggcGFubmVyLmxlZnQsIGcuaW4oJ2dhaW4nKSwgTG91ZG5lc3MgKSwgZy5tdWwoIHBhbm5lci5yaWdodCwgZy5pbignZ2FpbicpLCBMb3VkbmVzcyApIF1cbiAgICAgICAgc3luLmlzU3RlcmVvID0gdHJ1ZVxuICAgICAgfWVsc2V7XG4gICAgICAgIHN5bi5ncmFwaCA9IGcubXVsKCBmaWx0ZXJlZE9zYywgZy5pbignZ2FpbicpLCBMb3VkbmVzcyApXG4gICAgICAgIHN5bi5pc1N0ZXJlbyA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHN5bi5lbnYgPSBlbnZcbiAgICB9XG5cbiAgICBzeW4uX19yZXF1aXJlc1JlY29tcGlsYXRpb24gPSBbICd3YXZlZm9ybScsICdhbnRpYWxpYXMnLCAnZmlsdGVyTW9kZWwnLCAnZmlsdGVyTW9kZScgXVxuICAgIHN5bi5fX2NyZWF0ZUdyYXBoKClcblxuICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBzeW4sIHN5bi5ncmFwaCwgWydpbnN0cnVtZW50cycsJ01vbm9zeW50aCddLCBwcm9wcyApXG5cbiAgICByZXR1cm4gb3V0XG4gIH0gXG4gIFxuICBNb25vLmRlZmF1bHRzID0ge1xuICAgIHdhdmVmb3JtOiAnc2F3JyxcbiAgICBhdHRhY2s6IDQ0LFxuICAgIGRlY2F5OiAyMjA1MCxcbiAgICBzdXN0YWluOjQ0MTAwLFxuICAgIHN1c3RhaW5MZXZlbDouNixcbiAgICByZWxlYXNlOjIyMDUwLFxuICAgIHVzZUFEU1I6ZmFsc2UsXG4gICAgc2hhcGU6J2xpbmVhcicsXG4gICAgdHJpZ2dlclJlbGVhc2U6ZmFsc2UsXG4gICAgZ2FpbjogLjI1LFxuICAgIHB1bHNld2lkdGg6LjI1LFxuICAgIGZyZXF1ZW5jeToyMjAsXG4gICAgcGFuOiAuNSxcbiAgICBkZXR1bmUyOi4wMDUsXG4gICAgZGV0dW5lMzotLjAwNSxcbiAgICBjdXRvZmY6IC41LFxuICAgIFE6IC4yNSxcbiAgICBwYW5Wb2ljZXM6ZmFsc2UsXG4gICAgZ2xpZGU6IDEsXG4gICAgYW50aWFsaWFzOmZhbHNlLFxuICAgIC8vZmlsdGVyVHlwZTogMSxcbiAgICBmaWx0ZXJNb2RlbDogMSxcbiAgICBmaWx0ZXJNb2RlOiAwLCAvLyAwID0gTFAsIDEgPSBIUCwgMiA9IEJQLCAzID0gTm90Y2hcbiAgICBzYXR1cmF0aW9uOi41LFxuICAgIGZpbHRlck11bHQ6IDIsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICBsZXQgUG9seU1vbm8gPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBNb25vLCBcbiAgICBbICdmcmVxdWVuY3knLCdhdHRhY2snLCdkZWNheScsJ2N1dG9mZicsJ1EnLFxuICAgICAgJ2RldHVuZTInLCdkZXR1bmUzJywncHVsc2V3aWR0aCcsJ3BhbicsJ2dhaW4nLCBcbiAgICAgICdnbGlkZScsICdzYXR1cmF0aW9uJywgJ2ZpbHRlck11bHQnLCAgJ2FudGlhbGlhcycsIFxuICAgICAgJ2ZpbHRlck1vZGVsJywgJ3dhdmVmb3JtJywgJ2ZpbHRlck1vZGUnLCAnbG91ZG5lc3MnLCAnX190cmlnZ2VyTG91ZG5lc3MnIF1cbiAgKSBcbiAgUG9seU1vbm8uZGVmYXVsdHMgPSBNb25vLmRlZmF1bHRzXG5cbiAgcmV0dXJuIFsgTW9ubywgUG9seU1vbm8gXVxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcbiAgY29uc3QgbWVtbyA9IHt9XG4gIFxuICBPYmplY3QuYXNzaWduKCBwcm90bywge1xuICAgIHBpY2tGaWxlKCBzYW1wbGUgKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTYW1wbGUgPSBzYW1wbGVcbiAgICB9LFxuICAgIHBpY2soIF9faWR4ICkge1xuICAgICAgY29uc3QgaWR4ID0gTWF0aC5mbG9vciggX19pZHggKVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLnNhbXBsZXJzIClcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbIGlkeCBdXG4gICAgICB0aGlzLmN1cnJlbnRTYW1wbGUgPSBrZXlcbiAgICB9LFxuICAgIHBpY2twbGF5KCBfX2lkeCApIHtcbiAgICAgIGNvbnN0IGlkeCA9IE1hdGguZmxvb3IoIF9faWR4IClcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggdGhpcy5zYW1wbGVycyApXG4gICAgICBjb25zdCBrZXkgPSBrZXlzWyBpZHggXVxuICAgICAgdGhpcy5jdXJyZW50U2FtcGxlID0ga2V5XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKClcbiAgICB9LFxuICAgIG5vdGUoIHJhdGUgKSB7XG4gICAgICAvL3RoaXMucmF0ZSA9IHJhdGVcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoIG51bGwsIHJhdGUgKVxuICAgIH0sXG4gICAgc2V0cGFuKCBudW09MCwgdmFsdWU9LjUgKSB7XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBjb25zdCB2b2ljZSA9IHRoaXMudm9pY2VzWyBudW0gXVxuICAgICAgICAvLyBzZXQgdm9pY2UgYnVmZmVyIGxlbmd0aFxuICAgICAgICAvL2cuZ2VuLm1lbW9yeS5oZWFwLnNldCggWyB2YWx1ZSBdLCB2b2ljZS5wYW4ubWVtb3J5LnZhbHVlcy5pZHggKVxuICAgICAgICB2b2ljZS5wYW4gPSB2YWx1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0cmF0ZSggbnVtPTAsIHZhbHVlPTEgKSB7XG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBjb25zdCB2b2ljZSA9IHRoaXMudm9pY2VzWyBudW0gXVxuICAgICAgICAvLyBzZXQgdm9pY2UgYnVmZmVyIGxlbmd0aFxuICAgICAgICAvL2cuZ2VuLm1lbW9yeS5oZWFwLnNldCggWyB2YWx1ZSBdLCB2b2ljZS5yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IClcbiAgICAgICAgdm9pY2UucmF0ZSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSxcbiAgICB0cmlnZ2VyKCB2b2x1bWU9bnVsbCwgcmF0ZT1udWxsICkge1xuICAgICAgJ25vIGpzZHNwJ1xuICAgICAgaWYoIHZvbHVtZSAhPT0gbnVsbCApIHRoaXMuX190cmlnZ2VyTG91ZG5lc3MgPSB2b2x1bWVcblxuICAgICAgbGV0IHZvaWNlID0gbnVsbFxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHRoaXMuc2FtcGxlcnNbIHRoaXMuY3VycmVudFNhbXBsZSBdXG5cbiAgICAgICAgLy8gaWYgc2FtcGxlIGlzbid0IGxvYWRlZC4uLlxuICAgICAgICBpZiggc2FtcGxlciA9PT0gdW5kZWZpbmVkICkgcmV0dXJuXG5cbiAgICAgICAgdm9pY2UgPSB0aGlzLl9fZ2V0Vm9pY2VfXygpXG5cbiAgICAgICAgLy8gc2V0IHZvaWNlIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHZvaWNlLmJ1ZmZlckxlbmd0aC5tZW1vcnkudmFsdWVzLmlkeCBdID0gc2FtcGxlci5kYXRhTGVuZ3RoXG5cbiAgICAgICAgLy8gc2V0IHZvaWNlIGRhdGEgaW5kZXhcbiAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHZvaWNlLmJ1ZmZlckxvYy5tZW1vcnkudmFsdWVzLmlkeCBdID0gc2FtcGxlci5kYXRhSWR4XG5cbiAgICAgICAgLy9pZiggcmF0ZSAhPT0gbnVsbCApIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSByYXRlXG4gICAgICAgIGlmKCByYXRlICE9PSBudWxsICkgdm9pY2UucmF0ZSA9IHJhdGVcbiAgICAgICAgaWYoIHJhdGUgPiAwICkge1xuICAgICAgICAgIHZvaWNlLnRyaWdnZXIoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCAncmV2ZXJzZT8nLCByYXRlIClcbiAgICAgICAgICB2b2ljZS5iYW5nLnRyaWdnZXIoKVxuICAgICAgICAgIC8vdm9pY2UucGhhc2UudmFsdWUgPSAwXG4gICAgICAgICAgdm9pY2UucGhhc2UudmFsdWUgPSBzYW1wbGVyLmRhdGFMZW5ndGggLSAxXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyggJ3BoYXNlJywgdm9pY2UucGhhc2UudmFsdWUgKVxuICAgICAgICB9XG4gICAgICAgIC8vaWYoIHJhdGUgPCAwICkge1xuICAgICAgICAvLyAgY29uc3QgcGhhc2UgPSBzYW1wbGVyLmRhdGFJZHggKyBNYXRoLnJvdW5kKChzYW1wbGVyLmRhdGFMZW5ndGgvMikpIC0gMVxuICAgICAgICAvLyAgY29uc29sZS5sb2coICdwaGFzZTonLCBwaGFzZSwgJ2xlbmd0aDonLCBzYW1wbGVyLmRhdGFMZW5ndGgsICdzdGFydDonLCBzYW1wbGVyLmRhdGFJZHggKVxuICAgICAgICAvLyAgLy92b2ljZS5waGFzZS52YWx1ZSA9IHBoYXNlXG4gICAgICAgIC8vICAvL2cuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5waGFzZS5tZW1vcnkudmFsdWUuaWR4IF0gPSBwaGFzZVxuICAgICAgICAvL31lbHNle1xuICAgICAgICAvLyAgLy8gd2lsbCByZXNldCBwaGFzZSB0byAwXG4gICAgICAgIC8vICB2b2ljZS50cmlnZ2VyKClcbiAgICAgICAgLy99XG4gICAgICAgIFxuICAgICAgICAvL3ZvaWNlLnRyaWdnZXIoKVxuICAgICAgICAvL2cuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5yYXRlLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSByYXRlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2b2ljZVxuICAgIH0sXG4gICAgX19nZXRWb2ljZV9fKCkge1xuICAgICAgcmV0dXJuIHRoaXMudm9pY2VzWyB0aGlzLnZvaWNlQ291bnQrKyAlIHRoaXMudm9pY2VzLmxlbmd0aCBdXG4gICAgfSxcbiAgfSlcblxuICBjb25zdCBTYW1wbGVyID0gaW5wdXRQcm9wcyA9PiB7XG4gICAgY29uc3Qgc3luID0gT2JqZWN0LmNyZWF0ZSggcHJvdG8gKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7IG9ubG9hZDpudWxsLCB2b2ljZUNvdW50OjAsIGZpbGVzOltdIH0sIFNhbXBsZXIuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuXG4gICAgc3luLmlzU3RlcmVvID0gcHJvcHMuaXNTdGVyZW8gIT09IHVuZGVmaW5lZCA/IHByb3BzLmlzU3RlcmVvIDogZmFsc2VcblxuICAgIGNvbnN0IHN0YXJ0ID0gZy5pbiggJ3N0YXJ0JyApLCBlbmQgPSBnLmluKCAnZW5kJyApLCBcbiAgICAgICAgICByYXRlID0gZy5pbiggJ3JhdGUnICksIHNob3VsZExvb3AgPSBnLmluKCAnbG9vcHMnICksXG4gICAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApLFxuICAgICAgICAgIC8vIHJhdGUgc3RvcmFnZSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3JlIHBsYXlpbmdcbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIGZvcndhcmQgb3IgaW4gcmV2ZXJzZSwgZm9yIHVzZSBpbiB0aGUgJ3RyaWdnZXInIG1ldGhvZC5cbiAgICAgICAgICByYXRlU3RvcmFnZSA9IGcuZGF0YShbMF0sIDEsIHsgbWV0YTp0cnVlIH0pXG5cbiAgICBPYmplY3QuYXNzaWduKCBzeW4sIHByb3BzIClcblxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgc3luLl9fbWV0YV9fID0ge1xuICAgICAgICBhZGRyZXNzOidhZGQnLFxuICAgICAgICBuYW1lOiBbJ2luc3RydW1lbnRzJywgJ011bHRpc2FtcGxlciddLFxuICAgICAgICBwcm9wZXJ0aWVzOiBKU09OLnN0cmluZ2lmeShwcm9wcyksIFxuICAgICAgICBpZDogc3luLmlkXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggc3luLmlkLCBzeW4gKVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBzeW4uX19tZXRhX18gKVxuICAgIH1cblxuICAgIGNvbnN0IHZvaWNlcyA9IFtdXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBzeW4ubWF4Vm9pY2VzOyBpKysgKSB7XG4gICAgICAndXNlIGpzZHNwJ1xuXG4gICAgICBjb25zdCB2b2ljZSA9IHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIGJ1ZmZlckxvYzogICAgZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBiYW5nOiBnLmJhbmcoKSxcbiAgICAgICAgLy8gWFhYIGhvdyBkbyBJIGNoYW5nZSB0aGlzIGZyb20gbWFpbiB0aHJlYWQ/XG4gICAgICAgIF9fcGFuOiBnLmRhdGEoIFsuNV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX3JhdGU6IGcuZGF0YSggWzFdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgX19zaG91bGRMb29wOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fbG91ZG5lc3M6ICBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIGdldCBsb3VkbmVzcygpIHsgXG4gICAgICAgICAgcmV0dXJuIGcuZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLl9fbG91ZG5lc3MubWVtb3J5LnZhbHVlcy5pZHggICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNldCBsb3VkbmVzcyggdiApIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX2xvdWRuZXNzLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBwYW4odikge1xuICAgICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLl9fcGFuLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICAgIHNldCByYXRlKHYpIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX3JhdGUubWVtb3J5LnZhbHVlcy5pZHggXSA9IHZcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgdm9pY2UucGhhc2UgPSBnLmNvdW50ZXIoIFxuICAgICAgICByYXRlICogdm9pY2UuX19yYXRlWzBdLCBcbiAgICAgICAgc3RhcnQgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0sXG4gICAgICAgIGVuZCAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSwgXG4gICAgICAgIHZvaWNlLmJhbmcsXG4gICAgICAgIHNob3VsZExvb3AsIFxuICAgICAgICB7IHNob3VsZFdyYXA6ZmFsc2UsIGluaXRpYWxWYWx1ZTo5OTk5OTk5IH1cbiAgICAgIClcblxuICAgICAgdm9pY2UudHJpZ2dlciA9IHZvaWNlLmJhbmcudHJpZ2dlclxuXG4gICAgICB2b2ljZS5ncmFwaCA9IGcuaWZlbHNlKFxuICAgICAgICAvLyBpZiBwaGFzZSBpcyBncmVhdGVyIHRoYW4gc3RhcnQgYW5kIGxlc3MgdGhhbiBlbmQuLi4gXG4gICAgICAgIGcuYW5kKCBcbiAgICAgICAgICBnLmd0ZSggdm9pY2UucGhhc2UsIHN0YXJ0ICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdICksIFxuICAgICAgICAgIGcubHQoICB2b2ljZS5waGFzZSwgZW5kICAgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0gKSBcbiAgICAgICAgKSxcbiAgICAgICAgLy8gLi4ucmVhZCBkYXRhXG4gICAgICAgIHZvaWNlLnBlZWsgPSBnLnBlZWtEeW4oIFxuICAgICAgICAgIHZvaWNlLmJ1ZmZlckxvY1swXSwgXG4gICAgICAgICAgdm9pY2UuYnVmZmVyTGVuZ3RoWzBdLFxuICAgICAgICAgIHZvaWNlLnBoYXNlLFxuICAgICAgICAgIHsgbW9kZTonc2FtcGxlcycgfVxuICAgICAgICApLFxuICAgICAgICAvLyAuLi5lbHNlIHJldHVybiAwXG4gICAgICAgIDBcbiAgICAgICkgXG4gICAgICAqIGxvdWRuZXNzIFxuICAgICAgKiB2b2ljZS5fX2xvdWRuZXNzWzBdIFxuXG4gICAgICBjb25zdCBwYW4gPSBnLnBhbiggdm9pY2UuZ3JhcGgsIHZvaWNlLmdyYXBoLCB2b2ljZS5fX3BhblswXSApXG4gICAgICB2b2ljZS5ncmFwaCA9IFsgcGFuLmxlZnQsIHBhbi5yaWdodCBdXG5cbiAgICAgIHZvaWNlcy5wdXNoKCB2b2ljZSApXG4gICAgfVxuXG4gICAgLy8gbG9hZCBpbiBzYW1wbGUgZGF0YVxuICAgIGNvbnN0IHNhbXBsZXJzID0ge31cblxuICAgIC8vIGJvdW5kIHRvIGluZGl2aWR1YWwgc2FtcGxlciBvYmplY3RzIGluIGxvYWRTYW1wbGUgZnVuY3Rpb25cbiAgICBzeW4ubG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKCBidWZmZXIsIG9ubG9hZCApIHtcbiAgICAgIC8vIG1haW4gdGhyZWFkOiB3aGVuIHNhbXBsZSBpcyBsb2FkZWQsIGNvcHkgaXQgb3ZlciBtZXNzYWdlIHBvcnRcbiAgICAgIC8vIHByb2Nlc3NvciB0aHJlYWQ6IG9ubG9hZCBpcyBjYWxsZWQgdmlhIG1lc3NhZ2Vwb3J0IGhhbmRsZXIsIGFuZFxuICAgICAgLy8gcGFzc2VkIGluIHRoZSBuZXcgYnVmZmVyIHRvIGJlIGNvcGllZC5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBjb25zdCBtZW1JZHggPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKCB0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCwgdHJ1ZSApXG5cbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWRkcmVzczonY29weV9tdWx0aScsXG4gICAgICAgICAgaWQ6ICAgICBzeW4uaWQsXG4gICAgICAgICAgYnVmZmVyOiB0aGlzLmRhdGEuYnVmZmVyLFxuICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYoIHR5cGVvZiBvbmxvYWQgPT09ICdmdW5jdGlvbicgKSBvbmxvYWQoIHRoaXMsIGJ1ZmZlciApXG5cbiAgICAgIH1lbHNlIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIHRoaXMuZGF0YS5idWZmZXIgPSBidWZmZXIgXG5cbiAgICAgICAgLy8gc2V0IGRhdGEgbWVtb3J5IHNwZWMgYmVmb3JlIGlzc3VpbmcgbWVtb3J5IHJlcXVlc3RcbiAgICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMubGVuZ3RoID0gdGhpcy5kYXRhLmRpbSA9IHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoXG5cbiAgICAgICAgLy8gcmVxdWVzdCBtZW1vcnkgdG8gY29weSB0aGUgYnVmZXIgb3ZlclxuICAgICAgICBnLmdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLmRhdGEubWVtb3J5LCBmYWxzZSApXG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwLnNldCggdGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMuaWR4IClcblxuICAgICAgICAvLyBzZXQgbG9jYXRpb24gb2YgYnVmZmVyIChkb2VzIG5vdCB3b3JrKVxuICAgICAgICB0aGlzLmRhdGFJZHggPSB0aGlzLmRhdGEubWVtb3J5LnZhbHVlcy5pZHhcblxuICAgICAgICBzeW4uY3VycmVudFNhbXBsZSA9IHRoaXMuZmlsZW5hbWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW4ubG9hZFNhbXBsZSA9IGZ1bmN0aW9uKCBmaWxlbmFtZSwgX19vbmxvYWQsIGJ1ZmZlcj1udWxsICkge1xuICAgICAgJ3VzZSBqc2RzcCdcblxuICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyBmaWxlbmFtZSBdID0ge1xuICAgICAgICBkYXRhTGVuZ3RoOiBudWxsLFxuICAgICAgICBkYXRhSWR4OiBudWxsLFxuICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgIGZpbGVuYW1lXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9ubG9hZCA9IHN5bi5sb2FkQnVmZmVyLmJpbmQoIHNhbXBsZXIgKSBcbiAgICAgIC8vIHBhc3NpbmcgYSBmaWxlbmFtZSB0byBkYXRhIHdpbGwgY2F1c2UgaXQgdG8gYmUgbG9hZGVkIGluIHRoZSBtYWluIHRocmVhZFxuICAgICAgLy8gb25sb2FkIHdpbGwgdGhlbiBiZSBjYWxsZWQgdG8gcGFzcyB0aGUgYnVmZmVyIG92ZXIgdGhlIG1lc3NhZ2Vwb3J0LiBJbiB0aGVcbiAgICAgIC8vIHByb2Nlc3NvciB0aHJlYWQsIG1ha2UgYSBwbGFjZWhvbGRlciB1bnRpbCBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBzYW1wbGVyLmRhdGEgPSBnLmRhdGEoIGJ1ZmZlciAhPT0gbnVsbCA/IGJ1ZmZlciA6IGZpbGVuYW1lLCAxLCB7IG9ubG9hZCB9KVxuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBhIHByb21pc2UgaXMgcmV0dXJuZWQ7IGEgdmFsaWRcbiAgICAgICAgLy8gZGF0YSBvYmplY3QgaXMgb25seSByZXR1cm4gaWYgdGhlIGZpbGUgaGFzIGJlZW5cbiAgICAgICAgLy8gcHJldmlvdXNseSBsb2FkZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGJ1ZmZlciBoYXNcbiAgICAgICAgLy8gYmVlbiBjYWNoZWQuXG4gICAgICAgIGlmKCBzYW1wbGVyLmRhdGEgaW5zdGFuY2VvZiBQcm9taXNlICkge1xuICAgICAgICAgIHNhbXBsZXIuZGF0YS50aGVuKCBkID0+IHtcbiAgICAgICAgICAgIHNhbXBsZXIuZGF0YSA9IGRcbiAgICAgICAgICAgIG1lbW9bIGZpbGVuYW1lIF0gPSBzYW1wbGVyLmRhdGEgXG4gICAgICAgICAgICBvbmxvYWQoIHNhbXBsZXIsIF9fb25sb2FkIClcbiAgICAgICAgICB9KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyB1c2luZyBhIGNhY2hlZCBkYXRhIGJ1ZmZlciwgbm8gbmVlZFxuICAgICAgICAgIC8vIGZvciBhc3luY2hyb25vdXMgbG9hZGluZy5cbiAgICAgICAgICBtZW1vWyBmaWxlbmFtZSBdID0gc2FtcGxlclxuICAgICAgICAgIG9ubG9hZCggc2FtcGxlciwgX19vbmxvYWQgKVxuICAgICAgICB9ICAgICBcbiAgICAgIH1lbHNle1xuICAgICAgICBzYW1wbGVyLmRhdGEgPSBnLmRhdGEoIG5ldyBGbG9hdDMyQXJyYXkoKSwgMSwgeyBvbmxvYWQsIGZpbGVuYW1lIH0pXG4gICAgICAgIHNhbXBsZXIuZGF0YS5vbmxvYWQgPSBvbmxvYWRcbiAgICAgIH0gXG4gICAgfVxuXG4gICAgcHJvcHMuZmlsZXMuZm9yRWFjaCggZmlsZW5hbWUgPT4gc3luLmxvYWRTYW1wbGUoIGZpbGVuYW1lICkgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgICd1c2UganNkc3AnXG4gICAgICBcbiAgICAgIGNvbnN0IGdyYXBocyA9IHZvaWNlcy5tYXAoIHZvaWNlID0+IHZvaWNlLmdyYXBoIClcbiAgICAgIGNvbnN0IGxlZnQgPSBnLmFkZCggLi4udm9pY2VzLm1hcCggdm9pY2UgPT4gdm9pY2UuZ3JhcGhbMF0gKSApXG4gICAgICBjb25zdCByaWdodCA9IGcuYWRkKCAuLi52b2ljZXMubWFwKCB2b2ljZSA9PiB2b2ljZS5ncmFwaFsxXSApIClcbiAgICAgIGNvbnN0IGdhaW4gPSBnLmluKCAnZ2FpbicgKVxuICAgICAgc3luLmdyYXBoID0gWyBsZWZ0ICogZ2FpbiwgcmlnaHQgKiBnYWluIF1cblxuICAgICAgaWYoIHN5bi5wYW5Wb2ljZXMgPT09IHRydWUgKSB7IFxuICAgICAgICBjb25zdCBwYW5uZXIgPSBnLnBhbiggc3luLmdyYXBoWzBdLCBzeW4uZ3JhcGhbMV0sIGcuaW4oICdwYW4nICkgKSBcbiAgICAgICAgc3luLmdyYXBoID0gWyBwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW4uX19jcmVhdGVHcmFwaCgpXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBzeW4sXG4gICAgICBzeW4uZ3JhcGgsXG4gICAgICBbJ2luc3RydW1lbnRzJywnbXVsdGlzYW1wbGVyJ10sIFxuICAgICAgcHJvcHMgXG4gICAgKSBcblxuICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSB0cnVlXG4gICAgR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IGZhbHNlXG5cbiAgICBvdXQudm9pY2VzID0gdm9pY2VzXG4gICAgb3V0LnNhbXBsZXJzID0gc2FtcGxlcnNcblxuICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0cnVlXG4gICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IGZhbHNlXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBTYW1wbGVyLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IDEsXG4gICAgcGFuOiAuNSxcbiAgICByYXRlOiAxLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBzaG91bGRMb29wOmZhbHNlLFxuICAgIGxvb3BzOiAwLFxuICAgIHN0YXJ0OjAsXG4gICAgZW5kOjEsXG4gICAgYnVmZmVyTGVuZ3RoOi05OTk5OTk5OTksXG4gICAgbG91ZG5lc3M6MSxcbiAgICBtYXhWb2ljZXM6NSwgXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgcmV0dXJuIFNhbXBsZXJcbn1cbiIsIi8vIFhYWCBUT08gTUFOWSBHTE9CQUwgR0lCQkVSSVNIIFZBTFVFU1xuXG5jb25zdCBHaWJiZXJpc2ggPSByZXF1aXJlKCAnLi4vaW5kZXguanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vdGUoIGZyZXEgKSB7XG4gICAgLy8gd2lsbCBiZSBzZW50IHRvIHByb2Nlc3NvciBub2RlIHZpYSBwcm94eSBtZXRob2QuLi5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgIT09ICd3b3JrbGV0JyApIHtcbiAgICAgIGxldCB2b2ljZSA9IHRoaXMuX19nZXRWb2ljZV9fKClcbiAgICAgIC8vT2JqZWN0LmFzc2lnbiggdm9pY2UsIHRoaXMucHJvcGVydGllcyApXG4gICAgICAvL2lmKCBnYWluID09PSB1bmRlZmluZWQgKSBnYWluID0gdGhpcy5nYWluXG4gICAgICAvL3ZvaWNlLmdhaW4gPSBnYWluXG4gICAgICB2b2ljZS5fX3RyaWdnZXJMb3VkbmVzcyA9IHRoaXMuX190cmlnZ2VyTG91ZG5lc3NcbiAgICAgIHZvaWNlLm5vdGUoIGZyZXEsIHRoaXMuX190cmlnZ2VyTG91ZG5lc3MgKVxuICAgICAgdGhpcy5fX3J1blZvaWNlX18oIHZvaWNlLCB0aGlzIClcbiAgICAgIHRoaXMudHJpZ2dlck5vdGUgPSBmcmVxXG4gICAgfVxuICB9LFxuXG4gIC8vIFhYWCB0aGlzIGlzIG5vdCBwYXJ0aWN1bGFybHkgc2F0aXNmeWluZy4uLlxuICAvLyBtdXN0IGNoZWNrIGZvciBib3RoIG5vdGVzIGFuZCBjaG9yZHNcbiAgdHJpZ2dlciggbG91ZG5lc3MgKSB7XG4gICAgaWYoIHRoaXMudHJpZ2dlckNob3JkICE9PSBudWxsICkge1xuICAgICAgdGhpcy50cmlnZ2VyQ2hvcmQuZm9yRWFjaCggdiA9PiB7XG4gICAgICAgIGxldCB2b2ljZSA9IHRoaXMuX19nZXRWb2ljZV9fKClcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggdm9pY2UsIHRoaXMucHJvcGVydGllcyApXG4gICAgICAgIHZvaWNlLm5vdGUoIHYsIGxvdWRuZXNzIClcbiAgICAgICAgdGhpcy5fX3J1blZvaWNlX18oIHZvaWNlLCB0aGlzIClcbiAgICAgIH0pXG4gICAgfWVsc2UgaWYoIHRoaXMudHJpZ2dlck5vdGUgIT09IG51bGwgKSB7XG4gICAgICBsZXQgdm9pY2UgPSB0aGlzLl9fZ2V0Vm9pY2VfXygpXG4gICAgICBPYmplY3QuYXNzaWduKCB2b2ljZSwgdGhpcy5wcm9wZXJ0aWVzIClcbiAgICAgIHZvaWNlLm5vdGUoIHRoaXMudHJpZ2dlck5vdGUsIGxvdWRuZXNzIClcbiAgICAgIHRoaXMuX19ydW5Wb2ljZV9fKCB2b2ljZSwgdGhpcyApXG4gICAgfWVsc2V7XG4gICAgICBsZXQgdm9pY2UgPSB0aGlzLl9fZ2V0Vm9pY2VfXygpXG4gICAgICBPYmplY3QuYXNzaWduKCB2b2ljZSwgdGhpcy5wcm9wZXJ0aWVzIClcbiAgICAgIHZvaWNlLnRyaWdnZXIoIGxvdWRuZXNzIClcbiAgICAgIHRoaXMuX19ydW5Wb2ljZV9fKCB2b2ljZSwgdGhpcyApXG4gICAgfVxuICB9LFxuXG4gIF9fcnVuVm9pY2VfXyggdm9pY2UsIF9wb2x5ICkge1xuICAgIGlmKCAhdm9pY2UuaXNDb25uZWN0ZWQgKSB7XG4gICAgICB2b2ljZS5jb25uZWN0KCBfcG9seSApXG4gICAgICB2b2ljZS5pc0Nvbm5lY3RlZCA9IHRydWVcbiAgICB9XG5cbiAgICAvL2xldCBlbnZDaGVja1xuICAgIC8vaWYoIF9wb2x5LmVudkNoZWNrID09PSB1bmRlZmluZWQgKSB7XG4gICAgLy8gIGVudkNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgaWYoIHZvaWNlLmVudi5pc0NvbXBsZXRlKCkgKSB7XG4gICAgLy8gICAgICBfcG9seS5kaXNjb25uZWN0VWdlbiggdm9pY2UgKVxuICAgIC8vICAgICAgdm9pY2UuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIC8vICAgIH1lbHNle1xuICAgIC8vICAgICAgR2liYmVyaXNoLmJsb2NrQ2FsbGJhY2tzLnB1c2goIGVudkNoZWNrIClcbiAgICAvLyAgICB9XG4gICAgLy8gIH1cbiAgICAvL31lbHNle1xuICAgIC8vICBlbnZDaGVjayA9IF9wb2x5LmVudkNoZWNrKCB2b2ljZSwgX3BvbHkgKVxuICAgIC8vfVxuXG4gICAgLy8gWFhYIHVuY29tbWVudCB0aGlzIGxpbmUgdG8gdHVybiBvbiBkeW5hbWljYWxseSBjb25uZWN0aW5nXG4gICAgLy8gZGlzY29ubmVjdGluZyBpbmRpdmlkdWFsIHZvaWNlcyBmcm9tIGdyYXBoXG4gICAgLy9HaWJiZXJpc2guYmxvY2tDYWxsYmFja3MucHVzaCggZW52Q2hlY2sgKVxuICB9LFxuXG4gIF9fZ2V0Vm9pY2VfXygpIHtcbiAgICByZXR1cm4gdGhpcy52b2ljZXNbIHRoaXMudm9pY2VDb3VudCsrICUgdGhpcy52b2ljZXMubGVuZ3RoIF1cbiAgfSxcblxuICBjaG9yZCggZnJlcXVlbmNpZXMgKSB7XG4gICAgLy8gd2lsbCBiZSBzZW50IHRvIHByb2Nlc3NvciBub2RlIHZpYSBwcm94eSBtZXRob2QuLi5cbiAgICBpZiggR2liYmVyaXNoICE9PSB1bmRlZmluZWQgJiYgR2liYmVyaXNoLm1vZGUgIT09ICd3b3JrbGV0JyApIHtcbiAgICAgIGZyZXF1ZW5jaWVzLmZvckVhY2goIHYgPT4gdGhpcy5ub3RlKCB2ICkgKVxuICAgICAgdGhpcy50cmlnZ2VyQ2hvcmQgPSBmcmVxdWVuY2llc1xuICAgIH1cbiAgfSxcblxuICBmcmVlKCkge1xuICAgIGZvciggbGV0IGNoaWxkIG9mIHRoaXMudm9pY2VzICkgY2hpbGQuZnJlZSgpXG4gIH0sXG5cbiAgdHJpZ2dlckNob3JkOm51bGwsXG4gIHRyaWdnZXJOb3RlOm51bGxcbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGVzIGNyZWF0ZXMgYSBmYWN0b3J5IGdlbmVyYXRpbmcgcG9seXN5bnRoIGNvbnN0cnVjdG9ycy5cbiAqL1xuXG5jb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuY29uc3QgX19wcm94eSA9IHJlcXVpcmUoICcuLi93b3JrbGV0UHJveHkuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG5cbiAgY29uc3QgVGVtcGxhdGVGYWN0b3J5ID0gKCB1Z2VuLCBwcm9wZXJ0eUxpc3QsIF9lbnZDaGVjayApID0+IHtcblxuICAgIGNvbnN0IFRlbXBsYXRlID0gcHJvcHMgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oIHt9LCB7IGlzU3RlcmVvOnRydWUsIG1heFZvaWNlczo0IH0sIHByb3BzIClcblxuICAgICAgLy9jb25zdCBzeW50aCA9IHByb3BlcnRpZXMuaXNTdGVyZW8gPT09IHRydWUgPyBPYmplY3QuY3JlYXRlKCBzdGVyZW9Qcm90byApIDogT2JqZWN0LmNyZWF0ZSggbW9ub1Byb3RvIClcbiAgICAgIGNvbnN0IHN5bnRoID0gcHJvcGVydGllcy5pc1N0ZXJlbyA9PT0gdHJ1ZSA/IEdpYmJlcmlzaC5CdXMyKHsgX191c2VQcm94eV9fOmZhbHNlIH0pIDogR2liYmVyaXNoLkJ1cyh7IF9fdXNlUHJveHlfXzpmYWxzZSB9KSBcblxuICAgICAgT2JqZWN0LmFzc2lnbiggXG4gICAgICAgIHN5bnRoLCBcblxuICAgICAgICB7XG4gICAgICAgICAgbWF4Vm9pY2VzOiBwcm9wZXJ0aWVzLm1heFZvaWNlcywgXG4gICAgICAgICAgdm9pY2VDb3VudDogMCxcbiAgICAgICAgICBlbnZDaGVjazogX2VudkNoZWNrLFxuICAgICAgICAgIGRpcnR5OiB0cnVlLFxuICAgICAgICAgIHVnZW5OYW1lOiAncG9seScgKyB1Z2VuLm5hbWUgKyAnXycgKyBzeW50aC5pZCArICdfJyArICggcHJvcGVydGllcy5pc1N0ZXJlbyA/IDIgOiAxICksXG4gICAgICAgICAgcHJvcGVydGllc1xuICAgICAgICB9LFxuXG4gICAgICAgIEdpYmJlcmlzaC5taXhpbnMucG9seWluc3RydW1lbnRcbiAgICAgIClcblxuICAgICAgcHJvcGVydGllcy5wYW5Wb2ljZXMgPSB0cnVlLy9mYWxzZS8vcHJvcGVydGllcy5pc1N0ZXJlb1xuICAgICAgc3ludGguY2FsbGJhY2sudWdlbk5hbWUgPSBzeW50aC51Z2VuTmFtZVxuXG4gICAgICBjb25zdCBzdG9yZWRJZCA9IHByb3BlcnRpZXMuaWRcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmlkICE9PSB1bmRlZmluZWQgKSBkZWxldGUgcHJvcGVydGllcy5pZCBcblxuICAgICAgY29uc3Qgdm9pY2VzID0gW11cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgc3ludGgubWF4Vm9pY2VzOyBpKysgKSB7XG4gICAgICAgIHByb3BlcnRpZXMuaWQgPSBzeW50aC5pZCArJ18nK2lcbiAgICAgICAgdm9pY2VzW2ldID0gdWdlbiggcHJvcGVydGllcyApXG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKVxuICAgICAgICAgIHZvaWNlc1tpXS5jYWxsYmFjay51Z2VuTmFtZSA9IHZvaWNlc1tpXS51Z2VuTmFtZVxuXG4gICAgICAgIHZvaWNlc1tpXS5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgIC8vc3ludGguX192b2ljZXNbaV0gPSBwcm94eSggWydpbnN0cnVtZW50cycsIHVnZW4ubmFtZV0sIHByb3BlcnRpZXMsIHN5bnRoLnZvaWNlc1tpXSApXG4gICAgICB9XG5cbiAgICAgIGxldCBfcHJvcGVydHlMaXN0IFxuICAgICAgaWYoIHByb3BlcnRpZXMuaXNTdGVyZW8gPT09IGZhbHNlICkge1xuICAgICAgICBfcHJvcGVydHlMaXN0ID0gcHJvcGVydHlMaXN0LnNsaWNlKCAwIClcbiAgICAgICAgY29uc3QgaWR4ID0gIF9wcm9wZXJ0eUxpc3QuaW5kZXhPZiggJ3BhbicgKVxuICAgICAgICBpZiggaWR4ICA+IC0xICkgX3Byb3BlcnR5TGlzdC5zcGxpY2UoIGlkeCwgMSApXG4gICAgICB9XG5cbiAgICAgIHByb3BlcnRpZXMuaWQgPSBzdG9yZWRJZFxuXG4gICAgICBUZW1wbGF0ZUZhY3Rvcnkuc2V0dXBQcm9wZXJ0aWVzKCBzeW50aCwgdWdlbiwgcHJvcGVydGllcy5pc1N0ZXJlbyA/IHByb3BlcnR5TGlzdCA6IF9wcm9wZXJ0eUxpc3QgKVxuICAgICAgXG4gICAgICBjb25zdCBwID0gcHJveHkoIFsnaW5zdHJ1bWVudHMnLCAnUG9seScrdWdlbi5uYW1lXSwgcHJvcGVydGllcywgc3ludGggKSBcblxuICAgICAgLy8gcHJveHkgd29ya2Fyb3VuZCBuaWdodG1hcmUuLi4gaWYgd2UgaW5jbHVkZSB0aGUgdm9pY2VzIHdoZW4gd2UgY3JlYXRlXG4gICAgICAvLyB0aGUgcHJveHksIHRoZXkgd2luZCB1cCBiZWluZyBzdHJhbmdlbHkgdW5hZGRyZXNzYWJsZS4gcGVyaGFwcyB0aGV5XG4gICAgICAvLyBhcmUgYmVpbmcgb3ZlcndyaXR0aW5nIGluIHRoZSBQcm9jZXNzb3IudWdlbnMgbWFwIG9iamVjdD9cbiAgICAgIC8vIG1hbnVhbGx5IGFkZGluZyBlYWNoIG9uZSBzZWVtcyB0byB3b3JrIGFyb3VuZCB0aGUgcHJvYmxlbVxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgIHAudm9pY2VzID0gW11cbiAgICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgICBmb3IoIGxldCB2IG9mIHZvaWNlcyApIHtcbiAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICdhZGRPYmplY3RUb1Byb3BlcnR5JyxcbiAgICAgICAgICAgIG9iamVjdDogc3ludGguaWQsXG4gICAgICAgICAgICBuYW1lOid2b2ljZXMnLFxuICAgICAgICAgICAga2V5OmNvdW50LFxuICAgICAgICAgICAgdmFsdWU6di5pZFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBwLnZvaWNlc1sgY291bnQgXSA9IHZcbiAgICAgICAgICBjb3VudCsrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHAgXG4gICAgfVxuXG4gICAgcmV0dXJuIFRlbXBsYXRlXG4gIH1cblxuICBUZW1wbGF0ZUZhY3Rvcnkuc2V0dXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHN5bnRoLCB1Z2VuLCBwcm9wcyApIHtcbiAgICBmb3IoIGxldCBwcm9wZXJ0eSBvZiBwcm9wcyApIHtcbiAgICAgIGlmKCBwcm9wZXJ0eSA9PT0gJ3BhbicgfHwgcHJvcGVydHkgPT09ICdpZCcgKSBjb250aW51ZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBzeW50aCwgcHJvcGVydHksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOnRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc3ludGgucHJvcGVydGllc1sgcHJvcGVydHkgXSB8fCB1Z2VuLmRlZmF1bHRzWyBwcm9wZXJ0eSBdXG4gICAgICAgIH0sXG4gICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICBzeW50aC5wcm9wZXJ0aWVzWyBwcm9wZXJ0eSBdID0gdlxuICAgICAgICAgIGZvciggbGV0IGNoaWxkIG9mIHN5bnRoLnZvaWNlcyApIHtcbiAgICAgICAgICAgIGNoaWxkWyBwcm9wZXJ0eSBdID0gdlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVGVtcGxhdGVGYWN0b3J5XG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm90byA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuICBjb25zdCBtZW1vID0ge31cblxuICBPYmplY3QuYXNzaWduKCBwcm90bywge1xuICAgIG5vdGUoIHJhdGUgKSB7XG4gICAgICB0aGlzLnJhdGUgPSByYXRlXG4gICAgICBpZiggcmF0ZSA+IDAgKSB7XG4gICAgICAgIHRoaXMuX190cmlnZ2VyKClcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLl9fcGhhc2VfXy52YWx1ZSA9IHRoaXMuZW5kICogKHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoIC0gMSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXIoIHZvbHVtZSApIHtcbiAgICAgIGlmKCB2b2x1bWUgIT09IHVuZGVmaW5lZCApIHRoaXMuZ2FpbiA9IHZvbHVtZVxuXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIHRoZSBzYW1wbGUgZm9yd2FyZHMuLi5cbiAgICAgICAgaWYoIEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgdGhpcy5fX3JhdGVTdG9yYWdlX18ubWVtb3J5LnZhbHVlcy5pZHggXSA+IDAgKSB7XG4gICAgICAgICAgdGhpcy5fX3RyaWdnZXIoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aGlzLl9fcGhhc2VfXy52YWx1ZSA9IHRoaXMuZW5kICogKHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoIC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG5cbiAgY29uc3QgU2FtcGxlciA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHN5biA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBvbmxvYWQ6bnVsbCB9LCBTYW1wbGVyLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcblxuICAgIHN5bi5pc1N0ZXJlbyA9IHByb3BzLmlzU3RlcmVvICE9PSB1bmRlZmluZWQgPyBwcm9wcy5pc1N0ZXJlbyA6IGZhbHNlXG5cbiAgICBjb25zdCBzdGFydCA9IGcuaW4oICdzdGFydCcgKSwgZW5kID0gZy5pbiggJ2VuZCcgKSwgXG4gICAgICAgICAgYnVmZmVyTGVuZ3RoID0gZy5pbiggJ2J1ZmZlckxlbmd0aCcgKSwgXG4gICAgICAgICAgcmF0ZSA9IGcuaW4oICdyYXRlJyApLCBzaG91bGRMb29wID0gZy5pbiggJ2xvb3BzJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICAvLyByYXRlIHN0b3JhZ2UgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSdyZSBwbGF5aW5nXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBmb3J3YXJkIG9yIGluIHJldmVyc2UsIGZvciB1c2UgaW4gdGhlICd0cmlnZ2VyJyBtZXRob2QuXG4gICAgICAgICAgcmF0ZVN0b3JhZ2UgPSBnLmRhdGEoWzBdLCAxLCB7IG1ldGE6dHJ1ZSB9KVxuXG4gICAgT2JqZWN0LmFzc2lnbiggc3luLCBwcm9wcyApXG5cbiAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgIHN5bi5fX21ldGFfXyA9IHtcbiAgICAgICAgYWRkcmVzczonYWRkJyxcbiAgICAgICAgbmFtZTogWydpbnN0cnVtZW50cycsICdTYW1wbGVyJ10sXG4gICAgICAgIHByb3BlcnRpZXM6IEpTT04uc3RyaW5naWZ5KHByb3BzKSwgXG4gICAgICAgIGlkOiBzeW4uaWRcbiAgICAgIH1cblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuc2V0KCBzeW4uaWQsIHN5biApXG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoIHN5bi5fX21ldGFfXyApXG4gICAgfVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHN5bi5fX2JhbmdfXyA9IGcuYmFuZygpXG4gICAgICBzeW4uX190cmlnZ2VyID0gc3luLl9fYmFuZ19fLnRyaWdnZXJcblxuICAgICAgc3luLl9fcGhhc2VfXyA9IGcuY291bnRlciggXG4gICAgICAgIHJhdGUsIFxuICAgICAgICBnLm11bChzdGFydCxidWZmZXJMZW5ndGgpLCBcbiAgICAgICAgZy5tdWwoIGVuZCwgYnVmZmVyTGVuZ3RoICksIFxuICAgICAgICBzeW4uX19iYW5nX18sIFxuICAgICAgICBzaG91bGRMb29wLCBcbiAgICAgICAgeyBzaG91bGRXcmFwOmZhbHNlLCBpbml0aWFsVmFsdWU6OTk5OTk5OSB9XG4gICAgICApXG4gICAgICBcbiAgICAgIHN5bi5fX3JhdGVTdG9yYWdlX18gPSByYXRlU3RvcmFnZVxuICAgICAgcmF0ZVN0b3JhZ2VbMF0gPSByYXRlXG5cbiAgICAgIC8vIFhYWCB3ZSBhZGRlZCBvdXIgcmVjb3JkZWQgJ3JhdGUnIHBhcmFtIGFuZCB0aGVuIGVmZmVjdGl2ZWx5IHN1YnRyYWN0IGl0LFxuICAgICAgLy8gc28gdGhhdCBpdHMgcHJlc2VuY2UgaW4gdGhlIGdyYXBoIHdpbGwgZm9yY2UgZ2VuaXNoIHRvIGFjdHVhbGx5IHJlY29yZCB0aGUgXG4gICAgICAvLyByYXRlIGFzIHRoZSBpbnB1dC4gdGhpcyBpcyBleHRyZW1lbHkgaGFja3kuLi4gdGhlcmUgc2hvdWxkIGJlIGEgd2F5IHRvIHJlY29yZFxuICAgICAgLy8gdmFsdWUgd2l0aG91dCBoYXZpbmcgdG8gaW5jbHVkZSBpdCBpbiB0aGUgZ3JhcGghXG4gICAgICBzeW4uZ3JhcGggPSBnLmFkZCggZy5tdWwoIFxuICAgICAgICBnLmlmZWxzZSggXG4gICAgICAgICAgZy5hbmQoIGcuZ3RlKCBzeW4uX19waGFzZV9fLCBnLm11bChzdGFydCxidWZmZXJMZW5ndGgpICksIGcubHQoIHN5bi5fX3BoYXNlX18sIGcubXVsKGVuZCxidWZmZXJMZW5ndGgpICkgKSxcbiAgICAgICAgICBnLnBlZWsoIFxuICAgICAgICAgICAgc3luLmRhdGEsIFxuICAgICAgICAgICAgc3luLl9fcGhhc2VfXyxcbiAgICAgICAgICAgIHsgbW9kZTonc2FtcGxlcycgfVxuICAgICAgICAgICksXG4gICAgICAgICAgMFxuICAgICAgICApLCBcbiAgICAgICAgZy5tdWwoIGcubXVsKCBsb3VkbmVzcywgdHJpZ2dlckxvdWRuZXNzICksIGcuaW4oJ2dhaW4nKSApXG4gICAgICApLCByYXRlU3RvcmFnZVswXSwgZy5tdWwoIHJhdGVTdG9yYWdlWzBdLCAtMSApIClcbiAgICAgIFxuICAgICAgaWYoIHN5bi5wYW5Wb2ljZXMgPT09IHRydWUgKSB7IFxuICAgICAgICBjb25zdCBwYW5uZXIgPSBnLnBhbiggc3luLmdyYXBoLCBzeW4uZ3JhcGgsIGcuaW4oICdwYW4nICkgKSBcbiAgICAgICAgc3luLmdyYXBoID0gWyBwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbmxvYWQgPSAoYnVmZmVyLGZpbGVuYW1lKSA9PiB7XG4gICAgICBpZiggYnVmZmVyID09PSB1bmRlZmluZWQgKSByZXR1cm5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICAvL2NvbnN0IG1lbUlkeCA9IG1lbW9bIGZpbGVuYW1lIF0uaWR4ICE9PSB1bmRlZmluZWQgPyBtZW1vWyBmaWxlbmFtZSBdLmlkeCA6IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoIHN5bi5kYXRhLm1lbW9yeS52YWx1ZXMubGVuZ3RoLCB0cnVlIClcblxuICAgICAgICBjb25zdCBtZW1JZHggPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKCBidWZmZXIubGVuZ3RoLCB0cnVlIClcbiAgICAgICAgLy9tZW1vWyBmaWxlbmFtZSBdLmlkeCA9IG1lbUlkeFxuXG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFkZHJlc3M6J2NvcHknLFxuICAgICAgICAgIGlkOiAgICAgc3luLmlkLFxuICAgICAgICAgIGlkeDogICAgbWVtSWR4LFxuICAgICAgICAgIGJ1ZmZlclxuICAgICAgICB9KVxuXG4gICAgICB9ZWxzZSBpZiAoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgc3luLmRhdGEuYnVmZmVyID0gYnVmZmVyXG4gICAgICAgIHN5bi5kYXRhLm1lbW9yeS52YWx1ZXMubGVuZ3RoID0gc3luLmRhdGEuZGltID0gYnVmZmVyLmxlbmd0aFxuICAgICAgICBzeW4uX19yZWRvR3JhcGgoKSBcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiBzeW4ub25sb2FkID09PSAnZnVuY3Rpb24nICl7ICBcbiAgICAgICAgc3luLm9ubG9hZCggYnVmZmVyIHx8IHN5bi5kYXRhLmJ1ZmZlciApXG4gICAgICB9XG4gICAgICBpZiggc3luLmJ1ZmZlckxlbmd0aCA9PT0gLTk5OTk5OTk5OSAmJiBzeW4uZGF0YS5idWZmZXIgIT09IHVuZGVmaW5lZCApIHN5bi5idWZmZXJMZW5ndGggPSBzeW4uZGF0YS5idWZmZXIubGVuZ3RoIC0gMVxuICAgIH1cblxuICAgIC8vaWYoIHByb3BzLmZpbGVuYW1lICkge1xuICAgIHN5bi5sb2FkRmlsZSA9IGZ1bmN0aW9uKCBmaWxlbmFtZSApIHtcbiAgICAgIC8vaWYoIG1lbW9bIGZpbGVuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlICE9PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICBzeW4uZGF0YSA9IGcuZGF0YSggZmlsZW5hbWUsIDEsIHsgb25sb2FkIH0pXG5cblxuICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBhIHByb21pc2UgaXMgcmV0dXJuZWQ7IGEgdmFsaWRcbiAgICAgICAgICAvLyBkYXRhIG9iamVjdCBpcyBvbmx5IHJldHVybiBpZiB0aGUgZmlsZSBoYXMgYmVlblxuICAgICAgICAgIC8vIHByZXZpb3VzbHkgbG9hZGVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBidWZmZXIgaGFzXG4gICAgICAgICAgLy8gYmVlbiBjYWNoZWQuXG4gICAgICAgICAgaWYoIHN5bi5kYXRhIGluc3RhbmNlb2YgUHJvbWlzZSApIHtcbiAgICAgICAgICAgIHN5bi5kYXRhLnRoZW4oIGQgPT4ge1xuICAgICAgICAgICAgICBzeW4uZGF0YSA9IGRcbiAgICAgICAgICAgICAgbWVtb1sgZmlsZW5hbWUgXSA9IHN5bi5kYXRhXG4gICAgICAgICAgICAgIG9ubG9hZCggZC5idWZmZXIsIGZpbGVuYW1lIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvLyB1c2luZyBhIGNhY2hlZCBkYXRhIGJ1ZmZlciwgbm8gbmVlZFxuICAgICAgICAgICAgLy8gZm9yIGFzeW5jaHJvbm91cyBsb2FkaW5nLlxuICAgICAgICAgICAgbWVtb1sgZmlsZW5hbWUgXSA9IHN5bi5kYXRhXG4gICAgICAgICAgICBvbmxvYWQoIHN5bi5kYXRhLmJ1ZmZlciwgZmlsZW5hbWUgKVxuICAgICAgICAgIH0gICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzeW4uZGF0YSA9IGcuZGF0YSggbmV3IEZsb2F0MzJBcnJheSgpLCAxLCB7IG9ubG9hZCwgZmlsZW5hbWUgfSlcbiAgICAgICAgICAvL21lbW9bIGZpbGVuYW1lIF0gPSBzeW4uZGF0YVxuICAgICAgICB9XG4gICAgICAvL31lbHNle1xuICAgICAgLy8gIHN5bi5kYXRhID0gbWVtb1sgZmlsZW5hbWUgXVxuICAgICAgLy8gIGNvbnNvbGUubG9nKCAnbWVtbyBkYXRhOicsIHN5bi5kYXRhIClcbiAgICAgIC8vICBvbmxvYWQoIHN5bi5kYXRhLmJ1ZmZlciwgZmlsZW5hbWUgKVxuICAgICAgLy99XG4gICAgfVxuXG4gICAgc3luLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiggYnVmZmVyICkge1xuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgc3luLmRhdGEuYnVmZmVyID0gYnVmZmVyXG4gICAgICAgIHN5bi5kYXRhLm1lbW9yeS52YWx1ZXMubGVuZ3RoID0gc3luLmRhdGEuZGltID0gYnVmZmVyLmxlbmd0aFxuICAgICAgICBzeW4uX19yZWRvR3JhcGgoKSBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcHJvcHMuZmlsZW5hbWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHN5bi5sb2FkRmlsZSggcHJvcHMuZmlsZW5hbWUgKVxuICAgIH1lbHNle1xuICAgICAgc3luLmRhdGEgPSBnLmRhdGEoIG5ldyBGbG9hdDMyQXJyYXkoKSApXG4gICAgfVxuXG4gICAgaWYoIHN5bi5kYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBzeW4uZGF0YS5vbmxvYWQgPSBvbmxvYWRcblxuICAgICAgc3luLl9fY3JlYXRlR3JhcGgoKVxuICAgIH1cblxuICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBcbiAgICAgIHN5bixcbiAgICAgIHN5bi5ncmFwaCxcbiAgICAgIFsnaW5zdHJ1bWVudHMnLCdzYW1wbGVyJ10sIFxuICAgICAgcHJvcHMgXG4gICAgKSBcblxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIFNhbXBsZXIuZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBwYW46IC41LFxuICAgIHJhdGU6IDEsXG4gICAgcGFuVm9pY2VzOmZhbHNlLFxuICAgIGxvb3BzOiAwLFxuICAgIHN0YXJ0OjAsXG4gICAgZW5kOjEsXG4gICAgYnVmZmVyTGVuZ3RoOi05OTk5OTk5OTksXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICBjb25zdCBlbnZDaGVja0ZhY3RvcnkgPSBmdW5jdGlvbiggdm9pY2UsIF9wb2x5ICkge1xuICAgIGNvbnN0IGVudkNoZWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIHZvaWNlLl9fcGhhc2VfXy5tZW1vcnkudmFsdWUuaWR4IF1cbiAgICAgIGlmKCAoIHZvaWNlLnJhdGUgPiAwICYmIHBoYXNlID4gdm9pY2UuZW5kICkgfHwgKCB2b2ljZS5yYXRlIDwgMCAmJiBwaGFzZSA8IDAgKSApIHtcbiAgICAgICAgX3BvbHkuZGlzY29ubmVjdFVnZW4uY2FsbCggX3BvbHksIHZvaWNlIClcbiAgICAgICAgdm9pY2UuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgfWVsc2V7XG4gICAgICAgIEdpYmJlcmlzaC5ibG9ja0NhbGxiYWNrcy5wdXNoKCBlbnZDaGVjayApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudkNoZWNrXG4gIH1cblxuICBjb25zdCBQb2x5U2FtcGxlciA9IEdpYmJlcmlzaC5Qb2x5VGVtcGxhdGUoIFNhbXBsZXIsIFsncmF0ZScsJ3BhbicsJ2dhaW4nLCdzdGFydCcsJ2VuZCcsJ2xvb3BzJywnYnVmZmVyTGVuZ3RoJywnX190cmlnZ2VyTG91ZG5lc3MnLCdsb3VkbmVzcyddLCBlbnZDaGVja0ZhY3RvcnkgKSBcblxuICByZXR1cm4gWyBTYW1wbGVyLCBQb2x5U2FtcGxlciBdXG59XG5cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcbiAgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbiAgY29uc3QgU25hcmUgPSBhcmd1bWVudFByb3BzID0+IHtcbiAgICBjb25zdCBzbmFyZSA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKSxcbiAgICAgICAgICBkZWNheSA9IGcuaW4oICdkZWNheScgKSxcbiAgICAgICAgICBzY2FsZWREZWNheSA9IGcubXVsKCBkZWNheSwgZy5nZW4uc2FtcGxlcmF0ZSAqIDIgKSxcbiAgICAgICAgICBzbmFwcHk9IGcuaW4oICdzbmFwcHknICksXG4gICAgICAgICAgdHVuZSAgPSBnLmluKCAndHVuZScgKSxcbiAgICAgICAgICBnYWluICA9IGcuaW4oICdnYWluJyApLFxuICAgICAgICAgIGxvdWRuZXNzID0gZy5pbiggJ2xvdWRuZXNzJyApLFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oJ19fdHJpZ2dlckxvdWRuZXNzJyksXG4gICAgICAgICAgTG91ZG5lc3MgPSBnLm11bCggbG91ZG5lc3MsIHRyaWdnZXJMb3VkbmVzcyApLFxuICAgICAgICAgIGVnID0gZy5kZWNheSggc2NhbGVkRGVjYXksIHsgaW5pdFZhbHVlOjAgfSApLCBcbiAgICAgICAgICBjaGVjayA9IGcubWVtbyggZy5ndCggZWcsIC4wMDA1ICkgKSxcbiAgICAgICAgICBybmQgPSBnLm11bCggZy5ub2lzZSgpLCBlZyApLFxuICAgICAgICAgIGhwZiA9IGcuc3ZmKCBybmQsIGcuYWRkKCAxMDAwLCBnLm11bCggZy5hZGQoIDEsIHR1bmUpLCAxMDAwICkgKSwgLjUsIDEsIGZhbHNlICksXG4gICAgICAgICAgc25hcCA9IGcubXVsKCBnLmd0cCggZy5tdWwoIGhwZiwgc25hcHB5ICksIDAgKSwgTG91ZG5lc3MgKSwgLy8gcmVjdGlmeVxuICAgICAgICAgIGJwZjEgPSBnLnN2ZiggZWcsIGcubXVsKCAxODAsIGcuYWRkKCB0dW5lLCAxICkgKSwgLjA1LCAyLCBmYWxzZSApLFxuICAgICAgICAgIGJwZjIgPSBnLnN2ZiggZWcsIGcubXVsKCAzMzAsIGcuYWRkKCB0dW5lLCAxICkgKSwgLjA1LCAyLCBmYWxzZSApLFxuICAgICAgICAgIG91dCAgPSBnLm1lbW8oIGcuYWRkKCBzbmFwLCBicGYxLCBnLm11bCggYnBmMiwgLjggKSApICksIC8vWFhYIHdoeSBpcyBtZW1vIG5lZWRlZD9cbiAgICAgICAgICBzY2FsZWRPdXQgPSBnLm11bCggb3V0LCBnLm11bCggZ2FpbiwgTG91ZG5lc3MgKSApLFxuICAgICAgICAgIGlmZSA9IGcuc3dpdGNoKCBjaGVjaywgc2NhbGVkT3V0LCAwICksXG4gICAgICAgICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgU25hcmUuZGVmYXVsdHMsIGFyZ3VtZW50UHJvcHMgKVxuXG4gICAgLy8gWFhYIFRPRE8gOiBtYWtlIGFib3ZlIHN3aXRjaCB3b3JrIHdpdGggaWZlbHNlLiB0aGUgcHJvYmxlbSBpcyB0aGF0IHBva2UgdWdlbnMgcHV0IHRoZWlyXG4gICAgLy8gY29kZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgaW5zdGVhZCBvZiBhdCB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIGFzc29jaWF0ZWQgaWYvZWxzZSBibG9jay5cbiAgICBcbiAgICBzbmFyZS5lbnYgPSBlZyBcbiAgICBjb25zdCBfX3NuYXJlID0gR2liYmVyaXNoLmZhY3RvcnkoIHNuYXJlLCBpZmUsIFsnaW5zdHJ1bWVudHMnLCdzbmFyZSddLCBwcm9wcyAgKVxuICAgIFxuICAgIHJldHVybiBfX3NuYXJlXG4gIH1cbiAgXG4gIFNuYXJlLmRlZmF1bHRzID0ge1xuICAgIGdhaW46IC41LFxuICAgIHR1bmU6MCxcbiAgICBzbmFwcHk6IDEsXG4gICAgZGVjYXk6LjEsXG4gICAgbG91ZG5lc3M6MSxcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICByZXR1cm4gU25hcmVcblxufVxuIiwiLypmZXRjaCggJzAwMDBfQXNwaXJpbl9zZjJfZmlsZS5qc29uJyApXG4udGhlbiggcmVzID0+IHJlcy5qc29uKCkgKVxuLnRoZW4oIGpzb24gPT4ge1xuICB3aW5kb3cuem9uZXMgPSBqc29uLnpvbmVzXG4gIGNvbnNvbGUubG9nKCB3aW5kb3cuem9uZXMgKVxufSlcblxuYWIgPSBHaWJiZXJpc2gudXRpbGl0aWVzLi5kZWNvZGVBcnJheUJ1ZmZlciggem9uZXNbMF0uZmlsZSApXG5nZW5pc2gudXRpbGl0aWVzLmN0eC5kZWNvZGVBdWRpb0RhdGEoIGFiLCBidWZmZXIgPT4ge1xuICBfX2FiID0gYnVmZmVyXG4gIGNvbnNvbGUubG9nKCAnYnVmZmVyIG1hZGUnIClcbn0pXG5cblxuX2QgPSBkYXRhKCBfX2FiIClcbnBsYXkoIHBlZWsoIF9kLCBwaGFzb3IoMSwwLHttaW46MH0pICkgKVxuKi9cblxuY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbmNvbnN0IHNvdW5kZm9udHMgPSB7fVxuXG5jb25zdCBiYW5rcyA9IFtcbiAgJ0FzcGlyaW4nLFxuICAnQ2hhb3MnLFxuICAnRmx1aWRSMycsXG4gICdHZW5lcmFsVXNlckdTJyxcbiAgJ0pDTGl2ZSdcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBwcm90byA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuICBjb25zdCBtZW1vID0ge31cbiAgXG4gIE9iamVjdC5hc3NpZ24oIHByb3RvLCB7XG4gICAgcGlja0ZpbGUoIHNhbXBsZSApIHtcbiAgICAgIHRoaXMuY3VycmVudFNhbXBsZSA9IHNhbXBsZVxuICAgIH0sXG4gICAgcGljayggX19pZHggKSB7XG4gICAgICBjb25zdCBpZHggPSBNYXRoLmZsb29yKCBfX2lkeCApXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuc2FtcGxlcnMgKVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1sgaWR4IF1cbiAgICAgIHRoaXMuY3VycmVudFNhbXBsZSA9IGtleVxuICAgIH0sXG4gICAgcGlja3BsYXkoIF9faWR4ICkge1xuICAgICAgY29uc3QgaWR4ID0gTWF0aC5mbG9vciggX19pZHggKVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLnNhbXBsZXJzIClcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbIGlkeCBdXG4gICAgICB0aGlzLmN1cnJlbnRTYW1wbGUgPSBrZXlcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoKVxuICAgIH0sXG4gICAgX19ub3RlKCByYXRlLCBsb3VkbmVzcz1udWxsICkge1xuICAgICAgLy8gc291bmRmb250IG1lYXN1cmVzIHBpdGNoIGluIGNlbnRzXG4gICAgICAvLyBvcmlnaW5hbFBpdGNoID0gZmluZE1pZGlGb3JIeiggaHogKSAqIDEwMCAvLyAoMTAwIGNlbnRzIHBlciBtaWRpIGluZGV4KVxuICAgICAgLy8gcmF0ZSA9IE1hdGgucG93KDIsICgxMDAuMCAqIHBpdGNoIC0gb3JpZ2luYWxQaXRjaCkgLyAxMjAwLjApIC8vIDEyMDAgY2VudHMgcGVyIG9jdGF2ZVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlciggbG91ZG5lc3MsIHJhdGUgKVxuICAgIH0sXG4gICAgbm90ZSggZnJlcSwgbG91ZG5lc3M9bnVsbCApIHtcbiAgICAgICdubyBqc2RzcCdcbiAgICAgIGNvbnN0IG1pZGlub3RlID0gNjkgKyAxMiAqIE1hdGgubG9nMiggZnJlcS80NDAgKVxuICAgICAgdGhpcy5taWRpbm90ZSggbWlkaW5vdGUsIGxvdWRuZXNzIClcbiAgICB9LFxuICAgIG1pZGlwaWNrKCBtaWRpbm90ZSwgbG91ZG5lc3MgKSB7XG4gICAgICAvLyBsb29wIHRocm91Z2ggem9uZXMgdG8gZmluZCBjb3JyZWN0IHNhbXBsZSAjXG4gICAgICBsZXQgaWR4ID0gMCwgcGl0Y2ggPSAwXG4gICAgICBmb3IoIGxldCB6b25lIG9mIHRoaXMuem9uZXMgKSB7XG4gICAgICAgIGlmKCBtaWRpbm90ZSA+PSB6b25lLmtleVJhbmdlTG93ICYmIG1pZGlub3RlIDw9IHpvbmUua2V5UmFuZ2VIaWdoICkge1xuICAgICAgICAgIHBpdGNoID0gem9uZS5vcmlnaW5hbFBpdGNoXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWR4KytcbiAgICAgIH1cbiAgICAgIHRoaXMucGljayggaWR4IClcbiAgICAgIHJldHVybiBwaXRjaFxuICAgIH0sXG4gICAgbWlkaW5vdGUoIG1pZGlub3RlLCBsb3VkbmVzcz1udWxsICkge1xuICAgICAgJ25vIGpzZHNwJ1xuICAgICAgY29uc3Qgc2FtcGxlUGl0Y2ggPSB0aGlzLm1pZGlwaWNrKCBtaWRpbm90ZSApXG4gICAgICBjb25zdCBwaXRjaCA9IE1hdGgucG93KCAyLCAoMTAwICogbWlkaW5vdGUgLSBzYW1wbGVQaXRjaCApIC8gMTIwMCApIFxuICAgICAgLy9jb25zdCBwaXRjaCA9IDEvL01hdGgucG93KCAyLCAoc2FtcGxlUGl0Y2ggKSApIFxuICAgICAgdGhpcy5fX25vdGUoIHBpdGNoLCBsb3VkbmVzcyApXG4gICAgfSwgXG4gICAgbWlkaWNob3JkKCBmcmVxdWVuY2llcyApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2ggIT09IHVuZGVmaW5lZCAmJiBHaWJiZXJpc2gubW9kZSAhPT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBmcmVxdWVuY2llcy5mb3JFYWNoKCB2ID0+IHRoaXMubWlkaW5vdGUoIHYgKSApXG4gICAgICAgIHRoaXMudHJpZ2dlckNob3JkID0gZnJlcXVlbmNpZXNcbiAgICAgIH1cbiAgICB9LFxuICAgIGNob3JkKCBmcmVxdWVuY2llcyApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2ggIT09IHVuZGVmaW5lZCAmJiBHaWJiZXJpc2gubW9kZSAhPT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBmcmVxdWVuY2llcy5mb3JFYWNoKCB2ID0+IHRoaXMubm90ZSggdiApIClcbiAgICAgICAgdGhpcy50cmlnZ2VyQ2hvcmQgPSBmcmVxdWVuY2llc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRwYW4oIG51bT0wLCB2YWx1ZT0uNSApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIGNvbnN0IHZvaWNlID0gdGhpcy52b2ljZXNbIG51bSBdXG4gICAgICAgIC8vIHNldCB2b2ljZSBidWZmZXIgbGVuZ3RoXG4gICAgICAgIC8vZy5nZW4ubWVtb3J5LmhlYXAuc2V0KCBbIHZhbHVlIF0sIHZvaWNlLnBhbi5tZW1vcnkudmFsdWVzLmlkeCApXG4gICAgICAgIHZvaWNlLnBhbiA9IHZhbHVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRyYXRlKCBudW09MCwgdmFsdWU9MSApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIGNvbnN0IHZvaWNlID0gdGhpcy52b2ljZXNbIG51bSBdXG4gICAgICAgIC8vIHNldCB2b2ljZSBidWZmZXIgbGVuZ3RoXG4gICAgICAgIC8vZy5nZW4ubWVtb3J5LmhlYXAuc2V0KCBbIHZhbHVlIF0sIHZvaWNlLnJhdGUubWVtb3J5LnZhbHVlcy5pZHggKVxuICAgICAgICB2b2ljZS5yYXRlID0gdmFsdWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXIoIHZvbHVtZT1udWxsLCByYXRlPW51bGwgKSB7XG4gICAgICAnbm8ganNkc3AnXG4gICAgICAvL2lmKCB2b2x1bWUgIT09IG51bGwgKSB0aGlzLl9fdHJpZ2dlckxvdWRuZXNzID0gdm9sdW1lXG5cbiAgICAgIGxldCB2b2ljZSA9IG51bGxcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSB0aGlzLnNhbXBsZXJzWyB0aGlzLmN1cnJlbnRTYW1wbGUgXVxuXG4gICAgICAgIC8vIGlmIHNhbXBsZSBpc24ndCBsb2FkZWQuLi5cbiAgICAgICAgaWYoIHNhbXBsZXIgPT09IHVuZGVmaW5lZCApIHJldHVyblxuXG4gICAgICAgIHZvaWNlID0gdGhpcy5fX2dldFZvaWNlX18oKVxuXG4gICAgICAgIC8vIHNldCB2b2ljZSBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5idWZmZXJMZW5ndGgubWVtb3J5LnZhbHVlcy5pZHggXSA9IHNhbXBsZXIuZGF0YUxlbmd0aFxuXG4gICAgICAgIC8vIHNldCB2b2ljZSBkYXRhIGluZGV4XG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5idWZmZXJMb2MubWVtb3J5LnZhbHVlcy5pZHggXSA9IHNhbXBsZXIuZGF0YUlkeFxuXG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB2b2ljZS5fX2xvb3BTdGFydC5tZW1vcnkudmFsdWVzLmlkeCBdID0gc2FtcGxlci56b25lLmxvb3BTdGFydFxuICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdm9pY2UuX19sb29wRW5kLm1lbW9yeS52YWx1ZXMuaWR4ICAgXSA9IHNhbXBsZXIuem9uZS5sb29wRW5kXG5cbiAgICAgICAgaWYoIHZvbHVtZSAhPT0gbnVsbCApXG4gICAgICAgICAgZy5nZW4ubWVtb3J5LmhlYXBbIHZvaWNlLmxvdWRuZXNzLm1lbW9yeS52YWx1ZXMuaWR4ICAgXSA9IHZvbHVtZVxuXG4gICAgICAgIGlmKCByYXRlICE9PSBudWxsICkgdm9pY2UucmF0ZSA9IHJhdGUgXG4gICAgICAgIFxuICAgICAgICB2b2ljZS50cmlnZ2VyKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZvaWNlXG4gICAgfSxcbiAgICBfX2dldFZvaWNlX18oKSB7XG4gICAgICByZXR1cm4gdGhpcy52b2ljZXNbIHRoaXMudm9pY2VDb3VudCsrICUgdGhpcy52b2ljZXMubGVuZ3RoIF1cbiAgICB9LFxuICB9KVxuXG4gIGNvbnN0IFNvdW5kZm9udCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHN5biA9IE9iamVjdC5jcmVhdGUoIHByb3RvIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbiggeyBvbmxvYWQ6bnVsbCwgdm9pY2VDb3VudDowLCBmaWxlczpbXSB9LCBTb3VuZGZvbnQuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuXG4gICAgc3luLmlzU3RlcmVvID0gcHJvcHMuaXNTdGVyZW8gIT09IHVuZGVmaW5lZCA/IHByb3BzLmlzU3RlcmVvIDogZmFsc2VcblxuICAgIGNvbnN0IHN0YXJ0ID0gZy5pbiggJ3N0YXJ0JyApLCBlbmQgPSBnLmluKCAnZW5kJyApLCBcbiAgICAgICAgICByYXRlID0gZy5pbiggJ3JhdGUnICksIHNob3VsZExvb3AgPSBnLmluKCAnbG9vcHMnICksXG4gICAgICAgICAgbG91ZG5lc3MgPSBnLmluKCAnbG91ZG5lc3MnICksXG4gICAgICAgICAgdHJpZ2dlckxvdWRuZXNzID0gZy5pbiggJ19fdHJpZ2dlckxvdWRuZXNzJyApLFxuICAgICAgICAgIC8vIHJhdGUgc3RvcmFnZSBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3JlIHBsYXlpbmdcbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIGZvcndhcmQgb3IgaW4gcmV2ZXJzZSwgZm9yIHVzZSBpbiB0aGUgJ3RyaWdnZXInIG1ldGhvZC5cbiAgICAgICAgICByYXRlU3RvcmFnZSA9IGcuZGF0YShbMF0sIDEsIHsgbWV0YTp0cnVlIH0pXG5cbiAgICBPYmplY3QuYXNzaWduKCBzeW4sIHByb3BzIClcblxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgc3luLl9fbWV0YV9fID0ge1xuICAgICAgICBhZGRyZXNzOidhZGQnLFxuICAgICAgICBuYW1lOiBbJ2luc3RydW1lbnRzJywgJ1NvdW5kZm9udCddLFxuICAgICAgICBwcm9wZXJ0aWVzOiBKU09OLnN0cmluZ2lmeShwcm9wcyksIFxuICAgICAgICBpZDogc3luLmlkXG4gICAgICB9XG5cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zLnNldCggc3luLmlkLCBzeW4gKVxuXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKCBzeW4uX19tZXRhX18gKVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbGwgb3VyIHZvY2Vjc1xuICAgIGNvbnN0IHZvaWNlcyA9IFtdXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBzeW4ubWF4Vm9pY2VzOyBpKysgKSB7XG4gICAgICAndXNlIGpzZHNwJ1xuXG4gICAgICBjb25zdCB2b2ljZSA9IHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIGJ1ZmZlckxvYzogICAgZy5kYXRhKCBbMV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBiYW5nOiBnLmJhbmcoKSxcbiAgICAgICAgLy8gWFhYIGhvdyBkbyBJIGNoYW5nZSB0aGlzIGZyb20gbWFpbiB0aHJlYWQ/XG4gICAgICAgIF9fcGFuOiBnLmRhdGEoIFsuNV0sIDEsIHsgbWV0YTp0cnVlIH0pLFxuICAgICAgICBfX3JhdGU6IGcuZGF0YSggWzFdLCAxLCB7IG1ldGE6dHJ1ZSB9KSxcbiAgICAgICAgX19zaG91bGRMb29wOiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fbG9vcFN0YXJ0OiBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fbG9vcEVuZDogICBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIF9fbG91ZG5lc3M6ICBnLmRhdGEoIFsxXSwgMSwgeyBtZXRhOnRydWUgfSksXG4gICAgICAgIGdldCBsb3VkbmVzcygpIHsgXG4gICAgICAgICAgcmV0dXJuIGcuZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLl9fbG91ZG5lc3MubWVtb3J5LnZhbHVlcy5pZHggICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNldCBsb3VkbmVzcyggdiApIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX2xvdWRuZXNzLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBwYW4odikge1xuICAgICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwWyB0aGlzLl9fcGFuLm1lbW9yeS52YWx1ZXMuaWR4IF0gPSB2XG4gICAgICAgIH0sXG4gICAgICAgIHNldCByYXRlKHYpIHtcbiAgICAgICAgICBnLmdlbi5tZW1vcnkuaGVhcFsgdGhpcy5fX3JhdGUubWVtb3J5LnZhbHVlcy5pZHggXSA9IHZcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgdm9pY2UucGhhc2UgPSBnLmNvdW50ZXIoIFxuICAgICAgICByYXRlICogdm9pY2UuX19yYXRlWzBdLCBcbiAgICAgICAgc3RhcnQgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0sXG4gICAgICAgIGVuZCAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSwgXG4gICAgICAgIHZvaWNlLmJhbmcsXG4gICAgICAgIHNob3VsZExvb3AsIFxuICAgICAgICB7IHNob3VsZFdyYXA6ZmFsc2UsIGluaXRpYWxWYWx1ZTo5OTk5OTk5IH1cbiAgICAgIClcblxuICAgICAgdm9pY2UudHJpZ2dlciA9IHZvaWNlLmJhbmcudHJpZ2dlclxuXG4gICAgICB2b2ljZS5ncmFwaCA9IGcuaWZlbHNlKFxuICAgICAgICAvLyBpZiBwaGFzZSBpcyBncmVhdGVyIHRoYW4gc3RhcnQgYW5kIGxlc3MgdGhhbiBlbmQuLi4gXG4gICAgICAgIGcuYW5kKCBcbiAgICAgICAgICBnLmd0ZSggdm9pY2UucGhhc2UsIHN0YXJ0ICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdICksIFxuICAgICAgICAgIGcubHQoICB2b2ljZS5waGFzZSwgZW5kICAgKiB2b2ljZS5idWZmZXJMZW5ndGhbMF0gKSBcbiAgICAgICAgKSxcbiAgICAgICAgLy8gLi4ucmVhZCBkYXRhXG4gICAgICAgIHZvaWNlLnBlZWsgPSBnLnBlZWtEeW4oIFxuICAgICAgICAgIHZvaWNlLmJ1ZmZlckxvY1swXSwgXG4gICAgICAgICAgdm9pY2UuYnVmZmVyTGVuZ3RoWzBdLFxuICAgICAgICAgIHZvaWNlLnBoYXNlLFxuICAgICAgICAgIHsgbW9kZTonc2FtcGxlcycgfVxuICAgICAgICApLFxuICAgICAgICAvLyAuLi5lbHNlIHJldHVybiAwXG4gICAgICAgIDBcbiAgICAgICkgXG4gICAgICAqIGxvdWRuZXNzIFxuICAgICAgKiB2b2ljZS5fX2xvdWRuZXNzWzBdIFxuXG4gICAgICAvLyBzdGFydCBvZiBhdHRlbXB0IHRvIGxvb3Agc3VzdGFpbi4uLlxuICAgICAgLy92b2ljZS5ncmFwaCA9IGcuaWZlbHNlKFxuICAgICAgLy8gIC8vIGlmIHBoYXNlIGlzIGdyZWF0ZXIgdGhhbiBzdGFydCBhbmQgbGVzcyB0aGFuIGVuZC4uLiBcbiAgICAgIC8vICBnLmFuZCggXG4gICAgICAvLyAgICBnLmd0ZSggdm9pY2UucGhhc2UsIHN0YXJ0ICogdm9pY2UuYnVmZmVyTGVuZ3RoWzBdICksIFxuICAgICAgLy8gICAgZy5sdCggIHZvaWNlLnBoYXNlLCBlbmQgICAqIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSApIFxuICAgICAgLy8gICksXG4gICAgICAvLyAgLy8gLi4ucmVhZCBkYXRhXG4gICAgICAvLyAgdm9pY2UucGVlayA9IGcucGVla0R5biggXG4gICAgICAvLyAgICB2b2ljZS5idWZmZXJMb2NbMF0sIFxuICAgICAgLy8gICAgdm9pY2UuYnVmZmVyTGVuZ3RoWzBdLFxuICAgICAgLy8gICAgdm9pY2UucGhhc2UsXG4gICAgICAvLyAgICB7IG1vZGU6J3NhbXBsZXMnIH1cbiAgICAgIC8vICApLFxuICAgICAgLy8gIC8vIC4uLmVsc2UgcmV0dXJuIDBcbiAgICAgIC8vICBnLmlmZWxzZShcbiAgICAgIC8vICAgIGcuYW5kKFxuICAgICAgLy8gICAgICB2b2ljZS5fX3Nob3VsZExvb3BbMF0sXG4gICAgICAvLyAgICAgIGcuZ3QoIHZvaWNlLnBoYXNlLCB2b2ljZS5fX2xvb3BFbmRbMF0gKVxuICAgICAgLy8gICAgKSxcbiAgICAgIC8vICAgIGcucGVla0R5biggXG4gICAgICAvLyAgICAgIHZvaWNlLmJ1ZmZlckxvY1swXSwgXG4gICAgICAvLyAgICAgIHZvaWNlLmJ1ZmZlckxlbmd0aFswXSxcbiAgICAgIC8vICAgICAgZy5hZGQoIFxuICAgICAgLy8gICAgICAgIHZvaWNlLl9fbG9vcFN0YXJ0WzBdLFxuICAgICAgLy8gICAgICAgIGcubW9kKFxuICAgICAgLy8gICAgICAgICAgdm9pY2UucGhhc2UsXG4gICAgICAvLyAgICAgICAgICAvL2cuc3ViKCB2b2ljZS5waGFzZSwgdm9pY2UuX19sb29wU3RhcnRbMF0gKSxcbiAgICAgIC8vICAgICAgICAgIGcuc3ViKCB2b2ljZS5fX2xvb3BFbmRbMF0sIHZvaWNlLl9fbG9vcFN0YXJ0WzBdIClcbiAgICAgIC8vICAgICAgICApXG4gICAgICAvLyAgICAgICksXG4gICAgICAvLyAgICAgIHsgbW9kZTonc2FtcGxlcycgfVxuICAgICAgLy8gICAgKSxcbiAgICAgIC8vICAgIDBcbiAgICAgIC8vICApXG4gICAgICAvLykgXG4gICAgICAvLyogbG91ZG5lc3MgXG4gICAgICAvLyogdHJpZ2dlckxvdWRuZXNzIFxuICAgICAgXG4gICAgICBjb25zdCBwYW4gPSBnLnBhbiggdm9pY2UuZ3JhcGgsIHZvaWNlLmdyYXBoLCB2b2ljZS5fX3BhblswXSApXG4gICAgICB2b2ljZS5ncmFwaCA9IFsgcGFuLmxlZnQsIHBhbi5yaWdodCBdXG5cbiAgICAgIHZvaWNlcy5wdXNoKCB2b2ljZSApXG4gICAgfVxuXG4gICAgLy8gbG9hZCBpbiBzYW1wbGUgZGF0YVxuICAgIGNvbnN0IHNhbXBsZXJzID0ge31cblxuICAgIC8vIGJvdW5kIHRvIGluZGl2aWR1YWwgc2FtcGxlciBvYmplY3RzIGluIGxvYWRTYW1wbGUgZnVuY3Rpb25cbiAgICBzeW4ubG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKCBidWZmZXIsIG9ubG9hZCApIHtcbiAgICAgIC8vIG1haW4gdGhyZWFkOiB3aGVuIHNhbXBsZSBpcyBsb2FkZWQsIGNvcHkgaXQgb3ZlciBtZXNzYWdlIHBvcnRcbiAgICAgIC8vIHByb2Nlc3NvciB0aHJlYWQ6IG9ubG9hZCBpcyBjYWxsZWQgdmlhIG1lc3NhZ2Vwb3J0IGhhbmRsZXIsIGFuZFxuICAgICAgLy8gcGFzc2VkIGluIHRoZSBuZXcgYnVmZmVyIHRvIGJlIGNvcGllZC5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBjb25zdCBtZW1JZHggPSBHaWJiZXJpc2gubWVtb3J5LmFsbG9jKCB0aGlzLmRhdGEuYnVmZmVyLmxlbmd0aCwgdHJ1ZSApXG5cbiAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWRkcmVzczonY29weV9tdWx0aScsXG4gICAgICAgICAgaWQ6ICAgICBzeW4uaWQsXG4gICAgICAgICAgYnVmZmVyOiB0aGlzLmRhdGEuYnVmZmVyLFxuICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYoIHR5cGVvZiBvbmxvYWQgPT09ICdmdW5jdGlvbicgKSBvbmxvYWQoIHRoaXMsIGJ1ZmZlciApXG5cbiAgICAgIH1lbHNlIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgIHRoaXMuZGF0YS5idWZmZXIgPSBidWZmZXIgXG5cbiAgICAgICAgLy8gc2V0IGRhdGEgbWVtb3J5IHNwZWMgYmVmb3JlIGlzc3VpbmcgbWVtb3J5IHJlcXVlc3RcbiAgICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMubGVuZ3RoID0gdGhpcy5kYXRhLmRpbSA9IHRoaXMuZGF0YS5idWZmZXIubGVuZ3RoXG4gICAgICAgIHRoaXMuem9uZSA9IHN5bi56b25lc1sgdGhpcy5maWxlbmFtZSBdXG5cbiAgICAgICAgLy8gcmVxdWVzdCBtZW1vcnkgdG8gY29weSB0aGUgYnVmZXIgb3ZlclxuICAgICAgICBnLmdlbi5yZXF1ZXN0TWVtb3J5KCB0aGlzLmRhdGEubWVtb3J5LCBmYWxzZSApXG4gICAgICAgIGcuZ2VuLm1lbW9yeS5oZWFwLnNldCggdGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLm1lbW9yeS52YWx1ZXMuaWR4IClcblxuICAgICAgICAvLyBzZXQgbG9jYXRpb24gb2YgYnVmZmVyIChkb2VzIG5vdCB3b3JrKVxuICAgICAgICB0aGlzLmRhdGFJZHggPSB0aGlzLmRhdGEubWVtb3J5LnZhbHVlcy5pZHhcblxuICAgICAgICBzeW4uY3VycmVudFNhbXBsZSA9IHRoaXMuZmlsZW5hbWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW4ubG9hZFNhbXBsZSA9IGZ1bmN0aW9uKCBmaWxlbmFtZSwgX19vbmxvYWQsIGJ1ZmZlcj1udWxsICkge1xuICAgICAgJ3VzZSBqc2RzcCdcblxuICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyBmaWxlbmFtZSBdID0ge1xuICAgICAgICBkYXRhTGVuZ3RoOiBudWxsLFxuICAgICAgICBkYXRhSWR4OiBudWxsLFxuICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgIGZpbGVuYW1lXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9ubG9hZCA9IHN5bi5sb2FkQnVmZmVyLmJpbmQoIHNhbXBsZXIgKSBcbiAgICAgIC8vIHBhc3NpbmcgYSBmaWxlbmFtZSB0byBkYXRhIHdpbGwgY2F1c2UgaXQgdG8gYmUgbG9hZGVkIGluIHRoZSBtYWluIHRocmVhZFxuICAgICAgLy8gb25sb2FkIHdpbGwgdGhlbiBiZSBjYWxsZWQgdG8gcGFzcyB0aGUgYnVmZmVyIG92ZXIgdGhlIG1lc3NhZ2Vwb3J0LiBJbiB0aGVcbiAgICAgIC8vIHByb2Nlc3NvciB0aHJlYWQsIG1ha2UgYSBwbGFjZWhvbGRlciB1bnRpbCBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBzYW1wbGVyLmRhdGEgPSBnLmRhdGEoIGJ1ZmZlciAhPT0gbnVsbCA/IGJ1ZmZlciA6IGZpbGVuYW1lLCAxLCB7IG9ubG9hZCB9KVxuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBhIHByb21pc2UgaXMgcmV0dXJuZWQ7IGEgdmFsaWRcbiAgICAgICAgLy8gZGF0YSBvYmplY3QgaXMgb25seSByZXR1cm4gaWYgdGhlIGZpbGUgaGFzIGJlZW5cbiAgICAgICAgLy8gcHJldmlvdXNseSBsb2FkZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGJ1ZmZlciBoYXNcbiAgICAgICAgLy8gYmVlbiBjYWNoZWQuXG4gICAgICAgIGlmKCBzYW1wbGVyLmRhdGEgaW5zdGFuY2VvZiBQcm9taXNlICkge1xuICAgICAgICAgIHNhbXBsZXIuZGF0YS50aGVuKCBkID0+IHtcbiAgICAgICAgICAgIHNhbXBsZXIuZGF0YSA9IGRcbiAgICAgICAgICAgIG1lbW9bIGZpbGVuYW1lIF0gPSBzYW1wbGVyLmRhdGEgXG4gICAgICAgICAgICBvbmxvYWQoIHNhbXBsZXIsIF9fb25sb2FkIClcbiAgICAgICAgICB9KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyB1c2luZyBhIGNhY2hlZCBkYXRhIGJ1ZmZlciwgbm8gbmVlZFxuICAgICAgICAgIC8vIGZvciBhc3luY2hyb25vdXMgbG9hZGluZy5cbiAgICAgICAgICBtZW1vWyBmaWxlbmFtZSBdID0gc2FtcGxlclxuICAgICAgICAgIHNhbXBsZXIuZGF0YUxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgICBvbmxvYWQoIHNhbXBsZXIsIF9fb25sb2FkIClcbiAgICAgICAgfSAgICAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gbm90IHN1cmUgaWYgZmlyc3QgY2FzZSB3aWxsIGhhcHBlbiB3aXRoIHNvdW5kZm9udHMgKGl0IGRvZXMgd2l0aCByZWd1bGFyIG11bHRpc2FtcGxlcilcbiAgICAgICAgaWYoIGJ1ZmZlciA9PT0gbnVsbCApIHtcbiAgICAgICAgICBzYW1wbGVyLmRhdGEgPSBnLmRhdGEoIG5ldyBGbG9hdDMyQXJyYXkoKSwgMSwgeyBvbmxvYWQsIGZpbGVuYW1lIH0pXG4gICAgICAgICAgc2FtcGxlci5kYXRhLm9ubG9hZCA9IG9ubG9hZFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzYW1wbGVyLmRhdGEgPSBnLmRhdGEoIGJ1ZmZlciwgMSwgeyBvbmxvYWQsIGZpbGVuYW1lIH0pXG4gICAgICAgICAgLy9zYW1wbGVyLmRhdGEub25sb2FkID0gb25sb2FkXG4gICAgICAgICAgb25sb2FkKCBidWZmZXIsIF9fb25sb2FkIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2FtcGxlclxuICAgIH1cblxuICAgIHN5bi5sb2FkID0gZnVuY3Rpb24oIHNvdW5kTnVtYmVyPTAsIGJhbmtJbmRleD0wICkge1xuICAgICAgJ25vIGpzZHNwJ1xuXG4gICAgICAvLyBuZWVkIHRvIG1lbW9pemUuLi4gYWxyZWFkeSBzdG9yaW5nIGluIHNvdW5kZm9udHNcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSByZXR1cm5cblxuICAgICAgLy8gaW4gY2FzZSB1c2VycyBwYXNzIG5hbWUgb2Ygc291bmRmb250IGluc3RlYWQgb2YgbnVtYmVyXG4gICAgICBpZiggdHlwZW9mIHNvdW5kTnVtYmVyID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgbGV0IF9fc291bmROdW1iZXIgPSBTb3VuZGZvbnQubmFtZXMuaW5kZXhPZiggc291bmROdW1iZXIgKVxuICAgICAgICBpZiggX19zb3VuZE51bWJlciA9PT0gLTEgKSB7XG4gICAgICAgICAgX19zb3VuZE51bWJlciA9IDBcbiAgICAgICAgICBjb25zb2xlLndhcm4oIGBUaGUgJHtzb3VuZE51bWJlcn0gU291bmRmb250IGNhbid0IGJlIGZvdW5kLiBVc2luZyBQaWFubyBpbnN0ZWFkLmAgKVxuICAgICAgICB9XG4gICAgICAgIHNvdW5kTnVtYmVyID0gX19zb3VuZE51bWJlclxuICAgICAgfVxuXG4gICAgICBsZXQgbnVtID0gKHNvdW5kTnVtYmVyKSArICcwJ1xuICAgICAgaWYoIHNvdW5kTnVtYmVyIDwgMTAwICkgbnVtID0gJzAnK251bVxuICAgICAgaWYoIHNvdW5kTnVtYmVyIDwgMTAgKSAgbnVtID0gJzAnK251bVxuXG4gICAgICBmZXRjaCggYCR7U291bmRmb250LnJlc291cmNlUGF0aH0ke251bX1fJHtiYW5rc1tiYW5rSW5kZXhdfS5zZjIuanNvbmAgKVxuICAgICAgICAudGhlbiggcmVzID0+IHJlcy5qc29uKCkgKVxuICAgICAgICAudGhlbigganNvbiA9PiB7XG4gICAgICAgICAgY29uc3Qgem9uZXMgPSBzb3VuZGZvbnRzWyBzb3VuZE51bWJlciBdID0ganNvbi56b25lc1xuICAgICAgICAgIHRoaXMuem9uZXMgPSB6b25lc1xuICAgICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgem9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHpvbmUgPSB6b25lc1tpXVxuICAgICAgICAgICAgY29uc3QgYWIgPSBHaWJiZXJpc2gudXRpbGl0aWVzLmJhc2U2NC5kZWNvZGVBcnJheUJ1ZmZlciggem9uZS5maWxlIClcbiAgICAgICAgICAgIGcudXRpbGl0aWVzLmN0eC5kZWNvZGVBdWRpb0RhdGEoIGFiLCBidWZmZXIgPT4ge1xuICAgICAgICAgICAgICB6b25lLnNhbXBsZXIgPSBzeW4ubG9hZFNhbXBsZSggaSwgbnVsbCwgYnVmZmVyIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vcHJvcHMuZmlsZXMuZm9yRWFjaCggZmlsZW5hbWUgPT4gc3luLmxvYWRTYW1wbGUoIGZpbGVuYW1lICkgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgICd1c2UganNkc3AnXG4gICAgICBcbiAgICAgIGNvbnN0IGdyYXBocyA9IHZvaWNlcy5tYXAoIHZvaWNlID0+IHZvaWNlLmdyYXBoIClcbiAgICAgIGNvbnN0IGxlZnQgPSBnLmFkZCggLi4udm9pY2VzLm1hcCggdm9pY2UgPT4gdm9pY2UuZ3JhcGhbMF0gKSApXG4gICAgICBjb25zdCByaWdodCA9IGcuYWRkKCAuLi52b2ljZXMubWFwKCB2b2ljZSA9PiB2b2ljZS5ncmFwaFsxXSApIClcbiAgICAgIGNvbnN0IGdhaW4gPSBnLmluKCAnZ2FpbicgKVxuICAgICAgc3luLmdyYXBoID0gWyBsZWZ0ICogZ2FpbiwgcmlnaHQgKiBnYWluIF1cblxuICAgICAgaWYoIHN5bi5wYW5Wb2ljZXMgPT09IHRydWUgKSB7IFxuICAgICAgICBjb25zdCBwYW5uZXIgPSBnLnBhbiggc3luLmdyYXBoWzBdLCBzeW4uZ3JhcGhbMV0sIGcuaW4oICdwYW4nICkgKSBcbiAgICAgICAgc3luLmdyYXBoID0gWyBwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW4uX19jcmVhdGVHcmFwaCgpXG5cbiAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggXG4gICAgICBzeW4sXG4gICAgICBzeW4uZ3JhcGgsXG4gICAgICBbJ2luc3RydW1lbnRzJywnc291bmRmb250J10sIFxuICAgICAgcHJvcHMgXG4gICAgKSBcblxuICAgIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPSB0cnVlXG4gICAgR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IGZhbHNlXG5cbiAgICBvdXQudm9pY2VzID0gdm9pY2VzXG4gICAgb3V0LnNhbXBsZXJzID0gc2FtcGxlcnNcblxuICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0cnVlXG4gICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IGZhbHNlXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBTb3VuZGZvbnQuZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBwYW46IC41LFxuICAgIHJhdGU6IDEsXG4gICAgcGFuVm9pY2VzOmZhbHNlLFxuICAgIHNob3VsZExvb3A6ZmFsc2UsXG4gICAgbG9vcHM6IDAsXG4gICAgc3RhcnQ6MCxcbiAgICBlbmQ6MSxcbiAgICBidWZmZXJMZW5ndGg6LTk5OTk5OTk5OSxcbiAgICBsb3VkbmVzczoxLFxuICAgIG1heFZvaWNlczo1LCBcbiAgICBfX3RyaWdnZXJMb3VkbmVzczoxXG4gIH1cblxuICBTb3VuZGZvbnQucmVzb3VyY2VQYXRoID0gJ3Jlc291cmNlcy9zb3VuZGZvbnRzLydcbiAgU291bmRmb250Lm5hbWVzID0gW1xuICAgIFwiQWNvdXN0aWMgR3JhbmQgUGlhbm9cIixcbiAgICBcIkJyaWdodCBBY291c3RpYyBQaWFub1wiLFxuICAgIFwiRWxlY3RyaWMgR3JhbmQgUGlhbm9cIixcbiAgICBcIkhvbmt5LXRvbmsgUGlhbm9cIixcbiAgICBcIkVsZWN0cmljIFBpYW5vIDFcIixcbiAgICBcIkVsZWN0cmljIFBpYW5vIDJcIixcbiAgICBcIkhhcnBzaWNob3JkXCIsXG4gICAgXCJDbGF2aVwiLFxuICAgIFwiQ2VsZXN0YVwiLFxuICAgIFwiR2xvY2tlbnNwaWVsXCIsXG4gICAgXCJNdXNpYyBCb3hcIixcbiAgICBcIlZpYnJhcGhvbmVcIixcbiAgICBcIk1hcmltYmFcIixcbiAgICBcIlh5bG9waG9uZVwiLFxuICAgIFwiVHVidWxhciBCZWxsc1wiLFxuICAgIFwiRHVsY2ltZXJcIixcbiAgICBcIkRyYXdiYXIgT3JnYW5cIixcbiAgICBcIlBlcmN1c3NpdmUgT3JnYW5cIixcbiAgICBcIlJvY2sgT3JnYW5cIixcbiAgICBcIkNodXJjaCBPcmdhblwiLFxuICAgIFwiUmVlZCBPcmdhblwiLFxuICAgIFwiQWNjb3JkaW9uXCIsXG4gICAgXCJIYXJtb25pY2FcIixcbiAgICBcIlRhbmdvIEFjY29yZGlvblwiLFxuICAgIFwiQWNvdXN0aWMgR3VpdGFyIChueWxvbilcIixcbiAgICBcIkFjb3VzdGljIEd1aXRhciAoc3RlZWwpXCIsXG4gICAgXCJFbGVjdHJpYyBHdWl0YXIgKGphenopXCIsXG4gICAgXCJFbGVjdHJpYyBHdWl0YXIgKGNsZWFuKVwiLFxuICAgIFwiRWxlY3RyaWMgR3VpdGFyIChtdXRlZClcIixcbiAgICBcIk92ZXJkcml2ZW4gR3VpdGFyXCIsXG4gICAgXCJEaXN0b3J0aW9uIEd1aXRhclwiLFxuICAgIFwiR3VpdGFyIGhhcm1vbmljc1wiLFxuICAgIFwiQWNvdXN0aWMgQmFzc1wiLFxuICAgIFwiRWxlY3RyaWMgQmFzcyAoZmluZ2VyKVwiLFxuICAgIFwiRWxlY3RyaWMgQmFzcyAocGljaylcIixcbiAgICBcIkZyZXRsZXNzIEJhc3NcIixcbiAgICBcIlNsYXAgQmFzcyAxXCIsXG4gICAgXCJTbGFwIEJhc3MgMlwiLFxuICAgIFwiU3ludGggQmFzcyAxXCIsXG4gICAgXCJTeW50aCBCYXNzIDJcIixcbiAgICBcIlZpb2xpblwiLFxuICAgIFwiVmlvbGFcIixcbiAgICBcIkNlbGxvXCIsXG4gICAgXCJDb250cmFiYXNzXCIsXG4gICAgXCJUcmVtb2xvIFN0cmluZ3NcIixcbiAgICBcIlBpenppY2F0byBTdHJpbmdzXCIsXG4gICAgXCJPcmNoZXN0cmFsIEhhcnBcIixcbiAgICBcIlRpbXBhbmlcIixcbiAgICBcIlN0cmluZyBFbnNlbWJsZSAxXCIsXG4gICAgXCJTdHJpbmcgRW5zZW1ibGUgMlwiLFxuICAgIFwiU3ludGhTdHJpbmdzIDFcIixcbiAgICBcIlN5bnRoU3RyaW5ncyAyXCIsXG4gICAgXCJDaG9pciBBYWhzXCIsXG4gICAgXCJWb2ljZSBPb2hzXCIsXG4gICAgXCJTeW50aCBWb2ljZVwiLFxuICAgIFwiT3JjaGVzdHJhIEhpdFwiLFxuICAgIFwiVHJ1bXBldFwiLFxuICAgIFwiVHJvbWJvbmVcIixcbiAgICBcIlR1YmFcIixcbiAgICBcIk11dGVkIFRydW1wZXRcIixcbiAgICBcIkZyZW5jaCBIb3JuXCIsXG4gICAgXCJCcmFzcyBTZWN0aW9uXCIsXG4gICAgXCJTeW50aEJyYXNzIDFcIixcbiAgICBcIlN5bnRoQnJhc3MgMlwiLFxuICAgIFwiU29wcmFubyBTYXhcIixcbiAgICBcIkFsdG8gU2F4XCIsXG4gICAgXCJUZW5vciBTYXhcIixcbiAgICBcIkJhcml0b25lIFNheFwiLFxuICAgIFwiT2JvZVwiLFxuICAgIFwiRW5nbGlzaCBIb3JuXCIsXG4gICAgXCJCYXNzb29uXCIsXG4gICAgXCJDbGFyaW5ldFwiLFxuICAgIFwiUGljY29sb1wiLFxuICAgIFwiRmx1dGVcIixcbiAgICBcIlJlY29yZGVyXCIsXG4gICAgXCJQYW4gRmx1dGVcIixcbiAgICBcIkJsb3duIEJvdHRsZVwiLFxuICAgIFwiU2hha3VoYWNoaVwiLFxuICAgIFwiV2hpc3RsZVwiLFxuICAgIFwiT2NhcmluYVwiLFxuICAgIFwiTGVhZCAxIChzcXVhcmUpXCIsXG4gICAgXCJMZWFkIDIgKHNhd3Rvb3RoKVwiLFxuICAgIFwiTGVhZCAzIChjYWxsaW9wZSlcIixcbiAgICBcIkxlYWQgNCAoY2hpZmYpXCIsXG4gICAgXCJMZWFkIDUgKGNoYXJhbmcpXCIsXG4gICAgXCJMZWFkIDYgKHZvaWNlKVwiLFxuICAgIFwiTGVhZCA3IChmaWZ0aHMpXCIsXG4gICAgXCJMZWFkIDggKGJhc3MgKyBsZWFkKVwiLFxuICAgIFwiUGFkIDEgKG5ldyBhZ2UpXCIsXG4gICAgXCJQYWQgMiAod2FybSlcIixcbiAgICBcIlBhZCAzIChwb2x5c3ludGgpXCIsXG4gICAgXCJQYWQgNCAoY2hvaXIpXCIsXG4gICAgXCJQYWQgNSAoYm93ZWQpXCIsXG4gICAgXCJQYWQgNiAobWV0YWxsaWMpXCIsXG4gICAgXCJQYWQgNyAoaGFsbylcIixcbiAgICBcIlBhZCA4IChzd2VlcClcIixcbiAgICBcIkZYIDEgKHJhaW4pXCIsXG4gICAgXCJGWCAyIChzb3VuZHRyYWNrKVwiLFxuICAgIFwiRlggMyAoY3J5c3RhbClcIixcbiAgICBcIkZYIDQgKGF0bW9zcGhlcmUpXCIsXG4gICAgXCJGWCA1IChicmlnaHRuZXNzKVwiLFxuICAgIFwiRlggNiAoZ29ibGlucylcIixcbiAgICBcIkZYIDcgKGVjaG9lcylcIixcbiAgICBcIkZYIDggKHNjaS1maSlcIixcbiAgICBcIlNpdGFyXCIsXG4gICAgXCJCYW5qb1wiLFxuICAgIFwiU2hhbWlzZW5cIixcbiAgICBcIktvdG9cIixcbiAgICBcIkthbGltYmFcIixcbiAgICBcIkJhZyBwaXBlXCIsXG4gICAgXCJGaWRkbGVcIixcbiAgICBcIlNoYW5haVwiLFxuICAgIFwiVGlua2xlIEJlbGxcIixcbiAgICBcIkFnb2dvXCIsXG4gICAgXCJTdGVlbCBEcnVtc1wiLFxuICAgIFwiV29vZGJsb2NrXCIsXG4gICAgXCJUYWlrbyBEcnVtXCIsXG4gICAgXCJNZWxvZGljIFRvbVwiLFxuICAgIFwiU3ludGggRHJ1bVwiLFxuICAgIFwiUmV2ZXJzZSBDeW1iYWxcIixcbiAgICBcIkd1aXRhciBGcmV0IE5vaXNlXCIsXG4gICAgXCJCcmVhdGggTm9pc2VcIixcbiAgICBcIlNlYXNob3JlXCIsXG4gICAgXCJCaXJkIFR3ZWV0XCIsXG4gICAgXCJUZWxlcGhvbmUgUmluZ1wiLFxuICAgIFwiSGVsaWNvcHRlclwiLFxuICAgIFwiQXBwbGF1c2VcIixcbiAgICBcIkd1bnNob3RcIlxuICBdXG5cbiAgU291bmRmb250Lmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLnRhYmxlKCBTb3VuZGZvbnQubmFtZXMgKVxuICB9XG5cbiAgcmV0dXJuIFNvdW5kZm9udFxufVxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBpbnN0cnVtZW50ID0gcmVxdWlyZSggJy4vaW5zdHJ1bWVudC5qcycgKVxuXG5jb25zdCBnZW5pc2ggPSBnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBTeW50aCA9IGlucHV0UHJvcHMgPT4ge1xuICAgIGNvbnN0IHN5biA9IE9iamVjdC5jcmVhdGUoIGluc3RydW1lbnQgKVxuXG4gICAgY29uc3QgZnJlcXVlbmN5ID0gZy5pbiggJ2ZyZXF1ZW5jeScgKSxcbiAgICAgICAgICBsb3VkbmVzcyAgPSBnLmluKCAnbG91ZG5lc3MnICksIFxuICAgICAgICAgIHRyaWdnZXJMb3VkbmVzcyA9IGcuaW4oICdfX3RyaWdnZXJMb3VkbmVzcycgKSxcbiAgICAgICAgICBnbGlkZSA9IGcubWF4KCAxLCBnLmluKCAnZ2xpZGUnICkgKSxcbiAgICAgICAgICBzbGlkaW5nRnJlcSA9IGcuc2xpZGUoIGZyZXF1ZW5jeSwgZ2xpZGUsIGdsaWRlICksXG4gICAgICAgICAgYXR0YWNrID0gZy5pbiggJ2F0dGFjaycgKSwgZGVjYXkgPSBnLmluKCAnZGVjYXknICksXG4gICAgICAgICAgc3VzdGFpbiA9IGcuaW4oICdzdXN0YWluJyApLCBzdXN0YWluTGV2ZWwgPSBnLmluKCAnc3VzdGFpbkxldmVsJyApLFxuICAgICAgICAgIHJlbGVhc2UgPSBnLmluKCAncmVsZWFzZScgKVxuXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgU3ludGguZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHN5biwgcHJvcHMgKVxuXG4gICAgc3luLl9fY3JlYXRlR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG9zYyA9IEdpYmJlcmlzaC5vc2NpbGxhdG9ycy5mYWN0b3J5KCBzeW4ud2F2ZWZvcm0sIHNsaWRpbmdGcmVxLCBzeW4uYW50aWFsaWFzIClcblxuICAgICAgY29uc3QgZW52ID0gR2liYmVyaXNoLmVudmVsb3Blcy5mYWN0b3J5KCBcbiAgICAgICAgcHJvcHMudXNlQURTUiwgXG4gICAgICAgIHByb3BzLnNoYXBlLCBcbiAgICAgICAgYXR0YWNrLCBkZWNheSwgXG4gICAgICAgIHN1c3RhaW4sIHN1c3RhaW5MZXZlbCwgXG4gICAgICAgIHJlbGVhc2UsIFxuICAgICAgICBwcm9wcy50cmlnZ2VyUmVsZWFzZVxuICAgICAgKVxuXG5cbiAgICAgIC8vIHN5bi5lbnYgPSBlbnZcbiAgICAgIC8vIGJlbG93IGRvZXNuJ3Qgd29yayBhcyBpdCBhdHRlbXB0cyB0byBhc3NpZ24gdG8gcmVsZWFzZSBwcm9wZXJ0eSB0cmlnZ2VyaW5nIGNvZGVnZW4uLi5cbiAgICAgIHN5bi5hZHZhbmNlID0gKCk9PiB7IGVudi5yZWxlYXNlKCkgfVxuXG4gICAgICB7XG4gICAgICAgICd1c2UganNkc3AnXG4gICAgICAgIGxldCBvc2NXaXRoRW52ID0gb3NjICogZW52ICogbG91ZG5lc3MgKiB0cmlnZ2VyTG91ZG5lc3MsXG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gZy5pbignc2F0dXJhdGlvbicpLFxuICAgICAgICAgICAgcGFubmVyXG5cbiAgICAgICAgLy8gMTYgaXMgYW4gdW5mb3J0dW5hdGUgZW1waXJpY2FsbHkgZGVyaXZlZCBtYWdpYyBudW1iZXIuLi5cbiAgICAgICAgY29uc3QgYmFzZUN1dG9mZkZyZXEgPSBnLmluKCdjdXRvZmYnKSAqICggZnJlcXVlbmN5IC8gICggZy5nZW4uc2FtcGxlcmF0ZSAvIDE2ICkgKSBcbiAgICAgICAgY29uc3QgY3V0b2ZmID0gZy5taW4oIGJhc2VDdXRvZmZGcmVxICogZy5wb3coIDIsIGcuaW4oJ2ZpbHRlck11bHQnKSAqIGxvdWRuZXNzICogdHJpZ2dlckxvdWRuZXNzICkgKiBlbnYsIC45OTUgKSBcbiAgICAgICAgY29uc3QgZmlsdGVyZWRPc2MgPSBHaWJiZXJpc2guZmlsdGVycy5mYWN0b3J5KCBvc2NXaXRoRW52LCBjdXRvZmYsIHNhdHVyYXRpb24sIHByb3BzIClcblxuICAgICAgICBsZXQgc3ludGhXaXRoR2FpbiA9IGZpbHRlcmVkT3NjICogZy5pbiggJ2dhaW4nIClcbiAgICAgICAgXG4gICAgICAgIC8vIFhYWCBUaGlzIGxpbmUgaGFzIHRvIGJlIGhlcmUgZm9yIGNvcnJlY3QgY29kZSBnZW5lcmF0aW9uIHRvIHdvcmsgd2hlblxuICAgICAgICAvLyBzYXR1cmF0aW9uIGlzIG5vdCBiZWluZyB1c2VkLi4uIG9idmlvdXNseSB0aGlzIHNob3VsZCBjYW5jZWwgb3V0LiBcbiAgICAgICAgaWYoIHN5bi5maWx0ZXJNb2RlbCAhPT0gMiApIHN5bnRoV2l0aEdhaW4gPSBzeW50aFdpdGhHYWluICsgc2F0dXJhdGlvbiAtIHNhdHVyYXRpb25cbiAgICBcbiAgICAgICAgaWYoIHN5bi5wYW5Wb2ljZXMgPT09IHRydWUgKSB7IFxuICAgICAgICAgIHBhbm5lciA9IGcucGFuKCBzeW50aFdpdGhHYWluLCBzeW50aFdpdGhHYWluLCBnLmluKCAncGFuJyApICkgXG4gICAgICAgICAgc3luLmdyYXBoID0gWyBwYW5uZXIubGVmdCwgcGFubmVyLnJpZ2h0IF1cbiAgICAgICAgICBzeW4uaXNTdGVyZW8gPSB0cnVlXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHN5bi5ncmFwaCA9IHN5bnRoV2l0aEdhaW5cbiAgICAgICAgICBzeW4uaXNTdGVyZW8gPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgc3luLmVudiA9IGVudlxuICAgICAgICBzeW4ub3NjID0gb3NjXG4gICAgICAgIHN5bi5maWx0ZXIgPSBmaWx0ZXJlZE9zY1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW52XG5cbiAgICB9XG4gICAgXG4gICAgc3luLl9fcmVxdWlyZXNSZWNvbXBpbGF0aW9uID0gWyAnd2F2ZWZvcm0nLCAnYW50aWFsaWFzJywgJ2ZpbHRlck1vZGVsJywnZmlsdGVyTW9kZScsICd1c2VBRFNSJywgJ3NoYXBlJyBdXG4gICAgY29uc3QgZW52ID0gc3luLl9fY3JlYXRlR3JhcGgoKVxuXG4gICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHN5biwgc3luLmdyYXBoLCBbJ2luc3RydW1lbnRzJywgJ3N5bnRoJ10sIHByb3BzLCBudWxsLCB0cnVlLCBbJ3NhdHVyYXRpb24nXSAgKVxuXG4gICAgb3V0LmVudi5hZHZhbmNlID0gb3V0LmFkdmFuY2UgXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgXG4gIFN5bnRoLmRlZmF1bHRzID0ge1xuICAgIHdhdmVmb3JtOidzYXcnLFxuICAgIGF0dGFjazogNDQsXG4gICAgZGVjYXk6IDIyMDUwLFxuICAgIHN1c3RhaW46NDQxMDAsXG4gICAgc3VzdGFpbkxldmVsOi42LFxuICAgIHJlbGVhc2U6MjIwNTAsXG4gICAgdXNlQURTUjpmYWxzZSxcbiAgICBzaGFwZTonbGluZWFyJyxcbiAgICB0cmlnZ2VyUmVsZWFzZTpmYWxzZSxcbiAgICBnYWluOiAuNSxcbiAgICBwdWxzZXdpZHRoOi4yNSxcbiAgICBmcmVxdWVuY3k6MjIwLFxuICAgIHBhbjogLjUsXG4gICAgYW50aWFsaWFzOmZhbHNlLFxuICAgIHBhblZvaWNlczpmYWxzZSxcbiAgICBsb3VkbmVzczoxLFxuICAgIF9fdHJpZ2dlckxvdWRuZXNzOjEsXG4gICAgZ2xpZGU6MSxcbiAgICBzYXR1cmF0aW9uOjEsXG4gICAgZmlsdGVyTXVsdDoyLFxuICAgIFE6LjI1LFxuICAgIGN1dG9mZjouNSxcbiAgICBmaWx0ZXJNb2RlbDoxLFxuICAgIGZpbHRlck1vZGU6MFxuICB9XG5cbiAgLy8gZG8gbm90IGluY2x1ZGUgdmVsb2NpdHksIHdoaWNoIHNob3VkbCBhbHdheXMgYmUgcGVyIHZvaWNlXG4gIGxldCBQb2x5U3ludGggPSBHaWJiZXJpc2guUG9seVRlbXBsYXRlKCBTeW50aCwgWydmcmVxdWVuY3knLCdhdHRhY2snLCdkZWNheScsJ3B1bHNld2lkdGgnLCdwYW4nLCdnYWluJywnZ2xpZGUnLCAnc2F0dXJhdGlvbicsICdmaWx0ZXJNdWx0JywgJ1EnLCAnY3V0b2ZmJywgJ3Jlc29uYW5jZScsICdhbnRpYWxpYXMnLCAnZmlsdGVyTW9kZWwnLCAnd2F2ZWZvcm0nLCAnZmlsdGVyTW9kZScsICdfX3RyaWdnZXJMb3VkbmVzcycsICdsb3VkbmVzcyddICkgXG4gIFBvbHlTeW50aC5kZWZhdWx0cyA9IFN5bnRoLmRlZmF1bHRzXG5cbiAgcmV0dXJuIFsgU3ludGgsIFBvbHlTeW50aCBdXG5cbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgaW5zdHJ1bWVudCA9IHJlcXVpcmUoICcuL2luc3RydW1lbnQuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IFRvbSA9IGFyZ3VtZW50UHJvcHMgPT4ge1xuICAgIGxldCB0b20gPSBPYmplY3QuY3JlYXRlKCBpbnN0cnVtZW50IClcbiAgICBcbiAgICBjb25zdCBkZWNheSAgID0gZy5pbiggJ2RlY2F5JyApLFxuICAgICAgICAgIHBpdGNoICAgPSBnLmluKCAnZnJlcXVlbmN5JyApLFxuICAgICAgICAgIGdhaW4gICAgPSBnLmluKCAnZ2FpbicgKSxcbiAgICAgICAgICBsb3VkbmVzcyA9IGcuaW4oICdsb3VkbmVzcycgKSxcbiAgICAgICAgICB0cmlnZ2VyTG91ZG5lc3MgPSBnLmluKCAnX190cmlnZ2VyTG91ZG5lc3MnIClcblxuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbigge30sIFRvbS5kZWZhdWx0cywgYXJndW1lbnRQcm9wcyApXG5cbiAgICBjb25zdCB0cmlnZ2VyID0gZy5iYW5nKCksXG4gICAgICAgICAgaW1wdWxzZSA9IGcubXVsKCB0cmlnZ2VyLCAxICksXG4gICAgICAgICAgZWcgPSBnLmRlY2F5KCBnLm11bCggZGVjYXksIGcuZ2VuLnNhbXBsZXJhdGUgKiAyICksIHsgaW5pdFZhbHVlOjAgfSApLCBcbiAgICAgICAgICBicGYgPSBnLm11bCggZy5zdmYoIGltcHVsc2UsIHBpdGNoLCAuMDE3NSwgMiwgZmFsc2UgKSwgMTAgKSxcbiAgICAgICAgICBub2lzZSA9IGcuZ3RwKCBnLm5vaXNlKCksIDAgKSwgLy8gcmVjdGlmeSBub2lzZVxuICAgICAgICAgIGVudmVsb3BlZE5vaXNlID0gZy5tdWwoIG5vaXNlLCBlZyApLFxuICAgICAgICAgIGxwZiA9IGcubXVsKCBnLnN2ZiggZW52ZWxvcGVkTm9pc2UsIDEyMCwgLjUsIDAsIGZhbHNlICksIDIuNSApLFxuICAgICAgICAgIG91dCA9IGcubXVsKCBnLmFkZCggYnBmLCBscGYgKSwgZy5tdWwoIGdhaW4sIGcubXVsKCBsb3VkbmVzcywgdHJpZ2dlckxvdWRuZXNzICkgKSApXG5cbiAgICB0b20uZW52ID0ge1xuICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGVnLnRyaWdnZXIoKVxuICAgICAgICB0cmlnZ2VyLnRyaWdnZXIoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRvbS5pc1N0ZXJlbyA9IGZhbHNlXG5cbiAgICB0b20gPSBHaWJiZXJpc2guZmFjdG9yeSggdG9tLCBvdXQsIFsnaW5zdHJ1bWVudHMnLCAndG9tJ10sIHByb3BzICApXG4gICAgXG4gICAgcmV0dXJuIHRvbVxuICB9XG4gIFxuICBUb20uZGVmYXVsdHMgPSB7XG4gICAgZ2FpbjogMSxcbiAgICBkZWNheTouNyxcbiAgICBmcmVxdWVuY3k6MTIwLFxuICAgIGxvdWRuZXNzOjEsXG4gICAgX190cmlnZ2VyTG91ZG5lc3M6MVxuICB9XG5cbiAgcmV0dXJuIFRvbVxufVxuIiwiY29uc3QgdWdlbnByb3RvID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKSxcbiAgICAgX19wcm94eSAgICAgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApLFxuICAgICBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIGNvbnN0IHByb3h5ID0gX19wcm94eSggR2liYmVyaXNoIClcblxuICBjb25zdCBjcmVhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHAsIGlkICkge1xuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgMjsgaSsrICkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwLCBpLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICBnZXQoKSB7IHJldHVybiBwLmlucHV0c1sgaSBdIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgcC5pbnB1dHNbIGkgXSA9IHZcbiAgICAgICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgICAgICBhZGRyZXNzOidhZGRUb1Byb3BlcnR5JywgXG4gICAgICAgICAgICAgICAgb2JqZWN0OmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6J2lucHV0cycsXG4gICAgICAgICAgICAgICAga2V5OmksXG4gICAgICAgICAgICAgICAgdmFsdWU6dlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgICAgICBhZGRyZXNzOidhZGRPYmplY3RUb1Byb3BlcnR5JywgXG4gICAgICAgICAgICAgICAgb2JqZWN0OmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6J2lucHV0cycsXG4gICAgICAgICAgICAgICAga2V5OmksXG4gICAgICAgICAgICAgICAgdmFsdWU6di5pZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGFkZHJlc3M6J2RpcnR5JyxcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IEJpbm9wcyA9IHtcbiAgICBleHBvcnQoIG9iaiApIHtcbiAgICAgIGZvciggbGV0IGtleSBpbiBCaW5vcHMgKSB7XG4gICAgICAgIGlmKCBrZXkgIT09ICdleHBvcnQnICkge1xuICAgICAgICAgIG9ialsga2V5IF0gPSBCaW5vcHNbIGtleSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIEFkZCggLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IGlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcbiAgICAgIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCB1Z2VucHJvdG8gKVxuICAgICAgY29uc3QgaXNTdGVyZW8gPSBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1swXSApIHx8IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzFdIClcbiAgICAgIE9iamVjdC5hc3NpZ24oIHVnZW4sIHsgaXNvcDp0cnVlLCBvcDonKycsIGlucHV0czphcmdzLCB1Z2VuTmFtZTonYWRkJyArIGlkLCBpZCwgaXNTdGVyZW8gfSApXG4gICAgICBcbiAgICAgIGNvbnN0IHAgPSBwcm94eSggWydiaW5vcHMnLCdBZGQnXSwgeyBpc29wOnRydWUsIGlucHV0czphcmdzIH0sIHVnZW4gKVxuICAgICAgY3JlYXRlUHJvcGVydGllcyggcCwgaWQgKVxuXG4gICAgICByZXR1cm4gcFxuICAgIH0sXG5cbiAgICBTdWIoIC4uLmFyZ3MgKSB7XG4gICAgICBjb25zdCBpZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG4gICAgICBjb25zdCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggdWdlbnByb3RvIClcbiAgICAgIGNvbnN0IGlzU3RlcmVvID0gR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMF0gKSB8fCBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1sxXSApXG4gICAgICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IGlzb3A6dHJ1ZSwgb3A6Jy0nLCBpbnB1dHM6YXJncywgdWdlbk5hbWU6J3N1YicgKyBpZCwgaWQsIGlzU3RlcmVvIH0gKVxuXG4gICAgICByZXR1cm4gcHJveHkoIFsnYmlub3BzJywnU3ViJ10sIHsgaXNvcDp0cnVlLCBpbnB1dHM6YXJncyB9LCB1Z2VuIClcbiAgICB9LFxuXG4gICAgTXVsKCAuLi5hcmdzICkge1xuICAgICAgY29uc3QgaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuICAgICAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHVnZW5wcm90byApXG4gICAgICBjb25zdCBpc1N0ZXJlbyA9IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzBdICkgfHwgR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMV0gKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBpc29wOnRydWUsIG9wOicqJywgaW5wdXRzOmFyZ3MsIHVnZW5OYW1lOidtdWwnICsgaWQsIGlkLCBpc1N0ZXJlbyB9IClcblxuICAgICAgY29uc3QgcCA9IHByb3h5KCBbJ2Jpbm9wcycsJ011bCddLCB7IGlzb3A6dHJ1ZSwgaW5wdXRzOmFyZ3MgfSwgdWdlbiApXG4gICAgICBjcmVhdGVQcm9wZXJ0aWVzKCBwLCBpZCApXG4gICAgICByZXR1cm4gcFxuICAgIH0sXG5cbiAgICBEaXYoIC4uLmFyZ3MgKSB7XG4gICAgICBjb25zdCBpZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG4gICAgICBjb25zdCB1Z2VuID0gT2JqZWN0LmNyZWF0ZSggdWdlbnByb3RvIClcbiAgICAgIGNvbnN0IGlzU3RlcmVvID0gR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMF0gKSB8fCBHaWJiZXJpc2guX19pc1N0ZXJlbyggYXJnc1sxXSApXG4gICAgICBPYmplY3QuYXNzaWduKCB1Z2VuLCB7IGlzb3A6dHJ1ZSwgb3A6Jy8nLCBpbnB1dHM6YXJncywgdWdlbk5hbWU6J2RpdicgKyBpZCwgaWQsIGlzU3RlcmVvfSApXG4gICAgXG4gICAgICBjb25zdCBwID0gcHJveHkoIFsnYmlub3BzJywnRGl2J10sIHsgaXNvcDp0cnVlLCBpbnB1dHM6YXJncyB9LCB1Z2VuIClcbiAgICAgIGNyZWF0ZVByb3BlcnRpZXMoIHAsIGlkIClcblxuICAgICAgcmV0dXJuIHBcbiAgICB9LFxuXG4gICAgTW9kKCAuLi5hcmdzICkge1xuICAgICAgY29uc3QgaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuICAgICAgY29uc3QgdWdlbiA9IE9iamVjdC5jcmVhdGUoIHVnZW5wcm90byApXG4gICAgICBjb25zdCBpc1N0ZXJlbyA9IEdpYmJlcmlzaC5fX2lzU3RlcmVvKCBhcmdzWzBdICkgfHwgR2liYmVyaXNoLl9faXNTdGVyZW8oIGFyZ3NbMV0gKVxuICAgICAgT2JqZWN0LmFzc2lnbiggdWdlbiwgeyBpc29wOnRydWUsIG9wOiclJywgaW5wdXRzOmFyZ3MsIHVnZW5OYW1lOidtb2QnICsgaWQsIGlkLCBpc1N0ZXJlb30gKVxuXG4gICAgICBjb25zdCBwID0gcHJveHkoIFsnYmlub3BzJywnTW9kJ10sIHsgaXNvcDp0cnVlLCBpbnB1dHM6YXJncyB9LCB1Z2VuIClcbiAgICAgIGNyZWF0ZVByb3BlcnRpZXMoIHAsIGlkIClcblxuICAgICAgcmV0dXJuIHBcbiAgICB9LCAgIFxuICB9XG5cbiAgZm9yKCBsZXQga2V5IGluIEJpbm9wcyApIHtcbiAgICBCaW5vcHNbIGtleSBdLmRlZmF1bHRzID0geyAwOjAsIDE6MCB9XG4gIH1cblxuICByZXR1cm4gQmlub3BzXG59XG4iLCJsZXQgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKCksXG4gICAgX19wcm94eT0gcmVxdWlyZSggJy4uL3dvcmtsZXRQcm94eS5qcycgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG4gIGNvbnN0IHByb3h5ID0gX19wcm94eSggR2liYmVyaXNoIClcbiAgY29uc3QgQnVzID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG5cbiAgT2JqZWN0LmFzc2lnbiggQnVzLCB7XG4gICAgZ2Fpbjoge1xuICAgICAgc2V0KCB2ICkge1xuICAgICAgICB0aGlzLm11bC5pbnB1dHNbIDEgXSA9IHZcbiAgICAgICAgR2liYmVyaXNoLmRpcnR5KCB0aGlzIClcbiAgICAgIH0sXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bFsgMSBdXG4gICAgICB9XG4gICAgfSxcblxuICAgIF9fYWRkSW5wdXQoIGlucHV0ICkge1xuICAgICAgdGhpcy5zdW0uaW5wdXRzLnB1c2goIGlucHV0IClcbiAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGhpcyApXG4gICAgfSxcblxuICAgIGNyZWF0ZSggX3Byb3BzICkge1xuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBCdXMuZGVmYXVsdHMsIHsgaW5wdXRzOlswXSB9LCBfcHJvcHMgKVxuXG4gICAgICAvLyBNVVNUIFBSRVZFTlQgUFJPWFlcbiAgICAgIC8vIE90aGhlcndpc2UgdGhlc2UgYmlub3BzIGFyZSBjcmVhdGVkIGluIHRoZSB3b3JrbGV0IGFuZCBzZW50XG4gICAgICAvLyBhY3Jvc3MgdGhlIHRocmVhZCB0byBiZSBpbnN0YW50aWF0ZWQsIGFuZCB0aGVuIGluc3RhbnRpYXRlZCBhZ2FpblxuICAgICAgLy8gd2hlbiB0aGUgYnVzIGlzIGNyZWF0ZWQgaW4gdGhlIHByb2Nlc3NvciB0aHJlYWQsIG1lc3NpbmcgdXAgdGhlIHZhcmlvdXNcbiAgICAgIC8vIHVpZHMgaW52b2x2ZWQuIEJ5IHByZXZlbnRpbmcgcHJveHlpbmcgdGhlIGJpbm9wcyBhcmUgb25seSBjcmVhdGVkXG4gICAgICAvLyBhIHNpbmdsZSB0aW1lIHdoZW4gdGhlIGJ1cyBpcyBzZW50IGFjcm9zcyB0aGUgdGhyZWFkLlxuICAgICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IHRydWVcbiAgICAgIGNvbnN0IHN1bSA9IEdpYmJlcmlzaC5iaW5vcHMuQWRkKCAuLi5wcm9wcy5pbnB1dHMgKVxuICAgICAgY29uc3QgbXVsID0gR2liYmVyaXNoLmJpbm9wcy5NdWwoIHN1bSwgcHJvcHMuZ2FpbiApXG4gICAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gZmFsc2VcblxuICAgICAgY29uc3QgZ3JhcGggPSBHaWJiZXJpc2guUGFubmVyKHsgaW5wdXQ6bXVsLCBwYW46IHByb3BzLnBhbiB9KVxuXG4gICAgICBncmFwaC5zdW0gPSBzdW1cbiAgICAgIGdyYXBoLm11bCA9IG11bFxuICAgICAgZ3JhcGguZGlzY29ubmVjdFVnZW4gPSBCdXMuZGlzY29ubmVjdFVnZW5cblxuICAgICAgZ3JhcGguX19wcm9wZXJ0aWVzX18gPSBwcm9wc1xuXG4gICAgICBjb25zdCBvdXQgPSBwcm9wcy5fX3VzZVByb3h5X18gPT09IHRydWUgPyBwcm94eSggWydCdXMnXSwgcHJvcHMsIGdyYXBoICkgOiBncmFwaFxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG91dCwgJ2dhaW4nLCBCdXMuZ2FpbiApXG5cbiAgICAgIGlmKCBmYWxzZSAmJiBHaWJiZXJpc2gucHJldmVudFByb3h5ID09PSBmYWxzZSAmJiBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgIGFkZHJlc3M6J2FkZCcsXG4gICAgICAgICAgbmFtZTpbJ0J1cyddLFxuICAgICAgICAgIHByb3BzLCBcbiAgICAgICAgICBpZDpncmFwaC5pZFxuICAgICAgICB9XG4gICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoIG1ldGEgKVxuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgYWRkcmVzczonbWV0aG9kJywgXG4gICAgICAgICAgb2JqZWN0OmdyYXBoLmlkLFxuICAgICAgICAgIG5hbWU6J2Nvbm5lY3QnLFxuICAgICAgICAgIGFyZ3M6W11cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dCBcbiAgICB9LFxuXG4gICAgZGlzY29ubmVjdFVnZW4oIHVnZW4gKSB7XG4gICAgICBsZXQgcmVtb3ZlSWR4ID0gdGhpcy5zdW0uaW5wdXRzLmluZGV4T2YoIHVnZW4gKVxuXG4gICAgICBpZiggcmVtb3ZlSWR4ICE9PSAtMSApIHtcbiAgICAgICAgdGhpcy5zdW0uaW5wdXRzLnNwbGljZSggcmVtb3ZlSWR4LCAxIClcbiAgICAgICAgR2liYmVyaXNoLmRpcnR5KCB0aGlzIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gY2FuJ3QgaW5jbHVkZSBpbnB1dHMgaGVyZSBhcyBpdCB3aWxsIGJlIHN1Y2tlZCB1cCBieSBHaWJiZXIsXG4gICAgLy8gaW5zdGVhZCBwYXNzIGR1cmluZyBPYmplY3QuYXNzaWduKCkgYWZ0ZXIgZGVmYXVsdHMuXG4gICAgZGVmYXVsdHM6IHsgZ2FpbjoxLCBwYW46LjUsIF9fdXNlUHJveHlfXzp0cnVlIH1cbiAgfSlcblxuICBjb25zdCBjb25zdHJ1Y3RvciA9IEJ1cy5jcmVhdGUuYmluZCggQnVzIClcbiAgY29uc3RydWN0b3IuZGVmYXVsdHMgPSBCdXMuZGVmYXVsdHNcblxuICByZXR1cm4gY29uc3RydWN0b3Jcbn1cblxuIiwiY29uc3QgZyA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICB1Z2VuID0gcmVxdWlyZSggJy4uL3VnZW4uanMnICkoKSxcbiAgICAgIF9fcHJveHkgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBCdXMyID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApXG4gIGNvbnN0IHByb3h5ID0gX19wcm94eSggR2liYmVyaXNoIClcblxuICBsZXQgYnVmZmVyTCwgYnVmZmVyUlxuICBcbiAgT2JqZWN0LmFzc2lnbiggQnVzMiwgeyBcbiAgICBjcmVhdGUoIF9fcHJvcHMgKSB7XG5cbiAgICAgIGlmKCBidWZmZXJMID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNvbnN0IHAgPSBnLnBhbigpXG4gICAgICAgIFxuICAgICAgICAvLyBjb3B5IG1lbW9yeS4uLiBvdGhlcndpc2UgdGhlIHdhdmV0YWJsZXMgZG9uJ3QgaGF2ZSBtZW1vcnkgaW5kaWNlcy5cbiAgICAgICAgYnVmZmVyTCA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoMTAyNClcbiAgICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwLnNldCggR2liYmVyaXNoLmdlbmlzaC5nZW4uZ2xvYmFscy5wYW5MLmJ1ZmZlciwgYnVmZmVyTCApXG5cbiAgICAgICAgYnVmZmVyUiA9IEdpYmJlcmlzaC5tZW1vcnkuYWxsb2MoMTAyNClcbiAgICAgICAgR2liYmVyaXNoLm1lbW9yeS5oZWFwLnNldCggR2liYmVyaXNoLmdlbmlzaC5nZW4uZ2xvYmFscy5wYW5SLmJ1ZmZlciwgYnVmZmVyUiApXG4gICAgICB9XG5cbiAgICAgIC8vIFhYWCBtdXN0IGJlIHNhbWUgdHlwZSBhcyB3aGF0IGlzIHJldHVybmVkIGJ5IGdlbmlzaCBmb3IgdHlwZSBjaGVja3MgdG8gd29yayBjb3JyZWN0bHlcbiAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBGbG9hdDY0QXJyYXkoIDIgKSBcblxuICAgICAgY29uc3QgYnVzID0gT2JqZWN0LmNyZWF0ZSggQnVzMiApXG5cbiAgICAgIGxldCBpbml0ID0gZmFsc2VcblxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBCdXMyLmRlZmF1bHRzLCBfX3Byb3BzIClcblxuICAgICAgT2JqZWN0LmFzc2lnbiggXG4gICAgICAgIGJ1cyxcblxuICAgICAgICB7XG4gICAgICAgICAgY2FsbGJhY2soKSB7XG4gICAgICAgICAgICBvdXRwdXRbIDAgXSA9IG91dHB1dFsgMSBdID0gMFxuICAgICAgICAgICAgY29uc3QgbGFzdElkeCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxXG4gICAgICAgICAgICBjb25zdCBtZW1vcnkgID0gYXJndW1lbnRzWyBsYXN0SWR4IF1cbiAgICAgICAgICAgIGxldCBwYW4gID0gYXJndW1lbnRzWyBsYXN0SWR4IC0gMSBdXG4gICAgICAgICAgICBjb25zdCBnYWluID0gYXJndW1lbnRzWyBsYXN0SWR4IC0gMiBdXG5cbiAgICAgICAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgbGFzdElkeCAtIDI7IGkrPSAzICkge1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGFyZ3VtZW50c1sgaSBdLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGFyZ3VtZW50c1sgaSArIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGVyZW8gPSBhcmd1bWVudHNbIGkgKyAyIF1cblxuICAgICAgICAgICAgICBvdXRwdXRbIDAgXSArPSBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGlucHV0WyAwIF0gKiBsZXZlbCA6IGlucHV0ICogbGV2ZWxcblxuICAgICAgICAgICAgICBvdXRwdXRbIDEgXSArPSBpc1N0ZXJlbyA9PT0gdHJ1ZSA/IGlucHV0WyAxIF0gKiBsZXZlbCA6IGlucHV0ICogbGV2ZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHBhbiA8IDAgKSB7XG4gICAgICAgICAgICAgIHBhbiA9IDBcbiAgICAgICAgICAgIH1lbHNlIGlmKCBwYW4gPiAxICl7XG4gICAgICAgICAgICAgIHBhbiA9IDFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFuUmF3SW5kZXggID0gcGFuICogMTAyMyxcbiAgICAgICAgICAgICAgICAgIHBhbkJhc2VJbmRleCA9IHBhblJhd0luZGV4IHwgMCxcbiAgICAgICAgICAgICAgICAgIHBhbk5leHRJbmRleCA9IChwYW5CYXNlSW5kZXggKyAxKSAmIDEwMjMsXG4gICAgICAgICAgICAgICAgICBpbnRlcnBBbW91bnQgPSBwYW5SYXdJbmRleCAtIHBhbkJhc2VJbmRleCxcbiAgICAgICAgICAgICAgICAgIHBhbkwgPSBtZW1vcnlbIGJ1ZmZlckwgKyBwYW5CYXNlSW5kZXggXSBcbiAgICAgICAgICAgICAgICAgICAgKyAoIGludGVycEFtb3VudCAqICggbWVtb3J5WyBidWZmZXJMICsgcGFuTmV4dEluZGV4IF0gLSBtZW1vcnlbIGJ1ZmZlckwgKyBwYW5CYXNlSW5kZXggXSApICksXG4gICAgICAgICAgICAgICAgICBwYW5SID0gbWVtb3J5WyBidWZmZXJSICsgcGFuQmFzZUluZGV4IF0gXG4gICAgICAgICAgICAgICAgICAgICsgKCBpbnRlcnBBbW91bnQgKiAoIG1lbW9yeVsgYnVmZmVyUiArIHBhbk5leHRJbmRleCBdIC0gbWVtb3J5WyBidWZmZXJSICsgcGFuQmFzZUluZGV4IF0gKSApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG91dHB1dFswXSAqPSBnYWluICogcGFuTFxuICAgICAgICAgICAgb3V0cHV0WzFdICo9IGdhaW4gKiBwYW5SXG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkIDogR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKCksXG4gICAgICAgICAgZGlydHkgOiBmYWxzZSxcbiAgICAgICAgICB0eXBlIDogJ2J1cycsXG4gICAgICAgICAgaW5wdXRzOlsgMSwgLjUgXSxcbiAgICAgICAgICBpc1N0ZXJlbzogdHJ1ZSxcbiAgICAgICAgICBfX3Byb3BlcnRpZXNfXzpwcm9wc1xuICAgICAgICB9LFxuXG4gICAgICAgIEJ1czIuZGVmYXVsdHMsXG5cbiAgICAgICAgcHJvcHNcbiAgICAgIClcblxuICAgICAgYnVzLnVnZW5OYW1lID0gYnVzLmNhbGxiYWNrLnVnZW5OYW1lID0gJ2J1czJfJyArIGJ1cy5pZFxuXG4gICAgICBjb25zdCBvdXQgPSBidXMuX191c2VQcm94eV9fID09PSB0cnVlID8gcHJveHkoIFsnQnVzMiddLCBwcm9wcywgYnVzICkgOiBidXNcblxuXG4gICAgICAvLyB3ZSBoYXZlIHRvIGluY2x1ZGUgY3VzdG9tIHByb3BlcnRpZXMgZm9yIHRoZXNlIGFzIHRoZSBhcmd1bWVudCBsaXN0IGZvclxuICAgICAgLy8gdGhlIGNvbXBpbGVkIG91dHB1dCBmdW5jdGlvbiBpcyB2YXJpYWJsZVxuICAgICAgLy8gc28gY29kZWdlbiBjYW4ndCBrbm93IHRoZSBjb3JyZWN0IGFyZ3VtZW50IG9yZGVyIGZvciB0aGUgZnVuY3Rpb25cbiAgICAgIGxldCBwYW4gPSAuNVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvdXQsICdwYW4nLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHBhbiB9LFxuICAgICAgICBzZXQodil7IFxuICAgICAgICAgIHBhbiA9IHZcbiAgICAgICAgICBvdXQuaW5wdXRzWyBvdXQuaW5wdXRzLmxlbmd0aCAtIDEgXSA9IHBhblxuICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggb3V0IClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgbGV0IGdhaW4gPSAxXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG91dCwgJ2dhaW4nLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIGdhaW4gfSxcbiAgICAgICAgc2V0KHYpeyBcbiAgICAgICAgICBnYWluID0gdlxuICAgICAgICAgIG91dC5pbnB1dHNbIG91dC5pbnB1dHMubGVuZ3RoIC0gMiBdID0gZ2FpblxuICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggb3V0IClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH0sXG4gICAgXG4gICAgZGlzY29ubmVjdFVnZW4oIHVnZW4gKSB7XG4gICAgICBsZXQgcmVtb3ZlSWR4ID0gdGhpcy5pbnB1dHMuaW5kZXhPZiggdWdlbiApXG5cbiAgICAgIGlmKCByZW1vdmVJZHggIT09IC0xICkge1xuICAgICAgICB0aGlzLmlucHV0cy5zcGxpY2UoIHJlbW92ZUlkeCwgMyApXG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggdGhpcyApXG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlZmF1bHRzOiB7IGdhaW46MSwgcGFuOi41LCBfX3VzZVByb3h5X186dHJ1ZSB9XG4gIH0pXG5cbiAgY29uc3QgY29uc3RydWN0b3IgPSBCdXMyLmNyZWF0ZS5iaW5kKCBCdXMyIClcbiAgY29uc3RydWN0b3IuZGVmYXVsdHMgPSBCdXMyLmRlZmF1bHRzXG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yXG5cbn1cbiIsImNvbnN0ICBnICAgID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgICksXG4gICAgICAgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG4gIGNvbnN0IE1vbm9wcyA9IHtcbiAgICBleHBvcnQoIG9iaiApIHtcbiAgICAgIGZvciggbGV0IGtleSBpbiBNb25vcHMgKSB7XG4gICAgICAgIGlmKCBrZXkgIT09ICdleHBvcnQnICkge1xuICAgICAgICAgIG9ialsga2V5IF0gPSBNb25vcHNbIGtleSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIEFicyggaW5wdXQgKSB7XG4gICAgICBjb25zdCBhYnMgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IGdyYXBoID0gZy5hYnMoIGcuaW4oJ2lucHV0JykgKVxuICAgICAgXG4gICAgICBjb25zdCBfX291dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBhYnMsIGdyYXBoLCBbJ21vbm9wcycsJ2FicyddLCBPYmplY3QuYXNzaWduKHt9LCBNb25vcHMuZGVmYXVsdHMsIHsgaW5wdXRzOltpbnB1dF0sIGlzb3A6dHJ1ZSB9KSApXG5cbiAgICAgIHJldHVybiBfX291dFxuICAgIH0sXG5cbiAgICBQb3coIGlucHV0LCBleHBvbmVudCApIHtcbiAgICAgIGNvbnN0IHBvdyA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLnBvdyggZy5pbignaW5wdXQnKSwgZy5pbignZXhwb25lbnQnKSApXG4gICAgICBcbiAgICAgIEdpYmJlcmlzaC5mYWN0b3J5KCBwb3csIGdyYXBoLCBbJ21vbm9wcycsJ3BvdyddLCBPYmplY3QuYXNzaWduKHt9LCBNb25vcHMuZGVmYXVsdHMsIHsgaW5wdXRzOltpbnB1dF0sIGV4cG9uZW50LCBpc29wOnRydWUgfSkgKVxuXG4gICAgICByZXR1cm4gcG93XG4gICAgfSxcbiAgICBDbGFtcCggaW5wdXQsIG1pbiwgbWF4ICkge1xuICAgICAgY29uc3QgY2xhbXAgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IGdyYXBoID0gZy5jbGFtcCggZy5pbignaW5wdXQnKSwgZy5pbignbWluJyksIGcuaW4oJ21heCcpIClcbiAgICAgIFxuICAgICAgY29uc3QgX19vdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggY2xhbXAsIGdyYXBoLCBbJ21vbm9wcycsJ2NsYW1wJ10sIE9iamVjdC5hc3NpZ24oe30sIE1vbm9wcy5kZWZhdWx0cywgeyBpbnB1dHM6W2lucHV0XSwgaXNvcDp0cnVlLCBtaW4sIG1heCB9KSApXG5cbiAgICAgIHJldHVybiBfX291dFxuICAgIH0sXG5cbiAgICBNZXJnZSggaW5wdXQgKSB7XG4gICAgICBjb25zdCBtZXJnZXIgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IGNiID0gZnVuY3Rpb24oIF9pbnB1dCApIHtcbiAgICAgICAgcmV0dXJuIF9pbnB1dFswXSArIF9pbnB1dFsxXVxuICAgICAgfVxuXG4gICAgICBHaWJiZXJpc2guZmFjdG9yeSggbWVyZ2VyLCBnLmluKCAnaW5wdXQnICksIFsnbW9ub3BzJywnbWVyZ2UnXSwgeyBpbnB1dHM6W2lucHV0XSwgaXNvcDp0cnVlIH0sIGNiIClcbiAgICAgIG1lcmdlci50eXBlID0gJ2FuYWx5c2lzJ1xuICAgICAgbWVyZ2VyLmlucHV0TmFtZXMgPSBbICdpbnB1dCcgXVxuICAgICAgbWVyZ2VyLmlucHV0cyA9IFsgaW5wdXQgXVxuICAgICAgbWVyZ2VyLmlucHV0ID0gaW5wdXRcbiAgICAgIFxuICAgICAgcmV0dXJuIG1lcmdlclxuICAgIH0sXG4gIH1cblxuICBNb25vcHMuZGVmYXVsdHMgPSB7IGlucHV0OjAgfVxuXG4gIHJldHVybiBNb25vcHNcbn1cbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbmNvbnN0IHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiBcbmxldCBQYW5uZXIgPSBpbnB1dFByb3BzID0+IHtcbiAgY29uc3QgcHJvcHMgID0gT2JqZWN0LmFzc2lnbigge30sIFBhbm5lci5kZWZhdWx0cywgaW5wdXRQcm9wcyApLFxuICAgICAgICBwYW5uZXIgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcblxuICBjb25zdCBpc1N0ZXJlbyA9IHByb3BzLmlucHV0LmlzU3RlcmVvICE9PSB1bmRlZmluZWQgPyBwcm9wcy5pbnB1dC5pc1N0ZXJlbyA6IEFycmF5LmlzQXJyYXkoIHByb3BzLmlucHV0ICkgXG4gIFxuICBjb25zdCBpbnB1dCA9IGcuaW4oICdpbnB1dCcgKSxcbiAgICAgICAgcGFuICAgPSBnLmluKCAncGFuJyApXG5cbiAgbGV0IGdyYXBoIFxuICBpZiggaXNTdGVyZW8gKSB7XG4gICAgZ3JhcGggPSBnLnBhbiggaW5wdXRbMF0sIGlucHV0WzFdLCBwYW4gKSAgXG4gIH1lbHNle1xuICAgIGdyYXBoID0gZy5wYW4oIGlucHV0LCBpbnB1dCwgcGFuIClcbiAgfVxuXG4gIEdpYmJlcmlzaC5mYWN0b3J5KCBwYW5uZXIsIFsgZ3JhcGgubGVmdCwgZ3JhcGgucmlnaHRdLCBbJ3Bhbm5lciddLCBwcm9wcyApXG4gIFxuICByZXR1cm4gcGFubmVyXG59XG5cblBhbm5lci5kZWZhdWx0cyA9IHtcbiAgaW5wdXQ6MCxcbiAgcGFuOi41XG59XG5cbnJldHVybiBQYW5uZXIgXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBUaW1lID0ge1xuICAgIGJwbTogMTIwLFxuXG4gICAgZXhwb3J0OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oIHRhcmdldCwgVGltZSApXG4gICAgfSxcblxuICAgIG1zIDogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdmFsICogR2liYmVyaXNoLmN0eC5zYW1wbGVSYXRlIC8gMTAwMDtcbiAgICB9LFxuXG4gICAgc2Vjb25kcyA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAqIEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZTtcbiAgICB9LFxuXG4gICAgYmVhdHMgOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgXG4gICAgICAgIHZhciBzYW1wbGVzUGVyQmVhdCA9IEdpYmJlcmlzaC5jdHguc2FtcGxlUmF0ZSAvICggR2liYmVyaXNoLlRpbWUuYnBtIC8gNjAgKSA7XG4gICAgICAgIHJldHVybiBzYW1wbGVzUGVyQmVhdCAqIHZhbCA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFRpbWVcbn1cbiIsImNvbnN0IGdlbmlzaCA9IHJlcXVpcmUoICdnZW5pc2guanMnICksXG4gICAgICBzc2QgPSBnZW5pc2guaGlzdG9yeSxcbiAgICAgIG5vaXNlID0gZ2VuaXNoLm5vaXNlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIGpzZHNwXCJcblxuICBjb25zdCBsYXN0ID0gc3NkKCAwIClcblxuICBjb25zdCB3aGl0ZSA9ICggbm9pc2UoKSAqIDIgKSAtIDFcblxuICBsZXQgb3V0ID0gKGxhc3Qub3V0ICsgKC4wMiAqIHdoaXRlKSkgLyAxLjAyXG5cbiAgbGFzdC5pbiggb3V0IClcblxuICBvdXQgKj0gMy41XG4gICBcbiAgcmV0dXJuIG91dFxufVxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5cbmxldCBmZWVkYmFja09zYyA9IGZ1bmN0aW9uKCBmcmVxdWVuY3ksIGZpbHRlciwgcHVsc2V3aWR0aD0uNSwgYXJndW1lbnRQcm9wcyApIHtcbiAgaWYoIGFyZ3VtZW50UHJvcHMgPT09IHVuZGVmaW5lZCApIGFyZ3VtZW50UHJvcHMgPSB7IHR5cGU6IDAgfVxuXG4gIGxldCBsYXN0U2FtcGxlID0gZy5oaXN0b3J5KCksXG4gICAgICAvLyBkZXRlcm1pbmUgcGhhc2UgaW5jcmVtZW50IGFuZCBtZW1vaXplIHJlc3VsdFxuICAgICAgdyA9IGcubWVtbyggZy5kaXYoIGZyZXF1ZW5jeSwgZy5nZW4uc2FtcGxlcmF0ZSApICksXG4gICAgICAvLyBjcmVhdGUgc2NhbGluZyBmYWN0b3JcbiAgICAgIG4gPSBnLnN1YiggLS41LCB3ICksXG4gICAgICBzY2FsaW5nID0gZy5tdWwoIGcubXVsKCAxMywgZmlsdGVyICksIGcucG93KCBuLCA1ICkgKSxcbiAgICAgIC8vIGNhbGN1bGF0ZSBkYyBvZmZzZXQgYW5kIG5vcm1hbGl6YXRpb24gZmFjdG9yc1xuICAgICAgREMgPSBnLnN1YiggLjM3NiwgZy5tdWwoIHcsIC43NTIgKSApLFxuICAgICAgbm9ybSA9IGcuc3ViKCAxLCBnLm11bCggMiwgdyApICksXG4gICAgICAvLyBkZXRlcm1pbmUgcGhhc2VcbiAgICAgIG9zYzFQaGFzZSA9IGcuYWNjdW0oIHcsIDAsIHsgbWluOi0xIH0pLFxuICAgICAgb3NjMSwgb3V0XG5cbiAgLy8gY3JlYXRlIGN1cnJlbnQgc2FtcGxlLi4uIGZyb20gdGhlIHBhcGVyOlxuICAvLyBvc2MgPSAob3NjICsgc2luKDIqcGkqKHBoYXNlICsgb3NjKnNjYWxpbmcpKSkqMC41ZjtcbiAgb3NjMSA9IGcubWVtbyggXG4gICAgZy5tdWwoXG4gICAgICBnLmFkZChcbiAgICAgICAgbGFzdFNhbXBsZS5vdXQsXG4gICAgICAgIGcuc2luKFxuICAgICAgICAgIGcubXVsKFxuICAgICAgICAgICAgTWF0aC5QSSAqIDIsXG4gICAgICAgICAgICBnLm1lbW8oIGcuYWRkKCBvc2MxUGhhc2UsIGcubXVsKCBsYXN0U2FtcGxlLm91dCwgc2NhbGluZyApICkgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIC41XG4gICAgKVxuICApXG5cbiAgLy8gc3RvcmUgc2FtcGxlIHRvIHVzZSBhcyBtb2R1bGF0aW9uXG4gIGxhc3RTYW1wbGUuaW4oIG9zYzEgKVxuXG4gIC8vIGlmIHB3bSAvIHNxdWFyZSB3YXZlZm9ybSBpbnN0ZWFkIG9mIHNhd3Rvb3RoLi4uXG4gIGlmKCBhcmd1bWVudFByb3BzLnR5cGUgPT09IDEgKSB7IFxuICAgIGNvbnN0IGxhc3RTYW1wbGUyID0gZy5oaXN0b3J5KCkgLy8gZm9yIG9zYyAyXG4gICAgY29uc3QgbGFzdFNhbXBsZU1hc3RlciA9IGcuaGlzdG9yeSgpIC8vIGZvciBzdW0gb2Ygb3NjMSxvc2MyXG5cbiAgICBjb25zdCBvc2MyID0gZy5tdWwoXG4gICAgICBnLmFkZChcbiAgICAgICAgbGFzdFNhbXBsZTIub3V0LFxuICAgICAgICBnLnNpbihcbiAgICAgICAgICBnLm11bChcbiAgICAgICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICAgICAgZy5tZW1vKCBnLmFkZCggb3NjMVBoYXNlLCBnLm11bCggbGFzdFNhbXBsZTIub3V0LCBzY2FsaW5nICksIHB1bHNld2lkdGggKSApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgLjVcbiAgICApXG5cbiAgICBsYXN0U2FtcGxlMi5pbiggb3NjMiApXG4gICAgb3V0ID0gZy5tZW1vKCBnLnN1YiggbGFzdFNhbXBsZS5vdXQsIGxhc3RTYW1wbGUyLm91dCApIClcbiAgICBvdXQgPSBnLm1lbW8oIGcuYWRkKCBnLm11bCggMi41LCBvdXQgKSwgZy5tdWwoIC0xLjUsIGxhc3RTYW1wbGVNYXN0ZXIub3V0ICkgKSApXG4gICAgXG4gICAgbGFzdFNhbXBsZU1hc3Rlci5pbiggZy5zdWIoIG9zYzEsIG9zYzIgKSApXG5cbiAgfWVsc2V7XG4gICAgIC8vIG9mZnNldCBhbmQgbm9ybWFsaXplXG4gICAgb3NjMSA9IGcuYWRkKCBnLm11bCggMi41LCBvc2MxICksIGcubXVsKCAtMS41LCBsYXN0U2FtcGxlLm91dCApIClcbiAgICBvc2MxID0gZy5hZGQoIG9zYzEsIERDIClcbiBcbiAgICBvdXQgPSBvc2MxXG4gIH1cblxuICByZXR1cm4gZy5tdWwoIG91dCwgbm9ybSApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmVlZGJhY2tPc2NcbiIsImNvbnN0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgICAgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKCksXG4gICAgICBmZWVkYmFja09zYyA9IHJlcXVpcmUoICcuL2ZtZmVlZGJhY2tvc2MuanMnICksXG4gICAgICBwb2x5QmxlcCA9IHJlcXVpcmUoICcuL3BvbHlibGVwLmRzcC5qcycgKVxuXG4vLyAgX19tYWtlT3NjaWxsYXRvcl9fKCB0eXBlLCBmcmVxdWVuY3ksIGFudGlhbGlhcyApIHtcbiAgICBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcbiAgbGV0IE9zY2lsbGF0b3JzID0ge1xuICAgIGV4cG9ydCggb2JqICkge1xuICAgICAgZm9yKCBsZXQga2V5IGluIE9zY2lsbGF0b3JzICkge1xuICAgICAgICBpZigga2V5ICE9PSAnZXhwb3J0JyApIHtcbiAgICAgICAgICBvYmpbIGtleSBdID0gT3NjaWxsYXRvcnNbIGtleSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2VuaXNoOiB7XG4gICAgICBCcm93bjogcmVxdWlyZSggJy4vYnJvd25ub2lzZS5kc3AuanMnICksXG4gICAgICBQaW5rOiAgcmVxdWlyZSggJy4vcGlua25vaXNlLmRzcC5qcycgIClcbiAgICB9LFxuXG4gICAgV2F2ZXRhYmxlOiByZXF1aXJlKCAnLi93YXZldGFibGUuanMnICkoIEdpYmJlcmlzaCApLFxuICAgIFxuICAgIFNxdWFyZSggaW5wdXRQcm9wcyApIHtcbiAgICAgIGNvbnN0IHNxciAgID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApIFxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYW50aWFsaWFzOmZhbHNlIH0sIE9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICAgIGNvbnN0IG9zYyAgID0gT3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NxdWFyZScsIGcuaW4oICdmcmVxdWVuY3knICksIHByb3BzLmFudGlhbGlhcyApXG4gICAgICBjb25zdCBncmFwaCA9IGcubXVsKCBvc2MsIGcuaW4oJ2dhaW4nICkgKVxuXG4gICAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggc3FyLCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ3NxdWFyZSddLCBwcm9wcyApXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgVHJpYW5nbGUoIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCB0cmk9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSBcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGFudGlhbGlhczpmYWxzZSB9LCBPc2NpbGxhdG9ycy5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG4gICAgICBjb25zdCBvc2MgICA9IE9zY2lsbGF0b3JzLmZhY3RvcnkoICd0cmlhbmdsZScsIGcuaW4oICdmcmVxdWVuY3knICksIHByb3BzLmFudGlhbGlhcyApXG4gICAgICBjb25zdCBncmFwaCA9IGcubXVsKCBvc2MsIGcuaW4oJ2dhaW4nICkgKVxuXG4gICAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggdHJpLCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ3RyaWFuZ2xlJ10sIHByb3BzIClcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH0sXG5cbiAgICBQV00oIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCBwd20gICA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKSBcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGFudGlhbGlhczpmYWxzZSwgcHVsc2V3aWR0aDouMjUgfSwgT3NjaWxsYXRvcnMuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgICAgY29uc3Qgb3NjICAgPSBPc2NpbGxhdG9ycy5mYWN0b3J5KCAncHdtJywgZy5pbiggJ2ZyZXF1ZW5jeScgKSwgcHJvcHMuYW50aWFsaWFzIClcbiAgICAgIGNvbnN0IGdyYXBoID0gZy5tdWwoIG9zYywgZy5pbignZ2FpbicgKSApXG5cbiAgICAgIGNvbnN0IG91dCA9IEdpYmJlcmlzaC5mYWN0b3J5KCBwd20sIGdyYXBoLCBbJ29zY2lsbGF0b3JzJywnUFdNJ10sIHByb3BzIClcblxuICAgICAgcmV0dXJuIG91dFxuICAgIH0sXG5cbiAgICBTaW5lKCBpbnB1dFByb3BzICkge1xuICAgICAgY29uc3Qgc2luZSAgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgT3NjaWxsYXRvcnMuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgICAgY29uc3QgZ3JhcGggPSBnLm11bCggZy5jeWNsZSggZy5pbignZnJlcXVlbmN5JykgKSwgZy5pbignZ2FpbicpIClcblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHNpbmUsIGdyYXBoLCBbJ29zY2lsbGF0b3JzJywnc2luZSddLCBwcm9wcyApXG4gICAgICBcbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgTm9pc2UoIGlucHV0UHJvcHMgKSB7XG4gICAgICBjb25zdCBub2lzZSA9IE9iamVjdC5jcmVhdGUoIHVnZW4gKVxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgeyBnYWluOiAxLCBjb2xvcjond2hpdGUnIH0sIGlucHV0UHJvcHMgKVxuICAgICAgbGV0IGdyYXBoIFxuXG4gICAgICBzd2l0Y2goIHByb3BzLmNvbG9yICkge1xuICAgICAgICBjYXNlICdicm93bic6XG4gICAgICAgICAgZ3JhcGggPSBnLm11bCggT3NjaWxsYXRvcnMuZ2VuaXNoLkJyb3duKCksIGcuaW4oJ2dhaW4nKSApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BpbmsnOlxuICAgICAgICAgIGdyYXBoID0gZy5tdWwoIE9zY2lsbGF0b3JzLmdlbmlzaC5QaW5rKCksIGcuaW4oJ2dhaW4nKSApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZ3JhcGggPSBnLm11bCggZy5ub2lzZSgpLCBnLmluKCdnYWluJykgKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggbm9pc2UsIGdyYXBoLCBbJ29zY2lsbGF0b3JzJywnbm9pc2UnXSwgcHJvcHMgKVxuXG4gICAgICByZXR1cm4gb3V0XG4gICAgfSxcblxuICAgIFNhdyggaW5wdXRQcm9wcyApIHtcbiAgICAgIGNvbnN0IHNhdyAgID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApIFxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYW50aWFsaWFzOmZhbHNlIH0sIE9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICAgIGNvbnN0IG9zYyAgID0gT3NjaWxsYXRvcnMuZmFjdG9yeSggJ3NhdycsIGcuaW4oICdmcmVxdWVuY3knICksIHByb3BzLmFudGlhbGlhcyApXG4gICAgICBjb25zdCBncmFwaCA9IGcubXVsKCBvc2MsIGcuaW4oJ2dhaW4nICkgKVxuXG4gICAgICBjb25zdCBvdXQgPSBHaWJiZXJpc2guZmFjdG9yeSggc2F3LCBncmFwaCwgWydvc2NpbGxhdG9ycycsJ3NhdyddLCBwcm9wcyApXG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9LFxuXG4gICAgUmV2ZXJzZVNhdyggaW5wdXRQcm9wcyApIHtcbiAgICAgIGNvbnN0IHNhdyAgID0gT2JqZWN0LmNyZWF0ZSggdWdlbiApIFxuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYW50aWFsaWFzOmZhbHNlIH0sIE9zY2lsbGF0b3JzLmRlZmF1bHRzLCBpbnB1dFByb3BzIClcbiAgICAgIGNvbnN0IG9zYyAgID0gZy5zdWIoIDEsIE9zY2lsbGF0b3JzLmZhY3RvcnkoICdzYXcnLCBnLmluKCAnZnJlcXVlbmN5JyApLCBwcm9wcy5hbnRpYWxpYXMgKSApXG4gICAgICBjb25zdCBncmFwaCA9IGcubXVsKCBvc2MsIGcuaW4oICdnYWluJyApIClcblxuICAgICAgY29uc3Qgb3V0ID0gR2liYmVyaXNoLmZhY3RvcnkoIHNhdywgZ3JhcGgsIFsnb3NjaWxsYXRvcnMnLCdSZXZlcnNlU2F3J10sIHByb3BzIClcbiAgICAgIFxuICAgICAgcmV0dXJuIG91dFxuICAgIH0sXG5cbiAgICBmYWN0b3J5KCB0eXBlLCBmcmVxdWVuY3ksIGFudGlhbGlhcz1mYWxzZSApIHtcbiAgICAgIGxldCBvc2NcblxuICAgICAgc3dpdGNoKCB0eXBlICkge1xuICAgICAgICBjYXNlICdwd20nOlxuICAgICAgICAgIGxldCBwdWxzZXdpZHRoID0gZy5pbigncHVsc2V3aWR0aCcpXG4gICAgICAgICAgaWYoIGFudGlhbGlhcyA9PSB0cnVlICkge1xuICAgICAgICAgICAgb3NjID0gZmVlZGJhY2tPc2MoIGZyZXF1ZW5jeSwgMSwgcHVsc2V3aWR0aCwgeyB0eXBlOjEgfSlcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxldCBwaGFzZSA9IGcucGhhc29yKCBmcmVxdWVuY3ksIDAsIHsgbWluOjAgfSApXG4gICAgICAgICAgICBvc2MgPSBnLmx0KCBwaGFzZSwgcHVsc2V3aWR0aCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzYXcnOlxuICAgICAgICAgIGlmKCBhbnRpYWxpYXMgPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBvc2MgPSBnLnBoYXNvciggZnJlcXVlbmN5IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG9zYyA9IHBvbHlCbGVwKCBmcmVxdWVuY3ksIHsgdHlwZSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZSc6XG4gICAgICAgICAgb3NjID0gZy5jeWNsZSggZnJlcXVlbmN5IClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICBpZiggYW50aWFsaWFzID09IHRydWUgKSB7XG4gICAgICAgICAgICAvL29zYyA9IGZlZWRiYWNrT3NjKCBmcmVxdWVuY3ksIDEsIC41LCB7IHR5cGU6MSB9KVxuICAgICAgICAgICAgb3NjID0gcG9seUJsZXAoIGZyZXF1ZW5jeSwgeyB0eXBlIH0pXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvc2MgPSBnLndhdmV0YWJsZSggZnJlcXVlbmN5LCB7IGJ1ZmZlcjpPc2NpbGxhdG9ycy5TcXVhcmUuYnVmZmVyLCBuYW1lOidzcXVhcmUnIH0gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgICAgIGlmKCBhbnRpYWxpYXMgPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIG9zYyA9IHBvbHlCbGVwKCBmcmVxdWVuY3ksIHsgdHlwZSB9KVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgb3NjID0gZy53YXZldGFibGUoIGZyZXF1ZW5jeSwgeyBidWZmZXI6T3NjaWxsYXRvcnMuVHJpYW5nbGUuYnVmZmVyLCBuYW1lOid0cmlhbmdsZScgfSApXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdub2lzZSc6XG4gICAgICAgICAgb3NjID0gZy5ub2lzZSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvc2NcbiAgICB9XG4gIH1cblxuICBPc2NpbGxhdG9ycy5TcXVhcmUuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMTAyNCApXG5cbiAgZm9yKCBsZXQgaSA9IDEwMjM7IGkgPj0gMDsgaS0tICkgeyBcbiAgICBPc2NpbGxhdG9ycy5TcXVhcmUuYnVmZmVyIFsgaSBdID0gaSAvIDEwMjQgPiAuNSA/IDEgOiAtMVxuICB9XG5cbiAgT3NjaWxsYXRvcnMuVHJpYW5nbGUuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMTAyNCApXG5cbiAgXG4gIGZvciggbGV0IGkgPSAxMDI0OyBpLS07IGkgPSBpICkgeyBPc2NpbGxhdG9ycy5UcmlhbmdsZS5idWZmZXJbaV0gPSAxIC0gNCAqIE1hdGguYWJzKCggKGkgLyAxMDI0KSArIDAuMjUpICUgMSAtIDAuNSk7IH1cblxuICBPc2NpbGxhdG9ycy5kZWZhdWx0cyA9IHtcbiAgICBmcmVxdWVuY3k6IDQ0MCxcbiAgICBnYWluOiAxXG4gIH1cblxuICByZXR1cm4gT3NjaWxsYXRvcnNcblxufVxuIiwiY29uc3QgZ2VuaXNoID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIHNzZCA9IGdlbmlzaC5oaXN0b3J5LFxuICAgICAgZGF0YSA9IGdlbmlzaC5kYXRhLFxuICAgICAgbm9pc2UgPSBnZW5pc2gubm9pc2VcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2UganNkc3BcIlxuXG4gIGNvbnN0IGIgPSBkYXRhKCA4LCAxLCB7IG1ldGE6IHRydWUgfSlcbiAgY29uc3Qgd2hpdGUgPSBub2lzZSgpICogMiAtIDFcblxuICBiWzBdID0gKCAuOTk4ODYgKiBiWzBdICkgKyAoIHdoaXRlICogLjA1NTUxNzkgKVxuICBiWzFdID0gKCAuOTkzMzIgKiBiWzFdICkgKyAoIHdoaXRlICogLjA3NTA1NzkgKVxuICBiWzJdID0gKCAuOTY5MDAgKiBiWzJdICkgKyAoIHdoaXRlICogLjE1Mzg1MjAgKVxuICBiWzNdID0gKCAuODg2NTAgKiBiWzNdICkgKyAoIHdoaXRlICogLjMxMDQ4NTYgKVxuICBiWzRdID0gKCAuNTUwMDAgKiBiWzRdICkgKyAoIHdoaXRlICogLjUzMjk1MjIgKVxuICBiWzVdID0gKCAtLjc2MTYgKiBiWzVdICkgLSAoIHdoaXRlICogLjAxNjg5ODAgKVxuIFxuICBjb25zdCBvdXQgPSAoIGJbMF0gKyBiWzFdICsgYlsyXSArIGJbM10gKyBiWzRdICsgYls1XSArIGJbNl0gKyB3aGl0ZSAqIC41MzYyICkgKiAuMTFcblxuICBiWzZdID0gd2hpdGUgKiAuMTE1OTI2XG5cbiAgcmV0dXJuIG91dFxuXG59XG4iLCJjb25zdCBnZW5pc2ggPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApXG5jb25zdCBnID0gZ2VuaXNoXG5cbi8vIGJhc2VkIG9uIGh0dHA6Ly93d3cubWFydGluLWZpbmtlLmRlL2Jsb2cvYXJ0aWNsZXMvYXVkaW8tcGx1Z2lucy0wMTgtcG9seWJsZXAtb3NjaWxsYXRvci9cbmNvbnN0IHBvbHlCbGVwID0gZnVuY3Rpb24oIF9fZnJlcXVlbmN5LCBhcmd1bWVudFByb3BzICkge1xuICAndXNlIGpzZHNwJ1xuICBpZiggYXJndW1lbnRQcm9wcyA9PT0gdW5kZWZpbmVkICkgYXJndW1lbnRQcm9wcyA9IHsgdHlwZTogJ3NhdycgfVxuICBcbiAgY29uc3QgbWVtID0gZy5oaXN0b3J5KDApXG4gIGNvbnN0IHR5cGUgPSBhcmd1bWVudFByb3BzLnR5cGVcbiAgY29uc3QgZnJlcXVlbmN5ID0gX19mcmVxdWVuY3kgPT09IHVuZGVmaW5lZCA/IDIyMCA6IF9fZnJlcXVlbmN5XG4gIGNvbnN0IGR0ID0gZnJlcXVlbmN5IC8gZy5nZW4uc2FtcGxlcmF0ZVxuICBcbiAgY29uc3QgdCA9IGcuYWNjdW0oIGR0LCAwLCB7IG1pbjowIH0pXG4gIGxldCBvc2NcblxuICAvLyB0cmlhbmdsZSB3YXZlcyBhcmUgaW50ZWdyYXRlZCBzcXVhcmUgd2F2ZXMsIHNvIHRoZSBiZWxvdyBjYXNlIGFjY29tb2RhdGVzIGJvdGggdHlwZXNcbiAgaWYoIHR5cGUgPT09ICd0cmlhbmdsZScgfHwgdHlwZSA9PT0gJ3NxdWFyZScgKSB7XG4gICAgLy8gbHQgTk9UIGd0IHRvIGdldCBjb3JyZWN0IHBoYXNlXG4gICAgb3NjID0gKDIgKiBnLmx0KHQsLjUpICkgLSAxXG4gIH1lbHNle1xuICAgIG9zYyA9IDIgKiB0IC0gMVxuICB9XG4gIGNvbnN0IGNhc2UxID0gZy5sdCh0LGR0KVxuICBjb25zdCBjYXNlMiA9IGcuZ3QodCwxLWR0KVxuICBjb25zdCBhZGp1c3RlZFQgPSBnLnN3aXRjaCggY2FzZTEsIHQvZHQsIGcuc3dpdGNoKCBjYXNlMiwgKHQtMSkvZHQsIHQgKSApXG4gIFxuICAvLyBpZi9lbHNlaWYvZWxzZSB3aXRoIG5lc3RlZCB0ZXJuYXJ5IG9wZXJhdG9yc1xuICBjb25zdCBibGVwID0gZy5zd2l0Y2goXG4gICAgY2FzZTEsXG4gICAgYWRqdXN0ZWRUICsgYWRqdXN0ZWRUIC0gYWRqdXN0ZWRUICogYWRqdXN0ZWRUIC0gMSxcbiAgICBnLnN3aXRjaChcbiAgICAgIGNhc2UyLFxuICAgICAgYWRqdXN0ZWRUICogYWRqdXN0ZWRUICsgYWRqdXN0ZWRUICsgYWRqdXN0ZWRUICsgMSxcbiAgICAgIC8vIGZpbmFsIGVsc2UgY2FzZSBpcyAwXG4gICAgICAwXG4gICAgKVxuICApXG4gIFxuICAvLyB0cmlhbmdsZSB3YXZlcyBhcmUgaW50ZWdyYXRlZCBzcXVhcmUgd2F2ZXMsIHNvIHRoZSBiZWxvdyBjYXNlIGFjY29tb2RhdGVzIGJvdGggdHlwZXNcbiAgaWYoIHR5cGUgIT09ICdzYXcnICkge1xuICAgIG9zYyA9IG9zYyArIGJsZXBcbiAgICBjb25zdCB0XzIgPSBnLm1lbW8oIGcubW9kKCB0ICsgLjUsIDEgKSApXG4gICAgY29uc3QgY2FzZTFfMiA9IGcubHQodF8yLGR0KVxuICAgIGNvbnN0IGNhc2UyXzIgPSBnLmd0KHRfMiwxLWR0KVxuICAgIGNvbnN0IGFkanVzdGVkVF8yID0gZy5zd2l0Y2goIGNhc2UxXzIsIHRfMi9kdCwgZy5zd2l0Y2goIGNhc2UyXzIsICh0XzItMSkvZHQsIHRfMiApIClcbiBcbiAgICBjb25zdCBibGVwMiA9IGcuc3dpdGNoKFxuICAgICAgY2FzZTFfMixcbiAgICAgIGFkanVzdGVkVF8yICsgYWRqdXN0ZWRUXzIgLSBhZGp1c3RlZFRfMiAqIGFkanVzdGVkVF8yIC0gMSxcbiAgICAgIGcuc3dpdGNoKFxuICAgICAgICBjYXNlMl8yLFxuICAgICAgICBhZGp1c3RlZFRfMiAqIGFkanVzdGVkVF8yICsgYWRqdXN0ZWRUXzIgKyBhZGp1c3RlZFRfMiArIDEsXG4gICAgICAgIDBcbiAgICAgIClcbiAgICApXG4gICAgb3NjID0gb3NjIC0gYmxlcDJcbiAgICBcbiAgICAvLyBsZWFreSBpbnRlZ3JhdG9yIHRvIGNyZWF0ZSB0cmlhbmdsZSBmcm9tIHNxdWFyZSB3YXZlXG4gICAgaWYoIHR5cGUgPT09ICd0cmlhbmdsZScgKSB7XG4gICAgICBvc2MgPSBkdCAqIG9zYyArICgxIC0gZHQgKSAqIG1lbS5vdXRcbiAgICAgIG1lbS5pbiggb3NjIClcbiAgICB9XG4gIH1lbHNle1xuICAgIG9zYyA9IG9zYyAtIGJsZXBcbiAgfVxuICBcbiAgcmV0dXJuIG9zY1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlCbGVwIFxuIiwibGV0IGcgPSByZXF1aXJlKCAnZ2VuaXNoLmpzJyApLFxuICAgIHVnZW4gPSByZXF1aXJlKCAnLi4vdWdlbi5qcycgKSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuICBjb25zdCBXYXZldGFibGUgPSBmdW5jdGlvbiggaW5wdXRQcm9wcyApIHtcbiAgICBjb25zdCB3YXZldGFibGUgPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcbiAgICBjb25zdCBwcm9wcyAgPSBPYmplY3QuYXNzaWduKHt9LCBHaWJiZXJpc2gub3NjaWxsYXRvcnMuZGVmYXVsdHMsIGlucHV0UHJvcHMgKVxuICAgIGNvbnN0IG9zYyA9IGcud2F2ZXRhYmxlKCBnLmluKCdmcmVxdWVuY3knKSwgcHJvcHMgKVxuICAgIGNvbnN0IGdyYXBoID0gZy5tdWwoIFxuICAgICAgb3NjLCBcbiAgICAgIGcuaW4oICdnYWluJyApXG4gICAgKVxuXG4gICAgR2liYmVyaXNoLmZhY3RvcnkoIHdhdmV0YWJsZSwgZ3JhcGgsICd3YXZldGFibGUnLCBwcm9wcyApXG5cbiAgICByZXR1cm4gd2F2ZXRhYmxlXG4gIH1cblxuICBnLndhdmV0YWJsZSA9IGZ1bmN0aW9uKCBmcmVxdWVuY3ksIHByb3BzICkge1xuICAgIGxldCBkYXRhUHJvcHMgPSB7IGltbXV0YWJsZTp0cnVlIH1cblxuICAgIC8vIHVzZSBnbG9iYWwgcmVmZXJlbmNlcyBpZiBhcHBsaWNhYmxlXG4gICAgaWYoIHByb3BzLm5hbWUgIT09IHVuZGVmaW5lZCApIGRhdGFQcm9wcy5nbG9iYWwgPSBwcm9wcy5uYW1lXG5cbiAgICBjb25zdCBidWZmZXIgPSBnLmRhdGEoIHByb3BzLmJ1ZmZlciwgMSwgZGF0YVByb3BzIClcblxuICAgIHJldHVybiBnLnBlZWsoIGJ1ZmZlciwgZy5waGFzb3IoIGZyZXF1ZW5jeSwgMCwgeyBtaW46MCB9ICkgKVxuICB9XG5cbiAgcmV0dXJuIFdhdmV0YWJsZVxufVxuIiwiY29uc3QgUXVldWUgPSByZXF1aXJlKCAnLi4vZXh0ZXJuYWwvcHJpb3JpdHlxdWV1ZS5qcycgKVxuXG5sZXQgR2liYmVyaXNoID0gbnVsbFxuXG5jb25zdCBTY2hlZHVsZXIgPSB7XG4gIHBoYXNlOiAwLFxuXG4gIHF1ZXVlOiBuZXcgUXVldWUoICggYSwgYiApID0+IHtcbiAgICBpZiggYS50aW1lID09PSBiLnRpbWUgKSB7IFxuICAgICAgcmV0dXJuIGEucHJpb3JpdHkgPCBiLnByaW9yaXR5ID8gLTEgOiBhLnByaW9yaXR5ID4gYi5wcmlvcml0eSA/IDEgOiAwO1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIGEudGltZSAtIGIudGltZSAvL2EudGltZS5taW51cyggYi50aW1lIClcbiAgICB9XG4gIH0pLFxuXG4gIGluaXQoIF9fR2liYmVyaXNoICkge1xuICAgIEdpYmJlcmlzaCA9IF9fR2liYmVyaXNoXG4gIH0sXG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZS5kYXRhLmxlbmd0aCA9IDBcbiAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBoYXNlID0gMFxuICB9LFxuXG4gIGFkZCggdGltZSwgZnVuYywgcHJpb3JpdHkgPSAwICkge1xuICAgIHRpbWUgKz0gdGhpcy5waGFzZVxuXG4gICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGltZSwgZnVuYywgcHJpb3JpdHkgfSlcblxuICAgIHJldHVybiB0aGlzLnBoYXNlXG4gIH0sXG5cbiAgdGljayggdXNpbmdTeW5jID0gZmFsc2UgKSB7XG4gICAgaWYoIHRoaXMuc2hvdWxkU3luYyA9PT0gdXNpbmdTeW5jICkge1xuICAgICAgaWYoIHRoaXMucXVldWUubGVuZ3RoICkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMucXVldWUucGVlaygpXG5cbiAgICAgICAgaWYoIGlzTmFOKCBuZXh0LnRpbWUgKSApIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHdoaWxlKCB0aGlzLnBoYXNlID49IG5leHQudGltZSApIHtcbiAgICAgICAgICBuZXh0LmZ1bmMoIG5leHQucHJpb3JpdHkgKVxuICAgICAgICAgIHRoaXMucXVldWUucG9wKClcbiAgICAgICAgICBuZXh0ID0gdGhpcy5xdWV1ZS5wZWVrKClcblxuICAgICAgICAgIC8vIFhYWCB0aGlzIGhhcHBlbnMgd2hlbiBjYWxsaW5nIHNlcXVlbmNlci5zdG9wKCkuLi4gd2h5P1xuICAgICAgICAgIGlmKCBuZXh0ID09PSB1bmRlZmluZWQgKSBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGhhc2UrK1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBoYXNlXG4gIH0sXG5cbiAgYWR2YW5jZSggYW10ICkge1xuICAgIHRoaXMucGhhc2UgKz0gYW10XG4gICAgdGhpcy50aWNrKCB0cnVlIClcbiAgfVxufVxuXG5sZXQgc2hvdWxkU3luYyA9IGZhbHNlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIFNjaGVkdWxlciwgJ3Nob3VsZFN5bmMnLCB7XG4gIGdldCgpIHsgcmV0dXJuIHNob3VsZFN5bmMgfSxcbiAgc2V0KHYpeyBcbiAgICBzaG91bGRTeW5jID0gdlxuICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGFkZHJlc3M6J2V2YWwnLFxuICAgICAgICBjb2RlOidHaWJiZXJpc2guc2NoZWR1bGVyLnNob3VsZFN5bmMgPSAnICsgdlxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZWR1bGVyXG4iLCJjb25zdCBnID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIF9fcHJveHkgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApLFxuICAgICAgdWdlbiA9IHJlcXVpcmUoICcuLi91Z2VuLmpzJyApKClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICBjb25zdCBfX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKCB1Z2VuIClcblxuICBjb25zdCBwcm94eSA9IF9fcHJveHkoIEdpYmJlcmlzaCApXG5cbiAgT2JqZWN0LmFzc2lnbiggX19wcm90b19fLCB7XG4gICAgc3RhcnQoIGRlbGF5PTAgKSB7XG4gICAgICBpZiggZGVsYXkgIT09IDAgKSB7XG4gICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBkZWxheSwgKCk9PiB7XG4gICAgICAgICAgR2liYmVyaXNoLmFuYWx5emVycy5wdXNoKCB0aGlzIClcbiAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICB9KVxuICAgICAgfWVsc2V7XG4gICAgICAgIEdpYmJlcmlzaC5hbmFseXplcnMucHVzaCggdGhpcyApXG4gICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgc3RvcCggZGVsYXk9MCApIHtcbiAgICAgIGNvbnN0IGlkeCA9IEdpYmJlcmlzaC5hbmFseXplcnMuaW5kZXhPZiggdGhpcyApXG4gICAgICBpZiggZGVsYXkgPT09IDAgKSB7XG4gICAgICAgIGlmKCBpZHggPiAtMSApIHtcbiAgICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnNwbGljZSggaWR4LCAxIClcbiAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGhhc2UgPSAwXG4gICAgICAgIHRoaXMubmV4dFRpbWUgPSAwXG4gICAgICB9ZWxzZXtcbiAgICAgICAgR2liYmVyaXNoLnNjaGVkdWxlci5hZGQoIGRlbGF5LCAoKT0+IHtcbiAgICAgICAgICBpZiggaWR4ID4gLTEgKSB7XG4gICAgICAgICAgICBHaWJiZXJpc2guYW5hbHl6ZXJzLnNwbGljZSggaWR4LCAxIClcbiAgICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggR2liYmVyaXNoLmFuYWx5emVycyApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGhhc2UgPSAwXG4gICAgICAgICAgdGhpcy5uZXh0VGltZSA9IDBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGZpcmUoKXtcbiAgICAgIGxldCB2YWx1ZSAgPSB0eXBlb2YgdGhpcy52YWx1ZXMgID09PSAnZnVuY3Rpb24nID8gdGhpcy52YWx1ZXMgIDogdGhpcy52YWx1ZXNbIHRoaXMuX192YWx1ZXNQaGFzZSsrICAlIHRoaXMudmFsdWVzLmxlbmd0aCAgXVxuICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICB2YWx1ZSgpXG4gICAgICB9ZWxzZSBpZiggdHlwZW9mIHRoaXMudGFyZ2V0WyB0aGlzLmtleSBdID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICB9XG4gICAgICAgIGlmKCB2YWx1ZSAhPT0gdGhpcy5ETlIgKSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRbIHRoaXMua2V5IF0oIHZhbHVlIClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgaWYoIHZhbHVlICE9PSB0aGlzLkROUiApXG4gICAgICAgICAgdGhpcy50YXJnZXRbIHRoaXMua2V5IF0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAvLyBYWFggd2UgbmVlZCB0byBpbXBsZW1lbnQgcHJpb3JpdHksIHdoaWNoIHdpbGwgaW4gdHVybiBkZXRlcm1pbmUgdGhlIG9yZGVyXG4gIC8vIHRoYXQgdGhlIHNlcXVlbmNlcnMgYXJlIGFkZGVkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgY29uc3QgU2VxMiA9IHsgXG4gICAgY3JlYXRlKCBpbnB1dFByb3BzICkge1xuICAgICAgY29uc3Qgc2VxID0gT2JqZWN0LmNyZWF0ZSggX19wcm90b19fICksXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2VxMi5kZWZhdWx0cywgaW5wdXRQcm9wcyApXG5cbiAgICAgIHNlcS5waGFzZSA9IDBcbiAgICAgIHNlcS5pbnB1dE5hbWVzID0gWyAncmF0ZScsICdkZW5zaXR5JyBdXG4gICAgICBzZXEuaW5wdXRzID0gWyAxLCAxIF1cbiAgICAgIHNlcS5uZXh0VGltZSA9IDBcbiAgICAgIHNlcS5fX3ZhbHVlc1BoYXNlID0gMFxuICAgICAgc2VxLl9fdGltaW5nc1BoYXNlID0gMFxuICAgICAgc2VxLmlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcbiAgICAgIHNlcS5kaXJ0eSA9IHRydWVcbiAgICAgIHNlcS50eXBlID0gJ3NlcSdcbiAgICAgIHNlcS5fX2FkZHJlc3Nlc19fID0ge31cbiAgICAgIHNlcS5ETlIgPSAtOTg3NjU0MzIxXG5cbiAgICAgIHByb3BlcnRpZXMuaWQgPSBHaWJiZXJpc2guZmFjdG9yeS5nZXRVSUQoKVxuXG4gICAgICBPYmplY3QuYXNzaWduKCBzZXEsIHByb3BlcnRpZXMgKSBcbiAgICAgIHNlcS5fX3Byb3BlcnRpZXNfXyA9IHByb3BlcnRpZXNcblxuICAgICAgLy8gc3VwcG9ydCBmb3Igc2VxdWVuY2VzIHRoYXQgYXJlIHRyaWdnZXJlZCB2aWEgb3RoZXIgbWVhbnMsXG4gICAgICAvLyBpbiBHaWJiZXIgdGhpcyBpcyB3aGVuIHlvdSBwcm92aWRlIHRpbWluZyB0byBvbmUgc2VxdWVuY2VcbiAgICAgIC8vIG9uIGFuIG9iamVjdCBhbmQgd2FudCB0byB1c2UgdGhhdCBvbmUgcGF0dGVybiB0byB0cmlnZ2VyXG4gICAgICAvLyBtdWx0aXBsZSBzZXF1ZW5jZXMuXG4gICAgICBpZiggc2VxLnRpbWluZ3MgPT09IG51bGwgKSB7IHNlcS5uZXh0VGltZSA9IEluZmluaXR5IH0gXG5cbiAgICAgIC8vIFhYWCB0aGlzIG5lZWRzIHRvIGJlIG9wdGltaXplZCBhcyBtdWNoIGFzIGh1bWFubHkgcG9zc2libGUsIHNpbmNlIGl0J3MgcnVubmluZyBhdCBhdWRpbyByYXRlLi4uXG4gICAgICBzZXEuY2FsbGJhY2sgPSBmdW5jdGlvbiggcmF0ZSwgZGVuc2l0eSApIHtcbiAgICAgICAgd2hpbGUoIHNlcS5waGFzZSA+PSBzZXEubmV4dFRpbWUgKSB7XG4gICAgICAgICAgbGV0IHZhbHVlICA9IHR5cGVvZiBzZXEudmFsdWVzICA9PT0gJ2Z1bmN0aW9uJyA/IHNlcS52YWx1ZXMgIDogc2VxLnZhbHVlc1sgc2VxLl9fdmFsdWVzUGhhc2UrKyAgJSBzZXEudmFsdWVzLmxlbmd0aCAgXSxcbiAgICAgICAgICAgICAgc2hvdWxkUnVuID0gdHJ1ZVxuICAgICAgICAgIFxuICAgICAgICAgIGxldCB0aW1pbmcgPSBudWxsXG4gICAgICAgICAgaWYoIHNlcS50aW1pbmdzICE9PSBudWxsICYmIHNlcS50aW1pbmdzICE9PSB1bmRlZmluZWQgKSB7IFxuICAgICAgICAgICAgdGltaW5nID0gdHlwZW9mIHNlcS50aW1pbmdzID09PSAnZnVuY3Rpb24nID8gc2VxLnRpbWluZ3MgOiBzZXEudGltaW5nc1sgc2VxLl9fdGltaW5nc1BoYXNlKysgJSBzZXEudGltaW5ncy5sZW5ndGggXVxuICAgICAgICAgICAgaWYoIHR5cGVvZiB0aW1pbmcgPT09ICdmdW5jdGlvbicgKSB0aW1pbmcgPSB0aW1pbmcoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgc2hvdWxkSW5jcmVhc2VTcGVlZCA9IGRlbnNpdHkgPD0gMSA/IGZhbHNlIDogdHJ1ZVxuXG4gICAgICAgICAgLy8gWFhYIHRoaXMgc3VwcG9ydHMgYW4gZWRnZSBjYXNlIGluIEdpYmJlciwgd2hlcmUgcGF0dGVybnMgbGlrZSBFdWNsaWQgLyBIZXggcmV0dXJuXG4gICAgICAgICAgLy8gb2JqZWN0cyBpbmRpY2F0aW5nIGJvdGggd2hldGhlciBvciBub3QgdGhleSBzaG91bGQgc2hvdWxkIHRyaWdnZXIgdmFsdWVzIGFzIHdlbGxcbiAgICAgICAgICAvLyBhcyB0aGUgbmV4dCB0aW1lIHRoZXkgc2hvdWxkIHJ1bi4gcGVyaGFwcyB0aGlzIGNvdWxkIGJlIG1hZGUgbW9yZSBnZW5lcmFsaXphYmxlP1xuICAgICAgICAgIGlmKCB0aW1pbmcgIT09IG51bGwgJiYgdHlwZW9mIHRpbWluZyA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBpZiggdGltaW5nLnNob3VsZEV4ZWN1dGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgIHNob3VsZFJ1biA9IHRydWVcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBzaG91bGRSdW4gPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltaW5nID0gdGltaW5nLnRpbWUgXG4gICAgICAgICAgfWVsc2UgaWYoIHRpbWluZyAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIGlmKCBNYXRoLnJhbmRvbSgpID49IGRlbnNpdHkgKSBzaG91bGRSdW4gPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBzaG91bGRSdW4gKSB7XG4gICAgICAgICAgICBpZiggc2VxLm1haW50aHJlYWRvbmx5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5tZXNzYWdlcy5wdXNoKCBzZXEubWFpbnRocmVhZG9ubHksIHNlcS5rZXksIHZhbHVlIClcbiAgICAgICAgICAgIH1lbHNlIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VxLnRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICB2YWx1ZSgpXG4gICAgICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiggdmFsdWUgIT09IHNlcS5ETlIgKSB7XG4gICAgICAgICAgICAgICAgc2VxLnRhcmdldFsgc2VxLmtleSBdKCB2YWx1ZSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgICAgICAgIGlmKCB2YWx1ZSAhPT0gc2VxLkROUiApXG4gICAgICAgICAgICAgICAgc2VxLnRhcmdldFsgc2VxLmtleSBdID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggdGltaW5nID09PSBudWxsICkgcmV0dXJuXG5cbiAgICAgICAgICBzZXEucGhhc2UgLT0gc2VxLm5leHRUaW1lXG5cbiAgICAgICAgICBpZiggc2hvdWxkSW5jcmVhc2VTcGVlZCApIHtcbiAgICAgICAgICAgIHRpbWluZyA9IE1hdGgucmFuZG9tKCkgPiAoMiAtIGRlbnNpdHkpID8gdGltaW5nIC8gMiA6IHRpbWluZ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXEubmV4dFRpbWUgPSB0aW1pbmdcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcS5waGFzZSArPSByYXRlXG5cbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cblxuICAgICAgc2VxLnVnZW5OYW1lID0gc2VxLmNhbGxiYWNrLnVnZW5OYW1lID0gJ3NlcV8nICsgc2VxLmlkXG5cbiAgICAgIC8vIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIG91ciBzZXF1ZW5jZXIgdGhyb3VnaCB0aGUgdWdlbiB0ZW1wbGF0ZSwgd2UgbmVlZFxuICAgICAgLy8gdG8gZ3JhYiBhIG1lbW9yeSBhZGRyZXNzIGZvciBpdHMgcmF0ZSBzbyBpdCBjYW4gYmUgc2VxdWVuY2VkIGFuZCBkZWZpbmVcbiAgICAgIC8vIGEgcHJvcGVydHkgdGhhdCBtYW5pcHVsYXRlcyB0aGF0IG1lbW9yeSBhZGRyZXNzLlxuICAgICAgY29uc3QgaWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggMSApXG4gICAgICBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGlkeCBdID0gc2VxLnJhdGVcbiAgICAgIHNlcS5fX2FkZHJlc3Nlc19fLnJhdGUgPSBpZHhcblxuICAgICAgbGV0IHZhbHVlID0gc2VxLnJhdGVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggc2VxLCAncmF0ZScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdmFsdWUgfSxcbiAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgIGlmKCB2YWx1ZSAhPT0gdiApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ251bWJlcicgKSBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGlkeCBdID0gdlxuXG4gICAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICAgICAgdmFsdWUgPSB2XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjb25zdCBkaWR4ID0gR2liYmVyaXNoLm1lbW9yeS5hbGxvYyggMSApXG4gICAgICBHaWJiZXJpc2gubWVtb3J5LmhlYXBbIGRpZHggXSA9IHNlcS5kZW5zaXR5XG4gICAgICBzZXEuX19hZGRyZXNzZXNfXy5kZW5zaXR5ID0gZGlkeFxuXG4gICAgICBsZXQgZHZhbHVlID0gc2VxLmRlbnNpdHlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggc2VxLCAnZGVuc2l0eScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gZHZhbHVlIH0sXG4gICAgICAgIHNldCggdiApIHtcbiAgICAgICAgICBpZiggZHZhbHVlICE9PSB2ICkge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnbnVtYmVyJyApIEdpYmJlcmlzaC5tZW1vcnkuaGVhcFsgZGlkeCBdID0gdlxuXG4gICAgICAgICAgICBHaWJiZXJpc2guZGlydHkoIEdpYmJlcmlzaC5hbmFseXplcnMgKVxuICAgICAgICAgICAgZHZhbHVlID0gdlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgICAgIEdpYmJlcmlzaC51dGlsaXRpZXMuY3JlYXRlUHViU3ViKCBzZXEgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJveHkoIFsnU2VxdWVuY2VyMiddLCBwcm9wZXJ0aWVzLCBzZXEgKSBcbiAgICB9XG4gIH1cblxuICBTZXEyLmRlZmF1bHRzID0geyByYXRlOiAxLCBkZW5zaXR5OjEsIHByaW9yaXR5OjAsIHBoYXNlOjAgfVxuICBTZXEyLmNyZWF0ZS5ET19OT1RfT1VUUFVUID0gLTk4NzY1NDMyMVxuXG4gIHJldHVybiBTZXEyLmNyZWF0ZVxuXG59XG5cbiIsImNvbnN0IF9fcHJveHkgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuY29uc3QgcmVuZGVyRm5jID0gZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggcGF0dGVybi5kaWN0IClcbiAgY29uc3Qgb2JqcyA9IE9iamVjdC52YWx1ZXMoIHBhdHRlcm4uZGljdCApXG4gICAgLm1hcCggdiA9PiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoIHYgKVxuICAgID8gR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQodi5pZCkgXG4gICAgOiB2IFxuICAgIClcblxuICAvLyB3ZSBjcmVhdGUgYSBuZXcgaW5uZXIgZnVuY3Rpb24gdXNpbmcgdGhlIGZ1bmN0aW9uIGNvbnN0cnVjdG9yLFxuICAvLyB3aGVyZSBldmVyeSBhcmd1bWVudCBpcyBjb2RlZ2VuJ2QgYXMgYW4gdXB2YWx1ZSB0byB0aGVcbiAgLy8gcmV0dXJuZWQgZnVuY3Rpb24uIGFmdGVyIGNvZGVnZW4gd2UgY2FsbCB0aGUgZnVuY3RvblxuICAvLyB0byBnZXQgdGhlIGlubmVyIGZ1bmN0aW9uIHdpdGggdGhlIHVwdmFsdWVzIGFuZGRcbiAgLy8gcmV0dXJuIHRoYXQuIFN0b3JlIHJlZmVyZW5jZXMgdG8gZ2xvYmFscyBhcyB1cHZhbHVlcyBhcyB3ZWxsLlxuICBsZXQgY29kZSA9ICdsZXQgR2liYmVyaXNoID0gX19HaWJiZXJpc2gsIGdsb2JhbCA9IF9fZ2xvYmFsO1xcbidcbiAga2V5cy5mb3JFYWNoKCBrID0+IHtcbiAgICBsZXQgbGluZSA9IGBsZXQgJHtrfSA9IGBcbiAgICBjb25zdCB2YWx1ZSA9IHBhdHRlcm4uZGljdFsgayBdXG4gICAgY29uc3QgZ2V0dGVyID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyBcbiAgICAgID8gQXJyYXkuaXNBcnJheSggdmFsdWUgKVxuICAgICAgPyBgWyR7dmFsdWUudG9TdHJpbmcoKX1dYFxuICAgICAgOiBgR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQoJHsgdmFsdWUuaWQgfSlgXG4gICAgICA6IHZhbHVlXG4gICAgbGluZSArPSBnZXR0ZXIgXG4gICAgY29kZSArPSBsaW5lICsgJ1xcbidcblxuICB9KSAgXG4gIGNvZGUgKz1gcmV0dXJuIGZ1bmN0aW9uKCkgeyAkeyBwYXR0ZXJuLmZuY3N0ciB9IH1gIFxuXG4gIC8vIHBhc3MgaW4gZ2xvYmFscyB0byBiZSB1c2VkIGFzIHVwdmFsdWVzIGluIGZpbmFsIGZ1bmN0aW9uXG4gIGNvbnN0IGZuYyA9IG5ldyBGdW5jdGlvbiggJ19fR2liYmVyaXNoJywgJ19fZ2xvYmFsJywgY29kZSApKCBHaWJiZXJpc2gsIGdsb2JhbCApXG5cbiAgcmV0dXJuIGZuYyBcbn1cblxuY29uc3QgcHJveHkgPSBfX3Byb3h5KCBHaWJiZXJpc2ggKVxuXG5jb25zdCBTZXF1ZW5jZXIgPSBwcm9wcyA9PiB7XG4gIGxldCBfX3NlcVxuICBsZXQgZmxvYXRFcnJvciA9IDBcblxuICBjb25zdCBzZXEgPSB7XG4gICAgdHlwZTonc2VxJyxcbiAgICBfX2lzUnVubmluZzpmYWxzZSxcbiAgICBfX3ZhbHVlc1BoYXNlOiAgMCxcbiAgICBfX3RpbWluZ3NQaGFzZTogMCxcbiAgICBfX29ubHlSdW5zT25jZTogZmFsc2UsXG4gICAgX19yZXBlYXRDb3VudDogbnVsbCxcbiAgICBETlIgOiAtOTg3NjU0MzIxLFxuXG4gICAgdGljayggcHJpb3JpdHkgKSB7XG4gICAgICBsZXQgdmFsdWUgID0gdHlwZW9mIHNlcS52YWx1ZXMgID09PSAnZnVuY3Rpb24nIFxuICAgICAgICAgID8gc2VxLnZhbHVlcyAgXG4gICAgICAgICAgOiBzZXEudmFsdWVzWyAgc2VxLl9fdmFsdWVzUGhhc2UrKyAgJSBzZXEudmFsdWVzLmxlbmd0aCAgXSxcblxuICAgICAgICB0aW1pbmcgPSB0eXBlb2Ygc2VxLnRpbWluZ3MgPT09ICdmdW5jdGlvbicgXG4gICAgICAgICAgPyBzZXEudGltaW5ncyBcbiAgICAgICAgICA6IHNlcS50aW1pbmdzICE9PSBudWxsXG4gICAgICAgICAgICA/IHNlcS50aW1pbmdzWyBzZXEuX190aW1pbmdzUGhhc2UrKyAlIHNlcS50aW1pbmdzLmxlbmd0aCBdXG4gICAgICAgICAgICA6IG51bGwsXG5cbiAgICAgICAgc2hvdWxkUnVuID0gdHJ1ZVxuICAgICAgXG4gICAgICBpZiggc2VxLl9fb25seVJ1bnNPbmNlID09PSB0cnVlICkge1xuICAgICAgICBpZiggc2VxLl9fdmFsdWVzUGhhc2UgPT09IHNlcS52YWx1ZXMubGVuZ3RoICkge1xuICAgICAgICAgIHNlcS5zdG9wKClcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYoIHNlcS5fX3JlcGVhdENvdW50ICE9PSBudWxsICkge1xuICAgICAgICBpZiggc2VxLl9fdmFsdWVzUGhhc2UgJSBzZXEudmFsdWVzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICBzZXEuX19yZXBlYXRDb3VudC0tXG4gICAgICAgICAgaWYoIHNlcS5fX3JlcGVhdENvdW50ID09PSAwICkge1xuICAgICAgICAgICAgc2VxLnN0b3AoKVxuICAgICAgICAgICAgc2VxLl9fcmVwZWF0Q291bnQgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2YgdGltaW5nID09PSAnZnVuY3Rpb24nICkgdGltaW5nID0gdGltaW5nKClcblxuICAgICAgLy8gWFhYIHRoaXMgc3VwcG9ydHMgYW4gZWRnZSBjYXNlIGluIEdpYmJlciwgd2hlcmUgcGF0dGVybnMgbGlrZSBFdWNsaWQgLyBIZXggcmV0dXJuXG4gICAgICAvLyBvYmplY3RzIGluZGljYXRpbmcgYm90aCB3aGV0aGVyIG9yIG5vdCB0aGV5IHNob3VsZCBzaG91bGQgdHJpZ2dlciB2YWx1ZXMgYXMgd2VsbFxuICAgICAgLy8gYXMgdGhlIG5leHQgdGltZSB0aGV5IHNob3VsZCBydW4uIHBlcmhhcHMgdGhpcyBjb3VsZCBiZSBtYWRlIG1vcmUgZ2VuZXJhbGl6YWJsZT9cbiAgICAgIGlmKCB0aW1pbmcgIT09IG51bGwgKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGltaW5nID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICBpZiggdGltaW5nLnNob3VsZEV4ZWN1dGUgPT09IDEgKSB7XG4gICAgICAgICAgICBzaG91bGRSdW4gPSB0cnVlXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzaG91bGRSdW4gPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1pbmcgPSB0aW1pbmcudGltZSBcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWluZyAqPSBzZXEucmF0ZVxuICAgICAgfWVsc2V7XG4gICAgICAgIHNob3VsZFJ1biA9IGZhbHNlIFxuICAgICAgfVxuXG4gICAgICBpZiggdmFsdWUgPT09IFNlcXVlbmNlci5ET19OT1RfT1VUUFVUICkgc2hvdWxkUnVuID0gZmFsc2VcblxuICAgICAgaWYoIHNob3VsZFJ1biApIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIGlmKCBzZXEubWFpbnRocmVhZG9ubHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggJ21haW4gdGhyZWFkIG9ubHknIClcbiAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggc2VxLm1haW50aHJlYWRvbmx5LCBzZXEua2V5LCB2YWx1ZSApXG4gICAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXEudGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB2YWx1ZSgpXG4gICAgICAgICAgfWVsc2UgaWYoIHR5cGVvZiBzZXEudGFyZ2V0WyBzZXEua2V5IF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCBzZXEua2V5LCBzZXEudGFyZ2V0IClcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgICAgIGlmKCB2YWx1ZSAhPT0gc2VxLkROUiApXG4gICAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSggdmFsdWUgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgICAgaWYoIHZhbHVlICE9PSBzZXEuRE5SIClcbiAgICAgICAgICAgICAgc2VxLnRhcmdldFsgc2VxLmtleSBdID0gdmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggc2VxLnJlcG9ydE91dHB1dCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGFkZHJlc3M6J19fc2VxdWVuY2VyJyxcbiAgICAgICAgICAgICAgaWQ6IHNlcS5pZCxcbiAgICAgICAgICAgICAgbmFtZTonb3V0cHV0JyxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHBoYXNlOiBzZXEuX192YWx1ZXNQaGFzZSxcbiAgICAgICAgICAgICAgbGVuZ3RoOiBzZXEudmFsdWVzLmxlbmd0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGBBIHNlcXVlbmNlIHRhcmdldGluZyAke3NlcS50YXJnZXQudWdlbk5hbWV9LiR7c2VxLmtleX0gY29udGFpbnMgYW4gaW1wcm9wZXIgdmFsdWUgYW5kIHdpbGwgYmUgc3RvcHBlZC5gIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICkge1xuICAgICAgICBpZiggc2VxLl9faXNSdW5uaW5nID09PSB0cnVlICYmICFpc05hTiggdGltaW5nICkgJiYgc2VxLmF1dG90cmlnID09PSBmYWxzZSApIHtcbiAgICAgICAgICB0aW1pbmcgKz0gZmxvYXRFcnJvclxuICAgICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCB0aW1pbmcsIHNlcS50aWNrLCBzZXEucHJpb3JpdHkgKVxuICAgICAgICAgIGZsb2F0RXJyb3IgPSB0aW1pbmcgLSBNYXRoLmZsb29yKCB0aW1pbmcgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmaXJlKCl7XG4gICAgICBsZXQgdmFsdWUgID0gdHlwZW9mIHRoaXMudmFsdWVzICA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudmFsdWVzICA6IHRoaXMudmFsdWVzWyB0aGlzLl9fdmFsdWVzUGhhc2UrKyAgJSB0aGlzLnZhbHVlcy5sZW5ndGggIF1cbiAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdGhpcy50YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdmFsdWUoKVxuICAgICAgfWVsc2UgaWYoIHR5cGVvZiB0aGlzLnRhcmdldFsgdGhpcy5rZXkgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlKClcbiAgICAgICAgfVxuICAgICAgICBpZiggdmFsdWUgIT09IHRoaXMuRE5SICkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0WyB0aGlzLmtleSBdKCB2YWx1ZSApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkgdmFsdWUgPSB2YWx1ZSgpXG4gICAgICAgIGlmKCB2YWx1ZSAhPT0gdGhpcy5ETlIgKVxuICAgICAgICAgIHRoaXMudGFyZ2V0WyB0aGlzLmtleSBdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhcnQoIGRlbGF5ID0gMCApIHtcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgJiYgc2VxLl9faXNSdW5uaW5nID09PSBmYWxzZSApIHtcbiAgICAgICAgR2liYmVyaXNoLnNjaGVkdWxlci5hZGQoIFxuICAgICAgICAgIGRlbGF5LCBcbiAgICAgICAgICBwcmlvcml0eSA9PiB7XG4gICAgICAgICAgICBzZXEudGljayggcHJpb3JpdHkgKVxuICAgICAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgYWRkcmVzczonX19zZXF1ZW5jZXInLFxuICAgICAgICAgICAgICBpZDogc2VxLmlkLFxuICAgICAgICAgICAgICBuYW1lOidzdGFydCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgc2VxLnByaW9yaXR5IFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBzZXEuX19pc1J1bm5pbmcgPSB0cnVlXG4gICAgICBzZXEuX19kZWxheSA9IGRlbGF5XG4gICAgICByZXR1cm4gX19zZXFcbiAgICB9LFxuXG4gICAgc3RvcCggZGVsYXkgPSBudWxsICkge1xuICAgICAgaWYoIGRlbGF5ID09PSBudWxsICkge1xuICAgICAgICBzZXEuX19pc1J1bm5pbmcgPSBmYWxzZVxuXG4gICAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3Byb2Nlc3NvcicgKSB7XG4gICAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6J19fc2VxdWVuY2VyJyxcbiAgICAgICAgICAgIGlkOiBzZXEuaWQsXG4gICAgICAgICAgICBuYW1lOidzdG9wJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfWVsc2V7XG4gICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBkZWxheSwgc2VxLnN0b3AgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9fc2VxXG4gICAgfSxcblxuICAgIG9uY2UoKSB7XG4gICAgICBzZXEuX19vbmx5UnVuc09uY2UgPSB0cnVlXG4gICAgICByZXR1cm4gX19zZXFcbiAgICB9LFxuXG4gICAgcmVwZWF0KCByZXBlYXRDb3VudCA9IDIgKSB7XG4gICAgICBzZXEuX19yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50XG4gICAgICByZXR1cm4gX19zZXFcbiAgICB9XG4gIH1cblxuICBwcm9wcy5pZCA9IEdpYmJlcmlzaC5mYWN0b3J5LmdldFVJRCgpXG5cbiAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgKSB7XG4gICAgR2liYmVyaXNoLnV0aWxpdGllcy5jcmVhdGVQdWJTdWIoIHNlcSApXG4gIH1lbHNle1xuICAgIC8vIG5lZWQgYSBzZXBhcmF0ZSByZWZlcmVuY2UgdG8gdGhlIHByb3BlcnRpZXMgZm9yIHdvcmtsZXQgbWV0YS1wcm9ncmFtbWluZ1xuICAgIGlmKCB0eXBlb2YgcHJvcHMudmFsdWVzID09PSAnb2JqZWN0JyAmJiBwcm9wcy52YWx1ZXMucmVxdWlyZXNSZW5kZXIgPT09IHRydWUgKSB7XG4gICAgICBwcm9wcy52YWx1ZXMgPSByZW5kZXJGbmMoIHByb3BzLnZhbHVlcyApXG4gICAgfVxuICAgIGlmKCBwcm9wcy50aW1pbmdzICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy50aW1pbmdzID09PSAnb2JqZWN0JyAmJiBwcm9wcy50aW1pbmdzLnJlcXVpcmVzUmVuZGVyID09PSB0cnVlICkge1xuICAgICAgcHJvcHMudGltaW5ncyA9IHJlbmRlckZuYyggcHJvcHMudGltaW5ncyApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBTZXF1ZW5jZXIuZGVmYXVsdHMsIHByb3BzIClcbiAgT2JqZWN0LmFzc2lnbiggc2VxLCBwcm9wZXJ0aWVzICkgXG4gIHNlcS5fX3Byb3BlcnRpZXNfXyA9IHByb3BlcnRpZXNcblxuICBfX3NlcSA9ICBwcm94eSggWydTZXF1ZW5jZXInXSwgcHJvcGVydGllcywgc2VxIClcblxuICByZXR1cm4gX19zZXFcbn1cblxuU2VxdWVuY2VyLmRlZmF1bHRzID0geyBwcmlvcml0eToxMDAsIHJhdGU6MSwgcmVwb3J0T3V0cHV0OmZhbHNlLCBhdXRvdHJpZzpmYWxzZSB9XG5cblNlcXVlbmNlci5tYWtlID0gZnVuY3Rpb24oIHZhbHVlcywgdGltaW5ncywgdGFyZ2V0LCBrZXksIHByaW9yaXR5LCByZXBvcnRPdXRwdXQgKSB7XG4gIHJldHVybiBTZXF1ZW5jZXIoeyB2YWx1ZXMsIHRpbWluZ3MsIHRhcmdldCwga2V5LCBwcmlvcml0eSwgcmVwb3J0T3V0cHV0IH0pXG59XG5cblNlcXVlbmNlci5ET19OT1RfT1VUUFVUID0gLTk4NzY1NDMyMVxuXG5yZXR1cm4gU2VxdWVuY2VyXG5cbn1cbiIsImNvbnN0IF9fcHJveHkgPSByZXF1aXJlKCAnLi4vd29ya2xldFByb3h5LmpzJyApXG5jb25zdCBQYXR0ZXJuID0gcmVxdWlyZSggJ3RpZGFsLnBlZ2pzJyApXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIEdpYmJlcmlzaCApIHtcblxuY29uc3QgcHJveHkgPSBfX3Byb3h5KCBHaWJiZXJpc2ggKVxuXG5jb25zdCBTZXF1ZW5jZXIgPSBwcm9wcyA9PiB7XG4gIGxldCBfX3NlcVxuICBjb25zdCBzZXEgPSB7XG4gICAgX19pc1J1bm5pbmc6ZmFsc2UsXG5cbiAgICBfX3BoYXNlOiAgMCxcbiAgICBfX3R5cGU6J3NlcScsXG4gICAgX19wYXR0ZXJuOiBQYXR0ZXJuKCBwcm9wcy5wYXR0ZXJuLCB7IGFkZExvY2F0aW9uczp0cnVlLCBhZGRVSUQ6dHJ1ZSwgZW5jbG9zZTp0cnVlIH0pLFxuICAgIF9fZXZlbnRzOiBudWxsLFxuXG4gICAgdGljayggcHJpb3JpdHkgKSB7XG4gICAgICAvLyBydW5uaW5nIGZvciBmaXJzdCB0aW1lLCBwZXJmb3JtIGEgcXVlcnlcbiAgICAgIGlmKCBzZXEuX19ldmVudHMgPT09IG51bGwgfHwgc2VxLl9fZXZlbnRzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgc2VxLl9fZXZlbnRzID0gc2VxLl9fcGF0dGVybi5xdWVyeSggc2VxLl9fcGhhc2UrKywgMSApXG4gICAgICB9XG5cbiAgICAgIC8vIHVzZWQgd2hlbiBzY2hlZHVsaW5nIGV2ZW50cyB0aGF0IGFyZSB2ZXJ5IGZhciBhcGFydFxuICAgICAgaWYoIHNlcS5fX2V2ZW50cy5sZW5ndGggPD0gMCApIHtcbiAgICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgICBpZiggc2VxLl9faXNSdW5uaW5nID09PSB0cnVlICApIHtcbiAgICAgICAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyBTZXF1ZW5jZXIuY2xvY2suY3BzLCBzZXEudGljaywgc2VxLnByaW9yaXR5IClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBzZXEuX19ldmVudHNbIDAgXS5hcmMuc3RhcnRcblxuICAgICAgaWYoIHNlcS5rZXkgIT09ICdjaG9yZCcgKSB7XG4gICAgICAgIHdoaWxlKCBzZXEuX19ldmVudHMubGVuZ3RoID4gMCAmJiBzdGFydFRpbWUudmFsdWVPZigpID09PSBzZXEuX19ldmVudHNbMF0uYXJjLnN0YXJ0LnZhbHVlT2YoKSApIHtcbiAgICAgICAgICBsZXQgZXZlbnQgID0gc2VxLl9fZXZlbnRzLnNoaWZ0KCksXG4gICAgICAgICAgICAgIHZhbHVlICA9IGV2ZW50LnZhbHVlLFxuICAgICAgICAgICAgICB1aWQgICAgPSBldmVudC51aWRcblxuICAgICAgICAgIC8vIGZvciBiam9ya2x1bmQgZXRjLlxuICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICkgdmFsdWUgPSB2YWx1ZS52YWx1ZVxuXG4gICAgICAgICAgaWYoIHNlcS5maWx0ZXJzICE9PSBudWxsICkgdmFsdWUgPSBzZXEuZmlsdGVycy5yZWR1Y2UoIChjdXJyZW50VmFsdWUsIGZpbHRlcikgPT4gZmlsdGVyKCBjdXJyZW50VmFsdWUsIHNlcSwgdWlkICksIHZhbHVlICkgIFxuICAgICAgICAgIGlmKCBzZXEubWFpbnRocmVhZG9ubHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2liYmVyaXNoLnByb2Nlc3Nvci5tZXNzYWdlcy5wdXNoKCBzZXEubWFpbnRocmVhZG9ubHksIHNlcS5rZXksIHZhbHVlIClcbiAgICAgICAgICB9ZWxzZSBpZiggdHlwZW9mIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSggdmFsdWUgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc2VxLnRhcmdldFsgc2VxLmtleSBdID0gdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBsZXQgdmFsdWUgPSBzZXEuX19ldmVudHMuZmlsdGVyKCBldnQgPT4gc3RhcnRUaW1lLnZhbHVlT2YoKSA9PT0gZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgKS5tYXAoIGV2dCA9PiBldnQudmFsdWUgKVxuICAgICAgICBsZXQgdWlkID0gc2VxLl9fZXZlbnRzWzBdLnVpZFxuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHNlcS5fX2V2ZW50cy5zcGxpY2UoIDAsIHZhbHVlLmxlbmd0aCApXG5cbiAgICAgICAgaWYoIHNlcS5maWx0ZXJzICE9PSBudWxsICkge1xuICAgICAgICAgIGlmKCB2YWx1ZS5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNlcS5maWx0ZXJzLnJlZHVjZSggKGN1cnJlbnRWYWx1ZSwgZmlsdGVyKSA9PiBmaWx0ZXIoIGN1cnJlbnRWYWx1ZSwgc2VxLCB1aWQgKSwgdmFsdWUgKSAgXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCAodixpKSA9PiBzZXEuZmlsdGVycy5yZWR1Y2UoIChjdXJyZW50VmFsdWUsIGZpbHRlcikgPT4gZmlsdGVyKCBjdXJyZW50VmFsdWUsIHNlcSwgZXZlbnRzWyBpIF0udWlkICksIHYgKSApXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHR5cGVvZiBzZXEudGFyZ2V0WyBzZXEua2V5IF0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgc2VxLnRhcmdldFsgc2VxLmtleSBdKCB2YWx1ZSApXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHNlcS50YXJnZXRbIHNlcS5rZXkgXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAncHJvY2Vzc29yJyApIHtcbiAgICAgICAgbGV0IHRpbWluZ1xuICAgICAgICBpZiggc2VxLl9fZXZlbnRzLmxlbmd0aCA8PSAwICkge1xuICAgICAgICAgIGxldCB0aW1lID0gMFxuICAgICAgICAgIHdoaWxlKCBzZXEuX19ldmVudHMubGVuZ3RoIDw9IDAgKSB7XG4gICAgICAgICAgICBzZXEuX19ldmVudHMgPSBzZXEuX19wYXR0ZXJuLnF1ZXJ5KCBzZXEuX19waGFzZSsrLCAxIClcbiAgICAgICAgICAgIHRpbWUrK1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3NlcS5fX2V2ZW50cy5mb3JFYWNoKCBldnQgPT4ge1xuICAgICAgICAgIC8vICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5hZGQoIDEgKS5zdWIoIHN0YXJ0VGltZSApIFxuICAgICAgICAgIC8vICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQuYWRkKCAxICkuc3ViKCBzdGFydFRpbWUgKVxuICAgICAgICAgIC8vfSlcblxuICAgICAgICAgIHRpbWluZyA9IHRpbWUgLSBzdGFydFRpbWUudmFsdWVPZigpIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aW1pbmcgPSBzZXEuX19ldmVudHNbMF0uYXJjLnN0YXJ0LnN1Yiggc3RhcnRUaW1lICkudmFsdWVPZigpIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aW1pbmcgKj0gTWF0aC5jZWlsKCBHaWJiZXJpc2guY3R4LnNhbXBsZVJhdGUgLyBTZXF1ZW5jZXIuY2xvY2suY3BzICkgKyAxIFxuXG4gICAgICAgIGlmKCBzZXEuX19pc1J1bm5pbmcgPT09IHRydWUgJiYgIWlzTmFOKCB0aW1pbmcgKSAmJiB0aW1pbmcgPiAwICkge1xuICAgICAgICAgIC8vIFhYWCB0aGlzIHN1cHBvcnRzIGFuIGVkZ2UgY2FzZSBpbiBHaWJiZXIsIHdoZXJlIHBhdHRlcm5zIGxpa2UgRXVjbGlkIC8gSGV4IHJldHVyblxuICAgICAgICAgIC8vIG9iamVjdHMgaW5kaWNhdGluZyBib3RoIHdoZXRoZXIgb3Igbm90IHRoZXkgc2hvdWxkIHNob3VsZCB0cmlnZ2VyIHZhbHVlcyBhcyB3ZWxsXG4gICAgICAgICAgLy8gYXMgdGhlIG5leHQgdGltZSB0aGV5IHNob3VsZCBydW4uIHBlcmhhcHMgdGhpcyBjb3VsZCBiZSBtYWRlIG1vcmUgZ2VuZXJhbGl6YWJsZT9cbiAgICAgICAgICBcbiAgICAgICAgICAvL2lmKCB0eXBlb2YgdGltaW5nID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAvLyAgaWYoIHRpbWluZy5zaG91bGRFeGVjdXRlID09PSAxICkge1xuICAgICAgICAgIC8vICAgIHNob3VsZFJ1biA9IHRydWVcbiAgICAgICAgICAvLyAgfWVsc2V7XG4gICAgICAgICAgLy8gICAgc2hvdWxkUnVuID0gZmFsc2VcbiAgICAgICAgICAvLyAgfVxuICAgICAgICAgIC8vICB0aW1pbmcgPSB0aW1pbmcudGltZSBcbiAgICAgICAgICAvL31cblxuICAgICAgICAgIC8vdGltaW5nICo9IHNlcS5yYXRlXG5cbiAgICAgICAgICBHaWJiZXJpc2guc2NoZWR1bGVyLmFkZCggdGltaW5nLCBzZXEudGljaywgc2VxLnByaW9yaXR5IClcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICB9LFxuXG4gICAgcm90YXRlKCBhbXQgKSB7XG4gICAgICBzZXEuX19waGFzZSArPSBhbXRcbiAgICAgIHJldHVybiBfX3NlcSBcbiAgICB9LFxuXG4gICAgc3RhcnQoIGRlbGF5ID0gMCApIHtcbiAgICAgIHNlcS5fX2lzUnVubmluZyA9IHRydWVcbiAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCBkZWxheSwgc2VxLnRpY2ssIHNlcS5wcmlvcml0eSApXG4gICAgICByZXR1cm4gX19zZXFcbiAgICB9LFxuXG4gICAgc3RvcCgpIHtcbiAgICAgIHNlcS5fX2lzUnVubmluZyA9IGZhbHNlXG4gICAgICByZXR1cm4gX19zZXFcbiAgICB9LFxuXG4gICAgc2V0KCBwYXR0ZXJuU3RyaW5nICkge1xuICAgICAgc2VxLl9fcGF0dGVybiA9IFBhdHRlcm4oIHBhdHRlcm5TdHJpbmcsIHsgYWRkTG9jYXRpb25zOnRydWUsIGFkZFVJRDp0cnVlLCBlbmNsb3NlOnRydWUgfSlcblxuICAgIH1cbiAgfVxuXG4gIHByb3BzLmlkID0gR2liYmVyaXNoLmZhY3RvcnkuZ2V0VUlEKClcblxuICAvLyBuZWVkIGEgc2VwYXJhdGUgcmVmZXJlbmNlIHRvIHRoZSBwcm9wZXJ0aWVzIGZvciB3b3JrbGV0IG1ldGEtcHJvZ3JhbW1pbmdcbiAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oIHt9LCBTZXF1ZW5jZXIuZGVmYXVsdHMsIHByb3BzIClcbiAgT2JqZWN0LmFzc2lnbiggc2VxLCBwcm9wZXJ0aWVzICkgXG4gIHNlcS5fX3Byb3BlcnRpZXNfXyA9IHByb3BlcnRpZXNcblxuICBfX3NlcSA9ICBwcm94eSggWydUaWRhbCddLCBwcm9wZXJ0aWVzLCBzZXEgKVxuXG4gIHJldHVybiBfX3NlcVxufVxuXG5TZXF1ZW5jZXIuZGVmYXVsdHMgPSB7IHByaW9yaXR5OjEwMDAwMCwgcGF0dGVybjonJywgcmF0ZToxLCBmaWx0ZXJzOm51bGwgfVxuXG5TZXF1ZW5jZXIubWFrZSA9IGZ1bmN0aW9uKCB2YWx1ZXMsIHRpbWluZ3MsIHRhcmdldCwga2V5LCBwcmlvcml0eSApIHtcbiAgcmV0dXJuIFNlcXVlbmNlcih7IHZhbHVlcywgdGltaW5ncywgdGFyZ2V0LCBrZXksIHByaW9yaXR5IH0pXG59XG5cbmxldCBfX3VpZCA9IDBcblNlcXVlbmNlci5nZXRVSUQgPSAoKT0+IHtcbiAgcmV0dXJuIF9fdWlkKytcbn1cblxuU2VxdWVuY2VyLlBhdHRlcm4gPSBQYXR0ZXJuXG5cblNlcXVlbmNlci5jbG9jayA9IHsgY3BzOiAxIH1cblxuU2VxdWVuY2VyLmlkID0gR2liYmVyaXNoLnV0aWxpdGllcy5nZXRVSUQoKVxuXG5pZiggR2liYmVyaXNoLm1vZGUgPT09ICd3b3JrbGV0JyApIHtcbiAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgYWRkcmVzczonZXZhbCcsXG4gICAgY29kZTpgR2liYmVyaXNoLlRpZGFsLmNsb2NrLmlkID0gJHtTZXF1ZW5jZXIuaWR9OyBHaWJiZXJpc2gudWdlbnMuc2V0KCAke1NlcXVlbmNlci5pZH0sIEdpYmJlcmlzaC5UaWRhbC5jbG9jayApYFxuICB9KVxuICBcbiAgbGV0IGNwcyA9IDFcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBTZXF1ZW5jZXIsICdjcHMnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gY3BzIH0sXG4gICAgc2V0KHYpeyBcbiAgICAgIGNwcyA9IHZcbiAgICAgIGlmKCBHaWJiZXJpc2gubW9kZSA9PT0gJ3dvcmtsZXQnICkge1xuICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBhZGRyZXNzOidzZXQnLFxuICAgICAgICAgIG9iamVjdDpTZXF1ZW5jZXIuaWQsXG4gICAgICAgICAgbmFtZTonY3BzJyxcbiAgICAgICAgICB2YWx1ZTpjcHMgXG4gICAgICAgIH0pIFxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxucmV0dXJuIFNlcXVlbmNlclxuXG59XG4iLCJsZXQgR2liYmVyaXNoID0gbnVsbFxuXG5jb25zdCBfX3VnZW4gPSBmdW5jdGlvbiggX19HaWJiZXJpc2ggKSB7XG4gIGlmKCBfX0dpYmJlcmlzaCAhPT0gdW5kZWZpbmVkICYmIEdpYmJlcmlzaCA9PSBudWxsICkgR2liYmVyaXNoID0gX19HaWJiZXJpc2hcbiBcbiAgY29uc3QgcmVwbGFjZSA9IG9iaiA9PiB7XG4gICAgaWYoIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICkge1xuICAgICAgaWYoIG9iai5pZCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc29yLnVnZW5zLmdldCggb2JqLmlkIClcbiAgICAgIH0gXG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgY29uc3QgdWdlbiA9IHtcbiAgICBfX0dpYmJlcmlzaDpHaWJiZXJpc2gsXG5cbiAgICBmcmVlOmZ1bmN0aW9uKCkge1xuICAgICAgR2liYmVyaXNoLmdlbmlzaC5nZW4uZnJlZSggdGhpcy5ncmFwaCApXG4gICAgfSxcblxuICAgIHByaW50OmZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5sb2coIHRoaXMuY2FsbGJhY2sudG9TdHJpbmcoKSApXG4gICAgfSxcblxuICAgIGNvbm5lY3Q6ZnVuY3Rpb24oIHRhcmdldCwgbGV2ZWw9MSApIHtcbiAgICAgIGlmKCB0aGlzLmNvbm5lY3RlZCA9PT0gdW5kZWZpbmVkICkgdGhpcy5jb25uZWN0ZWQgPSBbXVxuXG4gICAgICAvL2xldCBpbnB1dCA9IGxldmVsID09PSAxID8gdGhpcyA6IEdpYmJlcmlzaC5iaW5vcHMuTXVsKCB0aGlzLCBsZXZlbCApXG4gICAgICBsZXQgaW5wdXQgPSB0aGlzXG5cbiAgICAgIGlmKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB0YXJnZXQgPSBHaWJiZXJpc2gub3V0cHV0IFxuXG5cbiAgICAgIC8vIFhYWCBJIGZvcmdvdCwgd2hlcmUgaXMgX19hZGRJbnB1dCBmb3VuZD8gQ2FuIHdlIGNvbnRyb2wgdGhlXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgaW5wdXQ/XG4gICAgICBpZiggdHlwZW9mIHRhcmdldC5fX2FkZElucHV0ID09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIHRhcmdldC5fX2FkZElucHV0KCBpbnB1dCApXG4gICAgICB9IGVsc2UgaWYoIHRhcmdldC5zdW0gJiYgdGFyZ2V0LnN1bS5pbnB1dHMgKSB7XG4gICAgICAgIHRhcmdldC5zdW0uaW5wdXRzLnB1c2goIGlucHV0IClcbiAgICAgIH0gZWxzZSBpZiggdGFyZ2V0LmlucHV0cyApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0LmlucHV0cy5pbmRleE9mKCBpbnB1dCApXG5cbiAgICAgICAgLy8gaWYgbm8gY29ubmVjdGlvbiBleGlzdHMuLi5cbiAgICAgICAgaWYoIGlkeCA9PT0gLTEgKSB7XG4gICAgICAgICAgdGFyZ2V0LmlucHV0cy51bnNoaWZ0KCBpbnB1dCwgbGV2ZWwsIGlucHV0LmlzU3RlcmVvIClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gLi4uIG90aGVyd2lzZSB1cGRhdGUgdGhlIGNvbm5lY3Rpb24ncyBsZXZlbCwgd2hpY2ggaXMgc3RvcmVkXG4gICAgICAgICAgLy8gb25lIGluZGV4IGhpZ2hlciBpbiB0aGUgaW5wdXQgbGlzdC5cbiAgICAgICAgICB0YXJnZXQuaW5wdXRzWyBpZHggKyAxIF0gPSBsZXZlbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuaW5wdXQgPSBpbnB1dFxuICAgICAgICB0YXJnZXQuaW5wdXRHYWluID0gbGV2ZWxcbiAgICAgIH1cblxuICAgICAgR2liYmVyaXNoLmRpcnR5KCB0YXJnZXQgKVxuXG4gICAgICB0aGlzLmNvbm5lY3RlZC5wdXNoKFsgdGFyZ2V0LCBpbnB1dCwgbGV2ZWwgXSlcbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZGlzY29ubmVjdDpmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgICAgaWYoIHRhcmdldCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB0aGlzLmNvbm5lY3RlZCApICkge1xuICAgICAgICAgIGZvciggbGV0IGNvbm5lY3Rpb24gb2YgdGhpcy5jb25uZWN0ZWQgKSB7XG4gICAgICAgICAgICBpZiggY29ubmVjdGlvblswXS5kaXNjb25uZWN0VWdlbiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uWzBdLmRpc2Nvbm5lY3RVZ2VuKCBjb25uZWN0aW9uWzFdIClcbiAgICAgICAgICAgIH1lbHNlIGlmKCBjb25uZWN0aW9uWzBdLmlucHV0ID09PSB0aGlzICkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uWzBdLmlucHV0ID0gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZC5sZW5ndGggPSAwXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0ZWQuZmluZCggdiA9PiB2WzBdID09PSB0YXJnZXQgKVxuICAgICAgICAvLyBpZiB0YXJnZXQgaXMgYSBidXMuLi5cbiAgICAgICAgaWYoIHRhcmdldC5kaXNjb25uZWN0VWdlbiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIGlmKCBjb25uZWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0YXJnZXQuZGlzY29ubmVjdFVnZW4oIGNvbm5lY3Rpb25bMV0gKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gbXVzdCBiZSBhbiBlZmZlY3QsIHNldCBpbnB1dCB0byAwXG4gICAgICAgICAgdGFyZ2V0LmlucHV0ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0SWR4ID0gdGhpcy5jb25uZWN0ZWQuaW5kZXhPZiggY29ubmVjdGlvbiApXG5cbiAgICAgICAgaWYoIHRhcmdldElkeCAhPT0gLTEgKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWQuc3BsaWNlKCB0YXJnZXRJZHgsIDEgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoYWluOmZ1bmN0aW9uKCB0YXJnZXQsIGxldmVsPTEgKSB7XG4gICAgICB0aGlzLmNvbm5lY3QoIHRhcmdldCxsZXZlbCApXG5cbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9LFxuXG4gICAgX19yZWRvR3JhcGg6ZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaXNTdGVyZW8gPSB0aGlzLmlzU3RlcmVvXG4gICAgICB0aGlzLl9fY3JlYXRlR3JhcGgoKVxuICAgICAgdGhpcy5jYWxsYmFjayA9IEdpYmJlcmlzaC5nZW5pc2guZ2VuLmNyZWF0ZUNhbGxiYWNrKCB0aGlzLmdyYXBoLCBHaWJiZXJpc2gubWVtb3J5LCBmYWxzZSwgdHJ1ZSApXG4gICAgICB0aGlzLmlucHV0TmFtZXMgPSBuZXcgU2V0KCBHaWJiZXJpc2guZ2VuaXNoLmdlbi5wYXJhbWV0ZXJzICkgXG4gICAgICB0aGlzLmNhbGxiYWNrLnVnZW5OYW1lID0gdGhpcy51Z2VuTmFtZVxuICAgICAgR2liYmVyaXNoLmRpcnR5KCB0aGlzIClcblxuICAgICAgLy8gaWYgY2hhbm5lbCBjb3VudCBoYXMgY2hhbmdlZCBhZnRlciByZWNvbXBpbGluZyBncmFwaC4uLlxuICAgICAgaWYoIGlzU3RlcmVvICE9PSB0aGlzLmlzU3RlcmVvICkge1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBhbnkgY29ubmVjdGlvbnMgYmVmb3JlIGl0ZXJhdGluZy4uLlxuICAgICAgICBpZiggdGhpcy5jb25uZWN0ZWQgPT09IHVuZGVmaW5lZCApIHJldHVyblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGJ1c3NlcyB0aGUgdWdlbiBpcyBjb25uZWN0ZWQgdG9cbiAgICAgICAgZm9yKCBsZXQgY29ubmVjdGlvbiBvZiB0aGlzLmNvbm5lY3RlZCApIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIGRpcnR5IGZsYWcgb2YgdGhlIGJ1c1xuICAgICAgICAgIEdpYmJlcmlzaC5kaXJ0eSggY29ubmVjdGlvblsgMCBdIClcblxuICAgICAgICAgIC8vIGNoZWNrIGZvciBpbnB1dHMgYXJyYXksIHdoaWNoIGluZGljYXRlcyBjb25uZWN0aW9uIGlzIHRvIGEgYnVzXG4gICAgICAgICAgaWYoIGNvbm5lY3Rpb25bMF0uaW5wdXRzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBpbnB1dCBpbiB0aGUgYnVzc2VzICdpbnB1dHMnIGFycmF5XG4gICAgICAgICAgICBjb25zdCBpbnB1dElkeCA9IGNvbm5lY3Rpb25bIDAgXS5pbnB1dHMuaW5kZXhPZiggY29ubmVjdGlvblsgMSBdIClcblxuICAgICAgICAgICAgLy8gYXNzdW1paW5nIGl0IGlzIGZvdW5kLi4uXG4gICAgICAgICAgICBpZiggaW5wdXRJZHggIT09IC0xICkge1xuICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc3RlcmVvIGZpZWxkXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25bIDAgXS5pbnB1dHNbIGlucHV0SWR4ICsgMiBdID0gdGhpcy5pc1N0ZXJlb1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIGlmKCBjb25uZWN0aW9uWzBdLmlucHV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBpZiggY29ubmVjdGlvblswXS5fX3JlZG9HcmFwaCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uWzBdLl9fcmVkb0dyYXBoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIHVnZW5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fdWdlblxuIiwiY29uc3QgZ2VuaXNoID0gcmVxdWlyZSggJ2dlbmlzaC5qcycgKSxcbiAgICAgIEFXUEYgPSByZXF1aXJlKCAnLi9leHRlcm5hbC9hdWRpb3dvcmtsZXQtcG9seWZpbGwuanMnIClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuXG5sZXQgdWlkID0gMFxuY29uc3QgdXRpbGl0aWVzID0ge1xuICBNYWtlOiBmdW5jdGlvbiggcHJvcHMgKXtcbiAgICBjb25zdCBuYW1lID0gcHJvcHMubmFtZSB8fCAnVWdlbicgKyAoTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSoxMDAwMCApIClcbiAgICBjb25zdCB0eXBlID0gcHJvcHMudHlwZSB8fCAnVWdlbidcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJvcHMucHJvcGVydGllcyB8fCB7fVxuICAgIGNvbnN0IGJsb2NrID0gYFxuICAgIGNvbnN0IHVnZW4gPSBPYmplY3QuY3JlYXRlKCBHaWJiZXJpc2gucHJvdG90eXBlc1sgJyR7dHlwZX0nIF0gKVxuICAgIGNvbnN0IGdyYXBoZm5jID0gJHtwcm9wcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpfVxuXG4gICAgY29uc3QgcHJveHkgPSBHaWJiZXJpc2guZmFjdG9yeSggdWdlbiwgZ3JhcGhmbmMoKSwgJyR7bmFtZX0nLCAke0pTT04uc3RyaW5naWZ5KHByb3BlcnRpZXMpfSApXG4gICAgaWYoIHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcgKSBPYmplY3QuYXNzaWduKCBwcm94eSwgcHJvcHMgKVxuXG4gICAgcmV0dXJuIHByb3h5YFxuXG4gICAgR2liYmVyaXNoWyBuYW1lIF0gPSBuZXcgRnVuY3Rpb24oICdwcm9wcycsIGJsb2NrIClcblxuICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgbmFtZSxcbiAgICAgIGFkZHJlc3M6J2FkZENvbnN0cnVjdG9yJyxcbiAgICAgIGNvbnN0cnVjdG9yU3RyaW5nOmBmdW5jdGlvbiggR2liYmVyaXNoICkge1xuICAgICAgY29uc3QgZm5jID0gJHtHaWJiZXJpc2hbIG5hbWUgXS50b1N0cmluZygpfVxuXG4gICAgICByZXR1cm4gZm5jXG4gICAgfWBcbiAgICB9KVxuXG4gICAgcmV0dXJuIEdpYmJlcmlzaFsgbmFtZSBdXG4gIH0sXG5cbiAgY3JlYXRlQ29udGV4dCggY3R4LCBjYiwgcmVzb2x2ZSwgYnVmZmVyU2l6ZT0yMDQ4ICkge1xuICAgIGxldCBBQyA9IHR5cGVvZiBBdWRpb0NvbnRleHQgPT09ICd1bmRlZmluZWQnID8gd2Via2l0QXVkaW9Db250ZXh0IDogQXVkaW9Db250ZXh0XG5cbiAgICBBV1BGKCB3aW5kb3csIGJ1ZmZlclNpemUgKVxuXG4gICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiggdHlwZW9mIEFDICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgdGhpcy5jdHggPSBHaWJiZXJpc2guY3R4ID0gY3R4ID09PSB1bmRlZmluZWQgPyBuZXcgQUMoeyBsYXRlbmN5SGludDouMDI1IH0pIDogY3R4XG5cbiAgICAgICAgZ2VuaXNoLmdlbi5zYW1wbGVyYXRlID0gdGhpcy5jdHguc2FtcGxlUmF0ZVxuICAgICAgICBnZW5pc2gudXRpbGl0aWVzLmN0eCA9IHRoaXMuY3R4XG5cbiAgICAgICAgaWYoIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgc3RhcnQgKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIHN0YXJ0IClcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBzdGFydCApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBteVNvdXJjZSA9IHV0aWxpdGllcy5jdHguY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICAgICAgbXlTb3VyY2UuY29ubmVjdCggdXRpbGl0aWVzLmN0eC5kZXN0aW5hdGlvbiApXG4gICAgICAgIG15U291cmNlLnN0YXJ0KClcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyApIGNiKCByZXNvbHZlIClcbiAgICB9XG5cbiAgICBpZiggZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIHN0YXJ0IClcbiAgICB9ZWxzZXtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgc3RhcnQgKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgc3RhcnQgKVxuICAgIH1cblxuICAgIHJldHVybiBHaWJiZXJpc2guY3R4XG4gIH0sXG4gIFxuICBjcmVhdGVXb3JrbGV0KCByZXNvbHZlICkge1xuICAgIEdpYmJlcmlzaC5jdHguYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSggR2liYmVyaXNoLndvcmtsZXRQYXRoICkudGhlbiggKCkgPT4ge1xuICAgICAgR2liYmVyaXNoLndvcmtsZXQgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZSggR2liYmVyaXNoLmN0eCwgJ2dpYmJlcmlzaCcsIHsgb3V0cHV0Q2hhbm5lbENvdW50OlsyXSB9IClcblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQuY29ubmVjdCggR2liYmVyaXNoLmN0eC5kZXN0aW5hdGlvbiApXG4gICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0Lm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBHaWJiZXJpc2gudXRpbGl0aWVzLndvcmtsZXRIYW5kbGVyc1sgZXZlbnQuZGF0YS5hZGRyZXNzIF1cbiAgICAgICAgaWYoIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIGNhbGxiYWNrKCBldmVudCApICAgICBcbiAgICAgIH1cbiAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnVnZW5zID0gbmV3IE1hcCgpXG5cbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0sXG5cbiAgZnV0dXJlKCBmbmMsIHRpbWUsIGRpY3QgKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBkaWN0IClcbiAgICBjb25zdCBjb2RlID0gYFxuICAgICAgY29uc3QgZm5jID0gJHtmbmMudG9TdHJpbmcoKX1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbJHtrZXlzLm1hcCgga2V5ID0+IHR5cGVvZiBkaWN0W2tleV0gPT09ICdvYmplY3QnID8gZGljdFsga2V5IF0uaWQgOiBgJyR7ZGljdFsga2V5XX0nYCApLmpvaW4oJywnKX1dXG4gICAgICBjb25zdCBvYmpzID0gYXJncy5tYXAoIHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInID8gR2liYmVyaXNoLnByb2Nlc3Nvci51Z2Vucy5nZXQodikgOiB2IClcbiAgICAgIEdpYmJlcmlzaC5zY2hlZHVsZXIuYWRkKCAke3RpbWV9LCAoKT0+IGZuYyggLi4ub2JqcyApLCAxIClcbiAgICBgIFxuICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgIGFkZHJlc3M6J2V2YWwnLCBcbiAgICAgIGNvZGVcbiAgICB9KVxuICB9LFxuXG4gIHdvcmtsZXRIYW5kbGVyczoge1xuICAgIHBoYXNlKCBldmVudCApIHtcbiAgICAgIEdpYmJlcmlzaC5waGFzZSA9IGV2ZW50LmRhdGEudmFsdWVcbiAgICAgIGlmKCB0eXBlb2YgR2liYmVyaXNoLm9ucGhhc2V1cGRhdGUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIEdpYmJlcmlzaC5vbnBoYXNldXBkYXRlKCBHaWJiZXJpc2gucGhhc2UgKVxuICAgICAgfVxuICAgIH0sXG4gICAgX19zZXF1ZW5jZXIoIGV2ZW50ICkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGFcbiAgICAgIGNvbnN0IGlkID0gbWVzc2FnZS5pZFxuICAgICAgY29uc3QgZXZlbnROYW1lID0gbWVzc2FnZS5uYW1lXG4gICAgICBjb25zdCBvYmogPSBHaWJiZXJpc2gud29ya2xldC51Z2Vucy5nZXQoIGlkIClcbiAgICAgIGlmKCBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmoucHVibGlzaCAhPT0gdW5kZWZpbmVkIClcbiAgICAgICAgb2JqLnB1Ymxpc2goIGV2ZW50TmFtZSwgbWVzc2FnZSApXG4gICAgfSxcbiAgICBjYWxsYmFjayggZXZlbnQgKSB7XG4gICAgICBpZiggdHlwZW9mIEdpYmJlcmlzaC5vbmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBHaWJiZXJpc2gub25jYWxsYmFjayggZXZlbnQuZGF0YS5jb2RlIClcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCggZXZlbnQgKSB7XG4gICAgICBsZXQgbmFtZSA9IGV2ZW50LmRhdGEubmFtZVxuICAgICAgbGV0IHZhbHVlXG4gICAgICBpZiggbmFtZVswXSA9PT0gJ0dpYmJlcmlzaCcgKSB7XG4gICAgICAgIHZhbHVlID0gR2liYmVyaXNoXG4gICAgICAgIG5hbWUuc2hpZnQoKVxuICAgICAgfVxuICAgICAgZm9yKCBsZXQgc2VnbWVudCBvZiBuYW1lICkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlWyBzZWdtZW50IF1cbiAgICAgIH1cblxuICAgICAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGFkZHJlc3M6J3NldCcsXG4gICAgICAgIG5hbWU6J0dpYmJlcmlzaC4nICsgbmFtZS5qb2luKCcuJyksXG4gICAgICAgIHZhbHVlXG4gICAgICB9KVxuICAgIH0sXG4gICAgc3RhdGUoIGV2ZW50ICl7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IGV2ZW50LmRhdGEubWVzc2FnZXNcbiAgICAgIGlmKCBtZXNzYWdlcy5sZW5ndGggPT09IDAgKSByZXR1cm5cblxuICAgICAgLy8gWFhYIGlzIHByZXZlbnRQcm94eSBhY3R1YWxseSB1c2VkP1xuICAgICAgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9IHRydWVcbiAgICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSBmYWxzZVxuXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIHdoaWxlKCBpIDwgbWVzc2FnZXMubGVuZ3RoICkge1xuICAgICAgICBjb25zdCBpZCA9IG1lc3NhZ2VzWyBpIF0gXG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gbWVzc2FnZXNbIGkgKyAxIF1cbiAgICAgICAgY29uc3QgdmFsdWVMID0gbWVzc2FnZXNbIGkgKyAyIF1cbiAgICAgICAgY29uc3QgdmFsdWVSID0gbWVzc2FnZXNbIGkgKyAzIF1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUxcbiAgICAgICAgY29uc3Qgb2JqID0gR2liYmVyaXNoLndvcmtsZXQudWdlbnMuZ2V0KCBpZCApXG5cbiAgICAgICAgaWYoIEdpYmJlcmlzaC53b3JrbGV0LmRlYnVnID09PSB0cnVlICkge1xuICAgICAgICAgIGlmKCBwcm9wTmFtZSAhPT0gJ291dHB1dCcgKSBjb25zb2xlLmxvZyggcHJvcE5hbWUsIHZhbHVlLCBpZCApXG4gICAgICAgIH1cblxuICAgICAgICBpZiggdHlwZW9mIHByb3BOYW1lICE9PSAnc3RyaW5nJyApIGNvbnRpbnVlXG4gICAgICAgIFxuICAgICAgICBpZiggb2JqICE9PSB1bmRlZmluZWQgJiYgcHJvcE5hbWUuaW5kZXhPZignLicpID09PSAtMSAmJiBwcm9wTmFtZSAhPT0gJ2lkJyApIHsgXG4gICAgICAgICAgaWYoIG9ialsgcHJvcE5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBvYmpbIHByb3BOYW1lIF0gIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIGlmKCBwcm9wTmFtZSA9PT0gJ291dHB1dCcgKSB7XG4gICAgICAgICAgICAgICAgb2JqWyBwcm9wTmFtZSBdID0gWyB2YWx1ZUwsIHZhbHVlUiBdXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG9ialsgcHJvcE5hbWUgXSA9IHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBvYmpbIHByb3BOYW1lIF0oIHZhbHVlIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG9ialsgcHJvcE5hbWUgXSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSBpZiggb2JqICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgY29uc3QgcHJvcFNwbGl0ID0gcHJvcE5hbWUuc3BsaXQoJy4nKVxuICAgICAgICAgIGlmKCBvYmpbIHByb3BTcGxpdFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGlmKCBwcm9wU3BsaXRbMV0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgaWYoIHR5cGVvZiBvYmpbIHByb3BTcGxpdFsgMCBdIF1bIHByb3BTcGxpdFsgMSBdIF0gIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgb2JqWyBwcm9wU3BsaXRbIDAgXSBdWyBwcm9wU3BsaXRbIDEgXSBdID0gdmFsdWVcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgb2JqWyBwcm9wU3BsaXRbIDAgXSBdWyBwcm9wU3BsaXRbIDEgXSBdKCB2YWx1ZSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coICd1bmRlZmluZWQgc3BsaXQgcHJvcGVydHkhJywgaWQsIHByb3BTcGxpdFswXSwgcHJvcFNwbGl0WzFdLCB2YWx1ZSwgb2JqIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gWFhYIGRvdWJsZSBjaGVjayBhbmQgbWFrZSBzdXJlIHRoaXMgaXNuJ3QgZ2V0dGluZyBzZW50IGJhY2sgdG8gcHJvY2Vzc29ybm9kZS4uLlxuICAgICAgICAvLyBjb25zb2xlLmxvZyggcHJvcE5hbWUsIHZhbHVlLCBvYmogKVxuICAgICAgICBpICs9IHByb3BOYW1lID09PSAnb3V0cHV0JyA/IDQgOiAzXG4gICAgICB9XG4gICAgICBHaWJiZXJpc2gucHJldmVudFByb3h5ID0gZmFsc2VcbiAgICAgIEdpYmJlcmlzaC5wcm94eUVuYWJsZWQgPSB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVB1YlN1Yiggb2JqICkge1xuICAgIGNvbnN0IGV2ZW50cyA9IHt9XG4gICAgb2JqLm9uID0gZnVuY3Rpb24oIGtleSwgZmNuICkge1xuICAgICAgaWYoIHR5cGVvZiBldmVudHNbIGtleSBdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgZXZlbnRzWyBrZXkgXSA9IFtdXG4gICAgICB9XG4gICAgICBldmVudHNbIGtleSBdLnB1c2goIGZjbiApXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgb2JqLm9mZiA9IGZ1bmN0aW9uKCBrZXksIGZjbiApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGV2ZW50c1sga2V5IF1cblxuICAgICAgICBhcnIuc3BsaWNlKCBhcnIuaW5kZXhPZiggZmNuICksIDEgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIG9iai5wdWJsaXNoID0gZnVuY3Rpb24oIGtleSwgZGF0YSApIHtcbiAgICAgIGlmKCB0eXBlb2YgZXZlbnRzWyBrZXkgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGV2ZW50c1sga2V5IF1cblxuICAgICAgICBhcnIuZm9yRWFjaCggdiA9PiB2KCBkYXRhICkgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfSxcblxuICB3cmFwKCBmdW5jLCAuLi5hcmdzICkge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIGFjdGlvbjond3JhcCcsXG4gICAgICB2YWx1ZTpmdW5jLFxuICAgICAgLy8gbXVzdCByZXR1cm4gb2JqZWN0cyBjb250YWluaW5nIG9ubHkgdGhlIGlkIG51bWJlciB0byBhdm9pZFxuICAgICAgLy8gY3JlYXRpbmcgY2lyY3VsYXIgSlNPTiByZWZlcmVuY2VzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gcGFzc2luZyBhY3R1YWwgdWdlbnNcbiAgICAgIGFyZ3M6IGFyZ3MubWFwKCB2ID0+IHsgcmV0dXJuIHsgaWQ6di5pZCB9IH0pXG4gICAgfVxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuICAvLyBmb3Igd3JhcHBpbmcgdXB2YWx1ZXMgaW4gYSBkaWN0aW9uYXJ5IGFuZCBwYXNzaW5nIGZ1bmN0aW9uIGFjcm9zcyB0aHJlYWRcbiAgLy8gdG8gYmUgcmVjb25zdHJ1Y3RlZC5cbiAgLy8gZXg7IHdyYXBwZWQgPSBmbiggKCk9PiB7IHJldHVybiBNYXRoLnJhbmRvbSgpICogdGVzdCB9LCB7IHRlc3Q6MjAgfSlcbiAgLy8gc3luLm5vdGUuc2VxKCB3cmFwcGVkLCAxLzQgKVxuICBmbiggZm5jLCBkaWN0PXt9KSB7XG4gICAgY29uc3QgZm5jc3RyID0gZm5jLnRvU3RyaW5nKClcbiAgICBjb25zdCBmaXJzdEJyYWNrZXRJZHggPSBmbmNzdHIuaW5kZXhPZigneycpXG4gICAgY29uc3QgY29kZSA9IGZuY3N0ci5zbGljZShmaXJzdEJyYWNrZXRJZHgrMSwgLTEgKVxuICAgIGNvbnN0IHMgPSB7IHJlcXVpcmVzUmVuZGVyOnRydWUsIGZpbHRlcnM6W10sIGZuY3N0cjpjb2RlLCBhcmdzOltdLCBkaWN0LCBhZGRGaWx0ZXIoIGYgKSB7IHRoaXMuZmlsdGVycy5wdXNoKGYpIH0gfSAgXG4gICAgcmV0dXJuIHNcbiAgfSxcblxuICBydW4oIGZuYyApIHsgXG4gICAgY29uc3Qgc3RyID0gZm5jLnRvc3RyaW5nKClcbiAgICBjb25zdCBpZHggPSBzdHIuaW5kZXhvZignPT4nKSArIDJcbiAgICBjb25zdCBjb2RlID0gc3RyLnNsaWNlKCBpZHggKS50cmltKClcbiAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICBhZGRyZXNzOidldmFsJyxcbiAgICAgIGNvZGVcbiAgICB9KVxuICB9LFxuXG4gIGV4cG9ydCggb2JqICkge1xuICAgIG9iai53cmFwID0gdGhpcy53cmFwXG4gICAgb2JqLmZ1dHVyZSA9IHRoaXMuZnV0dXJlXG4gICAgb2JqLk1ha2UgPSB0aGlzLk1ha2VcbiAgfSxcblxuICBnZXRVSUQoKSB7IHJldHVybiB1aWQrKyB9LFxuXG4gIGJhc2U2NCA6IHtcbiAgICBfa2V5U3RyIDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuICAgIC8vIHdpbGwgcmV0dXJuIGEgIFVpbnQ4QXJyYXkgdHlwZVxuICAgIGRlY29kZUFycmF5QnVmZmVyOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgYnl0ZXMgPSAoaW5wdXQubGVuZ3RoLzQpICogMztcbiAgICAgICAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcbiAgICAgICAgdGhpcy5kZWNvZGUoaW5wdXQsIGFiKTtcblxuICAgICAgICByZXR1cm4gYWI7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGlucHV0LCBhcnJheUJ1ZmZlcikge1xuICAgICAgLy9nZXQgbGFzdCBjaGFycyB0byBzZWUgaWYgYXJlIHZhbGlkXG4gICAgICB2YXIgbGtleTEgPSB0aGlzLl9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoLTEpKTtcdFx0IFxuICAgICAgdmFyIGxrZXkyID0gdGhpcy5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aC0yKSk7XHRcdCBcbiAgICAgIHZhciBieXRlcyA9IChpbnB1dC5sZW5ndGgvNCkgKiAzO1xuICAgICAgaWYgKGxrZXkxID09IDY0KSBieXRlcy0tOyAvL3BhZGRpbmcgY2hhcnMsIHNvIHNraXBcbiAgICAgIGlmIChsa2V5MiA9PSA2NCkgYnl0ZXMtLTsgLy9wYWRkaW5nIGNoYXJzLCBzbyBza2lwXG4gICAgICB2YXIgdWFycmF5O1xuICAgICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGlmIChhcnJheUJ1ZmZlcilcbiAgICAgICAgICB1YXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICBlbHNlXG4gICAgICAgICAgdWFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG4gICAgICBmb3IgKGk9MDsgaTxieXRlczsgaSs9Mykge1x0XG4gICAgICAgICAgLy9nZXQgdGhlIDMgb2N0ZWN0cyBpbiA0IGFzY2lpIGNoYXJzXG4gICAgICAgICAgZW5jMSA9IHRoaXMuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChqKyspKTtcbiAgICAgICAgICBlbmMyID0gdGhpcy5fa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGorKykpO1xuICAgICAgICAgIGVuYzMgPSB0aGlzLl9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaisrKSk7XG4gICAgICAgICAgZW5jNCA9IHRoaXMuX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChqKyspKTtcblxuICAgICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG4gICAgICAgICAgdWFycmF5W2ldID0gY2hyMTtcdFx0XHRcbiAgICAgICAgICBpZiAoZW5jMyAhPSA2NCkgdWFycmF5W2krMV0gPSBjaHIyO1xuICAgICAgICAgIGlmIChlbmM0ICE9IDY0KSB1YXJyYXlbaSsyXSA9IGNocjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdWFycmF5O1x0XG4gICAgfVxuICB9XG59XG5cbnJldHVybiB1dGlsaXRpZXNcblxufVxuIiwiY29uc3Qgc2VyaWFsaXplID0gcmVxdWlyZSgnc2VyaWFsaXplLWphdmFzY3JpcHQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBHaWJiZXJpc2ggKSB7XG5cbmNvbnN0IHJlcGxhY2VPYmogPSBmdW5jdGlvbiggb2JqLCBzaG91bGRTZXJpYWxpemVGdW5jdGlvbnMgPSB0cnVlICkge1xuICBpZiggdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIG9iai5pZCAhPT0gdW5kZWZpbmVkICkge1xuICAgIGlmKCBvYmouX190eXBlICE9PSAnc2VxJyApIHsgLy8gWFhYIHdoeT9cbiAgICAgIHJldHVybiB7IGlkOm9iai5pZCwgcHJvcDpvYmoucHJvcCB9XG4gICAgfWVsc2V7XG4gICAgICAvLyBzaG91bGRuJ3QgSSBiZSBzZXJpYWxpemluZyBtb3N0IG9iamVjdHMsIG5vdCBqdXN0IHNlcXM/XG4gICAgICByZXR1cm4gc2VyaWFsaXplKCBvYmogKVxuICAgIH1cbiAgfWVsc2UgaWYoIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgJiYgc2hvdWxkU2VyaWFsaXplRnVuY3Rpb25zID09PSB0cnVlICkge1xuICAgIHJldHVybiB7IGlzRnVuYzp0cnVlLCB2YWx1ZTpzZXJpYWxpemUoIG9iaiApIH1cbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbmNvbnN0IG1ha2VBbmRTZW5kT2JqZWN0ID0gZnVuY3Rpb24oIF9fbmFtZSwgdmFsdWVzLCBvYmogKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fVxuXG4gIC8vIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdGhyb3VnaCBtZXNzYWdlcG9ydC4uLlxuXG4gIGZvciggbGV0IGtleSBpbiB2YWx1ZXMgKSB7XG4gICAgY29uc3QgYWxyZWFkeVByb2Nlc3NlZCA9ICh0eXBlb2YgdmFsdWVzWyBrZXkgXSA9PT0gJ29iamVjdCcgJiYgdmFsdWVzWyBrZXkgXSAhPT0gbnVsbCAmJiB2YWx1ZXNbIGtleSBdLl9fbWV0YV9fICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAodHlwZW9mIHZhbHVlc1trZXldID09PSAnZnVuY3Rpb24nICYmIHZhbHVlc1sga2V5IF0uX19tZXRhX18gIT09IHVuZGVmaW5lZCApXG5cbiAgICBpZiggYWxyZWFkeVByb2Nlc3NlZCApIHsgXG4gICAgICBwcm9wZXJ0aWVzWyBrZXkgXSA9IHsgaWQ6dmFsdWVzWyBrZXkgXS5fX21ldGFfXy5pZCB9XG4gICAgfWVsc2UgaWYoIEFycmF5LmlzQXJyYXkoIHZhbHVlc1sga2V5IF0gKSApIHtcbiAgICAgIGNvbnN0IGFyciA9IFtdXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHZhbHVlc1sga2V5IF0ubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGFyclsgaSBdID0gcmVwbGFjZU9iaiggdmFsdWVzWyBrZXkgXVtpXSwgZmFsc2UgIClcbiAgICAgIH1cbiAgICAgIHByb3BlcnRpZXNbIGtleSBdID0gYXJyXG4gICAgfWVsc2UgaWYoIHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ29iamVjdCcgJiYgdmFsdWVzW2tleV0gIT09IG51bGwgKXtcbiAgICAgIHByb3BlcnRpZXNbIGtleSBdID0gcmVwbGFjZU9iaiggdmFsdWVzWyBrZXkgXSwgZmFsc2UgKVxuICAgIH1lbHNle1xuICAgICAgcHJvcGVydGllc1sga2V5IF0gPSB2YWx1ZXNbIGtleSBdXG4gICAgfVxuICB9XG5cbiAgbGV0IHNlcmlhbGl6ZWRQcm9wZXJ0aWVzID0gc2VyaWFsaXplKCBwcm9wZXJ0aWVzIClcblxuICBpZiggQXJyYXkuaXNBcnJheSggX19uYW1lICkgKSB7XG4gICAgY29uc3Qgb2xkTmFtZSA9IF9fbmFtZVsgX19uYW1lLmxlbmd0aCAtIDEgXVxuICAgIF9fbmFtZVsgX19uYW1lLmxlbmd0aCAtIDEgXSA9IG9sZE5hbWVbMF0udG9VcHBlckNhc2UoKSArIG9sZE5hbWUuc3Vic3RyaW5nKDEpXG4gIH1lbHNle1xuICAgIF9fbmFtZSA9IFsgX19uYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBfX25hbWUuc3Vic3RyaW5nKDEpIF1cbiAgfVxuXG4gIG9iai5fX21ldGFfXyA9IHtcbiAgICBhZGRyZXNzOidhZGQnLFxuICAgIG5hbWU6X19uYW1lLFxuICAgIHByb3BlcnRpZXM6c2VyaWFsaXplZFByb3BlcnRpZXMsIFxuICAgIGlkOm9iai5pZFxuICB9XG5cbiAgR2liYmVyaXNoLndvcmtsZXQudWdlbnMuc2V0KCBvYmouaWQsIG9iaiApXG5cbiAgR2liYmVyaXNoLndvcmtsZXQucG9ydC5wb3N0TWVzc2FnZSggb2JqLl9fbWV0YV9fIClcbn1cblxuY29uc3QgZG9Ob3RQcm94eSA9IFsgJ2Nvbm5lY3RlZCcsICdpbnB1dCcsICd3cmFwJywgJ2NhbGxiYWNrJywgJ2lucHV0TmFtZXMnLCAnb24nLCAnb2ZmJywncHVibGlzaCcgXVxuICAgXG5jb25zdCBfX3Byb3h5ID0gZnVuY3Rpb24oIF9fbmFtZSwgdmFsdWVzLCBvYmogKSB7XG5cbiAgaWYoIEdpYmJlcmlzaC5tb2RlID09PSAnd29ya2xldCcgJiYgR2liYmVyaXNoLnByZXZlbnRQcm94eSA9PT0gZmFsc2UgKSB7XG4gICAgbWFrZUFuZFNlbmRPYmplY3QoIF9fbmFtZSwgdmFsdWVzLCBvYmogKVxuXG4gICAgLy8gcHJveHkgZm9yIGFsbCBtZXRob2QgY2FsbHMgdG8gc2VuZCB0byB3b3JrbGV0XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoIG9iaiwge1xuICAgICAgZ2V0KCB0YXJnZXQsIHByb3AsIHJlY2VpdmVyICkge1xuICAgICAgICBpZiggdHlwZW9mIHRhcmdldFsgcHJvcCBdID09PSAnZnVuY3Rpb24nICYmIHByb3AuaW5kZXhPZignX18nKSA9PT0gLTEgJiYgZG9Ob3RQcm94eS5pbmRleE9mKCBwcm9wICkgPT09IC0xICkge1xuICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KCB0YXJnZXRbIHByb3AgXSwge1xuICAgICAgICAgICAgYXBwbHkoIF9fdGFyZ2V0LCB0aGlzQXJnLCBhcmdzICkge1xuXG4gICAgICAgICAgICAgIGlmKCBHaWJiZXJpc2gucHJveHlFbmFibGVkID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9fYXJncyA9IGFyZ3MubWFwKCBfX3ZhbHVlID0+IHJlcGxhY2VPYmooIF9fdmFsdWUsIHRydWUgKSApXG5cbiAgICAgICAgICAgICAgICBHaWJiZXJpc2gud29ya2xldC5wb3J0LnBvc3RNZXNzYWdlKHsgXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOidtZXRob2QnLCBcbiAgICAgICAgICAgICAgICAgIG9iamVjdDpvYmouaWQsXG4gICAgICAgICAgICAgICAgICBuYW1lOnByb3AsXG4gICAgICAgICAgICAgICAgICBhcmdzOl9fYXJnc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gR2liYmVyaXNoLnByb3h5RW5hYmxlZFxuICAgICAgICAgICAgICBHaWJiZXJpc2gucHJveHlFbmFibGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gIF9fdGFyZ2V0LmFwcGx5KCB0aGlzQXJnLCBhcmdzIClcbiAgICAgICAgICAgICAgR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9IHRlbXBcbiAgICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHByb3h5XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0WyBwcm9wIF1cbiAgICAgIH0sXG4gICAgICBzZXQoIHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyICkge1xuICAgICAgICBpZiggZG9Ob3RQcm94eS5pbmRleE9mKCBwcm9wICkgPT09IC0xICkgeyBcbiAgICAgICAgICBpZiggR2liYmVyaXNoLnByb3h5RW5hYmxlZCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIGNvbnN0IF9fdmFsdWUgPSByZXBsYWNlT2JqKCB2YWx1ZSApXG5cbiAgICAgICAgICAgIGlmKCBfX3ZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgIEdpYmJlcmlzaC53b3JrbGV0LnBvcnQucG9zdE1lc3NhZ2UoeyBcbiAgICAgICAgICAgICAgICBhZGRyZXNzOidzZXQnLCBcbiAgICAgICAgICAgICAgICBvYmplY3Q6b2JqLmlkLFxuICAgICAgICAgICAgICAgIG5hbWU6cHJvcCxcbiAgICAgICAgICAgICAgICB2YWx1ZTpfX3ZhbHVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0WyBwcm9wIF0gPSB2YWx1ZVxuXG4gICAgICAgIC8vIG11c3QgcmV0dXJuIHRydWUgZm9yIGFueSBFUzYgcHJveHkgc2V0dGVyXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFhYWCBYWFggWFhYIFhYWCBYWFggWFhYXG4gICAgLy8gUkVNRU1CRVIgVEhBVCBZT1UgTVVTVCBBU1NJR04gVEhFIFJFVFVSTkVEIFZBTFVFIFRPIFlPVVIgVUdFTixcbiAgICAvLyBZT1UgQ0FOTk9UIFVTRSBUSElTIEZVTkNUSU9OIFRPIE1PRElGWSBBIFVHRU4gSU4gUExBQ0UuXG4gICAgLy8gWFhYIFhYWCBYWFggWFhYIFhYWCBYWFhcblxuICAgIHJldHVybiBwcm94eVxuICB9ZWxzZSBpZiggR2liYmVyaXNoLm1vZGUgPT09ICdwcm9jZXNzb3InICYmIEdpYmJlcmlzaC5wcmV2ZW50UHJveHkgPT09IGZhbHNlICkge1xuXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoIG9iaiwge1xuICAgICAgLy9nZXQoIHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIgKSB7IHJldHVybiB0YXJnZXRbIHByb3AgXSB9LFxuICAgICAgc2V0KCB0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlciApIHtcbiAgICAgICAgbGV0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZVxuICAgICAgICBpZiggcHJvcC5pbmRleE9mKCdfXycpID09PSAtMSAmJiB2YWx1ZVR5cGUgIT09ICdmdW5jdGlvbicgJiYgdmFsdWVUeXBlICE9PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICBpZiggR2liYmVyaXNoLnByb2Nlc3NvciAhPT0gdW5kZWZpbmVkICkgeyBcbiAgICAgICAgICAgIEdpYmJlcmlzaC5wcm9jZXNzb3IubWVzc2FnZXMucHVzaCggb2JqLmlkLCBwcm9wLCB2YWx1ZSApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldFsgcHJvcCBdID0gdmFsdWVcblxuICAgICAgICAvLyBtdXN0IHJldHVybiB0cnVlIGZvciBhbnkgRVM2IHByb3h5IHNldHRlclxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJveHlcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxucmV0dXJuIF9fcHJveHlcblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHtcblx0XHR2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTtcblx0XHRyZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMTtcblx0fVxuXHRpZiAoIWdPUEQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBNZW1vcnlIZWxwZXIgPSB7XG4gIGNyZWF0ZSggc2l6ZU9yQnVmZmVyPTQwOTYsIG1lbXR5cGU9RmxvYXQzMkFycmF5ICkge1xuICAgIGxldCBoZWxwZXIgPSBPYmplY3QuY3JlYXRlKCB0aGlzIClcblxuICAgIC8vIGNvbnZlbmllbnRseSwgYnVmZmVyIGNvbnN0cnVjdG9ycyBhY2NlcHQgZWl0aGVyIGEgc2l6ZSBvciBhbiBhcnJheSBidWZmZXIgdG8gdXNlLi4uXG4gICAgLy8gc28sIG5vIG1hdHRlciB3aGljaCBpcyBwYXNzZWQgdG8gc2l6ZU9yQnVmZmVyIGl0IHNob3VsZCB3b3JrLlxuICAgIE9iamVjdC5hc3NpZ24oIGhlbHBlciwge1xuICAgICAgaGVhcDogbmV3IG1lbXR5cGUoIHNpemVPckJ1ZmZlciApLFxuICAgICAgbGlzdDoge30sXG4gICAgICBmcmVlTGlzdDoge31cbiAgICB9KVxuXG4gICAgcmV0dXJuIGhlbHBlclxuICB9LFxuXG4gIGFsbG9jKCBzaXplLCBpbW11dGFibGUgKSB7XG4gICAgbGV0IGlkeCA9IC0xXG5cbiAgICBpZiggc2l6ZSA+IHRoaXMuaGVhcC5sZW5ndGggKSB7XG4gICAgICB0aHJvdyBFcnJvciggJ0FsbG9jYXRpb24gcmVxdWVzdCBpcyBsYXJnZXIgdGhhbiBoZWFwIHNpemUgb2YgJyArIHRoaXMuaGVhcC5sZW5ndGggKVxuICAgIH1cblxuICAgIGZvciggbGV0IGtleSBpbiB0aGlzLmZyZWVMaXN0ICkge1xuICAgICAgbGV0IGNhbmRpZGF0ZSA9IHRoaXMuZnJlZUxpc3RbIGtleSBdXG5cbiAgICAgIGlmKCBjYW5kaWRhdGUuc2l6ZSA+PSBzaXplICkge1xuICAgICAgICBpZHggPSBrZXlcblxuICAgICAgICB0aGlzLmxpc3RbIGlkeCBdID0geyBzaXplLCBpbW11dGFibGUsIHJlZmVyZW5jZXM6MSB9XG5cbiAgICAgICAgaWYoIGNhbmRpZGF0ZS5zaXplICE9PSBzaXplICkge1xuICAgICAgICAgIGxldCBuZXdJbmRleCA9IGlkeCArIHNpemUsXG4gICAgICAgICAgICAgIG5ld0ZyZWVTaXplXG5cbiAgICAgICAgICBmb3IoIGxldCBrZXkgaW4gdGhpcy5saXN0ICkge1xuICAgICAgICAgICAgaWYoIGtleSA+IG5ld0luZGV4ICkge1xuICAgICAgICAgICAgICBuZXdGcmVlU2l6ZSA9IGtleSAtIG5ld0luZGV4XG4gICAgICAgICAgICAgIHRoaXMuZnJlZUxpc3RbIG5ld0luZGV4IF0gPSBuZXdGcmVlU2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGlkeCAhPT0gLTEgKSBkZWxldGUgdGhpcy5mcmVlTGlzdFsgaWR4IF1cblxuICAgIGlmKCBpZHggPT09IC0xICkge1xuICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyggdGhpcy5saXN0ICksXG4gICAgICAgICAgbGFzdEluZGV4XG5cbiAgICAgIGlmKCBrZXlzLmxlbmd0aCApIHsgLy8gaWYgbm90IGZpcnN0IGFsbG9jYXRpb24uLi5cbiAgICAgICAgbGFzdEluZGV4ID0gcGFyc2VJbnQoIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdIClcblxuICAgICAgICBpZHggPSBsYXN0SW5kZXggKyB0aGlzLmxpc3RbIGxhc3RJbmRleCBdLnNpemVcbiAgICAgIH1lbHNle1xuICAgICAgICBpZHggPSAwXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdFsgaWR4IF0gPSB7IHNpemUsIGltbXV0YWJsZSwgcmVmZXJlbmNlczoxIH1cbiAgICB9XG5cbiAgICBpZiggaWR4ICsgc2l6ZSA+PSB0aGlzLmhlYXAubGVuZ3RoICkge1xuICAgICAgdGhyb3cgRXJyb3IoICdObyBhdmFpbGFibGUgYmxvY2tzIHJlbWFpbiBzdWZmaWNpZW50IGZvciBhbGxvY2F0aW9uIHJlcXVlc3QuJyApXG4gICAgfVxuICAgIHJldHVybiBpZHhcbiAgfSxcblxuICBhZGRSZWZlcmVuY2UoIGluZGV4ICkge1xuICAgIGlmKCB0aGlzLmxpc3RbIGluZGV4IF0gIT09IHVuZGVmaW5lZCApIHsgXG4gICAgICB0aGlzLmxpc3RbIGluZGV4IF0ucmVmZXJlbmNlcysrXG4gICAgfVxuICB9LFxuXG4gIGZyZWUoIGluZGV4ICkge1xuICAgIGlmKCB0aGlzLmxpc3RbIGluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHRocm93IEVycm9yKCAnQ2FsbGluZyBmcmVlKCkgb24gbm9uLWV4aXN0aW5nIGJsb2NrLicgKVxuICAgIH1cblxuICAgIGxldCBzbG90ID0gdGhpcy5saXN0WyBpbmRleCBdXG4gICAgaWYoIHNsb3QgPT09IDAgKSByZXR1cm5cbiAgICBzbG90LnJlZmVyZW5jZXMtLVxuXG4gICAgaWYoIHNsb3QucmVmZXJlbmNlcyA9PT0gMCAmJiBzbG90LmltbXV0YWJsZSAhPT0gdHJ1ZSApIHsgICAgXG4gICAgICB0aGlzLmxpc3RbIGluZGV4IF0gPSAwXG5cbiAgICAgIGxldCBmcmVlQmxvY2tTaXplID0gMFxuICAgICAgZm9yKCBsZXQga2V5IGluIHRoaXMubGlzdCApIHtcbiAgICAgICAgaWYoIGtleSA+IGluZGV4ICkge1xuICAgICAgICAgIGZyZWVCbG9ja1NpemUgPSBrZXkgLSBpbmRleFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmVlTGlzdFsgaW5kZXggXSA9IGZyZWVCbG9ja1NpemVcbiAgICB9XG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtb3J5SGVscGVyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gQWxlYShzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIG1hc2ggPSBNYXNoKCk7XG5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIG1lLnMwICsgbWUuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgbWUuczAgPSBtZS5zMTtcbiAgICBtZS5zMSA9IG1lLnMyO1xuICAgIHJldHVybiBtZS5zMiA9IHQgLSAobWUuYyA9IHQgfCAwKTtcbiAgfTtcblxuICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gIG1lLmMgPSAxO1xuICBtZS5zMCA9IG1hc2goJyAnKTtcbiAgbWUuczEgPSBtYXNoKCcgJyk7XG4gIG1lLnMyID0gbWFzaCgnICcpO1xuICBtZS5zMCAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczAgPCAwKSB7IG1lLnMwICs9IDE7IH1cbiAgbWUuczEgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMxIDwgMCkgeyBtZS5zMSArPSAxOyB9XG4gIG1lLnMyIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMiA8IDApIHsgbWUuczIgKz0gMTsgfVxuICBtYXNoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYyA9IGYuYztcbiAgdC5zMCA9IGYuczA7XG4gIHQuczEgPSBmLnMxO1xuICB0LnMyID0gZi5zMjtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgQWxlYShzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IHhnLm5leHQ7XG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgKiAweDEwMDAwMDAwMCkgfCAwOyB9XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBybmcoKSArIChwcm5nKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcbiAgfTtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmZ1bmN0aW9uIE1hc2goKSB7XG4gIHZhciBuID0gMHhlZmM4MjQ5ZDtcblxuICB2YXIgbWFzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBkYXRhID0gU3RyaW5nKGRhdGEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHJldHVybiBtYXNoO1xufVxuXG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMuYWxlYSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwiVHljaGUtaVwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8uXG4vLyBTZWUgaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZCwgYSA9IG1lLmE7XG4gICAgYiA9IChiIDw8IDI1KSBeIChiID4+PiA3KSBeIGM7XG4gICAgYyA9IChjIC0gZCkgfCAwO1xuICAgIGQgPSAoZCA8PCAyNCkgXiAoZCA+Pj4gOCkgXiBhO1xuICAgIGEgPSAoYSAtIGIpIHwgMDtcbiAgICBtZS5iID0gYiA9IChiIDw8IDIwKSBeIChiID4+PiAxMikgXiBjO1xuICAgIG1lLmMgPSBjID0gKGMgLSBkKSB8IDA7XG4gICAgbWUuZCA9IChkIDw8IDE2KSBeIChjID4+PiAxNikgXiBhO1xuICAgIHJldHVybiBtZS5hID0gKGEgLSBiKSB8IDA7XG4gIH07XG5cbiAgLyogVGhlIGZvbGxvd2luZyBpcyBub24taW52ZXJ0ZWQgdHljaGUsIHdoaWNoIGhhcyBiZXR0ZXIgaW50ZXJuYWxcbiAgICogYml0IGRpZmZ1c2lvbiwgYnV0IHdoaWNoIGlzIGFib3V0IDI1JSBzbG93ZXIgdGhhbiB0eWNoZS1pIGluIEpTLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBtZS5hLCBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kO1xuICAgIGEgPSAobWUuYSArIG1lLmIgfCAwKSA+Pj4gMDtcbiAgICBkID0gbWUuZCBeIGE7IGQgPSBkIDw8IDE2IF4gZCA+Pj4gMTY7XG4gICAgYyA9IG1lLmMgKyBkIHwgMDtcbiAgICBiID0gbWUuYiBeIGM7IGIgPSBiIDw8IDEyIF4gZCA+Pj4gMjA7XG4gICAgbWUuYSA9IGEgPSBhICsgYiB8IDA7XG4gICAgZCA9IGQgXiBhOyBtZS5kID0gZCA9IGQgPDwgOCBeIGQgPj4+IDI0O1xuICAgIG1lLmMgPSBjID0gYyArIGQgfCAwO1xuICAgIGIgPSBiIF4gYztcbiAgICByZXR1cm4gbWUuYiA9IChiIDw8IDcgXiBiID4+PiAyNSk7XG4gIH1cbiAgKi9cblxuICBtZS5hID0gMDtcbiAgbWUuYiA9IDA7XG4gIG1lLmMgPSAyNjU0NDM1NzY5IHwgMDtcbiAgbWUuZCA9IDEzNjcxMzA1NTE7XG5cbiAgaWYgKHNlZWQgPT09IE1hdGguZmxvb3Ioc2VlZCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUuYSA9IChzZWVkIC8gMHgxMDAwMDAwMDApIHwgMDtcbiAgICBtZS5iID0gc2VlZCB8IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyAyMDsgaysrKSB7XG4gICAgbWUuYiBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5hID0gZi5hO1xuICB0LmIgPSBmLmI7XG4gIHQuYyA9IGYuYztcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMudHljaGVpID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3IxMjhcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gbWUueCBeIChtZS54IDw8IDExKTtcbiAgICBtZS54ID0gbWUueTtcbiAgICBtZS55ID0gbWUuejtcbiAgICBtZS56ID0gbWUudztcbiAgICByZXR1cm4gbWUudyBePSAobWUudyA+Pj4gMTkpIF4gdCBeICh0ID4+PiA4KTtcbiAgfTtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjEyOCA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yd293XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IChtZS54IF4gKG1lLnggPj4+IDIpKTtcbiAgICBtZS54ID0gbWUueTsgbWUueSA9IG1lLno7IG1lLnogPSBtZS53OyBtZS53ID0gbWUudjtcbiAgICByZXR1cm4gKG1lLmQgPSAobWUuZCArIDM2MjQzNyB8IDApKSArXG4gICAgICAgKG1lLnYgPSAobWUudiBeIChtZS52IDw8IDQpKSBeICh0IF4gKHQgPDwgMSkpKSB8IDA7XG4gIH07XG5cbiAgbWUueCA9IDA7XG4gIG1lLnkgPSAwO1xuICBtZS56ID0gMDtcbiAgbWUudyA9IDA7XG4gIG1lLnYgPSAwO1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBpZiAoayA9PSBzdHJzZWVkLmxlbmd0aCkge1xuICAgICAgbWUuZCA9IG1lLnggPDwgMTAgXiBtZS54ID4+PiA0O1xuICAgIH1cbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgdC52ID0gZi52O1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcndvdyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLypcbkNvcHlyaWdodCAyMDE5IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuXG52YXIgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59IGVsc2Uge1xuICAvLyBXaGVuIGluY2x1ZGVkIGFzIGEgcGxhaW4gc2NyaXB0LCBzZXQgdXAgTWF0aC5zZWVkcmFuZG9tIGdsb2JhbC5cbiAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG59XG5cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgLy8gZ2xvYmFsOiBgc2VsZmAgaW4gYnJvd3NlcnMgKGluY2x1ZGluZyBzdHJpY3QgbW9kZSBhbmQgd2ViIHdvcmtlcnMpLFxuICAvLyBvdGhlcndpc2UgYHRoaXNgIGluIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiB0aGlzLFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxNCwgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkNvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS5cblNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIEdlbmVyYXRlIGFuIGludGVybmFsIFVJRCB0byBtYWtlIHRoZSByZWdleHAgcGF0dGVybiBoYXJkZXIgdG8gZ3Vlc3MuXG52YXIgVUlEICAgICAgICAgICAgICAgICA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwMDApLnRvU3RyaW5nKDE2KTtcbnZhciBQTEFDRV9IT0xERVJfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXCJAX18oRnxSfER8TXxTKS0nICsgVUlEICsgJy0oXFxcXGQrKV9fQFwiJywgJ2cnKTtcblxudmFyIElTX05BVElWRV9DT0RFX1JFR0VYUCA9IC9cXHtcXHMqXFxbbmF0aXZlIGNvZGVcXF1cXHMqXFx9L2c7XG52YXIgSVNfUFVSRV9GVU5DVElPTiA9IC9mdW5jdGlvbi4qP1xcKC87XG52YXIgSVNfQVJST1dfRlVOQ1RJT04gPSAvLio/PT4uKj8vO1xudmFyIFVOU0FGRV9DSEFSU19SRUdFWFAgICA9IC9bPD5cXC9cXHUyMDI4XFx1MjAyOV0vZztcblxudmFyIFJFU0VSVkVEX1NZTUJPTFMgPSBbJyonLCAnYXN5bmMnXTtcblxuLy8gTWFwcGluZyBvZiB1bnNhZmUgSFRNTCBhbmQgaW52YWxpZCBKYXZhU2NyaXB0IGxpbmUgdGVybWluYXRvciBjaGFycyB0byB0aGVpclxuLy8gVW5pY29kZSBjaGFyIGNvdW50ZXJwYXJ0cyB3aGljaCBhcmUgc2FmZSB0byB1c2UgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxudmFyIEVTQ0FQRURfQ0hBUlMgPSB7XG4gICAgJzwnICAgICA6ICdcXFxcdTAwM0MnLFxuICAgICc+JyAgICAgOiAnXFxcXHUwMDNFJyxcbiAgICAnLycgICAgIDogJ1xcXFx1MDAyRicsXG4gICAgJ1xcdTIwMjgnOiAnXFxcXHUyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICdcXFxcdTIwMjknXG59O1xuXG5mdW5jdGlvbiBlc2NhcGVVbnNhZmVDaGFycyh1bnNhZmVDaGFyKSB7XG4gICAgcmV0dXJuIEVTQ0FQRURfQ0hBUlNbdW5zYWZlQ2hhcl07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgYHNwYWNlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7c3BhY2U6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIHZhciBmdW5jdGlvbnMgPSBbXTtcbiAgICB2YXIgcmVnZXhwcyAgID0gW107XG4gICAgdmFyIGRhdGVzICAgICA9IFtdO1xuICAgIHZhciBtYXBzICAgICAgPSBbXTtcbiAgICB2YXIgc2V0cyAgICAgID0gW107XG5cbiAgICAvLyBSZXR1cm5zIHBsYWNlaG9sZGVycyBmb3IgZnVuY3Rpb25zIGFuZCByZWdleHBzIChpZGVudGlmaWVkIGJ5IGluZGV4KVxuICAgIC8vIHdoaWNoIGFyZSBsYXRlciByZXBsYWNlZCBieSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHcvIGEgdG9KU09OIG1ldGhvZCwgdG9KU09OIGlzIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHJlcGxhY2VyIHJ1bnMsIHNvIHdlIHVzZSB0aGlzW2tleV0gdG8gZ2V0IHRoZSBub24tdG9KU09OZWQgdmFsdWUuXG4gICAgICAgIHZhciBvcmlnVmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9yaWdWYWx1ZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmKG9yaWdWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQF9fUi0nICsgVUlEICsgJy0nICsgKHJlZ2V4cHMucHVzaChvcmlnVmFsdWUpIC0gMSkgKyAnX19AJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYob3JpZ1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQF9fRC0nICsgVUlEICsgJy0nICsgKGRhdGVzLnB1c2gob3JpZ1ZhbHVlKSAtIDEpICsgJ19fQCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9yaWdWYWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQF9fTS0nICsgVUlEICsgJy0nICsgKG1hcHMucHVzaChvcmlnVmFsdWUpIC0gMSkgKyAnX19AJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYob3JpZ1ZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdAX19TLScgKyBVSUQgKyAnLScgKyAoc2V0cy5wdXNoKG9yaWdWYWx1ZSkgLSAxKSArICdfX0AnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnQF9fRi0nICsgVUlEICsgJy0nICsgKGZ1bmN0aW9ucy5wdXNoKG9yaWdWYWx1ZSkgLSAxKSArICdfX0AnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmMoZm4pIHtcbiAgICAgIHZhciBzZXJpYWxpemVkRm4gPSBmbi50b1N0cmluZygpO1xuICAgICAgaWYgKElTX05BVElWRV9DT0RFX1JFR0VYUC50ZXN0KHNlcmlhbGl6ZWRGbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXJpYWxpemluZyBuYXRpdmUgZnVuY3Rpb246ICcgKyBmbi5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHVyZSBmdW5jdGlvbnMsIGV4YW1wbGU6IHtrZXk6IGZ1bmN0aW9uKCkge319XG4gICAgICBpZihJU19QVVJFX0ZVTkNUSU9OLnRlc3Qoc2VyaWFsaXplZEZuKSkge1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkRm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFycm93IGZ1bmN0aW9ucywgZXhhbXBsZTogYXJnMSA9PiBhcmcxKzVcbiAgICAgIGlmKElTX0FSUk9XX0ZVTkNUSU9OLnRlc3Qoc2VyaWFsaXplZEZuKSkge1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkRm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzU3RhcnRzQXQgPSBzZXJpYWxpemVkRm4uaW5kZXhPZignKCcpO1xuICAgICAgdmFyIGRlZiA9IHNlcmlhbGl6ZWRGbi5zdWJzdHIoMCwgYXJnc1N0YXJ0c0F0KVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwubGVuZ3RoID4gMCB9KTtcblxuICAgICAgdmFyIG5vblJlc2VydmVkU3ltYm9scyA9IGRlZi5maWx0ZXIoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiBSRVNFUlZFRF9TWU1CT0xTLmluZGV4T2YodmFsKSA9PT0gLTFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBlbmhhbmNlZCBsaXRlcmFsIG9iamVjdHMsIGV4YW1wbGU6IHtrZXkoKSB7fX1cbiAgICAgIGlmKG5vblJlc2VydmVkU3ltYm9scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChkZWYuaW5kZXhPZignYXN5bmMnKSA+IC0xID8gJ2FzeW5jICcgOiAnJykgKyAnZnVuY3Rpb24nXG4gICAgICAgICAgICArIChkZWYuam9pbignJykuaW5kZXhPZignKicpID4gLTEgPyAnKicgOiAnJylcbiAgICAgICAgICAgICsgc2VyaWFsaXplZEZuLnN1YnN0cihhcmdzU3RhcnRzQXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcnJvdyBmdW5jdGlvbnNcbiAgICAgIHJldHVybiBzZXJpYWxpemVkRm47XG4gICAgfVxuXG4gICAgdmFyIHN0cjtcblxuICAgIC8vIENyZWF0ZXMgYSBKU09OIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUuXG4gICAgLy8gTk9URTogTm9kZSAwLjEyIGdvZXMgaW50byBzbG93IG1vZGUgd2l0aCBleHRyYSBKU09OLnN0cmluZ2lmeSgpIGFyZ3MuXG4gICAgaWYgKG9wdGlvbnMuaXNKU09OICYmICFvcHRpb25zLnNwYWNlKSB7XG4gICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBvcHRpb25zLmlzSlNPTiA/IG51bGwgOiByZXBsYWNlciwgb3B0aW9ucy5zcGFjZSk7XG4gICAgfVxuXG4gICAgLy8gUHJvdGVjdHMgYWdhaW5zdCBgSlNPTi5zdHJpbmdpZnkoKWAgcmV0dXJuaW5nIGB1bmRlZmluZWRgLCBieSBzZXJpYWxpemluZ1xuICAgIC8vIHRvIHRoZSBsaXRlcmFsIHN0cmluZzogXCJ1bmRlZmluZWRcIi5cbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UgdW5zYWZlIEhUTUwgYW5kIGludmFsaWQgSmF2YVNjcmlwdCBsaW5lIHRlcm1pbmF0b3IgY2hhcnMgd2l0aFxuICAgIC8vIHRoZWlyIHNhZmUgVW5pY29kZSBjaGFyIGNvdW50ZXJwYXJ0LiBUaGlzIF9tdXN0XyBoYXBwZW4gYmVmb3JlIHRoZVxuICAgIC8vIHJlZ2V4cHMgYW5kIGZ1bmN0aW9ucyBhcmUgc2VyaWFsaXplZCBhbmQgYWRkZWQgYmFjayB0byB0aGUgc3RyaW5nLlxuICAgIGlmIChvcHRpb25zLnVuc2FmZSAhPT0gdHJ1ZSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShVTlNBRkVfQ0hBUlNfUkVHRVhQLCBlc2NhcGVVbnNhZmVDaGFycyk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmN0aW9ucy5sZW5ndGggPT09IDAgJiYgcmVnZXhwcy5sZW5ndGggPT09IDAgJiYgZGF0ZXMubGVuZ3RoID09PSAwICYmIG1hcHMubGVuZ3RoID09PSAwICYmIHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIGZ1bmN0aW9uLCByZWdleHAsIGRhdGUsIG1hcCBhbmQgc2V0IHBsYWNlaG9sZGVycyBpbiB0aGVcbiAgICAvLyBKU09OIHN0cmluZyB3aXRoIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvbnMuIElmIHRoZSBvcmlnaW5hbCB2YWx1ZSBjYW5cbiAgICAvLyBub3QgYmUgZm91bmQsIHRoZW4gYHVuZGVmaW5lZGAgaXMgdXNlZC5cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoUExBQ0VfSE9MREVSX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoLCB0eXBlLCB2YWx1ZUluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm5ldyBEYXRlKFxcXCJcIiArIGRhdGVzW3ZhbHVlSW5kZXhdLnRvSVNPU3RyaW5nKCkgKyBcIlxcXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ1InKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZXhwc1t2YWx1ZUluZGV4XS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgcmV0dXJuIFwibmV3IE1hcChcIiArIHNlcmlhbGl6ZShBcnJheS5mcm9tKG1hcHNbdmFsdWVJbmRleF0uZW50cmllcygpKSwgb3B0aW9ucykgKyBcIilcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnUycpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm5ldyBTZXQoXCIgKyBzZXJpYWxpemUoQXJyYXkuZnJvbShzZXRzW3ZhbHVlSW5kZXhdLnZhbHVlcygpKSwgb3B0aW9ucykgKyBcIilcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uc1t2YWx1ZUluZGV4XTtcblxuICAgICAgICByZXR1cm4gc2VyaWFsaXplRnVuYyhmbik7XG4gICAgfSk7XG59XG4iLCIvKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjEwLjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm9yZy9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG5cbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgfVxufVxuXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjbGFzc1wiOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBcIlwiLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlc2NhcGVkUGFydHMgKz0gZXhwZWN0YXRpb24ucGFydHNbaV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pXG4gICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJylcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICAnXFxcXC0nKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdGlvbnNbaV0gPSBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGVkW2ldKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgcGF0dGVybjogcGVnJHBhcnNlcGF0dGVybiB9LFxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXBhdHRlcm4sXG5cbiAgICAgIHBlZyRjMCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGxldCBvdXQgPSB2YWx1ZVxuICAgICAgICBpZiggb3B0aW9ucy5lbmNsb3NlID09PSB0cnVlICYmIHZhbHVlLnR5cGUgIT09ICdncm91cCcgKSB7XG4gICAgICAgICAgb3V0ID0geyB0eXBlOidncm91cCcsIHZhbHVlczpbIHZhbHVlIF0gfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb3V0XG4gICAgICB9LFxuICAgICAgcGVnJGMxID0gZnVuY3Rpb24oX3ZhbHVlc3N0YXJ0LCBfdmFsdWVzZW5kKSB7XG4gICAgICAgIF92YWx1ZXNlbmQudW5zaGlmdCggX3ZhbHVlc3N0YXJ0IClcbiAgICAgICAgY29uc3QgdmFsdWVzID0gX3ZhbHVlc2VuZFxuXG4gICAgICAgIGxldCBvdXRcbiAgICAgICAgXG4gICAgICAgIGlmKCB2YWx1ZXMudHlwZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIC8vIGdldHRpbmcgbmVzdGVkIGFycmF5cyB3aXRoIGZlZXQuLi5cbiAgICAgICAgICBvdXQgPSB7XG4gICAgICAgICAgICB2YWx1ZXM6QXJyYXkuaXNBcnJheSggdmFsdWVzWzBdICkgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsXG4gICAgICAgICAgICB0eXBlOidncm91cCcgXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvdXQgPSB2YWx1ZXNcbiAgICAgICAgICBvdXQudHlwZSA9ICdncm91cCdcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICBhZGRMb2MoIG91dCwgbG9jYXRpb24oKSApXG5cbiAgICAgICAgcmV0dXJuIG91dFxuICAgICAgfSxcbiAgICAgIHBlZyRjMiA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiZ3JvdXBcIiksXG4gICAgICBwZWckYzMgPSBcIltcIixcbiAgICAgIHBlZyRjNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNSA9IFwiXVwiLFxuICAgICAgcGVnJGM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGM3ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgdHlwZTonZ3JvdXAnIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYWRkTG9jKCBvdXQsIGxvY2F0aW9uKCkgKSBcbiAgICAgIH0sXG4gICAgICBwZWckYzggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInRlcm1cIiksXG4gICAgICBwZWckYzkgPSBmdW5jdGlvbihib2R5KSB7cmV0dXJuIGJvZHl9LFxuICAgICAgcGVnJGMxMCA9IFwiKFwiLFxuICAgICAgcGVnJGMxMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIoXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTIgPSBcIixcIixcbiAgICAgIHBlZyRjMTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLFwiLCBmYWxzZSksXG4gICAgICBwZWckYzE0ID0gXCIpXCIsXG4gICAgICBwZWckYzE1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxNiA9IGZ1bmN0aW9uKHZhbHVlLCBwdWxzZXMsIHNsb3RzLCByb3RhdGlvbikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdHlwZTonYmpvcmtsdW5kJyxcbiAgICAgICAgICBwdWxzZXMsIFxuICAgICAgICAgIHNsb3RzLCBcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAncm90YXRpb24nOiByb3RhdGlvbi5sZW5ndGggPiAwID8gcm90YXRpb25bIDAgXSA6IG51bGxcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICBjb25zdCB3aXRoTG9jID0gYWRkTG9jKCByZXN1bHQsIGxvY2F0aW9uKCkgKSBcbiAgICAgICAgLy93aXRoTG9jLnZhbHVlLnVpZCA9IHdpdGhMb2MudWlkXG4gICAgICAgIHJldHVybiB3aXRoTG9jXG4gICAgICB9LFxuICAgICAgcGVnJGMxNyA9IGZ1bmN0aW9uKGJvZHkpIHsgcmV0dXJuIGJvZHkgfSxcbiAgICAgIHBlZyRjMTggPSBcIj9cIixcbiAgICAgIHBlZyRjMTkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiP1wiLCBmYWxzZSksXG4gICAgICBwZWckYzIwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0geyB0eXBlOidkZWdyYWRlJywgdmFsdWUgfVxuICAgICAgICByZXR1cm4gb3V0XG4gICAgICAgIC8vcmV0dXJuIGFkZExvYyggb3V0LCBsb2NhdGlvbigpIClcbiAgICAgIH0sXG4gICAgICBwZWckYzIxID0gXCIqXCIsXG4gICAgICBwZWckYzIyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIipcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMyMyA9IGZ1bmN0aW9uKHZhbHVlLCByYXRlKSB7XG4gICAgICAgIGNvbnN0IHIgPSAgeyB0eXBlOidzcGVlZCcsIHJhdGUsIHZhbHVlIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5hZGRMb2NhdGlvbnMgPT09IHRydWUgKSB7XG4gICAgICAgICAgci5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0OnZhbHVlLmxvY2F0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiByYXRlLmxvY2F0aW9uLmVuZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHIgXG4gICAgICB9LFxuICAgICAgcGVnJGMyNCA9IFwiL1wiLFxuICAgICAgcGVnJGMyNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIvXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjYgPSBmdW5jdGlvbih2YWx1ZSwgcmF0ZSkge1xuICAgICAgICAvKmNvbnN0IHIgPSAgeyB0eXBlOidzbG93JywgcmF0ZSwgdmFsdWUgfSovXG5cbiAgICAgICAgLy9pZiggb3B0aW9ucy5hZGRMb2NhdGlvbnMgPT09IHRydWUgKSB7XG4gICAgICAgIC8vICByLmxvY2F0aW9uID0ge1xuICAgICAgICAvLyAgICBzdGFydDp2YWx1ZS5sb2NhdGlvbi5zdGFydCxcbiAgICAgICAgLy8gICAgZW5kOiByYXRlLmxvY2F0aW9uLmVuZFxuICAgICAgICAvLyAgfVxuICAgICAgICAvL31cbiAgICAgICAgLy9jb25zdCBncm91cCA9IHZhbHVlLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgLy8gID8gdmFsdWVcbiAgICAgICAgY29uc3QgZ3JvdXAgPSB7IHR5cGU6J2dyb3VwJywgdmFsdWVzOlsgdmFsdWUgXSB9XG5cbiAgICAgICAgY29uc3Qgb25lc3RlcCA9IHtcbiAgICAgICAgICB0eXBlOidvbmVzdGVwJyxcbiAgICAgICAgICB2YWx1ZXM6WyBncm91cCBdXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHJhdGUudmFsdWUgLSAxOyBpKysgKSB7XG4gICAgICAgICAgZ3JvdXAudmFsdWVzLnB1c2goeyB0eXBlOidyZXN0JyB9KVxuICAgICAgICB9XG5cbiAgICAgICAgYWRkTG9jKCBvbmVzdGVwLCBsb2NhdGlvbigpIClcbiAgICAgICAgcmV0dXJuIG9uZXN0ZXBcbiAgICAgICAgLypyZXR1cm4gciAqL1xuICAgICAgfSxcbiAgICAgIHBlZyRjMjcgPSBcIntcIixcbiAgICAgIHBlZyRjMjggPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwie1wiLCBmYWxzZSksXG4gICAgICBwZWckYzI5ID0gXCJ9XCIsXG4gICAgICBwZWckYzMwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzMSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgXG4gICAgICAgICAgJ2xlZnQnOntcbiAgICAgICAgICAgIHR5cGU6J2dyb3VwJyxcbiAgICAgICAgICAgIHZhbHVlczpsZWZ0XG4gICAgICAgICAgfSwgXG4gICAgICAgICAgJ3JpZ2h0Jzp7XG4gICAgICAgICAgICB0eXBlOidncm91cCcsXG4gICAgICAgICAgICB2YWx1ZXM6cmlnaHQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAncG9seW1ldGVyJyBcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZExvYyggcmVzdWx0LmxlZnQsIGxvY2F0aW9uKCkgKVxuICAgICAgICBhZGRMb2MoIHJlc3VsdC5yaWdodCwgbG9jYXRpb24oKSApXG4gICAgICAgIGFkZExvYyggcmVzdWx0LCBsb2NhdGlvbigpIClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9LFxuICAgICAgcGVnJGMzMiA9IFwiflwiLFxuICAgICAgcGVnJGMzMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ+XCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMzQgPSBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4geyB0eXBlOidyZXN0JyB9XG4gICAgICB9LFxuICAgICAgcGVnJGMzNSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xuICAgICAgICAgIHR5cGU6J2dyb3VwJyxcbiAgICAgICAgICB2YWx1ZXM6IHN0YXJ0Lm1hcCggZ3JwID0+IGdycFswXSApXG4gICAgICAgIH1cbiAgICAgICAgb3V0LnZhbHVlcy5wdXNoKCBlbmQgKVxuXG4gICAgICAgIHJldHVybiBhZGRMb2MoIG91dCwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGMzNiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHBlZyRjMzcgPSBmdW5jdGlvbihib2R5LCBlbmQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gYm9keS5tYXAoIHZhbCA9PiB2YWxbMF0gKVxuXG4gICAgICAgIHZhbHVlcy5wdXNoKCBlbmQgKVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGF5ZXJzJyxcbiAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRMb2MoIHJlc3VsdCwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGMzOCA9IFwiPFwiLFxuICAgICAgcGVnJGMzOSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI8XCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDAgPSBcIj5cIixcbiAgICAgIHBlZyRjNDEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiPlwiLCBmYWxzZSksXG4gICAgICBwZWckYzQyID0gZnVuY3Rpb24oYm9keSwgZW5kKSB7XG4gICAgICAgIGNvbnN0IG9uZXN0ZXAgPSB7XG4gICAgICAgICAgdHlwZTonb25lc3RlcCcsXG4gICAgICAgICAgdmFsdWVzOltib2R5XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGVuZCAhPT0gbnVsbCApIHtcbiAgICAgICAgICBvbmVzdGVwLnZhbHVlcy5wdXNoKCBlbmQgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkZExvYyggb25lc3RlcCwgbG9jYXRpb24oKSApXG4gICAgICB9LFxuICAgICAgcGVnJGM0MyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwid29yZFwiKSxcbiAgICAgIHBlZyRjNDQgPSAvXltsZXR0ZXIgbnVtYmVyXS8sXG4gICAgICBwZWckYzQ1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wibFwiLCBcImVcIiwgXCJ0XCIsIFwidFwiLCBcImVcIiwgXCJyXCIsIFwiIFwiLCBcIm5cIiwgXCJ1XCIsIFwibVwiLCBcImJcIiwgXCJlXCIsIFwiclwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDYgPSBmdW5jdGlvbih2YWx1ZSkgeyBcbiAgICAgICAgcmV0dXJuIGFkZExvYyggeyB0eXBlOnR5cGVvZiB2YWx1ZSwgdmFsdWUsIH0sIGxvY2F0aW9uKCkgKVxuICAgICAgfSxcbiAgICAgIHBlZyRjNDcgPSBmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiBhZGRMb2MoIHsgdHlwZTonc3RyaW5nJywgdmFsdWU6dGV4dCgpLnRyaW0oKSB9LCBsb2NhdGlvbigpIClcbiAgICAgIH0sXG4gICAgICBwZWckYzQ4ID0gL15bXiBbXFxdIHt9ICgpIFxcdFxcblxcciAnKicgJ1xcLycgJy4nICd+JyAnPycgJywnICc+JyAnPCcgXS8sXG4gICAgICBwZWckYzQ5ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIltcIiwgXCJdXCIsIFwiIFwiLCBcIntcIiwgXCJ9XCIsIFwiIFwiLCBcIihcIiwgXCIpXCIsIFwiIFwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcclwiLCBcIiBcIiwgXCInXCIsIFwiKlwiLCBcIidcIiwgXCIgXCIsIFwiJ1wiLCBcIi9cIiwgXCInXCIsIFwiIFwiLCBcIidcIiwgXCIuXCIsIFwiJ1wiLCBcIiBcIiwgXCInXCIsIFwiflwiLCBcIidcIiwgXCIgXCIsIFwiJ1wiLCBcIj9cIiwgXCInXCIsIFwiIFwiLCBcIidcIiwgXCIsXCIsIFwiJ1wiLCBcIiBcIiwgXCInXCIsIFwiPlwiLCBcIidcIiwgXCIgXCIsIFwiJ1wiLCBcIjxcIiwgXCInXCIsIFwiIFwiXSwgdHJ1ZSwgZmFsc2UpLFxuICAgICAgcGVnJGM1MCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRMb2MoIHt0eXBlOidzdHJpbmcnLCB2YWx1ZSB9LCBsb2NhdGlvbigpIClcbiAgICAgIH0sXG4gICAgICBwZWckYzUxID0gXCIuXCIsXG4gICAgICBwZWckYzUyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi5cIiwgZmFsc2UpLFxuICAgICAgcGVnJGM1MyA9IFwiLVwiLFxuICAgICAgcGVnJGM1NCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCItXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTUgPSAvXlswLTldLyxcbiAgICAgIHBlZyRjNTYgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM1NyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jKCB7IHR5cGU6J251bWJlcicsIHZhbHVlOit0ZXh0KCkudHJpbSgpIH0sIGxvY2F0aW9uKCkgKVxuICAgICAgfSxcbiAgICAgIHBlZyRjNTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIndoaXRlc3BhY2VcIiksXG4gICAgICBwZWckYzU5ID0gL15bIFxcdFxcblxcciBdLyxcbiAgICAgIHBlZyRjNjAgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIgXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxyXCIsIFwiIFwiXSwgZmFsc2UsIGZhbHNlKSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHNhdmVkUG9zICAgICAgICAgPSAwLFxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZSAgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0c0NhY2hlID0ge30sXG5cbiAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgfVxuXG4gICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBsb2NhdGlvbikge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb24gIT09IHZvaWQgMCA/IGxvY2F0aW9uIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFxuICAgICAgW3BlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKV0sXG4gICAgICBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBsb2NhdGlvbikge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb24gIT09IHZvaWQgMCA/IGxvY2F0aW9uIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbih0ZXh0LCBpZ25vcmVDYXNlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiY2xhc3NcIiwgcGFydHM6IHBhcnRzLCBpbnZlcnRlZDogaW52ZXJ0ZWQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRhbnlFeHBlY3RhdGlvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImFueVwiIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIHZhciBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdLCBwO1xuXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gcG9zIC0gMTtcbiAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVtwXSkge1xuICAgICAgICBwLS07XG4gICAgICB9XG5cbiAgICAgIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3BdO1xuICAgICAgZGV0YWlscyA9IHtcbiAgICAgICAgbGluZTogICBkZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChwIDwgcG9zKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcCsrO1xuICAgICAgfVxuXG4gICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyksXG4gICAgICAgIGVuZFBvc0RldGFpbHMgICA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhlbmRQb3MpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIG9mZnNldDogc3RhcnRQb3MsXG4gICAgICAgIGxpbmU6ICAgc3RhcnRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgbGluZTogICBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTaW1wbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIG51bGwsIG51bGwsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBwZWckU3ludGF4RXJyb3IoXG4gICAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICBleHBlY3RlZCxcbiAgICAgIGZvdW5kLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcGF0dGVybigpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAwLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlZmVldCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VsaXN0KCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjMChzMSk7XG4gICAgfVxuICAgIHMwID0gczE7XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VsaXN0KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgczUgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMxKHMyLCBzNCk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZ3JvdXAoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMixcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgICAgczIgPSBwZWckYzM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRjNTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzcoczQpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V0ZXJtKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAzLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZXNwZWVkKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2VzbG93KCk7XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlZGVncmFkZSgpO1xuICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsYXllcigpO1xuICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVycygpO1xuICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vwb2x5bWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZXJlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW9uZXN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzkoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWV1Y2xpZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMCwgczExLCBzMTIsIHMxMywgczE0LCBzMTU7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDQsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZW5vdGV1Y2xpZCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMTA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJGMxMjtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJGMxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTUpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGMxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMyk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczE0ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzMTQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMy5wdXNoKHMxNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTQgPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxNSA9IHBlZyRjMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczE1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczE1ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczE1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzE2KHMyLCBzNSwgczgsIHMxMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdGV1Y2xpZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgNSxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJHBhcnNld29yZCgpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcnMoKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlb25lc3RlcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNyhzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZGVncmFkZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgNixcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZW5vdGRlZ3JhZGUoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjMpIHtcbiAgICAgICAgczIgPSBwZWckYzE4O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTkpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMyMChzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbm90ZGVncmFkZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDcsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZXNwZWVkKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VzbG93KCk7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJHBhcnNlZXVjbGlkKCk7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VvbmVzdGVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzcGVlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDgsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2Vub3RzcGVlZCgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xuICAgICAgICAgIHMzID0gcGVnJGMyMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW5vdHNwZWVkKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyMyhzMSwgczUpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vub3RzcGVlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgOSxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWV1Y2xpZCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2Vwb2x5bWV0ZXIoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxheWVyKCk7XG4gICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcnMoKTtcbiAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWdyb3VwKCk7XG4gICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZXJlc3QoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW9uZXN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE3KHMxKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzbG93KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTAsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2Vub3RzbG93KCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ3KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI0O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbm90c2xvdygpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjYoczEsIHM1KTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbm90c2xvdygpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTEsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VldWNsaWQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlcG9seW1ldGVyKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2VudW1iZXIoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VsYXllcigpO1xuICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXJzKCk7XG4gICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vncm91cCgpO1xuICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VvbmVzdGVwKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNyhzMSk7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcG9seW1ldGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxMixcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICAgIHMyID0gcGVnJGMyNztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZXRlcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzEyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM3ID0gW107XG4gICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2V0ZXJtKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczcucHVzaChzOCk7XG4gICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNldGVybSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRjMjk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMwKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMShzNCwgczcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VyZXN0KCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDEzLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI2KSB7XG4gICAgICBzMSA9IHBlZyRjMzI7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzMpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjMzQoKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZlZXQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDE0LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBwZWckcGFyc2Vmb290KCk7XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlZm9vdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2Vub3Rmb290KCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMzNShzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZvb3QoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxNSxcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNlbm90Zm9vdCgpO1xuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW5vdGZvb3QoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlZG90KCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMzNihzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdGZvb3QoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgdmFyIGtleSAgICA9IHBlZyRjdXJyUG9zICogMjggKyAxNixcbiAgICAgICAgY2FjaGVkID0gcGVnJHJlc3VsdHNDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBjYWNoZWQubmV4dFBvcztcblxuICAgICAgcmV0dXJuIGNhY2hlZC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgczAgPSBwZWckcGFyc2VsaXN0KCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZWRlZ3JhZGUoKTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRwYXJzZXBvbHltZXRlcigpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZXJlc3QoKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlc3BlZWQoKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZXNsb3coKTtcbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VldWNsaWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VsZXR0ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZXdvcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZW9uZXN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VsYXllcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczk7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDE3LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICBzMiA9IHBlZyRjMztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgczUgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNiA9IHBlZyRwYXJzZW5vdGxheWVyKCk7XG4gICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgczggPSBwZWckYzEyO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMyk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM2ID0gW3M2LCBzNywgczgsIHM5XTtcbiAgICAgICAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM1O1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgICBzNSA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZW5vdGxheWVyKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRjMTI7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMyk7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczYgPSBbczYsIHM3LCBzOCwgczldO1xuICAgICAgICAgICAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbm90bGF5ZXIoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckYzU7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzM3KHM0LCBzNSk7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbm90bGF5ZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDE4LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlc3BlZWQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlc2xvdygpO1xuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlbGlzdCgpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsZXR0ZXJzKCk7XG4gICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VldWNsaWQoKTtcbiAgICAgICAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vwb2x5bWV0ZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlZ3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZXJlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlb25lc3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTcoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW9uZXN0ZXAoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMTksXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2MCkge1xuICAgICAgczEgPSBwZWckYzM4O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM5KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlbm90b25lc3RlcCgpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRjMTI7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTMpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbm90b25lc3RlcCgpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckYzQwO1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQxKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzQyKHMzLCBzNSk7XG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5vdG9uZXN0ZXAoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDIwLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlbGlzdCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VldWNsaWQoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZXBvbHltZXRlcigpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZXdvcmQoKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlZ3JvdXAoKTtcbiAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VyZXN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VsYXllcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTcoczEpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXdvcmQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMjEsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgczMgPSBbXTtcbiAgICAgIGlmIChwZWckYzQ0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgaWYgKHBlZyRjNDQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ1KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gaW5wdXQuc3Vic3RyaW5nKHMyLCBwZWckY3VyclBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHMzO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNDYoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDMpOyB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbGV0dGVycygpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDIyLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VsZXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNDcoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VsZXR0ZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDIzLFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKHBlZyRjNDgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ5KTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gaW5wdXQuc3Vic3RyaW5nKHMxLCBwZWckY3VyclBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gczI7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjNTAoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZG90KCkge1xuICAgIHZhciBzMDtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMjQsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgIHMwID0gcGVnJGM1MTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VxdWVzdGlvbigpIHtcbiAgICB2YXIgczA7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDI1LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYzKSB7XG4gICAgICBzMCA9IHBlZyRjMTg7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTkpOyB9XG4gICAgfVxuXG4gICAgcGVnJHJlc3VsdHNDYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiBzMCB9O1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbnVtYmVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgIHZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqIDI4ICsgMjYsXG4gICAgICAgIGNhY2hlZCA9IHBlZyRyZXN1bHRzQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gY2FjaGVkLm5leHRQb3M7XG5cbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0O1xuICAgIH1cblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NSkge1xuICAgICAgczEgPSBwZWckYzUzO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU0KTsgfVxuICAgIH1cbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgczMgPSBbXTtcbiAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICBzNCA9IHBlZyRjNTE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzNiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IFtzMywgczQsIHM1XTtcbiAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgICAgIHMzID0gcGVnJGM1MTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gW3MzLCBzNF07XG4gICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNTcoKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0c0NhY2hlW2tleV0gPSB7IG5leHRQb3M6IHBlZyRjdXJyUG9zLCByZXN1bHQ6IHMwIH07XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICB2YXIga2V5ICAgID0gcGVnJGN1cnJQb3MgKiAyOCArIDI3LFxuICAgICAgICBjYWNoZWQgPSBwZWckcmVzdWx0c0NhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zO1xuXG4gICAgICByZXR1cm4gY2FjaGVkLnJlc3VsdDtcbiAgICB9XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IFtdO1xuICAgIGlmIChwZWckYzU5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICB9XG4gICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMC5wdXNoKHMxKTtcbiAgICAgIGlmIChwZWckYzU5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgIH1cblxuICAgIHBlZyRyZXN1bHRzQ2FjaGVba2V5XSA9IHsgbmV4dFBvczogcGVnJGN1cnJQb3MsIHJlc3VsdDogczAgfTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG5cbiAgICBjb25zdCBhZGRMb2NhdGlvbnMgPSBvcHRpb25zLmFkZExvY2F0aW9uc1xuICAgXG4gICAgbGV0IHVpZCA9IDBcbiAgICBjb25zdCBhZGRMb2MgPSBmdW5jdGlvbiggdmFsdWUsIGxvY2F0aW9uICkge1xuICAgICAgaWYoIGFkZExvY2F0aW9ucyA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdmFsdWUubG9jYXRpb24gPSBsb2NhdGlvblxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggb3B0aW9ucy5hZGRVSUQgPT09IHRydWUgKSB7XG4gICAgICAgIHZhbHVlLnVpZCA9IHVpZCsrXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwZWckcGFyc2Vcbn07XG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4uL2Rpc3QvdGlkYWwuanMnKS5wYXJzZVxuY29uc3QgcXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5QXJjLmpzJyApLnF1ZXJ5QXJjXG5jb25zdCBGcmFjdGlvbiA9IHJlcXVpcmUoICdmcmFjdGlvbi5qcycgKVxuXG4vKiBUaGUgUGF0dGVybiBvYmplY3QgaXMgdXNlZCB0byBwYXJzZSBhIHBhdHRlcm5cbiAqIGEgc2luZ2xlIHRpbWUgYW5kIHRoZW4gcXVlcnkgaXQgcmVwZWF0ZWRseSwgYXNzdW1pbmdcbiAqIGRpZmZlcmVudCBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIHF1ZXJ5LiBBIHByaW9yaXR5XG4gKiBxdWV1ZSBpcyB1c2VkIHRvIHNvcnQgdGhlIGV2ZW50cy4uLiBcbiovXG5jb25zdCBQYXR0ZXJuID0gKCBwYXR0ZXJuU3RyaW5nLCBvcHRzICkgPT4ge1xuICBpZiggdHlwZW9mIHBhdHRlcm5TdHJpbmcgIT09ICdzdHJpbmcnIClcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIHN0cmluZyB0byBnZW5lcmF0ZSB0aGUgcGF0dGVybiBmcm9tJ1xuXG4gIGxldCBfX2RhdGFcbiAgdHJ5e1xuICAgIF9fZGF0YSA9IHBhcnNlKCBwYXR0ZXJuU3RyaW5nLCBvcHRzIClcbiAgfWNhdGNoKCBlICkge1xuICAgIHRocm93IGBXZSB3ZXJlIHVuYWJsZSB0byBwYXJzZSB0aGUgcGF0dGVybiAke3BhdHRlcm5TdHJpbmd9LiAke2UudG9TdHJpbmcoKX1gXG4gIH1cblxuICBjb25zdCBwdHJuID0ge1xuICAgIF9fcmF3U3RyaW5nOiBwYXR0ZXJuU3RyaW5nLFxuICAgIF9fZGF0YSxcblxuICAgIGV2ZW50czogbnVsbCxcblxuICAgIF9fc29ydCggYSxiICkgeyByZXR1cm4gYS5hcmMuc3RhcnQuY29tcGFyZSggYi5hcmMuc3RhcnQgKSB9LFxuICAgIHF1ZXJ5KCBzdGFydCwgZHVyYXRpb24gKSB7XG4gICAgICBpZiggdHlwZW9mIHN0YXJ0ICE9PSAnb2JqZWN0JyApIHN0YXJ0ID0gRnJhY3Rpb24oIHN0YXJ0IClcbiAgICAgIGlmKCB0eXBlb2YgZHVyYXRpb24gIT09ICdvYmplY3QnICkgZHVyYXRpb24gPSBGcmFjdGlvbiggZHVyYXRpb24gKVxuXG4gICAgICBwdHJuLmV2ZW50cyA9IHF1ZXJ5KCBcbiAgICAgICAgcHRybi5fX2RhdGEsIFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZHVyYXRpb24gXG4gICAgICApXG4gICAgICAuc29ydCggcHRybi5fX3NvcnQgKVxuXG4gICAgICByZXR1cm4gcHRybi5ldmVudHNcbiAgICB9LFxuXG4gICAgcHJpbnQoKSB7XG4gICAgICBpZiggcHRybi5ldmVudHMgIT09IG51bGwgKSB7XG4gICAgICAgIHB0cm4uZXZlbnRzLmZvckVhY2goIHYgPT4gXG4gICAgICAgICAgY29uc29sZS5sb2coIFxuICAgICAgICAgICAgYCR7di5hcmMuc3RhcnQudG9GcmFjdGlvbigpfSAtICR7di5hcmMuZW5kLnRvRnJhY3Rpb24oKX06IFsgJHt2LnZhbHVlLnRvU3RyaW5nKCl9IF1gIFxuICAgICAgICAgICkgXG4gICAgICAgIClcbiAgICAgIH1lbHNle1xuICAgICAgICBjb25zb2xlLmxvZyggJ05vIGV2ZW50cyBoYXZlIGJlZW4gZ2VuZXJhdGVkIGZyb20gdGhlIHBhdHRlcm47IGhhdmUgeW91IHF1ZXJpZWQgaXQgeWV0PycgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdHJuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0dGVyblxuIiwiY29uc3QgRnJhY3Rpb24gPSByZXF1aXJlKCAnZnJhY3Rpb24uanMnIClcbmNvbnN0IHV0aWwgICAgID0gcmVxdWlyZSggJ3V0aWwnIClcbmNvbnN0IGJqb3JrICAgID0gcmVxdWlyZSggJ2Jqb3JrJyApIFxuY29uc3QgbG9nICAgICAgPSB1dGlsLmluc3BlY3RcbmNvbnN0IHNyYW5kICAgID0gcmVxdWlyZSggJ3NlZWRyYW5kb20nIClcblxuY29uc3Qgcm5kID0gZnVuY3Rpb24oIHBoYXNlICkge1xuICAvL2NvbnNvbGUubG9nKCAncGhhc2UnLCBwaGFzZS50b0ZyYWN0aW9uKCkgKVxuICByZXR1cm4gbmV3IHNyYW5kKCBwaGFzZS50b0ZyYWN0aW9uKCkgKSgpXG59XG5cbi8qIHF1ZXJ5QXJjXG4gKlxuICogR2VuZXJhdGVzIGV2ZW50cyBmb3IgcHJvdmlkZWQgcGF0dGVybiwgc3RhcnRpbmcgYXRcbiAqIGFuIGluaXRpYWwgcGhhc2UsIHN1YmRpdmlkZXMgcXVlcmllcyBpbiBpbmRpdmlkdWFsIFxuICogY3ljbGVzIGlmIGR1cmF0aW9uIG9mIHF1ZXJ5IGlzIGdyZWF0ZXIgdGhhbiAxIGN5Y2xlLlxuICogRmlsdGVycyBldmVudHMgb3V0c2lkZSBvZiB0aGUgdGhlIGludGVuZGVkIHJhbmdlLiBcbiAqIFJlbWFwcyBldmVudHMgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gKi9cbmNvbnN0IHF1ZXJ5QXJjID0gZnVuY3Rpb24oIHBhdHRlcm4sIHBoYXNlLCBkdXJhdGlvbiApIHtcbiAgY29uc3Qgc3RhcnQgICAgICAgICA9IHBoYXNlLmNsb25lKCksXG4gICAgICAgIGVuZCAgICAgICAgICAgPSBzdGFydC5hZGQoIGR1cmF0aW9uICksXG4gICAgICAgIC8vIGdldCBwaGFzZSBvZmZzZXQgaWYgc2NoZWR1bGluZyBiZWdpbnMgaW4gbWlkZGxlIG9mIGV2ZW50IGFyY1xuICAgICAgICBhZGp1c3RlZFBoYXNlID0gYWRqdXN0UGhhc2UoIHBoYXNlLCBnZXRQaGFzZUluY3IoIHBhdHRlcm4gKSwgZW5kIClcblxuICBsZXQgZXZlbnRMaXN0XG5cbiAgLy8gaWYgd2UncmUgcXVlcnlpbmcgYW4gYXJjIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG9uZSBjeWNsZSBpbiBsZW5ndGguLlxuICBpZiggZHVyYXRpb24udmFsdWVPZigpIDw9IDEgKSB7XG4gICAgZXZlbnRMaXN0ID0gcHJvY2Vzc1BhdHRlcm4oIFxuICAgICAgcGF0dGVybiwgXG4gICAgICBkdXJhdGlvbiwgXG4gICAgICBhZGp1c3RlZFBoYXNlLCBcbiAgICAgIG51bGwsIFxuICAgICAgbnVsbCwgXG4gICAgICBmYWxzZS8vc2hvdWxkUmVtYXAoIHBhdHRlcm4gKSBcbiAgICApXG4gIH1lbHNle1xuICAgIC8vIGZvciBsb25nZXIgYXJjcyB3ZSBuZWVkIHRvIHF1ZXJ5IG9uZSBjeWNsZSBhdCBhIHRpbWVcbiAgICBldmVudExpc3QgPSBbXVxuICAgIGxldCBjb3VudCA9IDBcbiAgICBmb3IoIGxldCBpID0gYWRqdXN0ZWRQaGFzZS52YWx1ZU9mKCk7IGkgPCBhZGp1c3RlZFBoYXNlLmFkZCggZHVyYXRpb24gKS52YWx1ZU9mKCk7IGkrKyApIHtcbiAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQoIFxuICAgICAgICBwcm9jZXNzUGF0dGVybiggXG4gICAgICAgICAgcGF0dGVybiwgXG4gICAgICAgICAgRnJhY3Rpb24oMSksXG4gICAgICAgICAgYWRqdXN0ZWRQaGFzZS5hZGQoIGNvdW50KysgKSwgXG4gICAgICAgICAgbnVsbCwgXG4gICAgICAgICAgbnVsbCwgXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIHBydW5lIGFueSBldmVudHMgdGhhdCBmYWxsIGJlZm9yZSBvdXIgc3RhcnQgcGhhc2Ugb3IgYWZ0ZXIgb3VyIGVuZCBwaGFzZVxuICBldmVudExpc3QgPSBldmVudExpc3QuZmlsdGVyKCBldnQgPT4ge1xuICAgIHJldHVybiAoZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgPj0gc3RhcnQudmFsdWVPZigpIFxuICAgICAgICAmJiBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSAgPCAgZW5kLnZhbHVlT2YoKSApIFxuICB9KVxuICAvLyByZW1hcCBldmVudHMgdG8gbWFrZSB0aGVpciBhcmNzIHJlbGF0aXZlIHRvIGluaXRpYWwgcGhhc2UgYXJndW1lbnRcbiAgLm1hcCggZXZ0ID0+IHtcbiAgICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5zdWIoIHN0YXJ0IClcbiAgICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQuc3ViKCBzdGFydCApXG4gICAgcmV0dXJuIGV2dFxuICB9KVxuIFxuICAvL2NvbnNvbGUubG9nKCAnZXZlbnRMaXN0OicsIGxvZyhldmVudExpc3Qse2RlcHRoOjR9KSApXG4gIHJldHVybiBldmVudExpc3Rcbn1cblxuLy8gaWYgYW4gZXZlbnQgaXMgZm91bmQgdGhhdCByZXByZXNlbnRzIGEgcGF0dGVybiAoYXMgb3Bwb3NlZCB0byBhIGNvbnN0YW50KSB0aGlzIGZ1bmN0aW9uXG4vLyBpcyBjYWxsZWQgdG8gcXVlcnkgdGhlIHBhdHRlcm4gYW5kIG1hcCBhbnkgZ2VuZXJhdGVkIGV2ZW50cyB0byB0aGUgYXBwcm9wcmlhdGUgdGltZXNwYW5cbmNvbnN0IHByb2Nlc3NQYXR0ZXJuID0gKCBwYXR0ZXJuLCBkdXJhdGlvbiwgcGhhc2UsIHBoYXNlSW5jcj1udWxsLCBvdmVycmlkZSA9IG51bGwsIHNob3VsZFJlbWFwQXJjcz1mYWxzZSApID0+IHtcbiAgLy9pZiggcGhhc2VJbmNyICE9PSBudWxsICkgZGVidWdnZXJcbiAgY29uc3Qgc3RhdGUgPSBbXVxuICBzdGF0ZS5waGFzZSA9IHBoYXNlXG4gIGxldCBldmVudHMgPSBoYW5kbGVyc1sgcGF0dGVybi50eXBlIF0oIFxuICAgIHN0YXRlLCBcbiAgICBwYXR0ZXJuLCBcbiAgICAvKnNob3VsZFJlc2V0KCBwYXR0ZXJuICkgPT09IHRydWUgPyBGcmFjdGlvbigwKSA6Ki8gcGhhc2UuY2xvbmUoKSwgXG4gICAgLy8gWFhYIHRoaXMgaXMgY29uZnVzaW5nLiB3ZSBhcmUgZ2V0dGluZyBhcm91bmQgYSBwcm9ibGVtXG4gICAgLy8gd2l0aCBwb2x5bWV0ZXJzIHdoZXJlIGR1cGxpY2F0ZSBldmVudHMgYXJlIGdlbmVyYXRlZCBieVxuICAgIC8vIG5vdCBwYXNzaW5nIGEgcGhhc2VJbmNyLi4uIGl0J3Mgbm90IG5lZWRlZCBzaW5jZSB0aGVyZSdzIGFuXG4gICAgLy8gb3ZlcnJpZGUuIEJ1dCB0aGlzIGRvZXNuJ3Qgc2VlbSBsaWtlIGNvcnJlY3Qgd2F5IHRvIHNvbHZlXG4gICAgLy8gdGhpcyBwcm9ibGVtIGFuZCB3aWxsIHByb2JhYmx5IGNhdXNlIGZ1dHVyZSBwcm9ibGVtcy4uLlxuICAgIHBoYXNlSW5jciAhPT0gbnVsbCA/IGR1cmF0aW9uLmRpdiggcGhhc2VJbmNyICkgOiBkdXJhdGlvbiwgXG4gICAgb3ZlcnJpZGUgXG4gIClcblxuICAvLyBpZiBuZWVkZWQsIHJlbWFwIGFyY3MgZm9yIGV2ZW50c1xuICBpZiggc2hvdWxkUmVtYXBBcmNzID09PSB0cnVlICkge1xuICAgIGlmKCBwaGFzZUluY3IgPT09IG51bGwgKSBwaGFzZUluY3IgPSBnZXRQaGFzZUluY3IoIHBhdHRlcm4gKVxuICAgIGV2ZW50cyA9IGV2ZW50cy5tYXAoIHYgPT4gKHtcbiAgICAgIHZhbHVlOiB2LnZhbHVlLFxuICAgICAgYXJjOiBnZXRNYXBwZWRBcmMoIHYuYXJjLCBwaGFzZS5jbG9uZSgpLCBwaGFzZUluY3IgKVxuICAgIH0pIClcbiAgfVxuIFxuICByZXR1cm4gZXZlbnRzIFxufVxuLy8gcGxhY2Vob2xkZXIgZm9yIHBvdGVudGlhbGx5IGFkZGluZyBtb3JlIGdvb2RpZXMgKHBhcmVudCBhcmMgZXRjLikgbGF0ZXJcbmNvbnN0IEFyYyA9ICggc3RhcnQsIGVuZCApID0+ICh7IHN0YXJ0LCBlbmQgfSlcblxuY29uc3Qgc2hvdWxkTm90UmVtYXAgPSBbJ3BvbHltZXRlcicsICdvbmVzdGVwJ11cbmNvbnN0IHNob3VsZFJlbWFwID0gcGF0dGVybiA9PiBzaG91bGROb3RSZW1hcC5pbmRleE9mKCBwYXR0ZXJuLnR5cGUgKSA9PT0gLTFcblxuLy8gWFhYIHNlZW1zIGxpa2UgZ2V0TWFwcGVkQXJjIHNob3VsZCBiZSBjaGFuZ2VkIHRvIHdoYXQgb25lc3RlcCBhbmQgZ3JvdXAgYXJlIG5vdyB1c2luZz9cbi8vIHdvdWxkIHRoYXQgY2hhbmdlIHdvcmsgd2l0aCBob3cgZ2V0TWFwcGVkQXJjIGlzIHVzZWQgaW4gcHJvY2Vzc1BhdHRlcm4/XG5cbi8vIG1hcCBhcmMgdGltZSB2YWx1ZXMgdG8gYXBwcm9wcmlhdGUgZHVyYXRpb25zXG5jb25zdCBnZXRNYXBwZWRBcmMgPSAoIGFyYywgcGhhc2UsIHBoYXNlSW5jciApID0+IHtcbiAgbGV0IG1hcHBlZEFyY1xuICBcbiAgaWYoIHBoYXNlLm1vZCggcGhhc2VJbmNyICkudmFsdWVPZigpICE9PSAwICkge1xuICAgIG1hcHBlZEFyYyA9IEFyYyggXG4gICAgICBhcmMuc3RhcnQubXVsKCBwaGFzZUluY3IgKS5hZGQoIHBoYXNlICksIFxuICAgICAgYXJjLmVuZC5tdWwoIHBoYXNlSW5jciApLmFkZCggcGhhc2VJbmNyLm1vZCggcGhhc2UgKSApIFxuICAgIClcbiAgfWVsc2V7XG4gICAgbWFwcGVkQXJjID0gQXJjKCBcbiAgICAgIGFyYy5zdGFydC5tdWwoIHBoYXNlSW5jciApLmFkZCggcGhhc2UgKSwgXG4gICAgICBhcmMuZW5kLm11bCggcGhhc2VJbmNyICkuYWRkKCBwaGFzZSApIFxuICAgIClcbiAgfVxuICBcbiAgcmV0dXJuIG1hcHBlZEFyY1xufVxuXG4vLyBpZiBpbml0aWFsIHBoYXNlIGlzIGluIHRoZSBtaWRkbGUgb2YgYW4gYXJjLCBhZHZhbmNlIHRvIHRoZSBlbmQgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2Vcbi8vIGJldHdlZW4gdGhlIGN1cnJlbnQgcGhhc2UgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBhcmMsIGFuZCBpbmNyZWFzaW5nIHBoYXNlIGFjY29yZGluZ2x5LlxuY29uc3QgYWRqdXN0UGhhc2UgPSAoIHBoYXNlLCBwaGFzZUluY3IsIGVuZCApID0+IHBoYXNlLnZhbHVlT2YoKSA9PT0gMCBcbiAgPyBGcmFjdGlvbigwKSBcbiAgOiBwaGFzZS5zdWIoIHBoYXNlLm1vZCggcGhhc2VJbmNyICkgKVxuXG4vLyBjaGVjayB0byBzZWUgaWYgcGhhc2Ugc2hvdWxkIGFkdmFuY2UgdG8gbmV4dCBldmVudCwgb3IsIGlmIG5leHQgZXZlbnQgaXMgdG9vIGZhciBpbiB0aGUgZnV0dXJlLCB0byB0aGVcbi8vIGVuZCBvZiB0aGUgY3VycmVudCBkdXJhdGlvbiBiZWluZyByZXF1ZXN0ZWQuXG5jb25zdCBhZHZhbmNlUGhhc2UgPSAoIHBoYXNlLCBwaGFzZUluY3IsIGVuZCApID0+IHBoYXNlICsgcGhhc2VJbmNyIDw9IGVuZCA/IHBoYXNlLmFkZCggcGhhc2VJbmNyICkgOiBlbmQgXG5cbi8vIGNhbGN1bGF0ZSB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgZXZlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuY29uc3QgY2FsY3VsYXRlRHVyYXRpb24gPSAoIHBoYXNlLCBwaGFzZUluY3IsIGVuZCApID0+IHBoYXNlICsgcGhhc2VJbmNyIDw9IGVuZCA/IHBoYXNlSW5jciA6IGVuZC5zdWIoIHBoYXNlIClcblxuLy8gZ2V0IGFuIGluZGV4IG51bWJlciBmb3IgYSBwYXR0ZXJuIGZvciBhIHBhcnRpY3VsYXIgcGhhc2VcbmNvbnN0IGdldEluZGV4ID0gKCBwYXR0ZXJuLCBwaGFzZSApID0+IHtcbiAgbGV0IGlkeCA9IDBcbiAgaWYoIHBhdHRlcm4ub3B0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuICAgIGlmKCBwYXR0ZXJuLm9wdGlvbnMub3ZlcnJpZGVJbmNyID09PSB0cnVlICkge1xuICAgICAgaWR4ID0gcGhhc2UuZGl2KCBwYXR0ZXJuLm9wdGlvbnMuaW5jciApLm1vZCggcGF0dGVybi52YWx1ZXMubGVuZ3RoICkuZmxvb3IoKVxuICAgIH1cbiAgfWVsc2V7XG4gICAgLy8gZGVmYXVsdCBsaXN0IGJlaGF2aW9yXG4gICAgaWR4ID0gcGhhc2UubXVsKCBGcmFjdGlvbiggcGF0dGVybi52YWx1ZXMubGVuZ3RoICkgKS5tb2QoIHBhdHRlcm4udmFsdWVzLmxlbmd0aCApLmZsb29yKClcbiAgfVxuXG4gIHJldHVybiBpZHgudmFsdWVPZigpXG59XG5cbi8vIGluIGFkZGl0aW9uIHRvICdmYXN0JywgcGhhc2UgcmVzZXRzIGFyZSBhbHNvIG5lY2Vzc2FyeSB3aGVuIGluZGV4aW5nIHN1YnBhdHRlcm5zLFxuLy8gd2hpY2ggYXJlIGN1cnJlbnRseSBhcnJheXMgd2l0aCBubyBkZWZpbmVkIC50eXBlIHByb3BlcnR5LCBoZW5jZSB0aGUgaW5jbHVzaW9uIG9mXG4vLyB1bmRlZmluZWQgaW4gdGhlIGFycmF5IGJlbG93XG5jb25zdCBzaG91bGRSZXNldFBoYXNlID0gWyAncmVwZWF0JywgdW5kZWZpbmVkLCAnZ3JvdXAnLCAnbGF5ZXJzJyBdIFxuXG4vLyBYWFggZG9lcyB0aGVzZSBuZWVkIHRvIGxvb2sgYXQgYWxsIHBhcmVudHMgcmVjdXJzaXZlbHk/IFJpZ2h0IG5vdyB3ZSdyZSBvbmx5IHVzaW5nIG9uZSBnZW5lcmF0aW9uLi4uXG5jb25zdCBzaG91bGRSZXNldCA9IHBhdHRlcm4gPT4ge1xuICBjb25zdCByZXNldCA9IHNob3VsZFJlc2V0UGhhc2UuaW5kZXhPZiggcGF0dGVybi50eXBlICkgPiAtMSBcbiAgY29uc3QgcGFyZW50ID0gcGF0dGVybi5wYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBzaG91bGRSZXNldFBoYXNlLmluZGV4T2YoIHBhdHRlcm4ucGFyZW50LnR5cGUgKSA+IC0xXG5cbiAgcmV0dXJuIHJlc2V0ICYmIHBhcmVudFxufVxuXG4vLyBJIGFzc3VtZSB0aGlzIHdpbGwgbmVlZCB0byBiZSBhIHN3aXRjaCBvbiBwYXR0ZXJuLnR5cGUgaW4gdGhlIGZ1dHVyZS4uLlxuY29uc3QgZ2V0UGhhc2VJbmNyID0gcGF0dGVybiA9PiB7XG4gIGxldCBpbmNyXG5cbiAgc3dpdGNoKCBwYXR0ZXJuLnR5cGUgKSB7XG4gICAgY2FzZSAncG9seW1ldGVyJzogaW5jciA9IEZyYWN0aW9uKCAxLCBwYXR0ZXJuLmxlZnQudmFsdWVzLmxlbmd0aCApOyBicmVhaztcbiAgICBjYXNlICdudW1iZXInOiBjYXNlICdzdHJpbmcnOiBpbmNyID0gRnJhY3Rpb24oIDEgKTsgYnJlYWs7XG4gICAgY2FzZSAnb25lc3RlcCc6IGluY3IgPSBudWxsOyBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYoIHBhdHRlcm4udmFsdWVzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgaW5jciA9IEZyYWN0aW9uKDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNyID0gRnJhY3Rpb24oIDEsIHBhdHRlcm4udmFsdWVzLmxlbmd0aCApXG4gICAgICAgIC8vbGV0IGxlbiA9IDBcbiAgICAgICAgLy9wYXR0ZXJuLnZhbHVlcy5mb3JFYWNoKCB2ID0+IGxlbiArPSB2LnR5cGUgPT09ICdzbG93JyA/IHYucmF0ZS52YWx1ZSA6IDEgKVxuICAgICAgICAvL2luY3IgPSBGcmFjdGlvbiggMSwgbGVuICkgXG4gICAgICB9XG4gICAgICBicmVhaztcblxuICB9XG5cbiAgcmV0dXJuIGluY3Jcbn1cblxuY29uc3QgaGFuZGxlcnMgPSB7XG4gIHJlc3QoIHN0YXRlICkgeyByZXR1cm4gc3RhdGUgfSxcblxuICAvLyBzdGFuZGFyZCBsaXN0cyBlLmcuICcwIDEgMiAzJyBvciAnWzAgMSAyXSdcbiAgZ3JvdXAoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24sIG92ZXJyaWRlSW5jcj1udWxsICkge1xuICAgIGNvbnN0IHN0YXJ0ICAgICA9IHBoYXNlLmNsb25lKCksXG4gICAgICAgICAgZW5kICAgICAgID0gc3RhcnQuYWRkKCBkdXJhdGlvbiApLFxuICAgICAgICAgIHBoYXNlSW5jciA9IG92ZXJyaWRlSW5jciA9PT0gbnVsbCBcbiAgICAgICAgICAgID8gZ2V0UGhhc2VJbmNyKCBwYXR0ZXJuICkgXG4gICAgICAgICAgICA6IG92ZXJyaWRlSW5jclxuICAgICAgICAgIFxuICAgIGxldCBldmVudExpc3QgPSBbXVxuXG4gICAgLy9jb25zb2xlLmxvZyggXG4gICAgLy8gICd0eXBlOicsICBwYXR0ZXJuLnR5cGUsIFxuICAgIC8vICAncGhhc2U6JywgcGhhc2UudG9GcmFjdGlvbigpLFxuICAgIC8vICAnaW5jcjonLCAgcGhhc2VJbmNyLnRvRnJhY3Rpb24oKSxcbiAgICAvLyAgJ2R1cjonLCAgIGR1cmF0aW9uLnRvRnJhY3Rpb24oKVxuICAgIC8vKVxuICAgIFxuICAgIHdoaWxlKCBwaGFzZS5jb21wYXJlKCBlbmQgKSA8IDAgKSB7XG4gICAgICAvLyBpZiBwYXR0ZXJuIGlzIGEgbGlzdCwgcmVhZCB1c2luZyBjdXJyZW50IHBoYXNlLCBlbHNlIHJlYWQgZGlyZWN0bHlcbiAgICAgIGNvbnN0IG1lbWJlciA9IEFycmF5LmlzQXJyYXkoIHBhdHRlcm4udmFsdWVzICkgPT09IHRydWUgXG4gICAgICAgID8gcGF0dGVybi52YWx1ZXNbIGdldEluZGV4KCBwYXR0ZXJuLCBwaGFzZSApIF0gXG4gICAgICAgIDogcGF0dGVybi52YWx1ZVxuXG4gICAgICAvLyBnZXQgZHVyYXRpb24gb2YgY3VycmVudCBldmVudCBiZWluZyBwcm9jZXNzZWRcbiAgICAgIGNvbnN0IGR1ciA9IGNhbGN1bGF0ZUR1cmF0aW9uKCBwaGFzZSwgcGhhc2VJbmNyLCBlbmQgKVxuXG4gICAgICAvLyBpZiB2YWx1ZSBpcyBub3QgYSBudW1lcmljIG9yIHN0cmluZyBjb25zdGFudCAoaWYgaXQncyBhIHBhdHRlcm4pLi4uXG4gICAgICBpZiggbWVtYmVyID09PSB1bmRlZmluZWQgfHwgKGlzTmFOKCBtZW1iZXIudmFsdWUgKSAmJiB0eXBlb2YgbWVtYmVyLnZhbHVlICE9PSAnc3RyaW5nJykgKSB7XG4gICAgICAgIC8vIHF1ZXJ5IHRoZSBwYXR0ZXJuIGFuZCByZW1hcCB0aW1lIHZhbHVlcyBhcHByb3ByaWF0ZWx5IFxuICAgICAgICBpZiggbWVtYmVyICE9PSB1bmRlZmluZWQgKSBtZW1iZXIucGFyZW50ID0gcGF0dGVyblxuICAgICAgICAvL2NvbnNvbGUubG9nKCAncHJvY2Vzc2luZyAnLCBwYXR0ZXJuLnR5cGUsIG1lbWJlci50eXBlLCBkdXIudG9GcmFjdGlvbigpLCAgcGhhc2VJbmNyLnRvRnJhY3Rpb24oKSApXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHByb2Nlc3NQYXR0ZXJuKCBcbiAgICAgICAgICBtZW1iZXIsIFxuICAgICAgICAgIEZyYWN0aW9uKDEpLCBcbiAgICAgICAgICAvL21lbWJlci50eXBlICE9PSAnc2xvdycgPyBGcmFjdGlvbigwKSA6IHBoYXNlLmNsb25lKCksIFxuICAgICAgICAgIEZyYWN0aW9uKDApLFxuICAgICAgICAgIG51bGwsIC8vZ2V0UGhhc2VJbmNyKG1lbWJlciksXG4gICAgICAgICAgbnVsbCwgXG4gICAgICAgICAgZmFsc2UvL3Nob3VsZFJlbWFwKCBtZW1iZXIgKVxuICAgICAgICApXG4gICAgICAgIC5tYXAoIGV2dCA9PiB7XG4gICAgICAgICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQubXVsKCBkdXIgKS5hZGQoIHBoYXNlIClcbiAgICAgICAgICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5lbmQubXVsKCBkdXIgKS5hZGQoIHBoYXNlIClcbiAgICAgICAgICByZXR1cm4gZXZ0XG4gICAgICAgIH0pXG5cbiAgICAgICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmNvbmNhdCggZXZlbnRzIClcbiAgICAgIH1lbHNle1xuICAgICAgICAvLyBYWFggc2hvdWxkbid0IHdlIGp1c3QgcHJvY2VzcyBhbGwgcGF0dGVybnM/Pz9cbiAgICAgICAgLy8gbWVtYmVyIGRvZXMgbm90IG5lZWQgZnVydGhlciBwcm9jZXNzaW5nLCBzbyBhZGQgdG8gZXZlbnQgbGlzdFxuICAgICAgICBjb25zdCBldnQgPSB7IFxuICAgICAgICAgIHZhbHVlOm1lbWJlci52YWx1ZSwgXG4gICAgICAgICAgYXJjOkFyYyggcGhhc2UsIHBoYXNlLmFkZCggZHVyICkgKSxcbiAgICAgICAgfVxuICAgICAgICBpZiggbWVtYmVyLnVpZCAhPT0gdW5kZWZpbmVkICkgZXZ0LnVpZCA9IG1lbWJlci51aWQgXG5cbiAgICAgICAgZXZlbnRMaXN0LnB1c2goIGV2dCApXG4gICAgICB9XG5cbiAgICAgIC8vIGFzc3VtaW5nIHdlIGFyZSBzdGFydGluZyAvIGVuZGluZyBhdCBhIHJlZ3VsYXIgcGhhc2UgaW5jcmVtZW50IHZhbHVlLi4uXG4gICAgICBcbiAgICAgIGlmKCBwaGFzZS5tb2QoIHBoYXNlSW5jciApLnZhbHVlT2YoKSA9PT0gMCApIHtcbiAgICAgICAgcGhhc2UgPSBhZHZhbmNlUGhhc2UoIHBoYXNlLCBwaGFzZUluY3IsIGVuZCApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gYWR2YW5jZSBwaGFzZSB0byBuZXh0IHBoYXNlIGluY3JlbWVudFxuICAgICAgICBwaGFzZSA9IHBoYXNlLmFkZCggcGhhc2VJbmNyLnN1YiggcGhhc2UubW9kKCBwaGFzZUluY3IgKSApICkgXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJ1bmUgYW55IGV2ZW50cyB0aGF0IGZhbGwgYmVmb3JlIG91ciBzdGFydCBwaGFzZSBvciBhZnRlciBvdXIgZW5kIHBoYXNlXG4gICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmZpbHRlciggZXZ0ID0+IHtcbiAgICAgIHJldHVybiBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSA+PSBzdGFydC52YWx1ZU9mKCkgJiYgZXZ0LmFyYy5zdGFydC52YWx1ZU9mKCkgPCBlbmQudmFsdWVPZigpXG4gICAgfSlcbiAgIFxuICAgIHJldHVybiBzdGF0ZS5jb25jYXQoIGV2ZW50TGlzdCApXG4gIH0sXG5cbiAgYmpvcmtsdW5kKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIGNvbnN0IG9uZXNBbmRaZXJvcyA9IGJqb3JrKCBwYXR0ZXJuLnB1bHNlcy52YWx1ZSwgcGF0dGVybi5zbG90cy52YWx1ZSApXG4gICAgbGV0IHJvdGF0aW9uID0gcGF0dGVybi5yb3RhdGlvbiAhPT0gbnVsbCA/IHBhdHRlcm4ucm90YXRpb24udmFsdWUgOiAwXG4gICAgXG4gICAgLy8gcm90YXRlIHJpZ2h0XG4gICAgaWYoIHJvdGF0aW9uID4gMCApIHtcbiAgICAgIHdoaWxlKCByb3RhdGlvbiA+IDAgKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gb25lc0FuZFplcm9zLnBvcCgpXG4gICAgICAgIG9uZXNBbmRaZXJvcy51bnNoaWZ0KCByaWdodCApXG4gICAgICAgIHJvdGF0aW9uLS1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIHJvdGF0aW9uIDwgMCApIHtcbiAgICAgIC8vIHJvdGF0ZSBsZWZ0XG4gICAgICB3aGlsZSggcm90YXRpb24gPCAwICkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gb25lc0FuZFplcm9zLnNoaWZ0KClcbiAgICAgICAgb25lc0FuZFplcm9zLnB1c2goIGxlZnQgKVxuICAgICAgICByb3RhdGlvbisrXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNsb3REdXJhdGlvbiA9IGR1cmF0aW9uLmRpdiggcGF0dGVybi5zbG90cy52YWx1ZSApXG4gICAgY29uc3QgdmFsdWVJc1ZhbHVlID0gcGF0dGVybi52YWx1ZS50eXBlID09PSAnbnVtYmVyJyB8fCBwYXR0ZXJuLnZhbHVlLnR5cGUgPT09ICdzdHJpbmcnXG5cbiAgICBjb25zdCBldmVudHMgPSBvbmVzQW5kWmVyb3MubWFwKCAoIHNob3VsZEluY2x1ZGUsIGksIGFyciApID0+IHtcbiAgICAgIGxldCBldnRcbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgdW5sZXNzIGFuIGFjdHVhbCBldmVudCB3aWxsIGJlIGluY2x1ZGVkLi4uXG4gICAgICBpZiggc2hvdWxkSW5jbHVkZSA9PT0gMSApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQaGFzZSA9IHBoYXNlLmFkZCggc2xvdER1cmF0aW9uLm11bCggaSApIClcbiAgICAgICAgZXZ0ID0ge1xuICAgICAgICAgIHNob3VsZEluY2x1ZGUsXG4gICAgICAgICAgLy8gWFhYIGlzIHRoZXJlIGEgY2FzZSB3aGVyZSB3ZSBzaG91bGQgdXNlIG1vcmUgdGhhbiBcbiAgICAgICAgICAvLyB0aGUgZmlyc3QgdmFsdWUgYnkgcXVlcnlpbmcgdGhlIHZhbHVlIHBhdHRlcm4/XG4gICAgICAgICAgdmFsdWU6dmFsdWVJc1ZhbHVlID8gcGF0dGVybi52YWx1ZSA6IHByb2Nlc3NQYXR0ZXJuKCBwYXR0ZXJuLnZhbHVlLCBzbG90RHVyYXRpb24sIHN0YXJ0UGhhc2UgKVswXS52YWx1ZSxcbiAgICAgICAgICBhcmM6QXJjKCBzdGFydFBoYXNlLCBzdGFydFBoYXNlLmFkZCggc2xvdER1cmF0aW9uICkgKSBcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGV2dCA9IHsgc2hvdWxkSW5jbHVkZSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldnRcbiAgICB9KVxuICAgIC5maWx0ZXIoIGV2dCA9PiB7XG4gICAgICBsZXQgc2hvdWxkSW5jbHVkZSA9IGV2dC5zaG91bGRJbmNsdWRlXG5cbiAgICAgIC8vIG5lZWRlZCB0byBwYXNzIHRlc3RzIGFuZCBpcyBhbHNvIGNsZWFuZXIuLi5cbiAgICAgIGRlbGV0ZSBldnQuc2hvdWxkSW5jbHVkZVxuICAgICAgcmV0dXJuIHNob3VsZEluY2x1ZGUgPT09IDFcbiAgICB9KVxuXG4gICAgZXZlbnRzLmZvckVhY2goIGV2dCA9PiB7XG4gICAgICBldnQudWlkID0gcGF0dGVybi52YWx1ZS51aWRcbiAgICAgIHN0YXRlLnB1c2goIGV2dCApIFxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHN0YXRlXG4gIH0sXG5cbiAgb25lc3RlcCggc3RhdGUsIHBhdHRlcm4sIHBoYXNlLCBkdXJhdGlvbiApIHtcbiAgICBwYXR0ZXJuLnZhbHVlcy5mb3JFYWNoKCBncm91cCA9PiB7XG4gICAgICAvLyBpbml0aWFsaXplLCB0aGVuIGluY3JlbWVudC4gdGhpcyBhc3N1bWVzIHRoYXQgdGhlIHBhdHRlcm4gd2lsbCBiZSBwYXJzZWQgb25jZSxcbiAgICAgIC8vIGFuZCB0aGVuIHRoZSByZXN1bHRpbmcgZGF0YSBzdHJ1Y3R1cmUgd2lsbCBiZSBxdWVyaWVkIHJlcGVhdGVkbHksIGVuYWJsaW5nIHRoZSB1c2VcbiAgICAgIC8vIG9mIHN0YXRlLlxuICAgICAgZ3JvdXAuY291bnQgPSBncm91cC5jb3VudCA9PT0gdW5kZWZpbmVkID8gMCA6IGdyb3VwLmNvdW50ICsgMVxuXG4gICAgICBjb25zdCBzdWJwYXR0ZXJuID0gZ3JvdXAudmFsdWVzWyBncm91cC5jb3VudCAlIGdyb3VwLnZhbHVlcy5sZW5ndGggXVxuICAgICAgY29uc3QgZHVyID0gZHVyYXRpb24udmFsdWVPZigpIDw9IDEgPyBGcmFjdGlvbigxKSA6IGR1cmF0aW9uIFxuICAgICAgY29uc3QgZHVyRGlmZiA9IGR1cmF0aW9uLm11bCggZHVyICkgXG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IHByb2Nlc3NQYXR0ZXJuKCBcbiAgICAgICAgc3VicGF0dGVybiwgXG4gICAgICAgIGR1cixcbiAgICAgICAgRnJhY3Rpb24oMCksIFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLG51bGwsdHJ1ZVxuICAgICAgKS5tYXAoIGV2dCA9PiB7XG4gICAgICAgIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0Lm11bCggZHVyYXRpb24gKS5hZGQoIHBoYXNlIClcbiAgICAgICAgZXZ0LmFyYy5lbmQgPSBldnQuYXJjLmVuZC5tdWwoIGR1cmF0aW9uICkuYWRkKCBwaGFzZSApXG5cbiAgICAgICAgcmV0dXJuIGV2dFxuICAgICAgfSkgIFxuXG4gICAgICBzdGF0ZS5wdXNoKCAuLi5ldmVudHMgKVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RhdGVcbiAgfSxcblxuICBudW1iZXIoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgLy9pZiggcGhhc2UudmFsdWVPZigpID09PSAwICkge1xuICAgICAgY29uc3QgZXZ0ID0geyBhcmM6QXJjKCBwaGFzZSwgcGhhc2UuYWRkKCBkdXJhdGlvbiApICksIHZhbHVlOnBhdHRlcm4udmFsdWUgfVxuICAgICAgaWYoIHBhdHRlcm4udWlkICE9PSB1bmRlZmluZWQgKSBldnQudWlkID0gcGF0dGVybi51aWRcbiAgICAgIHN0YXRlLnB1c2goZXZ0KVxuICAgIC8vfVxuICAgIHJldHVybiBzdGF0ZSBcbiAgfSxcblxuICBzdHJpbmcoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgY29uc3QgZXZ0ID0geyBhcmM6QXJjKCBwaGFzZSwgcGhhc2UuYWRkKCBkdXJhdGlvbiApICksIHZhbHVlOnBhdHRlcm4udmFsdWUgfVxuICAgIGlmKCBwYXR0ZXJuLnVpZCAhPT0gdW5kZWZpbmVkICkgZXZ0LnVpZCA9IHBhdHRlcm4udWlkXG4gICAgc3RhdGUucHVzaChldnQpXG4gICAgcmV0dXJuIHN0YXRlIFxuICB9LFxuXG4gIGRlZ3JhZGUoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgLy8gYXR0ZW1wdCB0byBzZWVkIHJhbmRvbS4uLiBybmQoIHN0YXRlLnBoYXNlIClcbiAgICBjb25zdCBybnVtID0gTWF0aC5yYW5kb20oKVxuICAgIC8vY29uc29sZS5sb2coICdybmQ6Jywgcm51bSwgc3RhdGUucGhhc2UudG9GcmFjdGlvbigpIClcbiAgICBpZiggcm51bSA+IC41ICkge1xuICAgICAgY29uc3QgZXZ0ID0geyBcbiAgICAgICAgYXJjOkFyYyggcGhhc2UsIHBoYXNlLmFkZCggZHVyYXRpb24gKSApLCBcbiAgICAgICAgdmFsdWU6cGF0dGVybi52YWx1ZS52YWx1ZVxuICAgICAgfVxuXG4gICAgICAvL2NvbnNvbGUubG9nKCAnYWRkaW5nJywgZXZ0IClcblxuICAgICAgaWYoIHBhdHRlcm4udWlkICE9PSB1bmRlZmluZWQgKSBldnQudWlkID0gcGF0dGVybi51aWRcblxuICAgICAgc3RhdGUucHVzaCggZXZ0IClcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUgXG4gIH0sXG5cbiAgcG9seW1ldGVyKCBzdGF0ZSwgcGF0dGVybiwgcGhhc2UsIGR1cmF0aW9uICkge1xuICAgIHBhdHRlcm4ubGVmdC5wYXJlbnQgPSBwYXR0ZXJuLnJpZ2h0LnBhcmVudCA9IHBhdHRlcm5cblxuICAgIGNvbnN0IGluY3IgID0gRnJhY3Rpb24oIDEsIHBhdHRlcm4ubGVmdC52YWx1ZXMubGVuZ3RoIClcbiAgICBjb25zdCBsZWZ0ICA9IHByb2Nlc3NQYXR0ZXJuKCBwYXR0ZXJuLmxlZnQsIGR1cmF0aW9uLCBwaGFzZS5jbG9uZSgpLCBkdXJhdGlvbiwgaW5jciwgZmFsc2UgKVxuXG4gICAgcGF0dGVybi5yaWdodC5vcHRpb25zID0geyBvdmVycmlkZUluY3I6IHRydWUsIGluY3IgfVxuICAgIGNvbnN0IHJpZ2h0ID0gcHJvY2Vzc1BhdHRlcm4oIHBhdHRlcm4ucmlnaHQsIGR1cmF0aW9uLCBwaGFzZS5jbG9uZSgpLCBkdXJhdGlvbiwgaW5jciwgZmFsc2UgKSBcblxuICAgIHJldHVybiBzdGF0ZS5jb25jYXQoIGxlZnQgKS5jb25jYXQoIHJpZ2h0IClcbiAgfSxcblxuICBsYXllcnMoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgLy9wYXR0ZXJuLmxlZnQucGFyZW50ID0gcGF0dGVybi5yaWdodC5wYXJlbnQgPSBwYXR0ZXJuXG4gICAgZm9yKCBjb25zdCBncm91cCBvZiBwYXR0ZXJuLnZhbHVlcyApIHtcbiAgICAgIGNvbnN0IGluY3IgPSBnZXRQaGFzZUluY3IoIGdyb3VwIClcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHByb2Nlc3NQYXR0ZXJuKCBncm91cCwgZHVyYXRpb24uY2xvbmUoKSwgcGhhc2UuY2xvbmUoKSwgZHVyYXRpb24sIG51bGwsIGZhbHNlKVxuICAgICAgLy8gbm90IHN1cmUgd2h5IGV4Y2VzcyBldmVudHMgYXJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgbmVlZCB0byBiZSBmaWx0ZXJlZC4uLlxuICAgICAgLmZpbHRlciggZXZ0ID0+IFxuICAgICAgICBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSA+PSBwaGFzZS52YWx1ZU9mKCkgXG4gICAgICAgICYmIGV2dC5hcmMuc3RhcnQudmFsdWVPZigpIDwgcGhhc2UuYWRkKCBkdXJhdGlvbiApLnZhbHVlT2YoKVxuICAgICAgKVxuICAgICAgXG4gICAgICAvL2NvbnNvbGUubG9nKCAnZ3JvdXA6JywgdXRpbC5pbnNwZWN0KCBncm91cCwgeyBkZXB0aDozIH0pIClcbiAgICAgIC8vY29uc29sZS5sb2coICdzdGF0ZTonLCB1dGlsLmluc3BlY3QoIGV2ZW50cywgeyBkZXB0aDozIH0pKVxuICAgICAgc3RhdGUgPSBzdGF0ZS5jb25jYXQoIGV2ZW50cyApXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlXG4gIH0sXG5cbiAgc2xvdyggc3RhdGUsIHBhdHRlcm4sIHBoYXNlLCBkdXJhdGlvbiApIHtcbiAgICBjb25zdCBzcGVlZCA9IHBhdHRlcm4ucmF0ZS52YWx1ZVxuXG4gICAgbGV0IGV2ZW50c1xuICAgIC8vaWYoIHBoYXNlLnZhbHVlT2YoKSAlIHNwZWVkID09PSAwICkge1xuICAgICAgLy8gWFhYIHdoeSBkbyB3ZSBuZWVkIHRoaXMgZWRnZSBjYXNlP1xuICAgICAgY29uc3QgcGhhc2VEaWZmID0gcGhhc2Uuc3ViKCBwaGFzZS5kaXYoIHNwZWVkICkgKVxuXG4gICAgICBpZiggcGF0dGVybi52YWx1ZS50eXBlICE9PSAnbGF5ZXJzJyApIHtcbiAgICAgICAgLy9ldmVudHMgPSBxdWVyeUFyYyhcbiAgICAgICAgLy8gIHBhdHRlcm4udmFsdWUsXG4gICAgICAgIC8vICBwaGFzZS5kaXYoIHNwZWVkICksXG4gICAgICAgIC8vICBkdXJhdGlvbi5kaXYoIHNwZWVkIClcbiAgICAgICAgLy8pXG4gICAgICAgIC8vY29uc29sZS5sb2coIGR1cmF0aW9uLCBwaGFzZSwgc3BlZWQgKVxuICAgICAgICAvL2V2ZW50cyA9IHByb2Nlc3NQYXR0ZXJuKFxuICAgICAgICAvLyAgcGF0dGVybi52YWx1ZSxcbiAgICAgICAgLy8gIGR1cmF0aW9uLm11bCggc3BlZWQgKSxcbiAgICAgICAgLy8gIHBoYXNlLmRpdiggc3BlZWQgKVxuICAgICAgICAvLykgICAgICAgXG4gICAgICAgIGV2ZW50cyA9IHF1ZXJ5QXJjKFxuICAgICAgICAgIHBhdHRlcm4udmFsdWUsXG4gICAgICAgICAgRnJhY3Rpb24oMCksXG4gICAgICAgICAgZHVyYXRpb24uZGl2KCBzcGVlZCApIFxuICAgICAgICApLm1hcCggZXZ0ID0+IHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gZXZ0LmFyYy5lbmQuc3ViKCBldnQuYXJjLnN0YXJ0IClcbiAgICAgICAgICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5hZGQoIHBoYXNlIClcbiAgICAgICAgICBldnQuYXJjLmVuZCAgID0gZXZ0LmFyYy5zdGFydC5hZGQoIGR1cmF0aW9uLm11bCggc3BlZWQgKSApLmFkZCggcGhhc2UgKVxuICAgICAgICAgIC8vY29uc29sZS5sb2coIGRpZmYsIGR1cmF0aW9uLm11bCggc3BlZWQgKSwgZXZ0LmFyYy5zdGFydCwgZXZ0LmFyYy5lbmQgKVxuICAgICAgICAgIHJldHVybiBldnRcbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICBldmVudHMgPSBoYW5kbGVycy5sYXllcnMoIHN0YXRlLCBwYXR0ZXJuLnZhbHVlLCBwaGFzZS5kaXYoIHNwZWVkICksIGR1cmF0aW9uLmRpdiggc3BlZWQgKSApXG4gICAgICB9XG5cbiAgICAgIC8vY29uc29sZS5sb2coIGxvZyggZXZlbnRzLCB7IGRlcHRoOjMgfSksIHBoYXNlLmFkZCggZHVyYXRpb24gKS50b0ZyYWN0aW9uKCkgKVxuICAgICAgLy9pZiggcGF0dGVybi52YWx1ZS50eXBlID09PSAnZ3JvdXAnICkge1xuICAgICAgLy8gIGV2ZW50cyA9IGV2ZW50cy5tYXAoIGV2dCA9PiB7XG4gICAgICAvLyAgICBldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5tdWwoIHNwZWVkIClcbiAgICAgIC8vICAgIGV2dC5hcmMuZW5kICAgPSBldnQuYXJjLmVuZC5tdWwoIHNwZWVkIClcbiAgICAgIC8vICAgIHJldHVybiBldnRcbiAgICAgIC8vICB9KVxuICAgICAgLy99XG4gICAgICAvL2V2ZW50cyA9IGV2ZW50cy5tYXAoIGV2dCA9PiB7XG4gICAgICAvLyAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuYWRkKCBwaGFzZURpZmYgKVxuICAgICAgLy8gIGV2dC5hcmMuZW5kICAgPSBldnQuYXJjLmVuZC5hZGQoIHBoYXNlRGlmZiApXG4gICAgICAvLyAgLy9ldnQuYXJjLnN0YXJ0ID0gZXZ0LmFyYy5zdGFydC5hZGQoIHBoYXNlIClcbiAgICAgIC8vICAvL2V2dC5hcmMuZW5kICAgPSBldnQuYXJjLmVuZC5hZGQoIHBoYXNlIClcbiAgICAgIC8vICByZXR1cm4gZXZ0XG4gICAgICAvL30pXG4gICAgICAvLy5maWx0ZXIoIGV2dCA9PiBldnQuYXJjLnN0YXJ0LnZhbHVlT2YoKSA8IHBoYXNlLmFkZCggZHVyYXRpb24gKS52YWx1ZU9mKCkgKVxuICAgIC8vfVxuICAgIC8vY29uc29sZS5sb2coICdzbG93OicsIGxvZyggZXZlbnRzLCB7IGRlcHRoOjMgfSksIHBoYXNlLmFkZCggZHVyYXRpb24gKS50b0ZyYWN0aW9uKCkgKVxuXG4gICAgaWYoIGV2ZW50cyAhPT0gdW5kZWZpbmVkICkgc3RhdGUgPSBzdGF0ZS5jb25jYXQoIGV2ZW50cyApXG5cbiAgICByZXR1cm4gc3RhdGVcbiAgfSxcblxuLy9jb25zdCBwcm9jZXNzUGF0dGVybiA9ICggcGF0dGVybiwgZHVyYXRpb24sIHBoYXNlLCBwaGFzZUluY3I9bnVsbCwgb3ZlcnJpZGUgPSBudWxsLCBzaG91bGRSZW1hcEFyY3M9dHJ1ZSApID0+IHtcbiAgc3BlZWQoIHN0YXRlLCBwYXR0ZXJuLCBwaGFzZSwgZHVyYXRpb24gKSB7XG4gICAgLy8gdGhlIGdlbmVyYWwgcHJvY2VzcyBvZiBpbmNyZWFzaW5nIHRoZSBzcGVlZCBvZiBhIHBhdHRlcm4gaXMgdG8gcXVlcnlcbiAgICAvLyBmb3IgYSBsb25nZXIgZHVyYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBzcGVlZCwgYW5kIHRoZSBzY2FsZSB0aGUgcmVzdWx0aW5nXG4gICAgLy8gZXZlbnRzLlxuICAgIFxuICAgIC8vIGZvbGxvd2luZyBleHBsYW5hdGlvbiBmcm9tIHlheHUgZm9yIGhvdyBzdWJwYXR0ZXJucyB3b3JrIHdpdGggcmF0ZXMuLi5cbiAgICAvLyBodHRwczovL3RhbGsubHVyay5vcmcvY2hhbm5lbC90aWRhbD9tc2c9ejVjazczSDlFdnhRd01xcTYgXG4gICAgLy8gcmU6IHBhdHRlcm4gYSpbMiA0IDhdXG4gICAgLy8gXCJBbnl3YXkgd2hhdCBoYXBwZW5zIGluIHRoaXMga2luZCBvZiBzaXR1YXRpb24gaXMgdGhhdCBpdCBzcGxpdHMgdGhlIGN5Y2xlIGluIHRocmVlLCBcbiAgICAvLyBlYWNoIGEgd2luZG93IG9uIHdoYXQgd291bGQgaGF2ZSBoYXBwZW5lZCBpZiB5b3UnZCBoYXZlIHNwZWQgdGhpbmdzIHVwIGJ5IHRoZSBnaXZlbiBudW1iZXJcbiAgICAvLyBzbyBmb3IgdGhlIGZpcnN0IHRoaXJkIHlvdSdkIGdldCBhIHRoaXJkIG9mIHR3byBhJ3NcbiAgICAvLyBmb3IgdGhlIHNlY29uZCB0aGlyZCB5b3UnZCBnZXQgdGhlIHNlY29uZCB0aGlyZCBvZiBmb3VyIGEncy4uLlwiXG4gICAgXG4gICAgY29uc3Qgc3BlZWQgPSBwYXR0ZXJuLnJhdGUudmFsdWVcbiAgICBjb25zdCBldmVudHMgPSBxdWVyeUFyYyhcbiAgICAgIHBhdHRlcm4udmFsdWUsXG4gICAgICBGcmFjdGlvbigwKSxcbiAgICAgIGR1cmF0aW9uLm11bCggc3BlZWQgKSBcbiAgICApLm1hcCggZXZ0ID0+IHtcbiAgICAgIGV2dC5hcmMuc3RhcnQgPSBldnQuYXJjLnN0YXJ0LmRpdiggc3BlZWQgKS5hZGQoIHBoYXNlIClcbiAgICAgIGV2dC5hcmMuZW5kICAgPSBldnQuYXJjLmVuZC5kaXYoIHNwZWVkICkuYWRkKCBwaGFzZSApXG4gICAgICByZXR1cm4gZXZ0XG4gICAgfSlcblxuICAgIC8vIFhYWCBhY2NvdW50IGZvciBoYXZpbmcgYSBzcGVlZHMgcGF0dGVybiEhISFcbiAgICAvKlxuICAgIFxuICAgIGNvbnN0IGluY3IgPSBGcmFjdGlvbigxLCBzcGVlZHMubGVuZ3RoKVxuICAgIGNvbnN0IHNwZWVkcyA9IHF1ZXJ5QXJjKCBwYXR0ZXJuLnJhdGUsIEZyYWN0aW9uKDApLCBGcmFjdGlvbigxKSApXG5cbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHNwZWVkcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGxldCBzcGVlZCA9IHNwZWVkc1sgaSBdLnZhbHVlXG5cbiAgICAgIGlmKCBwYXR0ZXJuLm9wZXJhdG9yID09PSAnKicgKSB7XG4gICAgICAgIC8vZXZlbnRzID0gcXVlcnlBcmMoIFxuICAgICAgICAvLyAgcGF0dGVybi52YWx1ZSxcbiAgICAgICAgLy8gIHBoYXNlLmNsb25lKCksIC8vRnJhY3Rpb24oIDAgKSwgXG4gICAgICAgIC8vICBGcmFjdGlvbiggc3BlZWQgKS5tdWwoIGR1cmF0aW9uIClcbiAgICAgICAgLy8pXG4gICAgICAgIGV2ZW50cyA9IHByb2Nlc3NQYXR0ZXJuKFxuICAgICAgICAgIHBhdHRlcm4udmFsdWUsXG4gICAgICAgICAgZHVyYXRpb24ubXVsKCBzcGVlZCApLFxuICAgICAgICAgIHBoYXNlLmNsb25lKCkvL0ZyYWN0aW9uKCBzcGVlZCApLm11bCggZHVyYXRpb24gKVxuICAgICAgICAgIC8vcGhhc2UuY2xvbmUoKSBcbiAgICAgICAgKVxuICAgICAgICAgIFxuICAgICAgICAvLyByZW1hcCBldmVudHMgdG8gY29ycmVjdCB0aW1lIHNwYW5zXG4gICAgICAgIC5tYXAoIGV2dCA9PiB7XG4gICAgICAgICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuZGl2KCBzcGVlZCApLy8uYWRkKCBwaGFzZSApXG4gICAgICAgICAgZXZ0LmFyYy5lbmQgICA9IGV2dC5hcmMuZW5kLmRpdiggc3BlZWQgKS8vLmFkZCggcGhhc2UgKVxuICAgICAgICAgIHJldHVybiBldnRcbiAgICAgICAgfSlcbiAgICAgICAgLy8uZmlsdGVyKCBldnQgPT4gXG4gICAgICAgIC8vICBldnQuYXJjLnN0YXJ0LmNvbXBhcmUoIGluY3IubXVsKCBpICkgKSA+PSAwIFxuICAgICAgICAvLyAgICAmJiBldnQuYXJjLnN0YXJ0LmNvbXBhcmUoIGluY3IubXVsKCBpKzEgKSApIDwgMCBcbiAgICAgICAgLy8pKVxuICAgICAgICAvLyBhZGQgdG8gcHJldmlvdXMgZXZlbnRzXG4gICAgICAgIC5jb25jYXQoIGV2ZW50cyApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgc3BlZWQgPSAxL3NwZWVkXG4gICAgICAgIC8vY29uc29sZS5sb2coICdwaGFzZTonLCBwaGFzZS5tdWwoIHNwZWVkICkgKVxuICAgICAgICBldmVudHMgPSBwcm9jZXNzUGF0dGVybiggXG4gICAgICAgICAgcGF0dGVybi52YWx1ZSwgXG4gICAgICAgICAgZHVyYXRpb24ubXVsKCBGcmFjdGlvbiggc3BlZWQgKSApLCBcbiAgICAgICAgICBwaGFzZS5tdWwoIHNwZWVkICksXG4gICAgICAgICAgZ2V0UGhhc2VJbmNyKCBwYXR0ZXJuICkubXVsKCBzcGVlZCApLCBudWxsLCBmYWxzZVxuICAgICAgICApXG4gICAgICAgIC8vY29uc29sZS5sb2coICdldmVudHM6JywgbG9nKCBldmVudHMsIHsgZGVwdGg6NCB9ICkgKVxuICAgICAgICAvLyByZW1hcCBldmVudHMgdG8gY29ycmVjdCB0aW1lIHNwYW5zXG4gICAgICAgIGV2ZW50cy5tYXAoIGV2dCA9PiB7XG4gICAgICAgICAgaWYoIGV2dC5hcmMuc3RhcnQudmFsdWVPZigpICE9PSAwICkge1xuICAgICAgICAgICAgLy8gWFhYIEkgZG9uJ3Qga25vdyB3aHkgdGhpcyBpcyBuZWNlc3NhcnkgYnV0IGl0IGdldHMgcmlkIG9mIGEgb2ZmLWJ5LW9uZSBlcnJvclxuICAgICAgICAgICAgZXZ0LmFyYy5zdGFydCA9IGV2dC5hcmMuc3RhcnQuc3ViKCBwaGFzZS5kaXYoIDEvc3BlZWQgKSApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWxzbywgZG9lcyB0aGUgZXZlbnQgbGVuZ3RoIG5lZWQgdG8gYmUgYWRqdXN0ZWQ/IG1pZ2h0IGFzIHdlbGwuLi5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCAnZW5kOicsIGV2dC5hcmMuZW5kLnRvRnJhY3Rpb24oKSwgcGhhc2UudG9GcmFjdGlvbigpLCBzcGVlZCApXG4gICAgICAgICAgZXZ0LmFyYy5lbmQgPSBldnQuYXJjLmVuZC5tdWwoIDEvc3BlZWQgKS8vLm11bCggMS9zcGVlZCApXG4gICAgICAgICAgLy9ldnQuYXJjLmVuZC5zdWIoIHBoYXNlLmRpdiggMS9zcGVlZCApICkuYWRkKCAxL3NwZWVkIC0gMSlcblxuICAgICAgICAgIHJldHVybiBldnRcbiAgICAgICAgfSlcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50cyBkb24ndCBmYWxsIGluIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAgICAuZmlsdGVyKCBldnQgPT4gXG4gICAgICAgICAgZXZ0LmFyYy5zdGFydC5jb21wYXJlKCBpbmNyLm11bChpKSApID49IDAgJiYgXG4gICAgICAgICAgZXZ0LmFyYy5zdGFydC5jb21wYXJlKCBpbmNyLm11bChpKzEpICkgPD0gMCBcbiAgICAgICAgKVxuICAgICAgICAvLyBhZGQgdG8gcHJldmlvdXMgZXZlbnRzXG4gICAgICAgIC5jb25jYXQoIGV2ZW50cyApXG4gICAgICB9XG4gICAgfSovXG5cbiAgICAvL2NvbnNvbGUubG9nKCAnZXZlbnRzOicsIGxvZyggZXZlbnRzLCB7IGRlcHRoOjQgfSkgKVxuICAgIHJldHVybiBzdGF0ZS5jb25jYXQoIGV2ZW50cyApXG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzLnF1ZXJ5QXJjID0gcXVlcnlBcmNcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCJjb25zdCBBdWRpbyA9IHJlcXVpcmUoXCJnaWJiZXIuYXVkaW8ubGliXCIpLFxuICBHaWJiZXIgPSByZXF1aXJlKFwiZ2liYmVyLmNvcmUubGliXCIpO1xuY2hyb21hID0gcmVxdWlyZShcImNocm9tYS1qc1wiKTtcbmNvbnN0IHBhbGxldHRlID0gY2hyb21hLmJyZXdlci5TZXQxO1xuY29uc29sZS5sb2coXCJwYWxsZXR0ZTogXCIsIHBhbGxldHRlKTtcblxuLy8gY29uc29sZS5sb2coJ0Nocm9tYTogJywgQ2hyb21hKTtcbmZvciAoY29uc3Qga2V5IGluIEF1ZGlvKSB7XG4gIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChBdWRpbywga2V5KSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBBdWRpb1trZXldO1xuICAgIC8vIGNvbnNvbGUubG9nKCdrZXk6ICcsIGtleSwgKHR5cGVvZiBlbGVtZW50KSk7XG4gIH1cbn1cbmNvbnNvbGUubG9nKFwiQXVkaW86IFwiLCBBdWRpbyk7XG5jb25zdCBpbnN0cnVtZW50cyA9IEF1ZGlvLlByZXNldHMuaW5zdHJ1bWVudHM7XG5jb25zb2xlLmxvZyhcImluc3RydW1lbnRzOiBcIiwgaW5zdHJ1bWVudHMpO1xubGV0IGNvdW50ZXIgPSAtMTtcbmNvbnN0IGRlc2NyaXB0aW9uc0Rpc3BsYXlzID0gW107XG5mb3IgKGNvbnN0IG5hbWUgaW4gaW5zdHJ1bWVudHMpIHtcbiAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluc3RydW1lbnRzLCBuYW1lKSkge1xuICAgIGNvdW50ZXIrKztcbiAgICBjb25zdCBpbnN0cnVtZW50VHlwZXMgPSBpbnN0cnVtZW50c1tuYW1lXTtcbiAgICAvLyBjb25zb2xlLmxvZygna2V5OiAnLCBrZXkpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBPYmplY3Qua2V5cyhlbGVtZW50KSk7XG4gICAgY29uc3QgaW5zdHJ1bWVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaW5zdHJ1bWVudERpdi5jbGFzc05hbWUgPSBcImluc3RydW1lbnRcIjtcbiAgICBjb25zdCBpbnN0cnVtZW50TmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoM1wiKTtcbiAgICBpbnN0cnVtZW50TmFtZS5jbGFzc05hbWUgPSBcImluc3RydW1lbnQtbmFtZVwiO1xuICAgIGluc3RydW1lbnROYW1lLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBpbnN0cnVtZW50RGVzY3JpcHRpb24uaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIGNsYWVyQWxsRGVzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICBpbnN0cnVtZW50TmFtZS5pbm5lckhUTUwgPSBuYW1lICsgXCItLS1cIjtcbiAgICBpbnN0cnVtZW50RGl2LmFwcGVuZENoaWxkKGluc3RydW1lbnROYW1lKTtcbiAgICBjb25zdCBpbnN0cnVtZW50RGVzY3JpcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDNcIik7XG4gICAgaW5zdHJ1bWVudERpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjaHJvbWEoXG4gICAgICBwYWxsZXR0ZVtjb3VudGVyICUgcGFsbGV0dGUubGVuZ3RoXVxuICAgIClcbiAgICAgIC5kYXJrZW4oMilcbiAgICAgIC5oZXgoKTtcbiAgICBjb25zdCBpbnN0cnVtZW50S2V5cyA9IE9iamVjdC5rZXlzKGluc3RydW1lbnRUeXBlcyk7XG4gICAgLy8gaWYoZmFsc2UpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydW1lbnRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBpbnN0cnVtZW50S2V5c1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBpbnN0cnVtZW50VHlwZXNba2V5XTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdwcm9wZXJ0aWVzOiAnLCBwcm9wZXJ0aWVzKTtcbiAgICAgIGNvbnN0IHBhcmFtRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBwYXJhbURpdi5jbGFzc05hbWUgPSBcInBhcmFtXCI7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHBhcmFtTmFtZS5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBjb25zb2xlLmxvZyhcImtleTogXCIsIG5hbWUsIFwiIC0gXCIsIGtleSk7XG4gICAgICBwYXJhbURpdi5hcHBlbmRDaGlsZChwYXJhbU5hbWUpO1xuICAgICAgcGFyYW1EaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgY2xhZXJBbGxEZXNjcmlwdGlvbnMoKTtcbiAgICAgICAgY29uc29sZS5sb2coa2V5LCBcIlwiLCBuYW1lKTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGluc3RydW1lbnRzW25hbWVdW2tleV07XG4gICAgICAgIGNvbnNvbGUubG9nKFwicHJvcGVydGllczogXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcm9wZXJ0eTogXCIsIHByb3BlcnR5LCB0eXBlb2YgZWxlbWVudCk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gYCR7cHJvcGVydHl9OiAke2VsZW1lbnR9PGJyPmA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3RydW1lbnREZXNjcmlwdGlvbi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgLy8gcGFyYW1WYWx1ZS5pbm5lckhUTUwgPSBwcm9wZXJ0aWVzO1xuICAgICAgLy8gaWYoZmFsc2UpXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Byb3BlcnR5OiAnLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZhbHVlOiAnLCB2YWx1ZSk7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHByb3BlcnR5RGl2LmNsYXNzTmFtZSA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUuaW5uZXJIVE1MID0gcHJvcGVydHkgKyBcIi5cIjtcbiAgICAgICAgICBwcm9wZXJ0eURpdi5hcHBlbmRDaGlsZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICBwcm9wZXJ0eVZhbHVlLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgIHByb3BlcnR5RGl2LmFwcGVuZENoaWxkKHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgIHBhcmFtRGl2LmFwcGVuZENoaWxkKHByb3BlcnR5RGl2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyYW1EaXYuYXBwZW5kQ2hpbGQocGFyYW1WYWx1ZSk7XG4gICAgICBpbnN0cnVtZW50RGl2LmFwcGVuZENoaWxkKHBhcmFtRGl2KTtcbiAgICB9XG4gICAgaW5zdHJ1bWVudERpdi5hcHBlbmRDaGlsZChpbnN0cnVtZW50RGVzY3JpcHRpb24pO1xuICAgIGRlc2NyaXB0aW9uc0Rpc3BsYXlzLnB1c2goaW5zdHJ1bWVudERlc2NyaXB0aW9uKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluc3RydW1lbnREaXYpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdpbnN0cnVtZW50RGl2OiAnLCBpbnN0cnVtZW50RGl2KTtcbiAgfVxufVxuY29uc3QgY2xhZXJBbGxEZXNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gIGRlc2NyaXB0aW9uc0Rpc3BsYXlzLmZvckVhY2goKGRpc3BsYXkpID0+IHtcbiAgICBkaXNwbGF5LmlubmVySFRNTCA9IFwiXCI7XG4gIH0pO1xufTtcbi8qXG4vLyAgIHdpbmRvdy5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgQXVkaW8uaW5pdCh7d29ya2xldFBhdGg6Jy4vb3V0L2dpYmJlcmlzaF93b3JrbGV0LmpzJ30sR2liYmVyKS50aGVuKCAoKSA9PiB7XG5cbiAgICAgIGNvbnN0IHN5biA9IFN5bnRoKClcbiAgICAgIHN5bi5ub3RlLnNlcSggWzAsMV0sIDEvNCApXG5cbiAgICAgIHdpbmRvdy5vbmNsaWNrID0gbnVsbFxuICAgIH0pXG4vLyAgIH1cbiovXG4iXX0=